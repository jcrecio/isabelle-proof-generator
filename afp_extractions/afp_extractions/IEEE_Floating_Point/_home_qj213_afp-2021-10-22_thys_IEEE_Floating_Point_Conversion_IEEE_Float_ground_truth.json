{"file_name": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point/Conversion_IEEE_Float.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point", "problem_names": ["lemma float_val_of_finite: \"is_finite x \\<Longrightarrow> of_finite x = valof x\"", "lemmas is_denormal_FloatD =\n  is_denormal_Float_def[THEN iffD1, THEN conjunct1]\n  is_denormal_Float_def[THEN iffD1, THEN conjunct2]", "lemma is_finite_Float_eq:\n  \"is_finite_Float TYPE(('e, 'f)float) f \\<longleftrightarrow>\n    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))\n    in bm \\<le> Suc LENGTH('f) \\<and>\n     bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n     1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)\"", "lemma sign_normal_of_Float:\"sign (normal_of_Float x) = (if x > 0 then 0 else 1)\"", "lemma uints_bitlen_eq: \"uints n = {i. 0 \\<le> i \\<and> bitlen i \\<le> n}\"", "lemma uint_word_of_int_bitlen_eq:\n  \"uint (word_of_int x::'a::len word) = x\" if \"bitlen x \\<le> LENGTH('a)\" \"x \\<ge> 0\"", "lemma fraction_normal_of_Float:\"fraction (normal_of_Float x::('e, 'f)float) =\n  (nat \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) - 2 ^ LENGTH('f))\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\"", "lemma exponent_normal_of_Float:\"exponent (normal_of_Float x::('e, 'f)float) =\n  nat (Float.exponent x + (bias TYPE(('e, 'f)float)) + bitlen \\<bar>mantissa x\\<bar> - 1)\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\"", "lemma sign_denormal_of_Float:\"sign (denormal_of_Float x) = (if x \\<ge> 0 then 0 else 1)\"", "lemma exponent_denormal_of_Float:\"exponent (denormal_of_Float x::('e, 'f)float) = 0\"", "lemma fraction_denormal_of_Float:\"fraction (denormal_of_Float x::('e, 'f)float) =\n  (nat \\<bar>mantissa x\\<bar> * 2 ^ nat (Float.exponent x + bias TYPE(('e, 'f)float) + LENGTH('f) - 1))\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\"", "lemma valof_normal_of_Float: \"valof (normal_of_Float x::('e, 'f)float) = x\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\"", "lemma valof_denormal_of_Float: \"valof (denormal_of_Float x::('e, 'f)float) = x\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\"", "lemma valof_of_finite_Float:\n  \"is_finite_Float (TYPE(('e, 'f) IEEE.float)) x \\<Longrightarrow> valof (of_finite_Float x::('e, 'f)float) = x\"", "lemma is_normal_normal_of_Float:\n  \"is_normal (normal_of_Float x::('e, 'f)float)\" if \"is_normal_Float TYPE(('e, 'f)float) x\"", "lemma is_denormal_denormal_of_Float: \"is_denormal (denormal_of_Float x::('e, 'f)float)\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\"", "lemma is_finite_of_finite_Float: \"is_finite (of_finite_Float x)\"", "lemma Float_eq_zero_iff: \"Float m e = 0 \\<longleftrightarrow> m = 0\"", "lemma bitlen_mantissa_Float:\n  shows \"bitlen \\<bar>mantissa (Float m e)\\<bar> = (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) - Float.exponent (Float m e)\"", "lemma exponent_Float:\n  shows \"Float.exponent (Float m e) = (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) - bitlen \\<bar>mantissa (Float m e)\\<bar> \"", "lemma is_normal_Float_normal:\n  \"is_normal_Float TYPE(('e, 'f)float) (Float (normal_mantissa x) (normal_exponent x))\"\n  if \"is_normal x\" for x::\"('e, 'f)float\"", "lemma is_denormal_Float_denormal:\n  \"is_denormal_Float TYPE(('e, 'f)float)\n    (Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float)))\"\n  if \"is_denormal x\" for x::\"('e, 'f)float\"", "lemma is_finite_Float_of_finite: \"is_finite_Float TYPE(('e, 'f)float) (of_finite x)\" for x::\"('e, 'f)float\""], "translations": [["", "lemma float_val_of_finite: \"is_finite x \\<Longrightarrow> of_finite x = valof x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite x \\<Longrightarrow> real_of_float (of_finite x) = valof x", "by (induction x) (auto simp: normal_imp_not_denormal of_finite_def)"], ["", "definition is_normal_Float::\"('e, 'f)float itself \\<Rightarrow> Float.float \\<Rightarrow> bool\" where\n  \"is_normal_Float x f \\<longleftrightarrow>\n    mantissa f \\<noteq> 0 \\<and>\n    bitlen \\<bar>mantissa f\\<bar> \\<le> fracwidth x + 1 \\<and>\n    - int (bias x) - bitlen \\<bar>mantissa f\\<bar> + 1 < Float.exponent f \\<and>\n    Float.exponent f < 2^(LENGTH('e)) - bitlen \\<bar>mantissa f\\<bar> - bias x\""], ["", "definition is_denormal_Float::\"('e, 'f)float itself \\<Rightarrow> Float.float \\<Rightarrow> bool\" where\n  \"is_denormal_Float x f \\<longleftrightarrow>\n    mantissa f \\<noteq> 0 \\<and>\n    bitlen \\<bar>mantissa f\\<bar> \\<le> 1 - Float.exponent f - int (bias x) \\<and>\n    1 - 2^(LENGTH('e) - 1) - int LENGTH('f) < Float.exponent f\""], ["", "lemmas is_denormal_FloatD =\n  is_denormal_Float_def[THEN iffD1, THEN conjunct1]\n  is_denormal_Float_def[THEN iffD1, THEN conjunct2]"], ["", "definition is_finite_Float::\"('e, 'f)float itself \\<Rightarrow> Float.float \\<Rightarrow> bool\" where\n  \"is_finite_Float x f \\<longleftrightarrow> is_normal_Float x f \\<or> is_denormal_Float x f \\<or> f = 0\""], ["", "lemma is_finite_Float_eq:\n  \"is_finite_Float TYPE(('e, 'f)float) f \\<longleftrightarrow>\n    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))\n    in bm \\<le> Suc LENGTH('f) \\<and>\n     bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n     1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "have *: \"(2::int) ^ (LENGTH('e) - Suc 0) - 1 < 2 ^ LENGTH('e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('e) - Suc 0) - 1 < 2 ^ LENGTH('e)", "by (metis Suc_1 diff_le_self lessI linorder_not_less one_less_numeral_iff\n        power_strict_increasing_iff zle_diff1_eq)"], ["proof (state)\nthis:\n  2 ^ (LENGTH('e) - Suc 0) - 1 < 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "have **: \"1 - 2 ^ (LENGTH('e) - Suc 0) < int LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - 2 ^ (LENGTH('e) - Suc 0) < int LENGTH('f)", "by (smt len_gt_0 of_nat_0_less_iff zero_less_power)"], ["proof (state)\nthis:\n  1 - 2 ^ (LENGTH('e) - Suc 0) < int LENGTH('f)\n\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "have ***: \"2 ^ (LENGTH('e) - 1) + 1 =\n    2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('e) - 1) + 1 =\n    2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float))", "by (simp add: bias_def power_Suc[symmetric] of_nat_diff)"], ["proof (state)\nthis:\n  2 ^ (LENGTH('e) - 1) + 1 =\n  2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "have rewr: \"x \\<le> 2 ^ n - e \\<longleftrightarrow> x + e < 2 ^ n + 1\" for x::int and n e"], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> 2 ^ n - e) = (x + e < 2 ^ n + 1)", "by auto"], ["proof (state)\nthis:\n  (?x \\<le> 2 ^ ?n - ?e) = (?x + ?e < 2 ^ ?n + 1)\n\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "unfolding *** rewr"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm + e\n        < 2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float)) \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "using * **"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) - 1 < 2 ^ LENGTH('e)\n  1 - 2 ^ (LENGTH('e) - Suc 0) < int LENGTH('f)\n\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm + e\n        < 2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float)) \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "unfolding is_finite_Float_def is_normal_Float_def is_denormal_Float_def"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) - 1 < 2 ^ LENGTH('e)\n  1 - 2 ^ (LENGTH('e) - Suc 0) < int LENGTH('f)\n\ngoal (1 subgoal):\n 1. (mantissa f \\<noteq> 0 \\<and>\n     bitlen \\<bar>mantissa f\\<bar> \\<le> int (LENGTH('f) + 1) \\<and>\n     - int (bias TYPE(('e, 'f) IEEE.float)) -\n     bitlen \\<bar>mantissa f\\<bar> +\n     1\n     < Float.exponent f \\<and>\n     Float.exponent f\n     < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n       int (bias TYPE(('e, 'f) IEEE.float)) \\<or>\n     mantissa f \\<noteq> 0 \\<and>\n     bitlen \\<bar>mantissa f\\<bar>\n     \\<le> 1 - Float.exponent f -\n           int (bias TYPE(('e, 'f) IEEE.float)) \\<and>\n     1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < Float.exponent f \\<or>\n     f = 0) =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH('f)) \\<and>\n        bm + e\n        < 2 ^ LENGTH('e) - int (bias TYPE(('e, 'f) IEEE.float)) \\<and>\n        1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)", "by (auto simp: Let_def bias_def mantissa_eq_zero_iff of_nat_diff\n        intro: le_less_trans[OF add_right_mono])"], ["proof (state)\nthis:\n  is_finite_Float TYPE(('e, 'f) IEEE.float) f =\n  (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n   in bm \\<le> int (Suc LENGTH('f)) \\<and>\n      bm \\<le> 2 ^ (LENGTH('e) - 1) - e \\<and>\n      1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition normal_of_Float :: \"Float.float \\<Rightarrow> ('e, 'f)float\"\n  is \"\\<lambda>x. let m = mantissa x; e = Float.exponent x in\n    (if m > 0 then 0 else 1,\n      word_of_int (e + int (bias TYPE(('e, 'f)float)) + bitlen \\<bar>m\\<bar> - 1),\n      word_of_int (\\<bar>m\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>m\\<bar>)) - 2 ^ (LENGTH('f))))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sign_normal_of_Float:\"sign (normal_of_Float x) = (if x > 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (normal_of_Float x) = (if 0 < x then 0 else 1)", "by transfer (auto simp: Let_def mantissa_pos_iff)"], ["", "lemma uints_bitlen_eq: \"uints n = {i. 0 \\<le> i \\<and> bitlen i \\<le> n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uints n = {i. 0 \\<le> i \\<and> bitlen i \\<le> int n}", "by (auto simp: uints_num bitlen_le_iff_power)"], ["", "lemma uint_word_of_int_bitlen_eq:\n  \"uint (word_of_int x::'a::len word) = x\" if \"bitlen x \\<le> LENGTH('a)\" \"x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. uint (word_of_int x) = x", "by (subst word_uint.Abs_inverse) (simp_all add: uints_bitlen_eq that)"], ["", "lemma fraction_normal_of_Float:\"fraction (normal_of_Float x::('e, 'f)float) =\n  (nat \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) - 2 ^ LENGTH('f))\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "from that"], ["proof (chain)\npicking this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x", "have bmp: \"bitlen \\<bar>mantissa x\\<bar> > 0\""], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. 0 < bitlen \\<bar>mantissa x\\<bar>", "by (metis abs_of_nonneg bitlen_bounds bitlen_def is_normal_Float_def nat_code(2) of_nat_0_le_iff\n        power.simps(1) zabs_less_one_iff zero_less_abs_iff)"], ["proof (state)\nthis:\n  0 < bitlen \\<bar>mantissa x\\<bar>\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "have mless: \"\\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)", "using bitlen_bounds"], ["proof (prove)\nusing this:\n  0 < ?x \\<Longrightarrow>\n  2 ^ nat (bitlen ?x - 1) \\<le> ?x \\<and> ?x < 2 ^ nat (bitlen ?x)\n\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)", "by force"], ["proof (state)\nthis:\n  \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "have lem: \"2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) \\<le> \\<bar>mantissa x\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) \\<le> \\<bar>mantissa x\\<bar>", "using bitlen_bounds is_normal_Float_def that zero_less_abs_iff"], ["proof (prove)\nusing this:\n  0 < ?x \\<Longrightarrow>\n  2 ^ nat (bitlen ?x - 1) \\<le> ?x \\<and> ?x < 2 ^ nat (bitlen ?x)\n  is_normal_Float ?x ?f =\n  (mantissa ?f \\<noteq> 0 \\<and>\n   bitlen \\<bar>mantissa ?f\\<bar> \\<le> int (LENGTH(?'f) + 1) \\<and>\n   - int (bias ?x) - bitlen \\<bar>mantissa ?f\\<bar> + 1\n   < Float.exponent ?f \\<and>\n   Float.exponent ?f\n   < 2 ^ LENGTH(?'e) - bitlen \\<bar>mantissa ?f\\<bar> - int (bias ?x))\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n  ((0::?'a) < \\<bar>?a\\<bar>) = (?a \\<noteq> (0::?'a))\n\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) \\<le> \\<bar>mantissa x\\<bar>", "by blast"], ["proof (state)\nthis:\n  2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) \\<le> \\<bar>mantissa x\\<bar>\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "from that"], ["proof (chain)\npicking this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x", "have nble: \"nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)\""], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)", "using bitlen_bounds"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n  0 < ?x \\<Longrightarrow>\n  2 ^ nat (bitlen ?x - 1) \\<le> ?x \\<and> ?x < 2 ^ nat (bitlen ?x)\n\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)", "by (auto simp: is_normal_Float_def)"], ["proof (state)\nthis:\n  nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "have nn: \"0 \\<le> \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) - 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> \\<bar>mantissa x\\<bar> *\n            2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n            2 ^ LENGTH('f)", "apply (rule add_le_imp_le_diff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 2 ^ LENGTH('f)\n    \\<le> \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "apply (rule order_trans[rotated])"], ["proof (prove)\ngoal (2 subgoals):\n 1. ?y2\n    \\<le> \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n 2. 0 + 2 ^ LENGTH('f) \\<le> ?y2", "apply (rule mult_right_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. ?a5 \\<le> \\<bar>mantissa x\\<bar>\n 2. 0 \\<le> 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n 3. 0 + 2 ^ LENGTH('f)\n    \\<le> ?a5 * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "apply (rule lem, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 2 ^ LENGTH('f)\n    \\<le> 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "unfolding power_add[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + 2 ^ LENGTH('f)\n    \\<le> 2 ^\n          (nat (bitlen \\<bar>mantissa x\\<bar> - 1) +\n           (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)))", "using nble bmp"], ["proof (prove)\nusing this:\n  nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)\n  0 < bitlen \\<bar>mantissa x\\<bar>\n\ngoal (1 subgoal):\n 1. 0 + 2 ^ LENGTH('f)\n    \\<le> 2 ^\n          (nat (bitlen \\<bar>mantissa x\\<bar> - 1) +\n           (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)))", "by (auto)"], ["proof (state)\nthis:\n  0 \\<le> \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n          2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "have \"\\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) < 2 * 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    < 2 * 2 ^ LENGTH('f)", "apply (rule less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    < ?y\n 2. ?y \\<le> 2 * 2 ^ LENGTH('f)", "apply (rule mult_strict_right_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<bar>mantissa x\\<bar> < ?b3\n 2. 0 < 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n 3. ?b3 * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> 2 * 2 ^ LENGTH('f)", "apply (rule mless)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 0 < 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n 2. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>) *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> 2 * 2 ^ LENGTH('f)", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>) *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> 2 * 2 ^ LENGTH('f)", "unfolding power_add[symmetric] power_Suc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^\n    (nat (bitlen \\<bar>mantissa x\\<bar>) +\n     (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)))\n    \\<le> 2 ^ Suc LENGTH('f)", "apply (rule power_increasing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> Suc LENGTH('f)\n 2. 1 \\<le> 2", "using nble"], ["proof (prove)\nusing this:\n  nat (bitlen \\<bar>mantissa x\\<bar>) \\<le> Suc LENGTH('f)\n\ngoal (2 subgoals):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> Suc LENGTH('f)\n 2. 1 \\<le> 2", "by auto"], ["proof (state)\nthis:\n  \\<bar>mantissa x\\<bar> *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n  < 2 * 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "then"], ["proof (chain)\npicking this:\n  \\<bar>mantissa x\\<bar> *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n  < 2 * 2 ^ LENGTH('f)", "have \"bitlen (\\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) - 2 ^ LENGTH('f))\n    \\<le> int LENGTH('f)\""], ["proof (prove)\nusing this:\n  \\<bar>mantissa x\\<bar> *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n  < 2 * 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen\n     (\\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f))\n    \\<le> int LENGTH('f)", "unfolding bitlen_le_iff_power"], ["proof (prove)\nusing this:\n  \\<bar>mantissa x\\<bar> *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n  < 2 * 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. 0 \\<le> int LENGTH('f) \\<and>\n    \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)\n    < 2 ^ nat (int LENGTH('f))", "by simp"], ["proof (state)\nthis:\n  bitlen\n   (\\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f))\n  \\<le> int LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "then"], ["proof (chain)\npicking this:\n  bitlen\n   (\\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f))\n  \\<le> int LENGTH('f)", "show ?thesis"], ["proof (prove)\nusing this:\n  bitlen\n   (\\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f))\n  \\<le> int LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (normal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "apply (transfer fixing: x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen\n     (\\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f))\n    \\<le> int LENGTH('f) \\<Longrightarrow>\n    (case let m = mantissa x; e = Float.exponent x\n          in (if 0 < m then 0 else 1,\n              word_of_int\n               (e + int (bias TYPE(('e, 'f) IEEE.float)) +\n                bitlen \\<bar>m\\<bar> -\n                1),\n              word_of_int\n               (\\<bar>m\\<bar> *\n                2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>m\\<bar>)) -\n                2 ^ LENGTH('f))) of\n     (uu_, uua_, xa) \\<Rightarrow> unat xa) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "unfolding Let_def split_beta' fst_conv snd_conv uint_nat [symmetric] nat_uint_eq [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen\n     (\\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f))\n    \\<le> int LENGTH('f) \\<Longrightarrow>\n    nat (uint\n          (word_of_int\n            (\\<bar>mantissa x\\<bar> *\n             2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n             2 ^ LENGTH('f)))) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "using nn"], ["proof (prove)\nusing this:\n  0 \\<le> \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n          2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen\n     (\\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f))\n    \\<le> int LENGTH('f) \\<Longrightarrow>\n    nat (uint\n          (word_of_int\n            (\\<bar>mantissa x\\<bar> *\n             2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n             2 ^ LENGTH('f)))) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n    2 ^ LENGTH('f)", "apply (subst uint_word_of_int_bitlen_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>bitlen\n              (\\<bar>mantissa x\\<bar> *\n               2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n               2 ^ LENGTH('f))\n             \\<le> int LENGTH('f);\n     0 \\<le> \\<bar>mantissa x\\<bar> *\n             2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n             2 ^ LENGTH('f)\\<rbrakk>\n    \\<Longrightarrow> bitlen\n                       (\\<bar>mantissa x\\<bar> *\n                        2 ^\n                        (Suc LENGTH('f) -\n                         nat (bitlen \\<bar>mantissa x\\<bar>)) -\n                        2 ^ LENGTH('f))\n                      \\<le> int LENGTH('f)\n 2. \\<lbrakk>bitlen\n              (\\<bar>mantissa x\\<bar> *\n               2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n               2 ^ LENGTH('f))\n             \\<le> int LENGTH('f);\n     0 \\<le> \\<bar>mantissa x\\<bar> *\n             2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n             2 ^ LENGTH('f)\\<rbrakk>\n    \\<Longrightarrow> 0 \\<le> \\<bar>mantissa x\\<bar> *\n                              2 ^\n                              (Suc LENGTH('f) -\n                               nat (bitlen \\<bar>mantissa x\\<bar>)) -\n                              2 ^ LENGTH('f)\n 3. \\<lbrakk>bitlen\n              (\\<bar>mantissa x\\<bar> *\n               2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n               2 ^ LENGTH('f))\n             \\<le> int LENGTH('f);\n     0 \\<le> \\<bar>mantissa x\\<bar> *\n             2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n             2 ^ LENGTH('f)\\<rbrakk>\n    \\<Longrightarrow> nat (\\<bar>mantissa x\\<bar> *\n                           2 ^\n                           (Suc LENGTH('f) -\n                            nat (bitlen \\<bar>mantissa x\\<bar>)) -\n                           2 ^ LENGTH('f)) =\n                      nat \\<bar>mantissa x\\<bar> *\n                      2 ^\n                      (Suc LENGTH('f) -\n                       nat (bitlen \\<bar>mantissa x\\<bar>)) -\n                      2 ^ LENGTH('f)", "apply (auto simp: nat_mult_distrib nat_diff_distrib nat_power_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fraction (normal_of_Float x) =\n  nat \\<bar>mantissa x\\<bar> *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n  2 ^ LENGTH('f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exponent_normal_of_Float:\"exponent (normal_of_Float x::('e, 'f)float) =\n  nat (Float.exponent x + (bias TYPE(('e, 'f)float)) + bitlen \\<bar>mantissa x\\<bar> - 1)\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (normal_of_Float x) =\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         bitlen \\<bar>mantissa x\\<bar> -\n         1)", "using that"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. IEEE.exponent (normal_of_Float x) =\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         bitlen \\<bar>mantissa x\\<bar> -\n         1)", "apply (transfer fixing: x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float) x \\<Longrightarrow>\n    (case let m = mantissa x; e = Float.exponent x\n          in (if 0 < m then 0 else 1,\n              word_of_int\n               (e + int (bias TYPE(('e, 'f) IEEE.float)) +\n                bitlen \\<bar>m\\<bar> -\n                1),\n              word_of_int\n               (\\<bar>m\\<bar> *\n                2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>m\\<bar>)) -\n                2 ^ LENGTH('f))) of\n     (uu_, e, uua_) \\<Rightarrow> unat e) =\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         bitlen \\<bar>mantissa x\\<bar> -\n         1)", "apply (simp flip: uint_nat nat_uint_eq add: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float) x \\<Longrightarrow>\n    nat (uint\n          (word_of_int (Float.exponent x) +\n           word_of_nat (bias TYPE(('e, 'f) IEEE.float)) +\n           word_of_int (bitlen \\<bar>mantissa x\\<bar>) -\n           1)) =\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         bitlen \\<bar>mantissa x\\<bar> -\n         1)", "apply (auto simp: is_normal_Float_def bitlen_le_iff_power uint_word_of_int_bitlen_eq Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mantissa x \\<noteq> 0;\n     \\<bar>mantissa x\\<bar> < 2 ^ nat (1 + int LENGTH('f));\n     - int (bias TYPE(('e, 'f) IEEE.float)) -\n     bitlen \\<bar>mantissa x\\<bar> +\n     1\n     < Float.exponent x;\n     Float.exponent x\n     < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa x\\<bar> -\n       int (bias TYPE(('e, 'f) IEEE.float))\\<rbrakk>\n    \\<Longrightarrow> unat\n                       (word_of_int (Float.exponent x) +\n                        word_of_nat (bias TYPE(('e, 'f) IEEE.float)) +\n                        word_of_int (bitlen \\<bar>mantissa x\\<bar>) -\n                        1) =\n                      nat (Float.exponent x +\n                           int (bias TYPE(('e, 'f) IEEE.float)) +\n                           bitlen \\<bar>mantissa x\\<bar> -\n                           1)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>mantissa x \\<noteq> 0;\n        \\<bar>mantissa x\\<bar> < 2 ^ nat (1 + int LENGTH('f));\n        - int (bias TYPE(('e, 'f) IEEE.float)) -\n        bitlen \\<bar>mantissa x\\<bar> +\n        1\n        < Float.exponent x;\n        Float.exponent x\n        < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa x\\<bar> -\n          int (bias TYPE(('e, 'f) IEEE.float))\\<rbrakk>\n       \\<Longrightarrow> (nat \\<circ> take_bit LENGTH('e))\n                          (Float.exponent x +\n                           int (bias TYPE(('e, 'f) IEEE.float)) +\n                           bitlen \\<bar>mantissa x\\<bar> -\n                           1) =\n                         nat (Float.exponent x +\n                              int (bias TYPE(('e, 'f) IEEE.float)) +\n                              bitlen \\<bar>mantissa x\\<bar> -\n                              1)", "apply (simp add: nat_take_bit_eq take_bit_int_eq_self)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lift_definition denormal_of_Float :: \"Float.float \\<Rightarrow> ('e, 'f)float\"\n  is \"\\<lambda>x. let m = mantissa x; e = Float.exponent x in\n  (if m \\<ge> 0 then 0 else 1, 0,\n    word_of_int (\\<bar>m\\<bar> * 2 ^ nat (e + bias TYPE(('e, 'f)float) + fracwidth TYPE(('e, 'f)float) - 1)))\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sign_denormal_of_Float:\"sign (denormal_of_Float x) = (if x \\<ge> 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (denormal_of_Float x) = (if 0 \\<le> x then 0 else 1)", "by transfer (auto simp: Let_def mantissa_nonneg_iff)"], ["", "lemma exponent_denormal_of_Float:\"exponent (denormal_of_Float x::('e, 'f)float) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (denormal_of_Float x) = 0", "by (transfer fixing: x) (auto simp: Let_def)"], ["", "lemma fraction_denormal_of_Float:\"fraction (denormal_of_Float x::('e, 'f)float) =\n  (nat \\<bar>mantissa x\\<bar> * 2 ^ nat (Float.exponent x + bias TYPE(('e, 'f)float) + LENGTH('f) - 1))\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "have mless: \"\\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)", "using bitlen_bounds"], ["proof (prove)\nusing this:\n  0 < ?x \\<Longrightarrow>\n  2 ^ nat (bitlen ?x - 1) \\<le> ?x \\<and> ?x < 2 ^ nat (bitlen ?x)\n\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)", "by force"], ["proof (state)\nthis:\n  \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)\n\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "have *: \"nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)\n    \\<le> LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)\n    \\<le> LENGTH('f)", "using that"], ["proof (prove)\nusing this:\n  is_denormal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)\n    \\<le> LENGTH('f)", "by (auto simp: is_denormal_Float_def nat_diff_distrib' le_diff_conv\n        bitlen_nonneg nat_le_iff bias_def nat_add_distrib[symmetric] of_nat_diff)"], ["proof (state)\nthis:\n  nat (bitlen \\<bar>mantissa x\\<bar>) +\n  nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)\n  \\<le> LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "have \"\\<bar>mantissa x\\<bar> *  2 ^ nat (Float.exponent x + int (bias TYPE(('e, 'f)float)) +\n    LENGTH('f) - 1) < 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    < 2 ^ LENGTH('f)", "apply (rule less_le_trans)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    < ?y\n 2. ?y \\<le> 2 ^ LENGTH('f)", "apply (rule mult_strict_right_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<bar>mantissa x\\<bar> < ?b3\n 2. 0 < 2 ^\n        nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n             int LENGTH('f) -\n             1)\n 3. ?b3 *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    \\<le> 2 ^ LENGTH('f)", "apply (rule mless, force)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>) *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    \\<le> 2 ^ LENGTH('f)", "unfolding power_add[symmetric] power_Suc[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^\n    (nat (bitlen \\<bar>mantissa x\\<bar>) +\n     nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n          int LENGTH('f) -\n          1))\n    \\<le> 2 ^ LENGTH('f)", "apply (rule power_increasing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    \\<le> LENGTH('f)\n 2. 1 \\<le> 2", "apply (auto simp: bias_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + int (2 ^ (LENGTH('e) - Suc 0) - Suc 0) +\n         int LENGTH('f) -\n         1)\n    \\<le> LENGTH('f)", "using that *"], ["proof (prove)\nusing this:\n  is_denormal_Float TYPE(('e, 'f) IEEE.float) x\n  nat (bitlen \\<bar>mantissa x\\<bar>) +\n  nat (Float.exponent x + (2 ^ (LENGTH('e) - Suc 0) + int LENGTH('f)) - 2)\n  \\<le> LENGTH('f)\n\ngoal (1 subgoal):\n 1. nat (bitlen \\<bar>mantissa x\\<bar>) +\n    nat (Float.exponent x + int (2 ^ (LENGTH('e) - Suc 0) - Suc 0) +\n         int LENGTH('f) -\n         1)\n    \\<le> LENGTH('f)", "by (auto simp: is_denormal_Float_def algebra_simps of_nat_diff)"], ["proof (state)\nthis:\n  \\<bar>mantissa x\\<bar> *\n  2 ^\n  nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n       int LENGTH('f) -\n       1)\n  < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "then"], ["proof (chain)\npicking this:\n  \\<bar>mantissa x\\<bar> *\n  2 ^\n  nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n       int LENGTH('f) -\n       1)\n  < 2 ^ LENGTH('f)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>mantissa x\\<bar> *\n  2 ^\n  nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n       int LENGTH('f) -\n       1)\n  < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. fraction (denormal_of_Float x) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "apply (transfer fixing: x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)\n    < 2 ^ LENGTH('f) \\<Longrightarrow>\n    (case let m = mantissa x; e = Float.exponent x\n          in (if 0 \\<le> m then 0 else 1, 0,\n              word_of_int\n               (\\<bar>m\\<bar> *\n                2 ^\n                nat (e + int (bias TYPE(('e, 'f) IEEE.float)) +\n                     int LENGTH('f) -\n                     1))) of\n     (uu_, uua_, xa) \\<Rightarrow> unat xa) =\n    nat \\<bar>mantissa x\\<bar> *\n    2 ^\n    nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<bar>mantissa x\\<bar> *\n       2 ^\n       nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n            int LENGTH('f) -\n            1)\n       < 2 ^ LENGTH('f) \\<Longrightarrow>\n       (case let m = mantissa x; e = Float.exponent x\n             in (if 0 \\<le> m then 0 else 1, 0,\n                 \\<bar>m\\<bar> *\n                 2 ^\n                 nat (e + int (bias TYPE(('e, 'f) IEEE.float)) +\n                      int LENGTH('f) -\n                      1)) of\n        (uu_, uua_, xa) \\<Rightarrow>\n          (nat \\<circ> take_bit LENGTH('f)) xa) =\n       nat \\<bar>mantissa x\\<bar> *\n       2 ^\n       nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n            int LENGTH('f) -\n            1)", "apply (simp add: Let_def nat_eq_iff take_bit_eq_mod)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fraction (denormal_of_Float x) =\n  nat \\<bar>mantissa x\\<bar> *\n  2 ^\n  nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n       int LENGTH('f) -\n       1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition of_finite_Float :: \"Float.float \\<Rightarrow> ('e, 'f) float\" where\n  \"of_finite_Float x = (if is_normal_Float TYPE(('e, 'f)float) x then normal_of_Float x\n    else if is_denormal_Float TYPE(('e, 'f)float) x then denormal_of_Float x\n    else 0)\""], ["", "lemma valof_normal_of_Float: \"valof (normal_of_Float x::('e, 'f)float) = x\"\n  if \"is_normal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "have \"valof (normal_of_Float x::('e, 'f)float) =\n    (- 1) ^ sign (normal_of_Float x::('e, 'f)float) *\n    ((1 + real (nat \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) - 2 ^ LENGTH('f)) / 2 ^ LENGTH('f)) *\n      2 powr (bitlen \\<bar>mantissa x\\<bar> - 1)) *\n    2 powr Float.exponent x\"\n    (is \"_ = ?s * ?m * ?e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) =\n    (- 1) ^ sign (normal_of_Float x) *\n    ((1 +\n      real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n        2 ^ LENGTH('f)) /\n      2 ^ LENGTH('f)) *\n     2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1)) *\n    2 powr real_of_int (Float.exponent x)", "using that"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) =\n    (- 1) ^ sign (normal_of_Float x) *\n    ((1 +\n      real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n        2 ^ LENGTH('f)) /\n      2 ^ LENGTH('f)) *\n     2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1)) *\n    2 powr real_of_int (Float.exponent x)", "by (auto simp: is_normal_Float_def valof_eq fraction_normal_of_Float\n        powr_realpow[symmetric] exponent_normal_of_Float powr_diff powr_add)"], ["proof (state)\nthis:\n  valof (normal_of_Float x) =\n  (- 1) ^ sign (normal_of_Float x) *\n  ((1 +\n    real\n     (nat \\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f)) /\n    2 ^ LENGTH('f)) *\n   2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1)) *\n  2 powr real_of_int (Float.exponent x)\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "also"], ["proof (state)\nthis:\n  valof (normal_of_Float x) =\n  (- 1) ^ sign (normal_of_Float x) *\n  ((1 +\n    real\n     (nat \\<bar>mantissa x\\<bar> *\n      2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n      2 ^ LENGTH('f)) /\n    2 ^ LENGTH('f)) *\n   2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1)) *\n  2 powr real_of_int (Float.exponent x)\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "have \"\\<bar>mantissa x\\<bar> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < \\<bar>mantissa x\\<bar>", "using that"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. 0 < \\<bar>mantissa x\\<bar>", "by (auto simp: is_normal_Float_def)"], ["proof (state)\nthis:\n  0 < \\<bar>mantissa x\\<bar>\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "have bound: \"2 ^ LENGTH('f) \\<le> nat \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "have \"(2::nat) ^ LENGTH('f) \\<le> 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "by (simp add: power_add[symmetric])"], ["proof (state)\nthis:\n  2 ^ LENGTH('f)\n  \\<le> 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "also"], ["proof (state)\nthis:\n  2 ^ LENGTH('f)\n  \\<le> 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "have \"\\<dots> \\<le> nat \\<bar>mantissa x\\<bar> * 2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "using bitlen_bounds[of \"\\<bar>mantissa x\\<bar>\"] that"], ["proof (prove)\nusing this:\n  0 < \\<bar>mantissa x\\<bar> \\<Longrightarrow>\n  2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1)\n  \\<le> \\<bar>mantissa x\\<bar> \\<and>\n  \\<bar>mantissa x\\<bar> < 2 ^ nat (bitlen \\<bar>mantissa x\\<bar>)\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. 2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n    2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "by (auto simp: is_normal_Float_def)"], ["proof (state)\nthis:\n  2 ^ nat (bitlen \\<bar>mantissa x\\<bar> - 1) *\n  2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "finally"], ["proof (chain)\npicking this:\n  2 ^ LENGTH('f)\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "show ?thesis"], ["proof (prove)\nusing this:\n  2 ^ LENGTH('f)\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "."], ["proof (state)\nthis:\n  2 ^ LENGTH('f)\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 ^ LENGTH('f)\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "have \"?m = abs (mantissa x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 +\n     real\n      (nat \\<bar>mantissa x\\<bar> *\n       2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n       2 ^ LENGTH('f)) /\n     2 ^ LENGTH('f)) *\n    2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n    real_of_int \\<bar>mantissa x\\<bar>", "apply (subst of_nat_diff)"], ["proof (prove)\ngoal (2 subgoals):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n 2. (1 +\n     (real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))) -\n      real (2 ^ LENGTH('f))) /\n     2 ^ LENGTH('f)) *\n    2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n    real_of_int \\<bar>mantissa x\\<bar>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "using bound"], ["proof (prove)\nusing this:\n  2 ^ LENGTH('f)\n  \\<le> nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))\n\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('f)\n    \\<le> nat \\<bar>mantissa x\\<bar> *\n          2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))", "by auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 +\n     (real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))) -\n      real (2 ^ LENGTH('f))) /\n     2 ^ LENGTH('f)) *\n    2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n    real_of_int \\<bar>mantissa x\\<bar>", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 +\n     (real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))) -\n      real (2 ^ LENGTH('f))) /\n     2 ^ LENGTH('f)) *\n    2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n    real_of_int \\<bar>mantissa x\\<bar>", "using that"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. (1 +\n     (real\n       (nat \\<bar>mantissa x\\<bar> *\n        2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>))) -\n      real (2 ^ LENGTH('f))) /\n     2 ^ LENGTH('f)) *\n    2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n    real_of_int \\<bar>mantissa x\\<bar>", "by (auto simp: powr_realpow[symmetric] powr_add[symmetric]\n          is_normal_Float_def bitlen_nonneg of_nat_diff divide_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (1 +\n   real\n    (nat \\<bar>mantissa x\\<bar> *\n     2 ^ (Suc LENGTH('f) - nat (bitlen \\<bar>mantissa x\\<bar>)) -\n     2 ^ LENGTH('f)) /\n   2 ^ LENGTH('f)) *\n  2 powr real_of_int (bitlen \\<bar>mantissa x\\<bar> - 1) =\n  real_of_int \\<bar>mantissa x\\<bar>\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "finally"], ["proof (chain)\npicking this:\n  valof (normal_of_Float x) =\n  (- 1) ^ sign (normal_of_Float x) * real_of_int \\<bar>mantissa x\\<bar> *\n  2 powr real_of_int (Float.exponent x)", "show ?thesis"], ["proof (prove)\nusing this:\n  valof (normal_of_Float x) =\n  (- 1) ^ sign (normal_of_Float x) * real_of_int \\<bar>mantissa x\\<bar> *\n  2 powr real_of_int (Float.exponent x)\n\ngoal (1 subgoal):\n 1. valof (normal_of_Float x) = real_of_float x", "by (auto simp: mantissa_exponent sign_normal_of_Float abs_real_def zero_less_mult_iff)"], ["proof (state)\nthis:\n  valof (normal_of_Float x) = real_of_float x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valof_denormal_of_Float: \"valof (denormal_of_Float x::('e, 'f)float) = x\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "have less: \"0 < Float.exponent x + (int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Float.exponent x +\n        (int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f))", "using that"], ["proof (prove)\nusing this:\n  is_denormal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. 0 < Float.exponent x +\n        (int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f))", "by (auto simp: is_denormal_Float_def bias_def of_nat_diff)"], ["proof (state)\nthis:\n  0 < Float.exponent x +\n      (int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f))\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "have \"valof (denormal_of_Float x::('e, 'f)float) =\n    ((- 1) ^ sign (denormal_of_Float x::('e, 'f)float) * \\<bar>real_of_int (mantissa x)\\<bar>) *\n    (2 powr real (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) + int LENGTH('f) - 1)) /\n      (2 powr real (bias TYPE(('e, 'f) IEEE.float)) * 2 powr LENGTH('f)) * 2)\"\n    (is \"_ = ?m * ?e\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) =\n    (- 1) ^ sign (denormal_of_Float x) *\n    \\<bar>real_of_int (mantissa x)\\<bar> *\n    (2 powr\n     real\n      (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n            int LENGTH('f) -\n            1)) /\n     (2 powr real (bias TYPE(('e, 'f) IEEE.float)) *\n      2 powr real LENGTH('f)) *\n     2)", "by (auto simp: valof_eq exponent_denormal_of_Float fraction_denormal_of_Float that\n        mantissa_exponent powr_realpow[symmetric])"], ["proof (state)\nthis:\n  valof (denormal_of_Float x) =\n  (- 1) ^ sign (denormal_of_Float x) *\n  \\<bar>real_of_int (mantissa x)\\<bar> *\n  (2 powr\n   real\n    (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n          int LENGTH('f) -\n          1)) /\n   (2 powr real (bias TYPE(('e, 'f) IEEE.float)) * 2 powr real LENGTH('f)) *\n   2)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "also"], ["proof (state)\nthis:\n  valof (denormal_of_Float x) =\n  (- 1) ^ sign (denormal_of_Float x) *\n  \\<bar>real_of_int (mantissa x)\\<bar> *\n  (2 powr\n   real\n    (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n          int LENGTH('f) -\n          1)) /\n   (2 powr real (bias TYPE(('e, 'f) IEEE.float)) * 2 powr real LENGTH('f)) *\n   2)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "have \"?m = mantissa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ sign (denormal_of_Float x) *\n    \\<bar>real_of_int (mantissa x)\\<bar> =\n    real_of_int (mantissa x)", "by (auto simp: sign_denormal_of_Float abs_real_def mantissa_neg_iff)"], ["proof (state)\nthis:\n  (- 1) ^ sign (denormal_of_Float x) *\n  \\<bar>real_of_int (mantissa x)\\<bar> =\n  real_of_int (mantissa x)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "also"], ["proof (state)\nthis:\n  (- 1) ^ sign (denormal_of_Float x) *\n  \\<bar>real_of_int (mantissa x)\\<bar> =\n  real_of_int (mantissa x)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "have \"?e = 2 powr Float.exponent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr\n    real\n     (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n           int LENGTH('f) -\n           1)) /\n    (2 powr real (bias TYPE(('e, 'f) IEEE.float)) *\n     2 powr real LENGTH('f)) *\n    2 =\n    2 powr real_of_int (Float.exponent x)", "by (auto simp: powr_add[symmetric] divide_simps powr_mult_base less ac_simps)"], ["proof (state)\nthis:\n  2 powr\n  real\n   (nat (Float.exponent x + int (bias TYPE(('e, 'f) IEEE.float)) +\n         int LENGTH('f) -\n         1)) /\n  (2 powr real (bias TYPE(('e, 'f) IEEE.float)) * 2 powr real LENGTH('f)) *\n  2 =\n  2 powr real_of_int (Float.exponent x)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "finally"], ["proof (chain)\npicking this:\n  valof (denormal_of_Float x) =\n  real_of_int (mantissa x) * 2 powr real_of_int (Float.exponent x)", "show ?thesis"], ["proof (prove)\nusing this:\n  valof (denormal_of_Float x) =\n  real_of_int (mantissa x) * 2 powr real_of_int (Float.exponent x)\n\ngoal (1 subgoal):\n 1. valof (denormal_of_Float x) = real_of_float x", "by (simp add: mantissa_exponent)"], ["proof (state)\nthis:\n  valof (denormal_of_Float x) = real_of_float x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valof_of_finite_Float:\n  \"is_finite_Float (TYPE(('e, 'f) IEEE.float)) x \\<Longrightarrow> valof (of_finite_Float x::('e, 'f)float) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) x \\<Longrightarrow>\n    valof (of_finite_Float x) = real_of_float x", "by (auto simp: of_finite_Float_def is_finite_Float_def valof_denormal_of_Float valof_normal_of_Float)"], ["", "lemma is_normal_normal_of_Float:\n  \"is_normal (normal_of_Float x::('e, 'f)float)\" if \"is_normal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal (normal_of_Float x)", "using that"], ["proof (prove)\nusing this:\n  is_normal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. is_normal (normal_of_Float x)", "by (auto simp: is_normal_def exponent_normal_of_Float that is_normal_Float_def\n      emax_eq nat_less_iff of_nat_diff)"], ["", "lemma is_denormal_denormal_of_Float: \"is_denormal (denormal_of_Float x::('e, 'f)float)\"\n  if \"is_denormal_Float TYPE(('e, 'f)float) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_denormal (denormal_of_Float x)", "using that"], ["proof (prove)\nusing this:\n  is_denormal_Float TYPE(('e, 'f) IEEE.float) x\n\ngoal (1 subgoal):\n 1. is_denormal (denormal_of_Float x)", "by (auto simp: is_denormal_def exponent_denormal_of_Float that is_denormal_Float_def\n      emax_eq fraction_denormal_of_Float le_nat_iff bias_def)"], ["", "lemma is_finite_of_finite_Float: \"is_finite (of_finite_Float x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (of_finite_Float x)", "by (auto simp: is_finite_def of_finite_Float_def is_normal_normal_of_Float\n      is_denormal_denormal_of_Float)"], ["", "lemma Float_eq_zero_iff: \"Float m e = 0 \\<longleftrightarrow> m = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Float m e = 0) = (m = 0)", "by (metis Float.compute_is_float_zero Float_0_eq_0)"], ["", "lemma bitlen_mantissa_Float:\n  shows \"bitlen \\<bar>mantissa (Float m e)\\<bar> = (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) - Float.exponent (Float m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen \\<bar>mantissa (Float m e)\\<bar> =\n    (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) -\n    Float.exponent (Float m e)", "using bitlen_Float[of m e]"], ["proof (prove)\nusing this:\n  bitlen \\<bar>mantissa (Float m e)\\<bar> + Float.exponent (Float m e) =\n  (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>mantissa (Float m e)\\<bar> =\n    (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) -\n    Float.exponent (Float m e)", "by auto"], ["", "lemma exponent_Float:\n  shows \"Float.exponent (Float m e) = (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) - bitlen \\<bar>mantissa (Float m e)\\<bar> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. Float.exponent (Float m e) =\n    (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) -\n    bitlen \\<bar>mantissa (Float m e)\\<bar>", "using bitlen_Float[of m e]"], ["proof (prove)\nusing this:\n  bitlen \\<bar>mantissa (Float m e)\\<bar> + Float.exponent (Float m e) =\n  (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e)\n\ngoal (1 subgoal):\n 1. Float.exponent (Float m e) =\n    (if m = 0 then 0 else bitlen \\<bar>m\\<bar> + e) -\n    bitlen \\<bar>mantissa (Float m e)\\<bar>", "by auto"], ["", "lemma is_normal_Float_normal:\n  \"is_normal_Float TYPE(('e, 'f)float) (Float (normal_mantissa x) (normal_exponent x))\"\n  if \"is_normal x\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "define f where \"f = Float (normal_mantissa x) (normal_exponent x)\""], ["proof (state)\nthis:\n  f = Float (normal_mantissa x) (normal_exponent x)\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "from that"], ["proof (chain)\npicking this:\n  is_normal x", "have \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_normal x\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by (auto simp: f_def is_normal_def zero_float_def[symmetric]\n        Float_eq_zero_iff normal_mantissa_def add_nonneg_eq_0_iff)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "from denormalize_shift[OF f_def this]"], ["proof (chain)\npicking this:\n  (\\<And>i.\n      \\<lbrakk>normal_mantissa x = mantissa f * 2 ^ i;\n       normal_exponent x = Float.exponent f - int i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain i where\n    i: \"normal_mantissa x = mantissa f * 2 ^ i\" \"normal_exponent x = Float.exponent f - int i\""], ["proof (prove)\nusing this:\n  (\\<And>i.\n      \\<lbrakk>normal_mantissa x = mantissa f * 2 ^ i;\n       normal_exponent x = Float.exponent f - int i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>normal_mantissa x = mantissa f * 2 ^ i;\n         normal_exponent x = Float.exponent f - int i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  normal_mantissa x = mantissa f * 2 ^ i\n  normal_exponent x = Float.exponent f - int i\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "have \"mantissa f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mantissa f \\<noteq> 0", "by (auto simp: \\<open>f \\<noteq> 0\\<close> i mantissa_eq_zero_iff Float_eq_zero_iff)"], ["proof (state)\nthis:\n  mantissa f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "moreover"], ["proof (state)\nthis:\n  mantissa f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "have \"normal_exponent x \\<le> Float.exponent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normal_exponent x \\<le> Float.exponent f", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Float.exponent f - int i \\<le> Float.exponent f", "by simp"], ["proof (state)\nthis:\n  normal_exponent x \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "then"], ["proof (chain)\npicking this:\n  normal_exponent x \\<le> Float.exponent f", "have \" bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)\""], ["proof (prove)\nusing this:\n  normal_exponent x \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)", "unfolding bitlen_mantissa_Float bitlen_normal_mantissa f_def"], ["proof (prove)\nusing this:\n  normal_exponent x\n  \\<le> Float.exponent (Float (normal_mantissa x) (normal_exponent x))\n\ngoal (1 subgoal):\n 1. (if normal_mantissa x = 0 then 0\n     else int (Suc LENGTH('f)) + normal_exponent x) -\n    Float.exponent (Float (normal_mantissa x) (normal_exponent x))\n    \\<le> 1 + int LENGTH('f)", "by auto"], ["proof (state)\nthis:\n  bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "moreover"], ["proof (state)\nthis:\n  bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "have \"- int (bias TYPE(('e, 'f)float)) - bitlen \\<bar>mantissa f\\<bar> + 1 < Float.exponent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - int (bias TYPE(('e, 'f) IEEE.float)) - bitlen \\<bar>mantissa f\\<bar> +\n    1\n    < Float.exponent f", "unfolding bitlen_mantissa_Float bitlen_normal_mantissa f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - int (bias TYPE(('e, 'f) IEEE.float)) -\n    ((if normal_mantissa x = 0 then 0\n      else int (Suc LENGTH('f)) + normal_exponent x) -\n     Float.exponent (Float (normal_mantissa x) (normal_exponent x))) +\n    1\n    < Float.exponent (Float (normal_mantissa x) (normal_exponent x))", "using that"], ["proof (prove)\nusing this:\n  is_normal x\n\ngoal (1 subgoal):\n 1. - int (bias TYPE(('e, 'f) IEEE.float)) -\n    ((if normal_mantissa x = 0 then 0\n      else int (Suc LENGTH('f)) + normal_exponent x) -\n     Float.exponent (Float (normal_mantissa x) (normal_exponent x))) +\n    1\n    < Float.exponent (Float (normal_mantissa x) (normal_exponent x))", "by (auto simp: mantissa_eq_zero_iff abs_mult bias_def normal_mantissa_def normal_exponent_def\n        is_normal_def emax_eq less_diff_conv add_nonneg_eq_0_iff)"], ["proof (state)\nthis:\n  - int (bias TYPE(('e, 'f) IEEE.float)) - bitlen \\<bar>mantissa f\\<bar> + 1\n  < Float.exponent f\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "moreover"], ["proof (state)\nthis:\n  - int (bias TYPE(('e, 'f) IEEE.float)) - bitlen \\<bar>mantissa f\\<bar> + 1\n  < Float.exponent f\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "have \"2 ^ (LENGTH('e) - Suc 0) + - (1::int) * 2 ^ LENGTH('e) \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('e) - Suc 0) + - 1 * 2 ^ LENGTH('e) \\<le> 0", "by simp"], ["proof (state)\nthis:\n  2 ^ (LENGTH('e) - Suc 0) + - 1 * 2 ^ LENGTH('e) \\<le> 0\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "then"], ["proof (chain)\npicking this:\n  2 ^ (LENGTH('e) - Suc 0) + - 1 * 2 ^ LENGTH('e) \\<le> 0", "have \"(2::int) ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)\""], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) + - 1 * 2 ^ LENGTH('e) \\<le> 0\n\ngoal (1 subgoal):\n 1. 2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)", "by arith"], ["proof (state)\nthis:\n  2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "then"], ["proof (chain)\npicking this:\n  2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)", "have \"Float.exponent f <\n      2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> - int (bias TYPE(('e, 'f)float))\""], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. Float.exponent f\n    < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n      int (bias TYPE(('e, 'f) IEEE.float))", "using normal_exponent_bounds_int[OF that]"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)\n  2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x\n  normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. Float.exponent f\n    < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n      int (bias TYPE(('e, 'f) IEEE.float))", "unfolding bitlen_mantissa_Float bitlen_normal_mantissa f_def"], ["proof (prove)\nusing this:\n  2 ^ (LENGTH('e) - Suc 0) < 1 + 2 ^ LENGTH('e)\n  2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x\n  normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. Float.exponent (Float (normal_mantissa x) (normal_exponent x))\n    < 2 ^ LENGTH('e) -\n      ((if normal_mantissa x = 0 then 0\n        else int (Suc LENGTH('f)) + normal_exponent x) -\n       Float.exponent (Float (normal_mantissa x) (normal_exponent x))) -\n      int (bias TYPE(('e, 'f) IEEE.float))", "by (auto simp: bias_def algebra_simps power_Suc[symmetric] of_nat_diff\n        intro: le_less_trans[OF add_right_mono] normal_exponent_bounds_int[OF that])"], ["proof (state)\nthis:\n  Float.exponent f\n  < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n    int (bias TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "ultimately"], ["proof (chain)\npicking this:\n  mantissa f \\<noteq> 0\n  bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)\n  - int (bias TYPE(('e, 'f) IEEE.float)) - bitlen \\<bar>mantissa f\\<bar> + 1\n  < Float.exponent f\n  Float.exponent f\n  < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n    int (bias TYPE(('e, 'f) IEEE.float))", "show ?thesis"], ["proof (prove)\nusing this:\n  mantissa f \\<noteq> 0\n  bitlen \\<bar>mantissa f\\<bar> \\<le> 1 + int LENGTH('f)\n  - int (bias TYPE(('e, 'f) IEEE.float)) - bitlen \\<bar>mantissa f\\<bar> + 1\n  < Float.exponent f\n  Float.exponent f\n  < 2 ^ LENGTH('e) - bitlen \\<bar>mantissa f\\<bar> -\n    int (bias TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_normal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (normal_mantissa x) (normal_exponent x))", "by (auto simp: is_normal_Float_def f_def)"], ["proof (state)\nthis:\n  is_normal_Float TYPE(('e, 'f) IEEE.float)\n   (Float (normal_mantissa x) (normal_exponent x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_denormal_Float_denormal:\n  \"is_denormal_Float TYPE(('e, 'f)float)\n    (Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float)))\"\n  if \"is_denormal x\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "define f where \"f = Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f)float))\""], ["proof (state)\nthis:\n  f =\n  Float (denormal_mantissa x) (denormal_exponent TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "from that"], ["proof (chain)\npicking this:\n  is_denormal x", "have \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  is_denormal x\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by (auto simp: f_def is_denormal_def zero_float_def[symmetric]\n        Float_eq_zero_iff denormal_mantissa_def add_nonneg_eq_0_iff)"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "from denormalize_shift[OF f_def this]"], ["proof (chain)\npicking this:\n  (\\<And>i.\n      \\<lbrakk>denormal_mantissa x = mantissa f * 2 ^ i;\n       denormal_exponent TYPE(('e, 'f) IEEE.float) =\n       Float.exponent f - int i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain i where\n    i: \"denormal_mantissa x = mantissa f * 2 ^ i\" \"denormal_exponent TYPE(('e, 'f)float) = Float.exponent f - int i\""], ["proof (prove)\nusing this:\n  (\\<And>i.\n      \\<lbrakk>denormal_mantissa x = mantissa f * 2 ^ i;\n       denormal_exponent TYPE(('e, 'f) IEEE.float) =\n       Float.exponent f - int i\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>denormal_mantissa x = mantissa f * 2 ^ i;\n         denormal_exponent TYPE(('e, 'f) IEEE.float) =\n         Float.exponent f - int i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  denormal_mantissa x = mantissa f * 2 ^ i\n  denormal_exponent TYPE(('e, 'f) IEEE.float) = Float.exponent f - int i\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "have \"mantissa f \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mantissa f \\<noteq> 0", "by (auto simp: \\<open>f \\<noteq> 0\\<close> i mantissa_eq_zero_iff Float_eq_zero_iff)"], ["proof (state)\nthis:\n  mantissa f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "moreover"], ["proof (state)\nthis:\n  mantissa f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "have \"bitlen \\<bar>mantissa f\\<bar> \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen \\<bar>mantissa f\\<bar>\n    \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))", "using \\<open>mantissa f \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  mantissa f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>mantissa f\\<bar>\n    \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))", "unfolding f_def bitlen_mantissa_Float"], ["proof (prove)\nusing this:\n  mantissa\n   (Float (denormal_mantissa x)\n     (denormal_exponent TYPE(('e, 'f) IEEE.float))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. (if denormal_mantissa x = 0 then 0\n     else bitlen \\<bar>denormal_mantissa x\\<bar> +\n          denormal_exponent TYPE(('e, 'f) IEEE.float)) -\n    Float.exponent\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))\n    \\<le> 1 -\n          Float.exponent\n           (Float (denormal_mantissa x)\n             (denormal_exponent TYPE(('e, 'f) IEEE.float))) -\n          int (bias TYPE(('e, 'f) IEEE.float))", "using bitlen_denormal_mantissa[of x]"], ["proof (prove)\nusing this:\n  mantissa\n   (Float (denormal_mantissa x)\n     (denormal_exponent TYPE(('e, 'f) IEEE.float))) \\<noteq>\n  0\n  bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)\n\ngoal (1 subgoal):\n 1. (if denormal_mantissa x = 0 then 0\n     else bitlen \\<bar>denormal_mantissa x\\<bar> +\n          denormal_exponent TYPE(('e, 'f) IEEE.float)) -\n    Float.exponent\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))\n    \\<le> 1 -\n          Float.exponent\n           (Float (denormal_mantissa x)\n             (denormal_exponent TYPE(('e, 'f) IEEE.float))) -\n          int (bias TYPE(('e, 'f) IEEE.float))", "by (auto simp: denormal_exponent_def)"], ["proof (state)\nthis:\n  bitlen \\<bar>mantissa f\\<bar>\n  \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "moreover"], ["proof (state)\nthis:\n  bitlen \\<bar>mantissa f\\<bar>\n  \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "have \"2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\"\n    (is \"?l \\<le> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "have \"?l \\<le> denormal_exponent TYPE(('e, 'f)float) + i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f)\n    \\<le> denormal_exponent TYPE(('e, 'f) IEEE.float) + int i", "using that"], ["proof (prove)\nusing this:\n  is_denormal x\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f)\n    \\<le> denormal_exponent TYPE(('e, 'f) IEEE.float) + int i", "by (auto simp: is_denormal_def bias_def denormal_exponent_def of_nat_diff)"], ["proof (state)\nthis:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f)\n  \\<le> denormal_exponent TYPE(('e, 'f) IEEE.float) + int i\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "also"], ["proof (state)\nthis:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f)\n  \\<le> denormal_exponent TYPE(('e, 'f) IEEE.float) + int i\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "have \"\\<dots> = Float.exponent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. denormal_exponent TYPE(('e, 'f) IEEE.float) + int i = Float.exponent f", "unfolding i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Float.exponent f - int i + int i = Float.exponent f", "by auto"], ["proof (state)\nthis:\n  denormal_exponent TYPE(('e, 'f) IEEE.float) + int i = Float.exponent f\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "finally"], ["proof (chain)\npicking this:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "show ?thesis"], ["proof (prove)\nusing this:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "."], ["proof (state)\nthis:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "ultimately"], ["proof (chain)\npicking this:\n  mantissa f \\<noteq> 0\n  bitlen \\<bar>mantissa f\\<bar>\n  \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f", "show ?thesis"], ["proof (prove)\nusing this:\n  mantissa f \\<noteq> 0\n  bitlen \\<bar>mantissa f\\<bar>\n  \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. is_denormal_Float TYPE(('e, 'f) IEEE.float)\n     (Float (denormal_mantissa x)\n       (denormal_exponent TYPE(('e, 'f) IEEE.float)))", "unfolding is_denormal_Float_def exponent_Float f_def[symmetric]"], ["proof (prove)\nusing this:\n  mantissa f \\<noteq> 0\n  bitlen \\<bar>mantissa f\\<bar>\n  \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float))\n  2 - 2 ^ (LENGTH('e) - Suc 0) - int LENGTH('f) \\<le> Float.exponent f\n\ngoal (1 subgoal):\n 1. mantissa f \\<noteq> 0 \\<and>\n    bitlen \\<bar>mantissa f\\<bar>\n    \\<le> 1 - Float.exponent f - int (bias TYPE(('e, 'f) IEEE.float)) \\<and>\n    1 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) < Float.exponent f", "by auto"], ["proof (state)\nthis:\n  is_denormal_Float TYPE(('e, 'f) IEEE.float)\n   (Float (denormal_mantissa x)\n     (denormal_exponent TYPE(('e, 'f) IEEE.float)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_finite_Float_of_finite: \"is_finite_Float TYPE(('e, 'f)float) (of_finite x)\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE(('e, 'f) IEEE.float) (of_finite x)", "by (auto simp: is_finite_Float_def of_finite_def is_normal_Float_normal\n      is_denormal_Float_denormal)"], ["", "end"]]}