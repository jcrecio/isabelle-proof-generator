{"file_name": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point/Double.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point", "problem_names": ["lemma \"float_of 2 < float_of 3 + float_of 4\"", "lemma float_of_int[code]:\n  \"double_of_int i = double_of_integer (integer_of_int i)\"", "lemma is_finite_double_eq:\n  \"is_finite_Float TYPE((11, 52)float) f \\<longleftrightarrow>\n    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))\n    in (bm \\<le> 53 \\<and> e + bm < 1025 \\<and> - 1075 < e))\"", "lemma compute_Float_of_double[code]:\n  \"Float_of_double x =\n    map_option (\\<lambda>(m, e). Float (int_of_integer m) (int_of_integer e)) (man_exp_of_double x)\"", "lemma compute_double_of_Float[code]:\n  \"double_of_Float f = double_of_man_exp (integer_of_int (mantissa f)) (integer_of_int (Float.exponent f))\"", "lemma \"check_conversions 100 100\""], "translations": [["", "lemma \"float_of 2 < float_of 3 + float_of 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Double.float_of 2 < Double.float_of 3 + Double.float_of 4", "by eval"], ["", "export_code float_of in SML"], ["", "subsection \\<open>Conversion from int\\<close>"], ["", "lift_definition double_of_int::\"int \\<Rightarrow> double\" is \"\\<lambda>i. round To_nearest (real_of_int i)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context includes integer.lifting begin"], ["", "lift_definition double_of_integer::\"integer \\<Rightarrow> double\" is double_of_int"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "end"], ["", "lemma float_of_int[code]:\n  \"double_of_int i = double_of_integer (integer_of_int i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. double_of_int i = double_of_integer (integer_of_int i)", "by (auto simp: double_of_integer_def)"], ["", "code_printing\n  constant \"double_of_integer :: integer \\<Rightarrow> double\" \\<rightharpoonup> (SML) \"Real.fromLargeInt\""], ["", "declare [[code drop: double_of_integer]]"], ["", "subsection \\<open>Conversion to and from software floats, extracting information\\<close>"], ["", "text \\<open>Need to trust a lot of code here...\\<close>"], ["", "lemma is_finite_double_eq:\n  \"is_finite_Float TYPE((11, 52)float) f \\<longleftrightarrow>\n    (let e = Float.exponent f; bm = bitlen (abs (mantissa f))\n    in (bm \\<le> 53 \\<and> e + bm < 1025 \\<and> - 1075 < e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE((11, 52) IEEE.float) f =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> 53 \\<and> e + bm < 1025 \\<and> - 1075 < e)", "unfolding is_finite_Float_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> int (Suc LENGTH(52)) \\<and>\n        bm \\<le> 2 ^ (LENGTH(11) - 1) - e \\<and>\n        1 - 2 ^ (LENGTH(11) - 1) - int LENGTH(52) < e) =\n    (let e = Float.exponent f; bm = bitlen \\<bar>mantissa f\\<bar>\n     in bm \\<le> 53 \\<and> e + bm < 1025 \\<and> - 1075 < e)", "by (auto simp: Let_def)"], ["", "code_printing\n  code_module \"IEEE_Mantissa_Exponent\" \\<rightharpoonup> (SML)\n\\<open>\nstructure IEEE_Mantissa_Exponent =\nstruct\nfun to_man_exp_double x =\n  if Real.isFinite x\n  then case Real.toManExp x of {man = m, exp = e} =>\n    SOME (Real.floor (Real.* (m, Math.pow (2.0, 53.0))), IntInf.- (e, 53))\n  else NONE\nfun normfloat (m, e) =\n(if m mod 2 = 0 andalso m <> 0 then normfloat (m div 2, e + 1)\n else if m = 0 then (0, 0) else (m, e))\nfun bitlen x = (if 0 < x then bitlen (x div 2) + 1 else 0)\nfun is_finite_double_eq m e =\n  let\n    val (m, e) = normfloat (m, e)\n    val bm = bitlen (abs m)\n  in bm <= 53 andalso e + bm < 1025 andalso e > ~1075 end\nfun from_man_exp_double m e =\n  if is_finite_double_eq m e\n  then SOME (Real.fromManExp {man = Real.fromLargeInt m, exp = e})\n  else NONE\nend\n\\<close>"], ["", "lift_definition of_finite::\"double \\<Rightarrow> Float.float\" is Conversion_IEEE_Float.of_finite"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition man_exp_of_double::\"double \\<Rightarrow> (integer * integer)option\" where\n  \"man_exp_of_double d = (if is_finite d then let f = of_finite d in\n    Some (integer_of_int (mantissa f), integer_of_int (Float.exponent f)) else None)\""], ["", "lift_definition of_finite_Float::\"Float.float \\<Rightarrow> double\" is Conversion_IEEE_Float.of_finite_Float"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition double_of_man_exp::\"integer \\<Rightarrow> integer \\<Rightarrow> double option\" where\n  \"double_of_man_exp m e = (let f = Float (int_of_integer m) (int_of_integer e) in\n    if is_finite_Float TYPE((11, 52)float) f\n    then Some (of_finite_Float f)\n    else None)\""], ["", "code_printing\n  constant \"man_exp_of_double :: double \\<Rightarrow> (integer * integer) option\" \\<rightharpoonup>\n    (SML) \"IEEE'_Mantissa'_Exponent.to'_man'_exp'_double\" |\n  constant \"double_of_man_exp :: integer \\<Rightarrow> integer \\<Rightarrow> double option\" \\<rightharpoonup>\n    (SML) \"IEEE'_Mantissa'_Exponent.from'_man'_exp'_double\""], ["", "declare [[code drop: man_exp_of_double]]"], ["", "declare [[code drop: double_of_man_exp]]"], ["", "lift_definition Float_of_double::\"double \\<Rightarrow> Float.float option\" is\n  \"\\<lambda>x. if is_finite x then Some (of_finite x) else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition double_of_Float::\"Float.float \\<Rightarrow> double option\" is\n  \"\\<lambda>x. if is_finite_Float TYPE((11, 52)float) x then Some (of_finite_Float x) else None\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma compute_Float_of_double[code]:\n  \"Float_of_double x =\n    map_option (\\<lambda>(m, e). Float (int_of_integer m) (int_of_integer e)) (man_exp_of_double x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Float_of_double x =\n    map_option\n     (\\<lambda>(m, e). Float (int_of_integer m) (int_of_integer e))\n     (man_exp_of_double x)", "apply (rule sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option\n     (\\<lambda>(m, e). Float (int_of_integer m) (int_of_integer e))\n     (man_exp_of_double x) =\n    Float_of_double x", "by transfer (auto simp: man_exp_of_double_def Let_def mantissa_exponent[symmetric]\n      Float_mantissa_exponent)"], ["", "lemma compute_double_of_Float[code]:\n  \"double_of_Float f = double_of_man_exp (integer_of_int (mantissa f)) (integer_of_int (Float.exponent f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. double_of_Float f =\n    double_of_man_exp (integer_of_int (mantissa f))\n     (integer_of_int (Float.exponent f))", "unfolding double_of_man_exp_def Let_def Float_mantissa_exponent int_of_integer_integer_of_int"], ["proof (prove)\ngoal (1 subgoal):\n 1. double_of_Float f =\n    (if is_finite_Float TYPE((11, 52) IEEE.float) f\n     then Some (Double.of_finite_Float f) else None)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. is_finite_Float TYPE((11, 52) IEEE.float) f \\<Longrightarrow>\n    double_of_Float f = Some (Double.of_finite_Float f)\n 2. \\<not> is_finite_Float TYPE((11, 52) IEEE.float) f \\<Longrightarrow>\n    double_of_Float f = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite_Float TYPE((11, 52) IEEE.float) f \\<Longrightarrow>\n    double_of_Float f = Some (Double.of_finite_Float f)", "by transfer auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_finite_Float TYPE((11, 52) IEEE.float) f \\<Longrightarrow>\n    double_of_Float f = None", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_finite_Float TYPE((11, 52) IEEE.float) f \\<Longrightarrow>\n    double_of_Float f = None", "by transfer auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition \"check_conversion m e =\n  (let f = Float (int_of_integer m) (int_of_integer e) in\n    do {\n      d \\<leftarrow> double_of_Float f;\n      Float_of_double d\n    } = (if is_finite_Float TYPE((11, 52)float) f then Some f else None))\""], ["", "primrec check_all::\"nat \\<Rightarrow> (nat \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"check_all 0 P \\<longleftrightarrow> True\"\n| \"check_all (Suc i) P \\<longleftrightarrow> P i \\<and> check_all i P\""], ["", "definition \"check_conversions dm de =\n  check_all (nat (2 * de)) (\\<lambda>e. check_all (nat (2 * dm)) (\\<lambda>m.\n    check_conversion (integer_of_int (int m - dm)) (integer_of_int (int e - de))))\""], ["", "lemma \"check_conversions 100 100\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_conversions 100 100", "by eval"], ["", "end"]]}