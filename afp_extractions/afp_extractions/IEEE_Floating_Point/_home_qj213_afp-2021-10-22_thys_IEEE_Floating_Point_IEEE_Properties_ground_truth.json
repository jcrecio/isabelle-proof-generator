{"file_name": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point/IEEE_Properties.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/IEEE_Floating_Point", "problem_names": ["lemma valof_eq:\n  \"valof x =\n    (if exponent x = 0\n       then (- 1) ^ sign x * (2 / 2 ^ bias TYPE(('a, 'b) float)) *\n            (real (fraction x) / 2 ^ LENGTH('b))\n       else (- 1) ^ sign x * (2 ^ exponent x / 2 ^ bias TYPE(('a, 'b) float)) *\n            (1 + real (fraction x) / 2 ^ LENGTH('b)))\"\n  for x::\"('a, 'b) float\"", "lemma exponent_le[simp]:\n  \"exponent a \\<le> unat (max_word::'a word)\" for a::\"('a, _)float\"", "lemma\n  max_word_le_exponent_iff[simp]:\n  \"unat (max_word::'a word) \\<le> exponent a \\<longleftrightarrow> unat (max_word::'a word) = exponent a\"\n  for a::\"('a, _)float\"", "lemma infinity_simps:\n  \"sign (plus_infinity::('e, 'f)float) = 0\"\n  \"sign (minus_infinity::('e, 'f)float) = 1\"\n  \"exponent (plus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)\"\n  \"exponent (minus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)\"\n  \"fraction (plus_infinity::('e, 'f)float) = 0\"\n  \"fraction (minus_infinity::('e, 'f)float) = 0\"", "lemma zero_simps:\n  \"sign (0::('e, 'f)float) = 0\"\n  \"sign (- 0::('e, 'f)float) = 1\"\n  \"exponent (0::('e, 'f)float) = 0\"\n  \"exponent (- 0::('e, 'f)float) = 0\"\n  \"fraction (0::('e, 'f)float) = 0\"\n  \"fraction (- 0::('e, 'f)float) = 0\"", "lemma emax_eq: \"emax x = 2^LENGTH('e) - 1\"\n  for x::\"('e, 'f)float itself\"", "lemma topfloat_simps:\n  \"sign (topfloat::('e, 'f)float) = 0\"\n  \"exponent (topfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1\"\n  \"fraction (topfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1\"\n  and bottomfloat_simps:\n  \"sign (bottomfloat::('e, 'f)float) = 1\"\n  \"exponent (bottomfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1\"\n  \"fraction (bottomfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1\"", "lemmas float_defs =\n  is_finite_def is_infinity_def is_zero_def is_nan_def\n  is_normal_def is_denormal_def valof_eq\n  less_eq_float_def less_float_def\n  flt_def fgt_def fle_def fge_def feq_def\n  fcompare_def\n  infinity_simps\n  zero_simps\n  topfloat_simps\n  bottomfloat_simps\n  float_eq_def", "lemma float_cases: \"is_nan a \\<or> is_infinity a \\<or> is_normal a \\<or> is_denormal a \\<or> is_zero a\"", "lemma float_cases_finite: \"is_nan a \\<or> is_infinity a \\<or> is_finite a\"", "lemma float_zero1[simp]: \"is_zero 0\"", "lemma float_zero2[simp]: \"is_zero (- x) \\<longleftrightarrow> is_zero x\"", "lemma emax_pos[simp]: \"0 < emax x\" \"emax x \\<noteq> 0\"", "lemma float_distinct:\n  \"\\<not> (is_nan a \\<and> is_infinity a)\"\n  \"\\<not> (is_nan a \\<and> is_normal a)\"\n  \"\\<not> (is_nan a \\<and> is_denormal a)\"\n  \"\\<not> (is_nan a \\<and> is_zero a)\"\n  \"\\<not> (is_infinity a \\<and> is_normal a)\"\n  \"\\<not> (is_infinity a \\<and> is_denormal a)\"\n  \"\\<not> (is_infinity a \\<and> is_zero a)\"\n  \"\\<not> (is_normal a \\<and> is_denormal a)\"\n  \"\\<not> (is_denormal a \\<and> is_zero a)\"", "lemma denormal_imp_not_zero: \"is_denormal f \\<Longrightarrow> \\<not>is_zero f\"", "lemma normal_imp_not_zero: \"is_normal f \\<Longrightarrow> \\<not>is_zero f\"", "lemma normal_imp_not_denormal: \"is_normal f \\<Longrightarrow> \\<not>is_denormal f\"", "lemma denormal_zero[simp]: \"\\<not>is_denormal 0\" \"\\<not>is_denormal minus_zero\"", "lemma normal_zero[simp]: \"\\<not>is_normal 0\" \"\\<not>is_normal minus_zero\"", "lemma float_distinct_finite: \"\\<not> (is_nan a \\<and> is_finite a)\" \"\\<not>(is_infinity a \\<and> is_finite a)\"", "lemma finite_infinity: \"is_finite a \\<Longrightarrow> \\<not> is_infinity a\"", "lemma finite_nan: \"is_finite a \\<Longrightarrow> \\<not> is_nan a\"", "lemma is_closest_exists:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n    and s :: \"('e, 'f)float set\"\n  assumes finite: \"finite s\"\n    and non_empty: \"s \\<noteq> {}\"\n  shows \"\\<exists>a. is_closest v s x a\"", "lemma closest_is_everything:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n    and s :: \"('e, 'f)float set\"\n  assumes finite: \"finite s\"\n    and non_empty: \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x) \\<and>\n    ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow> p (closest v p s x))\"", "lemma closest_in_set:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"finite s\" and \"s \\<noteq> {}\"\n  shows \"closest v p s x \\<in> s\"", "lemma closest_is_closest_finite:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"finite s\" and \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x)\"", "lemma is_finite_nonempty: \"{a. is_finite a} \\<noteq> {}\"", "lemma closest_is_closest:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x)\"", "lemma float_lt [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a < b \\<longleftrightarrow> valof a < valof b\"", "lemma float_eq [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a \\<doteq> b \\<longleftrightarrow> valof a = valof b\"", "lemma float_le [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a \\<le> b \\<longleftrightarrow> valof a \\<le> valof b\"", "lemma float_eq_refl [simp]: \"a \\<doteq> a \\<longleftrightarrow> \\<not> is_nan a\"", "lemma float_lt_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a < b \\<Longrightarrow> b < c \\<Longrightarrow> a < c\"", "lemma float_le_less_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a \\<le> b \\<Longrightarrow> b < c \\<Longrightarrow> a < c\"", "lemma float_le_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> a \\<le> c\"", "lemma float_le_neg: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> \\<not> a < b \\<longleftrightarrow> b \\<le> a\"", "lemma float_le_infinity [simp]: \"\\<not> is_nan a \\<Longrightarrow> a \\<le> plus_infinity\"", "lemma zero_le_topfloat[simp]: \"0 \\<le> topfloat\" \"- 0 \\<le> topfloat\"", "lemma LENGTH_contr:\n  \"Suc 0 < LENGTH('e) \\<Longrightarrow> 2 ^ LENGTH('e::len) \\<le> Suc (Suc 0) \\<Longrightarrow> False\"", "lemma valof_topfloat: \"valof (topfloat::('e, 'f)float) = largest TYPE(('e, 'f)float)\"\n  if \"LENGTH('e) > 1\"", "lemma float_frac_le: \"fraction a \\<le> 2^LENGTH('f) - 1\"\n  for a::\"('e, 'f)float\"", "lemma float_exp_le: \"is_finite a \\<Longrightarrow> exponent a \\<le> emax TYPE(('e, 'f)float) - 1\"\n  for a::\"('e, 'f)float\"", "lemma float_sign_le: \"(-1::real)^(sign a) = 1 \\<or> (-1::real)^(sign a) = -1\"", "lemma exp_less: \"a \\<le> b \\<Longrightarrow> (2::real)^a \\<le> 2^b\" for a b :: nat", "lemma div_less: \"a \\<le> b \\<and> c > 0 \\<Longrightarrow> a/c \\<le> b/c\" for a b c :: \"'a::linordered_field\"", "lemma finite_topfloat: \"is_finite topfloat\"", "lemmas float_leI = float_le[THEN iffD2]", "lemma factor_minus: \"x * a - x = x * (a - 1)\"\n  for x a::\"'a::comm_semiring_1_cancel\"", "lemma real_le_power_numeral_diff: \"real a \\<le> numeral b ^ n - 1 \\<longleftrightarrow> a \\<le> numeral b ^ n - 1\"", "lemma unat_one_word_le: \"unat a \\<le> Suc 0\" for a::\"1 word\"", "lemma one_word_le: \"a \\<le> 1\" for a::\"1 word\"", "lemma sign_cases[case_names pos neg]:\n  obtains \"sign x = 0\" | \"sign x = 1\"", "lemma is_infinity_cases:\n  assumes \"is_infinity x\"\n  obtains \"x = plus_infinity\" | \"x = minus_infinity\"", "lemma is_zero_cases:\n  assumes \"is_zero x\"\n  obtains \"x = 0\" | \"x = - 0\"", "lemma minus_minus_float[simp]: \"- (-f) = f\" for f::\"('e, 'f)float\"", "lemma sign_minus_float: \"sign (-f) = (1 - sign f)\" for f::\"('e, 'f)float\"", "lemma exponent_uminus[simp]: \"exponent (- f) = exponent f\"", "lemma fraction_uminus[simp]: \"fraction (- f) = fraction f\"", "lemma is_normal_minus_float[simp]: \"is_normal (-f) = is_normal f\" for f::\"('e, 'f)float\"", "lemma is_denormal_minus_float[simp]: \"is_denormal (-f) = is_denormal f\" for f::\"('e, 'f)float\"", "lemma bitlen_normal_mantissa:\n  \"bitlen (abs (normal_mantissa x)) = Suc LENGTH('f)\" for x::\"('e, 'f)float\"", "lemma less_int_natI: \"x < y\" if \"0 \\<le> x\" \"nat x < nat y\"", "lemma normal_exponent_bounds_int:\n  \"2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x\"\n  \"normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1\"\n  if \"is_normal x\"\n  for x::\"('e, 'f)float\"", "lemmas of_int_leI = of_int_le_iff[THEN iffD2]", "lemma normal_exponent_bounds_real:\n  \"2 - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) \\<le> normal_exponent x\"\n  \"normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1\"\n  if \"is_normal x\"\n  for x::\"('e, 'f)float\"", "lemma float_eqI:\n  \"x = y\" if \"sign x = sign y\" \"fraction x = fraction y\" \"exponent x = exponent y\"", "lemma float_induct[induct type:float, case_names normal denormal neg zero infinity nan]:\n  fixes a::\"('e, 'f)float\"\n  assumes normal:\n    \"\\<And>x. is_normal x \\<Longrightarrow> valof x = normal_mantissa x * 2 powr normal_exponent x \\<Longrightarrow> P x\"\n  assumes denormal:\n    \"\\<And>x. is_denormal x \\<Longrightarrow>\n      valof x = denormal_mantissa x * 2 powr denormal_exponent TYPE(('e, 'f)float) \\<Longrightarrow>\n      P x\"\n  assumes zero: \"P 0\" \"P minus_zero\"\n  assumes infty: \"P plus_infinity\" \"P minus_infinity\"\n  assumes nan: \"\\<And>x. is_nan x \\<Longrightarrow> P x\"\n  shows \"P a\"", "lemma infinite_infinity[simp]: \"\\<not> is_finite plus_infinity\" \"\\<not> is_finite minus_infinity\"", "lemma nan_not_finite[simp]: \"is_nan x \\<Longrightarrow> \\<not> is_finite x\"", "lemma valof_nonneg:\n  \"valof x \\<ge> 0\" if \"sign x = 0\" for x::\"('e, 'f)float\"", "lemma valof_nonpos:\n  \"valof x \\<le> 0\" if \"sign x = 1\" for x::\"('e, 'f)float\"", "lemma real_le_intI: \"x \\<le> y\" if \"floor x \\<le> floor y\" \"x \\<in> \\<int>\" for x y::real", "lemma real_of_int_le_2_powr_bitlenI:\n  \"real_of_int x \\<le> 2 powr n - 1\" if \"bitlen (abs x) \\<le> m\" \"m \\<le> n\"", "lemma largest_eq:\n  \"largest TYPE(('e, 'f)float) =\n    (2 ^ (LENGTH('f) + 1) - 1) * 2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\"", "lemma bitlen_denormal_mantissa:\n  \"bitlen (abs (denormal_mantissa x)) \\<le> LENGTH('f)\" for x::\"('e, 'f)float\"", "lemma float_le_topfloat:\n  fixes a::\"('e, 'f)float\"\n  assumes \"is_finite a\" \"LENGTH('e) > 1\"\n  shows \"a \\<le> topfloat\"", "lemma float_val_le_largest:\n  \"valof a \\<le> largest TYPE(('e, 'f)float)\"\n  if \"is_finite a\" \"LENGTH('e) > 1\"\n  for a::\"('e, 'f)float\"", "lemma float_val_lt_threshold:\n  \"valof a < threshold TYPE(('e, 'f)float)\"\n  if \"is_finite a\" \"LENGTH('e) > 1\"\n  for a::\"('e, 'f)float\"", "lemma\n  assumes \"is_finite a\" \"is_finite b\"\n  shows float_plus_comm_eq: \"a + b = b + a\"\n    and float_plus_comm: \"is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)\"", "lemma is_zero_uminus[simp]: \"is_zero (- a) \\<longleftrightarrow> is_zero a\"", "lemma is_infinity_uminus [simp]: \"is_infinity (- a) = is_infinity a\"", "lemma is_finite_uminus[simp]: \"is_finite (- a) \\<longleftrightarrow> is_finite a\"", "lemma is_nan_uminus[simp]: \"is_nan (- a) \\<longleftrightarrow> is_nan a\"", "lemma float_neg_sign: \"(sign a) \\<noteq> (sign (- a))\"", "lemma float_neg_sign1: \"sign a = sign (- b) \\<longleftrightarrow> sign a \\<noteq> sign b\"", "lemma valof_uminus:\n  assumes \"is_finite a\"\n  shows \"valof (- a) = - valof a\" (is \"?L = ?R\")", "lemma float_neg_add:\n  \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite (a - b) \\<Longrightarrow> valof a + valof (- b) = valof a - valof b\"", "lemma float_plus_minus:\n  assumes \"is_finite a\" \"is_finite b\" \"is_finite (a - b)\"\n  shows \"(a + - b) \\<doteq> (a - b)\"", "lemma finite_bottomfloat: \"is_finite bottomfloat\"", "lemma bottomfloat_eq_m_largest: \"valof (bottomfloat::('e, 'f)float) = - largest TYPE(('e, 'f)float)\"\n  if \"LENGTH('e) > 1\"", "lemma float_val_ge_bottomfloat: \"valof a \\<ge> valof (bottomfloat::('e, 'f)float)\"\n  if \"LENGTH('e) > 1\" \"is_finite a\"\n  for a::\"('e,'f)float\"", "lemma float_ge_bottomfloat: \"is_finite a \\<Longrightarrow> a \\<ge> bottomfloat\"\n  if \"LENGTH('e) > 1\" \"is_finite a\"\n  for a::\"('e,'f)float\"", "lemma float_val_ge_largest:\n  fixes a::\"('e,'f)float\"\n  assumes \"LENGTH('e) > 1\" \"is_finite a\"\n  shows \"valof a \\<ge> - largest TYPE(('e,'f)float)\"", "lemma float_val_gt_threshold:\n  fixes a::\"('e,'f)float\"\n  assumes \"LENGTH('e) > 1\" \"is_finite a\"\n  shows \"valof a > - threshold TYPE(('e,'f)float)\"", "lemma float_abs [simp]: \"\\<not> is_nan a \\<Longrightarrow> abs (- a) = abs a\"", "lemma neg_zerosign: \"- (zerosign s a) = zerosign (1 - s) (- a)\"", "lemma bound_at_worst_lemma:\n  fixes a::\"('e, 'f)float\"\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n  assumes finite: \"is_finite a\"\n  shows \"\\<bar>valof (round To_nearest x::('e, 'f)float) - x\\<bar> \\<le> \\<bar>valof a - x\\<bar>\"", "lemma error_at_worst_lemma:\n  fixes a::\"('e, 'f)float\"\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n    and \"is_finite a\"\n  shows \"\\<bar>error TYPE(('e, 'f)float) x\\<bar> \\<le> \\<bar>valof a - x\\<bar> \"", "lemma error_is_zero [simp]:\n  fixes a::\"('e, 'f)float\"\n  assumes \"is_finite a\" \"1 < LENGTH('e)\"\n  shows \"error TYPE(('e, 'f)float) (valof a) = 0\"", "lemma is_finite_zerosign[simp]: \"is_finite (zerosign s a) \\<longleftrightarrow> is_finite a\"", "lemma is_finite_closest: \"is_finite (closest (v::_\\<Rightarrow>real) p {a. is_finite a} x)\"", "lemma defloat_float_zerosign_round_finite:\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows \"is_finite (zerosign s (round To_nearest x::('e, 'f)float))\"", "lemma valof_zero[simp]: \"valof 0 = 0\" \"valof minus_zero = 0\"", "lemma signzero_zero:\n  \"is_zero a \\<Longrightarrow> valof (zerosign s a) = 0\"", "lemma val_zero: \"is_zero a \\<Longrightarrow> valof a = 0\"", "lemma float_add:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a + valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_add: \"is_finite (a + b)\"\n    and error_float_add:  \"valof (a + b) = valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b)\"", "lemma float_sub:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a - valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_sub: \"is_finite (a - b)\"\n    and error_float_sub: \"valof (a - b) = valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b)\"", "lemma float_mul:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a * valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_mul: \"is_finite (a * b)\"\n    and error_float_mul: \"valof (a * b) = valof a * valof b + error TYPE(('e, 'f)float) (valof a * valof b)\"", "lemma float_div:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and not_zero: \"\\<not> is_zero b\"\n    and threshold: \"\\<bar>valof a / valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_div: \"is_finite (a / b)\"\n    and error_float_div: \"valof (a / b) = valof a / valof b + error TYPE(('e, 'f)float) (valof a / valof b)\"", "lemma valof_one[simp]: \"valof (1::('e, 'f)float) = (if LENGTH('e) \\<le> 1 then 0 else 1)\""], "translations": [["", "lemma valof_eq:\n  \"valof x =\n    (if exponent x = 0\n       then (- 1) ^ sign x * (2 / 2 ^ bias TYPE(('a, 'b) float)) *\n            (real (fraction x) / 2 ^ LENGTH('b))\n       else (- 1) ^ sign x * (2 ^ exponent x / 2 ^ bias TYPE(('a, 'b) float)) *\n            (1 + real (fraction x) / 2 ^ LENGTH('b)))\"\n  for x::\"('a, 'b) float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof x =\n    (if IEEE.exponent x = 0\n     then (- 1) ^ sign x * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n          (real (fraction x) / 2 ^ LENGTH('b))\n     else (- 1) ^ sign x *\n          (2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n          (1 + real (fraction x) / 2 ^ LENGTH('b)))", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof x =\n    (if IEEE.exponent x = 0\n     then (- 1) ^ sign x * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n          (real (fraction x) / 2 ^ LENGTH('b))\n     else (- 1) ^ sign x *\n          (2 ^ IEEE.exponent x / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n          (1 + real (fraction x) / 2 ^ LENGTH('b)))", "by transfer (auto simp: bias_def divide_simps unat_eq_0)"], ["", "lemma exponent_le[simp]:\n  \"exponent a \\<le> unat (max_word::'a word)\" for a::\"('a, _)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent a \\<le> unat (- 1)", "by transfer (auto intro!: unat_mono simp: word_le_nat_alt[symmetric])"], ["", "lemma\n  max_word_le_exponent_iff[simp]:\n  \"unat (max_word::'a word) \\<le> exponent a \\<longleftrightarrow> unat (max_word::'a word) = exponent a\"\n  for a::\"('a, _)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (unat (- 1) \\<le> IEEE.exponent a) = (unat (- 1) = IEEE.exponent a)", "using le_antisym"], ["proof (prove)\nusing this:\n  \\<lbrakk>?m \\<le> ?n; ?n \\<le> ?m\\<rbrakk> \\<Longrightarrow> ?m = ?n\n\ngoal (1 subgoal):\n 1. (unat (- 1) \\<le> IEEE.exponent a) = (unat (- 1) = IEEE.exponent a)", "by fastforce"], ["", "lemma infinity_simps:\n  \"sign (plus_infinity::('e, 'f)float) = 0\"\n  \"sign (minus_infinity::('e, 'f)float) = 1\"\n  \"exponent (plus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)\"\n  \"exponent (minus_infinity::('e, 'f)float) = emax TYPE(('e, 'f)float)\"\n  \"fraction (plus_infinity::('e, 'f)float) = 0\"\n  \"fraction (minus_infinity::('e, 'f)float) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign \\<infinity> = 0 &&&\n     sign (- \\<infinity>) = 1 &&&\n     IEEE.exponent \\<infinity> = emax TYPE(('e, 'f) IEEE.float)) &&&\n    IEEE.exponent (- \\<infinity>) = emax TYPE(('e, 'f) IEEE.float) &&&\n    fraction \\<infinity> = 0 &&& fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign \\<infinity> = 0", "by transfer auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. sign (- \\<infinity>) = 1\n 2. IEEE.exponent \\<infinity> = emax TYPE(('e, 'f) IEEE.float)\n 3. IEEE.exponent (- \\<infinity>) = emax TYPE(('e, 'f) IEEE.float)\n 4. fraction \\<infinity> = 0\n 5. fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (- \\<infinity>) = 1", "by transfer auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. IEEE.exponent \\<infinity> = emax TYPE(('e, 'f) IEEE.float)\n 2. IEEE.exponent (- \\<infinity>) = emax TYPE(('e, 'f) IEEE.float)\n 3. fraction \\<infinity> = 0\n 4. fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent \\<infinity> = emax TYPE(('e, 'f) IEEE.float)", "by transfer (auto simp: emax_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. IEEE.exponent (- \\<infinity>) = emax TYPE(('e, 'f) IEEE.float)\n 2. fraction \\<infinity> = 0\n 3. fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (- \\<infinity>) = emax TYPE(('e, 'f) IEEE.float)", "by transfer (auto simp: emax_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. fraction \\<infinity> = 0\n 2. fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction \\<infinity> = 0", "by transfer auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- \\<infinity>) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- \\<infinity>) = 0", "by transfer auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma zero_simps:\n  \"sign (0::('e, 'f)float) = 0\"\n  \"sign (- 0::('e, 'f)float) = 1\"\n  \"exponent (0::('e, 'f)float) = 0\"\n  \"exponent (- 0::('e, 'f)float) = 0\"\n  \"fraction (0::('e, 'f)float) = 0\"\n  \"fraction (- 0::('e, 'f)float) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign 0 = 0 &&& sign (- 0) = 1 &&& IEEE.exponent 0 = 0) &&&\n    IEEE.exponent (- 0) = 0 &&& fraction 0 = 0 &&& fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign 0 = 0", "by transfer auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. sign (- 0) = 1\n 2. IEEE.exponent 0 = 0\n 3. IEEE.exponent (- 0) = 0\n 4. fraction 0 = 0\n 5. fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (- 0) = 1", "by transfer auto"], ["proof (prove)\ngoal (4 subgoals):\n 1. IEEE.exponent 0 = 0\n 2. IEEE.exponent (- 0) = 0\n 3. fraction 0 = 0\n 4. fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent 0 = 0", "by transfer auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. IEEE.exponent (- 0) = 0\n 2. fraction 0 = 0\n 3. fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (- 0) = 0", "by transfer auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. fraction 0 = 0\n 2. fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction 0 = 0", "by transfer auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- 0) = 0", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- 0) = 0", "by transfer auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma emax_eq: \"emax x = 2^LENGTH('e) - 1\"\n  for x::\"('e, 'f)float itself\""], ["proof (prove)\ngoal (1 subgoal):\n 1. emax x = 2 ^ LENGTH('e) - 1", "by (simp add: emax_def unat_minus_one_word)"], ["", "lemma topfloat_simps:\n  \"sign (topfloat::('e, 'f)float) = 0\"\n  \"exponent (topfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1\"\n  \"fraction (topfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1\"\n  and bottomfloat_simps:\n  \"sign (bottomfloat::('e, 'f)float) = 1\"\n  \"exponent (bottomfloat::('e, 'f)float) = emax TYPE(('e, 'f)float) - 1\"\n  \"fraction (bottomfloat::('e, 'f)float) = 2^fracwidth TYPE(('e, 'f)float) - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign topfloat = 0 &&&\n     IEEE.exponent topfloat = emax TYPE(('e, 'f) IEEE.float) - 1 &&&\n     fraction topfloat = 2 ^ LENGTH('f) - 1) &&&\n    sign (- topfloat) = 1 &&&\n    IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1 &&&\n    fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign topfloat = 0", "by transfer simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. IEEE.exponent topfloat = emax TYPE(('e, 'f) IEEE.float) - 1\n 2. fraction topfloat = 2 ^ LENGTH('f) - 1\n 3. sign (- topfloat) = 1\n 4. IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1\n 5. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent topfloat = emax TYPE(('e, 'f) IEEE.float) - 1", "by transfer (simp add: emax_eq take_bit_minus_small_eq\n    nat_diff_distrib nat_power_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. fraction topfloat = 2 ^ LENGTH('f) - 1\n 2. sign (- topfloat) = 1\n 3. IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1\n 4. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction topfloat = 2 ^ LENGTH('f) - 1", "by transfer (simp add: unat_minus_one_word)"], ["proof (prove)\ngoal (3 subgoals):\n 1. sign (- topfloat) = 1\n 2. IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1\n 3. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (- topfloat) = 1", "by transfer simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1\n 2. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (- topfloat) = emax TYPE(('e, 'f) IEEE.float) - 1", "by transfer (simp add: emax_eq take_bit_minus_small_eq\n    unat_minus_one_word nat_diff_distrib nat_power_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- topfloat) = 2 ^ LENGTH('f) - 1", "by transfer (simp add: unat_minus_one_word)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas float_defs =\n  is_finite_def is_infinity_def is_zero_def is_nan_def\n  is_normal_def is_denormal_def valof_eq\n  less_eq_float_def less_float_def\n  flt_def fgt_def fle_def fge_def feq_def\n  fcompare_def\n  infinity_simps\n  zero_simps\n  topfloat_simps\n  bottomfloat_simps\n  float_eq_def"], ["", "lemma float_cases: \"is_nan a \\<or> is_infinity a \\<or> is_normal a \\<or> is_denormal a \\<or> is_zero a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan a \\<or>\n    is_infinity a \\<or> is_normal a \\<or> is_denormal a \\<or> is_zero a", "by (auto simp: emax_def float_defs not_less)"], ["", "lemma float_cases_finite: \"is_nan a \\<or> is_infinity a \\<or> is_finite a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan a \\<or> is_infinity a \\<or> is_finite a", "by (simp add: float_cases is_finite_def)"], ["", "lemma float_zero1[simp]: \"is_zero 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero 0", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = 0 \\<and> 0 = 0", "by transfer auto"], ["", "lemma float_zero2[simp]: \"is_zero (- x) \\<longleftrightarrow> is_zero x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero (- x) = is_zero x", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. (IEEE.exponent (- x) = 0 \\<and> fraction (- x) = 0) =\n    (IEEE.exponent x = 0 \\<and> fraction x = 0)", "by transfer auto"], ["", "lemma emax_pos[simp]: \"0 < emax x\" \"emax x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < emax x &&& emax x \\<noteq> 0", "by (auto simp: emax_def)"], ["", "text \\<open>The types of floating-point numbers are mutually distinct.\\<close>"], ["", "lemma float_distinct:\n  \"\\<not> (is_nan a \\<and> is_infinity a)\"\n  \"\\<not> (is_nan a \\<and> is_normal a)\"\n  \"\\<not> (is_nan a \\<and> is_denormal a)\"\n  \"\\<not> (is_nan a \\<and> is_zero a)\"\n  \"\\<not> (is_infinity a \\<and> is_normal a)\"\n  \"\\<not> (is_infinity a \\<and> is_denormal a)\"\n  \"\\<not> (is_infinity a \\<and> is_zero a)\"\n  \"\\<not> (is_normal a \\<and> is_denormal a)\"\n  \"\\<not> (is_denormal a \\<and> is_zero a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<not> (is_nan a \\<and> is_infinity a) &&&\n      \\<not> (is_nan a \\<and> is_normal a)) &&&\n     \\<not> (is_nan a \\<and> is_denormal a) &&&\n     \\<not> (is_nan a \\<and> is_zero a)) &&&\n    (\\<not> (is_infinity a \\<and> is_normal a) &&&\n     \\<not> (is_infinity a \\<and> is_denormal a)) &&&\n    \\<not> (is_infinity a \\<and> is_zero a) &&&\n    \\<not> (is_normal a \\<and> is_denormal a) &&&\n    \\<not> (is_denormal a \\<and> is_zero a)", "by (auto simp: float_defs)"], ["", "lemma denormal_imp_not_zero: \"is_denormal f \\<Longrightarrow> \\<not>is_zero f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_denormal f \\<Longrightarrow> \\<not> is_zero f", "by (simp add: is_denormal_def is_zero_def)"], ["", "lemma normal_imp_not_zero: \"is_normal f \\<Longrightarrow> \\<not>is_zero f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal f \\<Longrightarrow> \\<not> is_zero f", "by (simp add: is_normal_def is_zero_def)"], ["", "lemma normal_imp_not_denormal: \"is_normal f \\<Longrightarrow> \\<not>is_denormal f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal f \\<Longrightarrow> \\<not> is_denormal f", "by (simp add: is_normal_def is_denormal_def)"], ["", "lemma denormal_zero[simp]: \"\\<not>is_denormal 0\" \"\\<not>is_denormal minus_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_denormal 0 &&& \\<not> is_denormal (- 0)", "using denormal_imp_not_zero float_zero1 float_zero2"], ["proof (prove)\nusing this:\n  is_denormal ?f \\<Longrightarrow> \\<not> is_zero ?f\n  is_zero 0\n  is_zero (- ?x) = is_zero ?x\n\ngoal (1 subgoal):\n 1. \\<not> is_denormal 0 &&& \\<not> is_denormal (- 0)", "by blast+"], ["", "lemma normal_zero[simp]: \"\\<not>is_normal 0\" \"\\<not>is_normal minus_zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_normal 0 &&& \\<not> is_normal (- 0)", "using normal_imp_not_zero float_zero1 float_zero2"], ["proof (prove)\nusing this:\n  is_normal ?f \\<Longrightarrow> \\<not> is_zero ?f\n  is_zero 0\n  is_zero (- ?x) = is_zero ?x\n\ngoal (1 subgoal):\n 1. \\<not> is_normal 0 &&& \\<not> is_normal (- 0)", "by blast+"], ["", "lemma float_distinct_finite: \"\\<not> (is_nan a \\<and> is_finite a)\" \"\\<not>(is_infinity a \\<and> is_finite a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (is_nan a \\<and> is_finite a) &&&\n    \\<not> (is_infinity a \\<and> is_finite a)", "by (auto simp: float_defs)"], ["", "lemma finite_infinity: \"is_finite a \\<Longrightarrow> \\<not> is_infinity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite a \\<Longrightarrow> \\<not> is_infinity a", "by (auto simp: float_defs)"], ["", "lemma finite_nan: \"is_finite a \\<Longrightarrow> \\<not> is_nan a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite a \\<Longrightarrow> \\<not> is_nan a", "by (auto simp: float_defs)"], ["", "text \\<open>For every real number, the floating-point numbers closest to it always exist.\\<close>"], ["", "lemma is_closest_exists:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n    and s :: \"('e, 'f)float set\"\n  assumes finite: \"finite s\"\n    and non_empty: \"s \\<noteq> {}\"\n  shows \"\\<exists>a. is_closest v s x a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v s x a", "using finite non_empty"], ["proof (prove)\nusing this:\n  finite s\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v s x a", "proof (induct s rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Ex (is_closest v {} x)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex (is_closest v F x);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex (is_closest v (insert xa F) x)", "case empty"], ["proof (state)\nthis:\n  {} \\<noteq> {}\n\ngoal (2 subgoals):\n 1. {} \\<noteq> {} \\<Longrightarrow> Ex (is_closest v {} x)\n 2. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex (is_closest v F x);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex (is_closest v (insert xa F) x)", "then"], ["proof (chain)\npicking this:\n  {} \\<noteq> {}", "show ?case"], ["proof (prove)\nusing this:\n  {} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v {} x a", "by simp"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v {} x a\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex (is_closest v F x);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex (is_closest v (insert xa F) x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex (is_closest v F x);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex (is_closest v (insert xa F) x)", "case (insert z s)"], ["proof (state)\nthis:\n  finite s\n  z \\<notin> s\n  s \\<noteq> {} \\<Longrightarrow> \\<exists>a. is_closest v s x a\n  insert z s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa F.\n       \\<lbrakk>finite F; xa \\<notin> F;\n        F \\<noteq> {} \\<Longrightarrow> Ex (is_closest v F x);\n        insert xa F \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> Ex (is_closest v (insert xa F) x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "proof (cases \"s = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s = {} \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a\n 2. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "case True"], ["proof (state)\nthis:\n  s = {}\n\ngoal (2 subgoals):\n 1. s = {} \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a\n 2. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  s = {}", "have \"is_closest v (insert z s) x z\""], ["proof (prove)\nusing this:\n  s = {}\n\ngoal (1 subgoal):\n 1. is_closest v (insert z s) x z", "by (auto simp: is_closest_def)"], ["proof (state)\nthis:\n  is_closest v (insert z s) x z\n\ngoal (2 subgoals):\n 1. s = {} \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a\n 2. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  is_closest v (insert z s) x z", "show ?thesis"], ["proof (prove)\nusing this:\n  is_closest v (insert z s) x z\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "by metis"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v (insert z s) x a\n\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "case False"], ["proof (state)\nthis:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  s \\<noteq> {}", "obtain a where a: \"is_closest v s x a\""], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. is_closest v s x a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using insert"], ["proof (prove)\nusing this:\n  s \\<noteq> {}\n  finite s\n  z \\<notin> s\n  s \\<noteq> {} \\<Longrightarrow> \\<exists>a. is_closest v s x a\n  insert z s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a. is_closest v s x a \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  is_closest v s x a\n\ngoal (1 subgoal):\n 1. s \\<noteq> {} \\<Longrightarrow>\n    \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  is_closest v s x a", "show ?thesis"], ["proof (prove)\nusing this:\n  is_closest v s x a\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "proof (cases \"\\<bar>v a - x\\<bar>\" \"\\<bar>v z - x\\<bar>\" rule: le_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v a - x\\<bar> \\<le> \\<bar>v z - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a\n 2. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "case le"], ["proof (state)\nthis:\n  \\<bar>v a - x\\<bar> \\<le> \\<bar>v z - x\\<bar>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v a - x\\<bar> \\<le> \\<bar>v z - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a\n 2. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  \\<bar>v a - x\\<bar> \\<le> \\<bar>v z - x\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>v a - x\\<bar> \\<le> \\<bar>v z - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "by (metis insert_iff a is_closest_def)"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v (insert z s) x a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "case ge"], ["proof (state)\nthis:\n  \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "have \"\\<forall>b. b \\<in> s \\<longrightarrow> \\<bar>v a - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in> s \\<longrightarrow>\n       \\<bar>v a - x\\<bar> \\<le> \\<bar>v b - x\\<bar>", "by (metis a is_closest_def)"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<in> s \\<longrightarrow>\n     \\<bar>v a - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  \\<forall>b.\n     b \\<in> s \\<longrightarrow>\n     \\<bar>v a - x\\<bar> \\<le> \\<bar>v b - x\\<bar>", "have \"\\<forall>b. b \\<in> insert z s \\<longrightarrow> \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\""], ["proof (prove)\nusing this:\n  \\<forall>b.\n     b \\<in> s \\<longrightarrow>\n     \\<bar>v a - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       b \\<in> insert z s \\<longrightarrow>\n       \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>", "by (metis eq_iff ge insert_iff order.trans)"], ["proof (state)\nthis:\n  \\<forall>b.\n     b \\<in> insert z s \\<longrightarrow>\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_closest v s x a;\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v a - x\\<bar>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. is_closest v (insert z s) x a", "then"], ["proof (chain)\npicking this:\n  \\<forall>b.\n     b \\<in> insert z s \\<longrightarrow>\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>b.\n     b \\<in> insert z s \\<longrightarrow>\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "using is_closest_def a"], ["proof (prove)\nusing this:\n  \\<forall>b.\n     b \\<in> insert z s \\<longrightarrow>\n     \\<bar>v z - x\\<bar> \\<le> \\<bar>v b - x\\<bar>\n  is_closest ?v ?s ?x ?a =\n  (?a \\<in> ?s \\<and>\n   (\\<forall>b.\n       b \\<in> ?s \\<longrightarrow>\n       \\<bar>?v ?a - ?x\\<bar> \\<le> \\<bar>?v b - ?x\\<bar>))\n  is_closest v s x a\n\ngoal (1 subgoal):\n 1. \\<exists>a. is_closest v (insert z s) x a", "by (metis insertI1)"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v (insert z s) x a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v (insert z s) x a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. is_closest v (insert z s) x a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closest_is_everything:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n    and s :: \"('e, 'f)float set\"\n  assumes finite: \"finite s\"\n    and non_empty: \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x) \\<and>\n    ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow> p (closest v p s x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closest v s x (closest v p s x) \\<and>\n    ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow>\n     p (closest v p s x))", "unfolding closest_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closest v s x\n     (SOME a.\n         is_closest v s x a \\<and>\n         ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow>\n          p a)) \\<and>\n    ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow>\n     p (SOME a.\n           is_closest v s x a \\<and>\n           ((\\<exists>b. is_closest v s x b \\<and> p b) \\<longrightarrow>\n            p a)))", "by (rule someI_ex) (metis assms is_closest_exists [of s v x])"], ["", "lemma closest_in_set:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"finite s\" and \"s \\<noteq> {}\"\n  shows \"closest v p s x \\<in> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closest v p s x \\<in> s", "by (metis assms closest_is_everything is_closest_def)"], ["", "lemma closest_is_closest_finite:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"finite s\" and \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closest v s x (closest v p s x)", "by (metis closest_is_everything assms)"], ["", "instance float::(len, len) finite"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) IEEE.float, finite_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. finite UNIV", "qed (transfer, simp)"], ["", "lemma is_finite_nonempty: \"{a. is_finite a} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. is_finite a} \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {a. is_finite a} \\<noteq> {}", "have \"0 \\<in> {a. is_finite a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {a. is_finite a}", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<in> {a. 0 < IEEE.exponent a \\<and>\n                IEEE.exponent a < emax TYPE(('c, 'd) IEEE.float) \\<or>\n                IEEE.exponent a = 0 \\<and> fraction a \\<noteq> 0 \\<or>\n                IEEE.exponent a = 0 \\<and> fraction a = 0}", "by transfer auto"], ["proof (state)\nthis:\n  0 \\<in> {a. is_finite a}\n\ngoal (1 subgoal):\n 1. {a. is_finite a} \\<noteq> {}", "then"], ["proof (chain)\npicking this:\n  0 \\<in> {a. is_finite a}", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<in> {a. is_finite a}\n\ngoal (1 subgoal):\n 1. {a. is_finite a} \\<noteq> {}", "by (metis empty_iff)"], ["proof (state)\nthis:\n  {a. is_finite a} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma closest_is_closest:\n  fixes v :: \"('e, 'f)float \\<Rightarrow> real\"\n  assumes \"s \\<noteq> {}\"\n  shows \"is_closest v s x (closest v p s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closest v s x (closest v p s x)", "by (rule closest_is_closest_finite) (auto simp: assms)"], ["", "subsection \\<open>Properties about ordering and bounding\\<close>"], ["", "text \\<open>Lifting of non-exceptional comparisons.\\<close>"], ["", "lemma float_lt [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a < b \\<longleftrightarrow> valof a < valof b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a < b) = (valof a < valof b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> valof a < valof b\n 2. valof a < valof b \\<Longrightarrow> a < b", "assume \"valof a < valof b\""], ["proof (state)\nthis:\n  valof a < valof b\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> valof a < valof b\n 2. valof a < valof b \\<Longrightarrow> a < b", "moreover"], ["proof (state)\nthis:\n  valof a < valof b\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> valof a < valof b\n 2. valof a < valof b \\<Longrightarrow> a < b", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by (auto simp: finite_nan finite_infinity)"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> valof a < valof b\n 2. valof a < valof b \\<Longrightarrow> a < b", "ultimately"], ["proof (chain)\npicking this:\n  valof a < valof b\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "have \"fcompare a b = Lt\""], ["proof (prove)\nusing this:\n  valof a < valof b\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. fcompare a b = Lt", "by (auto simp add: is_infinity_def is_nan_def valof_def fcompare_def)"], ["proof (state)\nthis:\n  fcompare a b = Lt\n\ngoal (2 subgoals):\n 1. a < b \\<Longrightarrow> valof a < valof b\n 2. valof a < valof b \\<Longrightarrow> a < b", "then"], ["proof (chain)\npicking this:\n  fcompare a b = Lt", "show \"a < b\""], ["proof (prove)\nusing this:\n  fcompare a b = Lt\n\ngoal (1 subgoal):\n 1. a < b", "by (auto simp: float_defs)"], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> valof a < valof b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> valof a < valof b", "assume \"a < b\""], ["proof (state)\nthis:\n  a < b\n\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> valof a < valof b", "then"], ["proof (chain)\npicking this:\n  a < b", "have lt: \"fcompare a b = Lt\""], ["proof (prove)\nusing this:\n  a < b\n\ngoal (1 subgoal):\n 1. fcompare a b = Lt", "by (simp add: float_defs)"], ["proof (state)\nthis:\n  fcompare a b = Lt\n\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> valof a < valof b", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by (auto simp: finite_nan finite_infinity)"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a < b \\<Longrightarrow> valof a < valof b", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "show \"valof a < valof b\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. valof a < valof b", "using lt assms"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n  fcompare a b = Lt\n  is_finite a\n  is_finite b\n\ngoal (1 subgoal):\n 1. valof a < valof b", "by (simp add: fcompare_def is_nan_def is_infinity_def valof_def split: if_split_asm)"], ["proof (state)\nthis:\n  valof a < valof b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_eq [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a \\<doteq> b \\<longleftrightarrow> valof a = valof b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<doteq> b = (valof a = valof b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b\n 2. valof a = valof b \\<Longrightarrow> a \\<doteq> b", "assume *: \"valof a = valof b\""], ["proof (state)\nthis:\n  valof a = valof b\n\ngoal (2 subgoals):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b\n 2. valof a = valof b \\<Longrightarrow> a \\<doteq> b", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms float_distinct_finite"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<not> (is_nan ?a \\<and> is_finite ?a)\n  \\<not> (is_infinity ?a \\<and> is_finite ?a)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by auto"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b\n 2. valof a = valof b \\<Longrightarrow> a \\<doteq> b", "with *"], ["proof (chain)\npicking this:\n  valof a = valof b\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "have \"fcompare a b = Eq\""], ["proof (prove)\nusing this:\n  valof a = valof b\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. fcompare a b = Eq", "by (auto simp add: is_infinity_def is_nan_def valof_def fcompare_def)"], ["proof (state)\nthis:\n  fcompare a b = Eq\n\ngoal (2 subgoals):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b\n 2. valof a = valof b \\<Longrightarrow> a \\<doteq> b", "then"], ["proof (chain)\npicking this:\n  fcompare a b = Eq", "show \"a \\<doteq> b\""], ["proof (prove)\nusing this:\n  fcompare a b = Eq\n\ngoal (1 subgoal):\n 1. a \\<doteq> b", "by (auto simp: float_defs)"], ["proof (state)\nthis:\n  a \\<doteq> b\n\ngoal (1 subgoal):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b", "assume \"a \\<doteq> b\""], ["proof (state)\nthis:\n  a \\<doteq> b\n\ngoal (1 subgoal):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b", "then"], ["proof (chain)\npicking this:\n  a \\<doteq> b", "have eq: \"fcompare a b = Eq\""], ["proof (prove)\nusing this:\n  a \\<doteq> b\n\ngoal (1 subgoal):\n 1. fcompare a b = Eq", "by (simp add: float_defs)"], ["proof (state)\nthis:\n  fcompare a b = Eq\n\ngoal (1 subgoal):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms float_distinct_finite"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<not> (is_nan ?a \\<and> is_finite ?a)\n  \\<not> (is_infinity ?a \\<and> is_finite ?a)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by auto"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a \\<doteq> b \\<Longrightarrow> valof a = valof b", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "show \"valof a = valof b\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. valof a = valof b", "using eq assms"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n  fcompare a b = Eq\n  is_finite a\n  is_finite b\n\ngoal (1 subgoal):\n 1. valof a = valof b", "by (simp add: fcompare_def is_nan_def is_infinity_def valof_def split: if_split_asm)"], ["proof (state)\nthis:\n  valof a = valof b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_le [simp]:\n  assumes \"is_finite a\" \"is_finite b\"\n  shows \"a \\<le> b \\<longleftrightarrow> valof a \\<le> valof b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b) = (valof a \\<le> valof b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a \\<le> b) = (valof a \\<le> valof b)", "have \"a \\<le> b \\<longleftrightarrow>  a < b \\<or> a \\<doteq> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<le> b) = (a < b \\<or> a \\<doteq> b)", "by (auto simp add: float_defs)"], ["proof (state)\nthis:\n  (a \\<le> b) = (a < b \\<or> a \\<doteq> b)\n\ngoal (1 subgoal):\n 1. (a \\<le> b) = (valof a \\<le> valof b)", "then"], ["proof (chain)\npicking this:\n  (a \\<le> b) = (a < b \\<or> a \\<doteq> b)", "show ?thesis"], ["proof (prove)\nusing this:\n  (a \\<le> b) = (a < b \\<or> a \\<doteq> b)\n\ngoal (1 subgoal):\n 1. (a \\<le> b) = (valof a \\<le> valof b)", "by (auto simp add: assms)"], ["proof (state)\nthis:\n  (a \\<le> b) = (valof a \\<le> valof b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Reflexivity of equality for non-NaNs.\\<close>"], ["", "lemma float_eq_refl [simp]: \"a \\<doteq> a \\<longleftrightarrow> \\<not> is_nan a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<doteq> a = (\\<not> is_nan a)", "by (auto simp: float_defs)"], ["", "text \\<open>Properties about Ordering.\\<close>"], ["", "lemma float_lt_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a < b \\<Longrightarrow> b < c \\<Longrightarrow> a < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_finite a; is_finite b; is_finite c; a < b; b < c\\<rbrakk>\n    \\<Longrightarrow> a < c", "by (auto simp: le_trans)"], ["", "lemma float_le_less_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a \\<le> b \\<Longrightarrow> b < c \\<Longrightarrow> a < c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_finite a; is_finite b; is_finite c; a \\<le> b;\n     b < c\\<rbrakk>\n    \\<Longrightarrow> a < c", "by (auto simp: le_trans)"], ["", "lemma float_le_trans: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite c \\<Longrightarrow> a \\<le> b \\<Longrightarrow> b \\<le> c \\<Longrightarrow> a \\<le> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_finite a; is_finite b; is_finite c; a \\<le> b;\n     b \\<le> c\\<rbrakk>\n    \\<Longrightarrow> a \\<le> c", "by (auto simp: le_trans)"], ["", "lemma float_le_neg: \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> \\<not> a < b \\<longleftrightarrow> b \\<le> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_finite a; is_finite b\\<rbrakk>\n    \\<Longrightarrow> (\\<not> a < b) = (b \\<le> a)", "by auto"], ["", "text \\<open>Properties about bounding.\\<close>"], ["", "lemma float_le_infinity [simp]: \"\\<not> is_nan a \\<Longrightarrow> a \\<le> plus_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_nan a \\<Longrightarrow> a \\<le> \\<infinity>", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n            fraction a \\<noteq> 0) \\<Longrightarrow>\n    (if IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n        fraction a \\<noteq> 0 \\<or>\n        emax TYPE(('a, 'b) IEEE.float) =\n        emax TYPE(('a, 'b) IEEE.float) \\<and>\n        0 \\<noteq> 0\n     then Und\n     else if (IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n              fraction a = 0) \\<and>\n             sign a = 1\n          then if (emax TYPE(('a, 'b) IEEE.float) =\n                   emax TYPE(('a, 'b) IEEE.float) \\<and>\n                   0 = 0) \\<and>\n                  0 = 1\n               then Eq else Lt\n          else if (IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n                   fraction a = 0) \\<and>\n                  sign a = 0\n               then if (emax TYPE(('a, 'b) IEEE.float) =\n                        emax TYPE(('a, 'b) IEEE.float) \\<and>\n                        0 = 0) \\<and>\n                       0 = 0\n                    then Eq else Gt\n               else if (emax TYPE(('a, 'b) IEEE.float) =\n                        emax TYPE(('a, 'b) IEEE.float) \\<and>\n                        0 = 0) \\<and>\n                       0 = 1\n                    then Gt\n                    else if (emax TYPE(('a, 'b) IEEE.float) =\n                             emax TYPE(('a, 'b) IEEE.float) \\<and>\n                             0 = 0) \\<and>\n                            0 = 0\n                         then Lt\n                         else if (if IEEE.exponent a = 0\n                                  then (- 1) ^ sign a *\n (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n (real (fraction a) / 2 ^ LENGTH('b))\n                                  else (- 1) ^ sign a *\n (2 ^ IEEE.exponent a / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n (1 + real (fraction a) / 2 ^ LENGTH('b)))\n                                 < (if emax TYPE(('a, 'b) IEEE.float) = 0\n                                    then (- 1) ^ 0 *\n   (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n   (real 0 / 2 ^ LENGTH('b))\n                                    else (- 1) ^ 0 *\n   (2 ^ emax TYPE(('a, 'b) IEEE.float) /\n    2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n   (1 + real 0 / 2 ^ LENGTH('b)))\n                              then Lt\n                              else if (if IEEE.exponent a = 0\n then (- 1) ^ sign a * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (real (fraction a) / 2 ^ LENGTH('b))\n else (- 1) ^ sign a *\n      (2 ^ IEEE.exponent a / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (1 + real (fraction a) / 2 ^ LENGTH('b))) =\n(if emax TYPE(('a, 'b) IEEE.float) = 0\n then (- 1) ^ 0 * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (real 0 / 2 ^ LENGTH('b))\n else (- 1) ^ 0 *\n      (2 ^ emax TYPE(('a, 'b) IEEE.float) /\n       2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (1 + real 0 / 2 ^ LENGTH('b)))\n                                   then Eq else Gt) =\n    Lt \\<or>\n    (if IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n        fraction a \\<noteq> 0 \\<or>\n        emax TYPE(('a, 'b) IEEE.float) =\n        emax TYPE(('a, 'b) IEEE.float) \\<and>\n        0 \\<noteq> 0\n     then Und\n     else if (IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n              fraction a = 0) \\<and>\n             sign a = 1\n          then if (emax TYPE(('a, 'b) IEEE.float) =\n                   emax TYPE(('a, 'b) IEEE.float) \\<and>\n                   0 = 0) \\<and>\n                  0 = 1\n               then Eq else Lt\n          else if (IEEE.exponent a = emax TYPE(('a, 'b) IEEE.float) \\<and>\n                   fraction a = 0) \\<and>\n                  sign a = 0\n               then if (emax TYPE(('a, 'b) IEEE.float) =\n                        emax TYPE(('a, 'b) IEEE.float) \\<and>\n                        0 = 0) \\<and>\n                       0 = 0\n                    then Eq else Gt\n               else if (emax TYPE(('a, 'b) IEEE.float) =\n                        emax TYPE(('a, 'b) IEEE.float) \\<and>\n                        0 = 0) \\<and>\n                       0 = 1\n                    then Gt\n                    else if (emax TYPE(('a, 'b) IEEE.float) =\n                             emax TYPE(('a, 'b) IEEE.float) \\<and>\n                             0 = 0) \\<and>\n                            0 = 0\n                         then Lt\n                         else if (if IEEE.exponent a = 0\n                                  then (- 1) ^ sign a *\n (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n (real (fraction a) / 2 ^ LENGTH('b))\n                                  else (- 1) ^ sign a *\n (2 ^ IEEE.exponent a / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n (1 + real (fraction a) / 2 ^ LENGTH('b)))\n                                 < (if emax TYPE(('a, 'b) IEEE.float) = 0\n                                    then (- 1) ^ 0 *\n   (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n   (real 0 / 2 ^ LENGTH('b))\n                                    else (- 1) ^ 0 *\n   (2 ^ emax TYPE(('a, 'b) IEEE.float) /\n    2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n   (1 + real 0 / 2 ^ LENGTH('b)))\n                              then Lt\n                              else if (if IEEE.exponent a = 0\n then (- 1) ^ sign a * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (real (fraction a) / 2 ^ LENGTH('b))\n else (- 1) ^ sign a *\n      (2 ^ IEEE.exponent a / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (1 + real (fraction a) / 2 ^ LENGTH('b))) =\n(if emax TYPE(('a, 'b) IEEE.float) = 0\n then (- 1) ^ 0 * (2 / 2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (real 0 / 2 ^ LENGTH('b))\n else (- 1) ^ 0 *\n      (2 ^ emax TYPE(('a, 'b) IEEE.float) /\n       2 ^ bias TYPE(('a, 'b) IEEE.float)) *\n      (1 + real 0 / 2 ^ LENGTH('b)))\n                                   then Eq else Gt) =\n    Eq", "by auto"], ["", "lemma zero_le_topfloat[simp]: \"0 \\<le> topfloat\" \"- 0 \\<le> topfloat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> topfloat &&& - 0 \\<le> topfloat", "by (auto simp: float_defs field_simps power_gt1_lemma of_nat_diff)"], ["", "lemma LENGTH_contr:\n  \"Suc 0 < LENGTH('e) \\<Longrightarrow> 2 ^ LENGTH('e::len) \\<le> Suc (Suc 0) \\<Longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Suc 0 < LENGTH('e); 2 ^ LENGTH('e) \\<le> Suc (Suc 0)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis le_antisym len_gt_0 n_less_equal_power_2 not_less_eq numeral_2_eq_2 one_le_numeral\n      self_le_power)"], ["", "lemma valof_topfloat: \"valof (topfloat::('e, 'f)float) = largest TYPE(('e, 'f)float)\"\n  if \"LENGTH('e) > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof topfloat = largest TYPE(('e, 'f) IEEE.float)", "using that LENGTH_contr"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n  \\<lbrakk>Suc 0 < LENGTH(?'e); 2 ^ LENGTH(?'e) \\<le> Suc (Suc 0)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. valof topfloat = largest TYPE(('e, 'f) IEEE.float)", "by (auto simp add: emax_eq largest_def divide_simps float_defs of_nat_diff)"], ["", "lemma float_frac_le: \"fraction a \\<le> 2^LENGTH('f) - 1\"\n  for a::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction a \\<le> 2 ^ LENGTH('f) - 1", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction a \\<le> 2 ^ LENGTH('f) - 1", "using less_Suc_eq_le"], ["proof (prove)\nusing this:\n  (?m < Suc ?n) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. fraction a \\<le> 2 ^ LENGTH('f) - 1", "by transfer fastforce"], ["", "lemma float_exp_le: \"is_finite a \\<Longrightarrow> exponent a \\<le> emax TYPE(('e, 'f)float) - 1\"\n  for a::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite a \\<Longrightarrow>\n    IEEE.exponent a \\<le> emax TYPE(('e, 'f) IEEE.float) - 1", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < IEEE.exponent a \\<and>\n    IEEE.exponent a < emax TYPE(('e, 'f) IEEE.float) \\<or>\n    IEEE.exponent a = 0 \\<and> fraction a \\<noteq> 0 \\<or>\n    IEEE.exponent a = 0 \\<and> fraction a = 0 \\<Longrightarrow>\n    IEEE.exponent a \\<le> emax TYPE(('e, 'f) IEEE.float) - 1", "by auto"], ["", "lemma float_sign_le: \"(-1::real)^(sign a) = 1 \\<or> (-1::real)^(sign a) = -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ sign a = 1 \\<or> (- 1) ^ sign a = - 1", "by (metis neg_one_even_power neg_one_odd_power)"], ["", "lemma exp_less: \"a \\<le> b \\<Longrightarrow> (2::real)^a \\<le> 2^b\" for a b :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<Longrightarrow> 2 ^ a \\<le> 2 ^ b", "by auto"], ["", "lemma div_less: \"a \\<le> b \\<and> c > 0 \\<Longrightarrow> a/c \\<le> b/c\" for a b c :: \"'a::linordered_field\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> b \\<and> (0::'a) < c \\<Longrightarrow> a / c \\<le> b / c", "by (metis divide_le_cancel less_asym)"], ["", "lemma finite_topfloat: \"is_finite topfloat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite topfloat", "unfolding float_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < emax TYPE(('a, 'b) IEEE.float) - 1 \\<and>\n    emax TYPE(('a, 'b) IEEE.float) - 1\n    < emax TYPE(('a, 'b) IEEE.float) \\<or>\n    emax TYPE(('a, 'b) IEEE.float) - 1 = 0 \\<and>\n    2 ^ LENGTH('b) - 1 \\<noteq> 0 \\<or>\n    emax TYPE(('a, 'b) IEEE.float) - 1 = 0 \\<and> 2 ^ LENGTH('b) - 1 = 0", "by auto"], ["", "lemmas float_leI = float_le[THEN iffD2]"], ["", "lemma factor_minus: \"x * a - x = x * (a - 1)\"\n  for x a::\"'a::comm_semiring_1_cancel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * a - x = x * (a - (1::'a))", "by (simp add: algebra_simps)"], ["", "lemma real_le_power_numeral_diff: \"real a \\<le> numeral b ^ n - 1 \\<longleftrightarrow> a \\<le> numeral b ^ n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real a \\<le> numeral b ^ n - 1) = (a \\<le> numeral b ^ n - 1)", "by (metis (mono_tags, lifting) of_nat_1 of_nat_diff of_nat_le_iff of_nat_numeral\n      one_le_numeral one_le_power semiring_1_class.of_nat_power)"], ["", "definition denormal_exponent::\"('e, 'f)float itself \\<Rightarrow> int\" where\n  \"denormal_exponent x = 1 - (int (LENGTH('f)) + int (bias TYPE(('e, 'f)float)))\""], ["", "definition normal_exponent::\"('e, 'f)float \\<Rightarrow> int\" where\n  \"normal_exponent x = int (exponent x) - int (bias TYPE(('e, 'f)float)) - int (LENGTH('f))\""], ["", "definition denormal_mantissa::\"('e, 'f)float \\<Rightarrow> int\" where\n  \"denormal_mantissa x = (-1::int)^sign x * int (fraction x)\""], ["", "definition normal_mantissa::\"('e, 'f)float \\<Rightarrow> int\" where\n  \"normal_mantissa x = (-1::int)^sign x * (2^LENGTH('f) + int (fraction x))\""], ["", "lemma unat_one_word_le: \"unat a \\<le> Suc 0\" for a::\"1 word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unat a \\<le> Suc 0", "using unat_lt2p[of a]"], ["proof (prove)\nusing this:\n  unat a < 2 ^ LENGTH(1)\n\ngoal (1 subgoal):\n 1. unat a \\<le> Suc 0", "by auto"], ["", "lemma one_word_le: \"a \\<le> 1\" for a::\"1 word\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> 1", "by (auto simp: word_le_nat_alt unat_one_word_le)"], ["", "lemma sign_cases[case_names pos neg]:\n  obtains \"sign x = 0\" | \"sign x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x = 0\""], ["proof (state)\nthis:\n  sign x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; \\<not> ?P2\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  sign x = 0\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; sign x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; sign x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x \\<noteq> 0\""], ["proof (state)\nthis:\n  sign x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; sign x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "have \"sign x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign x \\<le> 1", "by transfer (auto simp: unat_one_word_le)"], ["proof (state)\nthis:\n  sign x \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; sign x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x \\<le> 1", "have \"sign x = 1\""], ["proof (prove)\nusing this:\n  sign x \\<le> 1\n\ngoal (1 subgoal):\n 1. sign x = 1", "using \\<open>sign x \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  sign x \\<le> 1\n  sign x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. sign x = 1", "by auto"], ["proof (state)\nthis:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sign x = 0 \\<Longrightarrow> thesis;\n     sign x = 1 \\<Longrightarrow> thesis; sign x \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_infinity_cases:\n  assumes \"is_infinity x\"\n  obtains \"x = plus_infinity\" | \"x = minus_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases rule: sign_cases[of x])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x = 0\""], ["proof (state)\nthis:\n  sign x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 0", "have \"x = plus_infinity\""], ["proof (prove)\nusing this:\n  sign x = 0\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  sign x = 0\n  is_infinity x\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "unfolding float_defs"], ["proof (prove)\nusing this:\n  sign x = 0\n  IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and> fraction x = 0\n\ngoal (1 subgoal):\n 1. x = \\<infinity>", "by transfer (auto simp: emax_def unat_eq_0)"], ["proof (state)\nthis:\n  x = \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = \\<infinity>\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x = 1\""], ["proof (state)\nthis:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 1", "have \"x = minus_infinity\""], ["proof (prove)\nusing this:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. x = - \\<infinity>", "using assms"], ["proof (prove)\nusing this:\n  sign x = 1\n  is_infinity x\n\ngoal (1 subgoal):\n 1. x = - \\<infinity>", "unfolding float_defs"], ["proof (prove)\nusing this:\n  sign x = 1\n  IEEE.exponent x = emax TYPE(('a, 'b) IEEE.float) \\<and> fraction x = 0\n\ngoal (1 subgoal):\n 1. x = - \\<infinity>", "by transfer (auto simp: emax_def unat_eq_of_nat)"], ["proof (state)\nthis:\n  x = - \\<infinity>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = \\<infinity> \\<Longrightarrow> thesis;\n     x = - \\<infinity> \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = - \\<infinity>", "show ?thesis"], ["proof (prove)\nusing this:\n  x = - \\<infinity>\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_zero_cases:\n  assumes \"is_zero x\"\n  obtains \"x = 0\" | \"x = - 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof (cases rule: sign_cases[of x])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x = 0\""], ["proof (state)\nthis:\n  sign x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 0", "have \"x = 0\""], ["proof (prove)\nusing this:\n  sign x = 0\n\ngoal (1 subgoal):\n 1. x = 0", "using assms"], ["proof (prove)\nusing this:\n  sign x = 0\n  is_zero x\n\ngoal (1 subgoal):\n 1. x = 0", "unfolding float_defs"], ["proof (prove)\nusing this:\n  sign x = 0\n  IEEE.exponent x = 0 \\<and> fraction x = 0\n\ngoal (1 subgoal):\n 1. x = 0", "by transfer (auto simp: emax_def unat_eq_0)"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 0\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume \"sign x = 1\""], ["proof (state)\nthis:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  sign x = 1", "have \"x = minus_zero\""], ["proof (prove)\nusing this:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. x = - 0", "using assms"], ["proof (prove)\nusing this:\n  sign x = 1\n  is_zero x\n\ngoal (1 subgoal):\n 1. x = - 0", "unfolding float_defs"], ["proof (prove)\nusing this:\n  sign x = 1\n  IEEE.exponent x = 0 \\<and> fraction x = 0\n\ngoal (1 subgoal):\n 1. x = - 0", "by transfer (auto simp: emax_def unat_eq_of_nat)"], ["proof (state)\nthis:\n  x = - 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x = 0 \\<Longrightarrow> thesis;\n     x = - 0 \\<Longrightarrow> thesis; sign x = 1\\<rbrakk>\n    \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  x = - 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = - 0\n\ngoal (1 subgoal):\n 1. thesis", ".."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma minus_minus_float[simp]: \"- (-f) = f\" for f::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- f) = f", "by transfer auto"], ["", "lemma sign_minus_float: \"sign (-f) = (1 - sign f)\" for f::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (- f) = 1 - sign f", "by transfer (auto simp: unat_eq_1 one_word_le unat_sub)"], ["", "lemma exponent_uminus[simp]: \"exponent (- f) = exponent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.exponent (- f) = IEEE.exponent f", "by transfer auto"], ["", "lemma fraction_uminus[simp]: \"fraction (- f) = fraction f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction (- f) = fraction f", "by transfer auto"], ["", "lemma is_normal_minus_float[simp]: \"is_normal (-f) = is_normal f\" for f::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_normal (- f) = is_normal f", "by (auto simp: is_normal_def)"], ["", "lemma is_denormal_minus_float[simp]: \"is_denormal (-f) = is_denormal f\" for f::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_denormal (- f) = is_denormal f", "by (auto simp: is_denormal_def)"], ["", "lemma bitlen_normal_mantissa:\n  \"bitlen (abs (normal_mantissa x)) = Suc LENGTH('f)\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "have \"fraction x < 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction x < 2 ^ LENGTH('f)", "using float_frac_le[of x]"], ["proof (prove)\nusing this:\n  fraction x \\<le> 2 ^ LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. fraction x < 2 ^ LENGTH('f)", "by (metis One_nat_def Suc_pred le_imp_less_Suc pos2 zero_less_power)"], ["proof (state)\nthis:\n  fraction x < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "moreover"], ["proof (state)\nthis:\n  fraction x < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "have \"- int (fraction x) \\<le> 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - int (fraction x) \\<le> 2 ^ LENGTH('f)", "using negative_zle_0 order_trans zero_le_numeral zero_le_power"], ["proof (prove)\nusing this:\n  - int ?n \\<le> 0\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  (0::?'a) \\<le> numeral ?n\n  (0::?'a) \\<le> ?a \\<Longrightarrow> (0::?'a) \\<le> ?a ^ ?n\n\ngoal (1 subgoal):\n 1. - int (fraction x) \\<le> 2 ^ LENGTH('f)", "by blast"], ["proof (state)\nthis:\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "ultimately"], ["proof (chain)\npicking this:\n  fraction x < 2 ^ LENGTH('f)\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)", "show ?thesis"], ["proof (prove)\nusing this:\n  fraction x < 2 ^ LENGTH('f)\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))", "by (cases x rule: sign_cases)\n      (auto simp: bitlen_le_iff_power bitlen_ge_iff_power nat_add_distrib\n        normal_mantissa_def intro!: antisym)"], ["proof (state)\nthis:\n  bitlen \\<bar>normal_mantissa x\\<bar> = int (Suc LENGTH('f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma less_int_natI: \"x < y\" if \"0 \\<le> x\" \"nat x < nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < y", "using that"], ["proof (prove)\nusing this:\n  0 \\<le> x\n  nat x < nat y\n\ngoal (1 subgoal):\n 1. x < y", "by arith"], ["", "lemma normal_exponent_bounds_int:\n  \"2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x\"\n  \"normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1\"\n  if \"is_normal x\"\n  for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x &&&\n    normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1", "using that"], ["proof (prove)\nusing this:\n  is_normal x\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f) \\<le> normal_exponent x &&&\n    normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1", "unfolding normal_exponent_def is_normal_def emax_eq bias_def"], ["proof (prove)\nusing this:\n  0 < IEEE.exponent x \\<and> IEEE.exponent x < 2 ^ LENGTH('e) - 1\n\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - 1) - int LENGTH('f)\n    \\<le> int (IEEE.exponent x) - int (2 ^ (LENGTH('e) - 1) - 1) -\n          int LENGTH('f) &&&\n    int (IEEE.exponent x) - int (2 ^ (LENGTH('e) - 1) - 1) - int LENGTH('f)\n    \\<le> 2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1", "by (auto simp del: zless_nat_conj intro!: less_int_natI\n      simp: of_nat_diff nat_add_distrib nat_mult_distrib nat_power_eq\n      power_Suc[symmetric])"], ["", "lemmas of_int_leI = of_int_le_iff[THEN iffD2]"], ["", "lemma normal_exponent_bounds_real:\n  \"2 - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) \\<le> normal_exponent x\"\n  \"normal_exponent x \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1\"\n  if \"is_normal x\"\n  for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - 1) - real LENGTH('f)\n    \\<le> real_of_int (normal_exponent x) &&&\n    real_of_int (normal_exponent x)\n    \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 - 2 ^ (LENGTH('e) - 1) - real LENGTH('f)\n    \\<le> real_of_int (normal_exponent x)", "by (rule order_trans[OF _ of_int_leI[OF normal_exponent_bounds_int(1)[OF that]]]) auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (normal_exponent x)\n    \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (normal_exponent x)\n    \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1", "by (rule order_trans[OF of_int_leI[OF normal_exponent_bounds_int(2)[OF that]]]) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma float_eqI:\n  \"x = y\" if \"sign x = sign y\" \"fraction x = fraction y\" \"exponent x = exponent y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "using that"], ["proof (prove)\nusing this:\n  sign x = sign y\n  fraction x = fraction y\n  IEEE.exponent x = IEEE.exponent y\n\ngoal (1 subgoal):\n 1. x = y", "by transfer auto"], ["", "lemma float_induct[induct type:float, case_names normal denormal neg zero infinity nan]:\n  fixes a::\"('e, 'f)float\"\n  assumes normal:\n    \"\\<And>x. is_normal x \\<Longrightarrow> valof x = normal_mantissa x * 2 powr normal_exponent x \\<Longrightarrow> P x\"\n  assumes denormal:\n    \"\\<And>x. is_denormal x \\<Longrightarrow>\n      valof x = denormal_mantissa x * 2 powr denormal_exponent TYPE(('e, 'f)float) \\<Longrightarrow>\n      P x\"\n  assumes zero: \"P 0\" \"P minus_zero\"\n  assumes infty: \"P plus_infinity\" \"P minus_infinity\"\n  assumes nan: \"\\<And>x. is_nan x \\<Longrightarrow> P x\"\n  shows \"P a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P a", "from float_cases[of a]"], ["proof (chain)\npicking this:\n  is_nan a \\<or>\n  is_infinity a \\<or> is_normal a \\<or> is_denormal a \\<or> is_zero a", "consider \"is_nan a\" | \"is_infinity a\" | \"is_normal a\" | \"is_denormal a\" | \"is_zero a\""], ["proof (prove)\nusing this:\n  is_nan a \\<or>\n  is_infinity a \\<or> is_normal a \\<or> is_denormal a \\<or> is_zero a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>is_nan a \\<Longrightarrow> thesis;\n     is_infinity a \\<Longrightarrow> thesis;\n     is_normal a \\<Longrightarrow> thesis;\n     is_denormal a \\<Longrightarrow> thesis;\n     is_zero a \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>is_nan a \\<Longrightarrow> ?thesis;\n   is_infinity a \\<Longrightarrow> ?thesis;\n   is_normal a \\<Longrightarrow> ?thesis;\n   is_denormal a \\<Longrightarrow> ?thesis;\n   is_zero a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>is_nan a \\<Longrightarrow> ?thesis;\n   is_infinity a \\<Longrightarrow> ?thesis;\n   is_normal a \\<Longrightarrow> ?thesis;\n   is_denormal a \\<Longrightarrow> ?thesis;\n   is_zero a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>is_nan a \\<Longrightarrow> ?thesis;\n   is_infinity a \\<Longrightarrow> ?thesis;\n   is_normal a \\<Longrightarrow> ?thesis;\n   is_denormal a \\<Longrightarrow> ?thesis;\n   is_zero a \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P a", "proof cases"], ["proof (state)\ngoal (5 subgoals):\n 1. is_nan a \\<Longrightarrow> P a\n 2. is_infinity a \\<Longrightarrow> P a\n 3. is_normal a \\<Longrightarrow> P a\n 4. is_denormal a \\<Longrightarrow> P a\n 5. is_zero a \\<Longrightarrow> P a", "case 1"], ["proof (state)\nthis:\n  is_nan a\n\ngoal (5 subgoals):\n 1. is_nan a \\<Longrightarrow> P a\n 2. is_infinity a \\<Longrightarrow> P a\n 3. is_normal a \\<Longrightarrow> P a\n 4. is_denormal a \\<Longrightarrow> P a\n 5. is_zero a \\<Longrightarrow> P a", "then"], ["proof (chain)\npicking this:\n  is_nan a", "show ?thesis"], ["proof (prove)\nusing this:\n  is_nan a\n\ngoal (1 subgoal):\n 1. P a", "by (rule nan)"], ["proof (state)\nthis:\n  P a\n\ngoal (4 subgoals):\n 1. is_infinity a \\<Longrightarrow> P a\n 2. is_normal a \\<Longrightarrow> P a\n 3. is_denormal a \\<Longrightarrow> P a\n 4. is_zero a \\<Longrightarrow> P a", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. is_infinity a \\<Longrightarrow> P a\n 2. is_normal a \\<Longrightarrow> P a\n 3. is_denormal a \\<Longrightarrow> P a\n 4. is_zero a \\<Longrightarrow> P a", "case 2"], ["proof (state)\nthis:\n  is_infinity a\n\ngoal (4 subgoals):\n 1. is_infinity a \\<Longrightarrow> P a\n 2. is_normal a \\<Longrightarrow> P a\n 3. is_denormal a \\<Longrightarrow> P a\n 4. is_zero a \\<Longrightarrow> P a", "then"], ["proof (chain)\npicking this:\n  is_infinity a", "consider \"a = plus_infinity\" | \"a = minus_infinity\""], ["proof (prove)\nusing this:\n  is_infinity a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = \\<infinity> \\<Longrightarrow> thesis;\n     a = - \\<infinity> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (rule is_infinity_cases)"], ["proof (state)\nthis:\n  \\<lbrakk>a = \\<infinity> \\<Longrightarrow> ?thesis;\n   a = - \\<infinity> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (4 subgoals):\n 1. is_infinity a \\<Longrightarrow> P a\n 2. is_normal a \\<Longrightarrow> P a\n 3. is_denormal a \\<Longrightarrow> P a\n 4. is_zero a \\<Longrightarrow> P a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a = \\<infinity> \\<Longrightarrow> ?thesis;\n   a = - \\<infinity> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = \\<infinity> \\<Longrightarrow> ?thesis;\n   a = - \\<infinity> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P a", "by cases (auto intro: infty)"], ["proof (state)\nthis:\n  P a\n\ngoal (3 subgoals):\n 1. is_normal a \\<Longrightarrow> P a\n 2. is_denormal a \\<Longrightarrow> P a\n 3. is_zero a \\<Longrightarrow> P a", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. is_normal a \\<Longrightarrow> P a\n 2. is_denormal a \\<Longrightarrow> P a\n 3. is_zero a \\<Longrightarrow> P a", "case hyps: 3"], ["proof (state)\nthis:\n  is_normal a\n\ngoal (3 subgoals):\n 1. is_normal a \\<Longrightarrow> P a\n 2. is_denormal a \\<Longrightarrow> P a\n 3. is_zero a \\<Longrightarrow> P a", "from hyps"], ["proof (chain)\npicking this:\n  is_normal a", "have \"valof a = normal_mantissa a * 2 powr normal_exponent a\""], ["proof (prove)\nusing this:\n  is_normal a\n\ngoal (1 subgoal):\n 1. valof a =\n    real_of_int (normal_mantissa a) * 2 powr real_of_int (normal_exponent a)", "by (cases a rule: sign_cases)\n        (auto simp: valof_eq normal_mantissa_def normal_exponent_def is_normal_def\n          powr_realpow[symmetric] powr_diff powr_add divide_simps algebra_simps)"], ["proof (state)\nthis:\n  valof a =\n  real_of_int (normal_mantissa a) * 2 powr real_of_int (normal_exponent a)\n\ngoal (3 subgoals):\n 1. is_normal a \\<Longrightarrow> P a\n 2. is_denormal a \\<Longrightarrow> P a\n 3. is_zero a \\<Longrightarrow> P a", "from hyps this"], ["proof (chain)\npicking this:\n  is_normal a\n  valof a =\n  real_of_int (normal_mantissa a) * 2 powr real_of_int (normal_exponent a)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_normal a\n  valof a =\n  real_of_int (normal_mantissa a) * 2 powr real_of_int (normal_exponent a)\n\ngoal (1 subgoal):\n 1. P a", "by (rule normal)"], ["proof (state)\nthis:\n  P a\n\ngoal (2 subgoals):\n 1. is_denormal a \\<Longrightarrow> P a\n 2. is_zero a \\<Longrightarrow> P a", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. is_denormal a \\<Longrightarrow> P a\n 2. is_zero a \\<Longrightarrow> P a", "case hyps: 4"], ["proof (state)\nthis:\n  is_denormal a\n\ngoal (2 subgoals):\n 1. is_denormal a \\<Longrightarrow> P a\n 2. is_zero a \\<Longrightarrow> P a", "from hyps"], ["proof (chain)\npicking this:\n  is_denormal a", "have \"valof a = denormal_mantissa a * 2 powr denormal_exponent TYPE(('e, 'f)float)\""], ["proof (prove)\nusing this:\n  is_denormal a\n\ngoal (1 subgoal):\n 1. valof a =\n    real_of_int (denormal_mantissa a) *\n    2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))", "by (cases a rule: sign_cases)\n        (auto simp: valof_eq denormal_mantissa_def denormal_exponent_def is_denormal_def\n          powr_realpow[symmetric] powr_diff powr_add divide_simps algebra_simps)"], ["proof (state)\nthis:\n  valof a =\n  real_of_int (denormal_mantissa a) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n\ngoal (2 subgoals):\n 1. is_denormal a \\<Longrightarrow> P a\n 2. is_zero a \\<Longrightarrow> P a", "from hyps this"], ["proof (chain)\npicking this:\n  is_denormal a\n  valof a =\n  real_of_int (denormal_mantissa a) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))", "show ?thesis"], ["proof (prove)\nusing this:\n  is_denormal a\n  valof a =\n  real_of_int (denormal_mantissa a) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n\ngoal (1 subgoal):\n 1. P a", "by (rule denormal)"], ["proof (state)\nthis:\n  P a\n\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> P a", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> P a", "case 5"], ["proof (state)\nthis:\n  is_zero a\n\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> P a", "then"], ["proof (chain)\npicking this:\n  is_zero a", "consider \"a = 0\" | \"a = minus_zero\""], ["proof (prove)\nusing this:\n  is_zero a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a = 0 \\<Longrightarrow> thesis;\n     a = - 0 \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (rule is_zero_cases)"], ["proof (state)\nthis:\n  \\<lbrakk>a = 0 \\<Longrightarrow> ?thesis;\n   a = - 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> P a", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>a = 0 \\<Longrightarrow> ?thesis;\n   a = - 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>a = 0 \\<Longrightarrow> ?thesis;\n   a = - 0 \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. P a", "by cases (auto intro: zero)"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma infinite_infinity[simp]: \"\\<not> is_finite plus_infinity\" \"\\<not> is_finite minus_infinity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_finite \\<infinity> &&& \\<not> is_finite (- \\<infinity>)", "by (auto simp: is_finite_def is_normal_def infinity_simps is_denormal_def is_zero_def)"], ["", "lemma nan_not_finite[simp]: \"is_nan x \\<Longrightarrow> \\<not> is_finite x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow> \\<not> is_finite x", "using float_distinct_finite(1)"], ["proof (prove)\nusing this:\n  \\<not> (is_nan ?a \\<and> is_finite ?a)\n\ngoal (1 subgoal):\n 1. is_nan x \\<Longrightarrow> \\<not> is_finite x", "by blast"], ["", "lemma valof_nonneg:\n  \"valof x \\<ge> 0\" if \"sign x = 0\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> valof x", "by (auto simp: valof_eq that)"], ["", "lemma valof_nonpos:\n  \"valof x \\<le> 0\" if \"sign x = 1\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof x \\<le> 0", "using that"], ["proof (prove)\nusing this:\n  sign x = 1\n\ngoal (1 subgoal):\n 1. valof x \\<le> 0", "by (auto simp: valof_eq is_finite_def)"], ["", "lemma real_le_intI: \"x \\<le> y\" if \"floor x \\<le> floor y\" \"x \\<in> \\<int>\" for x y::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "using that(2,1)"], ["proof (prove)\nusing this:\n  x \\<in> \\<int>\n  \\<lfloor>x\\<rfloor> \\<le> \\<lfloor>y\\<rfloor>\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (induction rule: Ints_induct) (auto elim!: Ints_induct simp: le_floor_iff)"], ["", "lemma real_of_int_le_2_powr_bitlenI:\n  \"real_of_int x \\<le> 2 powr n - 1\" if \"bitlen (abs x) \\<le> m\" \"m \\<le> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "have \"real_of_int x \\<le> abs (real_of_int x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int x \\<le> \\<bar>real_of_int x\\<bar>", "by simp"], ["proof (state)\nthis:\n  real_of_int x \\<le> \\<bar>real_of_int x\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "also"], ["proof (state)\nthis:\n  real_of_int x \\<le> \\<bar>real_of_int x\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "have \"\\<dots> < 2 powr (bitlen (abs x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int x\\<bar> < 2 powr real_of_int (bitlen \\<bar>x\\<bar>)", "by (rule abs_real_le_2_powr_bitlen)"], ["proof (state)\nthis:\n  \\<bar>real_of_int x\\<bar> < 2 powr real_of_int (bitlen \\<bar>x\\<bar>)\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "finally"], ["proof (chain)\npicking this:\n  real_of_int x < 2 powr real_of_int (bitlen \\<bar>x\\<bar>)", "have \"real_of_int x \\<le> 2 powr (bitlen (abs x)) - 1\""], ["proof (prove)\nusing this:\n  real_of_int x < 2 powr real_of_int (bitlen \\<bar>x\\<bar>)\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1", "by (auto simp: powr_real_of_int bitlen_nonneg intro!: real_le_intI)"], ["proof (state)\nthis:\n  real_of_int x \\<le> 2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "also"], ["proof (state)\nthis:\n  real_of_int x \\<le> 2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "have \"\\<dots> \\<le> 2 powr m - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1\n    \\<le> 2 powr real_of_int m - 1", "by (simp add: that)"], ["proof (state)\nthis:\n  2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1\n  \\<le> 2 powr real_of_int m - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "also"], ["proof (state)\nthis:\n  2 powr real_of_int (bitlen \\<bar>x\\<bar>) - 1\n  \\<le> 2 powr real_of_int m - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "have \"\\<dots> \\<le> 2 powr n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr real_of_int m - 1 \\<le> 2 powr n - 1", "by (simp add: that)"], ["proof (state)\nthis:\n  2 powr real_of_int m - 1 \\<le> 2 powr n - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "finally"], ["proof (chain)\npicking this:\n  real_of_int x \\<le> 2 powr n - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int x \\<le> 2 powr n - 1\n\ngoal (1 subgoal):\n 1. real_of_int x \\<le> 2 powr n - 1", "."], ["proof (state)\nthis:\n  real_of_int x \\<le> 2 powr n - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma largest_eq:\n  \"largest TYPE(('e, 'f)float) =\n    (2 ^ (LENGTH('f) + 1) - 1) * 2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "have \"2 ^ LENGTH('e) - 1 - 1 = (2::nat) ^ LENGTH('e) - 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('e) - 1 - 1 = 2 ^ LENGTH('e) - 2", "by arith"], ["proof (state)\nthis:\n  2 ^ LENGTH('e) - 1 - 1 = 2 ^ LENGTH('e) - 2\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "then"], ["proof (chain)\npicking this:\n  2 ^ LENGTH('e) - 1 - 1 = 2 ^ LENGTH('e) - 2", "have \"largest TYPE(('e, 'f)float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) - LENGTH('f))\""], ["proof (prove)\nusing this:\n  2 ^ LENGTH('e) - 1 - 1 = 2 ^ LENGTH('e) - 2\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr\n    (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n     real LENGTH('f))", "unfolding largest_def emax_eq bias_def"], ["proof (prove)\nusing this:\n  2 ^ LENGTH('e) - 1 - 1 = 2 ^ LENGTH('e) - 2\n\ngoal (1 subgoal):\n 1. 2 ^ (2 ^ LENGTH('e) - 1 - 1) / 2 ^ (2 ^ (LENGTH('e) - 1) - 1) *\n    (2 - 1 / 2 ^ LENGTH('f)) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr\n    (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n     real LENGTH('f))", "by (auto simp: largest_def powr_realpow[symmetric]\n        powr_minus divide_simps algebra_simps powr_diff powr_add of_nat_diff)"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) =\n  (2 ^ (LENGTH('f) + 1) - 1) *\n  2 powr\n  (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n   real LENGTH('f))\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "also"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) =\n  (2 ^ (LENGTH('f) + 1) - 1) *\n  2 powr\n  (real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n   real LENGTH('f))\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "have \"2 ^ LENGTH('e) \\<ge> (2::nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> 2 ^ LENGTH('e)", "by (simp add: self_le_power)"], ["proof (state)\nthis:\n  2 \\<le> 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "then"], ["proof (chain)\npicking this:\n  2 \\<le> 2 ^ LENGTH('e)", "have \"(real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) - LENGTH('f)) =\n    (real (2 ^ LENGTH('e)) - 2 ^ (LENGTH('e) - 1) - LENGTH('f)) - 1\""], ["proof (prove)\nusing this:\n  2 \\<le> 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n    real LENGTH('f) =\n    real (2 ^ LENGTH('e)) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1", "by (auto simp add: of_nat_diff)"], ["proof (state)\nthis:\n  real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n  real LENGTH('f) =\n  real (2 ^ LENGTH('e)) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "also"], ["proof (state)\nthis:\n  real (2 ^ LENGTH('e) - 2) + 1 - real (2 ^ (LENGTH('e) - 1)) -\n  real LENGTH('f) =\n  real (2 ^ LENGTH('e)) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "have \"real (2 ^ LENGTH('e)) = 2 ^ LENGTH('e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real (2 ^ LENGTH('e)) = 2 ^ LENGTH('e)", "by auto"], ["proof (state)\nthis:\n  real (2 ^ LENGTH('e)) = 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "also"], ["proof (state)\nthis:\n  real (2 ^ LENGTH('e)) = 2 ^ LENGTH('e)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "have \"(2 ^ LENGTH('e) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1) =\n    real_of_int ((2 ^ (LENGTH('e) - 1) - int (LENGTH('f)) - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ LENGTH('e) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1 =\n    real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by (simp, subst power_Suc[symmetric], simp)"], ["proof (state)\nthis:\n  2 ^ LENGTH('e) - 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1 =\n  real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "finally"], ["proof (chain)\npicking this:\n  largest TYPE(('e, 'f) IEEE.float) =\n  (2 ^ (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  largest TYPE(('e, 'f) IEEE.float) =\n  (2 ^ (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by simp"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) =\n  (2 ^ (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bitlen_denormal_mantissa:\n  \"bitlen (abs (denormal_mantissa x)) \\<le> LENGTH('f)\" for x::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "have \"fraction x < 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fraction x < 2 ^ LENGTH('f)", "using float_frac_le[of x]"], ["proof (prove)\nusing this:\n  fraction x \\<le> 2 ^ LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. fraction x < 2 ^ LENGTH('f)", "by (metis One_nat_def Suc_pred le_imp_less_Suc pos2 zero_less_power)"], ["proof (state)\nthis:\n  fraction x < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "moreover"], ["proof (state)\nthis:\n  fraction x < 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "have \"- int (fraction x) \\<le> 2 ^ LENGTH('f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - int (fraction x) \\<le> 2 ^ LENGTH('f)", "using negative_zle_0 order_trans zero_le_numeral zero_le_power"], ["proof (prove)\nusing this:\n  - int ?n \\<le> 0\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  (0::?'a) \\<le> numeral ?n\n  (0::?'a) \\<le> ?a \\<Longrightarrow> (0::?'a) \\<le> ?a ^ ?n\n\ngoal (1 subgoal):\n 1. - int (fraction x) \\<le> 2 ^ LENGTH('f)", "by blast"], ["proof (state)\nthis:\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "ultimately"], ["proof (chain)\npicking this:\n  fraction x < 2 ^ LENGTH('f)\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)", "show ?thesis"], ["proof (prove)\nusing this:\n  fraction x < 2 ^ LENGTH('f)\n  - int (fraction x) \\<le> 2 ^ LENGTH('f)\n\ngoal (1 subgoal):\n 1. bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)", "by (cases x rule: sign_cases)\n      (auto simp: bitlen_le_iff_power denormal_mantissa_def intro!: antisym)"], ["proof (state)\nthis:\n  bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_le_topfloat:\n  fixes a::\"('e, 'f)float\"\n  assumes \"is_finite a\" \"LENGTH('e) > 1\"\n  shows \"a \\<le> topfloat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<le> topfloat", "using assms(1)"], ["proof (prove)\nusing this:\n  is_finite a\n\ngoal (1 subgoal):\n 1. a \\<le> topfloat", "proof (induction a rule: float_induct)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "case (normal x)"], ["proof (state)\nthis:\n  is_normal x\n  valof x =\n  real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n  is_finite x\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "note normal(2)"], ["proof (state)\nthis:\n  valof x =\n  real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  valof x =\n  real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x) \\<le>\n    (2 powr (LENGTH('f) + 1) - 1) * 2 powr (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n    \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n          2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "using normal_exponent_bounds_real(2)[OF \\<open>is_normal x\\<close>]"], ["proof (prove)\nusing this:\n  real_of_int (normal_exponent x)\n  \\<le> 2 ^ (LENGTH('e) - 1) - real LENGTH('f) - 1\n\ngoal (1 subgoal):\n 1. real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n    \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n          2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by (auto intro!: mult_mono real_of_int_le_2_powr_bitlenI\n        simp: bitlen_normal_mantissa powr_realpow[symmetric] ge_one_powr_ge_zero)"], ["proof (state)\nthis:\n  real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n  \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n        2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  real_of_int (normal_mantissa x) * 2 powr real_of_int (normal_exponent x)\n  \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n        2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"\\<dots> = largest TYPE(('e, 'f) IEEE.float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr real (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1) =\n    largest TYPE(('e, 'f) IEEE.float)", "unfolding largest_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr real (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1) =\n    (2 ^ (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by (auto simp: powr_realpow powr_add)"], ["proof (state)\nthis:\n  (2 powr real (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1) =\n  largest TYPE(('e, 'f) IEEE.float)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  (2 powr real (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1) =\n  largest TYPE(('e, 'f) IEEE.float)\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"\\<dots> = valof (topfloat::('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) = valof topfloat", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  1 < LENGTH('e)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) = valof topfloat", "by (simp add: valof_topfloat)"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) = valof topfloat\n\ngoal (7 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_normal x;\n        valof x =\n        real_of_int (normal_mantissa x) *\n        2 powr real_of_int (normal_exponent x);\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 3. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 4. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 5. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 6. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 7. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "finally"], ["proof (chain)\npicking this:\n  valof x \\<le> valof topfloat", "show ?case"], ["proof (prove)\nusing this:\n  valof x \\<le> valof topfloat\n\ngoal (1 subgoal):\n 1. x \\<le> topfloat", "by (intro float_leI normal finite_topfloat)"], ["proof (state)\nthis:\n  x \\<le> topfloat\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "case (denormal x)"], ["proof (state)\nthis:\n  is_denormal x\n  valof x =\n  real_of_int (denormal_mantissa x) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n  is_finite x\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "note denormal(2)"], ["proof (state)\nthis:\n  valof x =\n  real_of_int (denormal_mantissa x) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  valof x =\n  real_of_int (denormal_mantissa x) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "have \"3 \\<le> 2 powr (2::real)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr 2", "by simp"], ["proof (state)\nthis:\n  3 \\<le> 2 powr 2\n\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "also"], ["proof (state)\nthis:\n  3 \\<le> 2 powr 2\n\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "have \"\\<dots> \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 powr 2 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  1 < LENGTH('e)\n\ngoal (1 subgoal):\n 1. 2 powr 2 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "by (subst powr_le_cancel_iff) auto"], ["proof (state)\nthis:\n  2 powr 2 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "finally"], ["proof (chain)\npicking this:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n\ngoal (1 subgoal):\n 1. 3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "."], ["proof (state)\nthis:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "then"], ["proof (chain)\npicking this:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))", "have \"real_of_int (denormal_mantissa x) * 2 powr real_of_int (denormal_exponent TYPE(('e, 'f)float)) \\<le>\n    (2 powr (LENGTH('f) + 1) - 1) * 2 powr (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\""], ["proof (prove)\nusing this:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n\ngoal (1 subgoal):\n 1. real_of_int (denormal_mantissa x) *\n    2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n    \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n          2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "using bitlen_denormal_mantissa[of x]"], ["proof (prove)\nusing this:\n  3 \\<le> 2 powr (1 + real (LENGTH('e) - Suc 0))\n  bitlen \\<bar>denormal_mantissa x\\<bar> \\<le> int LENGTH('f)\n\ngoal (1 subgoal):\n 1. real_of_int (denormal_mantissa x) *\n    2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n    \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n          2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by (auto intro!: mult_mono real_of_int_le_2_powr_bitlenI\n        simp: bitlen_normal_mantissa powr_realpow[symmetric] ge_one_powr_ge_zero\n        denormal_exponent_def bias_def powr_mult_base of_nat_diff)"], ["proof (state)\nthis:\n  real_of_int (denormal_mantissa x) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n  \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n        2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  real_of_int (denormal_mantissa x) *\n  2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float))\n  \\<le> (2 powr real (LENGTH('f) + 1) - 1) *\n        2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"\\<dots> \\<le> largest TYPE(('e, 'f) IEEE.float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr real (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n    \\<le> largest TYPE(('e, 'f) IEEE.float)", "unfolding largest_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr real (LENGTH('f) + 1) - 1) *\n    2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n    \\<le> (2 ^ (LENGTH('f) + 1) - 1) *\n          2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)", "by (rule mult_mono)\n      (auto simp: powr_realpow powr_add power_Suc[symmetric] simp del: power_Suc)"], ["proof (state)\nthis:\n  (2 powr real (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n  \\<le> largest TYPE(('e, 'f) IEEE.float)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "also"], ["proof (state)\nthis:\n  (2 powr real (LENGTH('f) + 1) - 1) *\n  2 powr real_of_int (2 ^ (LENGTH('e) - 1) - int LENGTH('f) - 1)\n  \\<le> largest TYPE(('e, 'f) IEEE.float)\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "have \"\\<dots> = valof (topfloat::('e, 'f) float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) = valof topfloat", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  1 < LENGTH('e)\n\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) = valof topfloat", "by (simp add: valof_topfloat)"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) = valof topfloat\n\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>is_denormal x;\n        valof x =\n        real_of_int (denormal_mantissa x) *\n        2 powr real_of_int (denormal_exponent TYPE(('e, 'f) IEEE.float));\n        is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat\n 2. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 3. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 4. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 5. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 6. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "finally"], ["proof (chain)\npicking this:\n  valof x \\<le> valof topfloat", "show ?case"], ["proof (prove)\nusing this:\n  valof x \\<le> valof topfloat\n\ngoal (1 subgoal):\n 1. x \\<le> topfloat", "by (intro float_leI denormal finite_topfloat)"], ["proof (state)\nthis:\n  x \\<le> topfloat\n\ngoal (5 subgoals):\n 1. is_finite 0 \\<Longrightarrow> 0 \\<le> topfloat\n 2. is_finite (- 0) \\<Longrightarrow> - 0 \\<le> topfloat\n 3. is_finite \\<infinity> \\<Longrightarrow> \\<infinity> \\<le> topfloat\n 4. is_finite (- \\<infinity>) \\<Longrightarrow> - \\<infinity> \\<le> topfloat\n 5. \\<And>x.\n       \\<lbrakk>is_nan x; is_finite x\\<rbrakk>\n       \\<Longrightarrow> x \\<le> topfloat", "qed auto"], ["", "lemma float_val_le_largest:\n  \"valof a \\<le> largest TYPE(('e, 'f)float)\"\n  if \"is_finite a\" \"LENGTH('e) > 1\"\n  for a::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a \\<le> largest TYPE(('e, 'f) IEEE.float)", "by (metis that finite_topfloat float_le float_le_topfloat valof_topfloat)"], ["", "lemma float_val_lt_threshold:\n  \"valof a < threshold TYPE(('e, 'f)float)\"\n  if \"is_finite a\" \"LENGTH('e) > 1\"\n  for a::\"('e, 'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "have \"valof a \\<le> largest TYPE(('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a \\<le> largest TYPE(('e, 'f) IEEE.float)", "by (rule float_val_le_largest [OF that])"], ["proof (state)\nthis:\n  valof a \\<le> largest TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "also"], ["proof (state)\nthis:\n  valof a \\<le> largest TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "have \"\\<dots> < threshold TYPE(('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. largest TYPE(('e, 'f) IEEE.float) < threshold TYPE(('e, 'f) IEEE.float)", "by (auto simp: largest_def threshold_def divide_simps)"], ["proof (state)\nthis:\n  largest TYPE(('e, 'f) IEEE.float) < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "finally"], ["proof (chain)\npicking this:\n  valof a < threshold TYPE(('e, 'f) IEEE.float)", "show ?thesis"], ["proof (prove)\nusing this:\n  valof a < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. valof a < threshold TYPE(('e, 'f) IEEE.float)", "."], ["proof (state)\nthis:\n  valof a < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Algebraic properties about basic arithmetic\\<close>"], ["", "text \\<open>Commutativity of addition.\\<close>"], ["", "lemma\n  assumes \"is_finite a\" \"is_finite b\"\n  shows float_plus_comm_eq: \"a + b = b + a\"\n    and float_plus_comm: \"is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a &&&\n    (is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. a + b = b + a\n 2. is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by (auto simp: finite_nan finite_infinity)"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. a + b = b + a\n 2. is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "show \"a + b = b + a\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a + b = b + a", "by (simp add: float_defs fadd_def plus_float_def add.commute)"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)", "then"], ["proof (chain)\npicking this:\n  a + b = b + a", "show \"is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)\""], ["proof (prove)\nusing this:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)", "by (metis float_eq)"], ["proof (state)\nthis:\n  is_finite (a + b) \\<Longrightarrow> (a + b) \\<doteq> (b + a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The floating-point number a falls into the same category as the negation of \\<open>a\\<close>.\\<close>"], ["", "lemma is_zero_uminus[simp]: \"is_zero (- a) \\<longleftrightarrow> is_zero a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero (- a) = is_zero a", "by (simp add: is_zero_def)"], ["", "lemma is_infinity_uminus [simp]: \"is_infinity (- a) = is_infinity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_infinity (- a) = is_infinity a", "by (simp add: is_infinity_def)"], ["", "lemma is_finite_uminus[simp]: \"is_finite (- a) \\<longleftrightarrow> is_finite a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (- a) = is_finite a", "by (simp add: is_finite_def)"], ["", "lemma is_nan_uminus[simp]: \"is_nan (- a) \\<longleftrightarrow> is_nan a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_nan (- a) = is_nan a", "by (simp add: is_nan_def)"], ["", "text \\<open>The sign of a and the sign of a's negation is different.\\<close>"], ["", "lemma float_neg_sign: \"(sign a) \\<noteq> (sign (- a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign a \\<noteq> sign (- a)", "by (cases a rule: sign_cases) (auto simp: sign_minus_float)"], ["", "lemma float_neg_sign1: \"sign a = sign (- b) \\<longleftrightarrow> sign a \\<noteq> sign b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sign a = sign (- b)) = (sign a \\<noteq> sign b)", "by (metis float_neg_sign sign_cases)"], ["", "lemma valof_uminus:\n  assumes \"is_finite a\"\n  shows \"valof (- a) = - valof a\" (is \"?L = ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (- a) = - valof a", "by (cases a rule: sign_cases)  (auto simp: valof_eq sign_minus_float)"], ["", "text \\<open>Showing \\<open>a + (- b) = a - b\\<close>.\\<close>"], ["", "lemma float_neg_add:\n  \"is_finite a \\<Longrightarrow> is_finite b \\<Longrightarrow> is_finite (a - b) \\<Longrightarrow> valof a + valof (- b) = valof a - valof b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_finite a; is_finite b; is_finite (a - b)\\<rbrakk>\n    \\<Longrightarrow> valof a + valof (- b) = valof a - valof b", "by (simp add: valof_uminus)"], ["", "lemma float_plus_minus:\n  assumes \"is_finite a\" \"is_finite b\" \"is_finite (a - b)\"\n  shows \"(a + - b) \\<doteq> (a - b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "have nab: \"\\<not> is_nan a\" \"\\<not> is_nan (- b)\" \"\\<not> is_infinity a\" \"\\<not> is_infinity (-  b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan (- b)) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity (- b)", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  is_finite (a - b)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan (- b)) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity (- b)", "by (auto simp: finite_nan finite_infinity)"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan (- b)\n  \\<not> is_infinity a\n  \\<not> is_infinity (- b)\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "have \"a - b = (zerosign\n        (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then (sign a) else 0)\n        (round To_nearest (valof a - valof b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a - b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b))", "using nab"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan (- b)\n  \\<not> is_infinity a\n  \\<not> is_infinity (- b)\n\ngoal (1 subgoal):\n 1. a - b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b))", "by (auto simp: minus_float_def fsub_def)"], ["proof (state)\nthis:\n  a - b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "also"], ["proof (state)\nthis:\n  a - b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "have \"\\<dots> =\n    (zerosign\n        (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b) then sign a else 0)\n        (round To_nearest (valof a + valof (- b))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b)) =\n    zerosign\n     (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b)\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a + valof (- b)))", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  is_finite (a - b)\n\ngoal (1 subgoal):\n 1. zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b)) =\n    zerosign\n     (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b)\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a + valof (- b)))", "by (simp add: float_neg_sign1 float_neg_add)"], ["proof (state)\nthis:\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b)) =\n  zerosign\n   (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b) then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a + valof (- b)))\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "also"], ["proof (state)\nthis:\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b)) =\n  zerosign\n   (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b) then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a + valof (- b)))\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "have \"\\<dots> = a + - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zerosign\n     (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b)\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a + valof (- b))) =\n    a + - b", "using nab"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan (- b)\n  \\<not> is_infinity a\n  \\<not> is_infinity (- b)\n\ngoal (1 subgoal):\n 1. zerosign\n     (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b)\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a + valof (- b))) =\n    a + - b", "by (auto simp: float_defs fadd_def plus_float_def)"], ["proof (state)\nthis:\n  zerosign\n   (if is_zero a \\<and> is_zero (- b) \\<and> sign a = sign (- b) then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a + valof (- b))) =\n  a + - b\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "finally"], ["proof (chain)\npicking this:\n  a - b = a + - b", "show ?thesis"], ["proof (prove)\nusing this:\n  a - b = a + - b\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "using assms"], ["proof (prove)\nusing this:\n  a - b = a + - b\n  is_finite a\n  is_finite b\n  is_finite (a - b)\n\ngoal (1 subgoal):\n 1. (a + - b) \\<doteq> (a - b)", "by (metis float_eq)"], ["proof (state)\nthis:\n  (a + - b) \\<doteq> (a - b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_bottomfloat: \"is_finite bottomfloat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (- topfloat)", "by (simp add: finite_topfloat)"], ["", "lemma bottomfloat_eq_m_largest: \"valof (bottomfloat::('e, 'f)float) = - largest TYPE(('e, 'f)float)\"\n  if \"LENGTH('e) > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (- topfloat) = - largest TYPE(('e, 'f) IEEE.float)", "using that"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n\ngoal (1 subgoal):\n 1. valof (- topfloat) = - largest TYPE(('e, 'f) IEEE.float)", "by (auto simp: valof_topfloat valof_uminus finite_topfloat)"], ["", "lemma float_val_ge_bottomfloat: \"valof a \\<ge> valof (bottomfloat::('e, 'f)float)\"\n  if \"LENGTH('e) > 1\" \"is_finite a\"\n  for a::\"('e,'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "have \"- a \\<le> topfloat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - a \\<le> topfloat", "using that"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n  is_finite a\n\ngoal (1 subgoal):\n 1. - a \\<le> topfloat", "by (auto intro: float_le_topfloat)"], ["proof (state)\nthis:\n  - a \\<le> topfloat\n\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "then"], ["proof (chain)\npicking this:\n  - a \\<le> topfloat", "show ?thesis"], ["proof (prove)\nusing this:\n  - a \\<le> topfloat\n\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "using that"], ["proof (prove)\nusing this:\n  - a \\<le> topfloat\n  1 < LENGTH('e)\n  is_finite a\n\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "by (auto simp: valof_uminus finite_topfloat)"], ["proof (state)\nthis:\n  valof (- topfloat) \\<le> valof a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_ge_bottomfloat: \"is_finite a \\<Longrightarrow> a \\<ge> bottomfloat\"\n  if \"LENGTH('e) > 1\" \"is_finite a\"\n  for a::\"('e,'f)float\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite a \\<Longrightarrow> - topfloat \\<le> a", "by (metis finite_bottomfloat float_le float_val_ge_bottomfloat that)"], ["", "lemma float_val_ge_largest:\n  fixes a::\"('e,'f)float\"\n  assumes \"LENGTH('e) > 1\" \"is_finite a\"\n  shows \"valof a \\<ge> - largest TYPE(('e,'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "have \"- largest TYPE(('e,'f)float) = valof (bottomfloat::('e,'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) = valof (- topfloat)", "using assms"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n  is_finite a\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) = valof (- topfloat)", "by (simp add: bottomfloat_eq_m_largest)"], ["proof (state)\nthis:\n  - largest TYPE(('e, 'f) IEEE.float) = valof (- topfloat)\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "also"], ["proof (state)\nthis:\n  - largest TYPE(('e, 'f) IEEE.float) = valof (- topfloat)\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "have \"\\<dots> \\<le> valof a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "using assms"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n  is_finite a\n\ngoal (1 subgoal):\n 1. valof (- topfloat) \\<le> valof a", "by (simp add: float_val_ge_bottomfloat)"], ["proof (state)\nthis:\n  valof (- topfloat) \\<le> valof a\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "finally"], ["proof (chain)\npicking this:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "show ?thesis"], ["proof (prove)\nusing this:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "."], ["proof (state)\nthis:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_val_gt_threshold:\n  fixes a::\"('e,'f)float\"\n  assumes \"LENGTH('e) > 1\" \"is_finite a\"\n  shows \"valof a > - threshold TYPE(('e,'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float) < valof a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float) < valof a", "have largest: \"valof a \\<ge> -largest TYPE(('e,'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "using assms"], ["proof (prove)\nusing this:\n  1 < LENGTH('e)\n  is_finite a\n\ngoal (1 subgoal):\n 1. - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "by (metis float_val_ge_largest)"], ["proof (state)\nthis:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a\n\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float) < valof a", "then"], ["proof (chain)\npicking this:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a", "have \"-largest TYPE(('e,'f)float) > - threshold TYPE(('e,'f)float)\""], ["proof (prove)\nusing this:\n  - largest TYPE(('e, 'f) IEEE.float) \\<le> valof a\n\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float)\n    < - largest TYPE(('e, 'f) IEEE.float)", "by (auto simp: bias_def threshold_def largest_def divide_simps)"], ["proof (state)\nthis:\n  - threshold TYPE(('e, 'f) IEEE.float)\n  < - largest TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float) < valof a", "then"], ["proof (chain)\npicking this:\n  - threshold TYPE(('e, 'f) IEEE.float)\n  < - largest TYPE(('e, 'f) IEEE.float)", "show ?thesis"], ["proof (prove)\nusing this:\n  - threshold TYPE(('e, 'f) IEEE.float)\n  < - largest TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. - threshold TYPE(('e, 'f) IEEE.float) < valof a", "by (metis largest less_le_trans)"], ["proof (state)\nthis:\n  - threshold TYPE(('e, 'f) IEEE.float) < valof a\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Showing \\<open>abs (- a) = abs a\\<close>.\\<close>"], ["", "lemma float_abs [simp]: \"\\<not> is_nan a \\<Longrightarrow> abs (- a) = abs a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_nan a \\<Longrightarrow> \\<bar>- a\\<bar> = \\<bar>a\\<bar>", "by (metis IEEE.abs_float_def float_neg_sign1 minus_minus_float zero_simps(1))"], ["", "lemma neg_zerosign: \"- (zerosign s a) = zerosign (1 - s) (- a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - zerosign s a = zerosign (1 - s) (- a)", "by (auto simp: zerosign_def)"], ["", "subsection \\<open>Properties about Rounding Errors\\<close>"], ["", "definition error :: \"('e, 'f)float itself \\<Rightarrow> real \\<Rightarrow> real\"\n  where \"error _ x = valof (round To_nearest x::('e, 'f)float) - x\""], ["", "lemma bound_at_worst_lemma:\n  fixes a::\"('e, 'f)float\"\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n  assumes finite: \"is_finite a\"\n  shows \"\\<bar>valof (round To_nearest x::('e, 'f)float) - x\\<bar> \\<le> \\<bar>valof a - x\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "have *: \"(round To_nearest x::('e,'f)float) =\n      closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.round To_nearest x =\n    closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x", "using threshold finite"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n  is_finite a\n\ngoal (1 subgoal):\n 1. IEEE.round To_nearest x =\n    closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x", "by auto"], ["proof (state)\nthis:\n  IEEE.round To_nearest x =\n  closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x\n\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "have \"is_closest (valof) {a. is_finite a} x (round To_nearest x::('e,'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)", "using is_finite_nonempty"], ["proof (prove)\nusing this:\n  {a. is_finite a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)", "unfolding *"], ["proof (prove)\nusing this:\n  {a. is_finite a} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. is_closest valof {a. is_finite a} x\n     (closest valof (\\<lambda>a. even (fraction a)) (Collect is_finite) x)", "by (intro closest_is_closest) auto"], ["proof (state)\nthis:\n  is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)\n\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "then"], ["proof (chain)\npicking this:\n  is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)\n\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "using finite is_closest_def"], ["proof (prove)\nusing this:\n  is_closest valof {a. is_finite a} x (IEEE.round To_nearest x)\n  is_finite a\n  is_closest ?v ?s ?x ?a =\n  (?a \\<in> ?s \\<and>\n   (\\<forall>b.\n       b \\<in> ?s \\<longrightarrow>\n       \\<bar>?v ?a - ?x\\<bar> \\<le> \\<bar>?v b - ?x\\<bar>))\n\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "by (metis mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n  \\<le> \\<bar>valof a - x\\<bar>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma error_at_worst_lemma:\n  fixes a::\"('e, 'f)float\"\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n    and \"is_finite a\"\n  shows \"\\<bar>error TYPE(('e, 'f)float) x\\<bar> \\<le> \\<bar>valof a - x\\<bar> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>error TYPE(('e, 'f) IEEE.float) x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "unfolding error_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>valof (IEEE.round To_nearest x) - x\\<bar>\n    \\<le> \\<bar>valof a - x\\<bar>", "by (rule bound_at_worst_lemma; fact)"], ["", "lemma error_is_zero [simp]:\n  fixes a::\"('e, 'f)float\"\n  assumes \"is_finite a\" \"1 < LENGTH('e)\"\n  shows \"error TYPE(('e, 'f)float) (valof a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. error TYPE(('e, 'f) IEEE.float) (valof a) = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. error TYPE(('e, 'f) IEEE.float) (valof a) = 0", "have \"\\<bar>valof a\\<bar> < threshold TYPE(('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>valof a\\<bar> < threshold TYPE(('e, 'f) IEEE.float)", "by (metis abs_less_iff minus_less_iff float_val_gt_threshold float_val_lt_threshold assms)"], ["proof (state)\nthis:\n  \\<bar>valof a\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. error TYPE(('e, 'f) IEEE.float) (valof a) = 0", "then"], ["proof (chain)\npicking this:\n  \\<bar>valof a\\<bar> < threshold TYPE(('e, 'f) IEEE.float)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>valof a\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. error TYPE(('e, 'f) IEEE.float) (valof a) = 0", "by (metis abs_le_zero_iff abs_zero diff_self error_at_worst_lemma assms(1))"], ["proof (state)\nthis:\n  error TYPE(('e, 'f) IEEE.float) (valof a) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_finite_zerosign[simp]: \"is_finite (zerosign s a) \\<longleftrightarrow> is_finite a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (zerosign s a) = is_finite a", "by (auto simp: zerosign_def is_finite_def)"], ["", "lemma is_finite_closest: \"is_finite (closest (v::_\\<Rightarrow>real) p {a. is_finite a} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (closest v p {a. is_finite a} x)", "using closest_is_closest[OF is_finite_nonempty, of v x p]"], ["proof (prove)\nusing this:\n  is_closest v {a. is_finite a} x (closest v p {a. is_finite a} x)\n\ngoal (1 subgoal):\n 1. is_finite (closest v p {a. is_finite a} x)", "by (auto simp: is_closest_def)"], ["", "lemma defloat_float_zerosign_round_finite:\n  assumes threshold: \"\\<bar>x\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows \"is_finite (zerosign s (round To_nearest x::('e, 'f)float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "have \"(round To_nearest x::('e, 'f)float) =\n      (closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IEEE.round To_nearest x =\n    closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x", "using threshold"], ["proof (prove)\nusing this:\n  \\<bar>x\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. IEEE.round To_nearest x =\n    closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x", "by (metis (full_types) abs_less_iff leD le_minus_iff round.simps(1))"], ["proof (state)\nthis:\n  IEEE.round To_nearest x =\n  closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x\n\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "then"], ["proof (chain)\npicking this:\n  IEEE.round To_nearest x =\n  closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x", "have \"is_finite (round To_nearest x::('e, 'f)float)\""], ["proof (prove)\nusing this:\n  IEEE.round To_nearest x =\n  closest valof (\\<lambda>a. even (fraction a)) {a. is_finite a} x\n\ngoal (1 subgoal):\n 1. is_finite (IEEE.round To_nearest x)", "by (metis is_finite_closest)"], ["proof (state)\nthis:\n  is_finite (IEEE.round To_nearest x)\n\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "then"], ["proof (chain)\npicking this:\n  is_finite (IEEE.round To_nearest x)", "show ?thesis"], ["proof (prove)\nusing this:\n  is_finite (IEEE.round To_nearest x)\n\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "using is_finite_zerosign"], ["proof (prove)\nusing this:\n  is_finite (IEEE.round To_nearest x)\n  is_finite (zerosign ?s ?a) = is_finite ?a\n\ngoal (1 subgoal):\n 1. is_finite (zerosign s (IEEE.round To_nearest x))", "by auto"], ["proof (state)\nthis:\n  is_finite (zerosign s (IEEE.round To_nearest x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valof_zero[simp]: \"valof 0 = 0\" \"valof minus_zero = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof 0 = 0 &&& valof (- 0) = 0", "by (auto simp add: zerosign_def valof_eq zero_simps)"], ["", "lemma signzero_zero:\n  \"is_zero a \\<Longrightarrow> valof (zerosign s a) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> valof (zerosign s a) = 0", "by (auto simp add: zerosign_def)"], ["", "lemma val_zero: \"is_zero a \\<Longrightarrow> valof a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_zero a \\<Longrightarrow> valof a = 0", "by (cases a rule: is_zero_cases) auto"], ["", "lemma float_add:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a + valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_add: \"is_finite (a + b)\"\n    and error_float_add:  \"valof (a + b) = valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (a + b) &&&\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_finite (a + b)\n 2. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms float_distinct_finite"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<bar>valof a + valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n  \\<not> (is_nan ?a \\<and> is_finite ?a)\n  \\<not> (is_infinity ?a \\<and> is_finite ?a)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by auto"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. is_finite (a + b)\n 2. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "have ab: \"(a + b) =\n    (zerosign\n      (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then (sign a) else 0)\n      (round To_nearest (valof a + valof b)))\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a + b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a\n      else 0)\n     (IEEE.round To_nearest (valof a + valof b))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n  is_finite a\n  is_finite b\n  \\<bar>valof a + valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. a + b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a\n      else 0)\n     (IEEE.round To_nearest (valof a + valof b))", "by (auto simp add: float_defs fadd_def plus_float_def)"], ["proof (state)\nthis:\n  a + b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a else 0)\n   (IEEE.round To_nearest (valof a + valof b))\n\ngoal (2 subgoals):\n 1. is_finite (a + b)\n 2. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "then"], ["proof (chain)\npicking this:\n  a + b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a else 0)\n   (IEEE.round To_nearest (valof a + valof b))", "show \"is_finite ((a + b))\""], ["proof (prove)\nusing this:\n  a + b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a else 0)\n   (IEEE.round To_nearest (valof a + valof b))\n\ngoal (1 subgoal):\n 1. is_finite (a + b)", "by (metis threshold defloat_float_zerosign_round_finite)"], ["proof (state)\nthis:\n  is_finite (a + b)\n\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "have val_ab: \"valof (a + b) =\n    valof (zerosign\n      (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then (sign a) else 0)\n      (round To_nearest (valof a + valof b)::('e, 'f)float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof\n     (zerosign\n       (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a\n        else 0)\n       (IEEE.round To_nearest (valof a + valof b)))", "by (auto simp: ab is_infinity_def is_nan_def valof_def)"], ["proof (state)\nthis:\n  valof (a + b) =\n  valof\n   (zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a = sign b then sign a\n      else 0)\n     (IEEE.round To_nearest (valof a + valof b)))\n\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "show \"valof (a + b) = valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "proof (cases \"is_zero (round To_nearest (valof a + valof b)::('e, 'f)float)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "case True"], ["proof (state)\nthis:\n  is_zero (IEEE.round To_nearest (valof a + valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "have \"valof a + valof b + error TYPE(('e, 'f)float) (valof a + valof b) =\n        valof (round To_nearest (valof a + valof b)::('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a + valof b +\n    error TYPE(('e, 'f) IEEE.float) (valof a + valof b) =\n    valof (IEEE.round To_nearest (valof a + valof b))", "unfolding error_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a + valof b +\n    (valof (IEEE.round To_nearest (valof a + valof b)) -\n     (valof a + valof b)) =\n    valof (IEEE.round To_nearest (valof a + valof b))", "by simp"], ["proof (state)\nthis:\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b) =\n  valof (IEEE.round To_nearest (valof a + valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "then"], ["proof (chain)\npicking this:\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b) =\n  valof (IEEE.round To_nearest (valof a + valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b) =\n  valof (IEEE.round To_nearest (valof a + valof b))\n\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "by (metis True signzero_zero val_zero val_ab)"], ["proof (state)\nthis:\n  valof (a + b) =\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero (IEEE.round To_nearest (valof a + valof b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a + valof b)) \\<Longrightarrow>\n    valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a + valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a + valof b))\n\ngoal (1 subgoal):\n 1. valof (a + b) =\n    valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)", "by (metis ab add.commute eq_diff_eq' error_def zerosign_def)"], ["proof (state)\nthis:\n  valof (a + b) =\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valof (a + b) =\n  valof a + valof b + error TYPE(('e, 'f) IEEE.float) (valof a + valof b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_sub:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a - valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_sub: \"is_finite (a - b)\"\n    and error_float_sub: \"valof (a - b) = valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (a - b) &&&\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_finite (a - b)\n 2. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "have \"\\<not> is_nan a\" and \"\\<not> is_nan b\" and \"\\<not> is_infinity a\" and \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<bar>valof a - valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by (auto simp: finite_nan finite_infinity)"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. is_finite (a - b)\n 2. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "have ab: \"a - b =\n    (zerosign\n      (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a else 0)\n      (round To_nearest (valof a - valof b)))\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a - b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n  is_finite a\n  is_finite b\n  \\<bar>valof a - valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. a - b =\n    zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b))", "by (auto simp add: float_defs fsub_def minus_float_def)"], ["proof (state)\nthis:\n  a - b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b))\n\ngoal (2 subgoals):\n 1. is_finite (a - b)\n 2. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "then"], ["proof (chain)\npicking this:\n  a - b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b))", "show \"is_finite (a - b)\""], ["proof (prove)\nusing this:\n  a - b =\n  zerosign\n   (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a\n    else 0)\n   (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. is_finite (a - b)", "by (metis threshold defloat_float_zerosign_round_finite)"], ["proof (state)\nthis:\n  is_finite (a - b)\n\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "have val_ab: \"valof (a - b) =\n    valof (zerosign\n      (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b then sign a else 0)\n      (round To_nearest (valof a - valof b)::('e, 'f)float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof\n     (zerosign\n       (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n        then sign a else 0)\n       (IEEE.round To_nearest (valof a - valof b)))", "by (auto simp: ab is_infinity_def is_nan_def valof_def)"], ["proof (state)\nthis:\n  valof (a - b) =\n  valof\n   (zerosign\n     (if is_zero a \\<and> is_zero b \\<and> sign a \\<noteq> sign b\n      then sign a else 0)\n     (IEEE.round To_nearest (valof a - valof b)))\n\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "show \"valof (a - b) = valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "proof (cases \"is_zero (round To_nearest (valof a - valof b)::('e, 'f)float)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "case True"], ["proof (state)\nthis:\n  is_zero (IEEE.round To_nearest (valof a - valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "have \"valof a - valof b + error TYPE(('e, 'f)float) (valof a - valof b) =\n        valof (round To_nearest (valof a - valof b)::('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a - valof b +\n    error TYPE(('e, 'f) IEEE.float) (valof a - valof b) =\n    valof (IEEE.round To_nearest (valof a - valof b))", "unfolding error_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a - valof b +\n    (valof (IEEE.round To_nearest (valof a - valof b)) -\n     (valof a - valof b)) =\n    valof (IEEE.round To_nearest (valof a - valof b))", "by simp"], ["proof (state)\nthis:\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b) =\n  valof (IEEE.round To_nearest (valof a - valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "then"], ["proof (chain)\npicking this:\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b) =\n  valof (IEEE.round To_nearest (valof a - valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b) =\n  valof (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "by (metis True signzero_zero val_zero val_ab)"], ["proof (state)\nthis:\n  valof (a - b) =\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a - valof b)) \\<Longrightarrow>\n    valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a - valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a - valof b))\n\ngoal (1 subgoal):\n 1. valof (a - b) =\n    valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)", "by (metis ab add.commute eq_diff_eq' error_def zerosign_def)"], ["proof (state)\nthis:\n  valof (a - b) =\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valof (a - b) =\n  valof a - valof b + error TYPE(('e, 'f) IEEE.float) (valof a - valof b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_mul:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and threshold: \"\\<bar>valof a * valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_mul: \"is_finite (a * b)\"\n    and error_float_mul: \"valof (a * b) = valof a * valof b + error TYPE(('e, 'f)float) (valof a * valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (a * b) &&&\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_finite (a * b)\n 2. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "have non: \"\\<not> is_nan a\" \"\\<not> is_nan b\" \"\\<not> is_infinity a\" \"\\<not> is_infinity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "using assms float_distinct_finite"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<bar>valof a * valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n  \\<not> (is_nan ?a \\<and> is_finite ?a)\n  \\<not> (is_infinity ?a \\<and> is_finite ?a)\n\ngoal (1 subgoal):\n 1. (\\<not> is_nan a &&& \\<not> is_nan b) &&&\n    \\<not> is_infinity a &&& \\<not> is_infinity b", "by auto"], ["proof (state)\nthis:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (2 subgoals):\n 1. is_finite (a * b)\n 2. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b", "have ab: \"a * b =\n    (zerosign (of_bool (sign a \\<noteq> sign b))\n      (round To_nearest (valof a * valof b)::('e, 'f)float))\""], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n\ngoal (1 subgoal):\n 1. a * b =\n    zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a * valof b))", "using assms"], ["proof (prove)\nusing this:\n  \\<not> is_nan a\n  \\<not> is_nan b\n  \\<not> is_infinity a\n  \\<not> is_infinity b\n  is_finite a\n  is_finite b\n  \\<bar>valof a * valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. a * b =\n    zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a * valof b))", "by (auto simp: float_defs fmul_def times_float_def)"], ["proof (state)\nthis:\n  a * b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a * valof b))\n\ngoal (2 subgoals):\n 1. is_finite (a * b)\n 2. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "then"], ["proof (chain)\npicking this:\n  a * b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a * valof b))", "show \"is_finite (a * b)\""], ["proof (prove)\nusing this:\n  a * b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a * valof b))\n\ngoal (1 subgoal):\n 1. is_finite (a * b)", "by (metis threshold defloat_float_zerosign_round_finite)"], ["proof (state)\nthis:\n  is_finite (a * b)\n\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "have val_ab: \"valof (a * b) =\n      valof (zerosign (of_bool (sign a \\<noteq> sign b))\n        (round To_nearest (valof a * valof b)::('e, 'f)float))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof\n     (zerosign (of_bool (sign a \\<noteq> sign b))\n       (IEEE.round To_nearest (valof a * valof b)))", "by (auto simp: ab float_defs of_bool_def)"], ["proof (state)\nthis:\n  valof (a * b) =\n  valof\n   (zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a * valof b)))\n\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "show \"valof (a * b) = valof a * valof b + error TYPE(('e, 'f)float) (valof a * valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "proof (cases \"is_zero (round To_nearest (valof a * valof b)::('e, 'f)float)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "case True"], ["proof (state)\nthis:\n  is_zero (IEEE.round To_nearest (valof a * valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "have \"valof a * valof b + error TYPE(('e, 'f)float)  (valof a * valof b) =\n        valof (round To_nearest (valof a * valof b)::('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a * valof b +\n    error TYPE(('e, 'f) IEEE.float) (valof a * valof b) =\n    valof (IEEE.round To_nearest (valof a * valof b))", "unfolding error_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a * valof b +\n    (valof (IEEE.round To_nearest (valof a * valof b)) -\n     valof a * valof b) =\n    valof (IEEE.round To_nearest (valof a * valof b))", "by simp"], ["proof (state)\nthis:\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b) =\n  valof (IEEE.round To_nearest (valof a * valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "then"], ["proof (chain)\npicking this:\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b) =\n  valof (IEEE.round To_nearest (valof a * valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b) =\n  valof (IEEE.round To_nearest (valof a * valof b))\n\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "by (metis True signzero_zero val_zero val_ab)"], ["proof (state)\nthis:\n  valof (a * b) =\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero (IEEE.round To_nearest (valof a * valof b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a * valof b)) \\<Longrightarrow>\n    valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a * valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a * valof b))\n\ngoal (1 subgoal):\n 1. valof (a * b) =\n    valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)", "by (metis ab add.commute eq_diff_eq' error_def zerosign_def)"], ["proof (state)\nthis:\n  valof (a * b) =\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valof (a * b) =\n  valof a * valof b + error TYPE(('e, 'f) IEEE.float) (valof a * valof b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma float_div:\n  fixes a b::\"('e, 'f)float\"\n  assumes \"is_finite a\"\n    and \"is_finite b\"\n    and not_zero: \"\\<not> is_zero b\"\n    and threshold: \"\\<bar>valof a / valof b\\<bar> < threshold TYPE(('e, 'f)float)\"\n  shows finite_float_div: \"is_finite (a / b)\"\n    and error_float_div: \"valof (a / b) = valof a / valof b + error TYPE(('e, 'f)float) (valof a / valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_finite (a / b) &&&\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. is_finite (a / b)\n 2. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "have ab: \"a / b =\n    (zerosign (of_bool (sign a \\<noteq> sign b))\n      (round To_nearest (valof a / valof b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a / b =\n    zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a / valof b))", "using assms"], ["proof (prove)\nusing this:\n  is_finite a\n  is_finite b\n  \\<not> is_zero b\n  \\<bar>valof a / valof b\\<bar> < threshold TYPE(('e, 'f) IEEE.float)\n\ngoal (1 subgoal):\n 1. a / b =\n    zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a / valof b))", "by (simp add: divide_float_def fdiv_def finite_infinity finite_nan not_zero float_defs [symmetric])"], ["proof (state)\nthis:\n  a / b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a / valof b))\n\ngoal (2 subgoals):\n 1. is_finite (a / b)\n 2. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "then"], ["proof (chain)\npicking this:\n  a / b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a / valof b))", "show \"is_finite (a / b)\""], ["proof (prove)\nusing this:\n  a / b =\n  zerosign (of_bool (sign a \\<noteq> sign b))\n   (IEEE.round To_nearest (valof a / valof b))\n\ngoal (1 subgoal):\n 1. is_finite (a / b)", "by (metis threshold defloat_float_zerosign_round_finite)"], ["proof (state)\nthis:\n  is_finite (a / b)\n\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "have val_ab: \"valof (a / b) =\n      valof (zerosign (of_bool (sign a \\<noteq> sign b))\n        (round To_nearest (valof a / valof b))::('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof\n     (zerosign (of_bool (sign a \\<noteq> sign b))\n       (IEEE.round To_nearest (valof a / valof b)))", "by (auto simp: ab float_defs of_bool_def)"], ["proof (state)\nthis:\n  valof (a / b) =\n  valof\n   (zerosign (of_bool (sign a \\<noteq> sign b))\n     (IEEE.round To_nearest (valof a / valof b)))\n\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "show \"valof (a / b) = valof a / valof b + error TYPE(('e, 'f)float)  (valof a / valof b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "proof (cases \"is_zero (round To_nearest (valof a / valof b)::('e, 'f)float)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "case True"], ["proof (state)\nthis:\n  is_zero (IEEE.round To_nearest (valof a / valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "have \"valof a / valof b + error TYPE(('e, 'f)float) (valof a / valof b) =\n        valof (round To_nearest (valof a / valof b)::('e, 'f)float)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a / valof b +\n    error TYPE(('e, 'f) IEEE.float) (valof a / valof b) =\n    valof (IEEE.round To_nearest (valof a / valof b))", "unfolding error_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valof a / valof b +\n    (valof (IEEE.round To_nearest (valof a / valof b)) -\n     valof a / valof b) =\n    valof (IEEE.round To_nearest (valof a / valof b))", "by simp"], ["proof (state)\nthis:\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b) =\n  valof (IEEE.round To_nearest (valof a / valof b))\n\ngoal (2 subgoals):\n 1. is_zero (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n 2. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "then"], ["proof (chain)\npicking this:\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b) =\n  valof (IEEE.round To_nearest (valof a / valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b) =\n  valof (IEEE.round To_nearest (valof a / valof b))\n\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "by (metis True signzero_zero val_zero val_ab)"], ["proof (state)\nthis:\n  valof (a / b) =\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "case False"], ["proof (state)\nthis:\n  \\<not> is_zero (IEEE.round To_nearest (valof a / valof b))\n\ngoal (1 subgoal):\n 1. \\<not> is_zero\n            (IEEE.round To_nearest (valof a / valof b)) \\<Longrightarrow>\n    valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "then"], ["proof (chain)\npicking this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a / valof b))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> is_zero (IEEE.round To_nearest (valof a / valof b))\n\ngoal (1 subgoal):\n 1. valof (a / b) =\n    valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)", "by (metis ab add.commute eq_diff_eq' error_def zerosign_def)"], ["proof (state)\nthis:\n  valof (a / b) =\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valof (a / b) =\n  valof a / valof b + error TYPE(('e, 'f) IEEE.float) (valof a / valof b)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valof_one[simp]: \"valof (1::('e, 'f)float) = (if LENGTH('e) \\<le> 1 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valof 1 = (if LENGTH('e) \\<le> 1 then 0 else 1)", "by transfer (auto simp: bias_def unat_sub word_1_le_power p2_eq_1)"], ["", "end"]]}