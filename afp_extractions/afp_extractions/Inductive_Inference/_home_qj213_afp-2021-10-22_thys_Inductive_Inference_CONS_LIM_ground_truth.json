{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/CONS_LIM.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma rmge2:\n  assumes \"xs = list_decode e\"\n  shows \"rmge2 e =\n   (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n    else Some (xs ! (GREATEST i. i < length xs \\<and> xs ! i \\<ge> 2)))\"", "lemma rmge2_init:\n  \"rmge2 (f \\<triangleright> n) =\n   (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n    else Some (the (f (GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2))))\"", "lemma rmge2_in_R1: \"rmge2 \\<in> \\<R>\"", "lemma U_LIMCONS_in_Lim: \"U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM\"", "lemma goedel_at:\n  fixes m :: nat and k :: nat\n  assumes \"f \\<in> \\<R>\"\n  shows \"\\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)\"", "lemma U_LIMCONS_prefix_complete:\n  assumes \"length vs > 0\"\n  shows \"\\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs\"", "lemma U_prefix_complete_imp_total_strategy:\n  assumes \"\\<And>vs. length vs > 0 \\<Longrightarrow> \\<exists>f\\<in>U. prefix f (length vs - 1) = vs\"\n    and \"learn_cons \\<psi> U s\"\n  shows \"\\<exists>t. total1 t \\<and> learn_cons \\<psi> U t\"", "lemma r_s_recfn [simp]: \"recfn 1 r_s\"\n  and r_s_total [simp]: \"\\<And>x. eval r_s [x] \\<down>\"\n  and eval_r_s: \"s = (\\<lambda>x. eval r_s [x])\"", "lemma r_prefixes_aux_recfn: \"recfn 3 r_prefixes_aux\"", "lemma r_prefixes_aux:\n  \"eval r_prefixes_aux [j, v, i] \\<down>=\n    e_snoc v (if eval r_s [e_snoc v 0] = eval r_s [v] then 1 else 0)\"", "lemma r_prefixes_recfn: \"recfn 2 r_prefixes\"", "lemma r_prefixes: \"eval r_prefixes [i, n] \\<down>= list_encode (prefixes i n)\"", "lemma prefixes_neq_nil: \"length (prefixes i x) > 0\"", "lemma psi_in_R2: \"\\<psi> \\<in> \\<R>\\<^sup>2\"", "lemma psi_0_or_1:\n  assumes \"n > 0\"\n  shows \"\\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1\"", "lemma psi_init: \"(\\<psi> i) \\<triangleright> x = list_encode (prefixes i x)\"", "lemma ex_psi_in_U: \"\\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\"", "lemma U_LIMCONS_not_learn_cons: \"\\<not> learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\"", "lemma U_LIMCONS_not_in_CONS: \"U\\<^bsub>LIM-CONS\\<^esub> \\<notin> CONS\"", "theorem CONS_subset_Lim: \"CONS \\<subset> LIM\""], "translations": [["", "lemma rmge2:\n  assumes \"xs = list_decode e\"\n  shows \"rmge2 e =\n   (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n    else Some (xs ! (GREATEST i. i < length xs \\<and> xs ! i \\<ge> 2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "have \"(i < e_length e \\<and> e_nth e i \\<ge> 2) = (i < length xs \\<and> xs ! i \\<ge> 2)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i < e_length e \\<and> 2 \\<le> e_nth e i) =\n    (i < length xs \\<and> 2 \\<le> xs ! i)", "using assms"], ["proof (prove)\nusing this:\n  xs = Partial_Recursive.list_decode e\n\ngoal (1 subgoal):\n 1. (i < e_length e \\<and> 2 \\<le> e_nth e i) =\n    (i < length xs \\<and> 2 \\<le> xs ! i)", "by simp"], ["proof (state)\nthis:\n  (?i < e_length e \\<and> 2 \\<le> e_nth e ?i) =\n  (?i < length xs \\<and> 2 \\<le> xs ! ?i)\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "then"], ["proof (chain)\npicking this:\n  (?i < e_length e \\<and> 2 \\<le> e_nth e ?i) =\n  (?i < length xs \\<and> 2 \\<le> xs ! ?i)", "have \"(GREATEST i. i < e_length e \\<and> e_nth e i \\<ge> 2) =\n      (GREATEST i. i < length xs \\<and> xs ! i \\<ge> 2)\""], ["proof (prove)\nusing this:\n  (?i < e_length e \\<and> 2 \\<le> e_nth e ?i) =\n  (?i < length xs \\<and> 2 \\<le> xs ! ?i)\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n    (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)", "by simp"], ["proof (state)\nthis:\n  (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "moreover"], ["proof (state)\nthis:\n  (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "have \"(\\<forall>i<length xs. xs ! i < 2) = (\\<forall>i<e_length e. e_nth e i < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<length xs. xs ! i < 2) =\n    (\\<forall>i<e_length e. e_nth e i < 2)", "using assms"], ["proof (prove)\nusing this:\n  xs = Partial_Recursive.list_decode e\n\ngoal (1 subgoal):\n 1. (\\<forall>i<length xs. xs ! i < 2) =\n    (\\<forall>i<e_length e. e_nth e i < 2)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i<length xs. xs ! i < 2) =\n  (\\<forall>i<e_length e. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>i<length xs. xs ! i < 2) =\n  (\\<forall>i<e_length e. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "have \"(GREATEST i. i < length xs \\<and> xs ! i \\<ge> 2) < length xs\" (is \"Greatest ?P < _\")\n      if \"\\<not> (\\<forall>i<length xs. xs ! i < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs", "using that GreatestI_ex_nat[of ?P] le_less_linear order.asym"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<length xs. xs ! i < 2)\n  \\<lbrakk>\\<exists>k<length xs. 2 \\<le> xs ! k;\n   \\<And>y.\n      y < length xs \\<and> 2 \\<le> xs ! y \\<Longrightarrow>\n      y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n                    < length xs \\<and>\n                    2 \\<le> xs !\n                            (GREATEST i.\n                                i < length xs \\<and> 2 \\<le> xs ! i)\n  ?x \\<le> ?y \\<or> ?y < ?x\n  \\<lbrakk>?a < ?b; ?b < ?a\\<rbrakk> \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<length xs. xs ! i < 2) \\<Longrightarrow>\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "ultimately"], ["proof (chain)\npicking this:\n  (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n  (\\<forall>i<length xs. xs ! i < 2) =\n  (\\<forall>i<e_length e. e_nth e i < 2)\n  \\<not> (\\<forall>i<length xs. xs ! i < 2) \\<Longrightarrow>\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs", "show ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n  (\\<forall>i<length xs. xs ! i < 2) =\n  (\\<forall>i<e_length e. e_nth e i < 2)\n  \\<not> (\\<forall>i<length xs. xs ! i < 2) \\<Longrightarrow>\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "using rmge2_def assms"], ["proof (prove)\nusing this:\n  (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)\n  (\\<forall>i<length xs. xs ! i < 2) =\n  (\\<forall>i<e_length e. e_nth e i < 2)\n  \\<not> (\\<forall>i<length xs. xs ! i < 2) \\<Longrightarrow>\n  (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i) < length xs\n  rmge2 ?e \\<equiv>\n  if \\<forall>i<e_length ?e. e_nth ?e i < 2 then Some 0\n  else Some\n        (e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n  xs = Partial_Recursive.list_decode e\n\ngoal (1 subgoal):\n 1. rmge2 e =\n    (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n     else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))", "by auto"], ["proof (state)\nthis:\n  rmge2 e =\n  (if \\<forall>i<length xs. xs ! i < 2 then Some 0\n   else Some (xs ! (GREATEST i. i < length xs \\<and> 2 \\<le> xs ! i)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rmge2_init:\n  \"rmge2 (f \\<triangleright> n) =\n   (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n    else Some (the (f (GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "let ?xs = \"prefix f n\""], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "have \"f \\<triangleright> n = list_encode ?xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)", "by (simp add: init_def)"], ["proof (state)\nthis:\n  f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "moreover"], ["proof (state)\nthis:\n  f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "have \"(\\<forall>i<Suc n. the (f i) < 2) = (\\<forall>i<length ?xs. ?xs ! i < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i<Suc n. the (f i) < 2) =\n    (\\<forall>i<length (prefix f n). prefix f n ! i < 2)", "by simp"], ["proof (state)\nthis:\n  (\\<forall>i<Suc n. the (f i) < 2) =\n  (\\<forall>i<length (prefix f n). prefix f n ! i < 2)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "moreover"], ["proof (state)\nthis:\n  (\\<forall>i<Suc n. the (f i) < 2) =\n  (\\<forall>i<length (prefix f n). prefix f n ! i < 2)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "have \"(GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2) =\n      (GREATEST i. i < length ?xs \\<and> ?xs ! i \\<ge> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n    (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)", "using length_prefix[of f n] prefix_nth[of _ n f]"], ["proof (prove)\nusing this:\n  length (prefix f n) = Suc n\n  ?k < Suc n \\<Longrightarrow> prefix f n ! ?k = the (f ?k)\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n    (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)", "by metis"], ["proof (state)\nthis:\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n  (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "moreover"], ["proof (state)\nthis:\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n  (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "have \"(GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2) < Suc n\"\n      if \"\\<not> (\\<forall>i<Suc n. the (f i) < 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n", "using that GreatestI_ex_nat[of \"\\<lambda>i. i<Suc n \\<and> the (f i) \\<ge> 2\" n]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2)\n  \\<lbrakk>\\<exists>k<Suc n. 2 \\<le> the (f k);\n   \\<And>y.\n      y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n      y \\<le> n\\<rbrakk>\n  \\<Longrightarrow> (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))\n                    < Suc n \\<and>\n                    2 \\<le> the (f (GREATEST i.\n i < Suc n \\<and> 2 \\<le> the (f i)))\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n", "by fastforce"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2) \\<Longrightarrow>\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "ultimately"], ["proof (chain)\npicking this:\n  f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)\n  (\\<forall>i<Suc n. the (f i) < 2) =\n  (\\<forall>i<length (prefix f n). prefix f n ! i < 2)\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n  (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2) \\<Longrightarrow>\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)\n  (\\<forall>i<Suc n. the (f i) < 2) =\n  (\\<forall>i<length (prefix f n). prefix f n ! i < 2)\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n  (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2) \\<Longrightarrow>\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "using rmge2"], ["proof (prove)\nusing this:\n  f \\<triangleright> n = Partial_Recursive.list_encode (prefix f n)\n  (\\<forall>i<Suc n. the (f i) < 2) =\n  (\\<forall>i<length (prefix f n). prefix f n ! i < 2)\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) =\n  (GREATEST i. i < length (prefix f n) \\<and> 2 \\<le> prefix f n ! i)\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2) \\<Longrightarrow>\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) < Suc n\n  ?xs = Partial_Recursive.list_decode ?e \\<Longrightarrow>\n  rmge2 ?e =\n  (if \\<forall>i<length ?xs. ?xs ! i < 2 then Some 0\n   else Some (?xs ! (GREATEST i. i < length ?xs \\<and> 2 \\<le> ?xs ! i)))\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))", "by auto"], ["proof (state)\nthis:\n  rmge2 (f \\<triangleright> n) =\n  (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n   else Some (the (f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary rmge2_init_total:\n  assumes \"total1 f\"\n  shows \"rmge2 (f \\<triangleright> n) =\n   (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n    else f (GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))", "using assms total1_def rmge2_init"], ["proof (prove)\nusing this:\n  total1 f\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n  rmge2 (?f \\<triangleright> ?n) =\n  (if \\<forall>i<Suc ?n. the (?f i) < 2 then Some 0\n   else Some (the (?f (GREATEST i. i < Suc ?n \\<and> 2 \\<le> the (?f i)))))\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    (if \\<forall>i<Suc n. the (f i) < 2 then Some 0\n     else f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)))", "by auto"], ["", "lemma rmge2_in_R1: \"rmge2 \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "define g where\n    \"g = Cn 3 r_ifle [r_constn 2 2, Cn 3 r_nth [Id 3 2, Id 3 0], Cn 3 r_nth [Id 3 2, Id 3 0], Id 3 1]\""], ["proof (state)\nthis:\n  g =\n  Cn 3 r_ifle\n   [r_constn 2 2, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0],\n    Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0], recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  g =\n  Cn 3 r_ifle\n   [r_constn 2 2, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0],\n    Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0], recf.Id 3 1]", "have \"recfn 3 g\""], ["proof (prove)\nusing this:\n  g =\n  Cn 3 r_ifle\n   [r_constn 2 2, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0],\n    Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0], recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. recfn 3 g", "by simp"], ["proof (state)\nthis:\n  recfn 3 g\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  recfn 3 g", "have g: \"eval g [j, r, e] \\<down>= (if 2 \\<le> e_nth e j then e_nth e j else r)\" for j r e"], ["proof (prove)\nusing this:\n  recfn 3 g\n\ngoal (1 subgoal):\n 1. eval g [j, r, e] \\<down>= (if 2 \\<le> e_nth e j then e_nth e j else r)", "using g_def"], ["proof (prove)\nusing this:\n  recfn 3 g\n  g =\n  Cn 3 r_ifle\n   [r_constn 2 2, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0],\n    Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0], recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. eval g [j, r, e] \\<down>= (if 2 \\<le> e_nth e j then e_nth e j else r)", "by simp"], ["proof (state)\nthis:\n  eval g [?j, ?r, ?e] \\<down>=\n  (if 2 \\<le> e_nth ?e ?j then e_nth ?e ?j else ?r)\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "let ?h = \"Pr 1 Z g\""], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "have \"recfn 2 ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Pr 1 Z g)", "by (simp add: \\<open>recfn 3 g\\<close>)"], ["proof (state)\nthis:\n  recfn 2 (Pr 1 Z g)\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "have h: \"eval ?h [j, e] =\n   (if \\<forall>i<j. e_nth e i < 2 then Some 0\n    else Some (e_nth e (GREATEST i. i < j \\<and> e_nth e i \\<ge> 2)))\" for j e"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [j, e] =\n    (if \\<forall>i<j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (Pr 1 Z g) [0, e] =\n    (if \\<forall>i<0. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < 0 \\<and> 2 \\<le> e_nth e i)))\n 2. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval (Pr 1 Z g) [0, e] =\n    (if \\<forall>i<0. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < 0 \\<and> 2 \\<le> e_nth e i)))\n 2. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [0, e] =\n    (if \\<forall>i<0. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < 0 \\<and> 2 \\<le> e_nth e i)))", "using \\<open>recfn 2 ?h\\<close>"], ["proof (prove)\nusing this:\n  recfn 2 (Pr 1 Z g)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [0, e] =\n    (if \\<forall>i<0. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < 0 \\<and> 2 \\<le> e_nth e i)))", "by auto"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [0, e] =\n  (if \\<forall>i<0. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < 0 \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case (Suc j)"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [j, e] =\n  (if \\<forall>i<j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [j, e] =\n  (if \\<forall>i<j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))", "have \"eval ?h [Suc j, e] = eval g [j, the (eval ?h [j, e]), e]\""], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [j, e] =\n  (if \\<forall>i<j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]", "using \\<open>recfn 2 ?h\\<close>"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [j, e] =\n  (if \\<forall>i<j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))\n  recfn 2 (Pr 1 Z g)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]", "by auto"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]", "have *: \"eval ?h [Suc j, e] \\<down>=\n      (if 2 \\<le> e_nth e j then e_nth e j\n       else if \\<forall>i<j. e_nth e i < 2 then 0\n            else (e_nth e (GREATEST i. i < j \\<and> e_nth e i \\<ge> 2)))\""], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>=\n    (if 2 \\<le> e_nth e j then e_nth e j\n     else if \\<forall>i<j. e_nth e i < 2 then 0\n          else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))", "using g Suc"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] = eval g [j, the (eval (Pr 1 Z g) [j, e]), e]\n  eval g [?j, ?r, ?e] \\<down>=\n  (if 2 \\<le> e_nth ?e ?j then e_nth ?e ?j else ?r)\n  eval (Pr 1 Z g) [j, e] =\n  (if \\<forall>i<j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>=\n    (if 2 \\<le> e_nth e j then e_nth e j\n     else if \\<forall>i<j. e_nth e i < 2 then 0\n          else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))", "by auto"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       eval (Pr 1 Z g) [j, e] =\n       (if \\<forall>i<j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e\n                (GREATEST i.\n                    i < j \\<and> 2 \\<le> e_nth e i))) \\<Longrightarrow>\n       eval (Pr 1 Z g) [Suc j, e] =\n       (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n        else Some\n              (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "proof (cases \"\\<forall>i<Suc j. e_nth e i < 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i<Suc j. e_nth e i < 2 \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> (\\<forall>i<Suc j. e_nth e i < 2) \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case True"], ["proof (state)\nthis:\n  \\<forall>i<Suc j. e_nth e i < 2\n\ngoal (2 subgoals):\n 1. \\<forall>i<Suc j. e_nth e i < 2 \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> (\\<forall>i<Suc j. e_nth e i < 2) \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<Suc j. e_nth e i < 2", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc j. e_nth e i < 2\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "using *"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc j. e_nth e i < 2\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "by auto"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] =\n  (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<Suc j. e_nth e i < 2) \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<Suc j. e_nth e i < 2) \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case ex: False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<Suc j. e_nth e i < 2) \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "proof (cases \"2 \\<le> e_nth e j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case True"], ["proof (state)\nthis:\n  2 \\<le> e_nth e j\n\ngoal (2 subgoals):\n 1. 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:\n  2 \\<le> e_nth e j", "have \"eval ?h [Suc j, e] \\<down>= e_nth e j\""], ["proof (prove)\nusing this:\n  2 \\<le> e_nth e j\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j", "using *"], ["proof (prove)\nusing this:\n  2 \\<le> e_nth e j\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j", "by simp"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j\n\ngoal (2 subgoals):\n 1. 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "moreover"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j\n\ngoal (2 subgoals):\n 1. 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "have \"(GREATEST i. i < Suc j \\<and> e_nth e i \\<ge> 2) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j", "using ex True Greatest_equality[of \"\\<lambda>i.  i < Suc j \\<and> e_nth e i \\<ge> 2\"]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n  2 \\<le> e_nth e j\n  \\<lbrakk>?x < Suc j \\<and> 2 \\<le> e_nth e ?x;\n   \\<And>y.\n      y < Suc j \\<and> 2 \\<le> e_nth e y \\<Longrightarrow>\n      y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = ?x\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j", "by simp"], ["proof (state)\nthis:\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j\n\ngoal (2 subgoals):\n 1. 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n 2. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "ultimately"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "using ex"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>= e_nth e j\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) = j\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "by auto"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] =\n  (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "case False"], ["proof (state)\nthis:\n  \\<not> 2 \\<le> e_nth e j\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "then"], ["proof (chain)\npicking this:\n  \\<not> 2 \\<le> e_nth e j", "have \"\\<exists>i<j. e_nth e i \\<ge> 2\""], ["proof (prove)\nusing this:\n  \\<not> 2 \\<le> e_nth e j\n\ngoal (1 subgoal):\n 1. \\<exists>i<j. 2 \\<le> e_nth e i", "using ex leI less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<not> 2 \\<le> e_nth e j\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>i<j. 2 \\<le> e_nth e i", "by blast"], ["proof (state)\nthis:\n  \\<exists>i<j. 2 \\<le> e_nth e i\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "with *"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n  \\<exists>i<j. 2 \\<le> e_nth e i", "have \"eval ?h [Suc j, e] \\<down>= e_nth e (GREATEST i. i < j \\<and> e_nth e i \\<ge> 2)\""], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n  \\<exists>i<j. 2 \\<le> e_nth e i\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>=\n    e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)", "using False"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  (if 2 \\<le> e_nth e j then e_nth e j\n   else if \\<forall>i<j. e_nth e i < 2 then 0\n        else e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i))\n  \\<exists>i<j. 2 \\<le> e_nth e i\n  \\<not> 2 \\<le> e_nth e j\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] \\<down>=\n    e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)", "by (smt leD)"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "moreover"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "have \"(GREATEST i. i < Suc j \\<and> e_nth e i \\<ge> 2) =\n            (GREATEST i. i < j \\<and> e_nth e i \\<ge> 2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n    (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)", "using False ex"], ["proof (prove)\nusing this:\n  \\<not> 2 \\<le> e_nth e j\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n    (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)", "by (metis less_SucI less_Suc_eq less_antisym numeral_2_eq_2)"], ["proof (state)\nthis:\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n\ngoal (1 subgoal):\n 1. \\<not> 2 \\<le> e_nth e j \\<Longrightarrow>\n    eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "ultimately"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "using ex"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [Suc j, e] \\<down>=\n  e_nth e (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n  (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i) =\n  (GREATEST i. i < j \\<and> 2 \\<le> e_nth e i)\n  \\<not> (\\<forall>i<Suc j. e_nth e i < 2)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z g) [Suc j, e] =\n    (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n     else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))", "by metis"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] =\n  (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] =\n  (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [Suc j, e] =\n  (if \\<forall>i<Suc j. e_nth e i < 2 then Some 0\n   else Some (e_nth e (GREATEST i. i < Suc j \\<and> 2 \\<le> e_nth e i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Pr 1 Z g) [?j, ?e] =\n  (if \\<forall>i<?j. e_nth ?e i < 2 then Some 0\n   else Some (e_nth ?e (GREATEST i. i < ?j \\<and> 2 \\<le> e_nth ?e i)))\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "let ?hh = \"Cn 1 ?h [Cn 1 r_length [Id 1 0], Id 1 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "have \"recfn 1 ?hh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "using \\<open>recfn 2 ?h\\<close>"], ["proof (prove)\nusing this:\n  recfn 2 (Pr 1 Z g)\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "with h"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z g) [?j, ?e] =\n  (if \\<forall>i<?j. e_nth ?e i < 2 then Some 0\n   else Some (e_nth ?e (GREATEST i. i < ?j \\<and> 2 \\<le> e_nth ?e i)))\n  recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "have hh: \"eval ?hh [e] \\<down>=\n    (if \\<forall>i<e_length e. e_nth e i < 2 then 0\n     else e_nth e (GREATEST i. i < e_length e \\<and> e_nth e i \\<ge> 2))\" for e"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z g) [?j, ?e] =\n  (if \\<forall>i<?j. e_nth ?e i < 2 then Some 0\n   else Some (e_nth ?e (GREATEST i. i < ?j \\<and> 2 \\<le> e_nth ?e i)))\n  recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n     [e] \\<down>=\n    (if \\<forall>i<e_length e. e_nth e i < 2 then 0\n     else e_nth e (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i))", "by auto"], ["proof (state)\nthis:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n   [?e] \\<down>=\n  (if \\<forall>i<e_length ?e. e_nth ?e i < 2 then 0\n   else e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n   [?e] \\<down>=\n  (if \\<forall>i<e_length ?e. e_nth ?e i < 2 then 0\n   else e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))", "have \"eval ?hh [e] = rmge2 e\" for e"], ["proof (prove)\nusing this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n   [?e] \\<down>=\n  (if \\<forall>i<e_length ?e. e_nth ?e i < 2 then 0\n   else e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n\ngoal (1 subgoal):\n 1. eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [e] =\n    rmge2 e", "unfolding rmge2_def"], ["proof (prove)\nusing this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n   [?e] \\<down>=\n  (if \\<forall>i<e_length ?e. e_nth ?e i < 2 then 0\n   else e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n\ngoal (1 subgoal):\n 1. eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [e] =\n    (if \\<forall>i<e_length e. e_nth e i < 2 then Some 0\n     else Some\n           (e_nth e (GREATEST i. i < e_length e \\<and> 2 \\<le> e_nth e i)))", "by auto"], ["proof (state)\nthis:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [?e] =\n  rmge2 ?e\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "moreover"], ["proof (state)\nthis:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [?e] =\n  rmge2 ?e\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "have \"total ?hh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "using hh totalI1 \\<open>recfn 1 ?hh\\<close>"], ["proof (prove)\nusing this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n   [?e] \\<down>=\n  (if \\<forall>i<e_length ?e. e_nth ?e i < 2 then 0\n   else e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n  \\<lbrakk>recfn 1 ?f; \\<And>x. eval ?f [x] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total\n   (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [?e] =\n  rmge2 ?e\n  Partial_Recursive.total\n   (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [?e] =\n  rmge2 ?e\n  Partial_Recursive.total\n   (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "using \\<open>recfn 1 ?hh\\<close>"], ["proof (prove)\nusing this:\n  eval (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0]) [?e] =\n  rmge2 ?e\n  Partial_Recursive.total\n   (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n  recfn 1 (Cn 1 (Pr 1 Z g) [Cn 1 r_length [recf.Id 1 0], recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. rmge2 \\<in> \\<R>", "by blast"], ["proof (state)\nthis:\n  rmge2 \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The first part of the main result is that @{term \"U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM\"}.\\<close>"], ["", "lemma U_LIMCONS_in_Lim: \"U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "have \"U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>", "unfolding U_LIMCONS_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {vs @ [j] \\<odot> p |vs j p.\n     2 \\<le> j \\<and>\n     p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and> \\<phi> j = vs @ [j] \\<odot> p}\n    \\<subseteq> \\<R>", "using prepend_in_R1 RPred1_subseteq_R1"], ["proof (prove)\nusing this:\n  ?f \\<in> \\<R> \\<Longrightarrow> ?vs \\<odot> ?f \\<in> \\<R>\n  \\<R>\\<^sub>0\\<^sub>1 \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. {vs @ [j] \\<odot> p |vs j p.\n     2 \\<le> j \\<and>\n     p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and> \\<phi> j = vs @ [j] \\<odot> p}\n    \\<subseteq> \\<R>", "by blast"], ["proof (state)\nthis:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "have \"learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2", "proof (rule learn_limI)"], ["proof (state)\ngoal (2 subgoals):\n 1. environment \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\n 2. \\<And>f.\n       f \\<in> U\\<^bsub>LIM-CONS\\<^esub> \\<Longrightarrow>\n       \\<exists>i.\n          \\<phi> i = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 rmge2 (f \\<triangleright> n) \\<down>= i)", "show \"environment \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2", "using \\<open>U_LIMCONS \\<subseteq> \\<R>\\<close> phi_in_P2 rmge2_def rmge2_in_R1"], ["proof (prove)\nusing this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>\n  \\<phi> \\<in> \\<P>\\<^sup>2\n  rmge2 ?e \\<equiv>\n  if \\<forall>i<e_length ?e. e_nth ?e i < 2 then Some 0\n  else Some\n        (e_nth ?e (GREATEST i. i < e_length ?e \\<and> 2 \\<le> e_nth ?e i))\n  rmge2 \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. environment \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2", "by simp"], ["proof (state)\nthis:\n  environment \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U\\<^bsub>LIM-CONS\\<^esub> \\<Longrightarrow>\n       \\<exists>i.\n          \\<phi> i = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 rmge2 (f \\<triangleright> n) \\<down>= i)", "show \"\\<exists>i. \\<phi> i = f \\<and> (\\<forall>\\<^sup>\\<infinity>n. rmge2 (f \\<triangleright> n) \\<down>= i)\" if \"f \\<in> U\\<^bsub>LIM-CONS\\<^esub>\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "from that"], ["proof (chain)\npicking this:\n  f \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "obtain vs j p where\n        j: \"j \\<ge> 2\"\n        and p: \"p \\<in> \\<R>\\<^sub>0\\<^sub>1\"\n        and s: \"\\<phi> j = vs @ [j] \\<odot> p\"\n        and f: \"f = vs @ [j] \\<odot> p\""], ["proof (prove)\nusing this:\n  f \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. (\\<And>j p vs.\n        \\<lbrakk>2 \\<le> j; p \\<in> \\<R>\\<^sub>0\\<^sub>1;\n         \\<phi> j = vs @ [j] \\<odot> p; f = vs @ [j] \\<odot> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding U_LIMCONS_def"], ["proof (prove)\nusing this:\n  f \\<in> {vs @ [j] \\<odot> p |vs j p.\n           2 \\<le> j \\<and>\n           p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and>\n           \\<phi> j = vs @ [j] \\<odot> p}\n\ngoal (1 subgoal):\n 1. (\\<And>j p vs.\n        \\<lbrakk>2 \\<le> j; p \\<in> \\<R>\\<^sub>0\\<^sub>1;\n         \\<phi> j = vs @ [j] \\<odot> p; f = vs @ [j] \\<odot> p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  2 \\<le> j\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<phi> j = vs @ [j] \\<odot> p\n  f = vs @ [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "then"], ["proof (chain)\npicking this:\n  2 \\<le> j\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<phi> j = vs @ [j] \\<odot> p\n  f = vs @ [j] \\<odot> p", "have \"\\<phi> j = f\""], ["proof (prove)\nusing this:\n  2 \\<le> j\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<phi> j = vs @ [j] \\<odot> p\n  f = vs @ [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. \\<phi> j = f", "by simp"], ["proof (state)\nthis:\n  \\<phi> j = f\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "from that"], ["proof (chain)\npicking this:\n  f \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "have \"total1 f\""], ["proof (prove)\nusing this:\n  f \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. total1 f", "using \\<open>U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>\\<close> R1_imp_total1 total1_def"], ["proof (prove)\nusing this:\n  f \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  U\\<^bsub>LIM-CONS\\<^esub> \\<subseteq> \\<R>\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. total1 f", "by auto"], ["proof (state)\nthis:\n  total1 f\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "define n\\<^sub>0 where \"n\\<^sub>0 = length vs\""], ["proof (state)\nthis:\n  n\\<^sub>0 = length vs\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "have f_gr_n0: \"f n \\<down>= 0 \\<or> f n \\<down>= 1\" if \"n > n\\<^sub>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f n \\<down>= 0 \\<or> f n \\<down>= 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f n \\<down>= 0 \\<or> f n \\<down>= 1", "have \"f n = p (n - n\\<^sub>0 - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n = p (n - n\\<^sub>0 - 1)", "using that n\\<^sub>0_def f"], ["proof (prove)\nusing this:\n  n\\<^sub>0 < n\n  n\\<^sub>0 = length vs\n  f = vs @ [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. f n = p (n - n\\<^sub>0 - 1)", "by simp"], ["proof (state)\nthis:\n  f n = p (n - n\\<^sub>0 - 1)\n\ngoal (1 subgoal):\n 1. f n \\<down>= 0 \\<or> f n \\<down>= 1", "with RPred1_def p"], ["proof (chain)\npicking this:\n  \\<R>\\<^sub>0\\<^sub>1 \\<equiv>\n  {f \\<in> \\<R>. \\<forall>x. f x \\<down>= 0 \\<or> f x \\<down>= 1}\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  f n = p (n - n\\<^sub>0 - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>0\\<^sub>1 \\<equiv>\n  {f \\<in> \\<R>. \\<forall>x. f x \\<down>= 0 \\<or> f x \\<down>= 1}\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  f n = p (n - n\\<^sub>0 - 1)\n\ngoal (1 subgoal):\n 1. f n \\<down>= 0 \\<or> f n \\<down>= 1", "by auto"], ["proof (state)\nthis:\n  f n \\<down>= 0 \\<or> f n \\<down>= 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n\\<^sub>0 < ?n \\<Longrightarrow> f ?n \\<down>= 0 \\<or> f ?n \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "have \"rmge2 (f \\<triangleright> n) \\<down>= j\" if \"n \\<ge> n\\<^sub>0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "have n0_greatest: \"(GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2) = n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) = n\\<^sub>0", "proof (rule Greatest_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. n\\<^sub>0 < Suc n \\<and> 2 \\<le> the (f n\\<^sub>0)\n 2. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "show \"n\\<^sub>0 < Suc n \\<and> the (f n\\<^sub>0) \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>0 < Suc n \\<and> 2 \\<le> the (f n\\<^sub>0)", "using n\\<^sub>0_def f that j"], ["proof (prove)\nusing this:\n  n\\<^sub>0 = length vs\n  f = vs @ [j] \\<odot> p\n  n\\<^sub>0 \\<le> n\n  2 \\<le> j\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 < Suc n \\<and> 2 \\<le> the (f n\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  n\\<^sub>0 < Suc n \\<and> 2 \\<le> the (f n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "show \"\\<And>y. y < Suc n \\<and> the (f y) \\<ge> 2 \\<Longrightarrow> y \\<le> n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "assume \"y < Suc n \\<and> 2 \\<le> the (f y)\""], ["proof (state)\nthis:\n  y < Suc n \\<and> 2 \\<le> the (f y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "moreover"], ["proof (state)\nthis:\n  y < Suc n \\<and> 2 \\<le> the (f y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "have \"p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)", "using RPred1_def p"], ["proof (prove)\nusing this:\n  \\<R>\\<^sub>0\\<^sub>1 \\<equiv>\n  {f \\<in> \\<R>. \\<forall>x. f x \\<down>= 0 \\<or> f x \\<down>= 1}\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)", "by blast"], ["proof (state)\nthis:\n  p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc n \\<and> 2 \\<le> the (f y) \\<Longrightarrow>\n       y \\<le> n\\<^sub>0", "ultimately"], ["proof (chain)\npicking this:\n  y < Suc n \\<and> 2 \\<le> the (f y)\n  p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)", "show \"y \\<le> n\\<^sub>0\""], ["proof (prove)\nusing this:\n  y < Suc n \\<and> 2 \\<le> the (f y)\n  p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)\n\ngoal (1 subgoal):\n 1. y \\<le> n\\<^sub>0", "using f_gr_n0"], ["proof (prove)\nusing this:\n  y < Suc n \\<and> 2 \\<le> the (f y)\n  p \\<in> \\<R> \\<and> (\\<forall>n. p n \\<down>= 0 \\<or> p n \\<down>= 1)\n  n\\<^sub>0 < ?n \\<Longrightarrow> f ?n \\<down>= 0 \\<or> f ?n \\<down>= 1\n\ngoal (1 subgoal):\n 1. y \\<le> n\\<^sub>0", "by (metis Suc_1 Suc_n_not_le_n Zero_neq_Suc le_less_linear le_zero_eq option.sel)"], ["proof (state)\nthis:\n  y \\<le> n\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y < Suc n \\<and> 2 \\<le> the (f ?y) \\<Longrightarrow> ?y \\<le> n\\<^sub>0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) = n\\<^sub>0\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "have \"f n\\<^sub>0 \\<down>= j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n\\<^sub>0 \\<down>= j", "using n\\<^sub>0_def f"], ["proof (prove)\nusing this:\n  n\\<^sub>0 = length vs\n  f = vs @ [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. f n\\<^sub>0 \\<down>= j", "by simp"], ["proof (state)\nthis:\n  f n\\<^sub>0 \\<down>= j\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "then"], ["proof (chain)\npicking this:\n  f n\\<^sub>0 \\<down>= j", "have \"\\<not> (\\<forall>i<Suc n. the (f i) < 2)\""], ["proof (prove)\nusing this:\n  f n\\<^sub>0 \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<Suc n. the (f i) < 2)", "using j that less_Suc_eq_le"], ["proof (prove)\nusing this:\n  f n\\<^sub>0 \\<down>= j\n  2 \\<le> j\n  n\\<^sub>0 \\<le> n\n  (?m < Suc ?n) = (?m \\<le> ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>i<Suc n. the (f i) < 2)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2)", "have \"rmge2 (f \\<triangleright> n) = f (GREATEST i. i < Suc n \\<and> the (f i) \\<ge> 2)\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2)\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))", "using rmge2_init_total \\<open>total1 f\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>i<Suc n. the (f i) < 2)\n  total1 ?f \\<Longrightarrow>\n  rmge2 (?f \\<triangleright> ?n) =\n  (if \\<forall>i<Suc ?n. the (?f i) < 2 then Some 0\n   else ?f (GREATEST i. i < Suc ?n \\<and> 2 \\<le> the (?f i)))\n  total1 f\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) =\n    f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))", "by auto"], ["proof (state)\nthis:\n  rmge2 (f \\<triangleright> n) =\n  f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "with n0_greatest \\<open>f n\\<^sub>0 \\<down>= j\\<close>"], ["proof (chain)\npicking this:\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) = n\\<^sub>0\n  f n\\<^sub>0 \\<down>= j\n  rmge2 (f \\<triangleright> n) =\n  f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))", "show ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i)) = n\\<^sub>0\n  f n\\<^sub>0 \\<down>= j\n  rmge2 (f \\<triangleright> n) =\n  f (GREATEST i. i < Suc n \\<and> 2 \\<le> the (f i))\n\ngoal (1 subgoal):\n 1. rmge2 (f \\<triangleright> n) \\<down>= j", "by simp"], ["proof (state)\nthis:\n  rmge2 (f \\<triangleright> n) \\<down>= j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n\\<^sub>0 \\<le> ?n \\<Longrightarrow>\n  rmge2 (f \\<triangleright> ?n) \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "with \\<open>\\<phi> j = f\\<close>"], ["proof (chain)\npicking this:\n  \\<phi> j = f\n  n\\<^sub>0 \\<le> ?n \\<Longrightarrow>\n  rmge2 (f \\<triangleright> ?n) \\<down>= j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> j = f\n  n\\<^sub>0 \\<le> ?n \\<Longrightarrow>\n  rmge2 (f \\<triangleright> ?n) \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<phi> i = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              rmge2 (f \\<triangleright> n) \\<down>= i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     \\<phi> i = f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0. rmge2 (f \\<triangleright> n) \\<down>= i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U\\<^bsub>LIM-CONS\\<^esub> \\<Longrightarrow>\n  \\<exists>i.\n     \\<phi> i = ?f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0. rmge2 (?f \\<triangleright> n) \\<down>= i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "then"], ["proof (chain)\npicking this:\n  learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2", "show ?thesis"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "using Lim_def"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> rmge2\n  LIM \\<equiv> {U. \\<exists>\\<psi> s. learn_lim \\<psi> U s}\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM", "by auto"], ["proof (state)\nthis:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The class @{term \"U_LIMCONS\"} is \\emph{prefix-complete}, which\nmeans that every non-empty list is the prefix of some function in @{term\n\"U_LIMCONS\"}. To show this we use an auxiliary lemma: For every $f \\in\n\\mathcal{R}$ and $k \\in \\mathbb{N}$ the value of $f$ at $k$ can be replaced\nby a G?del number of the function resulting from the replacement.\\<close>"], ["", "lemma goedel_at:\n  fixes m :: nat and k :: nat\n  assumes \"f \\<in> \\<R>\"\n  shows \"\\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "define psi :: \"partial1 \\<Rightarrow> nat \\<Rightarrow> partial2\" where\n    \"psi = (\\<lambda>f k i x. (if x = k then Some i else f x))\""], ["proof (state)\nthis:\n  psi = (\\<lambda>f k i x. if x = k then Some i else f x)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "have \"psi f k \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. psi f k \\<in> \\<R>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. psi f k \\<in> \\<R>\\<^sup>2", "obtain r where r: \"recfn 1 r\" \"total r\" \"eval r [x] = f x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n         \\<And>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n         \\<And>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r\n  Partial_Recursive.total r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. psi f k \\<in> \\<R>\\<^sup>2", "define r_psi where\n      \"r_psi = Cn 2 r_ifeq [Id 2 1, r_dummy 1 (r_const k), Id 2 0, Cn 2 r [Id 2 1]]\""], ["proof (state)\nthis:\n  r_psi =\n  Cn 2 r_ifeq\n   [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0, Cn 2 r [recf.Id 2 1]]\n\ngoal (1 subgoal):\n 1. psi f k \\<in> \\<R>\\<^sup>2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. psi f k \\<in> \\<R>\\<^sup>2", "proof (rule R2I[of r_psi])"], ["proof (state)\ngoal (3 subgoals):\n 1. recfn 2 r_psi\n 2. Partial_Recursive.total r_psi\n 3. \\<And>x y. eval r_psi [x, y] = psi f k x y", "from r_psi_def"], ["proof (chain)\npicking this:\n  r_psi =\n  Cn 2 r_ifeq\n   [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0, Cn 2 r [recf.Id 2 1]]", "show \"recfn 2 r_psi\""], ["proof (prove)\nusing this:\n  r_psi =\n  Cn 2 r_ifeq\n   [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0, Cn 2 r [recf.Id 2 1]]\n\ngoal (1 subgoal):\n 1. recfn 2 r_psi", "using r(1)"], ["proof (prove)\nusing this:\n  r_psi =\n  Cn 2 r_ifeq\n   [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0, Cn 2 r [recf.Id 2 1]]\n  recfn 1 r\n\ngoal (1 subgoal):\n 1. recfn 2 r_psi", "by simp"], ["proof (state)\nthis:\n  recfn 2 r_psi\n\ngoal (2 subgoals):\n 1. Partial_Recursive.total r_psi\n 2. \\<And>x y. eval r_psi [x, y] = psi f k x y", "have \"eval r_psi [i, x] = (if x = k then Some i else f x)\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "have \"eval (Cn 2 r [Id 2 1]) [i, x] = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x", "using r"], ["proof (prove)\nusing this:\n  recfn 1 r\n  Partial_Recursive.total r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x\n\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "then"], ["proof (chain)\npicking this:\n  eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x", "have \"eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]\""], ["proof (prove)\nusing this:\n  eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x\n\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]", "unfolding r_psi_def"], ["proof (prove)\nusing this:\n  eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifeq\n       [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0,\n        Cn 2 r [recf.Id 2 1]])\n     [i, x] =\n    eval r_ifeq [x, k, i, the (f x)]", "using \\<open>recfn 2 r_psi\\<close> r R1_imp_total1[OF assms]"], ["proof (prove)\nusing this:\n  eval (Cn 2 r [recf.Id 2 1]) [i, x] = f x\n  recfn 2 r_psi\n  recfn 1 r\n  Partial_Recursive.total r\n  eval r [?x] = f ?x\n  total1 f\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifeq\n       [recf.Id 2 1, r_dummy 1 (r_const k), recf.Id 2 0,\n        Cn 2 r [recf.Id 2 1]])\n     [i, x] =\n    eval r_ifeq [x, k, i, the (f x)]", "by simp"], ["proof (state)\nthis:\n  eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]\n\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "then"], ["proof (chain)\npicking this:\n  eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]\n\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "using assms"], ["proof (prove)\nusing this:\n  eval r_psi [i, x] = eval r_ifeq [x, k, i, the (f x)]\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. eval r_psi [i, x] = (if x = k then Some i else f x)", "by simp"], ["proof (state)\nthis:\n  eval r_psi [i, x] = (if x = k then Some i else f x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_psi [?i, ?x] = (if ?x = k then Some ?i else f ?x)\n\ngoal (2 subgoals):\n 1. Partial_Recursive.total r_psi\n 2. \\<And>x y. eval r_psi [x, y] = psi f k x y", "then"], ["proof (chain)\npicking this:\n  eval r_psi [?i, ?x] = (if ?x = k then Some ?i else f ?x)", "show \"\\<And>x y. eval r_psi [x, y] = psi f k x y\""], ["proof (prove)\nusing this:\n  eval r_psi [?i, ?x] = (if ?x = k then Some ?i else f ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. eval r_psi [x, y] = psi f k x y", "unfolding psi_def"], ["proof (prove)\nusing this:\n  eval r_psi [?i, ?x] = (if ?x = k then Some ?i else f ?x)\n\ngoal (1 subgoal):\n 1. \\<And>x y. eval r_psi [x, y] = (if y = k then Some x else f y)", "by simp"], ["proof (state)\nthis:\n  eval r_psi [?x, ?y] = psi f k ?x ?y\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_psi", "then"], ["proof (chain)\npicking this:\n  eval r_psi [?x, ?y] = psi f k ?x ?y", "show \"total r_psi\""], ["proof (prove)\nusing this:\n  eval r_psi [?x, ?y] = psi f k ?x ?y\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_psi", "using totalI2[of r_psi] \\<open>recfn 2 r_psi\\<close> assms psi_def"], ["proof (prove)\nusing this:\n  eval r_psi [?x, ?y] = psi f k ?x ?y\n  \\<lbrakk>recfn 2 r_psi; \\<And>x y. eval r_psi [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total r_psi\n  recfn 2 r_psi\n  f \\<in> \\<R>\n  psi = (\\<lambda>f k i x. if x = k then Some i else f x)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_psi", "by fastforce"], ["proof (state)\nthis:\n  Partial_Recursive.total r_psi\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  psi f k \\<in> \\<R>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  psi f k \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "then"], ["proof (chain)\npicking this:\n  psi f k \\<in> \\<R>\\<^sup>2", "obtain n where \"n \\<ge> m\" \"\\<phi> n = psi f k n\""], ["proof (prove)\nusing this:\n  psi f k \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>m \\<le> n; \\<phi> n = psi f k n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms kleene_fixed_point[of \"psi f k\" m]"], ["proof (prove)\nusing this:\n  psi f k \\<in> \\<R>\\<^sup>2\n  f \\<in> \\<R>\n  \\<lbrakk>psi f k \\<in> \\<P>\\<^sup>2;\n   \\<And>i.\n      \\<lbrakk>m \\<le> i; \\<phi> i = psi f k i\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>m \\<le> n; \\<phi> n = psi f k n\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  m \\<le> n\n  \\<phi> n = psi f k n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "then"], ["proof (chain)\npicking this:\n  m \\<le> n\n  \\<phi> n = psi f k n", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<le> n\n  \\<phi> n = psi f k n\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "unfolding psi_def"], ["proof (prove)\nusing this:\n  m \\<le> n\n  \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>m. \\<phi> n = (\\<lambda>x. if x = k then Some n else f x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma U_LIMCONS_prefix_complete:\n  assumes \"length vs > 0\"\n  shows \"\\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "let ?p = \"\\<lambda>_. Some 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "let ?f = \"vs @ [0] \\<odot> ?p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "have \"?f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R>", "using prepend_in_R1 RPred1_subseteq_R1 const0_in_RPred1"], ["proof (prove)\nusing this:\n  ?f \\<in> \\<R> \\<Longrightarrow> ?vs \\<odot> ?f \\<in> \\<R>\n  \\<R>\\<^sub>0\\<^sub>1 \\<subseteq> \\<R>\n  0\\<^sup>\\<infinity> \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R>", "by blast"], ["proof (state)\nthis:\n  vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "with goedel_at[of ?f 2 \"length vs\"]"], ["proof (chain)\npicking this:\n  vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R> \\<Longrightarrow>\n  \\<exists>n\\<ge>2.\n     \\<phi> n =\n     (\\<lambda>x.\n         if x = length vs then Some n\n         else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R>", "obtain j where\n    j: \"j \\<ge> 2\" \"\\<phi> j = (\\<lambda>x. if x = length vs then Some j else ?f x)\" (is \"_ = ?g\")"], ["proof (prove)\nusing this:\n  vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R> \\<Longrightarrow>\n  \\<exists>n\\<ge>2.\n     \\<phi> n =\n     (\\<lambda>x.\n         if x = length vs then Some n\n         else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  vs @ [0] \\<odot> 0\\<^sup>\\<infinity> \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>2 \\<le> j;\n         \\<phi> j =\n         (\\<lambda>x.\n             if x = length vs then Some j\n             else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "moreover"], ["proof (state)\nthis:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "have g: \"?g x = (vs @ [j] \\<odot> ?p) x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if x = length vs then Some j\n     else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x) =\n    (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) x", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "ultimately"], ["proof (chain)\npicking this:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1", "have \"?g \\<in> U\\<^bsub>LIM-CONS\\<^esub>\""], ["proof (prove)\nusing this:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x = length vs then Some j\n        else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n    \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "unfolding U_LIMCONS_def"], ["proof (prove)\nusing this:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x = length vs then Some j\n        else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n    \\<in> {vs @ [j] \\<odot> p |vs j p.\n           2 \\<le> j \\<and>\n           p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and>\n           \\<phi> j = vs @ [j] \\<odot> p}", "using const0_in_RPred1"], ["proof (prove)\nusing this:\n  2 \\<le> j\n  \\<phi> j =\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1\n  0\\<^sup>\\<infinity> \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if x = length vs then Some j\n        else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n    \\<in> {vs @ [j] \\<odot> p |vs j p.\n           2 \\<le> j \\<and>\n           p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and>\n           \\<phi> j = vs @ [j] \\<odot> p}", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "have \"prefix ?g (length vs - 1) = vs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\n     (\\<lambda>x.\n         if x = length vs then Some j\n         else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n     (length vs - 1) =\n    vs", "using g assms prefixI prepend_associative"], ["proof (prove)\nusing this:\n  (if ?x1 = length vs then Some j\n   else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) ?x1) =\n  (vs @ [j] \\<odot> 0\\<^sup>\\<infinity>) ?x1\n  0 < length vs\n  \\<lbrakk>0 < length ?vs;\n   \\<And>x. x < length ?vs \\<Longrightarrow> ?f x \\<down>= ?vs ! x\\<rbrakk>\n  \\<Longrightarrow> prefix ?f (length ?vs - 1) = ?vs\n  ?us @ ?vs \\<odot> ?f = ?us \\<odot> ?vs \\<odot> ?f\n\ngoal (1 subgoal):\n 1. prefix\n     (\\<lambda>x.\n         if x = length vs then Some j\n         else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n     (length vs - 1) =\n    vs", "by auto"], ["proof (state)\nthis:\n  prefix\n   (\\<lambda>x.\n       if x = length vs then Some j\n       else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n   (length vs - 1) =\n  vs\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix\n   (\\<lambda>x.\n       if x = length vs then Some j\n       else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n   (length vs - 1) =\n  vs", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      if x = length vs then Some j\n      else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n  \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix\n   (\\<lambda>x.\n       if x = length vs then Some j\n       else (vs @ [0] \\<odot> 0\\<^sup>\\<infinity>) x)\n   (length vs - 1) =\n  vs\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs", "by auto"], ["proof (state)\nthis:\n  \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length vs - 1) = vs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Roughly speaking, a strategy learning a prefix-complete class\nmust be total because it must be defined for every prefix in\nthe class. Technically, however, the empty list is not a prefix, and thus a\nstrategy may diverge on input 0. We can work around this by\nshowing that if there is a strategy learning a prefix-complete class then\nthere is also a total strategy learning this class. We need the result only\nfor consistent learning.\\<close>"], ["", "lemma U_prefix_complete_imp_total_strategy:\n  assumes \"\\<And>vs. length vs > 0 \\<Longrightarrow> \\<exists>f\\<in>U. prefix f (length vs - 1) = vs\"\n    and \"learn_cons \\<psi> U s\"\n  shows \"\\<exists>t. total1 t \\<and> learn_cons \\<psi> U t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "define t where \"t = (\\<lambda>e. if e = 0 then Some 0 else s e)\""], ["proof (state)\nthis:\n  t = (\\<lambda>e. if e = 0 then Some 0 else s e)\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "have \"s e \\<down>\" if \"e > 0\" for e"], ["proof (prove)\ngoal (1 subgoal):\n 1. s e \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s e \\<down>", "from that"], ["proof (chain)\npicking this:\n  0 < e", "have \"list_decode e \\<noteq> []\" (is \"?vs \\<noteq> _\")"], ["proof (prove)\nusing this:\n  0 < e\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode e \\<noteq> []", "using list_encode_0 list_encode_decode"], ["proof (prove)\nusing this:\n  0 < e\n  Partial_Recursive.list_encode ?xs = 0 \\<Longrightarrow> ?xs = []\n  Partial_Recursive.list_encode (Partial_Recursive.list_decode ?n) = ?n\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode e \\<noteq> []", "by (metis less_imp_neq)"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode e \\<noteq> []\n\ngoal (1 subgoal):\n 1. s e \\<down>", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode e \\<noteq> []", "have \"length ?vs > 0\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode e \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < e_length e", "by simp"], ["proof (state)\nthis:\n  0 < e_length e\n\ngoal (1 subgoal):\n 1. s e \\<down>", "with assms(1)"], ["proof (chain)\npicking this:\n  0 < length ?vs \\<Longrightarrow>\n  \\<exists>f\\<in>U. prefix f (length ?vs - 1) = ?vs\n  0 < e_length e", "obtain f where f: \"f \\<in> U\" \"prefix f (length ?vs - 1) = ?vs\""], ["proof (prove)\nusing this:\n  0 < length ?vs \\<Longrightarrow>\n  \\<exists>f\\<in>U. prefix f (length ?vs - 1) = ?vs\n  0 < e_length e\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> U;\n         prefix f (e_length e - 1) =\n         Partial_Recursive.list_decode e\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> U\n  prefix f (e_length e - 1) = Partial_Recursive.list_decode e\n\ngoal (1 subgoal):\n 1. s e \\<down>", "with learn_cons_def learn_limE"], ["proof (chain)\npicking this:\n  learn_cons ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n k.\n         k \\<le> n \\<longrightarrow>\n         ?\\<psi> (the (?s (f \\<triangleright> n))) k = f k)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n  f \\<in> U\n  prefix f (e_length e - 1) = Partial_Recursive.list_decode e", "have \"s (f \\<triangleright> (length ?vs - 1)) \\<down>\""], ["proof (prove)\nusing this:\n  learn_cons ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n k.\n         k \\<le> n \\<longrightarrow>\n         ?\\<psi> (the (?s (f \\<triangleright> n))) k = f k)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n  f \\<in> U\n  prefix f (e_length e - 1) = Partial_Recursive.list_decode e\n\ngoal (1 subgoal):\n 1. s (f \\<triangleright> (e_length e - 1)) \\<down>", "using assms(2)"], ["proof (prove)\nusing this:\n  learn_cons ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n k.\n         k \\<le> n \\<longrightarrow>\n         ?\\<psi> (the (?s (f \\<triangleright> n))) k = f k)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n  f \\<in> U\n  prefix f (e_length e - 1) = Partial_Recursive.list_decode e\n  learn_cons \\<psi> U s\n\ngoal (1 subgoal):\n 1. s (f \\<triangleright> (e_length e - 1)) \\<down>", "by auto"], ["proof (state)\nthis:\n  s (f \\<triangleright> (e_length e - 1)) \\<down>\n\ngoal (1 subgoal):\n 1. s e \\<down>", "then"], ["proof (chain)\npicking this:\n  s (f \\<triangleright> (e_length e - 1)) \\<down>", "show \"s e \\<down>\""], ["proof (prove)\nusing this:\n  s (f \\<triangleright> (e_length e - 1)) \\<down>\n\ngoal (1 subgoal):\n 1. s e \\<down>", "using f(2) init_def"], ["proof (prove)\nusing this:\n  s (f \\<triangleright> (e_length e - 1)) \\<down>\n  prefix f (e_length e - 1) = Partial_Recursive.list_decode e\n  ?f \\<triangleright> ?n \\<equiv>\n  Partial_Recursive.list_encode (prefix ?f ?n)\n\ngoal (1 subgoal):\n 1. s e \\<down>", "by auto"], ["proof (state)\nthis:\n  s e \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < ?e \\<Longrightarrow> s ?e \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "then"], ["proof (chain)\npicking this:\n  0 < ?e \\<Longrightarrow> s ?e \\<down>", "have \"total1 t\""], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> s ?e \\<down>\n\ngoal (1 subgoal):\n 1. total1 t", "using t_def"], ["proof (prove)\nusing this:\n  0 < ?e \\<Longrightarrow> s ?e \\<down>\n  t = (\\<lambda>e. if e = 0 then Some 0 else s e)\n\ngoal (1 subgoal):\n 1. total1 t", "by auto"], ["proof (state)\nthis:\n  total1 t\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "have \"t \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "from assms(2)"], ["proof (chain)\npicking this:\n  learn_cons \\<psi> U s", "have \"s \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  learn_cons \\<psi> U s\n\ngoal (1 subgoal):\n 1. s \\<in> \\<P>", "using learn_consE"], ["proof (prove)\nusing this:\n  learn_cons \\<psi> U s\n  learn_cons ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_cons ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i n\\<^sub>0.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<forall>n\\<ge>n\\<^sub>0.\n                           ?s (?f \\<triangleright> n) \\<down>= i)\n  \\<lbrakk>learn_cons ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k\\<le>?n.\n                       ?\\<psi> (the (?s (?f \\<triangleright> ?n))) k = ?f k\n\ngoal (1 subgoal):\n 1. s \\<in> \\<P>", "by simp"], ["proof (state)\nthis:\n  s \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  s \\<in> \\<P>", "obtain rs where rs: \"recfn 1 rs\" \"eval rs [x] = s x\" for x"], ["proof (prove)\nusing this:\n  s \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>recfn 1 rs; \\<And>x. eval rs [x] = s x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 rs\n  eval rs [?x] = s ?x\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "define rt where \"rt = Cn 1 (r_lifz Z rs) [Id 1 0, Id 1 0]\""], ["proof (state)\nthis:\n  rt = Cn 1 (r_lifz Z rs) [recf.Id 1 0, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  rt = Cn 1 (r_lifz Z rs) [recf.Id 1 0, recf.Id 1 0]", "have \"recfn 1 rt\""], ["proof (prove)\nusing this:\n  rt = Cn 1 (r_lifz Z rs) [recf.Id 1 0, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 rt", "using rs"], ["proof (prove)\nusing this:\n  rt = Cn 1 (r_lifz Z rs) [recf.Id 1 0, recf.Id 1 0]\n  recfn 1 rs\n  eval rs [?x] = s ?x\n\ngoal (1 subgoal):\n 1. recfn 1 rt", "by auto"], ["proof (state)\nthis:\n  recfn 1 rt\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "moreover"], ["proof (state)\nthis:\n  recfn 1 rt\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "have \"eval rt [x] = t x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval rt [x] = t x", "using rs rt_def t_def"], ["proof (prove)\nusing this:\n  recfn 1 rs\n  eval rs [?x] = s ?x\n  rt = Cn 1 (r_lifz Z rs) [recf.Id 1 0, recf.Id 1 0]\n  t = (\\<lambda>e. if e = 0 then Some 0 else s e)\n\ngoal (1 subgoal):\n 1. eval rt [x] = t x", "by simp"], ["proof (state)\nthis:\n  eval rt [?x] = t ?x\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 rt\n  eval rt [?x] = t ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 rt\n  eval rt [?x] = t ?x\n\ngoal (1 subgoal):\n 1. t \\<in> \\<P>", "by blast"], ["proof (state)\nthis:\n  t \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "have \"s (f \\<triangleright> n) = t (f \\<triangleright> n)\" if \"f \\<in> U\" for f n"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (f \\<triangleright> n) = t (f \\<triangleright> n)", "unfolding t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (f \\<triangleright> n) =\n    (if f \\<triangleright> n = 0 then Some 0 else s (f \\<triangleright> n))", "by (simp add: init_neq_zero)"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  s (?f \\<triangleright> ?n) = t (?f \\<triangleright> ?n)\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "then"], ["proof (chain)\npicking this:\n  ?f \\<in> U \\<Longrightarrow>\n  s (?f \\<triangleright> ?n) = t (?f \\<triangleright> ?n)", "have \"learn_cons \\<psi> U t\""], ["proof (prove)\nusing this:\n  ?f \\<in> U \\<Longrightarrow>\n  s (?f \\<triangleright> ?n) = t (?f \\<triangleright> ?n)\n\ngoal (1 subgoal):\n 1. learn_cons \\<psi> U t", "using \\<open>t \\<in> \\<P>\\<close> assms(2) learn_consE[of \\<psi> U s] learn_consI[of \\<psi> U t]"], ["proof (prove)\nusing this:\n  ?f \\<in> U \\<Longrightarrow>\n  s (?f \\<triangleright> ?n) = t (?f \\<triangleright> ?n)\n  t \\<in> \\<P>\n  learn_cons \\<psi> U s\n  learn_cons \\<psi> U s \\<Longrightarrow> environment \\<psi> U s\n  \\<lbrakk>learn_cons \\<psi> U s; ?f \\<in> U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i n\\<^sub>0.\n                       \\<psi> i = ?f \\<and>\n                       (\\<forall>n\\<ge>n\\<^sub>0.\n                           s (?f \\<triangleright> n) \\<down>= i)\n  \\<lbrakk>learn_cons \\<psi> U s; ?f \\<in> U\\<rbrakk>\n  \\<Longrightarrow> \\<forall>k\\<le>?n.\n                       \\<psi> (the (s (?f \\<triangleright> ?n))) k = ?f k\n  \\<lbrakk>environment \\<psi> U t;\n   \\<And>f.\n      f \\<in> U \\<Longrightarrow>\n      \\<exists>i.\n         \\<psi> i = f \\<and>\n         (\\<exists>n\\<^sub>0.\n             \\<forall>n\\<ge>n\\<^sub>0. t (f \\<triangleright> n) \\<down>= i);\n   \\<And>f n.\n      f \\<in> U \\<Longrightarrow>\n      \\<forall>k\\<le>n.\n         \\<psi> (the (t (f \\<triangleright> n))) k = f k\\<rbrakk>\n  \\<Longrightarrow> learn_cons \\<psi> U t\n\ngoal (1 subgoal):\n 1. learn_cons \\<psi> U t", "by simp"], ["proof (state)\nthis:\n  learn_cons \\<psi> U t\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "with \\<open>total1 t\\<close>"], ["proof (chain)\npicking this:\n  total1 t\n  learn_cons \\<psi> U t", "show ?thesis"], ["proof (prove)\nusing this:\n  total1 t\n  learn_cons \\<psi> U t\n\ngoal (1 subgoal):\n 1. \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t", "by auto"], ["proof (state)\nthis:\n  \\<exists>t. total1 t \\<and> learn_cons \\<psi> U t\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The proof of @{prop \"U\\<^bsub>LIM-CONS\\<^esub> \\<notin> CONS\"} is by contradiction.\nAssume there is a consistent learning strategy $S$. By the previous\nlemma $S$ can be assumed to be total. Moreover it outputs a consistent\nhypothesis for every prefix. Thus for every $e \\in \\mathbb{N}^+$, $S(e) \\neq\nS(e0)$ or $S(e) \\neq S(e1)$ because $S(e)$ cannot be consistent with both\n$e0$ and $e1$. We use this property of $S$ to construct a function in @{term\n\"U\\<^bsub>LIM-CONS\\<^esub>\"} for which $S$ fails as a learning strategy. To\nthis end we define a numbering $\\psi \\in \\mathcal{R}^2$ with $\\psi_i(0) = i$\nand\n\\[\n\\psi_i(x + 1) = \\left\\{\\begin{array}{ll}\n    0 & \\mbox{if } S(\\psi_i^x0) \\neq S(\\psi_i^x),\\\\\n    1 & \\mbox{otherwise}.\n\\end{array}\\right.\n\\]\nThis numbering is recursive because $S$ is total. The ``otherwise'' case is\nequivalent to $S(\\psi_i^x1) \\neq S(\\psi_i^x)$ because $S(\\psi_i^x)$ cannot be\nconsistent with both $\\psi_i^x0$ and $\\psi_i^x1$. Therefore every prefix\n$\\psi_i^x$ is extended in such a way that $S$ changes its hypothesis. Hence\n$S$ does not learn $\\psi_i$ in the limit. Kleene's fixed-point theorem\nensures that for some $j \\geq 2$, $\\varphi_j = \\psi_j$. This $\\psi_j$ is the\nsought function in @{term \"U\\<^bsub>LIM-CONS\\<^esub>\"}.\n\nThe following locale formalizes the construction of $\\psi$ for a total\nstrategy $S$.\\<close>"], ["", "locale cons_lim =\n  fixes s :: partial1\n  assumes s_in_R1: \"s \\<in> \\<R>\"\nbegin"], ["", "text \\<open>A @{typ recf} computing the strategy:\\<close>"], ["", "definition r_s :: recf where\n  \"r_s \\<equiv> SOME r_s. recfn 1 r_s \\<and>  total r_s \\<and> s = (\\<lambda>x. eval r_s [x])\""], ["", "lemma r_s_recfn [simp]: \"recfn 1 r_s\"\n  and r_s_total [simp]: \"\\<And>x. eval r_s [x] \\<down>\"\n  and eval_r_s: \"s = (\\<lambda>x. eval r_s [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r_s &&&\n    (\\<And>x. eval r_s [x] \\<down>) &&& s = (\\<lambda>x. eval r_s [x])", "using r_s_def R1_SOME[OF s_in_R1, of r_s]"], ["proof (prove)\nusing this:\n  r_s \\<equiv>\n  SOME r_s.\n     recfn 1 r_s \\<and>\n     Partial_Recursive.total r_s \\<and> s = (\\<lambda>x. eval r_s [x])\n  r_s =\n  (SOME r'.\n      recfn 1 r' \\<and>\n      Partial_Recursive.total r' \\<and>\n      s = (\\<lambda>x. eval r' [x])) \\<Longrightarrow>\n  recfn 1 r_s\n  r_s =\n  (SOME r'.\n      recfn 1 r' \\<and>\n      Partial_Recursive.total r' \\<and>\n      s = (\\<lambda>x. eval r' [x])) \\<Longrightarrow>\n  eval r_s [?x] \\<down>\n  r_s =\n  (SOME r'.\n      recfn 1 r' \\<and>\n      Partial_Recursive.total r' \\<and>\n      s = (\\<lambda>x. eval r' [x])) \\<Longrightarrow>\n  s ?x = eval r_s [?x]\n  r_s =\n  (SOME r'.\n      recfn 1 r' \\<and>\n      Partial_Recursive.total r' \\<and>\n      s = (\\<lambda>x. eval r' [x])) \\<Longrightarrow>\n  s = (\\<lambda>x. eval r_s [x])\n\ngoal (1 subgoal):\n 1. recfn 1 r_s &&&\n    (\\<And>x. eval r_s [x] \\<down>) &&& s = (\\<lambda>x. eval r_s [x])", "by simp_all"], ["", "text \\<open>The next function represents the prefixes of $\\psi_i$.\\<close>"], ["", "fun prefixes :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n  \"prefixes i 0 = [i]\"\n| \"prefixes i (Suc x) = (prefixes i x) @\n    [if s (e_snoc (list_encode (prefixes i x)) 0) = s (list_encode (prefixes i x))\n     then 1 else 0]\""], ["", "definition \"r_prefixes_aux \\<equiv>\n  Cn 3 r_ifeq\n   [Cn 3 r_s [Cn 3 r_snoc [Id 3 1, r_constn 2 0]],\n    Cn 3 r_s [Id 3 1],\n    Cn 3 r_snoc [Id 3 1, r_constn 2 1],\n    Cn 3 r_snoc [Id 3 1, r_constn 2 0]]\""], ["", "lemma r_prefixes_aux_recfn: \"recfn 3 r_prefixes_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_prefixes_aux", "unfolding r_prefixes_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_ifeq\n       [Cn 3 r_s [Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]],\n        Cn 3 r_s [recf.Id 3 1], Cn 3 r_snoc [recf.Id 3 1, r_constn 2 1],\n        Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]])", "by simp"], ["", "lemma r_prefixes_aux:\n  \"eval r_prefixes_aux [j, v, i] \\<down>=\n    e_snoc v (if eval r_s [e_snoc v 0] = eval r_s [v] then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_prefixes_aux [j, v, i] \\<down>=\n    e_snoc v (if eval r_s [e_snoc v 0] = eval r_s [v] then 1 else 0)", "unfolding r_prefixes_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifeq\n       [Cn 3 r_s [Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]],\n        Cn 3 r_s [recf.Id 3 1], Cn 3 r_snoc [recf.Id 3 1, r_constn 2 1],\n        Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]])\n     [j, v, i] \\<down>=\n    e_snoc v (if eval r_s [e_snoc v 0] = eval r_s [v] then 1 else 0)", "by auto"], ["", "definition \"r_prefixes \\<equiv> r_swap (Pr 1 r_singleton_encode r_prefixes_aux)\""], ["", "lemma r_prefixes_recfn: \"recfn 2 r_prefixes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_prefixes", "unfolding r_prefixes_def r_prefixes_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (r_swap\n       (Pr 1 r_singleton_encode\n         (Cn 3 r_ifeq\n           [Cn 3 r_s [Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]],\n            Cn 3 r_s [recf.Id 3 1], Cn 3 r_snoc [recf.Id 3 1, r_constn 2 1],\n            Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]])))", "by simp"], ["", "lemma r_prefixes: \"eval r_prefixes [i, n] \\<down>= list_encode (prefixes i n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "let ?h = \"Pr 1 r_singleton_encode r_prefixes_aux\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "have \"eval ?h [n, i] \\<down>= list_encode (prefixes i n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [0, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i 0)\n 2. \\<And>n.\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i n) \\<Longrightarrow>\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i (Suc n))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [0, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i 0)\n 2. \\<And>n.\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i n) \\<Longrightarrow>\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i (Suc n))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [0, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i 0)", "using r_prefixes_def r_prefixes_aux_recfn r_singleton_encode"], ["proof (prove)\nusing this:\n  r_prefixes \\<equiv> r_swap (Pr 1 r_singleton_encode r_prefixes_aux)\n  recfn 3 r_prefixes_aux\n  eval r_singleton_encode [?x] \\<down>= singleton_encode ?x\n\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [0, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i 0)", "by simp"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [0, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i n) \\<Longrightarrow>\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i n) \\<Longrightarrow>\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i (Suc n))", "case (Suc n)"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i n) \\<Longrightarrow>\n       eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n       Partial_Recursive.list_encode (prefixes i (Suc n))", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)", "show ?case"], ["proof (prove)\nusing this:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i (Suc n))", "using r_prefixes_aux_recfn r_prefixes_aux eval_r_s"], ["proof (prove)\nusing this:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n  recfn 3 r_prefixes_aux\n  eval r_prefixes_aux [?j, ?v, ?i] \\<down>=\n  e_snoc ?v (if eval r_s [e_snoc ?v 0] = eval r_s [?v] then 1 else 0)\n  s = (\\<lambda>x. eval r_s [x])\n\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n    Partial_Recursive.list_encode (prefixes i (Suc n))", "by auto metis+"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [Suc n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "moreover"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "have \"eval ?h [n, i] = eval r_prefixes [i, n]\" for i n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] =\n    eval r_prefixes [i, n]", "unfolding r_prefixes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] =\n    eval (r_swap (Pr 1 r_singleton_encode r_prefixes_aux)) [i, n]", "by (simp add: r_prefixes_aux_recfn)"], ["proof (state)\nthis:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [?n, ?i] =\n  eval r_prefixes [?i, ?n]\n\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "ultimately"], ["proof (chain)\npicking this:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [?n, ?i] =\n  eval r_prefixes [?i, ?n]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [n, i] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n  eval (Pr 1 r_singleton_encode r_prefixes_aux) [?n, ?i] =\n  eval r_prefixes [?i, ?n]\n\ngoal (1 subgoal):\n 1. eval r_prefixes [i, n] \\<down>=\n    Partial_Recursive.list_encode (prefixes i n)", "by simp"], ["proof (state)\nthis:\n  eval r_prefixes [i, n] \\<down>=\n  Partial_Recursive.list_encode (prefixes i n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prefixes_neq_nil: \"length (prefixes i x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (prefixes i x)", "by (induction x) auto"], ["", "text \\<open>The actual numbering can then be defined via @{term prefixes}.\\<close>"], ["", "definition psi :: \"partial2\" (\"\\<psi>\") where\n  \"\\<psi> i x \\<equiv> Some (last (prefixes i x))\""], ["", "lemma psi_in_R2: \"\\<psi> \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> \\<R>\\<^sup>2", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2\n 2. total2 \\<psi>", "define r_psi where \"r_psi \\<equiv> Cn 2 r_last [r_prefixes]\""], ["proof (state)\nthis:\n  r_psi \\<equiv> Cn 2 r_last [r_prefixes]\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2\n 2. total2 \\<psi>", "have \"recfn 2 r_psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_psi", "unfolding r_psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_last [r_prefixes])", "by (simp add: r_prefixes_recfn)"], ["proof (state)\nthis:\n  recfn 2 r_psi\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2\n 2. total2 \\<psi>", "then"], ["proof (chain)\npicking this:\n  recfn 2 r_psi", "have \"eval r_psi [i, n] \\<down>= last (prefixes i n)\" for n i"], ["proof (prove)\nusing this:\n  recfn 2 r_psi\n\ngoal (1 subgoal):\n 1. eval r_psi [i, n] \\<down>= last (prefixes i n)", "unfolding r_psi_def"], ["proof (prove)\nusing this:\n  recfn 2 (Cn 2 r_last [r_prefixes])\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_last [r_prefixes]) [i, n] \\<down>= last (prefixes i n)", "using r_prefixes r_prefixes_recfn prefixes_neq_nil"], ["proof (prove)\nusing this:\n  recfn 2 (Cn 2 r_last [r_prefixes])\n  eval r_prefixes [?i, ?n] \\<down>=\n  Partial_Recursive.list_encode (prefixes ?i ?n)\n  recfn 2 r_prefixes\n  0 < length (prefixes ?i ?x)\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_last [r_prefixes]) [i, n] \\<down>= last (prefixes i n)", "by simp"], ["proof (state)\nthis:\n  eval r_psi [?i, ?n] \\<down>= last (prefixes ?i ?n)\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2\n 2. total2 \\<psi>", "then"], ["proof (chain)\npicking this:\n  eval r_psi [?i, ?n] \\<down>= last (prefixes ?i ?n)", "have \"(\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\nusing this:\n  eval r_psi [?i, ?n] \\<down>= last (prefixes ?i ?n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2", "using \\<open>recfn 2 r_psi\\<close> P2I[of \"r_psi\"]"], ["proof (prove)\nusing this:\n  eval r_psi [?i, ?n] \\<down>= last (prefixes ?i ?n)\n  recfn 2 r_psi\n  \\<lbrakk>recfn 2 r_psi; \\<And>x y. eval r_psi [x, y] = ?f x y\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2\n\ngoal (2 subgoals):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2\n 2. total2 \\<psi>", "with psi_def"], ["proof (chain)\npicking this:\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  (\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2", "show \"\\<psi> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  (\\<lambda>i x. Some (last (prefixes i x))) \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2", "by presburger"], ["proof (state)\nthis:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. total2 \\<psi>", "moreover"], ["proof (state)\nthis:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. total2 \\<psi>", "show \"total2 psi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total2 \\<psi>", "unfolding psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. total2 (\\<lambda>i x. Some (last (prefixes i x)))", "by auto"], ["proof (state)\nthis:\n  total2 \\<psi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psi_0_or_1:\n  assumes \"n > 0\"\n  shows \"\\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "from assms"], ["proof (chain)\npicking this:\n  0 < n", "obtain m where \"n = Suc m\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using gr0_implies_Suc"], ["proof (prove)\nusing this:\n  0 < n\n  0 < ?n \\<Longrightarrow> \\<exists>m. ?n = Suc m\n\ngoal (1 subgoal):\n 1. (\\<And>m. n = Suc m \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "then"], ["proof (chain)\npicking this:\n  n = Suc m", "have \"last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1\""], ["proof (prove)\nusing this:\n  n = Suc m\n\ngoal (1 subgoal):\n 1. last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1", "by simp"], ["proof (state)\nthis:\n  last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1\n\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "then"], ["proof (chain)\npicking this:\n  last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1\n\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "using \\<open>n = Suc m\\<close> psi_def"], ["proof (prove)\nusing this:\n  last (prefixes i (Suc m)) = 0 \\<or> last (prefixes i (Suc m)) = 1\n  n = Suc m\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n\ngoal (1 subgoal):\n 1. \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  \\<psi> i n \\<down>= 0 \\<or> \\<psi> i n \\<down>= 1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The function @{term \"prefixes\"} does indeed provide the prefixes\nfor @{term \"\\<psi>\"}.\\<close>"], ["", "lemma psi_init: \"(\\<psi> i) \\<triangleright> x = list_encode (prefixes i x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> i \\<triangleright> x =\n    Partial_Recursive.list_encode (prefixes i x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> i \\<triangleright> x =\n    Partial_Recursive.list_encode (prefixes i x)", "have \"prefix (\\<psi> i) x = prefixes i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (\\<psi> i) x = prefixes i x", "unfolding psi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (\\<lambda>x. Some (last (prefixes i x))) x = prefixes i x", "by (induction x) (simp_all add: prefix_0 prefix_Suc)"], ["proof (state)\nthis:\n  prefix (\\<psi> i) x = prefixes i x\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<triangleright> x =\n    Partial_Recursive.list_encode (prefixes i x)", "with init_def"], ["proof (chain)\npicking this:\n  ?f \\<triangleright> ?n \\<equiv>\n  Partial_Recursive.list_encode (prefix ?f ?n)\n  prefix (\\<psi> i) x = prefixes i x", "show ?thesis"], ["proof (prove)\nusing this:\n  ?f \\<triangleright> ?n \\<equiv>\n  Partial_Recursive.list_encode (prefix ?f ?n)\n  prefix (\\<psi> i) x = prefixes i x\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<triangleright> x =\n    Partial_Recursive.list_encode (prefixes i x)", "by simp"], ["proof (state)\nthis:\n  \\<psi> i \\<triangleright> x = Partial_Recursive.list_encode (prefixes i x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>One of the functions $\\psi_i$ is in @{term \"U\\<^bsub>LIM-CONS\\<^esub>\"}.\\<close>"], ["", "lemma ex_psi_in_U: \"\\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "obtain j where j: \"j \\<ge> 2\" \"\\<psi> j = \\<phi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>2 \\<le> j; \\<psi> j = \\<phi> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using kleene_fixed_point[of \\<psi>] psi_in_R2 R2_imp_P2"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<psi> \\<in> \\<P>\\<^sup>2;\n   \\<And>i.\n      \\<lbrakk>?k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<psi> \\<in> \\<R>\\<^sup>2\n  ?f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> ?f \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>2 \\<le> j; \\<psi> j = \\<phi> j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  2 \\<le> j\n  \\<psi> j = \\<phi> j\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "then"], ["proof (chain)\npicking this:\n  2 \\<le> j\n  \\<psi> j = \\<phi> j", "have \"\\<psi> j \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  2 \\<le> j\n  \\<psi> j = \\<phi> j\n\ngoal (1 subgoal):\n 1. \\<psi> j \\<in> \\<P>", "by (simp add: phi_in_P2)"], ["proof (state)\nthis:\n  \\<psi> j \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "define p where \"p = (\\<lambda>x. \\<psi> j (x + 1))\""], ["proof (state)\nthis:\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "have \"p \\<in> \\<R>\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "from p_def \\<open>\\<psi> j \\<in> \\<P>\\<close> skip_P1"], ["proof (chain)\npicking this:\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n  \\<psi> j \\<in> \\<P>\n  ?f \\<in> \\<P> \\<Longrightarrow> (\\<lambda>x. ?f (x + ?n)) \\<in> \\<P>", "have \"p \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n  \\<psi> j \\<in> \\<P>\n  ?f \\<in> \\<P> \\<Longrightarrow> (\\<lambda>x. ?f (x + ?n)) \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. p \\<in> \\<P>", "by blast"], ["proof (state)\nthis:\n  p \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "from psi_in_R2"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> \\<R>\\<^sup>2", "have \"total1 (\\<psi> j)\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. total1 (\\<psi> j)", "by simp"], ["proof (state)\nthis:\n  total1 (\\<psi> j)\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "with p_def"], ["proof (chain)\npicking this:\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n  total1 (\\<psi> j)", "have \"total1 p\""], ["proof (prove)\nusing this:\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n  total1 (\\<psi> j)\n\ngoal (1 subgoal):\n 1. total1 p", "by (simp add: total1_def)"], ["proof (state)\nthis:\n  total1 p\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "with psi_0_or_1"], ["proof (chain)\npicking this:\n  0 < ?n \\<Longrightarrow>\n  \\<psi> ?i ?n \\<down>= 0 \\<or> \\<psi> ?i ?n \\<down>= 1\n  total1 p", "have \"p n \\<down>= 0 \\<or> p n \\<down>= 1\" for n"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  \\<psi> ?i ?n \\<down>= 0 \\<or> \\<psi> ?i ?n \\<down>= 1\n  total1 p\n\ngoal (1 subgoal):\n 1. p n \\<down>= 0 \\<or> p n \\<down>= 1", "using psi_def p_def"], ["proof (prove)\nusing this:\n  0 < ?n \\<Longrightarrow>\n  \\<psi> ?i ?n \\<down>= 0 \\<or> \\<psi> ?i ?n \\<down>= 1\n  total1 p\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n\ngoal (1 subgoal):\n 1. p n \\<down>= 0 \\<or> p n \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  p ?n \\<down>= 0 \\<or> p ?n \\<down>= 1\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "then"], ["proof (chain)\npicking this:\n  p ?n \\<down>= 0 \\<or> p ?n \\<down>= 1", "show ?thesis"], ["proof (prove)\nusing this:\n  p ?n \\<down>= 0 \\<or> p ?n \\<down>= 1\n\ngoal (1 subgoal):\n 1. p \\<in> \\<R>\\<^sub>0\\<^sub>1", "by (simp add: RPred1_def P1_total_imp_R1 \\<open>p \\<in> \\<P>\\<close> \\<open>total1 p\\<close>)"], ["proof (state)\nthis:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "moreover"], ["proof (state)\nthis:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "have \"\\<psi> j = [j] \\<odot> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> j = [j] \\<odot> p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi> j x = ([j] \\<odot> p) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi> j x = ([j] \\<odot> p) x", "show \"\\<psi> j x = ([j] \\<odot> p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> j x = ([j] \\<odot> p) x", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x", "case True"], ["proof (state)\nthis:\n  x = 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x", "then"], ["proof (chain)\npicking this:\n  x = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0\n\ngoal (1 subgoal):\n 1. \\<psi> j x = ([j] \\<odot> p) x", "using psi_def psi_def prepend_at_less"], ["proof (prove)\nusing this:\n  x = 0\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  ?n < length ?vs \\<Longrightarrow> (?vs \\<odot> ?f) ?n \\<down>= ?vs ! ?n\n\ngoal (1 subgoal):\n 1. \\<psi> j x = ([j] \\<odot> p) x", "by simp"], ["proof (state)\nthis:\n  \\<psi> j x = ([j] \\<odot> p) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<psi> j x = ([j] \\<odot> p) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<psi> j x = ([j] \\<odot> p) x", "using p_def"], ["proof (prove)\nusing this:\n  x \\<noteq> 0\n  p = (\\<lambda>x. \\<psi> j (x + 1))\n\ngoal (1 subgoal):\n 1. \\<psi> j x = ([j] \\<odot> p) x", "by simp"], ["proof (state)\nthis:\n  \\<psi> j x = ([j] \\<odot> p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi> j x = ([j] \\<odot> p) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi> j = [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "ultimately"], ["proof (chain)\npicking this:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<psi> j = [j] \\<odot> p", "have \"\\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\""], ["proof (prove)\nusing this:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<psi> j = [j] \\<odot> p\n\ngoal (1 subgoal):\n 1. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "using j U_LIMCONS_def"], ["proof (prove)\nusing this:\n  p \\<in> \\<R>\\<^sub>0\\<^sub>1\n  \\<psi> j = [j] \\<odot> p\n  2 \\<le> j\n  \\<psi> j = \\<phi> j\n  U\\<^bsub>LIM-CONS\\<^esub> \\<equiv>\n  {vs @ [j] \\<odot> p |vs j p.\n   2 \\<le> j \\<and>\n   p \\<in> \\<R>\\<^sub>0\\<^sub>1 \\<and> \\<phi> j = vs @ [j] \\<odot> p}\n\ngoal (1 subgoal):\n 1. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "by (metis (mono_tags, lifting) append_Nil mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "then"], ["proof (chain)\npicking this:\n  \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>", "by auto"], ["proof (state)\nthis:\n  \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The strategy fails to learn @{term U_LIMCONS} because it changes\nits hypothesis all the time on functions $\\psi_j \\in V_0$.\\<close>"], ["", "lemma U_LIMCONS_not_learn_cons: \"\\<not> learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "assume learn: \"learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\""], ["proof (state)\nthis:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "have \"s (list_encode (vs @ [0])) \\<noteq> s (list_encode (vs @ [1]))\" for vs"], ["proof (prove)\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "obtain f\\<^sub>0 where f0: \"f\\<^sub>0 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\" \"prefix f\\<^sub>0 (length vs) = vs @ [0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>0.\n        \\<lbrakk>f\\<^sub>0 \\<in> U\\<^bsub>LIM-CONS\\<^esub>;\n         prefix f\\<^sub>0 (length vs) = vs @ [0]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U_LIMCONS_prefix_complete[of \"vs @ [0]\"]"], ["proof (prove)\nusing this:\n  0 < length (vs @ [0]) \\<Longrightarrow>\n  \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>.\n     prefix f (length (vs @ [0]) - 1) = vs @ [0]\n\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>0.\n        \\<lbrakk>f\\<^sub>0 \\<in> U\\<^bsub>LIM-CONS\\<^esub>;\n         prefix f\\<^sub>0 (length vs) = vs @ [0]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>0 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix f\\<^sub>0 (length vs) = vs @ [0]\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "obtain f\\<^sub>1 where f1: \"f\\<^sub>1 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\" \"prefix f\\<^sub>1 (length vs) = vs @ [1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>1.\n        \\<lbrakk>f\\<^sub>1 \\<in> U\\<^bsub>LIM-CONS\\<^esub>;\n         prefix f\\<^sub>1 (length vs) = vs @ [1]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U_LIMCONS_prefix_complete[of \"vs @ [1]\"]"], ["proof (prove)\nusing this:\n  0 < length (vs @ [1]) \\<Longrightarrow>\n  \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>.\n     prefix f (length (vs @ [1]) - 1) = vs @ [1]\n\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>1.\n        \\<lbrakk>f\\<^sub>1 \\<in> U\\<^bsub>LIM-CONS\\<^esub>;\n         prefix f\\<^sub>1 (length vs) = vs @ [1]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>1 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix f\\<^sub>1 (length vs) = vs @ [1]\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "have \"f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)", "using f0 f1"], ["proof (prove)\nusing this:\n  f\\<^sub>0 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix f\\<^sub>0 (length vs) = vs @ [0]\n  f\\<^sub>1 \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  prefix f\\<^sub>1 (length vs) = vs @ [1]\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)", "by (metis lessI nth_append_length prefix_nth zero_neq_one)"], ["proof (state)\nthis:\n  f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "moreover"], ["proof (state)\nthis:\n  f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "have \"\\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) = f\\<^sub>0 (length vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n    f\\<^sub>0 (length vs)", "using learn_consE(3)[of \\<phi> U_LIMCONS s, OF learn, of f\\<^sub>0 \"length vs\", OF f0(1)]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>length vs.\n     \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) k = f\\<^sub>0 k\n\ngoal (1 subgoal):\n 1. \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n    f\\<^sub>0 (length vs)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>0 (length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "moreover"], ["proof (state)\nthis:\n  \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>0 (length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "have \"\\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) = f\\<^sub>1 (length vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) =\n    f\\<^sub>1 (length vs)", "using learn_consE(3)[of \\<phi> U_LIMCONS s, OF learn, of f\\<^sub>1 \"length vs\", OF f1(1)]"], ["proof (prove)\nusing this:\n  \\<forall>k\\<le>length vs.\n     \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) k = f\\<^sub>1 k\n\ngoal (1 subgoal):\n 1. \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) =\n    f\\<^sub>1 (length vs)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>1 (length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "ultimately"], ["proof (chain)\npicking this:\n  f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)\n  \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>0 (length vs)\n  \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>1 (length vs)", "have \"the (s (f\\<^sub>0 \\<triangleright> length vs)) \\<noteq> the (s (f\\<^sub>1 \\<triangleright> length vs))\""], ["proof (prove)\nusing this:\n  f\\<^sub>0 (length vs) \\<noteq> f\\<^sub>1 (length vs)\n  \\<phi> (the (s (f\\<^sub>0 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>0 (length vs)\n  \\<phi> (the (s (f\\<^sub>1 \\<triangleright> length vs))) (length vs) =\n  f\\<^sub>1 (length vs)\n\ngoal (1 subgoal):\n 1. the (s (f\\<^sub>0 \\<triangleright> length vs)) \\<noteq>\n    the (s (f\\<^sub>1 \\<triangleright> length vs))", "by auto"], ["proof (state)\nthis:\n  the (s (f\\<^sub>0 \\<triangleright> length vs)) \\<noteq>\n  the (s (f\\<^sub>1 \\<triangleright> length vs))\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "then"], ["proof (chain)\npicking this:\n  the (s (f\\<^sub>0 \\<triangleright> length vs)) \\<noteq>\n  the (s (f\\<^sub>1 \\<triangleright> length vs))", "have \"s (f\\<^sub>0 \\<triangleright> length vs) \\<noteq> s (f\\<^sub>1 \\<triangleright> length vs)\""], ["proof (prove)\nusing this:\n  the (s (f\\<^sub>0 \\<triangleright> length vs)) \\<noteq>\n  the (s (f\\<^sub>1 \\<triangleright> length vs))\n\ngoal (1 subgoal):\n 1. s (f\\<^sub>0 \\<triangleright> length vs) \\<noteq>\n    s (f\\<^sub>1 \\<triangleright> length vs)", "by auto"], ["proof (state)\nthis:\n  s (f\\<^sub>0 \\<triangleright> length vs) \\<noteq>\n  s (f\\<^sub>1 \\<triangleright> length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "with f0(2) f1(2)"], ["proof (chain)\npicking this:\n  prefix f\\<^sub>0 (length vs) = vs @ [0]\n  prefix f\\<^sub>1 (length vs) = vs @ [1]\n  s (f\\<^sub>0 \\<triangleright> length vs) \\<noteq>\n  s (f\\<^sub>1 \\<triangleright> length vs)", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix f\\<^sub>0 (length vs) = vs @ [0]\n  prefix f\\<^sub>1 (length vs) = vs @ [1]\n  s (f\\<^sub>0 \\<triangleright> length vs) \\<noteq>\n  s (f\\<^sub>1 \\<triangleright> length vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode (vs @ [1]))", "by (simp add: init_def)"], ["proof (state)\nthis:\n  s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode (vs @ [1]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode (?vs @ [1]))\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode (?vs @ [1]))", "have \"s (list_encode (vs @ [0])) \\<noteq> s (list_encode vs) \\<or>\n      s (list_encode (vs @ [1])) \\<noteq> s (list_encode vs)\"\n      for vs"], ["proof (prove)\nusing this:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode (?vs @ [1]))\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (vs @ [0])) \\<noteq>\n    s (Partial_Recursive.list_encode vs) \\<or>\n    s (Partial_Recursive.list_encode (vs @ [1])) \\<noteq>\n    s (Partial_Recursive.list_encode vs)", "by metis"], ["proof (state)\nthis:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs) \\<or>\n  s (Partial_Recursive.list_encode (?vs @ [1])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs)\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs) \\<or>\n  s (Partial_Recursive.list_encode (?vs @ [1])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs)", "have \"s (list_encode (prefixes i (Suc x))) \\<noteq> s (list_encode (prefixes i x))\" for i x"], ["proof (prove)\nusing this:\n  s (Partial_Recursive.list_encode (?vs @ [0])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs) \\<or>\n  s (Partial_Recursive.list_encode (?vs @ [1])) \\<noteq>\n  s (Partial_Recursive.list_encode ?vs)\n\ngoal (1 subgoal):\n 1. s (Partial_Recursive.list_encode (prefixes i (Suc x))) \\<noteq>\n    s (Partial_Recursive.list_encode (prefixes i x))", "by simp"], ["proof (state)\nthis:\n  s (Partial_Recursive.list_encode (prefixes ?i (Suc ?x))) \\<noteq>\n  s (Partial_Recursive.list_encode (prefixes ?i ?x))\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  s (Partial_Recursive.list_encode (prefixes ?i (Suc ?x))) \\<noteq>\n  s (Partial_Recursive.list_encode (prefixes ?i ?x))", "have \"\\<not> learn_lim \\<phi> {\\<psi> i} s\" for i"], ["proof (prove)\nusing this:\n  s (Partial_Recursive.list_encode (prefixes ?i (Suc ?x))) \\<noteq>\n  s (Partial_Recursive.list_encode (prefixes ?i ?x))\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> {\\<psi> i} s", "using psi_def psi_init always_hyp_change_not_Lim"], ["proof (prove)\nusing this:\n  s (Partial_Recursive.list_encode (prefixes ?i (Suc ?x))) \\<noteq>\n  s (Partial_Recursive.list_encode (prefixes ?i ?x))\n  \\<psi> ?i ?x \\<equiv> Some (last (prefixes ?i ?x))\n  \\<psi> ?i \\<triangleright> ?x =\n  Partial_Recursive.list_encode (prefixes ?i ?x)\n  (\\<And>x.\n      ?s (?f \\<triangleright> Suc x) \\<noteq>\n      ?s (?f \\<triangleright> x)) \\<Longrightarrow>\n  \\<not> learn_lim ?\\<psi> {?f} ?s\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> {\\<psi> i} s", "by simp"], ["proof (state)\nthis:\n  \\<not> learn_lim \\<phi> {\\<psi> ?i} s\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> learn_lim \\<phi> {\\<psi> ?i} s", "have \"\\<not> learn_lim \\<phi> U_LIMCONS s\""], ["proof (prove)\nusing this:\n  \\<not> learn_lim \\<phi> {\\<psi> ?i} s\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s", "using ex_psi_in_U learn_lim_closed_subseteq"], ["proof (prove)\nusing this:\n  \\<not> learn_lim \\<phi> {\\<psi> ?i} s\n  \\<exists>j. \\<psi> j \\<in> U\\<^bsub>LIM-CONS\\<^esub>\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?V \\<subseteq> ?U\\<rbrakk>\n  \\<Longrightarrow> learn_lim ?\\<psi> ?V ?s\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s", "by blast"], ["proof (state)\nthis:\n  \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s", "show False"], ["proof (prove)\nusing this:\n  \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. False", "using learn learn_cons_def"], ["proof (prove)\nusing this:\n  \\<not> learn_lim \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n  learn_cons ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n k.\n         k \\<le> n \\<longrightarrow>\n         ?\\<psi> (the (?s (f \\<triangleright> n))) k = f k)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>With the locale we can now show the second part of the main\nresult:\\<close>"], ["", "lemma U_LIMCONS_not_in_CONS: \"U\\<^bsub>LIM-CONS\\<^esub> \\<notin> CONS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<notin> CONS", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "assume \"U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS\""], ["proof (state)\nthis:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS", "have \"U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>\""], ["proof (prove)\nusing this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>", "by (simp add: CONS_wrt_phi_eq_CONS)"], ["proof (state)\nthis:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>", "obtain almost_s where \"learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> almost_s\""], ["proof (prove)\nusing this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>\n\ngoal (1 subgoal):\n 1. (\\<And>almost_s.\n        learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub>\n         almost_s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using CONS_wrt_def"], ["proof (prove)\nusing this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS_wrt \\<phi>\n  CONS_wrt ?\\<psi> \\<equiv> {U. \\<exists>s. learn_cons ?\\<psi> U s}\n\ngoal (1 subgoal):\n 1. (\\<And>almost_s.\n        learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub>\n         almost_s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> almost_s\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> almost_s", "obtain s where s: \"total1 s\" \"learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\""], ["proof (prove)\nusing this:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> almost_s\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>total1 s;\n         learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using U_LIMCONS_prefix_complete U_prefix_complete_imp_total_strategy"], ["proof (prove)\nusing this:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> almost_s\n  0 < length ?vs \\<Longrightarrow>\n  \\<exists>f\\<in>U\\<^bsub>LIM-CONS\\<^esub>. prefix f (length ?vs - 1) = ?vs\n  \\<lbrakk>\\<And>vs.\n              0 < length vs \\<Longrightarrow>\n              \\<exists>f\\<in>?U. prefix f (length vs - 1) = vs;\n   learn_cons ?\\<psi> ?U ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t. total1 t \\<and> learn_cons ?\\<psi> ?U t\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>total1 s;\n         learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  total1 s\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  total1 s\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s", "have \"s \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  total1 s\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. s \\<in> \\<R>", "using learn_consE(1) P1_total_imp_R1"], ["proof (prove)\nusing this:\n  total1 s\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n  learn_cons ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>?f \\<in> \\<P>; total1 ?f\\<rbrakk> \\<Longrightarrow> ?f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. s \\<in> \\<R>", "by blast"], ["proof (state)\nthis:\n  s \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "with cons_lim_def"], ["proof (chain)\npicking this:\n  cons_lim ?s \\<equiv> ?s \\<in> \\<R>\n  s \\<in> \\<R>", "interpret cons_lim s"], ["proof (prove)\nusing this:\n  cons_lim ?s \\<equiv> ?s \\<in> \\<R>\n  s \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. cons_lim s", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. U\\<^bsub>LIM-CONS\\<^esub> \\<in> CONS \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using s(2) U_LIMCONS_not_learn_cons"], ["proof (prove)\nusing this:\n  learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n  \\<not> learn_cons \\<phi> U\\<^bsub>LIM-CONS\\<^esub> s\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The main result of this section:\\<close>"], ["", "theorem CONS_subset_Lim: \"CONS \\<subset> LIM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CONS \\<subset> LIM", "using U_LIMCONS_in_Lim U_LIMCONS_not_in_CONS CONS_subseteq_Lim"], ["proof (prove)\nusing this:\n  U\\<^bsub>LIM-CONS\\<^esub> \\<in> LIM\n  U\\<^bsub>LIM-CONS\\<^esub> \\<notin> CONS\n  CONS \\<subseteq> LIM\n\ngoal (1 subgoal):\n 1. CONS \\<subset> LIM", "by auto"], ["", "end"]]}