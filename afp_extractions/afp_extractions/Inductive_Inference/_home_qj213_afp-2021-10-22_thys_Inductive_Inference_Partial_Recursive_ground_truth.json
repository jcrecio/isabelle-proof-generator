{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/Partial_Recursive.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma wellf_arity_nonzero: \"wellf f \\<Longrightarrow> arity f > 0\"", "lemma wellf_Pr_arity_greater_1: \"wellf (Pr n f g) \\<Longrightarrow> arity (Pr n f g) > 1\"", "lemma eval_Z [simp]: \"eval Z [x] \\<down>= 0\"", "lemma eval_Z' [simp]: \"length xs = 1 \\<Longrightarrow> eval Z xs \\<down>= 0\"", "lemma eval_S [simp]: \"eval S [x] \\<down>= Suc x\"", "lemma eval_S' [simp]: \"length xs = 1 \\<Longrightarrow> eval S xs \\<down>= Suc (hd xs)\"", "lemma eval_Id [simp]:\n  assumes \"n < m\" and \"m = length xs\"\n  shows \"eval (Id m n) xs \\<down>= xs ! n\"", "lemma eval_Cn [simp]:\n  assumes \"recfn (length xs) (Cn n f gs)\"\n  shows \"eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs)\n     else None)\"", "lemma eval_Pr_0 [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\" and \"n = length xs\"\n  shows \"eval (Pr n f g) (0 # xs) = eval f xs\"", "lemma eval_Pr_diverg_Suc [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<up>\"\n  shows \"eval (Pr n f g) (Suc x # xs) \\<up>\"", "lemma eval_Pr_converg_Suc [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<down>\"\n  shows \"eval (Pr n f g) (Suc x # xs) = eval g (x # the (eval (Pr n f g) (x # xs)) # xs)\"", "lemma eval_Pr_diverg_add:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<up>\"\n  shows \"eval (Pr n f g) ((x + y) # xs) \\<up>\"", "lemma eval_Pr_converg_le:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<down>\"\n    and \"y \\<le> x\"\n  shows \"eval (Pr n f g) (y # xs) \\<down>\"", "lemma eval_Pr_Suc_converg:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (Suc x # xs) \\<down>\"\n  shows \"eval g (x # (the (eval (Pr n f g) (x # xs))) # xs) \\<down>\"\n    and \"eval (Pr n f g) (Suc x # xs) = eval g (x # the (eval (Pr n f g) (x # xs)) # xs)\"", "lemma eval_Mn [simp]:\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"eval (Mn n f) xs =\n   (if (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    then Some (LEAST z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    else None)\"", "lemma eval_wellf_Mn:\n  \"eval_wellf (Mn n f) xs =\n    (if (\\<exists>z. eval_wellf f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0)\n     else None)\"", "lemma eval_Mn':\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"eval (Mn n f) xs =\n   (if (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    then Some (LEAST z. eval f (z # xs) \\<down>= 0)\n    else None)\"", "lemma eval_Mn_convergI:\n  assumes \"recfn (length xs) (Mn n f)\"\n    and \"eval f (z # xs) \\<down>= 0\"\n    and \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\"\n  shows \"eval (Mn n f) xs \\<down>= z\"", "lemma eval_Mn_convergE:\n  assumes \"recfn (length xs) (Mn n f)\" and \"eval (Mn n f) xs \\<down>= z\"\n  shows \"z = (LEAST z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\"\n    and \"eval f (z # xs) \\<down>= 0\"\n    and \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\"", "lemma eval_Mn_diverg:\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"\\<not> (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)) \\<longleftrightarrow> eval (Mn n f) xs \\<up>\"", "lemma exteq_refl: \"f \\<simeq> f\"", "lemma exteq_sym: \"f \\<simeq> g \\<Longrightarrow> g \\<simeq> f\"", "lemma exteq_trans: \"f \\<simeq> g \\<Longrightarrow> g \\<simeq> h \\<Longrightarrow> f \\<simeq> h\"", "lemma exteqI:\n  assumes \"arity f = arity g\" and \"\\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs = eval g xs\"\n  shows \"f \\<simeq> g\"", "lemma exteqI1:\n  assumes \"arity f = 1\" and \"arity g = 1\" and \"\\<And>x. eval f [x] = eval g [x]\"\n  shows \"f \\<simeq> g\"", "lemma recfn_wrap_Id: \"recfn a f \\<Longrightarrow> recfn a (wrap_Id f n)\"", "lemma exteq_wrap_Id: \"recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\"", "lemma depth_wrap_Id: \"recfn a f \\<Longrightarrow> depth (wrap_Id f n) = depth f + n\"", "lemma wrap_Id_injective:\n  assumes \"recfn a f\" and \"wrap_Id f n\\<^sub>1 = wrap_Id f n\\<^sub>2\"\n  shows \"n\\<^sub>1 = n\\<^sub>2\"", "lemma exteq_infinite:\n  assumes \"recfn a f\"\n  shows \"infinite {g. recfn a g \\<and> g \\<simeq> f}\" (is \"infinite ?R\")", "lemma totalI [intro]:\n  assumes \"\\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>\"\n  shows \"total f\"", "lemma totalE [simp]:\n  assumes \"total f\" and \"recfn n f\" and \"length xs = n\"\n  shows \"eval f xs \\<down>\"", "lemma totalI1 :\n  assumes \"recfn 1 f\" and \"\\<And>x. eval f [x] \\<down>\"\n  shows \"total f\"", "lemma totalI2:\n  assumes \"recfn 2 f\" and \"\\<And>x y. eval f [x, y] \\<down>\"\n  shows \"total f\"", "lemma totalI3:\n  assumes \"recfn 3 f\" and \"\\<And>x y z. eval f [x, y, z] \\<down>\"\n  shows \"total f\"", "lemma totalI4:\n  assumes \"recfn 4 f\" and \"\\<And>w x y z. eval f [w, x, y, z] \\<down>\"\n  shows \"total f\"", "lemma Mn_free_imp_total [intro]:\n  assumes \"wellf f\" and \"Mn_free f\"\n  shows \"total f\"", "lemma prim_recfn_total: \"prim_recfn n f \\<Longrightarrow> total f\"", "lemma eval_Pr_prim_Suc:\n  assumes \"h = Pr n f g\" and \"prim_recfn (Suc n) h\" and \"length xs = n\"\n  shows \"eval h (Suc x # xs) = eval g (x # the (eval h (x # xs)) # xs)\"", "lemma Cn_total:\n  assumes \"\\<forall>g\\<in>set gs. total g\" and \"total f\" and \"recfn n (Cn n f gs)\"\n  shows \"total (Cn n f gs)\"", "lemma Pr_total:\n  assumes \"total f\" and \"total g\" and \"recfn (Suc n) (Pr n f g)\"\n  shows \"total (Pr n f g)\"", "lemma eval_Mn_total:\n  assumes \"recfn (length xs) (Mn n f)\" and \"total f\"\n  shows \"eval (Mn n f) xs =\n    (if (\\<exists>z. eval f (z # xs) \\<down>= 0)\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0)\n     else None)\"", "lemma r_dummy_prim [simp]:\n  \"prim_recfn a f \\<Longrightarrow> prim_recfn (a + n) (r_dummy n f)\"", "lemma r_dummy_recfn [simp]:\n  \"recfn a f \\<Longrightarrow> recfn (a + n) (r_dummy n f)\"", "lemma r_dummy [simp]:\n  \"r_dummy n f = Cn (arity f + n) f (map (\\<lambda>i. Id (arity f + n) i) [0..<arity f])\"", "lemma r_dummy_append:\n  assumes \"recfn (length xs) f\" and \"length ys = n\"\n  shows \"eval (r_dummy n f) (xs @ ys) = eval f xs\"", "lemma r_shrink_prim [simp]: \"prim_recfn 2 f \\<Longrightarrow> prim_recfn 1 (r_shrink f)\"", "lemma r_shrink_recfn [simp]: \"recfn 2 f \\<Longrightarrow> recfn 1 (r_shrink f)\"", "lemma r_shrink [simp]: \"recfn 2 f \\<Longrightarrow> eval (r_shrink f) [x] = eval f [x, x]\"", "lemma r_swap_recfn [simp]: \"recfn 2 f \\<Longrightarrow> recfn 2 (r_swap f)\"", "lemma r_swap_prim [simp]: \"prim_recfn 2 f \\<Longrightarrow> prim_recfn 2 (r_swap f)\"", "lemma r_swap [simp]: \"recfn 2 f \\<Longrightarrow> eval (r_swap f) [x, y] = eval f [y, x]\"", "lemma r_shift_prim [simp]: \"prim_recfn a f \\<Longrightarrow> prim_recfn (Suc a) (r_shift f)\"", "lemma r_shift_recfn [simp]: \"recfn a f \\<Longrightarrow> recfn (Suc a) (r_shift f)\"", "lemma r_shift [simp]:\n  assumes \"recfn (length xs) f\"\n  shows \"eval (r_shift f) (x # xs) = eval f xs\"", "lemma r_const_prim [simp]: \"prim_recfn 1 (r_const c)\"", "lemma r_const [simp]: \"eval (r_const c) [x] \\<down>= c\"", "lemma r_constn_prim [simp]: \"prim_recfn (Suc n) (r_constn n c)\"", "lemma r_constn [simp]: \"length xs = Suc n \\<Longrightarrow> eval (r_constn n c) xs \\<down>= c\"", "lemma r_add_prim [simp]: \"prim_recfn 2 r_add\"", "lemma r_add [simp]: \"eval r_add [a, b] \\<down>= a + b\"", "lemma r_mul_prim [simp]: \"prim_recfn 2 r_mul\"", "lemma r_mul [simp]: \"eval r_mul [a, b] \\<down>= a * b\"", "lemma r_dec_prim [simp]: \"prim_recfn 1 r_dec\"", "lemma r_dec [simp]: \"eval r_dec [a] \\<down>= a - 1\"", "lemma r_sub_prim [simp]: \"prim_recfn 2 r_sub\"", "lemma r_sub [simp]: \"eval r_sub [a, b] \\<down>= a - b\"", "lemma r_sign_prim [simp]: \"prim_recfn 1 r_sign\"", "lemma r_sign [simp]: \"eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)\"", "lemma r_not_prim [simp]: \"prim_recfn 1 r_not\"", "lemma r_not [simp]: \"eval r_not [x] \\<down>= (if x = 0 then 1 else 0)\"", "lemma r_nand_prim [simp]: \"prim_recfn 2 r_nand\"", "lemma r_nand [simp]: \"eval r_nand [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 1 else 0)\"", "lemma r_and_prim [simp]: \"prim_recfn 2 r_and\"", "lemma r_and [simp]: \"eval r_and [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 0 else 1)\"", "lemma r_or_prim [simp]: \"prim_recfn 2 r_or\"", "lemma r_or [simp]: \"eval r_or [x, y] \\<down>= (if x = 0 \\<or> y = 0 then 0 else 1)\"", "lemma r_ifz_prim [simp]: \"prim_recfn 3 r_ifz\"", "lemma r_ifz [simp]: \"eval r_ifz [cond, val0, val1] \\<down>= (if cond = 0 then val0 else val1)\"", "lemma r_eq_prim [simp]: \"prim_recfn 2 r_eq\"", "lemma r_eq [simp]: \"eval r_eq [x, y] \\<down>= (if x = y then 0 else 1)\"", "lemma r_ifeq_prim [simp]: \"prim_recfn 4 r_ifeq\"", "lemma r_ifeq [simp]: \"eval r_ifeq [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a = b then v\\<^sub>0 else v\\<^sub>1)\"", "lemma r_neq_prim [simp]: \"prim_recfn 2 r_neq\"", "lemma r_neq [simp]: \"eval r_neq [x, y] \\<down>= (if x = y then 1 else 0)\"", "lemma r_ifle_prim [simp]: \"prim_recfn 4 r_ifle\"", "lemma r_ifle [simp]: \"eval r_ifle [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a \\<le> b then v\\<^sub>0 else v\\<^sub>1)\"", "lemma r_ifless_prim [simp]: \"prim_recfn 4 r_ifless\"", "lemma r_ifless [simp]: \"eval r_ifless [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a < b then v\\<^sub>0 else v\\<^sub>1)\"", "lemma r_less_prim [simp]: \"prim_recfn 2 r_less\"", "lemma r_less [simp]: \"eval r_less [x, y] \\<down>= (if x < y then 0 else 1)\"", "lemma r_le_prim [simp]: \"prim_recfn 2 r_le\"", "lemma r_le [simp]: \"eval r_le [x, y] \\<down>= (if x \\<le> y then 0 else 1)\"", "lemma r_ifeq_else_diverg_recfn [simp]: \"recfn 3 r_ifeq_else_diverg\"", "lemma r_ifeq_else_diverg [simp]:\n  \"eval r_ifeq_else_diverg [a, b, v] = (if a = b then Some v else None)\"", "theorem halting_problem_undecidable:\n  fixes code :: \"nat \\<Rightarrow> recf\"\n  assumes \"\\<And>f. recfn 1 f \\<Longrightarrow> \\<exists>i. code i = f\"\n  shows \"\\<not> decidable {x. eval (code x) [x] \\<down>}\" (is \"\\<not> decidable ?K\")", "lemma r_triangle_prim: \"prim_recfn 1 r_triangle\"", "lemma r_triangle: \"eval r_triangle [n] \\<down>= Sum {0..n}\"", "lemma r_triangle_eq_triangle [simp]: \"eval r_triangle [n] \\<down>= triangle n\"", "lemma r_prod_encode_prim [simp]: \"prim_recfn 2 r_prod_encode\"", "lemma r_prod_encode [simp]: \"eval r_prod_encode [m, n] \\<down>= prod_encode (m, n)\"", "lemma pdec1_le: \"pdec1 i \\<le> i\"", "lemma pdec2_le: \"pdec2 i \\<le> i\"", "lemma pdec_less: \"pdec2 i < Suc i\"", "lemma pdec1_zero: \"pdec1 0 = 0\"", "lemma r_maxletr_prim: \"prim_recfn 2 r_maxletr\"", "lemma not_Suc_Greatest_not_Suc:\n  assumes \"\\<not> P (Suc x)\" and \"\\<exists>x. P x\"\n  shows \"(GREATEST y. y \\<le> x \\<and> P y) = (GREATEST y. y \\<le> Suc x \\<and> P y)\"", "lemma r_maxletr: \"eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>= (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\"", "lemma r_maxlt_prim: \"prim_recfn 1 r_maxlt\"", "lemma r_maxlt: \"eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)\"", "lemma max_triangle_bound: \"triangle z \\<le> e \\<Longrightarrow> z \\<le> e\"", "lemma triangle_greatest_le: \"triangle (GREATEST y. triangle y \\<le> e) \\<le> e\"", "lemma prod_encode_pdec': \"prod_encode (pdec1' e, pdec2' e) = e\"", "lemma pdec':\n  \"pdec1' e = pdec1 e\"\n  \"pdec2' e = pdec2 e\"", "lemma r_pdec1_prim [simp]: \"prim_recfn 1 r_pdec1\"", "lemma r_pdec1 [simp]: \"eval r_pdec1 [e] \\<down>= pdec1 e\"", "lemma r_pdec2_prim [simp]: \"prim_recfn 1 r_pdec2\"", "lemma r_pdec2 [simp]: \"eval r_pdec2 [e] \\<down>= pdec2 e\"", "lemma r_pdec12_prim [simp]: \"prim_recfn 1 r_pdec12\"", "lemma r_pdec12 [simp]: \"eval r_pdec12 [e] \\<down>= pdec12 e\"", "lemma r_pdec22_prim [simp]: \"prim_recfn 1 r_pdec22\"", "lemma r_pdec22 [simp]: \"eval r_pdec22 [e] \\<down>= pdec22 e\"", "lemma r_pdec122_prim [simp]: \"prim_recfn 1 r_pdec122\"", "lemma r_pdec122 [simp]: \"eval r_pdec122 [e] \\<down>= pdec122 e\"", "lemma r_pdec222_prim [simp]: \"prim_recfn 1 r_pdec222\"", "lemma r_pdec222 [simp]: \"eval r_pdec222 [e] \\<down>= pdec222 e\"", "lemma tuple_encode_prod_encode: \"tuple_encode 1 [x, y] = prod_encode (x, y)\"", "lemma tuple_encode_decode [simp]:\n  \"tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\"", "lemma tuple_encode_decode' [simp]: \"tuple_encode n (tuple_decode n i) = i\"", "lemma tuple_decode_encode:\n  assumes \"length xs > 0\"\n  shows \"tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs\"", "lemma tuple_decode_encode' [simp]:\n  assumes \"length xs = Suc n\"\n  shows \"tuple_decode n (tuple_encode n xs) = xs\"", "lemma tuple_decode_length [simp]: \"length (tuple_decode n i) = Suc n\"", "lemma tuple_decode_nonzero:\n  assumes \"n > 0\"\n  shows \"tuple_decode n i = pdec1 i # tuple_decode (n - 1) (pdec2 i)\"", "lemma r_tuple_encode_prim [simp]: \"prim_recfn (Suc n) (r_tuple_encode n)\"", "lemma r_tuple_encode:\n  assumes \"length xs = Suc n\"\n  shows \"eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs\"", "lemma e_tuple_nth_le [simp]: \"n \\<le> a \\<Longrightarrow> e_tuple_nth a i n = (tuple_decode a i) ! n\"", "lemma e_tuple_nth_gr [simp]: \"n > a \\<Longrightarrow> e_tuple_nth a i n = 0\"", "lemma tuple_decode_pdec2: \"tuple_decode a (pdec2 es) = tl (tuple_decode (Suc a) es)\"", "lemma iterate_additive:\n  assumes \"iterate t\\<^sub>1 f x = y\" and \"iterate t\\<^sub>2 f y = z\"\n  shows \"iterate (t\\<^sub>1 + t\\<^sub>2) f x = z\"", "lemma iterate_additive': \"iterate (t\\<^sub>1 + t\\<^sub>2) f x = iterate t\\<^sub>2 f (iterate t\\<^sub>1 f x)\"", "lemma e_tuple_nth_elementary:\n  assumes \"k \\<le> a\"\n  shows \"e_tuple_nth a i k = (if a = k then (iterate k pdec2 i) else (pdec1 (iterate k pdec2 i)))\"", "lemma r_nth_inbounds_prim: \"prim_recfn 3 r_nth_inbounds\"", "lemma r_nth_inbounds:\n  \"k \\<le> a \\<Longrightarrow> eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\"\n  \"eval r_nth_inbounds [a, i, k] \\<down>\"", "lemma r_tuple_nth_prim: \"prim_recfn 3 r_tuple_nth\"", "lemma r_tuple_nth [simp]: \"eval r_tuple_nth [a, i, k] \\<down>= e_tuple_nth a i k\"", "lemma list_encode_0 [simp]: \"list_encode xs = 0 \\<Longrightarrow> xs = []\"", "lemma list_encode_1: \"list_encode [0] = 1\"", "lemma list_encode_decode [simp]: \"list_encode (list_decode n) = n\"", "lemma list_decode_encode [simp]: \"list_decode (list_encode xs) = xs\"", "lemma list_decode_singleton: \"list_decode (singleton_encode x) = [x]\"", "lemma r_singleton_encode_prim [simp]: \"prim_recfn 1 r_singleton_encode\"", "lemma r_singleton_encode [simp]: \"eval r_singleton_encode [x] \\<down>= singleton_encode x\"", "lemma r_list_encode_prim [simp]: \"prim_recfn (Suc n) (r_list_encode n)\"", "lemma r_list_encode:\n  assumes \"length xs = Suc n\"\n  shows \"eval (r_list_encode n) xs \\<down>= list_encode xs\"", "lemma e_tl_elementary:\n  \"e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n     else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\"", "lemma r_tl_prim [simp]: \"prim_recfn 1 r_tl\"", "lemma r_tl [simp]: \"eval r_tl [e] \\<down>= e_tl e\"", "lemma e_hd [simp]:\n  assumes \"list_decode e = x # xs\"\n  shows \"e_hd e = x\"", "lemma e_hd_0 [simp]: \"e_hd 0 = 0\"", "lemma e_hd_neq_0 [simp]:\n  assumes \"e \\<noteq> 0\"\n  shows \"e_hd e = hd (list_decode e)\"", "lemma r_hd_prim [simp]: \"prim_recfn 1 r_hd\"", "lemma r_hd [simp]: \"eval r_hd [e] \\<down>= e_hd e\"", "lemma e_length_0: \"e_length e = 0 \\<Longrightarrow> e = 0\"", "lemma r_length_prim [simp]: \"prim_recfn 1 r_length\"", "lemma r_length [simp]: \"eval r_length [e] \\<down>= e_length e\"", "lemma e_nth [simp]:\n  \"e_nth e n = (if n < e_length e then (list_decode e) ! n else 0)\"", "lemma e_hd_nth0: \"e_hd e = e_nth e 0\"", "lemma r_nth_prim [simp]: \"prim_recfn 2 r_nth\"", "lemma r_nth [simp]: \"eval r_nth [e, n] \\<down>= e_nth e n\"", "lemma r_rev_aux_prim: \"prim_recfn 2 r_rev_aux\"", "lemma r_rev_aux:\n  assumes \"list_decode e = xs\" and \"length xs > 0\" and \"i < length xs\"\n  shows \"eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\"", "lemma r_rev_aux_total: \"eval r_rev_aux [i, e] \\<down>\"", "lemma r_rev_prim [simp]: \"prim_recfn 1 r_rev\"", "lemma r_rev [simp]: \"eval r_rev [e] \\<down>= list_encode (rev (list_decode e))\"", "lemma e_cons_elementary:\n  \"e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\"", "lemma r_cons_else_prim: \"prim_recfn 2 r_cons_else\"", "lemma r_cons_else:\n  \"eval r_cons_else [e, es] \\<down>=\n    Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1))))\"", "lemma r_cons_prim [simp]: \"prim_recfn 2 r_cons\"", "lemma r_cons [simp]: \"eval r_cons [e, es] \\<down>= e_cons e es\"", "lemma e_nth_snoc_small [simp]:\n  assumes \"n < e_length b\"\n  shows \"e_nth (e_snoc b z) n = e_nth b n\"", "lemma e_hd_snoc [simp]:\n  assumes \"e_length b > 0\"\n  shows \"e_hd (e_snoc b x) = e_hd b\"", "lemma r_snoc_prim [simp]: \"prim_recfn 2 r_snoc\"", "lemma r_snoc [simp]: \"eval r_snoc [es, e] \\<down>= e_snoc es e\"", "lemma r_take_prim [simp]: \"prim_recfn 2 r_take\"", "lemma r_take:\n  assumes \"x = list_encode es\"\n  shows \"eval r_take [n, x] \\<down>= list_encode (take n es)\"", "lemma r_last_prim [simp]: \"prim_recfn 1 r_last\"", "lemma r_last [simp]:\n  assumes \"e = list_encode xs\" and \"length xs > 0\"\n  shows \"eval r_last [e] \\<down>= last xs\"", "lemma r_update_aux_recfn: \"recfn 4 r_update_aux\"", "lemma r_update_aux:\n  assumes \"n \\<le> e_length b\"\n  shows \"eval r_update_aux [n, b, j, v] \\<down>= list_encode ((take n (list_decode b))[j:=v])\"", "lemma r_update_recfn [simp]: \"recfn 3 r_update\"", "lemma r_update [simp]: \"eval r_update [b, j, v] \\<down>= e_update b j v\"", "lemma e_length_update [simp]: \"e_length (e_update b k v) = e_length b\"", "lemma e_length_append: \"e_length (e_append xs ys) = e_length xs + e_length ys\"", "lemma e_nth_append_small:\n  assumes \"n < e_length xs\"\n  shows \"e_nth (e_append xs ys) n = e_nth xs n\"", "lemma e_nth_append_big:\n  assumes \"n \\<ge> e_length xs\"\n  shows \"e_nth (e_append xs ys) n = e_nth ys (n - e_length xs)\"", "lemma r_append_prim [simp]: \"prim_recfn 2 r_append\"", "lemma r_append [simp]: \"eval r_append [a, b] \\<down>= e_append a b\"", "lemma e_append_zeros_length: \"e_length (e_append_zeros b z) = e_length b + z\"", "lemma e_nth_append_zeros: \"e_nth (e_append_zeros b z) i = e_nth b i\"", "lemma e_nth_append_zeros_big:\n  assumes \"i \\<ge> e_length b\"\n  shows \"e_nth (e_append_zeros b z) i = 0\"", "lemma r_append_zeros_prim [simp]: \"prim_recfn 2 r_append_zeros\"", "lemma r_append_zeros: \"eval r_append_zeros [b, z] \\<down>= e_append_zeros b z\""], "translations": [["", "lemma wellf_arity_nonzero: \"wellf f \\<Longrightarrow> arity f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellf f \\<Longrightarrow> 0 < arity f", "by (induction f rule: arity.induct) simp_all"], ["", "lemma wellf_Pr_arity_greater_1: \"wellf (Pr n f g) \\<Longrightarrow> arity (Pr n f g) > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellf (Pr n f g) \\<Longrightarrow> 1 < arity (Pr n f g)", "using wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. wellf (Pr n f g) \\<Longrightarrow> 1 < arity (Pr n f g)", "by auto"], ["", "text \\<open>For the most part of this chapter this is the meaning of ``$f$\nis an $n$-ary partial recursive function'':\\<close>"], ["", "abbreviation recfn :: \"nat \\<Rightarrow> recf \\<Rightarrow> bool\" where\n  \"recfn n f \\<equiv> wellf f \\<and> arity f = n\""], ["", "text \\<open>Some abbreviations for working with @{typ \"nat option\"}:\\<close>"], ["", "abbreviation divergent :: \"nat option \\<Rightarrow> bool\" (\"_ \\<up>\" [50] 50) where\n  \"x \\<up> \\<equiv> x = None\""], ["", "abbreviation convergent :: \"nat option \\<Rightarrow> bool\" (\"_ \\<down>\" [50] 50) where\n  \"x \\<down> \\<equiv> x \\<noteq> None\""], ["", "abbreviation convergent_eq :: \"nat option \\<Rightarrow> nat \\<Rightarrow> bool\" (infix \"\\<down>=\" 50) where\n  \"x \\<down>= y \\<equiv> x = Some y\""], ["", "abbreviation convergent_neq :: \"nat option \\<Rightarrow> nat \\<Rightarrow> bool\" (infix \"\\<down>\\<noteq>\" 50) where\n  \"x \\<down>\\<noteq> y \\<equiv> x \\<down> \\<and> x \\<noteq> Some y\""], ["", "text \\<open>In prose the terms ``halt'', ``terminate'', ``converge'', and\n``defined'' will be used interchangeably; likewise for ``not halt'',\n``diverge'', and ``undefined''. In names of lemmas, the abbreviations @{text\nconverg} and @{text diverg} will be used consistently.\\<close>"], ["", "text \\<open>Our second major deviation from Xu\net~al.~\\cite{Universal_Turing_Machine-AFP} is that we model the semantics of\na @{typ recf} by combining the value and the termination of a function into\none evaluation function with codomain @{typ \"nat option\"}, rather than\nseparating both aspects into an evaluation function with codomain @{typ nat}\nand a termination predicate.\n\nThe value of a well-formed partial recursive function applied to a\ncorrectly-sized list of arguments:\\<close>"], ["", "fun eval_wellf :: \"recf \\<Rightarrow> nat list \\<Rightarrow> nat option\" where\n  \"eval_wellf Z xs \\<down>= 0\"\n| \"eval_wellf S xs \\<down>= Suc (xs ! 0)\"\n| \"eval_wellf (Id m n) xs \\<down>= xs ! n\"\n| \"eval_wellf (Cn n f gs) xs =\n   (if \\<forall>g \\<in> set gs. eval_wellf g xs \\<down>\n    then eval_wellf f (map (\\<lambda>g. the (eval_wellf g xs)) gs)\n    else None)\"\n| \"eval_wellf (Pr n f g) [] = undefined\"\n| \"eval_wellf (Pr n f g) (0 # xs) = eval_wellf f xs\"\n| \"eval_wellf (Pr n f g) (Suc x # xs) =\n   Option.bind (eval_wellf (Pr n f g) (x # xs)) (\\<lambda>v. eval_wellf g (x # v # xs))\"\n| \"eval_wellf (Mn n f) xs =\n   (let E = \\<lambda>z. eval_wellf f (z # xs)\n    in if \\<exists>z. E z \\<down>= 0 \\<and> (\\<forall>y<z. E y \\<down>)\n       then Some (LEAST z. E z \\<down>= 0 \\<and> (\\<forall>y<z. E y \\<down>))\n       else None)\""], ["", "text \\<open>We define a function value only if the @{typ recf} is well-formed\nand its arity matches the number of arguments.\\<close>"], ["", "definition eval :: \"recf \\<Rightarrow> nat list \\<Rightarrow> nat option\" where\n  \"recfn (length xs) f \\<Longrightarrow> eval f xs \\<equiv> eval_wellf f xs\""], ["", "lemma eval_Z [simp]: \"eval Z [x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval Z [x] \\<down>= 0", "by (simp add: eval_def)"], ["", "lemma eval_Z' [simp]: \"length xs = 1 \\<Longrightarrow> eval Z xs \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 1 \\<Longrightarrow> eval Z xs \\<down>= 0", "by (simp add: eval_def)"], ["", "lemma eval_S [simp]: \"eval S [x] \\<down>= Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval S [x] \\<down>= Suc x", "by (simp add: eval_def)"], ["", "lemma eval_S' [simp]: \"length xs = 1 \\<Longrightarrow> eval S xs \\<down>= Suc (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 1 \\<Longrightarrow> eval S xs \\<down>= Suc (hd xs)", "using eval_def hd_conv_nth[of xs]"], ["proof (prove)\nusing this:\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n  xs \\<noteq> [] \\<Longrightarrow> hd xs = xs ! 0\n\ngoal (1 subgoal):\n 1. length xs = 1 \\<Longrightarrow> eval S xs \\<down>= Suc (hd xs)", "by fastforce"], ["", "lemma eval_Id [simp]:\n  assumes \"n < m\" and \"m = length xs\"\n  shows \"eval (Id m n) xs \\<down>= xs ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (recf.Id m n) xs \\<down>= xs ! n", "using assms"], ["proof (prove)\nusing this:\n  n < m\n  m = length xs\n\ngoal (1 subgoal):\n 1. eval (recf.Id m n) xs \\<down>= xs ! n", "by (simp add: eval_def)"], ["", "lemma eval_Cn [simp]:\n  assumes \"recfn (length xs) (Cn n f gs)\"\n  shows \"eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs)\n     else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "have \"eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs", "using assms eval_def"], ["proof (prove)\nusing this:\n  recfn (length xs) (Cn n f gs)\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs", "by blast"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "moreover"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "have \"\\<And>g. g \\<in> set gs \\<Longrightarrow> eval_wellf g xs = eval g xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> set gs \\<Longrightarrow> eval_wellf g xs = eval g xs", "using assms eval_def"], ["proof (prove)\nusing this:\n  recfn (length xs) (Cn n f gs)\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n\ngoal (1 subgoal):\n 1. \\<And>g. g \\<in> set gs \\<Longrightarrow> eval_wellf g xs = eval g xs", "by simp"], ["proof (state)\nthis:\n  ?g \\<in> set gs \\<Longrightarrow> eval_wellf ?g xs = eval ?g xs\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\n  ?g \\<in> set gs \\<Longrightarrow> eval_wellf ?g xs = eval ?g xs", "have \"eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs)\n     else None)\""], ["proof (prove)\nusing this:\n  eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\n  ?g \\<in> set gs \\<Longrightarrow> eval_wellf ?g xs = eval ?g xs\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "using map_eq_conv[of \"\\<lambda>g. the (eval_wellf g xs)\" gs \"\\<lambda>g. the (eval g xs)\"]"], ["proof (prove)\nusing this:\n  eval (Cn n f gs) xs = eval_wellf (Cn n f gs) xs\n  ?g \\<in> set gs \\<Longrightarrow> eval_wellf ?g xs = eval ?g xs\n  (map (\\<lambda>g. the (eval_wellf g xs)) gs =\n   map (\\<lambda>g. the (eval g xs)) gs) =\n  (\\<forall>x\\<in>set gs. the (eval_wellf x xs) = the (eval x xs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "by (auto, metis)"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs =\n  (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n   then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "moreover"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs =\n  (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n   then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "have \"\\<And>ys. length ys = length gs \\<Longrightarrow> eval f ys = eval_wellf f ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       length ys = length gs \\<Longrightarrow> eval f ys = eval_wellf f ys", "using assms eval_def"], ["proof (prove)\nusing this:\n  recfn (length xs) (Cn n f gs)\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       length ys = length gs \\<Longrightarrow> eval f ys = eval_wellf f ys", "by simp"], ["proof (state)\nthis:\n  length ?ys = length gs \\<Longrightarrow> eval f ?ys = eval_wellf f ?ys\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn n f gs) xs =\n  (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n   then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)\n  length ?ys = length gs \\<Longrightarrow> eval f ?ys = eval_wellf f ?ys", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn n f gs) xs =\n  (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n   then eval_wellf f (map (\\<lambda>g. the (eval g xs)) gs) else None)\n  length ?ys = length gs \\<Longrightarrow> eval f ?ys = eval_wellf f ?ys\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs =\n    (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n     then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)", "by auto"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs =\n  (if \\<forall>g\\<in>set gs. eval g xs \\<down>\n   then eval f (map (\\<lambda>g. the (eval g xs)) gs) else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_Pr_0 [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\" and \"n = length xs\"\n  shows \"eval (Pr n f g) (0 # xs) = eval f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (0 # xs) = eval f xs", "using assms"], ["proof (prove)\nusing this:\n  recfn (Suc n) (Pr n f g)\n  n = length xs\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (0 # xs) = eval f xs", "by (simp add: eval_def)"], ["", "lemma eval_Pr_diverg_Suc [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<up>\"\n  shows \"eval (Pr n f g) (Suc x # xs) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (Suc x # xs) \\<up>", "using assms"], ["proof (prove)\nusing this:\n  recfn (Suc n) (Pr n f g)\n  n = length xs\n  eval (Pr n f g) (x # xs) \\<up>\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (Suc x # xs) \\<up>", "by (simp add: eval_def)"], ["", "lemma eval_Pr_converg_Suc [simp]:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<down>\"\n  shows \"eval (Pr n f g) (Suc x # xs) = eval g (x # the (eval (Pr n f g) (x # xs)) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (Suc x # xs) =\n    eval g (x # the (eval (Pr n f g) (x # xs)) # xs)", "using assms eval_def"], ["proof (prove)\nusing this:\n  recfn (Suc n) (Pr n f g)\n  n = length xs\n  eval (Pr n f g) (x # xs) \\<down>\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (Suc x # xs) =\n    eval g (x # the (eval (Pr n f g) (x # xs)) # xs)", "by auto"], ["", "lemma eval_Pr_diverg_add:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<up>\"\n  shows \"eval (Pr n f g) ((x + y) # xs) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) ((x + y) # xs) \\<up>", "using assms"], ["proof (prove)\nusing this:\n  recfn (Suc n) (Pr n f g)\n  n = length xs\n  eval (Pr n f g) (x # xs) \\<up>\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) ((x + y) # xs) \\<up>", "by (induction y) auto"], ["", "lemma eval_Pr_converg_le:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (x # xs) \\<down>\"\n    and \"y \\<le> x\"\n  shows \"eval (Pr n f g) (y # xs) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (y # xs) \\<down>", "using assms eval_Pr_diverg_add le_Suc_ex"], ["proof (prove)\nusing this:\n  recfn (Suc n) (Pr n f g)\n  n = length xs\n  eval (Pr n f g) (x # xs) \\<down>\n  y \\<le> x\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (?x # ?xs) \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) ((?x + ?y) # ?xs) \\<up>\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (y # xs) \\<down>", "by metis"], ["", "lemma eval_Pr_Suc_converg:\n  assumes \"recfn (Suc n) (Pr n f g)\"\n    and \"n = length xs\"\n    and \"eval (Pr n f g) (Suc x # xs) \\<down>\"\n  shows \"eval g (x # (the (eval (Pr n f g) (x # xs))) # xs) \\<down>\"\n    and \"eval (Pr n f g) (Suc x # xs) = eval g (x # the (eval (Pr n f g) (x # xs)) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g (x # the (eval (Pr n f g) (x # xs)) # xs) \\<down> &&&\n    eval (Pr n f g) (Suc x # xs) =\n    eval g (x # the (eval (Pr n f g) (x # xs)) # xs)", "using eval_Pr_converg_Suc[of n f g xs x, OF assms(1,2)]\n    eval_Pr_converg_le[of n f g xs \"Suc x\" x, OF assms] assms(3)"], ["proof (prove)\nusing this:\n  eval (Pr n f g) (x # xs) \\<down> \\<Longrightarrow>\n  eval (Pr n f g) (Suc x # xs) =\n  eval g (x # the (eval (Pr n f g) (x # xs)) # xs)\n  x \\<le> Suc x \\<Longrightarrow> eval (Pr n f g) (x # xs) \\<down>\n  eval (Pr n f g) (Suc x # xs) \\<down>\n\ngoal (1 subgoal):\n 1. eval g (x # the (eval (Pr n f g) (x # xs)) # xs) \\<down> &&&\n    eval (Pr n f g) (Suc x # xs) =\n    eval g (x # the (eval (Pr n f g) (x # xs)) # xs)", "by simp_all"], ["", "lemma eval_Mn [simp]:\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"eval (Mn n f) xs =\n   (if (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    then Some (LEAST z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z.\n           eval f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval f (y # xs) \\<down>)\n     then Some\n           (LEAST z.\n               eval f (z # xs) \\<down>= 0 \\<and>\n               (\\<forall>y<z. eval f (y # xs) \\<down>))\n     else None)", "using assms eval_def"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z.\n           eval f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval f (y # xs) \\<down>)\n     then Some\n           (LEAST z.\n               eval f (z # xs) \\<down>= 0 \\<and>\n               (\\<forall>y<z. eval f (y # xs) \\<down>))\n     else None)", "by auto"], ["", "text \\<open>For $\\mu$-recursion, the condition @{term \"(\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\"}\ninside @{text LEAST} in the definition of @{term eval_wellf} is redundant.\\<close>"], ["", "lemma eval_wellf_Mn:\n  \"eval_wellf (Mn n f) xs =\n    (if (\\<exists>z. eval_wellf f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0)\n     else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "let ?P = \"\\<lambda>z. eval_wellf f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "assume \"\\<exists>z. ?P z\""], ["proof (state)\nthis:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "moreover"], ["proof (state)\nthis:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "define z where \"z = Least ?P\""], ["proof (state)\nthis:\n  z =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n  z =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))", "have \"?P z\""], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n  z =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval_wellf f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)", "using LeastI[of ?P]"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n  z =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n  eval_wellf f (?k # xs) \\<down>= 0 \\<and>\n  (\\<forall>y<?k. eval_wellf f (y # xs) \\<down>) \\<Longrightarrow>\n  eval_wellf f\n   ((LEAST x.\n        eval_wellf f (x # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<x. eval_wellf f (y # xs) \\<down>)) #\n    xs) \\<down>=\n  0 \\<and>\n  (\\<forall>y<LEAST x.\n                 eval_wellf f (x # xs) \\<down>= 0 \\<and>\n                 (\\<forall>y<x. eval_wellf f (y # xs) \\<down>).\n      eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)", "by blast"], ["proof (state)\nthis:\n  eval_wellf f (z # xs) \\<down>= 0 \\<and>\n  (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "have \"(LEAST z. eval_wellf f (z # xs) \\<down>= 0) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST z. eval_wellf f (z # xs) \\<down>= 0) = z", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval_wellf f (z # xs) \\<down>= 0\n 2. \\<And>y. eval_wellf f (y # xs) \\<down>= 0 \\<Longrightarrow> z \\<le> y", "show \"eval_wellf f (z # xs) \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_wellf f (z # xs) \\<down>= 0", "using \\<open>?P z\\<close>"], ["proof (prove)\nusing this:\n  eval_wellf f (z # xs) \\<down>= 0 \\<and>\n  (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf f (z # xs) \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval_wellf f (z # xs) \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<And>y. eval_wellf f (y # xs) \\<down>= 0 \\<Longrightarrow> z \\<le> y", "show \"z \\<le> y\" if \"eval_wellf f (y # xs) \\<down>= 0\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<le> y", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> z \\<le> y \\<Longrightarrow> False", "assume \"\\<not> z \\<le> y\""], ["proof (state)\nthis:\n  \\<not> z \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le> y \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> z \\<le> y", "have \"y < z\""], ["proof (prove)\nusing this:\n  \\<not> z \\<le> y\n\ngoal (1 subgoal):\n 1. y < z", "by simp"], ["proof (state)\nthis:\n  y < z\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le> y \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  y < z\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le> y \\<Longrightarrow> False", "from this"], ["proof (chain)\npicking this:\n  y < z", "have \"?P y\""], ["proof (prove)\nusing this:\n  y < z\n\ngoal (1 subgoal):\n 1. eval_wellf f (y # xs) \\<down>= 0 \\<and>\n    (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)", "using that \\<open>?P z\\<close>"], ["proof (prove)\nusing this:\n  y < z\n  eval_wellf f (y # xs) \\<down>= 0\n  eval_wellf f (z # xs) \\<down>= 0 \\<and>\n  (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval_wellf f (y # xs) \\<down>= 0 \\<and>\n    (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)", "by simp"], ["proof (state)\nthis:\n  eval_wellf f (y # xs) \\<down>= 0 \\<and>\n  (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. \\<not> z \\<le> y \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  y < z\n  eval_wellf f (y # xs) \\<down>= 0 \\<and>\n  (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)", "show False"], ["proof (prove)\nusing this:\n  y < z\n  eval_wellf f (y # xs) \\<down>= 0 \\<and>\n  (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. False", "using that not_less_Least z_def"], ["proof (prove)\nusing this:\n  y < z\n  eval_wellf f (y # xs) \\<down>= 0 \\<and>\n  (\\<forall>ya<y. eval_wellf f (ya # xs) \\<down>)\n  eval_wellf f (y # xs) \\<down>= 0\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n  z =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_wellf f (?y # xs) \\<down>= 0 \\<Longrightarrow> z \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST z. eval_wellf f (z # xs) \\<down>= 0) = z\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "}"], ["proof (state)\nthis:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>) \\<Longrightarrow>\n  (LEAST z. eval_wellf f (z # xs) \\<down>= 0) =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "then"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>) \\<Longrightarrow>\n  (LEAST z. eval_wellf f (z # xs) \\<down>= 0) =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval_wellf f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval_wellf f (y # xs) \\<down>) \\<Longrightarrow>\n  (LEAST z. eval_wellf f (z # xs) \\<down>= 0) =\n  (LEAST z.\n      eval_wellf f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval_wellf f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval_wellf (Mn n f) xs =\n    (if \\<exists>z.\n           eval_wellf f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n     then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)", "by simp"], ["proof (state)\nthis:\n  eval_wellf (Mn n f) xs =\n  (if \\<exists>z.\n         eval_wellf f (z # xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval_wellf f (y # xs) \\<down>)\n   then Some (LEAST z. eval_wellf f (z # xs) \\<down>= 0) else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_Mn':\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"eval (Mn n f) xs =\n   (if (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\n    then Some (LEAST z. eval f (z # xs) \\<down>= 0)\n    else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z.\n           eval f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval f (y # xs) \\<down>)\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0) else None)", "using assms eval_def eval_wellf_Mn"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval ?f ?xs \\<equiv> eval_wellf ?f ?xs\n  eval_wellf (Mn ?n ?f) ?xs =\n  (if \\<exists>z.\n         eval_wellf ?f (z # ?xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval_wellf ?f (y # ?xs) \\<down>)\n   then Some (LEAST z. eval_wellf ?f (z # ?xs) \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z.\n           eval f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval f (y # xs) \\<down>)\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0) else None)", "by auto"], ["", "text \\<open>Proving that $\\mu$-recursion converges is easier if one does not\nhave to deal with @{text LEAST} directly.\\<close>"], ["", "lemma eval_Mn_convergI:\n  assumes \"recfn (length xs) (Mn n f)\"\n    and \"eval f (z # xs) \\<down>= 0\"\n    and \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\"\n  shows \"eval (Mn n f) xs \\<down>= z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "let ?P = \"\\<lambda>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "have \"z = Least ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))", "using Least_equality[of ?P z] assms(2,3) not_le_imp_less"], ["proof (prove)\nusing this:\n  \\<lbrakk>eval f (z # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<z. eval f (y # xs) \\<down>);\n   \\<And>y.\n      eval f (y # xs) \\<down>= 0 \\<and>\n      (\\<forall>ya<y. eval f (ya # xs) \\<down>) \\<Longrightarrow>\n      z \\<le> y\\<rbrakk>\n  \\<Longrightarrow> (LEAST z.\n                        eval f (z # xs) \\<down>= 0 \\<and>\n                        (\\<forall>y<z. eval f (y # xs) \\<down>)) =\n                    z\n  eval f (z # xs) \\<down>= 0\n  ?y < z \\<Longrightarrow> eval f (?y # xs) \\<down>\\<noteq> 0\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))", "by blast"], ["proof (state)\nthis:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "moreover"], ["proof (state)\nthis:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "have \"?P z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval f (y # xs) \\<down>)", "using assms(2,3)"], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0\n  ?y < z \\<Longrightarrow> eval f (?y # xs) \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval f (y # xs) \\<down>)", "by simp"], ["proof (state)\nthis:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "ultimately"], ["proof (chain)\npicking this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)", "show \"eval (Mn n f) xs \\<down>= z\""], ["proof (prove)\nusing this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "using eval_Mn[OF assms(1)]"], ["proof (prove)\nusing this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n  eval (Mn n f) xs =\n  (if \\<exists>z.\n         eval f (z # xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval f (y # xs) \\<down>)\n   then Some\n         (LEAST z.\n             eval f (z # xs) \\<down>= 0 \\<and>\n             (\\<forall>y<z. eval f (y # xs) \\<down>))\n   else None)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down>= z", "by meson"], ["proof (state)\nthis:\n  eval (Mn n f) xs \\<down>= z\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Similarly, reasoning from a $\\mu$-recursive function is\nsimplified somewhat by the next lemma.\\<close>"], ["", "lemma eval_Mn_convergE:\n  assumes \"recfn (length xs) (Mn n f)\" and \"eval (Mn n f) xs \\<down>= z\"\n  shows \"z = (LEAST z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>))\"\n    and \"eval f (z # xs) \\<down>= 0\"\n    and \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>)) &&&\n    eval f (z # xs) \\<down>= 0 &&&\n    (\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0)", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))\n 2. eval f (z # xs) \\<down>= 0\n 3. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "let ?P = \"\\<lambda>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\""], ["proof (state)\ngoal (3 subgoals):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))\n 2. eval f (z # xs) \\<down>= 0\n 3. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "show \"z = Least ?P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))", "using assms eval_Mn[OF assms(1)]"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  eval (Mn n f) xs \\<down>= z\n  eval (Mn n f) xs =\n  (if \\<exists>z.\n         eval f (z # xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval f (y # xs) \\<down>)\n   then Some\n         (LEAST z.\n             eval f (z # xs) \\<down>= 0 \\<and>\n             (\\<forall>y<z. eval f (y # xs) \\<down>))\n   else None)\n\ngoal (1 subgoal):\n 1. z =\n    (LEAST z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>))", "by (metis (no_types, lifting) option.inject option.simps(3))"], ["proof (state)\nthis:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n\ngoal (2 subgoals):\n 1. eval f (z # xs) \\<down>= 0\n 2. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n\ngoal (2 subgoals):\n 1. eval f (z # xs) \\<down>= 0\n 2. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "have \"\\<exists>z. ?P z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z.\n       eval f (z # xs) \\<down>= 0 \\<and>\n       (\\<forall>y<z. eval f (y # xs) \\<down>)", "using assms eval_Mn[OF assms(1)]"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  eval (Mn n f) xs \\<down>= z\n  eval (Mn n f) xs =\n  (if \\<exists>z.\n         eval f (z # xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval f (y # xs) \\<down>)\n   then Some\n         (LEAST z.\n             eval f (z # xs) \\<down>= 0 \\<and>\n             (\\<forall>y<z. eval f (y # xs) \\<down>))\n   else None)\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       eval f (z # xs) \\<down>= 0 \\<and>\n       (\\<forall>y<z. eval f (y # xs) \\<down>)", "by (metis option.distinct(1))"], ["proof (state)\nthis:\n  \\<exists>z.\n     eval f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (2 subgoals):\n 1. eval f (z # xs) \\<down>= 0\n 2. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  \\<exists>z.\n     eval f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval f (y # xs) \\<down>)", "have \"?P z\""], ["proof (prove)\nusing this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  \\<exists>z.\n     eval f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval f (y # xs) \\<down>)", "using LeastI[of ?P]"], ["proof (prove)\nusing this:\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  \\<exists>z.\n     eval f (z # xs) \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval f (y # xs) \\<down>)\n  eval f (?k # xs) \\<down>= 0 \\<and>\n  (\\<forall>y<?k. eval f (y # xs) \\<down>) \\<Longrightarrow>\n  eval f\n   ((LEAST x.\n        eval f (x # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<x. eval f (y # xs) \\<down>)) #\n    xs) \\<down>=\n  0 \\<and>\n  (\\<forall>y<LEAST x.\n                 eval f (x # xs) \\<down>= 0 \\<and>\n                 (\\<forall>y<x. eval f (y # xs) \\<down>).\n      eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval f (y # xs) \\<down>)", "by blast"], ["proof (state)\nthis:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (2 subgoals):\n 1. eval f (z # xs) \\<down>= 0\n 2. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)", "have \"eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\""], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 \\<and>\n    (\\<forall>y<z. eval f (y # xs) \\<down>)", "by simp"], ["proof (state)\nthis:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (2 subgoals):\n 1. eval f (z # xs) \\<down>= 0\n 2. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "then"], ["proof (chain)\npicking this:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)", "show \"eval f (z # xs) \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval f (z # xs) \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "show \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "using not_less_Least[of _ ?P] \\<open>z = Least ?P\\<close> \\<open>?P z\\<close> less_trans"], ["proof (prove)\nusing this:\n  ?k < (LEAST x.\n           eval f (x # xs) \\<down>= 0 \\<and>\n           (\\<forall>y<x. eval f (y # xs) \\<down>)) \\<Longrightarrow>\n  \\<not> (eval f (?k # xs) \\<down>= 0 \\<and>\n          (\\<forall>y<?k. eval f (y # xs) \\<down>))\n  z =\n  (LEAST z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>))\n  eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. \\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  ?y < z \\<Longrightarrow> eval f (?y # xs) \\<down>\\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_Mn_diverg:\n  assumes \"recfn (length xs) (Mn n f)\"\n  shows \"\\<not> (\\<exists>z. eval f (z # xs) \\<down>= 0 \\<and> (\\<forall>y<z. eval f (y # xs) \\<down>)) \\<longleftrightarrow> eval (Mn n f) xs \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>)) =\n    (eval (Mn n f) xs \\<up>)", "using assms eval_Mn[OF assms(1)]"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  eval (Mn n f) xs =\n  (if \\<exists>z.\n         eval f (z # xs) \\<down>= 0 \\<and>\n         (\\<forall>y<z. eval f (y # xs) \\<down>)\n   then Some\n         (LEAST z.\n             eval f (z # xs) \\<down>= 0 \\<and>\n             (\\<forall>y<z. eval f (y # xs) \\<down>))\n   else None)\n\ngoal (1 subgoal):\n 1. (\\<nexists>z.\n        eval f (z # xs) \\<down>= 0 \\<and>\n        (\\<forall>y<z. eval f (y # xs) \\<down>)) =\n    (eval (Mn n f) xs \\<up>)", "by simp"], ["", "subsection \\<open>Extensional equality\\<close>"], ["", "definition exteq :: \"recf \\<Rightarrow> recf \\<Rightarrow> bool\" (infix \"\\<simeq>\" 55) where\n  \"f \\<simeq> g \\<equiv> arity f = arity g \\<and> (\\<forall>xs. length xs = arity f \\<longrightarrow> eval f xs = eval g xs)\""], ["", "lemma exteq_refl: \"f \\<simeq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<simeq> f", "using exteq_def"], ["proof (prove)\nusing this:\n  ?f \\<simeq> ?g \\<equiv>\n  arity ?f = arity ?g \\<and>\n  (\\<forall>xs.\n      length xs = arity ?f \\<longrightarrow> eval ?f xs = eval ?g xs)\n\ngoal (1 subgoal):\n 1. f \\<simeq> f", "by simp"], ["", "lemma exteq_sym: \"f \\<simeq> g \\<Longrightarrow> g \\<simeq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<simeq> g \\<Longrightarrow> g \\<simeq> f", "using exteq_def"], ["proof (prove)\nusing this:\n  ?f \\<simeq> ?g \\<equiv>\n  arity ?f = arity ?g \\<and>\n  (\\<forall>xs.\n      length xs = arity ?f \\<longrightarrow> eval ?f xs = eval ?g xs)\n\ngoal (1 subgoal):\n 1. f \\<simeq> g \\<Longrightarrow> g \\<simeq> f", "by simp"], ["", "lemma exteq_trans: \"f \\<simeq> g \\<Longrightarrow> g \\<simeq> h \\<Longrightarrow> f \\<simeq> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<simeq> g; g \\<simeq> h\\<rbrakk>\n    \\<Longrightarrow> f \\<simeq> h", "using exteq_def"], ["proof (prove)\nusing this:\n  ?f \\<simeq> ?g \\<equiv>\n  arity ?f = arity ?g \\<and>\n  (\\<forall>xs.\n      length xs = arity ?f \\<longrightarrow> eval ?f xs = eval ?g xs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<simeq> g; g \\<simeq> h\\<rbrakk>\n    \\<Longrightarrow> f \\<simeq> h", "by simp"], ["", "lemma exteqI:\n  assumes \"arity f = arity g\" and \"\\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs = eval g xs\"\n  shows \"f \\<simeq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<simeq> g", "using assms exteq_def"], ["proof (prove)\nusing this:\n  arity f = arity g\n  length ?xs = arity f \\<Longrightarrow> eval f ?xs = eval g ?xs\n  ?f \\<simeq> ?g \\<equiv>\n  arity ?f = arity ?g \\<and>\n  (\\<forall>xs.\n      length xs = arity ?f \\<longrightarrow> eval ?f xs = eval ?g xs)\n\ngoal (1 subgoal):\n 1. f \\<simeq> g", "by simp"], ["", "lemma exteqI1:\n  assumes \"arity f = 1\" and \"arity g = 1\" and \"\\<And>x. eval f [x] = eval g [x]\"\n  shows \"f \\<simeq> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<simeq> g", "using assms exteqI"], ["proof (prove)\nusing this:\n  arity f = 1\n  arity g = 1\n  eval f [?x] = eval g [?x]\n  \\<lbrakk>arity ?f = arity ?g;\n   \\<And>xs.\n      length xs = arity ?f \\<Longrightarrow>\n      eval ?f xs = eval ?g xs\\<rbrakk>\n  \\<Longrightarrow> ?f \\<simeq> ?g\n\ngoal (1 subgoal):\n 1. f \\<simeq> g", "by (metis One_nat_def Suc_length_conv length_0_conv)"], ["", "text \\<open>For every partial recursive function @{term f} there are\ninfinitely many extensionally equal ones, for example, those that wrap @{term\nf} arbitrarily often in the identity function.\\<close>"], ["", "fun wrap_Id :: \"recf \\<Rightarrow> nat \\<Rightarrow> recf\" where\n  \"wrap_Id f 0 = f\"\n| \"wrap_Id f (Suc n) = Cn (arity f) (Id 1 0) [wrap_Id f n]\""], ["", "lemma recfn_wrap_Id: \"recfn a f \\<Longrightarrow> recfn a (wrap_Id f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> recfn a (wrap_Id f n)", "using wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> recfn a (wrap_Id f n)", "by (induction n) auto"], ["", "lemma exteq_wrap_Id: \"recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f 0\n 2. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "case 0"], ["proof (state)\nthis:\n  recfn a f\n\ngoal (2 subgoals):\n 1. recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f 0\n 2. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "then"], ["proof (chain)\npicking this:\n  recfn a f", "show ?case"], ["proof (prove)\nusing this:\n  recfn a f\n\ngoal (1 subgoal):\n 1. f \\<simeq> wrap_Id f 0", "by (simp add: exteq_refl)"], ["proof (state)\nthis:\n  f \\<simeq> wrap_Id f 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\n  recfn a f\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "have \"wrap_Id f n \\<simeq> wrap_Id f (Suc n) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. wrap_Id f n \\<simeq> wrap_Id f (Suc n)", "proof (rule exteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. arity (wrap_Id f n) = arity (wrap_Id f (Suc n))\n 2. \\<And>xs.\n       length xs = arity (wrap_Id f n) \\<Longrightarrow>\n       eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "show \"arity (wrap_Id f n) = arity (wrap_Id f (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity (wrap_Id f n) = arity (wrap_Id f (Suc n))", "using Suc"], ["proof (prove)\nusing this:\n  recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\n  recfn a f\n\ngoal (1 subgoal):\n 1. arity (wrap_Id f n) = arity (wrap_Id f (Suc n))", "by (simp add: recfn_wrap_Id)"], ["proof (state)\nthis:\n  arity (wrap_Id f n) = arity (wrap_Id f (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       length xs = arity (wrap_Id f n) \\<Longrightarrow>\n       eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "show \"eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs\"\n      if \"length xs = arity (wrap_Id f n)\" for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "have \"recfn (length xs) (Cn (arity f) (Id 1 0) [wrap_Id f n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn (arity f) (recf.Id 1 0) [wrap_Id f n])", "using that Suc recfn_wrap_Id"], ["proof (prove)\nusing this:\n  length xs = arity (wrap_Id f n)\n  recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\n  recfn a f\n  recfn ?a ?f \\<Longrightarrow> recfn ?a (wrap_Id ?f ?n)\n\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn (arity f) (recf.Id 1 0) [wrap_Id f n])", "by (metis wrap_Id.simps(2))"], ["proof (state)\nthis:\n  recfn (length xs) (Cn (arity f) (recf.Id 1 0) [wrap_Id f n])\n\ngoal (1 subgoal):\n 1. eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "then"], ["proof (chain)\npicking this:\n  recfn (length xs) (Cn (arity f) (recf.Id 1 0) [wrap_Id f n])", "show \"eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs\""], ["proof (prove)\nusing this:\n  recfn (length xs) (Cn (arity f) (recf.Id 1 0) [wrap_Id f n])\n\ngoal (1 subgoal):\n 1. eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs", "by auto"], ["proof (state)\nthis:\n  eval (wrap_Id f n) xs = eval (wrap_Id f (Suc n)) xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ?xs = arity (wrap_Id f n) \\<Longrightarrow>\n  eval (wrap_Id f n) ?xs = eval (wrap_Id f (Suc n)) ?xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wrap_Id f n \\<simeq> wrap_Id f (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n;\n        recfn a f\\<rbrakk>\n       \\<Longrightarrow> f \\<simeq> wrap_Id f (Suc n)", "then"], ["proof (chain)\npicking this:\n  wrap_Id f n \\<simeq> wrap_Id f (Suc n)", "show ?case"], ["proof (prove)\nusing this:\n  wrap_Id f n \\<simeq> wrap_Id f (Suc n)\n\ngoal (1 subgoal):\n 1. f \\<simeq> wrap_Id f (Suc n)", "using Suc exteq_trans"], ["proof (prove)\nusing this:\n  wrap_Id f n \\<simeq> wrap_Id f (Suc n)\n  recfn a f \\<Longrightarrow> f \\<simeq> wrap_Id f n\n  recfn a f\n  \\<lbrakk>?f \\<simeq> ?g; ?g \\<simeq> ?h\\<rbrakk>\n  \\<Longrightarrow> ?f \\<simeq> ?h\n\ngoal (1 subgoal):\n 1. f \\<simeq> wrap_Id f (Suc n)", "by fast"], ["proof (state)\nthis:\n  f \\<simeq> wrap_Id f (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun depth :: \"recf \\<Rightarrow> nat\" where\n  \"depth Z = 0\"\n| \"depth S = 0\"\n| \"depth (Id m n) = 0\"\n| \"depth (Cn n f gs) = Suc (max (depth f) (Max (set (map depth gs))))\"\n| \"depth (Pr n f g) = Suc (max (depth f) (depth g))\"\n| \"depth (Mn n f) = Suc (depth f)\""], ["", "lemma depth_wrap_Id: \"recfn a f \\<Longrightarrow> depth (wrap_Id f n) = depth f + n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> depth (wrap_Id f n) = depth f + n", "by (induction n) simp_all"], ["", "lemma wrap_Id_injective:\n  assumes \"recfn a f\" and \"wrap_Id f n\\<^sub>1 = wrap_Id f n\\<^sub>2\"\n  shows \"n\\<^sub>1 = n\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>1 = n\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  recfn a f\n  wrap_Id f n\\<^sub>1 = wrap_Id f n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 = n\\<^sub>2", "by (metis add_left_cancel depth_wrap_Id)"], ["", "lemma exteq_infinite:\n  assumes \"recfn a f\"\n  shows \"infinite {g. recfn a g \\<and> g \\<simeq> f}\" (is \"infinite ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "have \"inj (wrap_Id f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (wrap_Id f)", "using wrap_Id_injective \\<open>recfn a f\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn ?a ?f;\n   wrap_Id ?f ?n\\<^sub>1 = wrap_Id ?f ?n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> ?n\\<^sub>1 = ?n\\<^sub>2\n  recfn a f\n\ngoal (1 subgoal):\n 1. inj (wrap_Id f)", "by (meson inj_onI)"], ["proof (state)\nthis:\n  inj (wrap_Id f)\n\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "then"], ["proof (chain)\npicking this:\n  inj (wrap_Id f)", "have \"infinite (range (wrap_Id f))\""], ["proof (prove)\nusing this:\n  inj (wrap_Id f)\n\ngoal (1 subgoal):\n 1. infinite (range (wrap_Id f))", "using finite_imageD"], ["proof (prove)\nusing this:\n  inj (wrap_Id f)\n  \\<lbrakk>finite (?f ` ?A); inj_on ?f ?A\\<rbrakk>\n  \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. infinite (range (wrap_Id f))", "by blast"], ["proof (state)\nthis:\n  infinite (range (wrap_Id f))\n\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "moreover"], ["proof (state)\nthis:\n  infinite (range (wrap_Id f))\n\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "have \"range (wrap_Id f) \\<subseteq> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. range (wrap_Id f) \\<subseteq> {g. recfn a g \\<and> g \\<simeq> f}", "using assms exteq_sym exteq_wrap_Id recfn_wrap_Id"], ["proof (prove)\nusing this:\n  recfn a f\n  ?f \\<simeq> ?g \\<Longrightarrow> ?g \\<simeq> ?f\n  recfn ?a ?f \\<Longrightarrow> ?f \\<simeq> wrap_Id ?f ?n\n  recfn ?a ?f \\<Longrightarrow> recfn ?a (wrap_Id ?f ?n)\n\ngoal (1 subgoal):\n 1. range (wrap_Id f) \\<subseteq> {g. recfn a g \\<and> g \\<simeq> f}", "by blast"], ["proof (state)\nthis:\n  range (wrap_Id f) \\<subseteq> {g. recfn a g \\<and> g \\<simeq> f}\n\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "ultimately"], ["proof (chain)\npicking this:\n  infinite (range (wrap_Id f))\n  range (wrap_Id f) \\<subseteq> {g. recfn a g \\<and> g \\<simeq> f}", "show ?thesis"], ["proof (prove)\nusing this:\n  infinite (range (wrap_Id f))\n  range (wrap_Id f) \\<subseteq> {g. recfn a g \\<and> g \\<simeq> f}\n\ngoal (1 subgoal):\n 1. infinite {g. recfn a g \\<and> g \\<simeq> f}", "by (simp add: infinite_super)"], ["proof (state)\nthis:\n  infinite {g. recfn a g \\<and> g \\<simeq> f}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Primitive recursive and total functions\\<close>"], ["", "fun Mn_free :: \"recf \\<Rightarrow> bool\" where\n  \"Mn_free Z = True\"\n| \"Mn_free S = True\"\n| \"Mn_free (Id m n) = True\"\n| \"Mn_free (Cn n f gs) = ((\\<forall>g \\<in> set gs. Mn_free g) \\<and> Mn_free f)\"\n| \"Mn_free (Pr n f g) = (Mn_free f \\<and> Mn_free g)\"\n| \"Mn_free (Mn n f) = False\""], ["", "text \\<open>This is our notion of $n$-ary primitive recursive function:\\<close>"], ["", "abbreviation prim_recfn :: \"nat \\<Rightarrow> recf \\<Rightarrow> bool\" where\n  \"prim_recfn n f \\<equiv> recfn n f \\<and> Mn_free f\""], ["", "definition total :: \"recf \\<Rightarrow> bool\" where\n  \"total f \\<equiv> \\<forall>xs. length xs = arity f \\<longrightarrow> eval f xs \\<down>\""], ["", "lemma totalI [intro]:\n  assumes \"\\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "using assms total_def"], ["proof (prove)\nusing this:\n  length ?xs = arity f \\<Longrightarrow> eval f ?xs \\<down>\n  Partial_Recursive.total ?f \\<equiv>\n  \\<forall>xs. length xs = arity ?f \\<longrightarrow> eval ?f xs \\<down>\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "by simp"], ["", "lemma totalE [simp]:\n  assumes \"total f\" and \"recfn n f\" and \"length xs = n\"\n  shows \"eval f xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "using assms total_def"], ["proof (prove)\nusing this:\n  Partial_Recursive.total f\n  recfn n f\n  length xs = n\n  Partial_Recursive.total ?f \\<equiv>\n  \\<forall>xs. length xs = arity ?f \\<longrightarrow> eval ?f xs \\<down>\n\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "by simp"], ["", "lemma totalI1 :\n  assumes \"recfn 1 f\" and \"\\<And>x. eval f [x] \\<down>\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "using assms totalI[of f]"], ["proof (prove)\nusing this:\n  recfn 1 f\n  eval f [?x] \\<down>\n  (\\<And>xs.\n      length xs = arity f \\<Longrightarrow>\n      eval f xs \\<down>) \\<Longrightarrow>\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "by (metis One_nat_def length_0_conv length_Suc_conv)"], ["", "lemma totalI2:\n  assumes \"recfn 2 f\" and \"\\<And>x y. eval f [x, y] \\<down>\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "using assms totalI[of f]"], ["proof (prove)\nusing this:\n  recfn 2 f\n  eval f [?x, ?y] \\<down>\n  (\\<And>xs.\n      length xs = arity f \\<Longrightarrow>\n      eval f xs \\<down>) \\<Longrightarrow>\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "by (smt length_0_conv length_Suc_conv numeral_2_eq_2)"], ["", "lemma totalI3:\n  assumes \"recfn 3 f\" and \"\\<And>x y z. eval f [x, y, z] \\<down>\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "using assms totalI[of f]"], ["proof (prove)\nusing this:\n  recfn 3 f\n  eval f [?x, ?y, ?z] \\<down>\n  (\\<And>xs.\n      length xs = arity f \\<Longrightarrow>\n      eval f xs \\<down>) \\<Longrightarrow>\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "by (smt length_0_conv length_Suc_conv numeral_3_eq_3)"], ["", "lemma totalI4:\n  assumes \"recfn 4 f\" and \"\\<And>w x y z. eval f [w, x, y, z] \\<down>\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "proof (rule totalI[of f])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>", "fix xs :: \"nat list\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>", "assume \"length xs = arity f\""], ["proof (state)\nthis:\n  length xs = arity f\n\ngoal (1 subgoal):\n 1. \\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>", "then"], ["proof (chain)\npicking this:\n  length xs = arity f", "have \"length xs = Suc (Suc (Suc (Suc 0)))\""], ["proof (prove)\nusing this:\n  length xs = arity f\n\ngoal (1 subgoal):\n 1. length xs = Suc (Suc (Suc (Suc 0)))", "using assms(1)"], ["proof (prove)\nusing this:\n  length xs = arity f\n  recfn 4 f\n\ngoal (1 subgoal):\n 1. length xs = Suc (Suc (Suc (Suc 0)))", "by simp"], ["proof (state)\nthis:\n  length xs = Suc (Suc (Suc (Suc 0)))\n\ngoal (1 subgoal):\n 1. \\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>", "then"], ["proof (chain)\npicking this:\n  length xs = Suc (Suc (Suc (Suc 0)))", "obtain w x y z where \"xs = [w, x, y, z]\""], ["proof (prove)\nusing this:\n  length xs = Suc (Suc (Suc (Suc 0)))\n\ngoal (1 subgoal):\n 1. (\\<And>w x y z.\n        xs = [w, x, y, z] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt Suc_length_conv length_0_conv)"], ["proof (state)\nthis:\n  xs = [w, x, y, z]\n\ngoal (1 subgoal):\n 1. \\<And>xs. length xs = arity f \\<Longrightarrow> eval f xs \\<down>", "then"], ["proof (chain)\npicking this:\n  xs = [w, x, y, z]", "show \"eval f xs \\<down>\""], ["proof (prove)\nusing this:\n  xs = [w, x, y, z]\n\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "using assms(2)"], ["proof (prove)\nusing this:\n  xs = [w, x, y, z]\n  eval f [?w, ?x, ?y, ?z] \\<down>\n\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "by simp"], ["proof (state)\nthis:\n  eval f xs \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mn_free_imp_total [intro]:\n  assumes \"wellf f\" and \"Mn_free f\"\n  shows \"total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "using assms"], ["proof (prove)\nusing this:\n  wellf f\n  Mn_free f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "proof (induction f rule: Mn_free.induct)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<lbrakk>wellf Z; Mn_free Z\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total Z\n 2. \\<lbrakk>wellf S; Mn_free S\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total S\n 3. \\<And>m n.\n       \\<lbrakk>wellf (recf.Id m n); Mn_free (recf.Id m n)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (recf.Id m n)\n 4. \\<And>n f gs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set gs; wellf x; Mn_free x\\<rbrakk>\n                   \\<Longrightarrow> Partial_Recursive.total x;\n        \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total f;\n        wellf (Cn n f gs); Mn_free (Cn n f gs)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Cn n f gs)\n 5. \\<And>n f g.\n       \\<lbrakk>\\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n                \\<Longrightarrow> Partial_Recursive.total f;\n        \\<lbrakk>wellf g; Mn_free g\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total g;\n        wellf (Pr n f g); Mn_free (Pr n f g)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Pr n f g)\n 6. \\<And>n f.\n       \\<lbrakk>wellf (Mn n f); Mn_free (Mn n f)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Mn n f)", "case (5 n f g)"], ["proof (state)\nthis:\n  \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total f\n  \\<lbrakk>wellf g; Mn_free g\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total g\n  wellf (Pr n f g)\n  Mn_free (Pr n f g)\n\ngoal (6 subgoals):\n 1. \\<lbrakk>wellf Z; Mn_free Z\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total Z\n 2. \\<lbrakk>wellf S; Mn_free S\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total S\n 3. \\<And>m n.\n       \\<lbrakk>wellf (recf.Id m n); Mn_free (recf.Id m n)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (recf.Id m n)\n 4. \\<And>n f gs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set gs; wellf x; Mn_free x\\<rbrakk>\n                   \\<Longrightarrow> Partial_Recursive.total x;\n        \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total f;\n        wellf (Cn n f gs); Mn_free (Cn n f gs)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Cn n f gs)\n 5. \\<And>n f g.\n       \\<lbrakk>\\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n                \\<Longrightarrow> Partial_Recursive.total f;\n        \\<lbrakk>wellf g; Mn_free g\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total g;\n        wellf (Pr n f g); Mn_free (Pr n f g)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Pr n f g)\n 6. \\<And>n f.\n       \\<lbrakk>wellf (Mn n f); Mn_free (Mn n f)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Mn n f)", "have \"eval (Pr n f g) (x # xs) \\<down>\" if \"length (x # xs) = arity (Pr n f g)\" for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (x # xs) \\<down>", "using 5 that"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total f\n  \\<lbrakk>wellf g; Mn_free g\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total g\n  wellf (Pr n f g)\n  Mn_free (Pr n f g)\n  length (x # xs) = arity (Pr n f g)\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (x # xs) \\<down>", "by (induction x) auto"], ["proof (state)\nthis:\n  length (?x # ?xs) = arity (Pr n f g) \\<Longrightarrow>\n  eval (Pr n f g) (?x # ?xs) \\<down>\n\ngoal (6 subgoals):\n 1. \\<lbrakk>wellf Z; Mn_free Z\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total Z\n 2. \\<lbrakk>wellf S; Mn_free S\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total S\n 3. \\<And>m n.\n       \\<lbrakk>wellf (recf.Id m n); Mn_free (recf.Id m n)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (recf.Id m n)\n 4. \\<And>n f gs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set gs; wellf x; Mn_free x\\<rbrakk>\n                   \\<Longrightarrow> Partial_Recursive.total x;\n        \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total f;\n        wellf (Cn n f gs); Mn_free (Cn n f gs)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Cn n f gs)\n 5. \\<And>n f g.\n       \\<lbrakk>\\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n                \\<Longrightarrow> Partial_Recursive.total f;\n        \\<lbrakk>wellf g; Mn_free g\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total g;\n        wellf (Pr n f g); Mn_free (Pr n f g)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Pr n f g)\n 6. \\<And>n f.\n       \\<lbrakk>wellf (Mn n f); Mn_free (Mn n f)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Mn n f)", "then"], ["proof (chain)\npicking this:\n  length (?x # ?xs) = arity (Pr n f g) \\<Longrightarrow>\n  eval (Pr n f g) (?x # ?xs) \\<down>", "show ?case"], ["proof (prove)\nusing this:\n  length (?x # ?xs) = arity (Pr n f g) \\<Longrightarrow>\n  eval (Pr n f g) (?x # ?xs) \\<down>\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "by (metis arity.simps(5) length_Suc_conv totalI)"], ["proof (state)\nthis:\n  Partial_Recursive.total (Pr n f g)\n\ngoal (5 subgoals):\n 1. \\<lbrakk>wellf Z; Mn_free Z\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total Z\n 2. \\<lbrakk>wellf S; Mn_free S\\<rbrakk>\n    \\<Longrightarrow> Partial_Recursive.total S\n 3. \\<And>m n.\n       \\<lbrakk>wellf (recf.Id m n); Mn_free (recf.Id m n)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (recf.Id m n)\n 4. \\<And>n f gs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> set gs; wellf x; Mn_free x\\<rbrakk>\n                   \\<Longrightarrow> Partial_Recursive.total x;\n        \\<lbrakk>wellf f; Mn_free f\\<rbrakk>\n        \\<Longrightarrow> Partial_Recursive.total f;\n        wellf (Cn n f gs); Mn_free (Cn n f gs)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Cn n f gs)\n 5. \\<And>n f.\n       \\<lbrakk>wellf (Mn n f); Mn_free (Mn n f)\\<rbrakk>\n       \\<Longrightarrow> Partial_Recursive.total (Mn n f)", "qed (auto simp add: total_def eval_def)"], ["", "lemma prim_recfn_total: \"prim_recfn n f \\<Longrightarrow> total f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn n f \\<Longrightarrow> Partial_Recursive.total f", "using Mn_free_imp_total"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. prim_recfn n f \\<Longrightarrow> Partial_Recursive.total f", "by simp"], ["", "lemma eval_Pr_prim_Suc:\n  assumes \"h = Pr n f g\" and \"prim_recfn (Suc n) h\" and \"length xs = n\"\n  shows \"eval h (Suc x # xs) = eval g (x # the (eval h (x # xs)) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h (Suc x # xs) = eval g (x # the (eval h (x # xs)) # xs)", "using assms eval_Pr_converg_Suc prim_recfn_total"], ["proof (prove)\nusing this:\n  h = Pr n f g\n  prim_recfn (Suc n) h\n  length xs = n\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (Suc ?x # ?xs) =\n                    eval ?g (?x # the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs)\n  prim_recfn ?n ?f \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. eval h (Suc x # xs) = eval g (x # the (eval h (x # xs)) # xs)", "by simp"], ["", "lemma Cn_total:\n  assumes \"\\<forall>g\\<in>set gs. total g\" and \"total f\" and \"recfn n (Cn n f gs)\"\n  shows \"total (Cn n f gs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Cn n f gs)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set gs. Partial_Recursive.total g\n  Partial_Recursive.total f\n  recfn n (Cn n f gs)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Cn n f gs)", "by (simp add: totalI)"], ["", "lemma Pr_total:\n  assumes \"total f\" and \"total g\" and \"recfn (Suc n) (Pr n f g)\"\n  shows \"total (Pr n f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "have \"eval (Pr n f g) (x # xs) \\<down>\" if \"length xs = n\" for x xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (x # xs) \\<down>", "using that assms"], ["proof (prove)\nusing this:\n  length xs = n\n  Partial_Recursive.total f\n  Partial_Recursive.total g\n  recfn (Suc n) (Pr n f g)\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (x # xs) \\<down>", "by (induction x) auto"], ["proof (state)\nthis:\n  length ?xs = n \\<Longrightarrow> eval (Pr n f g) (?x # ?xs) \\<down>\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "then"], ["proof (chain)\npicking this:\n  length ?xs = n \\<Longrightarrow> eval (Pr n f g) (?x # ?xs) \\<down>", "show ?thesis"], ["proof (prove)\nusing this:\n  length ?xs = n \\<Longrightarrow> eval (Pr n f g) (?x # ?xs) \\<down>\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "using assms(3) totalI"], ["proof (prove)\nusing this:\n  length ?xs = n \\<Longrightarrow> eval (Pr n f g) (?x # ?xs) \\<down>\n  recfn (Suc n) (Pr n f g)\n  (\\<And>xs.\n      length xs = arity ?f \\<Longrightarrow>\n      eval ?f xs \\<down>) \\<Longrightarrow>\n  Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Pr n f g)", "by (metis Suc_length_conv arity.simps(5))"], ["proof (state)\nthis:\n  Partial_Recursive.total (Pr n f g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_Mn_total:\n  assumes \"recfn (length xs) (Mn n f)\" and \"total f\"\n  shows \"eval (Mn n f) xs =\n    (if (\\<exists>z. eval f (z # xs) \\<down>= 0)\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0)\n     else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z. eval f (z # xs) \\<down>= 0\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0) else None)", "using assms"], ["proof (prove)\nusing this:\n  recfn (length xs) (Mn n f)\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs =\n    (if \\<exists>z. eval f (z # xs) \\<down>= 0\n     then Some (LEAST z. eval f (z # xs) \\<down>= 0) else None)", "by auto"], ["", "section \\<open>Simple functions\\<close>"], ["", "text \\<open>This section, too, bears some similarity to Urban's formalization\nin Xu et~al.~\\cite{Universal_Turing_Machine-AFP}, but is more minimalistic in\nscope.\n\nAs a general naming rule, instances of @{typ recf} and functions\nreturning such instances get names starting with @{text r_}. Typically, for\nan @{text r_xyz} there will be a lemma @{text r_xyz_recfn} or @{text\nr_xyz_prim} establishing its (primitive) recursiveness, arity, and\nwell-formedness. Moreover there will be a lemma @{text r_xyz} describing its\nsemantics, for which we will sometimes introduce an Isabelle function @{text\nxyz}.\\<close>"], ["", "subsection \\<open>Manipulating parameters\\<close>"], ["", "text \\<open>Appending dummy parameters:\\<close>"], ["", "definition r_dummy :: \"nat \\<Rightarrow> recf \\<Rightarrow> recf\" where\n  \"r_dummy n f \\<equiv> Cn (arity f + n) f (map (\\<lambda>i. Id (arity f + n) i) [0..<arity f])\""], ["", "lemma r_dummy_prim [simp]:\n  \"prim_recfn a f \\<Longrightarrow> prim_recfn (a + n) (r_dummy n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn a f \\<Longrightarrow> prim_recfn (a + n) (r_dummy n f)", "using wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. prim_recfn a f \\<Longrightarrow> prim_recfn (a + n) (r_dummy n f)", "by (auto simp add: r_dummy_def)"], ["", "lemma r_dummy_recfn [simp]:\n  \"recfn a f \\<Longrightarrow> recfn (a + n) (r_dummy n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> recfn (a + n) (r_dummy n f)", "using wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> recfn (a + n) (r_dummy n f)", "by (auto simp add: r_dummy_def)"], ["", "lemma r_dummy [simp]:\n  \"r_dummy n f = Cn (arity f + n) f (map (\\<lambda>i. Id (arity f + n) i) [0..<arity f])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_dummy n f =\n    Cn (arity f + n) f (map (recf.Id (arity f + n)) [0..<arity f])", "unfolding r_dummy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn (arity f + n) f (map (recf.Id (arity f + n)) [0..<arity f]) =\n    Cn (arity f + n) f (map (recf.Id (arity f + n)) [0..<arity f])", "by simp"], ["", "lemma r_dummy_append:\n  assumes \"recfn (length xs) f\" and \"length ys = n\"\n  shows \"eval (r_dummy n f) (xs @ ys) = eval f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "let ?r = \"r_dummy n f\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "let ?gs = \"map (\\<lambda>i. Id (arity f + n) i) [0..<arity f]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "have \"length ?gs = arity f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (map (recf.Id (arity f + n)) [0..<arity f]) = arity f", "by simp"], ["proof (state)\nthis:\n  length (map (recf.Id (arity f + n)) [0..<arity f]) = arity f\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "moreover"], ["proof (state)\nthis:\n  length (map (recf.Id (arity f + n)) [0..<arity f]) = arity f\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "have \"?gs ! i = (Id (arity f + n) i)\" if \"i < arity f\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (recf.Id (arity f + n)) [0..<arity f] ! i = recf.Id (arity f + n) i", "by (simp add: that)"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  map (recf.Id (arity f + n)) [0..<arity f] ! ?i = recf.Id (arity f + n) ?i\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "moreover"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  map (recf.Id (arity f + n)) [0..<arity f] ! ?i = recf.Id (arity f + n) ?i\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "have *: \"eval_wellf (?gs ! i) (xs @ ys) \\<down>= xs ! i\" if \"i < arity f\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! i)\n     (xs @ ys) \\<down>=\n    xs ! i", "using that assms"], ["proof (prove)\nusing this:\n  i < arity f\n  recfn (length xs) f\n  length ys = n\n\ngoal (1 subgoal):\n 1. eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! i)\n     (xs @ ys) \\<down>=\n    xs ! i", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! ?i)\n   (xs @ ys) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "ultimately"], ["proof (chain)\npicking this:\n  length (map (recf.Id (arity f + n)) [0..<arity f]) = arity f\n  ?i < arity f \\<Longrightarrow>\n  map (recf.Id (arity f + n)) [0..<arity f] ! ?i = recf.Id (arity f + n) ?i\n  ?i < arity f \\<Longrightarrow>\n  eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! ?i)\n   (xs @ ys) \\<down>=\n  xs ! ?i", "have \"map (\\<lambda>g. the (eval_wellf g (xs @ ys))) ?gs = xs\""], ["proof (prove)\nusing this:\n  length (map (recf.Id (arity f + n)) [0..<arity f]) = arity f\n  ?i < arity f \\<Longrightarrow>\n  map (recf.Id (arity f + n)) [0..<arity f] ! ?i = recf.Id (arity f + n) ?i\n  ?i < arity f \\<Longrightarrow>\n  eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! ?i)\n   (xs @ ys) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval_wellf g (xs @ ys)))\n     (map (recf.Id (arity f + n)) [0..<arity f]) =\n    xs", "by (metis (no_types, lifting) assms(1) length_map nth_equalityI nth_map option.sel)"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval_wellf g (xs @ ys)))\n   (map (recf.Id (arity f + n)) [0..<arity f]) =\n  xs\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval_wellf g (xs @ ys)))\n   (map (recf.Id (arity f + n)) [0..<arity f]) =\n  xs\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "have \"\\<forall>g \\<in> set ?gs. eval_wellf g (xs @ ys) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n       eval_wellf g (xs @ ys) \\<down>", "using *"], ["proof (prove)\nusing this:\n  ?i < arity f \\<Longrightarrow>\n  eval_wellf (map (recf.Id (arity f + n)) [0..<arity f] ! ?i)\n   (xs @ ys) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n       eval_wellf g (xs @ ys) \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n     eval_wellf g (xs @ ys) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "moreover"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n     eval_wellf g (xs @ ys) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "have \"recfn (length (xs @ ys)) ?r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length (xs @ ys)) (r_dummy n f)", "using assms r_dummy_recfn"], ["proof (prove)\nusing this:\n  recfn (length xs) f\n  length ys = n\n  recfn ?a ?f \\<Longrightarrow> recfn (?a + ?n) (r_dummy ?n ?f)\n\ngoal (1 subgoal):\n 1. recfn (length (xs @ ys)) (r_dummy n f)", "by fastforce"], ["proof (state)\nthis:\n  recfn (length (xs @ ys)) (r_dummy n f)\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. the (eval_wellf g (xs @ ys)))\n   (map (recf.Id (arity f + n)) [0..<arity f]) =\n  xs\n  \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n     eval_wellf g (xs @ ys) \\<down>\n  recfn (length (xs @ ys)) (r_dummy n f)", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. the (eval_wellf g (xs @ ys)))\n   (map (recf.Id (arity f + n)) [0..<arity f]) =\n  xs\n  \\<forall>g\\<in>set (map (recf.Id (arity f + n)) [0..<arity f]).\n     eval_wellf g (xs @ ys) \\<down>\n  recfn (length (xs @ ys)) (r_dummy n f)\n\ngoal (1 subgoal):\n 1. eval (r_dummy n f) (xs @ ys) = eval f xs", "by (auto simp add: assms eval_def)"], ["proof (state)\nthis:\n  eval (r_dummy n f) (xs @ ys) = eval f xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Shrinking a binary function to a unary one is useful when we want\nto define a unary function via the @{term Pr} operation, which can only\nconstruct @{typ recf}s of arity two or higher.\\<close>"], ["", "definition r_shrink :: \"recf \\<Rightarrow> recf\" where\n  \"r_shrink f \\<equiv> Cn 1 f [Id 1 0, Id 1 0]\""], ["", "lemma r_shrink_prim [simp]: \"prim_recfn 2 f \\<Longrightarrow> prim_recfn 1 (r_shrink f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 f \\<Longrightarrow> prim_recfn 1 (r_shrink f)", "by (simp add: r_shrink_def)"], ["", "lemma r_shrink_recfn [simp]: \"recfn 2 f \\<Longrightarrow> recfn 1 (r_shrink f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 f \\<Longrightarrow> recfn 1 (r_shrink f)", "by (simp add: r_shrink_def)"], ["", "lemma r_shrink [simp]: \"recfn 2 f \\<Longrightarrow> eval (r_shrink f) [x] = eval f [x, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 f \\<Longrightarrow> eval (r_shrink f) [x] = eval f [x, x]", "by (simp add: r_shrink_def)"], ["", "definition r_swap :: \"recf \\<Rightarrow> recf\" where\n  \"r_swap f \\<equiv> Cn 2 f [Id 2 1, Id 2 0]\""], ["", "lemma r_swap_recfn [simp]: \"recfn 2 f \\<Longrightarrow> recfn 2 (r_swap f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 f \\<Longrightarrow> recfn 2 (r_swap f)", "by (simp add: r_swap_def)"], ["", "lemma r_swap_prim [simp]: \"prim_recfn 2 f \\<Longrightarrow> prim_recfn 2 (r_swap f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 f \\<Longrightarrow> prim_recfn 2 (r_swap f)", "by (simp add: r_swap_def)"], ["", "lemma r_swap [simp]: \"recfn 2 f \\<Longrightarrow> eval (r_swap f) [x, y] = eval f [y, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 f \\<Longrightarrow> eval (r_swap f) [x, y] = eval f [y, x]", "by (simp add: r_swap_def)"], ["", "text \\<open>Prepending one dummy parameter:\\<close>"], ["", "definition r_shift :: \"recf \\<Rightarrow> recf\" where\n  \"r_shift f \\<equiv> Cn (Suc (arity f)) f (map (\\<lambda>i. Id (Suc (arity f)) (Suc i)) [0..<arity f])\""], ["", "lemma r_shift_prim [simp]: \"prim_recfn a f \\<Longrightarrow> prim_recfn (Suc a) (r_shift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn a f \\<Longrightarrow> prim_recfn (Suc a) (r_shift f)", "by (simp add: r_shift_def)"], ["", "lemma r_shift_recfn [simp]: \"recfn a f \\<Longrightarrow> recfn (Suc a) (r_shift f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn a f \\<Longrightarrow> recfn (Suc a) (r_shift f)", "by (simp add: r_shift_def)"], ["", "lemma r_shift [simp]:\n  assumes \"recfn (length xs) f\"\n  shows \"eval (r_shift f) (x # xs) = eval f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "let ?r = \"r_shift f\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "let ?gs = \"map (\\<lambda>i. Id (Suc (arity f)) (Suc i)) [0..<arity f]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "have \"length ?gs = arity f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n    arity f", "by simp"], ["proof (state)\nthis:\n  length (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  arity f\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "moreover"], ["proof (state)\nthis:\n  length (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  arity f\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "have \"?gs ! i = (Id (Suc (arity f)) (Suc i))\" if \"i < arity f\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! i =\n    recf.Id (Suc (arity f)) (Suc i)", "by (simp add: that)"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i =\n  recf.Id (Suc (arity f)) (Suc ?i)\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "moreover"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i =\n  recf.Id (Suc (arity f)) (Suc ?i)\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "have *: \"eval (?gs ! i) (x # xs) \\<down>= xs ! i\" if \"i < arity f\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! i)\n     (x # xs) \\<down>=\n    xs ! i", "using assms nth_append that"], ["proof (prove)\nusing this:\n  recfn (length xs) f\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n  i < arity f\n\ngoal (1 subgoal):\n 1. eval\n     (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! i)\n     (x # xs) \\<down>=\n    xs ! i", "by simp"], ["proof (state)\nthis:\n  ?i < arity f \\<Longrightarrow>\n  eval\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i)\n   (x # xs) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "ultimately"], ["proof (chain)\npicking this:\n  length (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  arity f\n  ?i < arity f \\<Longrightarrow>\n  map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i =\n  recf.Id (Suc (arity f)) (Suc ?i)\n  ?i < arity f \\<Longrightarrow>\n  eval\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i)\n   (x # xs) \\<down>=\n  xs ! ?i", "have \"map (\\<lambda>g. the (eval g (x # xs))) ?gs = xs\""], ["proof (prove)\nusing this:\n  length (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  arity f\n  ?i < arity f \\<Longrightarrow>\n  map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i =\n  recf.Id (Suc (arity f)) (Suc ?i)\n  ?i < arity f \\<Longrightarrow>\n  eval\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i)\n   (x # xs) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g (x # xs)))\n     (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n    xs", "by (metis (no_types, lifting) assms length_map nth_equalityI nth_map option.sel)"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g (x # xs)))\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  xs\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g (x # xs)))\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  xs\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "have \"\\<forall>g \\<in> set ?gs. eval g (x # xs) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                         [0..<arity f]).\n       eval g (x # xs) \\<down>", "using *"], ["proof (prove)\nusing this:\n  ?i < arity f \\<Longrightarrow>\n  eval\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f] ! ?i)\n   (x # xs) \\<down>=\n  xs ! ?i\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                         [0..<arity f]).\n       eval g (x # xs) \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                       [0..<arity f]).\n     eval g (x # xs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. the (eval g (x # xs)))\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  xs\n  \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                       [0..<arity f]).\n     eval g (x # xs) \\<down>", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. the (eval g (x # xs)))\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  xs\n  \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                       [0..<arity f]).\n     eval g (x # xs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "using r_shift_def assms"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. the (eval g (x # xs)))\n   (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i)) [0..<arity f]) =\n  xs\n  \\<forall>g\\<in>set (map (\\<lambda>i. recf.Id (Suc (arity f)) (Suc i))\n                       [0..<arity f]).\n     eval g (x # xs) \\<down>\n  r_shift ?f \\<equiv>\n  Cn (Suc (arity ?f)) ?f\n   (map (\\<lambda>i. recf.Id (Suc (arity ?f)) (Suc i)) [0..<arity ?f])\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. eval (r_shift f) (x # xs) = eval f xs", "by simp"], ["proof (state)\nthis:\n  eval (r_shift f) (x # xs) = eval f xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Arithmetic and logic\\<close>"], ["", "text \\<open>The unary constants:\\<close>"], ["", "fun r_const :: \"nat \\<Rightarrow> recf\" where\n  \"r_const 0 = Z\"\n| \"r_const (Suc c) = Cn 1 S [r_const c]\""], ["", "lemma r_const_prim [simp]: \"prim_recfn 1 (r_const c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_const c)", "by (induction c) (simp_all)"], ["", "lemma r_const [simp]: \"eval (r_const c) [x] \\<down>= c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_const c) [x] \\<down>= c", "by (induction c) simp_all"], ["", "text \\<open>Constants of higher arities:\\<close>"], ["", "definition \"r_constn n c \\<equiv> if n = 0 then r_const c else r_dummy n (r_const c)\""], ["", "lemma r_constn_prim [simp]: \"prim_recfn (Suc n) (r_constn n c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn (Suc n) (r_constn n c)", "unfolding r_constn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn (Suc n) (if n = 0 then r_const c else r_dummy n (r_const c))", "by simp"], ["", "lemma r_constn [simp]: \"length xs = Suc n \\<Longrightarrow> eval (r_constn n c) xs \\<down>= c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc n \\<Longrightarrow> eval (r_constn n c) xs \\<down>= c", "unfolding r_constn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = Suc n \\<Longrightarrow>\n    eval (if n = 0 then r_const c else r_dummy n (r_const c)) xs \\<down>= c", "by simp (metis length_0_conv length_Suc_conv r_const)"], ["", "text \\<open>We introduce addition, subtraction, and multiplication, but\ninterestingly enough we can make do without division.\\<close>"], ["", "definition \"r_add \\<equiv> Pr 1 (Id 1 0) (Cn 3 S [Id 3 1])\""], ["", "lemma r_add_prim [simp]: \"prim_recfn 2 r_add\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_add", "by (simp add: r_add_def)"], ["", "lemma r_add [simp]: \"eval r_add [a, b] \\<down>= a + b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_add [a, b] \\<down>= a + b", "unfolding r_add_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 S [recf.Id 3 1])) [a, b] \\<down>= a + b", "by (induction a) simp_all"], ["", "definition \"r_mul \\<equiv> Pr 1 Z (Cn 3 r_add [Id 3 1, Id 3 2])\""], ["", "lemma r_mul_prim [simp]: \"prim_recfn 2 r_mul\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_mul", "unfolding r_mul_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Pr 1 Z (Cn 3 r_add [recf.Id 3 1, recf.Id 3 2]))", "by simp"], ["", "lemma r_mul [simp]: \"eval r_mul [a, b] \\<down>= a * b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_mul [a, b] \\<down>= a * b", "unfolding r_mul_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z (Cn 3 r_add [recf.Id 3 1, recf.Id 3 2])) [a, b] \\<down>=\n    a * b", "by (induction a) simp_all"], ["", "definition \"r_dec \\<equiv> Cn 1 (Pr 1 Z (Id 3 0)) [Id 1 0, Id 1 0]\""], ["", "lemma r_dec_prim [simp]: \"prim_recfn 1 r_dec\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_dec", "by (simp add: r_dec_def)"], ["", "lemma r_dec [simp]: \"eval r_dec [a] \\<down>= a - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dec [a] \\<down>= a - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_dec [a] \\<down>= a - 1", "have \"eval (Pr 1 Z (Id 3 0)) [x, y] \\<down>= x - 1\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z (recf.Id 3 0)) [x, y] \\<down>= x - 1", "by (induction x) simp_all"], ["proof (state)\nthis:\n  eval (Pr 1 Z (recf.Id 3 0)) [?x, ?y] \\<down>= ?x - 1\n\ngoal (1 subgoal):\n 1. eval r_dec [a] \\<down>= a - 1", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z (recf.Id 3 0)) [?x, ?y] \\<down>= ?x - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z (recf.Id 3 0)) [?x, ?y] \\<down>= ?x - 1\n\ngoal (1 subgoal):\n 1. eval r_dec [a] \\<down>= a - 1", "by (simp add: r_dec_def)"], ["proof (state)\nthis:\n  eval r_dec [a] \\<down>= a - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_sub \\<equiv> r_swap (Pr 1 (Id 1 0) (Cn 3 r_dec [Id 3 1]))\""], ["", "lemma r_sub_prim [simp]: \"prim_recfn 2 r_sub\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_sub", "unfolding r_sub_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (r_swap (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])))", "by simp"], ["", "lemma r_sub [simp]: \"eval r_sub [a, b] \\<down>= a - b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_sub [a, b] \\<down>= a - b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_sub [a, b] \\<down>= a - b", "have \"eval (Pr 1 (Id 1 0) (Cn 3 r_dec [Id 3 1])) [x, y] \\<down>= y - x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])) [x, y] \\<down>=\n    y - x", "by (induction x) simp_all"], ["proof (state)\nthis:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])) [?x, ?y] \\<down>=\n  ?y - ?x\n\ngoal (1 subgoal):\n 1. eval r_sub [a, b] \\<down>= a - b", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])) [?x, ?y] \\<down>=\n  ?y - ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])) [?x, ?y] \\<down>=\n  ?y - ?x\n\ngoal (1 subgoal):\n 1. eval r_sub [a, b] \\<down>= a - b", "unfolding r_sub_def"], ["proof (prove)\nusing this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])) [?x, ?y] \\<down>=\n  ?y - ?x\n\ngoal (1 subgoal):\n 1. eval (r_swap (Pr 1 (recf.Id 1 0) (Cn 3 r_dec [recf.Id 3 1])))\n     [a, b] \\<down>=\n    a - b", "by simp"], ["proof (state)\nthis:\n  eval r_sub [a, b] \\<down>= a - b\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_sign \\<equiv> r_shrink (Pr 1 Z (r_constn 2 1))\""], ["", "lemma r_sign_prim [simp]: \"prim_recfn 1 r_sign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_sign", "unfolding r_sign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_shrink (Pr 1 Z (r_constn 2 1)))", "by simp"], ["", "lemma r_sign [simp]: \"eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)", "have \"eval (Pr 1 Z (r_constn 2 1)) [x, y] \\<down>= (if x = 0 then 0 else 1)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z (r_constn 2 1)) [x, y] \\<down>= (if x = 0 then 0 else 1)", "by (induction x) simp_all"], ["proof (state)\nthis:\n  eval (Pr 1 Z (r_constn 2 1)) [?x, ?y] \\<down>= (if ?x = 0 then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z (r_constn 2 1)) [?x, ?y] \\<down>= (if ?x = 0 then 0 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z (r_constn 2 1)) [?x, ?y] \\<down>= (if ?x = 0 then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)", "unfolding r_sign_def"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z (r_constn 2 1)) [?x, ?y] \\<down>= (if ?x = 0 then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval (r_shrink (Pr 1 Z (r_constn 2 1))) [x] \\<down>=\n    (if x = 0 then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  eval r_sign [x] \\<down>= (if x = 0 then 0 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the logical functions, true will be represented by zero, and\nfalse will be represented by non-zero as argument and by one as\nresult.\\<close>"], ["", "definition \"r_not \\<equiv> Cn 1 r_sub [r_const 1, r_sign]\""], ["", "lemma r_not_prim [simp]: \"prim_recfn 1 r_not\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_not", "unfolding r_not_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_sub [r_const 1, r_sign])", "by simp"], ["", "lemma r_not [simp]: \"eval r_not [x] \\<down>= (if x = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_not [x] \\<down>= (if x = 0 then 1 else 0)", "unfolding r_not_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_sub [r_const 1, r_sign]) [x] \\<down>=\n    (if x = 0 then 1 else 0)", "by simp"], ["", "definition \"r_nand \\<equiv> Cn 2 r_not [r_add]\""], ["", "lemma r_nand_prim [simp]: \"prim_recfn 2 r_nand\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_nand", "unfolding r_nand_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_not [r_add])", "by simp"], ["", "lemma r_nand [simp]: \"eval r_nand [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nand [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 1 else 0)", "unfolding r_nand_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_not [r_add]) [x, y] \\<down>=\n    (if x = 0 \\<and> y = 0 then 1 else 0)", "by simp"], ["", "definition \"r_and \\<equiv> Cn 2 r_not [r_nand]\""], ["", "lemma r_and_prim [simp]: \"prim_recfn 2 r_and\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_and", "unfolding r_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_not [r_nand])", "by simp"], ["", "lemma r_and [simp]: \"eval r_and [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_and [x, y] \\<down>= (if x = 0 \\<and> y = 0 then 0 else 1)", "unfolding r_and_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_not [r_nand]) [x, y] \\<down>=\n    (if x = 0 \\<and> y = 0 then 0 else 1)", "by simp"], ["", "definition \"r_or \\<equiv> Cn 2 r_sign [r_mul]\""], ["", "lemma r_or_prim [simp]: \"prim_recfn 2 r_or\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_or", "unfolding r_or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_sign [r_mul])", "by simp"], ["", "lemma r_or [simp]: \"eval r_or [x, y] \\<down>= (if x = 0 \\<or> y = 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_or [x, y] \\<down>= (if x = 0 \\<or> y = 0 then 0 else 1)", "unfolding r_or_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_sign [r_mul]) [x, y] \\<down>=\n    (if x = 0 \\<or> y = 0 then 0 else 1)", "by simp"], ["", "subsection \\<open>Comparison and conditions\\<close>"], ["", "definition \"r_ifz \\<equiv>\n  let ifzero = (Cn 3 r_mul [r_dummy 2 r_not, Id 3 1]);\n      ifnzero = (Cn 3 r_mul [r_dummy 2 r_sign, Id 3 2])\n  in Cn 3 r_add [ifzero, ifnzero]\""], ["", "lemma r_ifz_prim [simp]: \"prim_recfn 3 r_ifz\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_ifz", "unfolding r_ifz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (let ifzero = Cn 3 r_mul [r_dummy 2 r_not, recf.Id 3 1];\n          ifnzero = Cn 3 r_mul [r_dummy 2 r_sign, recf.Id 3 2]\n      in Cn 3 r_add [ifzero, ifnzero])", "by simp"], ["", "lemma r_ifz [simp]: \"eval r_ifz [cond, val0, val1] \\<down>= (if cond = 0 then val0 else val1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifz [cond, val0, val1] \\<down>= (if cond = 0 then val0 else val1)", "unfolding r_ifz_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (let ifzero = Cn 3 r_mul [r_dummy 2 r_not, recf.Id 3 1];\n          ifnzero = Cn 3 r_mul [r_dummy 2 r_sign, recf.Id 3 2]\n      in Cn 3 r_add [ifzero, ifnzero])\n     [cond, val0, val1] \\<down>=\n    (if cond = 0 then val0 else val1)", "by (simp add: Let_def)"], ["", "definition \"r_eq \\<equiv> Cn 2 r_sign [Cn 2 r_add [r_sub, r_swap r_sub]]\""], ["", "lemma r_eq_prim [simp]: \"prim_recfn 2 r_eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_eq", "unfolding r_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_sign [Cn 2 r_add [r_sub, r_swap r_sub]])", "by simp"], ["", "lemma r_eq [simp]: \"eval r_eq [x, y] \\<down>= (if x = y then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_eq [x, y] \\<down>= (if x = y then 0 else 1)", "unfolding r_eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_sign [Cn 2 r_add [r_sub, r_swap r_sub]]) [x, y] \\<down>=\n    (if x = y then 0 else 1)", "by simp"], ["", "definition \"r_ifeq \\<equiv> Cn 4 r_ifz [r_dummy 2 r_eq, Id 4 2, Id 4 3]\""], ["", "lemma r_ifeq_prim [simp]: \"prim_recfn 4 r_ifeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 r_ifeq", "unfolding r_ifeq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 (Cn 4 r_ifz [r_dummy 2 r_eq, recf.Id 4 2, recf.Id 4 3])", "by simp"], ["", "lemma r_ifeq [simp]: \"eval r_ifeq [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a = b then v\\<^sub>0 else v\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifeq [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a = b then v\\<^sub>0 else v\\<^sub>1)", "unfolding r_ifeq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [r_dummy 2 r_eq, recf.Id 4 2, recf.Id 4 3])\n     [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a = b then v\\<^sub>0 else v\\<^sub>1)", "using r_dummy_append[of r_eq \"[a, b]\" \"[v\\<^sub>0, v\\<^sub>1]\" 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn (length [a, b]) r_eq;\n   length [v\\<^sub>0, v\\<^sub>1] = 2\\<rbrakk>\n  \\<Longrightarrow> eval (r_dummy 2 r_eq)\n                     ([a, b] @ [v\\<^sub>0, v\\<^sub>1]) =\n                    eval r_eq [a, b]\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [r_dummy 2 r_eq, recf.Id 4 2, recf.Id 4 3])\n     [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a = b then v\\<^sub>0 else v\\<^sub>1)", "by simp"], ["", "definition \"r_neq \\<equiv> Cn 2 r_not [r_eq]\""], ["", "lemma r_neq_prim [simp]: \"prim_recfn 2 r_neq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_neq", "unfolding r_neq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_not [r_eq])", "by simp"], ["", "lemma r_neq [simp]: \"eval r_neq [x, y] \\<down>= (if x = y then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_neq [x, y] \\<down>= (if x = y then 1 else 0)", "unfolding r_neq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_not [r_eq]) [x, y] \\<down>= (if x = y then 1 else 0)", "by simp"], ["", "definition \"r_ifle \\<equiv> Cn 4 r_ifz [r_dummy 2 r_sub, Id 4 2, Id 4 3]\""], ["", "lemma r_ifle_prim [simp]: \"prim_recfn 4 r_ifle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 r_ifle", "unfolding r_ifle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 (Cn 4 r_ifz [r_dummy 2 r_sub, recf.Id 4 2, recf.Id 4 3])", "by simp"], ["", "lemma r_ifle [simp]: \"eval r_ifle [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a \\<le> b then v\\<^sub>0 else v\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifle [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a \\<le> b then v\\<^sub>0 else v\\<^sub>1)", "unfolding r_ifle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [r_dummy 2 r_sub, recf.Id 4 2, recf.Id 4 3])\n     [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a \\<le> b then v\\<^sub>0 else v\\<^sub>1)", "using r_dummy_append[of r_sub \"[a, b]\" \"[v\\<^sub>0, v\\<^sub>1]\" 2]"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn (length [a, b]) r_sub;\n   length [v\\<^sub>0, v\\<^sub>1] = 2\\<rbrakk>\n  \\<Longrightarrow> eval (r_dummy 2 r_sub)\n                     ([a, b] @ [v\\<^sub>0, v\\<^sub>1]) =\n                    eval r_sub [a, b]\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [r_dummy 2 r_sub, recf.Id 4 2, recf.Id 4 3])\n     [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a \\<le> b then v\\<^sub>0 else v\\<^sub>1)", "by simp"], ["", "definition \"r_ifless \\<equiv> Cn 4 r_ifle [Id 4 1, Id 4 0, Id 4 3, Id 4 2]\""], ["", "lemma r_ifless_prim [simp]: \"prim_recfn 4 r_ifless\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 r_ifless", "unfolding r_ifless_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4\n     (Cn 4 r_ifle [recf.Id 4 1, recf.Id 4 0, recf.Id 4 3, recf.Id 4 2])", "by simp"], ["", "lemma r_ifless [simp]: \"eval r_ifless [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>= (if a < b then v\\<^sub>0 else v\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifless [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a < b then v\\<^sub>0 else v\\<^sub>1)", "unfolding r_ifless_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifle [recf.Id 4 1, recf.Id 4 0, recf.Id 4 3, recf.Id 4 2])\n     [a, b, v\\<^sub>0, v\\<^sub>1] \\<down>=\n    (if a < b then v\\<^sub>0 else v\\<^sub>1)", "by simp"], ["", "definition \"r_less \\<equiv> Cn 2 r_ifle [Id 2 1, Id 2 0, r_constn 1 1, r_constn 1 0]\""], ["", "lemma r_less_prim [simp]: \"prim_recfn 2 r_less\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_less", "unfolding r_less_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifle [recf.Id 2 1, recf.Id 2 0, r_constn 1 1, r_constn 1 0])", "by simp"], ["", "lemma r_less [simp]: \"eval r_less [x, y] \\<down>= (if x < y then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_less [x, y] \\<down>= (if x < y then 0 else 1)", "unfolding r_less_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifle [recf.Id 2 1, recf.Id 2 0, r_constn 1 1, r_constn 1 0])\n     [x, y] \\<down>=\n    (if x < y then 0 else 1)", "by simp"], ["", "definition \"r_le \\<equiv> Cn 2 r_ifle [Id 2 0, Id 2 1, r_constn 1 0, r_constn 1 1]\""], ["", "lemma r_le_prim [simp]: \"prim_recfn 2 r_le\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_le", "unfolding r_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifle [recf.Id 2 0, recf.Id 2 1, r_constn 1 0, r_constn 1 1])", "by simp"], ["", "lemma r_le [simp]: \"eval r_le [x, y] \\<down>= (if x \\<le> y then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_le [x, y] \\<down>= (if x \\<le> y then 0 else 1)", "unfolding r_le_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifle [recf.Id 2 0, recf.Id 2 1, r_constn 1 0, r_constn 1 1])\n     [x, y] \\<down>=\n    (if x \\<le> y then 0 else 1)", "by simp"], ["", "text \\<open>Arguments are evaluated eagerly. Therefore @{term \"r_ifz\"}, etc.\ncannot be combined with a diverging function to implement a conditionally\ndiverging function in the naive way. The following function implements a\nspecial case needed in the next section. A \\hyperlink{p:r_lifz}{general lazy\nversion} of @{term \"r_ifz\"} will be introduced later with the help of a\nuniversal function.\\<close>"], ["", "definition \"r_ifeq_else_diverg \\<equiv>\n  Cn 3 r_add [Id 3 2, Mn 3 (Cn 4 r_add [Id 4 0, Cn 4 r_eq [Id 4 1, Id 4 2]])]\""], ["", "lemma r_ifeq_else_diverg_recfn [simp]: \"recfn 3 r_ifeq_else_diverg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_ifeq_else_diverg", "unfolding r_ifeq_else_diverg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_add\n       [recf.Id 3 2,\n        Mn 3\n         (Cn 4 r_add [recf.Id 4 0, Cn 4 r_eq [recf.Id 4 1, recf.Id 4 2]])])", "by simp"], ["", "lemma r_ifeq_else_diverg [simp]:\n  \"eval r_ifeq_else_diverg [a, b, v] = (if a = b then Some v else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifeq_else_diverg [a, b, v] = (if a = b then Some v else None)", "unfolding r_ifeq_else_diverg_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_add\n       [recf.Id 3 2,\n        Mn 3\n         (Cn 4 r_add [recf.Id 4 0, Cn 4 r_eq [recf.Id 4 1, recf.Id 4 2]])])\n     [a, b, v] =\n    (if a = b then Some v else None)", "by simp"], ["", "section \\<open>The halting problem\\label{s:halting}\\<close>"], ["", "text \\<open>Decidability will be treated more thoroughly in\nSection~\\ref{s:decidable}. But the halting problem is prominent enough to\ndeserve an early mention.\\<close>"], ["", "definition decidable :: \"nat set \\<Rightarrow> bool\" where\n  \"decidable X \\<equiv> \\<exists>f. recfn 1 f \\<and> (\\<forall>x. eval f [x] \\<down>= (if x \\<in> X then 1 else 0))\""], ["", "text \\<open>No matter how partial recursive functions are encoded as natural\nnumbers, the set of all codes of functions halting on their own code is\nundecidable.\\<close>"], ["", "theorem halting_problem_undecidable:\n  fixes code :: \"nat \\<Rightarrow> recf\"\n  assumes \"\\<And>f. recfn 1 f \\<Longrightarrow> \\<exists>i. code i = f\"\n  shows \"\\<not> decidable {x. eval (code x) [x] \\<down>}\" (is \"\\<not> decidable ?K\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> decidable {x. eval (code x) [x] \\<down>}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "assume \"decidable ?K\""], ["proof (state)\nthis:\n  decidable {x. eval (code x) [x] \\<down>}\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  decidable {x. eval (code x) [x] \\<down>}", "obtain f where \"recfn 1 f\" and f: \"\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?K then 1 else 0)\""], ["proof (prove)\nusing this:\n  decidable {x. eval (code x) [x] \\<down>}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>=\n            (if x \\<in> {x. eval (code x) [x] \\<down>} then 1\n             else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decidable_def"], ["proof (prove)\nusing this:\n  decidable {x. eval (code x) [x] \\<down>}\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>=\n            (if x \\<in> {x. eval (code x) [x] \\<down>} then 1\n             else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x.\n     eval f [x] \\<down>=\n     (if x \\<in> {x. eval (code x) [x] \\<down>} then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "define g where \"g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\""], ["proof (state)\nthis:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. recfn 1 g", "using \\<open>recfn 1 f\\<close> r_ifeq_else_diverg_recfn"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n  recfn 1 f\n  recfn 3 r_ifeq_else_diverg\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by simp"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  recfn 1 ?f \\<Longrightarrow> \\<exists>i. code i = ?f\n  recfn 1 g", "obtain i where i: \"code i = g\""], ["proof (prove)\nusing this:\n  recfn 1 ?f \\<Longrightarrow> \\<exists>i. code i = ?f\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. (\\<And>i. code i = g \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  code i = g\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "from g_def"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]", "have \"eval g [x] = (if x \\<notin> ?K then Some 0 else None)\" for x"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. eval g [x] =\n    (if x \\<notin> {x. eval (code x) [x] \\<down>} then Some 0 else None)", "using r_ifeq_else_diverg_recfn \\<open>recfn 1 f\\<close> f"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n  recfn 3 r_ifeq_else_diverg\n  recfn 1 f\n  \\<forall>x.\n     eval f [x] \\<down>=\n     (if x \\<in> {x. eval (code x) [x] \\<down>} then 1 else 0)\n\ngoal (1 subgoal):\n 1. eval g [x] =\n    (if x \\<notin> {x. eval (code x) [x] \\<down>} then Some 0 else None)", "by simp"], ["proof (state)\nthis:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval (code x) [x] \\<down>} then Some 0 else None)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval (code x) [x] \\<down>} then Some 0 else None)", "have \"eval g [i] \\<down> \\<longleftrightarrow> i \\<notin> ?K\""], ["proof (prove)\nusing this:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval (code x) [x] \\<down>} then Some 0 else None)\n\ngoal (1 subgoal):\n 1. (eval g [i] \\<down>) = (i \\<notin> {x. eval (code x) [x] \\<down>})", "by simp"], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (i \\<notin> {x. eval (code x) [x] \\<down>})\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (i \\<notin> {x. eval (code x) [x] \\<down>})\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "have \"... \\<longleftrightarrow> eval (code i) [i] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<notin> {x. eval (code x) [x] \\<down>}) = (eval (code i) [i] \\<up>)", "by simp"], ["proof (state)\nthis:\n  (i \\<notin> {x. eval (code x) [x] \\<down>}) = (eval (code i) [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (i \\<notin> {x. eval (code x) [x] \\<down>}) = (eval (code i) [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "have \"... \\<longleftrightarrow> eval g [i] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval (code i) [i] \\<up>) = (eval g [i] \\<up>)", "using i"], ["proof (prove)\nusing this:\n  code i = g\n\ngoal (1 subgoal):\n 1. (eval (code i) [i] \\<up>) = (eval g [i] \\<up>)", "by simp"], ["proof (state)\nthis:\n  (eval (code i) [i] \\<up>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)", "have \"eval g [i] \\<down> \\<longleftrightarrow> eval g [i] \\<up>\""], ["proof (prove)\nusing this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. (eval g [i] \\<down>) = (eval g [i] \\<up>)", "."], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval (code x) [x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)", "show False"], ["proof (prove)\nusing this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Encoding tuples and lists\\<close>"], ["", "text \\<open>This section is based on the Cantor encoding for pairs. Tuples\nare encoded by repeated application of the pairing function, lists by pairing\ntheir length with the code for a tuple. Thus tuples have a fixed length that\nmust be known when decoding, whereas lists are dynamically sized and know\ntheir current length.\\<close>"], ["", "subsection \\<open>Pairs and tuples\\<close>"], ["", "subsubsection \\<open>The Cantor pairing function\\<close>"], ["", "definition \"r_triangle \\<equiv> r_shrink (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add])))\""], ["", "lemma r_triangle_prim: \"prim_recfn 1 r_triangle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_triangle", "unfolding r_triangle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_shrink (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))))", "by simp"], ["", "lemma r_triangle: \"eval r_triangle [n] \\<down>= Sum {0..n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "let ?r = \"r_dummy 1 (Cn 2 S [r_add])\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "have \"eval ?r [x, y, z] \\<down>= Suc (x + y)\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_dummy 1 (Cn 2 S [r_add])) [x, y, z] \\<down>= Suc (x + y)", "using r_dummy_append[of \"Cn 2 S [r_add]\" \"[x, y]\" \"[z]\" 1]"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn (length [x, y]) (Cn 2 S [r_add]); length [z] = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_dummy 1 (Cn 2 S [r_add])) ([x, y] @ [z]) =\n                    eval (Cn 2 S [r_add]) [x, y]\n\ngoal (1 subgoal):\n 1. eval (r_dummy 1 (Cn 2 S [r_add])) [x, y, z] \\<down>= Suc (x + y)", "by simp"], ["proof (state)\nthis:\n  eval (r_dummy 1 (Cn 2 S [r_add])) [?x, ?y, ?z] \\<down>= Suc (?x + ?y)\n\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "then"], ["proof (chain)\npicking this:\n  eval (r_dummy 1 (Cn 2 S [r_add])) [?x, ?y, ?z] \\<down>= Suc (?x + ?y)", "have \"eval (Pr 1 Z ?r) [x, y] \\<down>= Sum {0..x}\" for x y"], ["proof (prove)\nusing this:\n  eval (r_dummy 1 (Cn 2 S [r_add])) [?x, ?y, ?z] \\<down>= Suc (?x + ?y)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))) [x, y] \\<down>= \\<Sum> {0..x}", "by (induction x) simp_all"], ["proof (state)\nthis:\n  eval (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))) [?x, ?y] \\<down>=\n  \\<Sum> {0..?x}\n\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))) [?x, ?y] \\<down>=\n  \\<Sum> {0..?x}", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))) [?x, ?y] \\<down>=\n  \\<Sum> {0..?x}\n\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= \\<Sum> {0..n}", "unfolding r_triangle_def"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add]))) [?x, ?y] \\<down>=\n  \\<Sum> {0..?x}\n\ngoal (1 subgoal):\n 1. eval (r_shrink (Pr 1 Z (r_dummy 1 (Cn 2 S [r_add])))) [n] \\<down>=\n    \\<Sum> {0..n}", "by simp"], ["proof (state)\nthis:\n  eval r_triangle [n] \\<down>= \\<Sum> {0..n}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_triangle_eq_triangle [simp]: \"eval r_triangle [n] \\<down>= triangle n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= triangle n", "using r_triangle gauss_sum_nat triangle_def"], ["proof (prove)\nusing this:\n  eval r_triangle [?n] \\<down>= \\<Sum> {0..?n}\n  \\<Sum> {0..?n} = ?n * Suc ?n div 2\n  triangle ?n = ?n * Suc ?n div 2\n\ngoal (1 subgoal):\n 1. eval r_triangle [n] \\<down>= triangle n", "by simp"], ["", "definition \"r_prod_encode \\<equiv> Cn 2 r_add [Cn 2 r_triangle [r_add], Id 2 0]\""], ["", "lemma r_prod_encode_prim [simp]: \"prim_recfn 2 r_prod_encode\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_prod_encode", "unfolding r_prod_encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_add [Cn 2 r_triangle [r_add], recf.Id 2 0])", "using r_triangle_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. prim_recfn 2 (Cn 2 r_add [Cn 2 r_triangle [r_add], recf.Id 2 0])", "by simp"], ["", "lemma r_prod_encode [simp]: \"eval r_prod_encode [m, n] \\<down>= prod_encode (m, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_prod_encode [m, n] \\<down>= prod_encode (m, n)", "unfolding r_prod_encode_def prod_encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_add [Cn 2 r_triangle [r_add], recf.Id 2 0]) [m, n] \\<down>=\n    (case (m, n) of (m, n) \\<Rightarrow> triangle (m + n) + m)", "using r_triangle_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_add [Cn 2 r_triangle [r_add], recf.Id 2 0]) [m, n] \\<down>=\n    (case (m, n) of (m, n) \\<Rightarrow> triangle (m + n) + m)", "by simp"], ["", "text \\<open>These abbreviations are just two more things borrowed from\nXu~et~al.~\\cite{Universal_Turing_Machine-AFP}.\\<close>"], ["", "abbreviation \"pdec1 z \\<equiv> fst (prod_decode z)\""], ["", "abbreviation \"pdec2 z \\<equiv> snd (prod_decode z)\""], ["", "lemma pdec1_le: \"pdec1 i \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 i \\<le> i", "by (metis le_prod_encode_1 prod.collapse prod_decode_inverse)"], ["", "lemma pdec2_le: \"pdec2 i \\<le> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 i \\<le> i", "by (metis le_prod_encode_2 prod.collapse prod_decode_inverse)"], ["", "lemma pdec_less: \"pdec2 i < Suc i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 i < Suc i", "using pdec2_le"], ["proof (prove)\nusing this:\n  pdec2 ?i \\<le> ?i\n\ngoal (1 subgoal):\n 1. pdec2 i < Suc i", "by (simp add: le_imp_less_Suc)"], ["", "lemma pdec1_zero: \"pdec1 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 0 = 0", "using pdec1_le"], ["proof (prove)\nusing this:\n  pdec1 ?i \\<le> ?i\n\ngoal (1 subgoal):\n 1. pdec1 0 = 0", "by auto"], ["", "definition \"r_maxletr \\<equiv>\n  Pr 1 Z (Cn 3 r_ifle [r_dummy 2 (Cn 1 r_triangle [S]), Id 3 2, Cn 3 S [Id 3 0], Id 3 1])\""], ["", "lemma r_maxletr_prim: \"prim_recfn 2 r_maxletr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_maxletr", "unfolding r_maxletr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))", "using r_triangle_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))", "by simp"], ["", "lemma not_Suc_Greatest_not_Suc:\n  assumes \"\\<not> P (Suc x)\" and \"\\<exists>x. P x\"\n  shows \"(GREATEST y. y \\<le> x \\<and> P y) = (GREATEST y. y \\<le> Suc x \\<and> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST y. y \\<le> x \\<and> P y) =\n    (GREATEST y. y \\<le> Suc x \\<and> P y)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> P (Suc x)\n  \\<exists>x. P x\n\ngoal (1 subgoal):\n 1. (GREATEST y. y \\<le> x \\<and> P y) =\n    (GREATEST y. y \\<le> Suc x \\<and> P y)", "by (metis le_SucI le_Suc_eq)"], ["", "lemma r_maxletr: \"eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>= (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "let ?g = \"Cn 3 r_ifle [r_dummy 2 (Cn 1 r_triangle [S]), Id 3 2, Cn 3 S [Id 3 0], Id 3 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "have greatest:\n    \"(if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0 else (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)) =\n     (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\"\n    for x\\<^sub>0 x\\<^sub>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "proof (cases \"triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n 2. \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "case True"], ["proof (state)\nthis:\n  triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n\ngoal (2 subgoals):\n 1. triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n 2. \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n\ngoal (1 subgoal):\n 1. (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "using Greatest_equality[of \"\\<lambda>y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1\"]"], ["proof (prove)\nusing this:\n  triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n  \\<lbrakk>?x \\<le> Suc x\\<^sub>0 \\<and> triangle ?x \\<le> x\\<^sub>1;\n   \\<And>y.\n      y \\<le> Suc x\\<^sub>0 \\<and>\n      triangle y \\<le> x\\<^sub>1 \\<Longrightarrow>\n      y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> (GREATEST y.\n                        y \\<le> Suc x\\<^sub>0 \\<and>\n                        triangle y \\<le> x\\<^sub>1) =\n                    ?x\n\ngoal (1 subgoal):\n 1. (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "by fastforce"], ["proof (state)\nthis:\n  (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n   else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n  (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "case False"], ["proof (state)\nthis:\n  \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 \\<Longrightarrow>\n    (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n\ngoal (1 subgoal):\n 1. (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "using not_Suc_Greatest_not_Suc[of \"\\<lambda>y. triangle y \\<le> x\\<^sub>1\" x\\<^sub>0]"], ["proof (prove)\nusing this:\n  \\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1\n  \\<lbrakk>\\<not> triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1;\n   \\<exists>x. triangle x \\<le> x\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> (GREATEST y.\n                        y \\<le> x\\<^sub>0 \\<and>\n                        triangle y \\<le> x\\<^sub>1) =\n                    (GREATEST y.\n                        y \\<le> Suc x\\<^sub>0 \\<and>\n                        triangle y \\<le> x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n     else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "by fastforce"], ["proof (state)\nthis:\n  (if triangle (Suc x\\<^sub>0) \\<le> x\\<^sub>1 then Suc x\\<^sub>0\n   else GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1) =\n  (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if triangle (Suc ?x\\<^sub>0) \\<le> ?x\\<^sub>1 then Suc ?x\\<^sub>0\n   else GREATEST y. y \\<le> ?x\\<^sub>0 \\<and> triangle y \\<le> ?x\\<^sub>1) =\n  (GREATEST y. y \\<le> Suc ?x\\<^sub>0 \\<and> triangle y \\<le> ?x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "unfolding r_maxletr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "using r_triangle_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "proof (induction x\\<^sub>0)"], ["proof (state)\ngoal (2 subgoals):\n 1. prim_recfn 1 r_triangle \\<Longrightarrow>\n    eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1)\n 2. \\<And>x\\<^sub>0.\n       \\<lbrakk>prim_recfn 1 r_triangle \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_ifle\n                     [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                      Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                 [x\\<^sub>0, x\\<^sub>1] \\<down>=\n                (GREATEST y.\n                    y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1);\n        prim_recfn 1 r_triangle\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_ifle\n                              [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                               Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                          [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n                         (GREATEST y.\n                             y \\<le> Suc x\\<^sub>0 \\<and>\n                             triangle y \\<le> x\\<^sub>1)", "case 0"], ["proof (state)\nthis:\n  prim_recfn 1 r_triangle\n\ngoal (2 subgoals):\n 1. prim_recfn 1 r_triangle \\<Longrightarrow>\n    eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1)\n 2. \\<And>x\\<^sub>0.\n       \\<lbrakk>prim_recfn 1 r_triangle \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_ifle\n                     [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                      Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                 [x\\<^sub>0, x\\<^sub>1] \\<down>=\n                (GREATEST y.\n                    y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1);\n        prim_recfn 1 r_triangle\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_ifle\n                              [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                               Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                          [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n                         (GREATEST y.\n                             y \\<le> Suc x\\<^sub>0 \\<and>\n                             triangle y \\<le> x\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  prim_recfn 1 r_triangle", "show ?case"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1)", "using Greatest_equality[of \"\\<lambda>y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1\" 0]"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n  \\<lbrakk>0 \\<le> 0 \\<and> triangle 0 \\<le> x\\<^sub>1;\n   \\<And>y.\n      y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1 \\<Longrightarrow>\n      y \\<le> 0\\<rbrakk>\n  \\<Longrightarrow> (GREATEST y.\n                        y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1) =\n                    0\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> 0 \\<and> triangle y \\<le> x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       \\<lbrakk>prim_recfn 1 r_triangle \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_ifle\n                     [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                      Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                 [x\\<^sub>0, x\\<^sub>1] \\<down>=\n                (GREATEST y.\n                    y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1);\n        prim_recfn 1 r_triangle\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_ifle\n                              [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                               Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                          [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n                         (GREATEST y.\n                             y \\<le> Suc x\\<^sub>0 \\<and>\n                             triangle y \\<le> x\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       \\<lbrakk>prim_recfn 1 r_triangle \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_ifle\n                     [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                      Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                 [x\\<^sub>0, x\\<^sub>1] \\<down>=\n                (GREATEST y.\n                    y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1);\n        prim_recfn 1 r_triangle\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_ifle\n                              [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                               Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                          [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n                         (GREATEST y.\n                             y \\<le> Suc x\\<^sub>0 \\<and>\n                             triangle y \\<le> x\\<^sub>1)", "case (Suc x\\<^sub>0)"], ["proof (state)\nthis:\n  prim_recfn 1 r_triangle \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. \\<And>x\\<^sub>0.\n       \\<lbrakk>prim_recfn 1 r_triangle \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_ifle\n                     [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                      Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                 [x\\<^sub>0, x\\<^sub>1] \\<down>=\n                (GREATEST y.\n                    y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1);\n        prim_recfn 1 r_triangle\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_ifle\n                              [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n                               Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n                          [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n                         (GREATEST y.\n                             y \\<le> Suc x\\<^sub>0 \\<and>\n                             triangle y \\<le> x\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  prim_recfn 1 r_triangle \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n  prim_recfn 1 r_triangle", "show ?case"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n  prim_recfn 1 r_triangle\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "using greatest"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n  prim_recfn 1 r_triangle\n  (if triangle (Suc ?x\\<^sub>0) \\<le> ?x\\<^sub>1 then Suc ?x\\<^sub>0\n   else GREATEST y. y \\<le> ?x\\<^sub>0 \\<and> triangle y \\<le> ?x\\<^sub>1) =\n  (GREATEST y. y \\<le> Suc ?x\\<^sub>0 \\<and> triangle y \\<le> ?x\\<^sub>1)\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_ifle\n         [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2,\n          Cn 3 S [recf.Id 3 0], recf.Id 3 1]))\n     [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n    (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_ifle\n       [r_dummy 2 (Cn 1 r_triangle [S]), recf.Id 3 2, Cn 3 S [recf.Id 3 0],\n        recf.Id 3 1]))\n   [Suc x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> Suc x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_maxletr [x\\<^sub>0, x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> x\\<^sub>0 \\<and> triangle y \\<le> x\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_maxlt \\<equiv> r_shrink r_maxletr\""], ["", "lemma r_maxlt_prim: \"prim_recfn 1 r_maxlt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_maxlt", "unfolding r_maxlt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_shrink r_maxletr)", "using r_maxletr_prim"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_maxletr\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_shrink r_maxletr)", "by simp"], ["", "lemma r_maxlt: \"eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "have \"y \\<le> triangle y\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> triangle y", "by (induction y) auto"], ["proof (state)\nthis:\n  ?y \\<le> triangle ?y\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "then"], ["proof (chain)\npicking this:\n  ?y \\<le> triangle ?y", "have \"triangle y \\<le> e \\<Longrightarrow> y \\<le> e\" for y e"], ["proof (prove)\nusing this:\n  ?y \\<le> triangle ?y\n\ngoal (1 subgoal):\n 1. triangle y \\<le> e \\<Longrightarrow> y \\<le> e", "using order_trans"], ["proof (prove)\nusing this:\n  ?y \\<le> triangle ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. triangle y \\<le> e \\<Longrightarrow> y \\<le> e", "by blast"], ["proof (state)\nthis:\n  triangle ?y \\<le> ?e \\<Longrightarrow> ?y \\<le> ?e\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "then"], ["proof (chain)\npicking this:\n  triangle ?y \\<le> ?e \\<Longrightarrow> ?y \\<le> ?e", "have \"(GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) = (GREATEST y. triangle y \\<le> e)\""], ["proof (prove)\nusing this:\n  triangle ?y \\<le> ?e \\<Longrightarrow> ?y \\<le> ?e\n\ngoal (1 subgoal):\n 1. (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) =\n    (GREATEST y. triangle y \\<le> e)", "by metis"], ["proof (state)\nthis:\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) =\n  (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "moreover"], ["proof (state)\nthis:\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) =\n  (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "have \"eval r_maxlt [e] \\<down>= (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>=\n    (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)", "using r_maxletr r_shrink r_maxlt_def r_maxletr_prim"], ["proof (prove)\nusing this:\n  eval r_maxletr [?x\\<^sub>0, ?x\\<^sub>1] \\<down>=\n  (GREATEST y. y \\<le> ?x\\<^sub>0 \\<and> triangle y \\<le> ?x\\<^sub>1)\n  recfn 2 ?f \\<Longrightarrow> eval (r_shrink ?f) [?x] = eval ?f [?x, ?x]\n  r_maxlt \\<equiv> r_shrink r_maxletr\n  prim_recfn 2 r_maxletr\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>=\n    (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)", "by fastforce"], ["proof (state)\nthis:\n  eval r_maxlt [e] \\<down>=\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "ultimately"], ["proof (chain)\npicking this:\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) =\n  (GREATEST y. triangle y \\<le> e)\n  eval r_maxlt [e] \\<down>=\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)", "show ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e) =\n  (GREATEST y. triangle y \\<le> e)\n  eval r_maxlt [e] \\<down>=\n  (GREATEST y. y \\<le> e \\<and> triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)", "by simp"], ["proof (state)\nthis:\n  eval r_maxlt [e] \\<down>= (GREATEST y. triangle y \\<le> e)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"pdec1' e \\<equiv> e - triangle (GREATEST y. triangle y \\<le> e)\""], ["", "definition \"pdec2' e \\<equiv> (GREATEST y. triangle y \\<le> e) - pdec1' e\""], ["", "lemma max_triangle_bound: \"triangle z \\<le> e \\<Longrightarrow> z \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triangle z \\<le> e \\<Longrightarrow> z \\<le> e", "by (metis Suc_pred add_leD2 less_Suc_eq triangle_Suc zero_le zero_less_Suc)"], ["", "lemma triangle_greatest_le: \"triangle (GREATEST y. triangle y \\<le> e) \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. triangle (GREATEST y. triangle y \\<le> e) \\<le> e", "using max_triangle_bound GreatestI_nat[of \"\\<lambda>y. triangle y \\<le> e\" 0 e]"], ["proof (prove)\nusing this:\n  triangle ?z \\<le> ?e \\<Longrightarrow> ?z \\<le> ?e\n  \\<lbrakk>triangle 0 \\<le> e;\n   \\<And>y. triangle y \\<le> e \\<Longrightarrow> y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> triangle (GREATEST y. triangle y \\<le> e) \\<le> e\n\ngoal (1 subgoal):\n 1. triangle (GREATEST y. triangle y \\<le> e) \\<le> e", "by simp"], ["", "lemma prod_encode_pdec': \"prod_encode (pdec1' e, pdec2' e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "let ?P = \"\\<lambda>y. triangle y \\<le> e\""], ["proof (state)\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "let ?y = \"GREATEST y. ?P y\""], ["proof (state)\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "have \"pdec1' e \\<le> ?y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "assume \"\\<not> pdec1' e \\<le> ?y\""], ["proof (state)\nthis:\n  \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)", "have \"e - triangle ?y > ?y\""], ["proof (prove)\nusing this:\n  \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. (GREATEST y. triangle y \\<le> e)\n    < e - triangle (GREATEST y. triangle y \\<le> e)", "using pdec1'_def"], ["proof (prove)\nusing this:\n  \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n  pdec1' ?e \\<equiv> ?e - triangle (GREATEST y. triangle y \\<le> ?e)\n\ngoal (1 subgoal):\n 1. (GREATEST y. triangle y \\<le> e)\n    < e - triangle (GREATEST y. triangle y \\<le> e)", "by simp"], ["proof (state)\nthis:\n  (GREATEST y. triangle y \\<le> e)\n  < e - triangle (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (GREATEST y. triangle y \\<le> e)\n  < e - triangle (GREATEST y. triangle y \\<le> e)", "have \"?P (Suc ?y)\""], ["proof (prove)\nusing this:\n  (GREATEST y. triangle y \\<le> e)\n  < e - triangle (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e", "by simp"], ["proof (state)\nthis:\n  triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "have \"\\<forall>z. ?P z \\<longrightarrow> z \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e", "using max_triangle_bound"], ["proof (prove)\nusing this:\n  triangle ?z \\<le> ?e \\<Longrightarrow> ?z \\<le> ?e\n\ngoal (1 subgoal):\n 1. \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e", "by simp"], ["proof (state)\nthis:\n  \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e\n  \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e", "have \"Suc ?y \\<le> ?y\""], ["proof (prove)\nusing this:\n  triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e\n  \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e\n\ngoal (1 subgoal):\n 1. Suc (GREATEST y. triangle y \\<le> e)\n    \\<le> (GREATEST y. triangle y \\<le> e)", "using Greatest_le_nat[of ?P \"Suc ?y\" e]"], ["proof (prove)\nusing this:\n  triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e\n  \\<forall>z. triangle z \\<le> e \\<longrightarrow> z \\<le> e\n  \\<lbrakk>triangle (Suc (GREATEST y. triangle y \\<le> e)) \\<le> e;\n   \\<And>y. triangle y \\<le> e \\<Longrightarrow> y \\<le> e\\<rbrakk>\n  \\<Longrightarrow> Suc (GREATEST y. triangle y \\<le> e)\n                    \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. Suc (GREATEST y. triangle y \\<le> e)\n    \\<le> (GREATEST y. triangle y \\<le> e)", "by blast"], ["proof (state)\nthis:\n  Suc (GREATEST y. triangle y \\<le> e)\n  \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. \\<not> pdec1' e \\<le> (GREATEST y. triangle y \\<le> e) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  Suc (GREATEST y. triangle y \\<le> e)\n  \\<le> (GREATEST y. triangle y \\<le> e)", "show False"], ["proof (prove)\nusing this:\n  Suc (GREATEST y. triangle y \\<le> e)\n  \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "then"], ["proof (chain)\npicking this:\n  pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)", "have \"pdec1' e + pdec2' e = ?y\""], ["proof (prove)\nusing this:\n  pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. pdec1' e + pdec2' e = (GREATEST y. triangle y \\<le> e)", "using pdec1'_def pdec2'_def"], ["proof (prove)\nusing this:\n  pdec1' e \\<le> (GREATEST y. triangle y \\<le> e)\n  pdec1' ?e \\<equiv> ?e - triangle (GREATEST y. triangle y \\<le> ?e)\n  pdec2' ?e \\<equiv> (GREATEST y. triangle y \\<le> ?e) - pdec1' ?e\n\ngoal (1 subgoal):\n 1. pdec1' e + pdec2' e = (GREATEST y. triangle y \\<le> e)", "by simp"], ["proof (state)\nthis:\n  pdec1' e + pdec2' e = (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "then"], ["proof (chain)\npicking this:\n  pdec1' e + pdec2' e = (GREATEST y. triangle y \\<le> e)", "have \"prod_encode (pdec1' e, pdec2' e) = triangle ?y + pdec1' e\""], ["proof (prove)\nusing this:\n  pdec1' e + pdec2' e = (GREATEST y. triangle y \\<le> e)\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) =\n    triangle (GREATEST y. triangle y \\<le> e) + pdec1' e", "by (simp add: prod_encode_def)"], ["proof (state)\nthis:\n  prod_encode (pdec1' e, pdec2' e) =\n  triangle (GREATEST y. triangle y \\<le> e) + pdec1' e\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "then"], ["proof (chain)\npicking this:\n  prod_encode (pdec1' e, pdec2' e) =\n  triangle (GREATEST y. triangle y \\<le> e) + pdec1' e", "show ?thesis"], ["proof (prove)\nusing this:\n  prod_encode (pdec1' e, pdec2' e) =\n  triangle (GREATEST y. triangle y \\<le> e) + pdec1' e\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "using pdec1'_def triangle_greatest_le"], ["proof (prove)\nusing this:\n  prod_encode (pdec1' e, pdec2' e) =\n  triangle (GREATEST y. triangle y \\<le> e) + pdec1' e\n  pdec1' ?e \\<equiv> ?e - triangle (GREATEST y. triangle y \\<le> ?e)\n  triangle (GREATEST y. triangle y \\<le> ?e) \\<le> ?e\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1' e, pdec2' e) = e", "by simp"], ["proof (state)\nthis:\n  prod_encode (pdec1' e, pdec2' e) = e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pdec':\n  \"pdec1' e = pdec1 e\"\n  \"pdec2' e = pdec2 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1' e = pdec1 e &&& pdec2' e = pdec2 e", "using prod_encode_pdec' prod_encode_inverse"], ["proof (prove)\nusing this:\n  prod_encode (pdec1' ?e, pdec2' ?e) = ?e\n  prod_decode (prod_encode ?x) = ?x\n\ngoal (1 subgoal):\n 1. pdec1' e = pdec1 e &&& pdec2' e = pdec2 e", "by (metis fst_conv, metis snd_conv)"], ["", "definition \"r_pdec1 \\<equiv> Cn 1 r_sub [Id 1 0, Cn 1 r_triangle [r_maxlt]]\""], ["", "lemma r_pdec1_prim [simp]: \"prim_recfn 1 r_pdec1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec1", "unfolding r_pdec1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_sub [recf.Id 1 0, Cn 1 r_triangle [r_maxlt]])", "using r_triangle_prim r_maxlt_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n  prim_recfn 1 r_maxlt\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_sub [recf.Id 1 0, Cn 1 r_triangle [r_maxlt]])", "by simp"], ["", "lemma r_pdec1 [simp]: \"eval r_pdec1 [e] \\<down>= pdec1 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec1 [e] \\<down>= pdec1 e", "unfolding r_pdec1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_sub [recf.Id 1 0, Cn 1 r_triangle [r_maxlt]]) [e] \\<down>=\n    pdec1 e", "using r_triangle_prim r_maxlt_prim pdec' pdec1'_def"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_triangle\n  prim_recfn 1 r_maxlt\n  pdec1' ?e = pdec1 ?e\n  pdec2' ?e = pdec2 ?e\n  pdec1' ?e \\<equiv> ?e - triangle (GREATEST y. triangle y \\<le> ?e)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_sub [recf.Id 1 0, Cn 1 r_triangle [r_maxlt]]) [e] \\<down>=\n    pdec1 e", "by (simp add: r_maxlt)"], ["", "definition \"r_pdec2 \\<equiv> Cn 1 r_sub [r_maxlt, r_pdec1]\""], ["", "lemma r_pdec2_prim [simp]: \"prim_recfn 1 r_pdec2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec2", "unfolding r_pdec2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_sub [r_maxlt, r_pdec1])", "using r_maxlt_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_maxlt\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_sub [r_maxlt, r_pdec1])", "by simp"], ["", "lemma r_pdec2 [simp]: \"eval r_pdec2 [e] \\<down>= pdec2 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec2 [e] \\<down>= pdec2 e", "unfolding r_pdec2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_sub [r_maxlt, r_pdec1]) [e] \\<down>= pdec2 e", "using r_maxlt_prim r_maxlt pdec' pdec2'_def"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_maxlt\n  eval r_maxlt [?e] \\<down>= (GREATEST y. triangle y \\<le> ?e)\n  pdec1' ?e = pdec1 ?e\n  pdec2' ?e = pdec2 ?e\n  pdec2' ?e \\<equiv> (GREATEST y. triangle y \\<le> ?e) - pdec1' ?e\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_sub [r_maxlt, r_pdec1]) [e] \\<down>= pdec2 e", "by simp"], ["", "abbreviation \"pdec12 i \\<equiv> pdec1 (pdec2 i)\""], ["", "abbreviation \"pdec22 i \\<equiv> pdec2 (pdec2 i)\""], ["", "abbreviation \"pdec122 i \\<equiv> pdec1 (pdec22 i)\""], ["", "abbreviation \"pdec222 i \\<equiv> pdec2 (pdec22 i)\""], ["", "definition \"r_pdec12 \\<equiv> Cn 1 r_pdec1 [r_pdec2]\""], ["", "lemma r_pdec12_prim [simp]: \"prim_recfn 1 r_pdec12\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec12", "unfolding r_pdec12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec1 [r_pdec2])", "by simp"], ["", "lemma r_pdec12 [simp]: \"eval r_pdec12 [e] \\<down>= pdec12 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec12 [e] \\<down>= pdec12 e", "unfolding r_pdec12_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec1 [r_pdec2]) [e] \\<down>= pdec12 e", "by simp"], ["", "definition \"r_pdec22 \\<equiv> Cn 1 r_pdec2 [r_pdec2]\""], ["", "lemma r_pdec22_prim [simp]: \"prim_recfn 1 r_pdec22\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec22", "unfolding r_pdec22_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec2 [r_pdec2])", "by simp"], ["", "lemma r_pdec22 [simp]: \"eval r_pdec22 [e] \\<down>= pdec22 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec22 [e] \\<down>= pdec22 e", "unfolding r_pdec22_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec2 [r_pdec2]) [e] \\<down>= pdec22 e", "by simp"], ["", "definition \"r_pdec122 \\<equiv> Cn 1 r_pdec1 [r_pdec22]\""], ["", "lemma r_pdec122_prim [simp]: \"prim_recfn 1 r_pdec122\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec122", "unfolding r_pdec122_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec1 [r_pdec22])", "by simp"], ["", "lemma r_pdec122 [simp]: \"eval r_pdec122 [e] \\<down>= pdec122 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec122 [e] \\<down>= pdec122 e", "unfolding r_pdec122_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec1 [r_pdec22]) [e] \\<down>= pdec122 e", "by simp"], ["", "definition \"r_pdec222 \\<equiv> Cn 1 r_pdec2 [r_pdec22]\""], ["", "lemma r_pdec222_prim [simp]: \"prim_recfn 1 r_pdec222\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec222", "unfolding r_pdec222_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec2 [r_pdec22])", "by simp"], ["", "lemma r_pdec222 [simp]: \"eval r_pdec222 [e] \\<down>= pdec222 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec222 [e] \\<down>= pdec222 e", "unfolding r_pdec222_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec2 [r_pdec22]) [e] \\<down>= pdec222 e", "by simp"], ["", "subsubsection \\<open>The Cantor tuple function\\<close>"], ["", "text \\<open>The empty tuple gets no code, whereas singletons are encoded by their\nonly element and other tuples by recursively applying the pairing function.\nThis yields, for every $n$, the function @{term \"tuple_encode n\"}, which is a\nbijection between the natural numbers and the lists of length $(n + 1)$.\\<close>"], ["", "fun tuple_encode :: \"nat \\<Rightarrow> nat list \\<Rightarrow> nat\" where\n  \"tuple_encode n [] = undefined\"\n| \"tuple_encode 0 (x # xs) = x\"\n| \"tuple_encode (Suc n) (x # xs) = prod_encode (x, tuple_encode n xs)\""], ["", "lemma tuple_encode_prod_encode: \"tuple_encode 1 [x, y] = prod_encode (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_encode 1 [x, y] = prod_encode (x, y)", "by simp"], ["", "fun tuple_decode where\n  \"tuple_decode 0 i = [i]\"\n| \"tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)\""], ["", "lemma tuple_encode_decode [simp]:\n  \"tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i", "proof (induction \"length xs - 1\" arbitrary: xs i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       0 = length xs - 1 \\<Longrightarrow>\n       tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\n 2. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "case 0"], ["proof (state)\nthis:\n  0 = length xs - 1\n\ngoal (2 subgoals):\n 1. \\<And>xs i.\n       0 = length xs - 1 \\<Longrightarrow>\n       tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\n 2. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "then"], ["proof (chain)\npicking this:\n  0 = length xs - 1", "show ?case"], ["proof (prove)\nusing this:\n  0 = length xs - 1\n\ngoal (1 subgoal):\n 1. tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i", "by simp"], ["proof (state)\nthis:\n  tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "case (Suc n)"], ["proof (state)\nthis:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "then"], ["proof (chain)\npicking this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1", "have \"length xs - 1 > 0\""], ["proof (prove)\nusing this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n\ngoal (1 subgoal):\n 1. 0 < length xs - 1", "by simp"], ["proof (state)\nthis:\n  0 < length xs - 1\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "with Suc"], ["proof (chain)\npicking this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n  0 < length xs - 1", "have *: \"tuple_encode n (tuple_decode n j) = j\" for j"], ["proof (prove)\nusing this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n  0 < length xs - 1\n\ngoal (1 subgoal):\n 1. tuple_encode n (tuple_decode n j) = j", "by (metis diff_Suc_1 length_tl)"], ["proof (state)\nthis:\n  tuple_encode n (tuple_decode n ?j) = ?j\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "from Suc"], ["proof (chain)\npicking this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1", "have \"tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)\""], ["proof (prove)\nusing this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)", "using tuple_decode.simps(2)"], ["proof (prove)\nusing this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n  tuple_decode (Suc ?n) ?i = pdec1 ?i # tuple_decode ?n (pdec2 ?i)\n\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)", "by blast"], ["proof (state)\nthis:\n  tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "then"], ["proof (chain)\npicking this:\n  tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)", "have \"tuple_encode (Suc n) (tuple_decode (Suc n) i) =\n      tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i))\""], ["proof (prove)\nusing this:\n  tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)\n\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) (tuple_decode (Suc n) i) =\n    tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i))", "using Suc"], ["proof (prove)\nusing this:\n  tuple_decode (Suc n) i = pdec1 i # tuple_decode n (pdec2 i)\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) (tuple_decode (Suc n) i) =\n    tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i))", "by simp"], ["proof (state)\nthis:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) =\n  tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "also"], ["proof (state)\nthis:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) =\n  tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "have \"... = prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i)) =\n    prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i)))", "by simp"], ["proof (state)\nthis:\n  tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i)) =\n  prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "also"], ["proof (state)\nthis:\n  tuple_encode (Suc n) (pdec1 i # tuple_decode n (pdec2 i)) =\n  prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i)))\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "have \"... = prod_encode (pdec1 i, pdec2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i))) =\n    prod_encode (pdec1 i, pdec2 i)", "using Suc *"], ["proof (prove)\nusing this:\n  n = length ?xs - 1 \\<Longrightarrow>\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n  Suc n = length xs - 1\n  tuple_encode n (tuple_decode n ?j) = ?j\n\ngoal (1 subgoal):\n 1. prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i))) =\n    prod_encode (pdec1 i, pdec2 i)", "by simp"], ["proof (state)\nthis:\n  prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i))) =\n  prod_encode (pdec1 i, pdec2 i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "also"], ["proof (state)\nthis:\n  prod_encode (pdec1 i, tuple_encode n (tuple_decode n (pdec2 i))) =\n  prod_encode (pdec1 i, pdec2 i)\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "have \"... = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode (pdec1 i, pdec2 i) = i", "by simp"], ["proof (state)\nthis:\n  prod_encode (pdec1 i, pdec2 i) = i\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "finally"], ["proof (chain)\npicking this:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) = i", "have \"tuple_encode (Suc n) (tuple_decode (Suc n) i) = i\""], ["proof (prove)\nusing this:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) = i\n\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) (tuple_decode (Suc n) i) = i", "."], ["proof (state)\nthis:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) = i\n\ngoal (1 subgoal):\n 1. \\<And>x xs i.\n       \\<lbrakk>\\<And>xs i.\n                   x = length xs - 1 \\<Longrightarrow>\n                   tuple_encode (length xs - 1)\n                    (tuple_decode (length xs - 1) i) =\n                   i;\n        Suc x = length xs - 1\\<rbrakk>\n       \\<Longrightarrow> tuple_encode (length xs - 1)\n                          (tuple_decode (length xs - 1) i) =\n                         i", "then"], ["proof (chain)\npicking this:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) = i", "show ?case"], ["proof (prove)\nusing this:\n  tuple_encode (Suc n) (tuple_decode (Suc n) i) = i\n\ngoal (1 subgoal):\n 1. tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i", "by (simp add: Suc.hyps(2))"], ["proof (state)\nthis:\n  tuple_encode (length xs - 1) (tuple_decode (length xs - 1) i) = i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_encode_decode' [simp]: \"tuple_encode n (tuple_decode n i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_encode n (tuple_decode n i) = i", "using tuple_encode_decode"], ["proof (prove)\nusing this:\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n\ngoal (1 subgoal):\n 1. tuple_encode n (tuple_decode n i) = i", "by (metis Ex_list_of_length diff_Suc_1 length_Cons)"], ["", "lemma tuple_decode_encode:\n  assumes \"length xs > 0\"\n  shows \"tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs", "using assms"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs", "proof (induction \"length xs - 1\" arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "case 0"], ["proof (state)\nthis:\n  0 = length xs - 1\n  0 < length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "moreover"], ["proof (state)\nthis:\n  0 = length xs - 1\n  0 < length xs\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "from this"], ["proof (chain)\npicking this:\n  0 = length xs - 1\n  0 < length xs", "have \"length xs = 1\""], ["proof (prove)\nusing this:\n  0 = length xs - 1\n  0 < length xs\n\ngoal (1 subgoal):\n 1. length xs = 1", "by linarith"], ["proof (state)\nthis:\n  length xs = 1\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>0 = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "ultimately"], ["proof (chain)\npicking this:\n  0 = length xs - 1\n  0 < length xs\n  length xs = 1", "show ?case"], ["proof (prove)\nusing this:\n  0 = length xs - 1\n  0 < length xs\n  length xs = 1\n\ngoal (1 subgoal):\n 1. tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs", "by (metis One_nat_def length_0_conv length_Suc_conv tuple_decode.simps(1)\n      tuple_encode.simps(2))"], ["proof (state)\nthis:\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "case (Suc n)"], ["proof (state)\nthis:\n  \\<lbrakk>n = length ?xs - 1; 0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> tuple_decode (length ?xs - 1)\n                     (tuple_encode (length ?xs - 1) ?xs) =\n                    ?xs\n  Suc n = length xs - 1\n  0 < length xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "let ?t = \"tl xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "let ?i = \"tuple_encode (Suc n) xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "have \"length ?t > 0\" and \"length ?t - 1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (tl xs) &&& length (tl xs) - 1 = n", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length ?xs - 1; 0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> tuple_decode (length ?xs - 1)\n                     (tuple_encode (length ?xs - 1) ?xs) =\n                    ?xs\n  Suc n = length xs - 1\n  0 < length xs\n\ngoal (1 subgoal):\n 1. 0 < length (tl xs) &&& length (tl xs) - 1 = n", "by simp_all"], ["proof (state)\nthis:\n  0 < length (tl xs)\n  length (tl xs) - 1 = n\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "then"], ["proof (chain)\npicking this:\n  0 < length (tl xs)\n  length (tl xs) - 1 = n", "have \"tuple_decode n (tuple_encode n ?t) = ?t\""], ["proof (prove)\nusing this:\n  0 < length (tl xs)\n  length (tl xs) - 1 = n\n\ngoal (1 subgoal):\n 1. tuple_decode n (tuple_encode n (tl xs)) = tl xs", "using Suc"], ["proof (prove)\nusing this:\n  0 < length (tl xs)\n  length (tl xs) - 1 = n\n  \\<lbrakk>n = length ?xs - 1; 0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> tuple_decode (length ?xs - 1)\n                     (tuple_encode (length ?xs - 1) ?xs) =\n                    ?xs\n  Suc n = length xs - 1\n  0 < length xs\n\ngoal (1 subgoal):\n 1. tuple_decode n (tuple_encode n (tl xs)) = tl xs", "by blast"], ["proof (state)\nthis:\n  tuple_decode n (tuple_encode n (tl xs)) = tl xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "moreover"], ["proof (state)\nthis:\n  tuple_decode n (tuple_encode n (tl xs)) = tl xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "have \"?i = prod_encode (hd xs, tuple_encode n ?t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>n = length ?xs - 1; 0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> tuple_decode (length ?xs - 1)\n                     (tuple_encode (length ?xs - 1) ?xs) =\n                    ?xs\n  Suc n = length xs - 1\n  0 < length xs\n\ngoal (1 subgoal):\n 1. tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))", "by (metis hd_Cons_tl length_greater_0_conv tuple_encode.simps(3))"], ["proof (state)\nthis:\n  tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "moreover"], ["proof (state)\nthis:\n  tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "have \"tuple_decode (Suc n) ?i = pdec1 ?i # tuple_decode n (pdec2 ?i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n    pdec1 (tuple_encode (Suc n) xs) #\n    tuple_decode n (pdec2 (tuple_encode (Suc n) xs))", "using tuple_decode.simps(2)"], ["proof (prove)\nusing this:\n  tuple_decode (Suc ?n) ?i = pdec1 ?i # tuple_decode ?n (pdec2 ?i)\n\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n    pdec1 (tuple_encode (Suc n) xs) #\n    tuple_decode n (pdec2 (tuple_encode (Suc n) xs))", "by blast"], ["proof (state)\nthis:\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n  pdec1 (tuple_encode (Suc n) xs) #\n  tuple_decode n (pdec2 (tuple_encode (Suc n) xs))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "ultimately"], ["proof (chain)\npicking this:\n  tuple_decode n (tuple_encode n (tl xs)) = tl xs\n  tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n  pdec1 (tuple_encode (Suc n) xs) #\n  tuple_decode n (pdec2 (tuple_encode (Suc n) xs))", "have \"tuple_decode (Suc n) ?i = xs\""], ["proof (prove)\nusing this:\n  tuple_decode n (tuple_encode n (tl xs)) = tl xs\n  tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n  pdec1 (tuple_encode (Suc n) xs) #\n  tuple_decode n (pdec2 (tuple_encode (Suc n) xs))\n\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) (tuple_encode (Suc n) xs) = xs", "using Suc.prems"], ["proof (prove)\nusing this:\n  tuple_decode n (tuple_encode n (tl xs)) = tl xs\n  tuple_encode (Suc n) xs = prod_encode (hd xs, tuple_encode n (tl xs))\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) =\n  pdec1 (tuple_encode (Suc n) xs) #\n  tuple_decode n (pdec2 (tuple_encode (Suc n) xs))\n  0 < length xs\n\ngoal (1 subgoal):\n 1. tuple_decode (Suc n) (tuple_encode (Suc n) xs) = xs", "by simp"], ["proof (state)\nthis:\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) = xs\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<And>xs.\n                   \\<lbrakk>x = length xs - 1; 0 < length xs\\<rbrakk>\n                   \\<Longrightarrow> tuple_decode (length xs - 1)\n(tuple_encode (length xs - 1) xs) =\n                                     xs;\n        Suc x = length xs - 1; 0 < length xs\\<rbrakk>\n       \\<Longrightarrow> tuple_decode (length xs - 1)\n                          (tuple_encode (length xs - 1) xs) =\n                         xs", "then"], ["proof (chain)\npicking this:\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) = xs", "show ?case"], ["proof (prove)\nusing this:\n  tuple_decode (Suc n) (tuple_encode (Suc n) xs) = xs\n\ngoal (1 subgoal):\n 1. tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs", "by (simp add: Suc.hyps(2))"], ["proof (state)\nthis:\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs) = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_decode_encode' [simp]:\n  assumes \"length xs = Suc n\"\n  shows \"tuple_decode n (tuple_encode n xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode n (tuple_encode n xs) = xs", "using assms tuple_decode_encode"], ["proof (prove)\nusing this:\n  length xs = Suc n\n  0 < length ?xs \\<Longrightarrow>\n  tuple_decode (length ?xs - 1) (tuple_encode (length ?xs - 1) ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. tuple_decode n (tuple_encode n xs) = xs", "by (metis diff_Suc_1 zero_less_Suc)"], ["", "lemma tuple_decode_length [simp]: \"length (tuple_decode n i) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (tuple_decode n i) = Suc n", "by (induction n arbitrary: i) simp_all"], ["", "lemma tuple_decode_nonzero:\n  assumes \"n > 0\"\n  shows \"tuple_decode n i = pdec1 i # tuple_decode (n - 1) (pdec2 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode n i = pdec1 i # tuple_decode (n - 1) (pdec2 i)", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. tuple_decode n i = pdec1 i # tuple_decode (n - 1) (pdec2 i)", "by (metis One_nat_def Suc_pred tuple_decode.simps(2))"], ["", "text \\<open>The tuple encoding functions are primitive recursive.\\<close>"], ["", "fun r_tuple_encode :: \"nat \\<Rightarrow> recf\" where\n  \"r_tuple_encode 0 = Id 1 0\"\n| \"r_tuple_encode (Suc n) =\n     Cn (Suc (Suc n)) r_prod_encode [Id (Suc (Suc n)) 0, r_shift (r_tuple_encode n)]\""], ["", "lemma r_tuple_encode_prim [simp]: \"prim_recfn (Suc n) (r_tuple_encode n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn (Suc n) (r_tuple_encode n)", "by (induction n) simp_all"], ["", "lemma r_tuple_encode:\n  assumes \"length xs = Suc n\"\n  shows \"eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs", "using assms"], ["proof (prove)\nusing this:\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs", "proof (induction n arbitrary: xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs = Suc 0 \\<Longrightarrow>\n       eval (r_tuple_encode 0) xs \\<down>= tuple_encode 0 xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "case 0"], ["proof (state)\nthis:\n  length xs = Suc 0\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       length xs = Suc 0 \\<Longrightarrow>\n       eval (r_tuple_encode 0) xs \\<down>= tuple_encode 0 xs\n 2. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "then"], ["proof (chain)\npicking this:\n  length xs = Suc 0", "show ?case"], ["proof (prove)\nusing this:\n  length xs = Suc 0\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode 0) xs \\<down>= tuple_encode 0 xs", "by (metis One_nat_def eval_Id length_Suc_conv nth_Cons_0\n      r_tuple_encode.simps(1) tuple_encode.simps(2) zero_less_one)"], ["proof (state)\nthis:\n  eval (r_tuple_encode 0) xs \\<down>= tuple_encode 0 xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "case (Suc n)"], ["proof (state)\nthis:\n  length ?xs = Suc n \\<Longrightarrow>\n  eval (r_tuple_encode n) ?xs \\<down>= tuple_encode n ?xs\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "then"], ["proof (chain)\npicking this:\n  length ?xs = Suc n \\<Longrightarrow>\n  eval (r_tuple_encode n) ?xs \\<down>= tuple_encode n ?xs\n  length xs = Suc (Suc n)", "obtain y ys where y_ys: \"y # ys = xs\""], ["proof (prove)\nusing this:\n  length ?xs = Suc n \\<Longrightarrow>\n  eval (r_tuple_encode n) ?xs \\<down>= tuple_encode n ?xs\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. y # ys = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis length_Suc_conv)"], ["proof (state)\nthis:\n  y # ys = xs\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "with Suc"], ["proof (chain)\npicking this:\n  length ?xs = Suc n \\<Longrightarrow>\n  eval (r_tuple_encode n) ?xs \\<down>= tuple_encode n ?xs\n  length xs = Suc (Suc n)\n  y # ys = xs", "have \"eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys\""], ["proof (prove)\nusing this:\n  length ?xs = Suc n \\<Longrightarrow>\n  eval (r_tuple_encode n) ?xs \\<down>= tuple_encode n ?xs\n  length xs = Suc (Suc n)\n  y # ys = xs\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys", "by auto"], ["proof (state)\nthis:\n  eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "with y_ys"], ["proof (chain)\npicking this:\n  y # ys = xs\n  eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys", "have \"eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\""], ["proof (prove)\nusing this:\n  y # ys = xs\n  eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys\n\ngoal (1 subgoal):\n 1. eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys", "using Suc.prems r_shift_prim r_tuple_encode_prim"], ["proof (prove)\nusing this:\n  y # ys = xs\n  eval (r_tuple_encode n) ys \\<down>= tuple_encode n ys\n  length xs = Suc (Suc n)\n  prim_recfn ?a ?f \\<Longrightarrow> prim_recfn (Suc ?a) (r_shift ?f)\n  prim_recfn (Suc ?n) (r_tuple_encode ?n)\n\ngoal (1 subgoal):\n 1. eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys", "by auto"], ["proof (state)\nthis:\n  eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "moreover"], ["proof (state)\nthis:\n  eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "have \"eval (Id (Suc (Suc n)) 0) xs \\<down>= y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y", "using y_ys Suc.prems"], ["proof (prove)\nusing this:\n  y # ys = xs\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y", "by auto"], ["proof (state)\nthis:\n  eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\n  eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y", "have \"eval (r_tuple_encode (Suc n)) xs \\<down>= prod_encode (y, tuple_encode n ys)\""], ["proof (prove)\nusing this:\n  eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\n  eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode (Suc n)) xs \\<down>=\n    prod_encode (y, tuple_encode n ys)", "using Suc.prems"], ["proof (prove)\nusing this:\n  eval (r_shift (r_tuple_encode n)) xs \\<down>= tuple_encode n ys\n  eval (recf.Id (Suc (Suc n)) 0) xs \\<down>= y\n  length xs = Suc (Suc n)\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode (Suc n)) xs \\<down>=\n    prod_encode (y, tuple_encode n ys)", "by simp"], ["proof (state)\nthis:\n  eval (r_tuple_encode (Suc n)) xs \\<down>=\n  prod_encode (y, tuple_encode n ys)\n\ngoal (1 subgoal):\n 1. \\<And>n xs.\n       \\<lbrakk>\\<And>xs.\n                   length xs = Suc n \\<Longrightarrow>\n                   eval (r_tuple_encode n) xs \\<down>= tuple_encode n xs;\n        length xs = Suc (Suc n)\\<rbrakk>\n       \\<Longrightarrow> eval (r_tuple_encode (Suc n)) xs \\<down>=\n                         tuple_encode (Suc n) xs", "then"], ["proof (chain)\npicking this:\n  eval (r_tuple_encode (Suc n)) xs \\<down>=\n  prod_encode (y, tuple_encode n ys)", "show ?case"], ["proof (prove)\nusing this:\n  eval (r_tuple_encode (Suc n)) xs \\<down>=\n  prod_encode (y, tuple_encode n ys)\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode (Suc n)) xs \\<down>= tuple_encode (Suc n) xs", "using y_ys"], ["proof (prove)\nusing this:\n  eval (r_tuple_encode (Suc n)) xs \\<down>=\n  prod_encode (y, tuple_encode n ys)\n  y # ys = xs\n\ngoal (1 subgoal):\n 1. eval (r_tuple_encode (Suc n)) xs \\<down>= tuple_encode (Suc n) xs", "by auto"], ["proof (state)\nthis:\n  eval (r_tuple_encode (Suc n)) xs \\<down>= tuple_encode (Suc n) xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Functions on encoded tuples\\<close>"], ["", "text \\<open>The function for accessing the $n$-th element of a tuple returns\n$0$ for out-of-bounds access.\\<close>"], ["", "definition e_tuple_nth :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_tuple_nth a i n \\<equiv> if n \\<le> a then (tuple_decode a i) ! n else 0\""], ["", "lemma e_tuple_nth_le [simp]: \"n \\<le> a \\<Longrightarrow> e_tuple_nth a i n = (tuple_decode a i) ! n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> a \\<Longrightarrow> e_tuple_nth a i n = tuple_decode a i ! n", "using e_tuple_nth_def"], ["proof (prove)\nusing this:\n  e_tuple_nth ?a ?i ?n \\<equiv>\n  if ?n \\<le> ?a then tuple_decode ?a ?i ! ?n else 0\n\ngoal (1 subgoal):\n 1. n \\<le> a \\<Longrightarrow> e_tuple_nth a i n = tuple_decode a i ! n", "by simp"], ["", "lemma e_tuple_nth_gr [simp]: \"n > a \\<Longrightarrow> e_tuple_nth a i n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a < n \\<Longrightarrow> e_tuple_nth a i n = 0", "using e_tuple_nth_def"], ["proof (prove)\nusing this:\n  e_tuple_nth ?a ?i ?n \\<equiv>\n  if ?n \\<le> ?a then tuple_decode ?a ?i ! ?n else 0\n\ngoal (1 subgoal):\n 1. a < n \\<Longrightarrow> e_tuple_nth a i n = 0", "by simp"], ["", "lemma tuple_decode_pdec2: \"tuple_decode a (pdec2 es) = tl (tuple_decode (Suc a) es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode a (pdec2 es) = tl (tuple_decode (Suc a) es)", "by simp"], ["", "fun iterate :: \"nat \\<Rightarrow> ('a \\<Rightarrow> 'a) \\<Rightarrow> ('a \\<Rightarrow> 'a)\" where\n  \"iterate 0 f = id\"\n| \"iterate (Suc n) f = f \\<circ> (iterate n f)\""], ["", "lemma iterate_additive:\n  assumes \"iterate t\\<^sub>1 f x = y\" and \"iterate t\\<^sub>2 f y = z\"\n  shows \"iterate (t\\<^sub>1 + t\\<^sub>2) f x = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate (t\\<^sub>1 + t\\<^sub>2) f x = z", "using assms"], ["proof (prove)\nusing this:\n  iterate t\\<^sub>1 f x = y\n  iterate t\\<^sub>2 f y = z\n\ngoal (1 subgoal):\n 1. iterate (t\\<^sub>1 + t\\<^sub>2) f x = z", "by (induction t\\<^sub>2 arbitrary: z) auto"], ["", "lemma iterate_additive': \"iterate (t\\<^sub>1 + t\\<^sub>2) f x = iterate t\\<^sub>2 f (iterate t\\<^sub>1 f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate (t\\<^sub>1 + t\\<^sub>2) f x =\n    iterate t\\<^sub>2 f (iterate t\\<^sub>1 f x)", "using iterate_additive"], ["proof (prove)\nusing this:\n  \\<lbrakk>iterate ?t\\<^sub>1 ?f ?x = ?y;\n   iterate ?t\\<^sub>2 ?f ?y = ?z\\<rbrakk>\n  \\<Longrightarrow> iterate (?t\\<^sub>1 + ?t\\<^sub>2) ?f ?x = ?z\n\ngoal (1 subgoal):\n 1. iterate (t\\<^sub>1 + t\\<^sub>2) f x =\n    iterate t\\<^sub>2 f (iterate t\\<^sub>1 f x)", "by metis"], ["", "lemma e_tuple_nth_elementary:\n  assumes \"k \\<le> a\"\n  shows \"e_tuple_nth a i k = (if a = k then (iterate k pdec2 i) else (pdec1 (iterate k pdec2 i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "have *: \"tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)", "using assms"], ["proof (prove)\nusing this:\n  k \\<le> a\n\ngoal (1 subgoal):\n 1. tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)", "by (induction k) (simp, simp add: Suc_diff_Suc tuple_decode_pdec2 drop_Suc tl_drop)"], ["proof (state)\nthis:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "proof (cases \"a = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n 2. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "case True"], ["proof (state)\nthis:\n  a = k\n\ngoal (2 subgoals):\n 1. a = k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n 2. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "then"], ["proof (chain)\npicking this:\n  a = k", "have \"tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\""], ["proof (prove)\nusing this:\n  a = k\n\ngoal (1 subgoal):\n 1. tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)", "using assms *"], ["proof (prove)\nusing this:\n  a = k\n  k \\<le> a\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (1 subgoal):\n 1. tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)", "by simp"], ["proof (state)\nthis:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (2 subgoals):\n 1. a = k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n 2. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "moreover"], ["proof (state)\nthis:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (2 subgoals):\n 1. a = k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n 2. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "from this"], ["proof (chain)\npicking this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)", "have \"drop k (tuple_decode a i) = [tuple_decode a i ! k]\""], ["proof (prove)\nusing this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (1 subgoal):\n 1. drop k (tuple_decode a i) = [tuple_decode a i ! k]", "using assms True"], ["proof (prove)\nusing this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n  k \\<le> a\n  a = k\n\ngoal (1 subgoal):\n 1. drop k (tuple_decode a i) = [tuple_decode a i ! k]", "by (metis nth_via_drop tuple_decode.simps(1))"], ["proof (state)\nthis:\n  drop k (tuple_decode a i) = [tuple_decode a i ! k]\n\ngoal (2 subgoals):\n 1. a = k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n 2. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "ultimately"], ["proof (chain)\npicking this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n  drop k (tuple_decode a i) = [tuple_decode a i ! k]", "show ?thesis"], ["proof (prove)\nusing this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n  drop k (tuple_decode a i) = [tuple_decode a i ! k]\n\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "using True"], ["proof (prove)\nusing this:\n  tuple_decode 0 (iterate k pdec2 i) = drop k (tuple_decode a i)\n  drop k (tuple_decode a i) = [tuple_decode a i ! k]\n  a = k\n\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "by simp"], ["proof (state)\nthis:\n  e_tuple_nth a i k =\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "case False"], ["proof (state)\nthis:\n  a \\<noteq> k\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "with assms"], ["proof (chain)\npicking this:\n  k \\<le> a\n  a \\<noteq> k", "have \"a - k > 0\""], ["proof (prove)\nusing this:\n  k \\<le> a\n  a \\<noteq> k\n\ngoal (1 subgoal):\n 1. 0 < a - k", "by simp"], ["proof (state)\nthis:\n  0 < a - k\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "with *"], ["proof (chain)\npicking this:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n  0 < a - k", "have \"tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\""], ["proof (prove)\nusing this:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n  0 < a - k\n\ngoal (1 subgoal):\n 1. tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)", "by simp"], ["proof (state)\nthis:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "then"], ["proof (chain)\npicking this:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)", "have \"pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))\""], ["proof (prove)\nusing this:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n\ngoal (1 subgoal):\n 1. pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))", "using tuple_decode_nonzero \\<open>a - k > 0\\<close>"], ["proof (prove)\nusing this:\n  tuple_decode (a - k) (iterate k pdec2 i) = drop k (tuple_decode a i)\n  0 < ?n \\<Longrightarrow>\n  tuple_decode ?n ?i = pdec1 ?i # tuple_decode (?n - 1) (pdec2 ?i)\n  0 < a - k\n\ngoal (1 subgoal):\n 1. pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))", "by (metis list.sel(1))"], ["proof (state)\nthis:\n  pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "with \\<open>a - k > 0\\<close>"], ["proof (chain)\npicking this:\n  0 < a - k\n  pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))", "have \"pdec1 (iterate k pdec2 i) = (tuple_decode a i) ! k\""], ["proof (prove)\nusing this:\n  0 < a - k\n  pdec1 (iterate k pdec2 i) = hd (drop k (tuple_decode a i))\n\ngoal (1 subgoal):\n 1. pdec1 (iterate k pdec2 i) = tuple_decode a i ! k", "by (simp add: hd_drop_conv_nth)"], ["proof (state)\nthis:\n  pdec1 (iterate k pdec2 i) = tuple_decode a i ! k\n\ngoal (1 subgoal):\n 1. a \\<noteq> k \\<Longrightarrow>\n    e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "with False assms"], ["proof (chain)\npicking this:\n  a \\<noteq> k\n  k \\<le> a\n  pdec1 (iterate k pdec2 i) = tuple_decode a i ! k", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> k\n  k \\<le> a\n  pdec1 (iterate k pdec2 i) = tuple_decode a i ! k\n\ngoal (1 subgoal):\n 1. e_tuple_nth a i k =\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "by simp"], ["proof (state)\nthis:\n  e_tuple_nth a i k =\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_tuple_nth a i k =\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_nth_inbounds \\<equiv>\n  let r = Pr 1 (Id 1 0) (Cn 3 r_pdec2 [Id 3 1])\n  in Cn 3 r_ifeq\n       [Id 3 0,\n        Id 3 2,\n        Cn 3 r [Id 3 2, Id 3 1],\n        Cn 3 r_pdec1 [Cn 3 r [Id 3 2, Id 3 1]]]\""], ["", "lemma r_nth_inbounds_prim: \"prim_recfn 3 r_nth_inbounds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_nth_inbounds", "unfolding r_nth_inbounds_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (let r = Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])\n      in Cn 3 r_ifeq\n          [recf.Id 3 0, recf.Id 3 2, Cn 3 r [recf.Id 3 2, recf.Id 3 1],\n           Cn 3 r_pdec1 [Cn 3 r [recf.Id 3 2, recf.Id 3 1]]])", "by (simp add: Let_def)"], ["", "lemma r_nth_inbounds:\n  \"k \\<le> a \\<Longrightarrow> eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\"\n  \"eval r_nth_inbounds [a, i, k] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (k \\<le> a \\<Longrightarrow>\n     eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k) &&&\n    eval r_nth_inbounds [a, i, k] \\<down>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "let ?r = \"Pr 1 (Id 1 0) (Cn 3 r_pdec2 [Id 3 1])\""], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "let ?h = \"Cn 3 ?r [Id 3 2, Id 3 1]\""], ["proof (state)\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "have \"eval ?r [k, i] \\<down>= iterate k pdec2 i\" for k i"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [k, i] \\<down>=\n    iterate k pdec2 i", "using r_pdec2_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec2\n\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [k, i] \\<down>=\n    iterate k pdec2 i", "by (induction k) (simp_all)"], ["proof (state)\nthis:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [?k, ?i] \\<down>=\n  iterate ?k pdec2 ?i\n\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [?k, ?i] \\<down>=\n  iterate ?k pdec2 ?i", "have \"eval ?h [a, i, k] \\<down>= iterate k pdec2 i\""], ["proof (prove)\nusing this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [?k, ?i] \\<down>=\n  iterate ?k pdec2 ?i\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n       [recf.Id 3 2, recf.Id 3 1])\n     [a, i, k] \\<down>=\n    iterate k pdec2 i", "using r_pdec2_prim"], ["proof (prove)\nusing this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])) [?k, ?i] \\<down>=\n  iterate ?k pdec2 ?i\n  prim_recfn 1 r_pdec2\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n       [recf.Id 3 2, recf.Id 3 1])\n     [a, i, k] \\<down>=\n    iterate k pdec2 i", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n     [recf.Id 3 2, recf.Id 3 1])\n   [a, i, k] \\<down>=\n  iterate k pdec2 i\n\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n     [recf.Id 3 2, recf.Id 3 1])\n   [a, i, k] \\<down>=\n  iterate k pdec2 i", "have \"eval r_nth_inbounds [a, i, k] \\<down>=\n      (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n     [recf.Id 3 2, recf.Id 3 1])\n   [a, i, k] \\<down>=\n  iterate k pdec2 i\n\ngoal (1 subgoal):\n 1. eval r_nth_inbounds [a, i, k] \\<down>=\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "unfolding r_nth_inbounds_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 (Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1]))\n     [recf.Id 3 2, recf.Id 3 1])\n   [a, i, k] \\<down>=\n  iterate k pdec2 i\n\ngoal (1 subgoal):\n 1. eval\n     (let r = Pr 1 (recf.Id 1 0) (Cn 3 r_pdec2 [recf.Id 3 1])\n      in Cn 3 r_ifeq\n          [recf.Id 3 0, recf.Id 3 2, Cn 3 r [recf.Id 3 2, recf.Id 3 1],\n           Cn 3 r_pdec1 [Cn 3 r [recf.Id 3 2, recf.Id 3 1]]])\n     [a, i, k] \\<down>=\n    (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  eval r_nth_inbounds [a, i, k] \\<down>=\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n\ngoal (2 subgoals):\n 1. k \\<le> a \\<Longrightarrow>\n    eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n 2. eval r_nth_inbounds [a, i, k] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval r_nth_inbounds [a, i, k] \\<down>=\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))", "show \"k \\<le> a \\<Longrightarrow> eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\"\n    and \"eval r_nth_inbounds [a, i, k] \\<down>\""], ["proof (prove)\nusing this:\n  eval r_nth_inbounds [a, i, k] \\<down>=\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n\ngoal (1 subgoal):\n 1. (k \\<le> a \\<Longrightarrow>\n     eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k) &&&\n    eval r_nth_inbounds [a, i, k] \\<down>", "using e_tuple_nth_elementary"], ["proof (prove)\nusing this:\n  eval r_nth_inbounds [a, i, k] \\<down>=\n  (if a = k then iterate k pdec2 i else pdec1 (iterate k pdec2 i))\n  ?k \\<le> ?a \\<Longrightarrow>\n  e_tuple_nth ?a ?i ?k =\n  (if ?a = ?k then iterate ?k pdec2 ?i else pdec1 (iterate ?k pdec2 ?i))\n\ngoal (1 subgoal):\n 1. (k \\<le> a \\<Longrightarrow>\n     eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k) &&&\n    eval r_nth_inbounds [a, i, k] \\<down>", "by simp_all"], ["proof (state)\nthis:\n  k \\<le> a \\<Longrightarrow>\n  eval r_nth_inbounds [a, i, k] \\<down>= e_tuple_nth a i k\n  eval r_nth_inbounds [a, i, k] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_tuple_nth \\<equiv>\n  Cn 3 r_ifle [Id 3 2, Id 3 0, r_nth_inbounds, r_constn 2 0]\""], ["", "lemma r_tuple_nth_prim: \"prim_recfn 3 r_tuple_nth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_tuple_nth", "unfolding r_tuple_nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_nth_inbounds, r_constn 2 0])", "using r_nth_inbounds_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_nth_inbounds\n\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_nth_inbounds, r_constn 2 0])", "by simp"], ["", "lemma r_tuple_nth [simp]: \"eval r_tuple_nth [a, i, k] \\<down>= e_tuple_nth a i k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_tuple_nth [a, i, k] \\<down>= e_tuple_nth a i k", "unfolding r_tuple_nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_nth_inbounds, r_constn 2 0])\n     [a, i, k] \\<down>=\n    e_tuple_nth a i k", "using r_nth_inbounds_prim r_nth_inbounds"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_nth_inbounds\n  ?k \\<le> ?a \\<Longrightarrow>\n  eval r_nth_inbounds [?a, ?i, ?k] \\<down>= e_tuple_nth ?a ?i ?k\n  eval r_nth_inbounds [?a, ?i, ?k] \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_nth_inbounds, r_constn 2 0])\n     [a, i, k] \\<down>=\n    e_tuple_nth a i k", "by simp"], ["", "subsection \\<open>Lists\\<close>"], ["", "subsubsection \\<open>Encoding and decoding\\<close>"], ["", "text \\<open>Lists are encoded by pairing the length of the list with the code\nfor the tuple made up of the list's elements. Then all these codes are\nincremented in order to make room for the empty list\n(cf.~Rogers~\\cite[p.~71]{Rogers87}).\\<close>"], ["", "fun list_encode :: \"nat list \\<Rightarrow> nat\" where\n  \"list_encode [] = 0\"\n| \"list_encode (x # xs) = Suc (prod_encode (length xs, tuple_encode (length xs) (x # xs)))\""], ["", "lemma list_encode_0 [simp]: \"list_encode xs = 0 \\<Longrightarrow> xs = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode xs = 0 \\<Longrightarrow> xs = []", "using list_encode.elims"], ["proof (prove)\nusing this:\n  \\<lbrakk>Partial_Recursive.list_encode ?x = ?y;\n   \\<lbrakk>?x = []; ?y = 0\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>x xs.\n      \\<lbrakk>?x = x # xs;\n       ?y =\n       Suc (prod_encode\n             (length xs, tuple_encode (length xs) (x # xs)))\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode xs = 0 \\<Longrightarrow> xs = []", "by blast"], ["", "lemma list_encode_1: \"list_encode [0] = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode [0] = 1", "by (simp add: prod_encode_def)"], ["", "fun list_decode :: \"nat \\<Rightarrow> nat list\" where\n  \"list_decode 0 = []\"\n| \"list_decode (Suc n) = tuple_decode (pdec1 n) (pdec2 n)\""], ["", "lemma list_encode_decode [simp]: \"list_encode (list_decode n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "proof (cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "case (Suc k)"], ["proof (state)\nthis:\n  n = Suc k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  n = Suc k", "have *: \"list_decode n = tuple_decode (pdec1 k) (pdec2 k)\" (is \"_ = ?t\")"], ["proof (prove)\nusing this:\n  n = Suc k\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)", "obtain x xs where xxs: \"x # xs = ?t\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        x # xs = tuple_decode (pdec1 k) (pdec2 k) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis tuple_decode.elims)"], ["proof (state)\nthis:\n  x # xs = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  x # xs = tuple_decode (pdec1 k) (pdec2 k)", "have \"list_encode ?t = list_encode (x # xs)\""], ["proof (prove)\nusing this:\n  x # xs = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n    Partial_Recursive.list_encode (x # xs)", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Partial_Recursive.list_encode (x # xs)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Partial_Recursive.list_encode (x # xs)", "have 1: \"list_encode ?t = Suc (prod_encode (length xs, tuple_encode (length xs) (x # xs)))\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Partial_Recursive.list_encode (x # xs)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n    Suc (prod_encode (length xs, tuple_encode (length xs) (x # xs)))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Suc (prod_encode (length xs, tuple_encode (length xs) (x # xs)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "have 2: \"length xs = length ?t - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1", "using xxs"], ["proof (prove)\nusing this:\n  x # xs = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1", "by (metis length_tl list.sel(3))"], ["proof (state)\nthis:\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1", "have 3: \"length xs = pdec1 k\""], ["proof (prove)\nusing this:\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1\n\ngoal (1 subgoal):\n 1. length xs = pdec1 k", "using *"], ["proof (prove)\nusing this:\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. length xs = pdec1 k", "by simp"], ["proof (state)\nthis:\n  length xs = pdec1 k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  length xs = pdec1 k", "have \"tuple_encode (length ?t - 1) ?t = pdec2 k\""], ["proof (prove)\nusing this:\n  length xs = pdec1 k\n\ngoal (1 subgoal):\n 1. tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n     (tuple_decode (pdec1 k) (pdec2 k)) =\n    pdec2 k", "using 2 tuple_encode_decode"], ["proof (prove)\nusing this:\n  length xs = pdec1 k\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1\n  tuple_encode (length ?xs - 1) (tuple_decode (length ?xs - 1) ?i) = ?i\n\ngoal (1 subgoal):\n 1. tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n     (tuple_decode (pdec1 k) (pdec2 k)) =\n    pdec2 k", "by metis"], ["proof (state)\nthis:\n  tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n   (tuple_decode (pdec1 k) (pdec2 k)) =\n  pdec2 k\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "then"], ["proof (chain)\npicking this:\n  tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n   (tuple_decode (pdec1 k) (pdec2 k)) =\n  pdec2 k", "have \"list_encode ?t = Suc (prod_encode (pdec1 k, pdec2 k))\""], ["proof (prove)\nusing this:\n  tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n   (tuple_decode (pdec1 k) (pdec2 k)) =\n  pdec2 k\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n    Suc (prod_encode (pdec1 k, pdec2 k))", "using 1 2 3 xxs"], ["proof (prove)\nusing this:\n  tuple_encode (length (tuple_decode (pdec1 k) (pdec2 k)) - 1)\n   (tuple_decode (pdec1 k) (pdec2 k)) =\n  pdec2 k\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Suc (prod_encode (length xs, tuple_encode (length xs) (x # xs)))\n  length xs = length (tuple_decode (pdec1 k) (pdec2 k)) - 1\n  length xs = pdec1 k\n  x # xs = tuple_decode (pdec1 k) (pdec2 k)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n    Suc (prod_encode (pdec1 k, pdec2 k))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Suc (prod_encode (pdec1 k, pdec2 k))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "with * Suc"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)\n  n = Suc k\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Suc (prod_encode (pdec1 k, pdec2 k))", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode n = tuple_decode (pdec1 k) (pdec2 k)\n  n = Suc k\n  Partial_Recursive.list_encode (tuple_decode (pdec1 k) (pdec2 k)) =\n  Suc (prod_encode (pdec1 k, pdec2 k))\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode (Partial_Recursive.list_decode n) = n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma list_decode_encode [simp]: \"list_decode (list_encode xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow>\n    Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "then"], ["proof (chain)\npicking this:\n  xs = []", "show ?thesis"], ["proof (prove)\nusing this:\n  xs = []\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "then"], ["proof (chain)\npicking this:\n  xs = y # ys", "have \"list_encode xs =\n      Suc (prod_encode (length ys, tuple_encode (length ys) xs))\"\n      (is \"_ = Suc ?i\")"], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode xs =\n    Suc (prod_encode (length ys, tuple_encode (length ys) xs))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode xs =\n  Suc (prod_encode (length ys, tuple_encode (length ys) xs))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_encode xs =\n  Suc (prod_encode (length ys, tuple_encode (length ys) xs))", "have \"list_decode (Suc ?i) = tuple_decode (pdec1 ?i) (pdec2 ?i)\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode xs =\n  Suc (prod_encode (length ys, tuple_encode (length ys) xs))\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode\n     (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n    tuple_decode\n     (pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)))\n     (pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode\n   (pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)))\n   (pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "moreover"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode\n   (pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)))\n   (pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "have \"pdec1 ?i = length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)) = length ys", "by simp"], ["proof (state)\nthis:\n  pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)) = length ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "moreover"], ["proof (state)\nthis:\n  pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)) = length ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "have \"pdec2 ?i = tuple_encode (length ys) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)) =\n    tuple_encode (length ys) xs", "by simp"], ["proof (state)\nthis:\n  pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)) =\n  tuple_encode (length ys) xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "ultimately"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode\n   (pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)))\n   (pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)))\n  pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)) = length ys\n  pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)) =\n  tuple_encode (length ys) xs", "have \"list_decode (Suc ?i) =\n      tuple_decode (length ys) (tuple_encode (length ys) xs)\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode\n   (pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)))\n   (pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)))\n  pdec1 (prod_encode (length ys, tuple_encode (length ys) xs)) = length ys\n  pdec2 (prod_encode (length ys, tuple_encode (length ys) xs)) =\n  tuple_encode (length ys) xs\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode\n     (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n    tuple_decode (length ys) (tuple_encode (length ys) xs)", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length ys) (tuple_encode (length ys) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "moreover"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length ys) (tuple_encode (length ys) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "have \"length ys = length xs - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ys = length xs - 1", "using Cons"], ["proof (prove)\nusing this:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. length ys = length xs - 1", "by simp"], ["proof (state)\nthis:\n  length ys = length xs - 1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "ultimately"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length ys) (tuple_encode (length ys) xs)\n  length ys = length xs - 1", "have \"list_decode (Suc ?i) =\n      tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length ys) (tuple_encode (length ys) xs)\n  length ys = length xs - 1\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode\n     (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n    tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "using Cons"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (length ys, tuple_encode (length ys) xs))) =\n  tuple_decode (length xs - 1) (tuple_encode (length xs - 1) xs)\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode xs) = xs\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation singleton_encode :: \"nat \\<Rightarrow> nat\" where\n  \"singleton_encode x \\<equiv> list_encode [x]\""], ["", "lemma list_decode_singleton: \"list_decode (singleton_encode x) = [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode (singleton_encode x) = [x]", "by simp"], ["", "definition \"r_singleton_encode \\<equiv> Cn 1 S [Cn 1 r_prod_encode [Z, Id 1 0]]\""], ["", "lemma r_singleton_encode_prim [simp]: \"prim_recfn 1 r_singleton_encode\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_singleton_encode", "unfolding r_singleton_encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 S [Cn 1 r_prod_encode [Z, recf.Id 1 0]])", "by simp"], ["", "lemma r_singleton_encode [simp]: \"eval r_singleton_encode [x] \\<down>= singleton_encode x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_singleton_encode [x] \\<down>= singleton_encode x", "unfolding r_singleton_encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 S [Cn 1 r_prod_encode [Z, recf.Id 1 0]]) [x] \\<down>=\n    singleton_encode x", "by simp"], ["", "definition r_list_encode :: \"nat \\<Rightarrow> recf\" where\n  \"r_list_encode n \\<equiv> Cn (Suc n) S [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]]\""], ["", "lemma r_list_encode_prim [simp]: \"prim_recfn (Suc n) (r_list_encode n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn (Suc n) (r_list_encode n)", "unfolding r_list_encode_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn (Suc n)\n     (Cn (Suc n) S\n       [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])", "by simp"], ["", "lemma r_list_encode:\n  assumes \"length xs = Suc n\"\n  shows \"eval (r_list_encode n) xs \\<down>= list_encode xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "have \"eval (r_tuple_encode n) xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_tuple_encode n) xs \\<down>", "by (simp add: assms r_tuple_encode)"], ["proof (state)\nthis:\n  eval (r_tuple_encode n) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "then"], ["proof (chain)\npicking this:\n  eval (r_tuple_encode n) xs \\<down>", "have \"eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]) xs \\<down>\""], ["proof (prove)\nusing this:\n  eval (r_tuple_encode n) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n     xs \\<down>", "using assms"], ["proof (prove)\nusing this:\n  eval (r_tuple_encode n) xs \\<down>\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n     xs \\<down>", "by simp"], ["proof (state)\nthis:\n  eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n   xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "then"], ["proof (chain)\npicking this:\n  eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n   xs \\<down>", "have \"eval (r_list_encode n) xs =\n      eval S [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]) xs)]\""], ["proof (prove)\nusing this:\n  eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n   xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs =\n    eval S\n     [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n            xs)]", "unfolding r_list_encode_def"], ["proof (prove)\nusing this:\n  eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n   xs \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) S\n       [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n     xs =\n    eval S\n     [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n            xs)]", "using assms r_tuple_encode"], ["proof (prove)\nusing this:\n  eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n   xs \\<down>\n  length xs = Suc n\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_tuple_encode ?n) ?xs \\<down>= tuple_encode ?n ?xs\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) S\n       [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n     xs =\n    eval S\n     [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n            xs)]", "by simp"], ["proof (state)\nthis:\n  eval (r_list_encode n) xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "moreover"], ["proof (state)\nthis:\n  eval (r_list_encode n) xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "from assms"], ["proof (chain)\npicking this:\n  length xs = Suc n", "obtain y ys where \"xs = y # ys\""], ["proof (prove)\nusing this:\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson length_Suc_conv)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_list_encode n) xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n  xs = y # ys", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_list_encode n) xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs", "unfolding r_list_encode_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn (Suc n) S\n     [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n   xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) S\n       [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n     xs \\<down>=\n    Partial_Recursive.list_encode xs", "using assms r_tuple_encode"], ["proof (prove)\nusing this:\n  eval\n   (Cn (Suc n) S\n     [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n   xs =\n  eval S\n   [the (eval (Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n])\n          xs)]\n  xs = y # ys\n  length xs = Suc n\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_tuple_encode ?n) ?xs \\<down>= tuple_encode ?n ?xs\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) S\n       [Cn (Suc n) r_prod_encode [r_constn n n, r_tuple_encode n]])\n     xs \\<down>=\n    Partial_Recursive.list_encode xs", "by simp"], ["proof (state)\nthis:\n  eval (r_list_encode n) xs \\<down>= Partial_Recursive.list_encode xs\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Functions on encoded lists\\<close>"], ["", "text \\<open>The functions in this section mimic those on type @{typ \"nat\nlist\"}. Their names are prefixed by @{text e_} and the names of the\ncorresponding @{typ recf}s by @{text r_}.\\<close>"], ["", "abbreviation e_tl :: \"nat \\<Rightarrow> nat\" where\n  \"e_tl e \\<equiv> list_encode (tl (list_decode e))\""], ["", "text \\<open>In order to turn @{term e_tl} into a partial recursive function\nwe first represent it in a more elementary way.\\<close>"], ["", "lemma e_tl_elementary:\n  \"e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n     else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "proof (cases e)"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_tl e =\n       (if e = 0 then 0\n        else if pdec1 (e - 1) = 0 then 0\n             else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "case 0"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_tl e =\n       (if e = 0 then 0\n        else if pdec1 (e - 1) = 0 then 0\n             else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  e = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  e = 0\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "by simp"], ["proof (state)\nthis:\n  e_tl e =\n  (if e = 0 then 0\n   else if pdec1 (e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_tl e =\n       (if e = 0 then 0\n        else if pdec1 (e - 1) = 0 then 0\n             else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_tl e =\n       (if e = 0 then 0\n        else if pdec1 (e - 1) = 0 then 0\n             else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "case Suc_d: (Suc d)"], ["proof (state)\nthis:\n  e = Suc d\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_tl e =\n       (if e = 0 then 0\n        else if pdec1 (e - 1) = 0 then 0\n             else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  e = Suc d", "show ?thesis"], ["proof (prove)\nusing this:\n  e = Suc d\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "proof (cases \"pdec1 d\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>e = Suc d; pdec1 d = 0\\<rbrakk>\n    \\<Longrightarrow> e_tl e =\n                      (if e = 0 then 0\n                       else if pdec1 (e - 1) = 0 then 0\n                            else Suc (prod_encode\n (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n 2. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "case 0"], ["proof (state)\nthis:\n  pdec1 d = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>e = Suc d; pdec1 d = 0\\<rbrakk>\n    \\<Longrightarrow> e_tl e =\n                      (if e = 0 then 0\n                       else if pdec1 (e - 1) = 0 then 0\n                            else Suc (prod_encode\n (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n 2. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  pdec1 d = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  pdec1 d = 0\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "using Suc_d"], ["proof (prove)\nusing this:\n  pdec1 d = 0\n  e = Suc d\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "by simp"], ["proof (state)\nthis:\n  e_tl e =\n  (if e = 0 then 0\n   else if pdec1 (e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "case (Suc a)"], ["proof (state)\nthis:\n  pdec1 d = Suc a\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have *: \"list_decode e = tuple_decode (pdec1 d) (pdec2 d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)", "using Suc_d"], ["proof (prove)\nusing this:\n  e = Suc d\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "with Suc"], ["proof (chain)\npicking this:\n  pdec1 d = Suc a\n  Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)", "obtain x xs where xxs: \"list_decode e = x # xs\""], ["proof (prove)\nusing this:\n  pdec1 d = Suc a\n  Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)\n\ngoal (1 subgoal):\n 1. (\\<And>x xs.\n        Partial_Recursive.list_decode e = x # xs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode e = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode e = x # xs", "have **: \"e_tl e = list_encode xs\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode e = x # xs\n\ngoal (1 subgoal):\n 1. e_tl e = Partial_Recursive.list_encode xs", "by simp"], ["proof (state)\nthis:\n  e_tl e = Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"list_decode (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n        tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1))\"\n        (is \"?lhs = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n    tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "also"], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"... = tuple_decode a (pdec22 (e - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1)) =\n    tuple_decode a (pdec22 (e - 1))", "using Suc Suc_d"], ["proof (prove)\nusing this:\n  pdec1 d = Suc a\n  e = Suc d\n\ngoal (1 subgoal):\n 1. tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1)) =\n    tuple_decode a (pdec22 (e - 1))", "by simp"], ["proof (state)\nthis:\n  tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1)) =\n  tuple_decode a (pdec22 (e - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "also"], ["proof (state)\nthis:\n  tuple_decode (pdec1 (e - 1) - 1) (pdec22 (e - 1)) =\n  tuple_decode a (pdec22 (e - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"... = tl (tuple_decode (Suc a) (pdec2 (e - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple_decode a (pdec22 (e - 1)) =\n    tl (tuple_decode (Suc a) (pdec2 (e - 1)))", "using tuple_decode_pdec2 Suc"], ["proof (prove)\nusing this:\n  tuple_decode ?a (pdec2 ?es) = tl (tuple_decode (Suc ?a) ?es)\n  pdec1 d = Suc a\n\ngoal (1 subgoal):\n 1. tuple_decode a (pdec22 (e - 1)) =\n    tl (tuple_decode (Suc a) (pdec2 (e - 1)))", "by presburger"], ["proof (state)\nthis:\n  tuple_decode a (pdec22 (e - 1)) =\n  tl (tuple_decode (Suc a) (pdec2 (e - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "also"], ["proof (state)\nthis:\n  tuple_decode a (pdec22 (e - 1)) =\n  tl (tuple_decode (Suc a) (pdec2 (e - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"... = tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (tuple_decode (Suc a) (pdec2 (e - 1))) =\n    tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1)))", "using Suc Suc_d"], ["proof (prove)\nusing this:\n  pdec1 d = Suc a\n  e = Suc d\n\ngoal (1 subgoal):\n 1. tl (tuple_decode (Suc a) (pdec2 (e - 1))) =\n    tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1)))", "by auto"], ["proof (state)\nthis:\n  tl (tuple_decode (Suc a) (pdec2 (e - 1))) =\n  tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "also"], ["proof (state)\nthis:\n  tl (tuple_decode (Suc a) (pdec2 (e - 1))) =\n  tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1)))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"... = tl (list_decode e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1))) =\n    tl (Partial_Recursive.list_decode e)", "using * Suc_d"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode e = tuple_decode (pdec1 d) (pdec2 d)\n  e = Suc d\n\ngoal (1 subgoal):\n 1. tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1))) =\n    tl (Partial_Recursive.list_decode e)", "by simp"], ["proof (state)\nthis:\n  tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1))) =\n  tl (Partial_Recursive.list_decode e)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "also"], ["proof (state)\nthis:\n  tl (tuple_decode (pdec1 (e - 1)) (pdec2 (e - 1))) =\n  tl (Partial_Recursive.list_decode e)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "have \"... = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (Partial_Recursive.list_decode e) = xs", "using xxs"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode e = x # xs\n\ngoal (1 subgoal):\n 1. tl (Partial_Recursive.list_decode e) = xs", "by simp"], ["proof (state)\nthis:\n  tl (Partial_Recursive.list_decode e) = xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "finally"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  xs", "have \"?lhs = xs\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  xs\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n    xs", "."], ["proof (state)\nthis:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  xs", "have \"list_encode ?lhs = list_encode xs\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode\n   (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1)))) =\n  xs\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode\n     (Partial_Recursive.list_decode\n       (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))) =\n    Partial_Recursive.list_encode xs", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))) =\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))) =\n  Partial_Recursive.list_encode xs", "have \"Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) = list_encode xs\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))) =\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n    Partial_Recursive.list_encode xs", "using list_encode_decode"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode\n     (Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))) =\n  Partial_Recursive.list_encode xs\n  Partial_Recursive.list_encode (Partial_Recursive.list_decode ?n) = ?n\n\ngoal (1 subgoal):\n 1. Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n    Partial_Recursive.list_encode xs", "by metis"], ["proof (state)\nthis:\n  Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       \\<lbrakk>e = Suc d; pdec1 d = Suc nat\\<rbrakk>\n       \\<Longrightarrow> e_tl e =\n                         (if e = 0 then 0\n                          else if pdec1 (e - 1) = 0 then 0\n                               else Suc (prod_encode\n    (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "then"], ["proof (chain)\npicking this:\n  Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n  Partial_Recursive.list_encode xs", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "using ** Suc_d Suc"], ["proof (prove)\nusing this:\n  Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))) =\n  Partial_Recursive.list_encode xs\n  e_tl e = Partial_Recursive.list_encode xs\n  e = Suc d\n  pdec1 d = Suc a\n\ngoal (1 subgoal):\n 1. e_tl e =\n    (if e = 0 then 0\n     else if pdec1 (e - 1) = 0 then 0\n          else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))", "by simp"], ["proof (state)\nthis:\n  e_tl e =\n  (if e = 0 then 0\n   else if pdec1 (e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_tl e =\n  (if e = 0 then 0\n   else if pdec1 (e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (e - 1) - 1, pdec22 (e - 1))))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_tl \\<equiv>\n let r = Cn 1 r_pdec1 [r_dec]\n in Cn 1 r_ifz\n     [Id 1 0,\n      Z,\n      Cn 1 r_ifz\n       [r, Z, Cn 1 S [Cn 1 r_prod_encode [Cn 1 r_dec [r], Cn 1 r_pdec22 [r_dec]]]]]\""], ["", "lemma r_tl_prim [simp]: \"prim_recfn 1 r_tl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_tl", "unfolding r_tl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (let r = Cn 1 r_pdec1 [r_dec]\n      in Cn 1 r_ifz\n          [recf.Id 1 0, Z,\n           Cn 1 r_ifz\n            [r, Z,\n             Cn 1 S\n              [Cn 1 r_prod_encode\n                [Cn 1 r_dec [r], Cn 1 r_pdec22 [r_dec]]]]])", "by (simp add: Let_def)"], ["", "lemma r_tl [simp]: \"eval r_tl [e] \\<down>= e_tl e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_tl [e] \\<down>= e_tl e", "unfolding r_tl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (let r = Cn 1 r_pdec1 [r_dec]\n      in Cn 1 r_ifz\n          [recf.Id 1 0, Z,\n           Cn 1 r_ifz\n            [r, Z,\n             Cn 1 S\n              [Cn 1 r_prod_encode\n                [Cn 1 r_dec [r], Cn 1 r_pdec22 [r_dec]]]]])\n     [e] \\<down>=\n    e_tl e", "using e_tl_elementary"], ["proof (prove)\nusing this:\n  e_tl ?e =\n  (if ?e = 0 then 0\n   else if pdec1 (?e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (?e - 1) - 1, pdec22 (?e - 1))))\n\ngoal (1 subgoal):\n 1. eval\n     (let r = Cn 1 r_pdec1 [r_dec]\n      in Cn 1 r_ifz\n          [recf.Id 1 0, Z,\n           Cn 1 r_ifz\n            [r, Z,\n             Cn 1 S\n              [Cn 1 r_prod_encode\n                [Cn 1 r_dec [r], Cn 1 r_pdec22 [r_dec]]]]])\n     [e] \\<down>=\n    e_tl e", "by (simp add: Let_def)"], ["", "text \\<open>We define the head of the empty encoded list to be zero.\\<close>"], ["", "definition e_hd :: \"nat \\<Rightarrow> nat\" where\n  \"e_hd e \\<equiv> if e = 0 then 0 else hd (list_decode e)\""], ["", "lemma e_hd [simp]:\n  assumes \"list_decode e = x # xs\"\n  shows \"e_hd e = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd e = x", "using e_hd_def assms"], ["proof (prove)\nusing this:\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n  Partial_Recursive.list_decode e = x # xs\n\ngoal (1 subgoal):\n 1. e_hd e = x", "by auto"], ["", "lemma e_hd_0 [simp]: \"e_hd 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd 0 = 0", "using e_hd_def"], ["proof (prove)\nusing this:\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. e_hd 0 = 0", "by simp"], ["", "lemma e_hd_neq_0 [simp]:\n  assumes \"e \\<noteq> 0\"\n  shows \"e_hd e = hd (list_decode e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd e = hd (Partial_Recursive.list_decode e)", "using e_hd_def assms"], ["proof (prove)\nusing this:\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_hd e = hd (Partial_Recursive.list_decode e)", "by simp"], ["", "definition \"r_hd \\<equiv>\n  Cn 1 r_ifz [Cn 1 r_pdec1 [r_dec], Cn 1 r_pdec2 [r_dec], Cn 1 r_pdec12 [r_dec]]\""], ["", "lemma r_hd_prim [simp]: \"prim_recfn 1 r_hd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_hd", "unfolding r_hd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [Cn 1 r_pdec1 [r_dec], Cn 1 r_pdec2 [r_dec], Cn 1 r_pdec12 [r_dec]])", "by simp"], ["", "lemma r_hd [simp]: \"eval r_hd [e] \\<down>= e_hd e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_hd [e] \\<down>= e_hd e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_hd [e] \\<down>= e_hd e", "have \"e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "proof (cases e)"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_hd e =\n       (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "case 0"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n 2. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_hd e =\n       (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "then"], ["proof (chain)\npicking this:\n  e = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  e = 0\n\ngoal (1 subgoal):\n 1. e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "using pdec1_zero pdec2_le"], ["proof (prove)\nusing this:\n  e = 0\n  pdec1 0 = 0\n  pdec2 ?i \\<le> ?i\n\ngoal (1 subgoal):\n 1. e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "by auto"], ["proof (state)\nthis:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_hd e =\n       (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_hd e =\n       (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "case (Suc d)"], ["proof (state)\nthis:\n  e = Suc d\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       e = Suc nat \\<Longrightarrow>\n       e_hd e =\n       (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "then"], ["proof (chain)\npicking this:\n  e = Suc d", "show ?thesis"], ["proof (prove)\nusing this:\n  e = Suc d\n\ngoal (1 subgoal):\n 1. e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "by (cases \"pdec1 d\") (simp_all add: pdec1_zero)"], ["proof (state)\nthis:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n\ngoal (1 subgoal):\n 1. eval r_hd [e] \\<down>= e_hd e", "then"], ["proof (chain)\npicking this:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n\ngoal (1 subgoal):\n 1. eval r_hd [e] \\<down>= e_hd e", "unfolding r_hd_def"], ["proof (prove)\nusing this:\n  e_hd e = (if pdec1 (e - 1) = 0 then pdec2 (e - 1) else pdec12 (e - 1))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [Cn 1 r_pdec1 [r_dec], Cn 1 r_pdec2 [r_dec], Cn 1 r_pdec12 [r_dec]])\n     [e] \\<down>=\n    e_hd e", "by simp"], ["proof (state)\nthis:\n  eval r_hd [e] \\<down>= e_hd e\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation e_length :: \"nat \\<Rightarrow> nat\" where\n  \"e_length e \\<equiv> length (list_decode e)\""], ["", "lemma e_length_0: \"e_length e = 0 \\<Longrightarrow> e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length e = 0 \\<Longrightarrow> e = 0", "by (metis list_encode.simps(1) length_0_conv list_encode_decode)"], ["", "definition \"r_length \\<equiv> Cn 1 r_ifz [Id 1 0, Z, Cn 1 S [Cn 1 r_pdec1 [r_dec]]]\""], ["", "lemma r_length_prim [simp]: \"prim_recfn 1 r_length\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_length", "unfolding r_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz [recf.Id 1 0, Z, Cn 1 S [Cn 1 r_pdec1 [r_dec]]])", "by simp"], ["", "lemma r_length [simp]: \"eval r_length [e] \\<down>= e_length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_length [e] \\<down>= e_length e", "unfolding r_length_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_ifz [recf.Id 1 0, Z, Cn 1 S [Cn 1 r_pdec1 [r_dec]]])\n     [e] \\<down>=\n    e_length e", "by (cases e) simp_all"], ["", "text \\<open>Accessing an encoded list out of bounds yields zero.\\<close>"], ["", "definition e_nth :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_nth e n \\<equiv> if e = 0 then 0 else e_tuple_nth (pdec1 (e - 1)) (pdec2 (e - 1)) n\""], ["", "lemma e_nth [simp]:\n  \"e_nth e n = (if n < e_length e then (list_decode e) ! n else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth e n =\n    (if n < e_length e then Partial_Recursive.list_decode e ! n else 0)", "by (cases e) (simp_all add: e_nth_def e_tuple_nth_def)"], ["", "lemma e_hd_nth0: \"e_hd e = e_nth e 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd e = e_nth e 0", "by (simp add: e_hd_def e_length_0 hd_conv_nth)"], ["", "definition \"r_nth \\<equiv>\n  Cn 2 r_ifz\n   [Id 2 0,\n    r_constn 1 0,\n    Cn 2 r_tuple_nth\n     [Cn 2 r_pdec1 [r_dummy 1 r_dec], Cn 2 r_pdec2 [r_dummy 1 r_dec], Id 2 1]]\""], ["", "lemma r_nth_prim [simp]: \"prim_recfn 2 r_nth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_nth", "unfolding r_nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifz\n       [recf.Id 2 0, r_constn 1 0,\n        Cn 2 r_tuple_nth\n         [Cn 2 r_pdec1 [r_dummy 1 r_dec], Cn 2 r_pdec2 [r_dummy 1 r_dec],\n          recf.Id 2 1]])", "using r_tuple_nth_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_tuple_nth\n\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifz\n       [recf.Id 2 0, r_constn 1 0,\n        Cn 2 r_tuple_nth\n         [Cn 2 r_pdec1 [r_dummy 1 r_dec], Cn 2 r_pdec2 [r_dummy 1 r_dec],\n          recf.Id 2 1]])", "by simp"], ["", "lemma r_nth [simp]: \"eval r_nth [e, n] \\<down>= e_nth e n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nth [e, n] \\<down>= e_nth e n", "unfolding r_nth_def e_nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifz\n       [recf.Id 2 0, r_constn 1 0,\n        Cn 2 r_tuple_nth\n         [Cn 2 r_pdec1 [r_dummy 1 r_dec], Cn 2 r_pdec2 [r_dummy 1 r_dec],\n          recf.Id 2 1]])\n     [e, n] \\<down>=\n    (if e = 0 then 0 else e_tuple_nth (pdec1 (e - 1)) (pdec2 (e - 1)) n)", "using r_tuple_nth_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_tuple_nth\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifz\n       [recf.Id 2 0, r_constn 1 0,\n        Cn 2 r_tuple_nth\n         [Cn 2 r_pdec1 [r_dummy 1 r_dec], Cn 2 r_pdec2 [r_dummy 1 r_dec],\n          recf.Id 2 1]])\n     [e, n] \\<down>=\n    (if e = 0 then 0 else e_tuple_nth (pdec1 (e - 1)) (pdec2 (e - 1)) n)", "by simp"], ["", "definition \"r_rev_aux \\<equiv>\n  Pr 1 r_hd (Cn 3 r_prod_encode [Cn 3 r_nth [Id 3 2, Cn 3 S [Id 3 0]], Id 3 1])\""], ["", "lemma r_rev_aux_prim: \"prim_recfn 2 r_rev_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_rev_aux", "unfolding r_rev_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Pr 1 r_hd\n       (Cn 3 r_prod_encode\n         [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1]))", "by simp"], ["", "lemma r_rev_aux:\n  assumes \"list_decode e = xs\" and \"length xs > 0\" and \"i < length xs\"\n  shows \"eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))", "using assms(3)"], ["proof (prove)\nusing this:\n  i < length xs\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))", "proof (induction i)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < length xs \\<Longrightarrow>\n    eval r_rev_aux [0, e] \\<down>= tuple_encode 0 (rev (take (Suc 0) xs))\n 2. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "case 0"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (2 subgoals):\n 1. 0 < length xs \\<Longrightarrow>\n    eval r_rev_aux [0, e] \\<down>= tuple_encode 0 (rev (take (Suc 0) xs))\n 2. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "show ?case"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [0, e] \\<down>= tuple_encode 0 (rev (take (Suc 0) xs))", "unfolding r_rev_aux_def"], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 r_hd\n       (Cn 3 r_prod_encode\n         [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1]))\n     [0, e] \\<down>=\n    tuple_encode 0 (rev (take (Suc 0) xs))", "using assms e_hd_def r_hd"], ["proof (prove)\nusing this:\n  0 < length xs\n  Partial_Recursive.list_decode e = xs\n  0 < length xs\n  i < length xs\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n  eval r_hd [?e] \\<down>= e_hd ?e\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 r_hd\n       (Cn 3 r_prod_encode\n         [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1]))\n     [0, e] \\<down>=\n    tuple_encode 0 (rev (take (Suc 0) xs))", "by (auto simp add: take_Suc)"], ["proof (state)\nthis:\n  eval r_rev_aux [0, e] \\<down>= tuple_encode 0 (rev (take (Suc 0) xs))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "case (Suc i)"], ["proof (state)\nthis:\n  i < length xs \\<Longrightarrow>\n  eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\n  Suc i < length xs\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "let ?g = \"Cn 3 r_prod_encode [Cn 3 r_nth [Id 3 2, Cn 3 S [Id 3 0]], Id 3 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "from Suc"], ["proof (chain)\npicking this:\n  i < length xs \\<Longrightarrow>\n  eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\n  Suc i < length xs", "have \"eval r_rev_aux [Suc i, e] = eval ?g [i, the (eval r_rev_aux [i, e]), e]\""], ["proof (prove)\nusing this:\n  i < length xs \\<Longrightarrow>\n  eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\n  Suc i < length xs\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [Suc i, e] =\n    eval\n     (Cn 3 r_prod_encode\n       [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n     [i, the (eval r_rev_aux [i, e]), e]", "unfolding r_rev_aux_def"], ["proof (prove)\nusing this:\n  i < length xs \\<Longrightarrow>\n  eval\n   (Pr 1 r_hd\n     (Cn 3 r_prod_encode\n       [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1]))\n   [i, e] \\<down>=\n  tuple_encode i (rev (take (Suc i) xs))\n  Suc i < length xs\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 r_hd\n       (Cn 3 r_prod_encode\n         [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1]))\n     [Suc i, e] =\n    eval\n     (Cn 3 r_prod_encode\n       [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n     [i, the (eval\n               (Pr 1 r_hd\n                 (Cn 3 r_prod_encode\n                   [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]],\n                    recf.Id 3 1]))\n               [i, e]),\n      e]", "by simp"], ["proof (state)\nthis:\n  eval r_rev_aux [Suc i, e] =\n  eval\n   (Cn 3 r_prod_encode\n     [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n   [i, the (eval r_rev_aux [i, e]), e]\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "also"], ["proof (state)\nthis:\n  eval r_rev_aux [Suc i, e] =\n  eval\n   (Cn 3 r_prod_encode\n     [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n   [i, the (eval r_rev_aux [i, e]), e]\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "have \"... \\<down>= prod_encode (xs ! (Suc i), tuple_encode i (rev (take (Suc i) xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_prod_encode\n       [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n     [i, the (eval r_rev_aux [i, e]), e] \\<down>=\n    prod_encode (xs ! Suc i, tuple_encode i (rev (take (Suc i) xs)))", "using Suc"], ["proof (prove)\nusing this:\n  i < length xs \\<Longrightarrow>\n  eval r_rev_aux [i, e] \\<down>= tuple_encode i (rev (take (Suc i) xs))\n  Suc i < length xs\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_prod_encode\n       [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n     [i, the (eval r_rev_aux [i, e]), e] \\<down>=\n    prod_encode (xs ! Suc i, tuple_encode i (rev (take (Suc i) xs)))", "by (simp add: assms(1))"], ["proof (state)\nthis:\n  eval\n   (Cn 3 r_prod_encode\n     [Cn 3 r_nth [recf.Id 3 2, Cn 3 S [recf.Id 3 0]], recf.Id 3 1])\n   [i, the (eval r_rev_aux [i, e]), e] \\<down>=\n  prod_encode (xs ! Suc i, tuple_encode i (rev (take (Suc i) xs)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length xs \\<Longrightarrow>\n                eval r_rev_aux [i, e] \\<down>=\n                tuple_encode i (rev (take (Suc i) xs));\n        Suc i < length xs\\<rbrakk>\n       \\<Longrightarrow> eval r_rev_aux [Suc i, e] \\<down>=\n                         tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "finally"], ["proof (chain)\npicking this:\n  eval r_rev_aux [Suc i, e] \\<down>=\n  prod_encode (xs ! Suc i, tuple_encode i (rev (take (Suc i) xs)))", "show ?case"], ["proof (prove)\nusing this:\n  eval r_rev_aux [Suc i, e] \\<down>=\n  prod_encode (xs ! Suc i, tuple_encode i (rev (take (Suc i) xs)))\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [Suc i, e] \\<down>=\n    tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))", "by (simp add: Suc.prems take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  eval r_rev_aux [Suc i, e] \\<down>=\n  tuple_encode (Suc i) (rev (take (Suc (Suc i)) xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary r_rev_aux_full:\n  assumes \"list_decode e = xs\" and \"length xs > 0\"\n  shows \"eval r_rev_aux [length xs - 1, e] \\<down>= tuple_encode (length xs - 1) (rev xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_rev_aux [length xs - 1, e] \\<down>=\n    tuple_encode (length xs - 1) (rev xs)", "using r_rev_aux assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>Partial_Recursive.list_decode ?e = ?xs; 0 < length ?xs;\n   ?i < length ?xs\\<rbrakk>\n  \\<Longrightarrow> eval r_rev_aux [?i, ?e] \\<down>=\n                    tuple_encode ?i (rev (take (Suc ?i) ?xs))\n  Partial_Recursive.list_decode e = xs\n  0 < length xs\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [length xs - 1, e] \\<down>=\n    tuple_encode (length xs - 1) (rev xs)", "by simp"], ["", "lemma r_rev_aux_total: \"eval r_rev_aux [i, e] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_rev_aux [i, e] \\<down>", "using r_rev_aux_prim totalE"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_rev_aux\n  \\<lbrakk>Partial_Recursive.total ?f; recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval ?f ?xs \\<down>\n\ngoal (1 subgoal):\n 1. eval r_rev_aux [i, e] \\<down>", "by fastforce"], ["", "definition \"r_rev \\<equiv>\n  Cn 1 r_ifz\n   [Id 1 0,\n    Z,\n    Cn 1 S\n     [Cn 1 r_prod_encode\n      [Cn 1 r_dec [r_length], Cn 1 r_rev_aux [Cn 1 r_dec [r_length], Id 1 0]]]]\""], ["", "lemma r_rev_prim [simp]: \"prim_recfn 1 r_rev\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_rev", "unfolding r_rev_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [recf.Id 1 0, Z,\n        Cn 1 S\n         [Cn 1 r_prod_encode\n           [Cn 1 r_dec [r_length],\n            Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]]])", "using r_rev_aux_prim"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_rev_aux\n\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [recf.Id 1 0, Z,\n        Cn 1 S\n         [Cn 1 r_prod_encode\n           [Cn 1 r_dec [r_length],\n            Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]]])", "by simp"], ["", "lemma r_rev [simp]: \"eval r_rev [e] \\<down>= list_encode (rev (list_decode e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "let ?d = \"Cn 1 r_dec [r_length]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "let ?a = \"Cn 1 r_rev_aux [?d, Id 1 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "let ?p = \"Cn 1 r_prod_encode [?d, ?a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "let ?s = \"Cn 1 S [?p]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "have eval_a: \"eval ?a [e] = eval r_rev_aux [e_length e - 1, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n    eval r_rev_aux [e_length e - 1, e]", "using r_rev_aux_prim"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_rev_aux\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n    eval r_rev_aux [e_length e - 1, e]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]", "have \"eval ?s [e] \\<down>\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>", "using r_rev_aux_prim"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]\n  prim_recfn 2 r_rev_aux\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>", "by (simp add: r_rev_aux_total)"], ["proof (state)\nthis:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>", "have *: \"eval r_rev [e] \\<down>= (if e = 0 then 0 else the (eval ?s [e]))\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    (if e = 0 then 0\n     else the (eval\n                (Cn 1 S\n                  [Cn 1 r_prod_encode\n                    [Cn 1 r_dec [r_length],\n                     Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n                [e]))", "using r_rev_aux_prim"], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>\n  prim_recfn 2 r_rev_aux\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    (if e = 0 then 0\n     else the (eval\n                (Cn 1 S\n                  [Cn 1 r_prod_encode\n                    [Cn 1 r_dec [r_length],\n                     Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n                [e]))", "by (simp add: r_rev_def)"], ["proof (state)\nthis:\n  eval r_rev [e] \\<down>=\n  (if e = 0 then 0\n   else the (eval\n              (Cn 1 S\n                [Cn 1 r_prod_encode\n                  [Cn 1 r_dec [r_length],\n                   Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n              [e]))\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "proof (cases \"e = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))\n 2. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "case True"], ["proof (state)\nthis:\n  e = 0\n\ngoal (2 subgoals):\n 1. e = 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))\n 2. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  e = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  e = 0\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "using *"], ["proof (prove)\nusing this:\n  e = 0\n  eval r_rev [e] \\<down>=\n  (if e = 0 then 0\n   else the (eval\n              (Cn 1 S\n                [Cn 1 r_prod_encode\n                  [Cn 1 r_dec [r_length],\n                   Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n              [e]))\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "by simp"], ["proof (state)\nthis:\n  eval r_rev [e] \\<down>=\n  Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "case False"], ["proof (state)\nthis:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  e \\<noteq> 0", "obtain xs where xs: \"xs = list_decode e\" \"length xs > 0\""], ["proof (prove)\nusing this:\n  e \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs = Partial_Recursive.list_decode e;\n         0 < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using e_length_0"], ["proof (prove)\nusing this:\n  e \\<noteq> 0\n  e_length ?e = 0 \\<Longrightarrow> ?e = 0\n\ngoal (1 subgoal):\n 1. (\\<And>xs.\n        \\<lbrakk>xs = Partial_Recursive.list_decode e;\n         0 < length xs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = Partial_Recursive.list_decode e\n  0 < length xs\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  xs = Partial_Recursive.list_decode e\n  0 < length xs", "have len: \"length xs = e_length e\""], ["proof (prove)\nusing this:\n  xs = Partial_Recursive.list_decode e\n  0 < length xs\n\ngoal (1 subgoal):\n 1. length xs = e_length e", "by simp"], ["proof (state)\nthis:\n  length xs = e_length e\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "with eval_a"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]\n  length xs = e_length e", "have \"eval ?a [e] = eval r_rev_aux [length xs - 1, e]\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [e_length e - 1, e]\n  length xs = e_length e\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n    eval r_rev_aux [length xs - 1, e]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [length xs - 1, e]\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [length xs - 1, e]", "have \"eval ?a [e] \\<down>= tuple_encode (length xs - 1) (rev xs)\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [length xs - 1, e]\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n    tuple_encode (length xs - 1) (rev xs)", "using xs r_rev_aux_full"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] =\n  eval r_rev_aux [length xs - 1, e]\n  xs = Partial_Recursive.list_decode e\n  0 < length xs\n  \\<lbrakk>Partial_Recursive.list_decode ?e = ?xs; 0 < length ?xs\\<rbrakk>\n  \\<Longrightarrow> eval r_rev_aux [length ?xs - 1, ?e] \\<down>=\n                    tuple_encode (length ?xs - 1) (rev ?xs)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n    tuple_encode (length xs - 1) (rev xs)", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n  tuple_encode (length xs - 1) (rev xs)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n  tuple_encode (length xs - 1) (rev xs)", "have \"eval ?s [e] \\<down>=\n        Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n  tuple_encode (length xs - 1) (rev xs)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>=\n    Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))", "using len r_rev_aux_prim"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]) [e] \\<down>=\n  tuple_encode (length xs - 1) (rev xs)\n  length xs = e_length e\n  prim_recfn 2 r_rev_aux\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>=\n    Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))", "have \"eval ?s [e] \\<down>=\n        Suc (prod_encode\n              (length (rev xs) - 1, tuple_encode (length (rev xs) - 1) (rev xs)))\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode (length xs - 1, tuple_encode (length xs - 1) (rev xs)))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>=\n    Suc (prod_encode\n          (length (rev xs) - 1,\n           tuple_encode (length (rev xs) - 1) (rev xs)))", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode\n        (length (rev xs) - 1, tuple_encode (length (rev xs) - 1) (rev xs)))\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "moreover"], ["proof (state)\nthis:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode\n        (length (rev xs) - 1, tuple_encode (length (rev xs) - 1) (rev xs)))\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "have \"length (rev xs) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < length (rev xs)", "using xs"], ["proof (prove)\nusing this:\n  xs = Partial_Recursive.list_decode e\n  0 < length xs\n\ngoal (1 subgoal):\n 1. 0 < length (rev xs)", "by simp"], ["proof (state)\nthis:\n  0 < length (rev xs)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "ultimately"], ["proof (chain)\npicking this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode\n        (length (rev xs) - 1, tuple_encode (length (rev xs) - 1) (rev xs)))\n  0 < length (rev xs)", "have \"eval ?s [e] \\<down>= list_encode (rev xs)\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Suc (prod_encode\n        (length (rev xs) - 1, tuple_encode (length (rev xs) - 1) (rev xs)))\n  0 < length (rev xs)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 S\n       [Cn 1 r_prod_encode\n         [Cn 1 r_dec [r_length],\n          Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n     [e] \\<down>=\n    Partial_Recursive.list_encode (rev xs)", "by (metis list_encode.elims diff_Suc_1 length_Cons length_greater_0_conv)"], ["proof (state)\nthis:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Partial_Recursive.list_encode (rev xs)\n\ngoal (1 subgoal):\n 1. e \\<noteq> 0 \\<Longrightarrow>\n    eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Partial_Recursive.list_encode (rev xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Partial_Recursive.list_encode (rev xs)\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "using xs *"], ["proof (prove)\nusing this:\n  eval\n   (Cn 1 S\n     [Cn 1 r_prod_encode\n       [Cn 1 r_dec [r_length],\n        Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n   [e] \\<down>=\n  Partial_Recursive.list_encode (rev xs)\n  xs = Partial_Recursive.list_decode e\n  0 < length xs\n  eval r_rev [e] \\<down>=\n  (if e = 0 then 0\n   else the (eval\n              (Cn 1 S\n                [Cn 1 r_prod_encode\n                  [Cn 1 r_dec [r_length],\n                   Cn 1 r_rev_aux [Cn 1 r_dec [r_length], recf.Id 1 0]]])\n              [e]))\n\ngoal (1 subgoal):\n 1. eval r_rev [e] \\<down>=\n    Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))", "by simp"], ["proof (state)\nthis:\n  eval r_rev [e] \\<down>=\n  Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_rev [e] \\<down>=\n  Partial_Recursive.list_encode (rev (Partial_Recursive.list_decode e))\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation e_cons :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_cons e es \\<equiv> list_encode (e # list_decode es)\""], ["", "lemma e_cons_elementary:\n  \"e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "proof (cases \"es = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. es = 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\n 2. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "case True"], ["proof (state)\nthis:\n  es = 0\n\ngoal (2 subgoals):\n 1. es = 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\n 2. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "then"], ["proof (chain)\npicking this:\n  es = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  es = 0\n\ngoal (1 subgoal):\n 1. e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "by simp"], ["proof (state)\nthis:\n  e_cons e es =\n  (if es = 0 then Suc (prod_encode (0, e))\n   else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\n\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "case False"], ["proof (state)\nthis:\n  es \\<noteq> 0\n\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "then"], ["proof (chain)\npicking this:\n  es \\<noteq> 0", "have \"e_length es = Suc (pdec1 (es - 1))\""], ["proof (prove)\nusing this:\n  es \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_length es = Suc (pdec1 (es - 1))", "by (metis list_decode.elims diff_Suc_1 tuple_decode_length)"], ["proof (state)\nthis:\n  e_length es = Suc (pdec1 (es - 1))\n\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "moreover"], ["proof (state)\nthis:\n  e_length es = Suc (pdec1 (es - 1))\n\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "have \"es = e_tl (list_encode (e # list_decode es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. es = e_tl (e_cons e es)", "by (metis list.sel(3) list_decode_encode list_encode_decode)"], ["proof (state)\nthis:\n  es = e_tl (e_cons e es)\n\ngoal (1 subgoal):\n 1. es \\<noteq> 0 \\<Longrightarrow>\n    e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "ultimately"], ["proof (chain)\npicking this:\n  e_length es = Suc (pdec1 (es - 1))\n  es = e_tl (e_cons e es)", "show ?thesis"], ["proof (prove)\nusing this:\n  e_length es = Suc (pdec1 (es - 1))\n  es = e_tl (e_cons e es)\n\ngoal (1 subgoal):\n 1. e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "using False e_tl_elementary"], ["proof (prove)\nusing this:\n  e_length es = Suc (pdec1 (es - 1))\n  es = e_tl (e_cons e es)\n  es \\<noteq> 0\n  e_tl ?e =\n  (if ?e = 0 then 0\n   else if pdec1 (?e - 1) = 0 then 0\n        else Suc (prod_encode (pdec1 (?e - 1) - 1, pdec22 (?e - 1))))\n\ngoal (1 subgoal):\n 1. e_cons e es =\n    (if es = 0 then Suc (prod_encode (0, e))\n     else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))", "by (metis list_decode.simps(2) diff_Suc_1 list_encode_decode prod.sel(1)\n      prod_encode_inverse snd_conv tuple_decode.simps(2))"], ["proof (state)\nthis:\n  e_cons e es =\n  (if es = 0 then Suc (prod_encode (0, e))\n   else Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1)))))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_cons_else \\<equiv>\n  Cn 2 S\n   [Cn 2 r_prod_encode\n     [Cn 2 r_length\n       [Id 2 1], Cn 2 r_prod_encode [Id 2 0, Cn 2 r_pdec2 [Cn 2 r_dec [Id 2 1]]]]]\""], ["", "lemma r_cons_else_prim: \"prim_recfn 2 r_cons_else\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_cons_else", "unfolding r_cons_else_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 S\n       [Cn 2 r_prod_encode\n         [Cn 2 r_length [recf.Id 2 1],\n          Cn 2 r_prod_encode\n           [recf.Id 2 0, Cn 2 r_pdec2 [Cn 2 r_dec [recf.Id 2 1]]]]])", "by simp"], ["", "lemma r_cons_else:\n  \"eval r_cons_else [e, es] \\<down>=\n    Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_cons_else [e, es] \\<down>=\n    Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1))))", "unfolding r_cons_else_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 S\n       [Cn 2 r_prod_encode\n         [Cn 2 r_length [recf.Id 2 1],\n          Cn 2 r_prod_encode\n           [recf.Id 2 0, Cn 2 r_pdec2 [Cn 2 r_dec [recf.Id 2 1]]]]])\n     [e, es] \\<down>=\n    Suc (prod_encode (e_length es, prod_encode (e, pdec2 (es - 1))))", "by simp"], ["", "definition \"r_cons \\<equiv>\n  Cn 2 r_ifz\n    [Id 2 1, Cn 2 S [Cn 2 r_prod_encode [r_constn 1 0, Id 2 0]], r_cons_else]\""], ["", "lemma r_cons_prim [simp]: \"prim_recfn 2 r_cons\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_cons", "unfolding r_cons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifz\n       [recf.Id 2 1,\n        Cn 2 S [Cn 2 r_prod_encode [r_constn 1 0, recf.Id 2 0]],\n        r_cons_else])", "using r_cons_else_prim"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_cons_else\n\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifz\n       [recf.Id 2 1,\n        Cn 2 S [Cn 2 r_prod_encode [r_constn 1 0, recf.Id 2 0]],\n        r_cons_else])", "by simp"], ["", "lemma r_cons [simp]: \"eval r_cons [e, es] \\<down>= e_cons e es\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_cons [e, es] \\<down>= e_cons e es", "unfolding r_cons_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifz\n       [recf.Id 2 1,\n        Cn 2 S [Cn 2 r_prod_encode [r_constn 1 0, recf.Id 2 0]],\n        r_cons_else])\n     [e, es] \\<down>=\n    e_cons e es", "using r_cons_else_prim r_cons_else e_cons_elementary"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_cons_else\n  eval r_cons_else [?e, ?es] \\<down>=\n  Suc (prod_encode (e_length ?es, prod_encode (?e, pdec2 (?es - 1))))\n  e_cons ?e ?es =\n  (if ?es = 0 then Suc (prod_encode (0, ?e))\n   else Suc (prod_encode (e_length ?es, prod_encode (?e, pdec2 (?es - 1)))))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifz\n       [recf.Id 2 1,\n        Cn 2 S [Cn 2 r_prod_encode [r_constn 1 0, recf.Id 2 0]],\n        r_cons_else])\n     [e, es] \\<down>=\n    e_cons e es", "by simp"], ["", "abbreviation e_snoc :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_snoc es e \\<equiv> list_encode (list_decode es @ [e])\""], ["", "lemma e_nth_snoc_small [simp]:\n  assumes \"n < e_length b\"\n  shows \"e_nth (e_snoc b z) n = e_nth b n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_snoc b z) n = e_nth b n", "using assms"], ["proof (prove)\nusing this:\n  n < e_length b\n\ngoal (1 subgoal):\n 1. e_nth (e_snoc b z) n = e_nth b n", "by (simp add: nth_append)"], ["", "lemma e_hd_snoc [simp]:\n  assumes \"e_length b > 0\"\n  shows \"e_hd (e_snoc b x) = e_hd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "from assms"], ["proof (chain)\npicking this:\n  0 < e_length b", "have \"b \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < e_length b\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "using less_imp_neq"], ["proof (prove)\nusing this:\n  0 < e_length b\n  ?x < ?y \\<Longrightarrow> ?x \\<noteq> ?y\n\ngoal (1 subgoal):\n 1. b \\<noteq> 0", "by force"], ["proof (state)\nthis:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "then"], ["proof (chain)\npicking this:\n  b \\<noteq> 0", "have hd: \"e_hd b = hd (list_decode b)\""], ["proof (prove)\nusing this:\n  b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_hd b = hd (Partial_Recursive.list_decode b)", "by simp"], ["proof (state)\nthis:\n  e_hd b = hd (Partial_Recursive.list_decode b)\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "have \"e_length (e_snoc b x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < e_length (e_snoc b x)", "by simp"], ["proof (state)\nthis:\n  0 < e_length (e_snoc b x)\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "then"], ["proof (chain)\npicking this:\n  0 < e_length (e_snoc b x)", "have \"e_snoc b x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  0 < e_length (e_snoc b x)\n\ngoal (1 subgoal):\n 1. e_snoc b x \\<noteq> 0", "using not_gr_zero"], ["proof (prove)\nusing this:\n  0 < e_length (e_snoc b x)\n  (\\<not> (0::?'a) < ?n) = (?n = (0::?'a))\n\ngoal (1 subgoal):\n 1. e_snoc b x \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  e_snoc b x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "then"], ["proof (chain)\npicking this:\n  e_snoc b x \\<noteq> 0", "have \"e_hd (e_snoc b x) = hd (list_decode (e_snoc b x))\""], ["proof (prove)\nusing this:\n  e_snoc b x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = hd (Partial_Recursive.list_decode (e_snoc b x))", "by simp"], ["proof (state)\nthis:\n  e_hd (e_snoc b x) = hd (Partial_Recursive.list_decode (e_snoc b x))\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "with assms hd"], ["proof (chain)\npicking this:\n  0 < e_length b\n  e_hd b = hd (Partial_Recursive.list_decode b)\n  e_hd (e_snoc b x) = hd (Partial_Recursive.list_decode (e_snoc b x))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < e_length b\n  e_hd b = hd (Partial_Recursive.list_decode b)\n  e_hd (e_snoc b x) = hd (Partial_Recursive.list_decode (e_snoc b x))\n\ngoal (1 subgoal):\n 1. e_hd (e_snoc b x) = e_hd b", "by simp"], ["proof (state)\nthis:\n  e_hd (e_snoc b x) = e_hd b\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_snoc \\<equiv> Cn 2 r_rev [Cn 2 r_cons [Id 2 1, Cn 2 r_rev [Id 2 0]]]\""], ["", "lemma r_snoc_prim [simp]: \"prim_recfn 2 r_snoc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_snoc", "unfolding r_snoc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_rev [Cn 2 r_cons [recf.Id 2 1, Cn 2 r_rev [recf.Id 2 0]]])", "by simp"], ["", "lemma r_snoc [simp]: \"eval r_snoc [es, e] \\<down>= e_snoc es e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_snoc [es, e] \\<down>= e_snoc es e", "unfolding r_snoc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_rev [Cn 2 r_cons [recf.Id 2 1, Cn 2 r_rev [recf.Id 2 0]]])\n     [es, e] \\<down>=\n    e_snoc es e", "by simp"], ["", "abbreviation e_butlast :: \"nat \\<Rightarrow> nat\" where\n  \"e_butlast e \\<equiv> list_encode (butlast (list_decode e))\""], ["", "abbreviation e_take :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_take n x \\<equiv> list_encode (take n (list_decode x))\""], ["", "definition \"r_take \\<equiv>\n  Cn 2 r_ifle\n   [Id 2 0, Cn 2 r_length [Id 2 1],\n    Pr 1 Z (Cn 3 r_snoc [Id 3 1, Cn 3 r_nth [Id 3 2, Id 3 0]]),\n    Id 2 1]\""], ["", "lemma r_take_prim [simp]: \"prim_recfn 2 r_take\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_take", "unfolding r_take_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (Cn 2 r_ifle\n       [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n        Pr 1 Z\n         (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n        recf.Id 2 1])", "by simp_all"], ["", "lemma r_take:\n  assumes \"x = list_encode es\"\n  shows \"eval r_take [n, x] \\<down>= list_encode (take n es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "let ?g = \"Cn 3 r_snoc [Id 3 1, Cn 3 r_nth [Id 3 2, Id 3 0]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "let ?h = \"Pr 1 Z ?g\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "have \"total ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))", "using Mn_free_imp_total"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "have \"m \\<le> length es \\<Longrightarrow> eval ?h [m, x] \\<down>= list_encode (take m es)\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<le> length es \\<Longrightarrow>\n    eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [m, x] \\<down>=\n    Partial_Recursive.list_encode (take m es)", "proof (induction m)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> length es \\<Longrightarrow>\n    eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [0, x] \\<down>=\n    Partial_Recursive.list_encode (take 0 es)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> length es\n\ngoal (2 subgoals):\n 1. 0 \\<le> length es \\<Longrightarrow>\n    eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [0, x] \\<down>=\n    Partial_Recursive.list_encode (take 0 es)\n 2. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "then"], ["proof (chain)\npicking this:\n  0 \\<le> length es", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> length es\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [0, x] \\<down>=\n    Partial_Recursive.list_encode (take 0 es)", "using assms r_take_def"], ["proof (prove)\nusing this:\n  0 \\<le> length es\n  x = Partial_Recursive.list_encode es\n  r_take \\<equiv>\n  Cn 2 r_ifle\n   [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n    Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [0, x] \\<down>=\n    Partial_Recursive.list_encode (take 0 es)", "by (simp add: r_take_def)"], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [0, x] \\<down>=\n  Partial_Recursive.list_encode (take 0 es)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "case (Suc m)"], ["proof (state)\nthis:\n  m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [m, x] \\<down>=\n  Partial_Recursive.list_encode (take m es)\n  Suc m \\<le> length es\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "then"], ["proof (chain)\npicking this:\n  m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [m, x] \\<down>=\n  Partial_Recursive.list_encode (take m es)\n  Suc m \\<le> length es", "have \"m < length es\""], ["proof (prove)\nusing this:\n  m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [m, x] \\<down>=\n  Partial_Recursive.list_encode (take m es)\n  Suc m \\<le> length es\n\ngoal (1 subgoal):\n 1. m < length es", "by simp"], ["proof (state)\nthis:\n  m < length es\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "then"], ["proof (chain)\npicking this:\n  m < length es", "have \"eval ?h [Suc m, x] = eval ?g [m, the (eval ?h [m, x]), x]\""], ["proof (prove)\nusing this:\n  m < length es\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [Suc m, x] =\n    eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, the (eval\n               (Pr 1 Z\n                 (Cn 3 r_snoc\n                   [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n               [m, x]),\n      x]", "using Suc r_take_def"], ["proof (prove)\nusing this:\n  m < length es\n  m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [m, x] \\<down>=\n  Partial_Recursive.list_encode (take m es)\n  Suc m \\<le> length es\n  r_take \\<equiv>\n  Cn 2 r_ifle\n   [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n    Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [Suc m, x] =\n    eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, the (eval\n               (Pr 1 Z\n                 (Cn 3 r_snoc\n                   [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n               [m, x]),\n      x]", "by simp"], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [Suc m, x] =\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, the (eval\n             (Pr 1 Z\n               (Cn 3 r_snoc\n                 [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n             [m, x]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "also"], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [Suc m, x] =\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, the (eval\n             (Pr 1 Z\n               (Cn 3 r_snoc\n                 [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n             [m, x]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "have \"... = eval ?g [m, list_encode (take m es), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, the (eval\n               (Pr 1 Z\n                 (Cn 3 r_snoc\n                   [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n               [m, x]),\n      x] =\n    eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, Partial_Recursive.list_encode (take m es), x]", "using Suc"], ["proof (prove)\nusing this:\n  m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [m, x] \\<down>=\n  Partial_Recursive.list_encode (take m es)\n  Suc m \\<le> length es\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, the (eval\n               (Pr 1 Z\n                 (Cn 3 r_snoc\n                   [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n               [m, x]),\n      x] =\n    eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, Partial_Recursive.list_encode (take m es), x]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, the (eval\n             (Pr 1 Z\n               (Cn 3 r_snoc\n                 [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n             [m, x]),\n    x] =\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, Partial_Recursive.list_encode (take m es), x]\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "also"], ["proof (state)\nthis:\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, the (eval\n             (Pr 1 Z\n               (Cn 3 r_snoc\n                 [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n             [m, x]),\n    x] =\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, Partial_Recursive.list_encode (take m es), x]\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "have \"... \\<down>= e_snoc (list_encode (take m es)) (es ! m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n     [m, Partial_Recursive.list_encode (take m es), x] \\<down>=\n    e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)", "by (simp add: \\<open>m < length es\\<close> assms)"], ["proof (state)\nthis:\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, Partial_Recursive.list_encode (take m es), x] \\<down>=\n  e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "also"], ["proof (state)\nthis:\n  eval (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]])\n   [m, Partial_Recursive.list_encode (take m es), x] \\<down>=\n  e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "have \"... \\<down>= list_encode ((take m es) @ [es ! m])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)) \\<down>=\n    Partial_Recursive.list_encode (take m es @ [es ! m])", "using list_decode_encode"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. Some\n     (e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)) \\<down>=\n    Partial_Recursive.list_encode (take m es @ [es ! m])", "by simp"], ["proof (state)\nthis:\n  Some\n   (e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)) \\<down>=\n  Partial_Recursive.list_encode (take m es @ [es ! m])\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "also"], ["proof (state)\nthis:\n  Some\n   (e_snoc (Partial_Recursive.list_encode (take m es)) (es ! m)) \\<down>=\n  Partial_Recursive.list_encode (take m es @ [es ! m])\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "have \"... \\<down>= list_encode (take (Suc m) es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (Partial_Recursive.list_encode (take m es @ [es ! m])) \\<down>=\n    Partial_Recursive.list_encode (take (Suc m) es)", "by (simp add: \\<open>m < length es\\<close> take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  Some (Partial_Recursive.list_encode (take m es @ [es ! m])) \\<down>=\n  Partial_Recursive.list_encode (take (Suc m) es)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       \\<lbrakk>m \\<le> length es \\<Longrightarrow>\n                eval\n                 (Pr 1 Z\n                   (Cn 3 r_snoc\n                     [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                 [m, x] \\<down>=\n                Partial_Recursive.list_encode (take m es);\n        Suc m \\<le> length es\\<rbrakk>\n       \\<Longrightarrow> eval\n                          (Pr 1 Z\n                            (Cn 3 r_snoc\n                              [recf.Id 3 1,\n                               Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                          [Suc m, x] \\<down>=\n                         Partial_Recursive.list_encode (take (Suc m) es)", "finally"], ["proof (chain)\npicking this:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [Suc m, x] \\<down>=\n  Partial_Recursive.list_encode (take (Suc m) es)", "show ?case"], ["proof (prove)\nusing this:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [Suc m, x] \\<down>=\n  Partial_Recursive.list_encode (take (Suc m) es)\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n     [Suc m, x] \\<down>=\n    Partial_Recursive.list_encode (take (Suc m) es)", "."], ["proof (state)\nthis:\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [Suc m, x] \\<down>=\n  Partial_Recursive.list_encode (take (Suc m) es)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "moreover"], ["proof (state)\nthis:\n  ?m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "have \"eval (Id 2 1) [m, x] \\<down>= list_encode (take m es)\" if \"m > length es\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (recf.Id 2 1) [m, x] \\<down>=\n    Partial_Recursive.list_encode (take m es)", "using that assms"], ["proof (prove)\nusing this:\n  length es < m\n  x = Partial_Recursive.list_encode es\n\ngoal (1 subgoal):\n 1. eval (recf.Id 2 1) [m, x] \\<down>=\n    Partial_Recursive.list_encode (take m es)", "by simp"], ["proof (state)\nthis:\n  length es < ?m \\<Longrightarrow>\n  eval (recf.Id 2 1) [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "moreover"], ["proof (state)\nthis:\n  length es < ?m \\<Longrightarrow>\n  eval (recf.Id 2 1) [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "have \"eval r_take [m, x] \\<down>=\n      (if m \\<le> e_length x then the (eval ?h [m, x]) else the (eval (Id 2 1) [m, x]))\"\n      for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_take [m, x] \\<down>=\n    (if m \\<le> e_length x\n     then the (eval\n                (Pr 1 Z\n                  (Cn 3 r_snoc\n                    [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                [m, x])\n     else the (eval (recf.Id 2 1) [m, x]))", "unfolding r_take_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifle\n       [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n        Pr 1 Z\n         (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n        recf.Id 2 1])\n     [m, x] \\<down>=\n    (if m \\<le> e_length x\n     then the (eval\n                (Pr 1 Z\n                  (Cn 3 r_snoc\n                    [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                [m, x])\n     else the (eval (recf.Id 2 1) [m, x]))", "using \\<open>total ?h\\<close>"], ["proof (prove)\nusing this:\n  Partial_Recursive.total\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifle\n       [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n        Pr 1 Z\n         (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n        recf.Id 2 1])\n     [m, x] \\<down>=\n    (if m \\<le> e_length x\n     then the (eval\n                (Pr 1 Z\n                  (Cn 3 r_snoc\n                    [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n                [m, x])\n     else the (eval (recf.Id 2 1) [m, x]))", "by simp"], ["proof (state)\nthis:\n  eval r_take [?m, x] \\<down>=\n  (if ?m \\<le> e_length x\n   then the (eval\n              (Pr 1 Z\n                (Cn 3 r_snoc\n                  [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n              [?m, x])\n   else the (eval (recf.Id 2 1) [?m, x]))\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "ultimately"], ["proof (chain)\npicking this:\n  ?m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  length es < ?m \\<Longrightarrow>\n  eval (recf.Id 2 1) [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  eval r_take [?m, x] \\<down>=\n  (if ?m \\<le> e_length x\n   then the (eval\n              (Pr 1 Z\n                (Cn 3 r_snoc\n                  [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n              [?m, x])\n   else the (eval (recf.Id 2 1) [?m, x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  length es < ?m \\<Longrightarrow>\n  eval (recf.Id 2 1) [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  eval r_take [?m, x] \\<down>=\n  (if ?m \\<le> e_length x\n   then the (eval\n              (Pr 1 Z\n                (Cn 3 r_snoc\n                  [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n              [?m, x])\n   else the (eval (recf.Id 2 1) [?m, x]))\n\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)", "unfolding r_take_def"], ["proof (prove)\nusing this:\n  ?m \\<le> length es \\<Longrightarrow>\n  eval\n   (Pr 1 Z\n     (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n   [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  length es < ?m \\<Longrightarrow>\n  eval (recf.Id 2 1) [?m, x] \\<down>=\n  Partial_Recursive.list_encode (take ?m es)\n  eval\n   (Cn 2 r_ifle\n     [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n      Pr 1 Z\n       (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n      recf.Id 2 1])\n   [?m, x] \\<down>=\n  (if ?m \\<le> e_length x\n   then the (eval\n              (Pr 1 Z\n                (Cn 3 r_snoc\n                  [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]))\n              [?m, x])\n   else the (eval (recf.Id 2 1) [?m, x]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifle\n       [recf.Id 2 0, Cn 2 r_length [recf.Id 2 1],\n        Pr 1 Z\n         (Cn 3 r_snoc [recf.Id 3 1, Cn 3 r_nth [recf.Id 3 2, recf.Id 3 0]]),\n        recf.Id 2 1])\n     [n, x] \\<down>=\n    Partial_Recursive.list_encode (take n es)", "by fastforce"], ["proof (state)\nthis:\n  eval r_take [n, x] \\<down>= Partial_Recursive.list_encode (take n es)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary r_take' [simp]: \"eval r_take [n, x] \\<down>= e_take n x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_take [n, x] \\<down>= e_take n x", "by (simp add: r_take)"], ["", "definition \"r_last \\<equiv> Cn 1 r_hd [r_rev]\""], ["", "lemma r_last_prim [simp]: \"prim_recfn 1 r_last\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_last", "unfolding r_last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_hd [r_rev])", "by simp"], ["", "lemma r_last [simp]:\n  assumes \"e = list_encode xs\" and \"length xs > 0\"\n  shows \"eval r_last [e] \\<down>= last xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "from assms(2)"], ["proof (chain)\npicking this:\n  0 < length xs", "have \"length (rev xs) > 0\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. 0 < length (rev xs)", "by simp"], ["proof (state)\nthis:\n  0 < length (rev xs)\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "then"], ["proof (chain)\npicking this:\n  0 < length (rev xs)", "have \"list_encode (rev xs) > 0\""], ["proof (prove)\nusing this:\n  0 < length (rev xs)\n\ngoal (1 subgoal):\n 1. 0 < Partial_Recursive.list_encode (rev xs)", "by (metis gr0I list.size(3) list_encode_0)"], ["proof (state)\nthis:\n  0 < Partial_Recursive.list_encode (rev xs)\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "moreover"], ["proof (state)\nthis:\n  0 < Partial_Recursive.list_encode (rev xs)\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "have \"eval r_last [e] = eval r_hd [the (eval r_rev [e])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_last [e] = eval r_hd [the (eval r_rev [e])]", "unfolding r_last_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_hd [r_rev]) [e] = eval r_hd [the (eval r_rev [e])]", "by simp"], ["proof (state)\nthis:\n  eval r_last [e] = eval r_hd [the (eval r_rev [e])]\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "ultimately"], ["proof (chain)\npicking this:\n  0 < Partial_Recursive.list_encode (rev xs)\n  eval r_last [e] = eval r_hd [the (eval r_rev [e])]", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < Partial_Recursive.list_encode (rev xs)\n  eval r_last [e] = eval r_hd [the (eval r_rev [e])]\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "using assms hd_rev"], ["proof (prove)\nusing this:\n  0 < Partial_Recursive.list_encode (rev xs)\n  eval r_last [e] = eval r_hd [the (eval r_rev [e])]\n  e = Partial_Recursive.list_encode xs\n  0 < length xs\n  ?xs \\<noteq> [] \\<Longrightarrow> hd (rev ?xs) = last ?xs\n\ngoal (1 subgoal):\n 1. eval r_last [e] \\<down>= last xs", "by auto"], ["proof (state)\nthis:\n  eval r_last [e] \\<down>= last xs\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_update_aux \\<equiv>\n  let\n    f = r_constn 2 0;\n    g = Cn 5 r_snoc\n         [Id 5 1, Cn 5 r_ifeq [Id 5 0, Id 5 3, Id 5 4, Cn 5 r_nth [Id 5 2, Id 5 0]]]\n  in Pr 3 f g\""], ["", "lemma r_update_aux_recfn: \"recfn 4 r_update_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 r_update_aux", "unfolding r_update_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4\n     (let f = r_constn 2 0\n      in Let (Cn 5 r_snoc\n               [recf.Id 5 1,\n                Cn 5 r_ifeq\n                 [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n                  Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]])\n          (Pr 3 f))", "by simp"], ["", "lemma r_update_aux:\n  assumes \"n \\<le> e_length b\"\n  shows \"eval r_update_aux [n, b, j, v] \\<down>= list_encode ((take n (list_decode b))[j:=v])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_update_aux [n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v])", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> e_length b\n\ngoal (1 subgoal):\n 1. eval r_update_aux [n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v])", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> e_length b \\<Longrightarrow>\n    eval r_update_aux [0, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take 0 (Partial_Recursive.list_decode b))[j := v])\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "case 0"], ["proof (state)\nthis:\n  0 \\<le> e_length b\n\ngoal (2 subgoals):\n 1. 0 \\<le> e_length b \\<Longrightarrow>\n    eval r_update_aux [0, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take 0 (Partial_Recursive.list_decode b))[j := v])\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  0 \\<le> e_length b", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> e_length b\n\ngoal (1 subgoal):\n 1. eval r_update_aux [0, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take 0 (Partial_Recursive.list_decode b))[j := v])", "unfolding r_update_aux_def"], ["proof (prove)\nusing this:\n  0 \\<le> e_length b\n\ngoal (1 subgoal):\n 1. eval\n     (let f = r_constn 2 0\n      in Let (Cn 5 r_snoc\n               [recf.Id 5 1,\n                Cn 5 r_ifeq\n                 [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n                  Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]])\n          (Pr 3 f))\n     [0, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take 0 (Partial_Recursive.list_decode b))[j := v])", "by simp"], ["proof (state)\nthis:\n  eval r_update_aux [0, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take 0 (Partial_Recursive.list_decode b))[j := v])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> e_length b \\<Longrightarrow>\n  eval r_update_aux [n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take n (Partial_Recursive.list_decode b))[j := v])\n  Suc n \\<le> e_length b\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  n \\<le> e_length b \\<Longrightarrow>\n  eval r_update_aux [n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take n (Partial_Recursive.list_decode b))[j := v])\n  Suc n \\<le> e_length b", "have n: \"n < e_length b\""], ["proof (prove)\nusing this:\n  n \\<le> e_length b \\<Longrightarrow>\n  eval r_update_aux [n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take n (Partial_Recursive.list_decode b))[j := v])\n  Suc n \\<le> e_length b\n\ngoal (1 subgoal):\n 1. n < e_length b", "by simp"], ["proof (state)\nthis:\n  n < e_length b\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "let ?a = \"Cn 5 r_nth [Id 5 2, Id 5 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "let ?b = \"Cn 5 r_ifeq [Id 5 0, Id 5 3, Id 5 4, ?a]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "define g where \"g \\<equiv> Cn 5 r_snoc [Id 5 1, ?b]\""], ["proof (state)\nthis:\n  g \\<equiv>\n  Cn 5 r_snoc\n   [recf.Id 5 1,\n    Cn 5 r_ifeq\n     [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n      Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  g \\<equiv>\n  Cn 5 r_snoc\n   [recf.Id 5 1,\n    Cn 5 r_ifeq\n     [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n      Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]]", "have g: \"eval g [n, r, b, j, v] \\<down>= e_snoc r (if n = j then v else e_nth b n)\" for r"], ["proof (prove)\nusing this:\n  g \\<equiv>\n  Cn 5 r_snoc\n   [recf.Id 5 1,\n    Cn 5 r_ifeq\n     [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n      Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]]\n\ngoal (1 subgoal):\n 1. eval g [n, r, b, j, v] \\<down>=\n    e_snoc r (if n = j then v else e_nth b n)", "by simp"], ["proof (state)\nthis:\n  eval g [n, ?r, b, j, v] \\<down>=\n  e_snoc ?r (if n = j then v else e_nth b n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "have \"Pr 3 (r_constn 2 0) g = r_update_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Pr 3 (r_constn 2 0) g = r_update_aux", "using r_update_aux_def g_def"], ["proof (prove)\nusing this:\n  r_update_aux \\<equiv>\n  let f = r_constn 2 0\n  in Let (Cn 5 r_snoc\n           [recf.Id 5 1,\n            Cn 5 r_ifeq\n             [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n              Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]])\n      (Pr 3 f)\n  g \\<equiv>\n  Cn 5 r_snoc\n   [recf.Id 5 1,\n    Cn 5 r_ifeq\n     [recf.Id 5 0, recf.Id 5 3, recf.Id 5 4,\n      Cn 5 r_nth [recf.Id 5 2, recf.Id 5 0]]]\n\ngoal (1 subgoal):\n 1. Pr 3 (r_constn 2 0) g = r_update_aux", "by simp"], ["proof (state)\nthis:\n  Pr 3 (r_constn 2 0) g = r_update_aux\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  Pr 3 (r_constn 2 0) g = r_update_aux", "have \"eval r_update_aux [Suc n, b, j, v] =\n      eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]\""], ["proof (prove)\nusing this:\n  Pr 3 (r_constn 2 0) g = r_update_aux\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] =\n    eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]", "using r_update_aux_recfn Suc n eval_Pr_converg_Suc"], ["proof (prove)\nusing this:\n  Pr 3 (r_constn 2 0) g = r_update_aux\n  recfn 4 r_update_aux\n  n \\<le> e_length b \\<Longrightarrow>\n  eval r_update_aux [n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take n (Partial_Recursive.list_decode b))[j := v])\n  Suc n \\<le> e_length b\n  n < e_length b\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (Suc ?x # ?xs) =\n                    eval ?g (?x # the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs)\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] =\n    eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]", "by (metis arity.simps(5) length_Cons list.size(3) nat_less_le\n      numeral_3_eq_3 option.simps(3))"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] =\n  eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  eval r_update_aux [Suc n, b, j, v] =\n  eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]", "have *: \"eval r_update_aux [Suc n, b, j, v] \\<down>= e_snoc\n      (list_encode ((take n (list_decode b))[j:=v]))\n      (if n = j then v else e_nth b n)\""], ["proof (prove)\nusing this:\n  eval r_update_aux [Suc n, b, j, v] =\n  eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    e_snoc\n     (Partial_Recursive.list_encode\n       ((take n (Partial_Recursive.list_decode b))[j := v]))\n     (if n = j then v else e_nth b n)", "using g Suc"], ["proof (prove)\nusing this:\n  eval r_update_aux [Suc n, b, j, v] =\n  eval g [n, the (eval r_update_aux [n, b, j, v]), b, j, v]\n  eval g [n, ?r, b, j, v] \\<down>=\n  e_snoc ?r (if n = j then v else e_nth b n)\n  n \\<le> e_length b \\<Longrightarrow>\n  eval r_update_aux [n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take n (Partial_Recursive.list_decode b))[j := v])\n  Suc n \\<le> e_length b\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    e_snoc\n     (Partial_Recursive.list_encode\n       ((take n (Partial_Recursive.list_decode b))[j := v]))\n     (if n = j then v else e_nth b n)", "by simp"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  e_snoc\n   (Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v]))\n   (if n = j then v else e_nth b n)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "consider (j_eq_n) \"j = n\" | (j_less_n) \"j < n\" | (j_gt_n) \"j > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>j = n \\<Longrightarrow> thesis; j < n \\<Longrightarrow> thesis;\n     n < j \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>j = n \\<Longrightarrow> ?thesis; j < n \\<Longrightarrow> ?thesis;\n   n < j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length b \\<Longrightarrow>\n                eval r_update_aux [n, b, j, v] \\<down>=\n                Partial_Recursive.list_encode\n                 ((take n (Partial_Recursive.list_decode b))[j := v]);\n        Suc n \\<le> e_length b\\<rbrakk>\n       \\<Longrightarrow> eval r_update_aux [Suc n, b, j, v] \\<down>=\n                         Partial_Recursive.list_encode\n                          ((take (Suc n) (Partial_Recursive.list_decode b))\n                           [j := v])", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>j = n \\<Longrightarrow> ?thesis; j < n \\<Longrightarrow> ?thesis;\n   n < j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>j = n \\<Longrightarrow> ?thesis; j < n \\<Longrightarrow> ?thesis;\n   n < j \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. j = n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 3. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "case j_eq_n"], ["proof (state)\nthis:\n  j = n\n\ngoal (3 subgoals):\n 1. j = n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 3. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "moreover"], ["proof (state)\nthis:\n  j = n\n\ngoal (3 subgoals):\n 1. j = n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 3. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "from this"], ["proof (chain)\npicking this:\n  j = n", "have \"(take (Suc n) (list_decode b))[j:=v] =\n        (take n (list_decode b))[j:=v] @ [v]\""], ["proof (prove)\nusing this:\n  j = n\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @ [v]", "using n"], ["proof (prove)\nusing this:\n  j = n\n  n < e_length b\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @ [v]", "by (metis length_list_update nth_list_update_eq take_Suc_conv_app_nth take_update_swap)"], ["proof (state)\nthis:\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @ [v]\n\ngoal (3 subgoals):\n 1. j = n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 3. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "ultimately"], ["proof (chain)\npicking this:\n  j = n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @ [v]", "show ?thesis"], ["proof (prove)\nusing this:\n  j = n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @ [v]\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "using *"], ["proof (prove)\nusing this:\n  j = n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @ [v]\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  e_snoc\n   (Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v]))\n   (if n = j then v else e_nth b n)\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "by simp"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n\ngoal (2 subgoals):\n 1. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "case j_less_n"], ["proof (state)\nthis:\n  j < n\n\ngoal (2 subgoals):\n 1. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "moreover"], ["proof (state)\nthis:\n  j < n\n\ngoal (2 subgoals):\n 1. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "from this"], ["proof (chain)\npicking this:\n  j < n", "have \"(take (Suc n) (list_decode b))[j:=v] =\n        (take n (list_decode b))[j:=v] @ [(list_decode b) ! n]\""], ["proof (prove)\nusing this:\n  j < n\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @\n    [Partial_Recursive.list_decode b ! n]", "using n"], ["proof (prove)\nusing this:\n  j < n\n  n < e_length b\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @\n    [Partial_Recursive.list_decode b ! n]", "by (simp add: le_eq_less_or_eq list_update_append min_absorb2 take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n\ngoal (2 subgoals):\n 1. j < n \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n 2. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "ultimately"], ["proof (chain)\npicking this:\n  j < n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]", "show ?thesis"], ["proof (prove)\nusing this:\n  j < n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "using *"], ["proof (prove)\nusing this:\n  j < n\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  e_snoc\n   (Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v]))\n   (if n = j then v else e_nth b n)\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "by auto"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n\ngoal (1 subgoal):\n 1. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "case j_gt_n"], ["proof (state)\nthis:\n  n < j\n\ngoal (1 subgoal):\n 1. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "moreover"], ["proof (state)\nthis:\n  n < j\n\ngoal (1 subgoal):\n 1. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "from this"], ["proof (chain)\npicking this:\n  n < j", "have \"(take (Suc n) (list_decode b))[j:=v] =\n        (take n (list_decode b))[j:=v] @ [(list_decode b) ! n]\""], ["proof (prove)\nusing this:\n  n < j\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @\n    [Partial_Recursive.list_decode b ! n]", "using n take_Suc_conv_app_nth"], ["proof (prove)\nusing this:\n  n < j\n  n < e_length b\n  ?i < length ?xs \\<Longrightarrow>\n  take (Suc ?i) ?xs = take ?i ?xs @ [?xs ! ?i]\n\ngoal (1 subgoal):\n 1. (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n    (take n (Partial_Recursive.list_decode b))[j := v] @\n    [Partial_Recursive.list_decode b ! n]", "by auto"], ["proof (state)\nthis:\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n\ngoal (1 subgoal):\n 1. n < j \\<Longrightarrow>\n    eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "ultimately"], ["proof (chain)\npicking this:\n  n < j\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]", "show ?thesis"], ["proof (prove)\nusing this:\n  n < j\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "using *"], ["proof (prove)\nusing this:\n  n < j\n  (take (Suc n) (Partial_Recursive.list_decode b))[j := v] =\n  (take n (Partial_Recursive.list_decode b))[j := v] @\n  [Partial_Recursive.list_decode b ! n]\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  e_snoc\n   (Partial_Recursive.list_encode\n     ((take n (Partial_Recursive.list_decode b))[j := v]))\n   (if n = j then v else e_nth b n)\n\ngoal (1 subgoal):\n 1. eval r_update_aux [Suc n, b, j, v] \\<down>=\n    Partial_Recursive.list_encode\n     ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])", "by auto"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_update_aux [Suc n, b, j, v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take (Suc n) (Partial_Recursive.list_decode b))[j := v])\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation e_update :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_update b j v \\<equiv> list_encode ((list_decode b)[j:=v])\""], ["", "definition \"r_update \\<equiv>\n  Cn 3 r_update_aux [Cn 3 r_length [Id 3 0], Id 3 0, Id 3 1, Id 3 2]\""], ["", "lemma r_update_recfn [simp]: \"recfn 3 r_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_update", "unfolding r_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_update_aux\n       [Cn 3 r_length [recf.Id 3 0], recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])", "using r_update_aux_recfn"], ["proof (prove)\nusing this:\n  recfn 4 r_update_aux\n\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_update_aux\n       [Cn 3 r_length [recf.Id 3 0], recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])", "by simp"], ["", "lemma r_update [simp]: \"eval r_update [b, j, v] \\<down>= e_update b j v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_update [b, j, v] \\<down>= e_update b j v", "unfolding r_update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_update_aux\n       [Cn 3 r_length [recf.Id 3 0], recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n     [b, j, v] \\<down>=\n    e_update b j v", "using r_update_aux r_update_aux_recfn"], ["proof (prove)\nusing this:\n  ?n \\<le> e_length ?b \\<Longrightarrow>\n  eval r_update_aux [?n, ?b, ?j, ?v] \\<down>=\n  Partial_Recursive.list_encode\n   ((take ?n (Partial_Recursive.list_decode ?b))[?j := ?v])\n  recfn 4 r_update_aux\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_update_aux\n       [Cn 3 r_length [recf.Id 3 0], recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n     [b, j, v] \\<down>=\n    e_update b j v", "by simp"], ["", "lemma e_length_update [simp]: \"e_length (e_update b k v) = e_length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_update b k v) = e_length b", "by simp"], ["", "definition e_append :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_append xs ys \\<equiv> list_encode (list_decode xs @ list_decode ys)\""], ["", "lemma e_length_append: \"e_length (e_append xs ys) = e_length xs + e_length ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_append xs ys) = e_length xs + e_length ys", "using e_append_def"], ["proof (prove)\nusing this:\n  e_append ?xs ?ys \\<equiv>\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode ?xs @ Partial_Recursive.list_decode ?ys)\n\ngoal (1 subgoal):\n 1. e_length (e_append xs ys) = e_length xs + e_length ys", "by simp"], ["", "lemma e_nth_append_small:\n  assumes \"n < e_length xs\"\n  shows \"e_nth (e_append xs ys) n = e_nth xs n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_append xs ys) n = e_nth xs n", "using e_append_def assms"], ["proof (prove)\nusing this:\n  e_append ?xs ?ys \\<equiv>\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode ?xs @ Partial_Recursive.list_decode ?ys)\n  n < e_length xs\n\ngoal (1 subgoal):\n 1. e_nth (e_append xs ys) n = e_nth xs n", "by (simp add: nth_append)"], ["", "lemma e_nth_append_big:\n  assumes \"n \\<ge> e_length xs\"\n  shows \"e_nth (e_append xs ys) n = e_nth ys (n - e_length xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_append xs ys) n = e_nth ys (n - e_length xs)", "using e_append_def assms e_nth"], ["proof (prove)\nusing this:\n  e_append ?xs ?ys \\<equiv>\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode ?xs @ Partial_Recursive.list_decode ?ys)\n  e_length xs \\<le> n\n  e_nth ?e ?n =\n  (if ?n < e_length ?e then Partial_Recursive.list_decode ?e ! ?n else 0)\n\ngoal (1 subgoal):\n 1. e_nth (e_append xs ys) n = e_nth ys (n - e_length xs)", "by (simp add: less_diff_conv2 nth_append)"], ["", "definition \"r_append \\<equiv>\n  let\n    f = Id 2 0;\n    g = Cn 4 r_snoc [Id 4 1, Cn 4 r_nth [Id 4 3, Id 4 0]]\n  in Cn 2 (Pr 2 f g) [Cn 2 r_length [Id 2 1], Id 2 0, Id 2 1]\""], ["", "lemma r_append_prim [simp]: \"prim_recfn 2 r_append\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_append", "unfolding r_append_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (let f = recf.Id 2 0;\n          g = Cn 4 r_snoc\n               [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]\n      in Cn 2 (Pr 2 f g)\n          [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])", "by simp"], ["", "lemma r_append [simp]: \"eval r_append [a, b] \\<down>= e_append a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "define g where \"g = Cn 4 r_snoc [Id 4 1, Cn 4 r_nth [Id 4 3, Id 4 0]]\""], ["proof (state)\nthis:\n  g = Cn 4 r_snoc [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "then"], ["proof (chain)\npicking this:\n  g = Cn 4 r_snoc [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]", "have g: \"eval g [j, r, a, b] \\<down>= e_snoc r (e_nth b j)\" for j r"], ["proof (prove)\nusing this:\n  g = Cn 4 r_snoc [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval g [j, r, a, b] \\<down>= e_snoc r (e_nth b j)", "by simp"], ["proof (state)\nthis:\n  eval g [?j, ?r, a, b] \\<down>= e_snoc ?r (e_nth b ?j)\n\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "let ?h = \"Pr 2 (Id 2 0) g\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "have \"eval ?h [n, a, b] \\<down>= list_encode (list_decode a @ (take n (list_decode b)))\"\n      if \"n \\<le> e_length b\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 2 (recf.Id 2 0) g) [n, a, b] \\<down>=\n    Partial_Recursive.list_encode\n     (Partial_Recursive.list_decode a @\n      take n (Partial_Recursive.list_decode b))", "using that g g_def"], ["proof (prove)\nusing this:\n  n \\<le> e_length b\n  eval g [?j, ?r, a, b] \\<down>= e_snoc ?r (e_nth b ?j)\n  g = Cn 4 r_snoc [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval (Pr 2 (recf.Id 2 0) g) [n, a, b] \\<down>=\n    Partial_Recursive.list_encode\n     (Partial_Recursive.list_decode a @\n      take n (Partial_Recursive.list_decode b))", "by (induction n) (simp_all add: take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  ?n \\<le> e_length b \\<Longrightarrow>\n  eval (Pr 2 (recf.Id 2 0) g) [?n, a, b] \\<down>=\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode a @\n    take ?n (Partial_Recursive.list_decode b))\n\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "then"], ["proof (chain)\npicking this:\n  ?n \\<le> e_length b \\<Longrightarrow>\n  eval (Pr 2 (recf.Id 2 0) g) [?n, a, b] \\<down>=\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode a @\n    take ?n (Partial_Recursive.list_decode b))", "show ?thesis"], ["proof (prove)\nusing this:\n  ?n \\<le> e_length b \\<Longrightarrow>\n  eval (Pr 2 (recf.Id 2 0) g) [?n, a, b] \\<down>=\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode a @\n    take ?n (Partial_Recursive.list_decode b))\n\ngoal (1 subgoal):\n 1. eval r_append [a, b] \\<down>= e_append a b", "unfolding r_append_def g_def e_append_def"], ["proof (prove)\nusing this:\n  ?n \\<le> e_length b \\<Longrightarrow>\n  eval\n   (Pr 2 (recf.Id 2 0)\n     (Cn 4 r_snoc [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]))\n   [?n, a, b] \\<down>=\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode a @\n    take ?n (Partial_Recursive.list_decode b))\n\ngoal (1 subgoal):\n 1. eval\n     (let f = recf.Id 2 0;\n          g = Cn 4 r_snoc\n               [recf.Id 4 1, Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]]\n      in Cn 2 (Pr 2 f g)\n          [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [a, b] \\<down>=\n    Partial_Recursive.list_encode\n     (Partial_Recursive.list_decode a @ Partial_Recursive.list_decode b)", "by simp"], ["proof (state)\nthis:\n  eval r_append [a, b] \\<down>= e_append a b\n\ngoal:\nNo subgoals!", "qed"], ["", "definition e_append_zeros :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"e_append_zeros b z \\<equiv> e_append b (list_encode (replicate z 0))\""], ["", "lemma e_append_zeros_length: \"e_length (e_append_zeros b z) = e_length b + z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_append_zeros b z) = e_length b + z", "using e_append_def e_append_zeros_def"], ["proof (prove)\nusing this:\n  e_append ?xs ?ys \\<equiv>\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode ?xs @ Partial_Recursive.list_decode ?ys)\n  e_append_zeros ?b ?z \\<equiv>\n  e_append ?b (Partial_Recursive.list_encode (replicate ?z 0))\n\ngoal (1 subgoal):\n 1. e_length (e_append_zeros b z) = e_length b + z", "by simp"], ["", "lemma e_nth_append_zeros: \"e_nth (e_append_zeros b z) i = e_nth b i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_append_zeros b z) i = e_nth b i", "using e_append_zeros_def e_nth_append_small e_nth_append_big"], ["proof (prove)\nusing this:\n  e_append_zeros ?b ?z \\<equiv>\n  e_append ?b (Partial_Recursive.list_encode (replicate ?z 0))\n  ?n < e_length ?xs \\<Longrightarrow>\n  e_nth (e_append ?xs ?ys) ?n = e_nth ?xs ?n\n  e_length ?xs \\<le> ?n \\<Longrightarrow>\n  e_nth (e_append ?xs ?ys) ?n = e_nth ?ys (?n - e_length ?xs)\n\ngoal (1 subgoal):\n 1. e_nth (e_append_zeros b z) i = e_nth b i", "by auto"], ["", "lemma e_nth_append_zeros_big:\n  assumes \"i \\<ge> e_length b\"\n  shows \"e_nth (e_append_zeros b z) i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_append_zeros b z) i = 0", "unfolding e_append_zeros_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (e_append b (Partial_Recursive.list_encode (replicate z 0))) i = 0", "using e_nth_append_big[of b i \"list_encode (replicate z 0)\", OF assms(1)]"], ["proof (prove)\nusing this:\n  e_nth (e_append b (Partial_Recursive.list_encode (replicate z 0))) i =\n  e_nth (Partial_Recursive.list_encode (replicate z 0)) (i - e_length b)\n\ngoal (1 subgoal):\n 1. e_nth (e_append b (Partial_Recursive.list_encode (replicate z 0))) i = 0", "by simp"], ["", "definition \"r_append_zeros \\<equiv>\n  r_swap (Pr 1 (Id 1 0) (Cn 3 r_snoc [Id 3 1, r_constn 2 0]))\""], ["", "lemma r_append_zeros_prim [simp]: \"prim_recfn 2 r_append_zeros\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_append_zeros", "unfolding r_append_zeros_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2\n     (r_swap (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0])))", "by simp"], ["", "lemma r_append_zeros: \"eval r_append_zeros [b, z] \\<down>= e_append_zeros b z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_append_zeros [b, z] \\<down>= e_append_zeros b z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_append_zeros [b, z] \\<down>= e_append_zeros b z", "let ?r = \"Pr 1 (Id 1 0) (Cn 3 r_snoc [Id 3 1, r_constn 2 0])\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_append_zeros [b, z] \\<down>= e_append_zeros b z", "have \"eval ?r [z, b] \\<down>= e_append_zeros b z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]))\n     [z, b] \\<down>=\n    e_append_zeros b z", "using e_append_zeros_def e_append_def"], ["proof (prove)\nusing this:\n  e_append_zeros ?b ?z \\<equiv>\n  e_append ?b (Partial_Recursive.list_encode (replicate ?z 0))\n  e_append ?xs ?ys \\<equiv>\n  Partial_Recursive.list_encode\n   (Partial_Recursive.list_decode ?xs @ Partial_Recursive.list_decode ?ys)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]))\n     [z, b] \\<down>=\n    e_append_zeros b z", "by (induction z) (simp_all add: replicate_append_same)"], ["proof (state)\nthis:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]))\n   [z, b] \\<down>=\n  e_append_zeros b z\n\ngoal (1 subgoal):\n 1. eval r_append_zeros [b, z] \\<down>= e_append_zeros b z", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]))\n   [z, b] \\<down>=\n  e_append_zeros b z", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 (recf.Id 1 0) (Cn 3 r_snoc [recf.Id 3 1, r_constn 2 0]))\n   [z, b] \\<down>=\n  e_append_zeros b z\n\ngoal (1 subgoal):\n 1. eval r_append_zeros [b, z] \\<down>= e_append_zeros b z", "by (simp add: r_append_zeros_def)"], ["proof (state)\nthis:\n  eval r_append_zeros [b, z] \\<down>= e_append_zeros b z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}