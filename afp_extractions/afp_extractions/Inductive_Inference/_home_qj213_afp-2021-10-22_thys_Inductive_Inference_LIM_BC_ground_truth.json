{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/LIM_BC.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma r_sigma_recfn: \"recfn 2 r_sigma\"", "lemma r_sigma: \"eval r_sigma [i, x] = \\<phi> (the (eval r_limr [i])) x\"", "lemma r_sigma_total: \"total r_sigma\"", "lemma sigma: \"\\<sigma> i = \\<phi> (the (eval r_limr [i]))\"", "lemma learn_lim_sigma:\n  assumes \"learn_lim \\<psi> U (\\<phi> i)\"\n  shows \"learn_lim \\<psi> U (\\<sigma> i)\"", "lemma r_next_recfn: \"recfn 1 r_next\"", "lemma change_conditions:\n  obtains\n    (on_0) \"change_on_0 b k\"\n  | (on_1) \"change_on_1 b k\"\n  | (neither) \"change_on_neither b k\"", "lemma r_next:\n  assumes \"arg = prod_encode (b, k)\"\n  shows \"change_on_0 b k \\<Longrightarrow> eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\"\n    and \"change_on_1 b k \\<Longrightarrow>\n      eval r_next [arg] \\<down>= prod_encode (e_snoc (e_update b k 1) 0, e_length b)\"\n    and \"change_on_neither b k \\<Longrightarrow> eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)\"", "lemma r_next_total: \"total r_next\"", "lemma r_state_recfn: \"recfn 2 r_state\"", "lemma r_state_at_0: \"eval r_state [0, i] \\<down>= prod_encode (list_encode [i, 0], 1)\"", "lemma r_state_total: \"total r_state\"", "lemma state_at_0:\n  \"block i 0 = list_encode [i, 0]\"\n  \"gap i 0 = 1\"", "lemma state_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\"\n    and \"gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))\"", "lemma gap_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"change_on_0 b k \\<Longrightarrow> gap i (Suc t) = e_length b\"\n    and \"change_on_1 b k \\<Longrightarrow> gap i (Suc t) = e_length b\"\n    and \"change_on_neither b k\\<Longrightarrow> gap i (Suc t) = k\"", "lemma block_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"change_on_0 b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0\"\n    and \"change_on_1 b k \\<Longrightarrow> block i (Suc t) = e_snoc (e_update b k 1) 0\"\n    and \"change_on_neither b k\\<Longrightarrow> block i (Suc t) = e_snoc b 0\"", "lemma block_stable:\n  assumes \"j < e_length (block i t)\" and \"j \\<noteq> gap i t\"\n  shows \"e_nth (block i t) j = e_nth (block i (Suc t)) j\"", "lemma gap_in_block: \"gap i t < e_length (block i t)\"", "lemma length_block: \"e_length (block i t) = Suc (Suc t)\"", "lemma gap_gr0: \"gap i t > 0\"", "lemma hd_block: \"e_hd (block i t) = i\"", "lemma last_block: \"e_nth (block i t) (gap i t) = 0\"", "lemma gap_le_Suc: \"gap i t \\<le> gap i (Suc t)\"", "lemma gap_monotone:\n  assumes \"t\\<^sub>1 \\<le> t\\<^sub>2\"\n  shows \"gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2\"", "lemma state_change_on_neither:\n  assumes \"gap i (Suc t) = gap i t\"\n  shows \"change_on_neither (block i t) (gap i t)\"\n    and \"block i (Suc t) = e_snoc (block i t) 0\"", "lemma state_change_on_either:\n  assumes \"gap i (Suc t) \\<noteq> gap i t\"\n  shows \"\\<not> change_on_neither (block i t) (gap i t)\"\n    and \"gap i (Suc t) = e_length (block i t)\"", "lemma determined_0: \"determined i 0\"", "lemma r_dettime_recfn: \"recfn 2 r_dettime\"", "lemma r_dettime:\n  shows \"determined i x \\<Longrightarrow> dettime i x \\<down>= (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\"\n    and \"\\<not> determined i x \\<Longrightarrow> dettime i x \\<up>\"", "lemma r_dettimeI:\n  assumes \"x < e_length (block i t) \\<and> x \\<noteq> gap i t\"\n    and \"\\<And>T. x < e_length (block i T) \\<and> x \\<noteq> gap i T \\<Longrightarrow> t \\<le> T\"\n  shows \"dettime i x \\<down>= t\"", "lemma r_dettime_0: \"dettime i 0 \\<down>= 0\"", "lemma r_tau_recfn: \"recfn 2 r_tau\"", "lemma tau_in_P2: \"\\<tau> \\<in> \\<P>\\<^sup>2\"", "lemma tau_diverg:\n  assumes \"\\<not> determined i x\"\n  shows \"\\<tau> i x \\<up>\"", "lemma tau_converg:\n  assumes \"determined i x\"\n  shows \"\\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x\"", "lemma tau_converg':\n  assumes \"dettime i x \\<down>= t\"\n  shows \"\\<tau> i x \\<down>= e_nth (block i t) x\"", "lemma tau_at_0: \"\\<tau> i 0 \\<down>= i\"", "lemma state_unchanged:\n  assumes \"gap i t - 1 \\<le> y\" and \"y \\<le> t\"\n  shows \"gap i t = gap i y\"", "lemma tau_eq_state:\n  assumes \"j < e_length (block i t)\" and \"j \\<noteq> gap i t\"\n  shows \"\\<tau> i j \\<down>= e_nth (block i t) j\"", "lemma tau_eq_state':\n  assumes \"j < t + 2\" and \" j \\<noteq> gap i t\"\n  shows \"\\<tau> i j \\<down>= e_nth (block i t) j\"", "lemma case_two_iff_forever_neither:\n  \"case_two i \\<longleftrightarrow> (\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T))\"", "lemma case_one_tau_total:\n  assumes \"case_one i\"\n  shows \"\\<tau> i x \\<down>\"", "lemma case_two_tau_not_quite_total:\n  assumes \"\\<forall>T. gap i T \\<le> gap i t\"\n  shows \"\\<tau> i (gap i t) \\<up>\"\n    and \"x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>\"", "lemma case_two_tau_almost_total:\n  assumes \"\\<exists>t. \\<forall>T. gap i T \\<le> gap i t\" (is \"\\<exists>t. ?P t\")\n  shows \"\\<tau> i (gap i (Least ?P)) \\<up>\"\n    and \"x \\<noteq> gap i (Least ?P) \\<Longrightarrow> \\<tau> i x \\<down>\"", "lemma init_tau_gap: \"(\\<tau> i) \\<triangleright> (gap i t - 1) = e_take (gap i t) (block i t)\"", "lemma change_on_0_init_tau:\n  assumes \"change_on_0 (block i t) (gap i t)\"\n  shows \"(\\<tau> i) \\<triangleright> (t + 1) = block i t\"", "lemma change_on_0_hyp_change:\n  assumes \"change_on_0 (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\"", "lemma change_on_1_init_tau:\n  assumes \"change_on_1 (block i t) (gap i t)\"\n  shows \"(\\<tau> i) \\<triangleright>  (t + 1) = e_update (block i t) (gap i t) 1\"", "lemma change_on_1_hyp_change:\n  assumes \"change_on_1 (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\"", "lemma change_on_either_hyp_change:\n  assumes \"\\<not> change_on_neither (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\"", "lemma filled_gap_0_init_tau:\n  assumes \"f\\<^sub>0 = (\\<tau> i)((gap i t):=Some 0)\"\n  shows \"f\\<^sub>0 \\<triangleright> (t + 1) = block i t\"", "lemma filled_gap_1_init_tau:\n  assumes \"f\\<^sub>1 = (\\<tau> i)((gap i t):=Some 1)\"\n  shows \"f\\<^sub>1 \\<triangleright> (t + 1) = e_update (block i t) (gap i t) 1\"", "lemma V_subseteq_R1: \"V_bclim i \\<subseteq> \\<R>\"", "lemma case_one_imp_gap_unbounded:\n  assumes \"case_one i\"\n  shows \"\\<exists>t. gap i t - 1 > n\"", "lemma case_one_imp_not_learn_lim_V:\n  assumes \"case_one i\"\n  shows \"\\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\"", "lemma case_two_imp_not_learn_lim_V:\n  assumes \"case_two i\"\n  shows \"\\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\"", "lemma V_BCLIM_R1: \"V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>\"", "lemma V_BCLIM_not_in_Lim: \"V\\<^bsub>BC-LIM\\<^esub> \\<notin> LIM\"", "lemma psitau_in_P2: \"\\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2\"", "lemma psitau_init:\n  \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)\"", "lemma learn_bc_V_BCLIM: \"learn_bc \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\"", "theorem Lim_subset_BC: \"LIM \\<subset> BC\""], "translations": [["", "lemma r_sigma_recfn: \"recfn 2 r_sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_sigma", "unfolding r_sigma_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_phi [Cn 2 r_limr [recf.Id 2 0], recf.Id 2 1])", "using r_limr_recfn"], ["proof (prove)\nusing this:\n  recfn 1 r_limr\n\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_phi [Cn 2 r_limr [recf.Id 2 0], recf.Id 2 1])", "by simp"], ["", "lemma r_sigma: \"eval r_sigma [i, x] = \\<phi> (the (eval r_limr [i])) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_sigma [i, x] = \\<phi> (the (eval r_limr [i])) x", "unfolding r_sigma_def phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_phi [Cn 2 r_limr [recf.Id 2 0], recf.Id 2 1]) [i, x] =\n    eval r_phi [the (eval r_limr [i]), x]", "using r_sigma_recfn r_limr_total r_limr_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_sigma\n  Partial_Recursive.total r_limr\n  recfn 1 r_limr\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_phi [Cn 2 r_limr [recf.Id 2 0], recf.Id 2 1]) [i, x] =\n    eval r_phi [the (eval r_limr [i]), x]", "by simp"], ["", "lemma r_sigma_total: \"total r_sigma\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_sigma", "using r_sigma r_limr r_sigma_recfn totalI2[of r_sigma]"], ["proof (prove)\nusing this:\n  eval r_sigma [?i, ?x] = \\<phi> (the (eval r_limr [?i])) ?x\n  \\<phi> (the (eval r_limr [?i])) \\<in> \\<R>\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<phi> (the (eval r_limr [?i])))\n  recfn 2 r_sigma\n  \\<lbrakk>recfn 2 r_sigma; \\<And>x y. eval r_sigma [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total r_sigma\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_sigma", "by simp"], ["", "abbreviation sigma :: partial2 (\"\\<sigma>\") where\n  \"\\<sigma> i x \\<equiv> eval r_sigma [i, x]\""], ["", "lemma sigma: \"\\<sigma> i = \\<phi> (the (eval r_limr [i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<phi> (the (eval r_limr [i]))", "using r_sigma"], ["proof (prove)\nusing this:\n  \\<sigma> ?i ?x = \\<phi> (the (eval r_limr [?i])) ?x\n\ngoal (1 subgoal):\n 1. \\<sigma> i = \\<phi> (the (eval r_limr [i]))", "by simp"], ["", "text \\<open>The numbering @{term \\<sigma>} does indeed enumerate enough total\nstrategies for every LIM learning problem.\\<close>"], ["", "lemma learn_lim_sigma:\n  assumes \"learn_lim \\<psi> U (\\<phi> i)\"\n  shows \"learn_lim \\<psi> U (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_lim \\<psi> U (\\<sigma> i)", "using assms sigma r_limr"], ["proof (prove)\nusing this:\n  learn_lim \\<psi> U (\\<phi> i)\n  \\<sigma> ?i = \\<phi> (the (eval r_limr [?i]))\n  \\<phi> (the (eval r_limr [?i])) \\<in> \\<R>\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<phi> (the (eval r_limr [?i])))\n\ngoal (1 subgoal):\n 1. learn_lim \\<psi> U (\\<sigma> i)", "by simp"], ["", "subsection \\<open>The diagonalization process\\<close>"], ["", "text \\<open>The following function represents the process described above. It\ncomputes the next state from a given state $(b, k)$.\\<close>"], ["", "definition \"r_next \\<equiv>\n  Cn 1 r_ifeq\n   [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], r_pdec1],\n    Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n    Cn 1 r_ifeq\n     [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n      Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n      Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n      Cn 1 r_prod_encode\n       [Cn 1 r_snoc\n         [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z], Cn 1 r_length [r_pdec1]]],\n    Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]]]\""], ["", "lemma r_next_recfn: \"recfn 1 r_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r_next", "unfolding r_next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], r_pdec1],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_ifeq\n         [Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1],\n            Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n          Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n          Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n          Cn 1 r_prod_encode\n           [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n            Cn 1 r_length [r_pdec1]]],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]]])", "using r_sigma_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_sigma\n\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], r_pdec1],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_ifeq\n         [Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1],\n            Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n          Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n          Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n          Cn 1 r_prod_encode\n           [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n            Cn 1 r_length [r_pdec1]]],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]]])", "by simp"], ["", "text \\<open>The three conditions distinguished in @{term r_next} correspond\nto Steps 1, 2, and 3 of the process: hypothesis change when the gap is\nfilled with 0; hypothesis change when the gap is filled with 1; or\nno hypothesis change either way.\\<close>"], ["", "abbreviation \"change_on_0 b k \\<equiv> \\<sigma> (e_hd b) b \\<noteq> \\<sigma> (e_hd b) (e_take k b)\""], ["", "abbreviation \"change_on_1 b k \\<equiv>\n  \\<sigma> (e_hd b) b = \\<sigma> (e_hd b) (e_take k b) \\<and>\n  \\<sigma> (e_hd b) (e_update b k 1) \\<noteq> \\<sigma> (e_hd b) (e_take k b)\""], ["", "abbreviation \"change_on_neither b k \\<equiv>\n  \\<sigma> (e_hd b) b = \\<sigma> (e_hd b) (e_take k b) \\<and>\n  \\<sigma> (e_hd b) (e_update b k 1) = \\<sigma> (e_hd b) (e_take k b)\""], ["", "lemma change_conditions:\n  obtains\n    (on_0) \"change_on_0 b k\"\n  | (on_1) \"change_on_1 b k\"\n  | (neither) \"change_on_neither b k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>change_on_0 b k \\<Longrightarrow> thesis;\n     change_on_1 b k \\<Longrightarrow> thesis;\n     change_on_neither b k \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["", "lemma r_next:\n  assumes \"arg = prod_encode (b, k)\"\n  shows \"change_on_0 b k \\<Longrightarrow> eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\"\n    and \"change_on_1 b k \\<Longrightarrow>\n      eval r_next [arg] \\<down>= prod_encode (e_snoc (e_update b k 1) 0, e_length b)\"\n    and \"change_on_neither b k \\<Longrightarrow> eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (change_on_0 b k \\<Longrightarrow>\n     eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)) &&&\n    (change_on_1 b k \\<Longrightarrow>\n     eval r_next [arg] \\<down>=\n     prod_encode (e_snoc (e_update b k 1) 0, e_length b)) &&&\n    (change_on_neither b k \\<Longrightarrow>\n     eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k))", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?bhd = \"Cn 1 r_hd [r_pdec1]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?bup = \"Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?bk = \"Cn 1 r_take [r_pdec2, r_pdec1]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?bap = \"Cn 1 r_snoc [r_pdec1, Z]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?len = \"Cn 1 r_length [r_pdec1]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?thenthen = \"Cn 1 r_prod_encode [?bap, r_pdec2]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?thenelse = \"Cn 1 r_prod_encode [Cn 1 r_snoc [?bup, Z], ?len]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "let ?else = \"Cn 1 r_prod_encode [?bap, ?len]\""], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have bhd: \"eval ?bhd [arg] \\<down>= e_hd b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_hd [r_pdec1]) [arg] \\<down>= e_hd b", "using assms"], ["proof (prove)\nusing this:\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_hd [r_pdec1]) [arg] \\<down>= e_hd b", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_hd [r_pdec1]) [arg] \\<down>= e_hd b\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have bup: \"eval ?bup [arg] \\<down>= e_update b k 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]) [arg] \\<down>=\n    e_update b k 1", "using assms"], ["proof (prove)\nusing this:\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]) [arg] \\<down>=\n    e_update b k 1", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]) [arg] \\<down>=\n  e_update b k 1\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have bk: \"eval ?bk [arg] \\<down>= e_take k b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_take [r_pdec2, r_pdec1]) [arg] \\<down>= e_take k b", "using assms"], ["proof (prove)\nusing this:\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_take [r_pdec2, r_pdec1]) [arg] \\<down>= e_take k b", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_take [r_pdec2, r_pdec1]) [arg] \\<down>= e_take k b\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have bap: \"eval ?bap [arg] \\<down>= e_snoc b 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_snoc [r_pdec1, Z]) [arg] \\<down>= e_snoc b 0", "using assms"], ["proof (prove)\nusing this:\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_snoc [r_pdec1, Z]) [arg] \\<down>= e_snoc b 0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_snoc [r_pdec1, Z]) [arg] \\<down>= e_snoc b 0\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have len: \"eval ?len [arg] \\<down>= e_length b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_length [r_pdec1]) [arg] \\<down>= e_length b", "using assms"], ["proof (prove)\nusing this:\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_length [r_pdec1]) [arg] \\<down>= e_length b", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_length [r_pdec1]) [arg] \\<down>= e_length b\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have else_: \"eval ?else [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]])\n     [arg] \\<down>=\n    prod_encode (e_snoc b 0, e_length b)", "using bap len"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_snoc [r_pdec1, Z]) [arg] \\<down>= e_snoc b 0\n  eval (Cn 1 r_length [r_pdec1]) [arg] \\<down>= e_length b\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]])\n     [arg] \\<down>=\n    prod_encode (e_snoc b 0, e_length b)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]])\n   [arg] \\<down>=\n  prod_encode (e_snoc b 0, e_length b)\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have thenthen: \"eval ?thenthen [arg] \\<down>= prod_encode (e_snoc b 0, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2])\n     [arg] \\<down>=\n    prod_encode (e_snoc b 0, k)", "using bap assms"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_snoc [r_pdec1, Z]) [arg] \\<down>= e_snoc b 0\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2])\n     [arg] \\<down>=\n    prod_encode (e_snoc b 0, k)", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2])\n   [arg] \\<down>=\n  prod_encode (e_snoc b 0, k)\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have thenelse: \"eval ?thenelse [arg] \\<down>= prod_encode (e_snoc (e_update b k 1) 0, e_length b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n        Cn 1 r_length [r_pdec1]])\n     [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)", "using bup len"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]) [arg] \\<down>=\n  e_update b k 1\n  eval (Cn 1 r_length [r_pdec1]) [arg] \\<down>= e_length b\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n        Cn 1 r_length [r_pdec1]])\n     [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 1 r_prod_encode\n     [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n      Cn 1 r_length [r_pdec1]])\n   [arg] \\<down>=\n  prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have then_:\n    \"eval\n      (Cn 1 r_ifeq [Cn 1 r_sigma [?bhd, ?bup], Cn 1 r_sigma [?bhd, ?bk], ?thenthen, ?thenelse])\n      [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) (e_update b k 1)) = the (\\<sigma> (e_hd b) (e_take k b))\n     then prod_encode (e_snoc b 0, k)\n     else prod_encode (e_snoc (e_update b k 1) 0, e_length b))\"\n    (is \"eval ?then [arg] \\<down>= ?then_eval\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma\n         [Cn 1 r_hd [r_pdec1], Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n          Cn 1 r_length [r_pdec1]]])\n     [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n        the (\\<sigma> (e_hd b) (e_take k b))\n     then prod_encode (e_snoc b 0, k)\n     else prod_encode (e_snoc (e_update b k 1) 0, e_length b))", "using bhd bup bk thenthen thenelse r_sigma r_sigma_recfn r_limr R1_imp_total1"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_hd [r_pdec1]) [arg] \\<down>= e_hd b\n  eval (Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]) [arg] \\<down>=\n  e_update b k 1\n  eval (Cn 1 r_take [r_pdec2, r_pdec1]) [arg] \\<down>= e_take k b\n  eval (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2])\n   [arg] \\<down>=\n  prod_encode (e_snoc b 0, k)\n  eval\n   (Cn 1 r_prod_encode\n     [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n      Cn 1 r_length [r_pdec1]])\n   [arg] \\<down>=\n  prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n  \\<sigma> ?i ?x = \\<phi> (the (eval r_limr [?i])) ?x\n  recfn 2 r_sigma\n  \\<phi> (the (eval r_limr [?i])) \\<in> \\<R>\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<phi> (the (eval r_limr [?i])))\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma\n         [Cn 1 r_hd [r_pdec1], Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n          Cn 1 r_length [r_pdec1]]])\n     [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n        the (\\<sigma> (e_hd b) (e_take k b))\n     then prod_encode (e_snoc b 0, k)\n     else prod_encode (e_snoc (e_update b k 1) 0, e_length b))", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 1 r_ifeq\n     [Cn 1 r_sigma\n       [Cn 1 r_hd [r_pdec1], Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n      Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n      Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n      Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n        Cn 1 r_length [r_pdec1]]])\n   [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n      the (\\<sigma> (e_hd b) (e_take k b))\n   then prod_encode (e_snoc b 0, k)\n   else prod_encode (e_snoc (e_update b k 1) 0, e_length b))\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have *: \"eval r_next [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n     then ?then_eval\n     else prod_encode (e_snoc b 0, e_length b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n     then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n             the (\\<sigma> (e_hd b) (e_take k b))\n          then prod_encode (e_snoc b 0, k)\n          else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n     else prod_encode (e_snoc b 0, e_length b))", "unfolding r_next_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], r_pdec1],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_ifeq\n         [Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1],\n            Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n          Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n          Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n          Cn 1 r_prod_encode\n           [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n            Cn 1 r_length [r_pdec1]]],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]]])\n     [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n     then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n             the (\\<sigma> (e_hd b) (e_take k b))\n          then prod_encode (e_snoc b 0, k)\n          else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n     else prod_encode (e_snoc b 0, e_length b))", "using bhd bk then_ else_ r_sigma r_sigma_recfn r_limr R1_imp_total1 assms"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_hd [r_pdec1]) [arg] \\<down>= e_hd b\n  eval (Cn 1 r_take [r_pdec2, r_pdec1]) [arg] \\<down>= e_take k b\n  eval\n   (Cn 1 r_ifeq\n     [Cn 1 r_sigma\n       [Cn 1 r_hd [r_pdec1], Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n      Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n      Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n      Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n        Cn 1 r_length [r_pdec1]]])\n   [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n      the (\\<sigma> (e_hd b) (e_take k b))\n   then prod_encode (e_snoc b 0, k)\n   else prod_encode (e_snoc (e_update b k 1) 0, e_length b))\n  eval\n   (Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]])\n   [arg] \\<down>=\n  prod_encode (e_snoc b 0, e_length b)\n  \\<sigma> ?i ?x = \\<phi> (the (eval r_limr [?i])) ?x\n  recfn 2 r_sigma\n  \\<phi> (the (eval r_limr [?i])) \\<in> \\<R>\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<phi> (the (eval r_limr [?i])))\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  arg = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], r_pdec1],\n        Cn 1 r_sigma [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n        Cn 1 r_ifeq\n         [Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1],\n            Cn 1 r_update [r_pdec1, r_pdec2, r_const 1]],\n          Cn 1 r_sigma\n           [Cn 1 r_hd [r_pdec1], Cn 1 r_take [r_pdec2, r_pdec1]],\n          Cn 1 r_prod_encode [Cn 1 r_snoc [r_pdec1, Z], r_pdec2],\n          Cn 1 r_prod_encode\n           [Cn 1 r_snoc [Cn 1 r_update [r_pdec1, r_pdec2, r_const 1], Z],\n            Cn 1 r_length [r_pdec1]]],\n        Cn 1 r_prod_encode\n         [Cn 1 r_snoc [r_pdec1, Z], Cn 1 r_length [r_pdec1]]])\n     [arg] \\<down>=\n    (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n     then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n             the (\\<sigma> (e_hd b) (e_take k b))\n          then prod_encode (e_snoc b 0, k)\n          else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n     else prod_encode (e_snoc b 0, e_length b))", "by simp"], ["proof (state)\nthis:\n  eval r_next [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n   then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n           the (\\<sigma> (e_hd b) (e_take k b))\n        then prod_encode (e_snoc b 0, k)\n        else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n   else prod_encode (e_snoc b 0, e_length b))\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "have r_sigma_neq: \"eval r_sigma [x\\<^sub>1, y\\<^sub>1] \\<noteq> eval r_sigma [x\\<^sub>2, y\\<^sub>2] \\<longleftrightarrow>\n      the (eval r_sigma [x\\<^sub>1, y\\<^sub>1]) \\<noteq> the (eval r_sigma [x\\<^sub>2, y\\<^sub>2])\"\n      for x\\<^sub>1 y\\<^sub>1 x\\<^sub>2 y\\<^sub>2"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> x\\<^sub>1 y\\<^sub>1 \\<noteq> \\<sigma> x\\<^sub>2 y\\<^sub>2) =\n    (the (\\<sigma> x\\<^sub>1 y\\<^sub>1) \\<noteq>\n     the (\\<sigma> x\\<^sub>2 y\\<^sub>2))", "using r_sigma r_limr totalE[OF r_sigma_total r_sigma_recfn] r_sigma_recfn r_sigma_total"], ["proof (prove)\nusing this:\n  \\<sigma> ?i ?x = \\<phi> (the (eval r_limr [?i])) ?x\n  \\<phi> (the (eval r_limr [?i])) \\<in> \\<R>\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<phi> (the (eval r_limr [?i])))\n  length ?xs = 2 \\<Longrightarrow> eval r_sigma ?xs \\<down>\n  recfn 2 r_sigma\n  Partial_Recursive.total r_sigma\n\ngoal (1 subgoal):\n 1. (\\<sigma> x\\<^sub>1 y\\<^sub>1 \\<noteq> \\<sigma> x\\<^sub>2 y\\<^sub>2) =\n    (the (\\<sigma> x\\<^sub>1 y\\<^sub>1) \\<noteq>\n     the (\\<sigma> x\\<^sub>2 y\\<^sub>2))", "by (metis One_nat_def Suc_1 length_Cons list.size(3) option.expand)"], ["proof (state)\nthis:\n  (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1 \\<noteq> \\<sigma> ?x\\<^sub>2 ?y\\<^sub>2) =\n  (the (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1) \\<noteq>\n   the (\\<sigma> ?x\\<^sub>2 ?y\\<^sub>2))\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "{"], ["proof (state)\nthis:\n  (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1 \\<noteq> \\<sigma> ?x\\<^sub>2 ?y\\<^sub>2) =\n  (the (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1) \\<noteq>\n   the (\\<sigma> ?x\\<^sub>2 ?y\\<^sub>2))\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "assume \"change_on_0 b k\""], ["proof (state)\nthis:\n  change_on_0 b k\n\ngoal (3 subgoals):\n 1. change_on_0 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n 2. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 3. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "then"], ["proof (chain)\npicking this:\n  change_on_0 b k", "show \"eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\""], ["proof (prove)\nusing this:\n  change_on_0 b k\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)", "using * r_sigma_neq"], ["proof (prove)\nusing this:\n  change_on_0 b k\n  eval r_next [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n   then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n           the (\\<sigma> (e_hd b) (e_take k b))\n        then prod_encode (e_snoc b 0, k)\n        else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n   else prod_encode (e_snoc b 0, e_length b))\n  (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1 \\<noteq> \\<sigma> ?x\\<^sub>2 ?y\\<^sub>2) =\n  (the (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1) \\<noteq>\n   the (\\<sigma> ?x\\<^sub>2 ?y\\<^sub>2))\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)", "by simp"], ["proof (state)\nthis:\n  eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, e_length b)\n\ngoal (2 subgoals):\n 1. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 2. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 2. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "assume \"change_on_1 b k\""], ["proof (state)\nthis:\n  change_on_1 b k\n\ngoal (2 subgoals):\n 1. change_on_1 b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n 2. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "then"], ["proof (chain)\npicking this:\n  change_on_1 b k", "show \"eval r_next [arg] \\<down>= prod_encode (e_snoc (e_update b k 1) 0, e_length b)\""], ["proof (prove)\nusing this:\n  change_on_1 b k\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)", "using * r_sigma_neq"], ["proof (prove)\nusing this:\n  change_on_1 b k\n  eval r_next [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n   then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n           the (\\<sigma> (e_hd b) (e_take k b))\n        then prod_encode (e_snoc b 0, k)\n        else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n   else prod_encode (e_snoc b 0, e_length b))\n  (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1 \\<noteq> \\<sigma> ?x\\<^sub>2 ?y\\<^sub>2) =\n  (the (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1) \\<noteq>\n   the (\\<sigma> ?x\\<^sub>2 ?y\\<^sub>2))\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>=\n    prod_encode (e_snoc (e_update b k 1) 0, e_length b)", "by simp"], ["proof (state)\nthis:\n  eval r_next [arg] \\<down>=\n  prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n\ngoal (1 subgoal):\n 1. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "assume \"change_on_neither b k\""], ["proof (state)\nthis:\n  change_on_neither b k\n\ngoal (1 subgoal):\n 1. change_on_neither b k \\<Longrightarrow>\n    eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "then"], ["proof (chain)\npicking this:\n  change_on_neither b k", "show \"eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)\""], ["proof (prove)\nusing this:\n  change_on_neither b k\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "using * r_sigma_neq"], ["proof (prove)\nusing this:\n  change_on_neither b k\n  eval r_next [arg] \\<down>=\n  (if the (\\<sigma> (e_hd b) b) = the (\\<sigma> (e_hd b) (e_take k b))\n   then if the (\\<sigma> (e_hd b) (e_update b k 1)) =\n           the (\\<sigma> (e_hd b) (e_take k b))\n        then prod_encode (e_snoc b 0, k)\n        else prod_encode (e_snoc (e_update b k 1) 0, e_length b)\n   else prod_encode (e_snoc b 0, e_length b))\n  (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1 \\<noteq> \\<sigma> ?x\\<^sub>2 ?y\\<^sub>2) =\n  (the (\\<sigma> ?x\\<^sub>1 ?y\\<^sub>1) \\<noteq>\n   the (\\<sigma> ?x\\<^sub>2 ?y\\<^sub>2))\n\ngoal (1 subgoal):\n 1. eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)", "by simp"], ["proof (state)\nthis:\n  eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  change_on_neither b k \\<Longrightarrow>\n  eval r_next [arg] \\<down>= prod_encode (e_snoc b 0, k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_next_total: \"total r_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_next", "proof (rule totalI1)"], ["proof (state)\ngoal (2 subgoals):\n 1. recfn 1 r_next\n 2. \\<And>x. eval r_next [x] \\<down>", "show \"recfn 1 r_next\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r_next", "using r_next_recfn"], ["proof (prove)\nusing this:\n  recfn 1 r_next\n\ngoal (1 subgoal):\n 1. recfn 1 r_next", "by simp"], ["proof (state)\nthis:\n  recfn 1 r_next\n\ngoal (1 subgoal):\n 1. \\<And>x. eval r_next [x] \\<down>", "show \"eval r_next [x] \\<down>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_next [x] \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_next [x] \\<down>", "obtain b k where \"x = prod_encode (b, k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b k.\n        x = prod_encode (b, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod_encode_pdec'[of x]"], ["proof (prove)\nusing this:\n  prod_encode (pdec1' x, pdec2' x) = x\n\ngoal (1 subgoal):\n 1. (\\<And>b k.\n        x = prod_encode (b, k) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  x = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval r_next [x] \\<down>", "then"], ["proof (chain)\npicking this:\n  x = prod_encode (b, k)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = prod_encode (b, k)\n\ngoal (1 subgoal):\n 1. eval r_next [x] \\<down>", "using r_next"], ["proof (prove)\nusing this:\n  x = prod_encode (b, k)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc (e_update ?b ?k 1) 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, ?k)\n\ngoal (1 subgoal):\n 1. eval r_next [x] \\<down>", "by fast"], ["proof (state)\nthis:\n  eval r_next [x] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_next [?x] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next function computes the state of the process after\nany number of iterations.\\<close>"], ["", "definition \"r_state \\<equiv>\n  Pr 1\n   (Cn 1 r_prod_encode [Cn 1 r_snoc [Cn 1 r_singleton_encode [Id 1 0], Z], r_const 1])\n   (Cn 3 r_next [Id 3 1])\""], ["", "lemma r_state_recfn: \"recfn 2 r_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_state", "unfolding r_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))", "using r_next_recfn"], ["proof (prove)\nusing this:\n  recfn 1 r_next\n\ngoal (1 subgoal):\n 1. recfn 2\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))", "by simp"], ["", "lemma r_state_at_0: \"eval r_state [0, i] \\<down>= prod_encode (list_encode [i, 0], 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "let ?f = \"Cn 1 r_prod_encode [Cn 1 r_snoc [Cn 1 r_singleton_encode [Id 1 0], Z], r_const 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "have \"eval r_state [0, i] = eval ?f [i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_state [0, i] =\n    eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n     [i]", "unfolding r_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))\n     [0, i] =\n    eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n     [i]", "using r_next_recfn"], ["proof (prove)\nusing this:\n  recfn 1 r_next\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))\n     [0, i] =\n    eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n     [i]", "by simp"], ["proof (state)\nthis:\n  eval r_state [0, i] =\n  eval\n   (Cn 1 r_prod_encode\n     [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n   [i]\n\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "also"], ["proof (state)\nthis:\n  eval r_state [0, i] =\n  eval\n   (Cn 1 r_prod_encode\n     [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n   [i]\n\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "have \"... \\<down>= prod_encode (list_encode [i, 0], 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n     [i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "by (simp add: list_decode_singleton)"], ["proof (state)\nthis:\n  eval\n   (Cn 1 r_prod_encode\n     [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z], r_const 1])\n   [i] \\<down>=\n  prod_encode (Partial_Recursive.list_encode [i, 0], 1)\n\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "finally"], ["proof (chain)\npicking this:\n  eval r_state [0, i] \\<down>=\n  prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_state [0, i] \\<down>=\n  prod_encode (Partial_Recursive.list_encode [i, 0], 1)\n\ngoal (1 subgoal):\n 1. eval r_state [0, i] \\<down>=\n    prod_encode (Partial_Recursive.list_encode [i, 0], 1)", "."], ["proof (state)\nthis:\n  eval r_state [0, i] \\<down>=\n  prod_encode (Partial_Recursive.list_encode [i, 0], 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_state_total: \"total r_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_state", "unfolding r_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))", "using r_next_recfn totalE[OF r_next_total r_next_recfn] totalI3[of \"Cn 3 r_next [Id 3 1]\"]"], ["proof (prove)\nusing this:\n  recfn 1 r_next\n  length ?xs = 1 \\<Longrightarrow> eval r_next ?xs \\<down>\n  \\<lbrakk>recfn 3 (Cn 3 r_next [recf.Id 3 1]);\n   \\<And>x y z. eval (Cn 3 r_next [recf.Id 3 1]) [x, y, z] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn 3 r_next [recf.Id 3 1])\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Pr 1\n       (Cn 1 r_prod_encode\n         [Cn 1 r_snoc [Cn 1 r_singleton_encode [recf.Id 1 0], Z],\n          r_const 1])\n       (Cn 3 r_next [recf.Id 3 1]))", "by (intro Pr_total) auto"], ["", "text \\<open>We call the components of a state $(b, k)$ the \\emph{block} $b$\nand the \\emph{gap} $k$.\\<close>"], ["", "definition block :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"block i t \\<equiv> pdec1 (the (eval r_state [t, i]))\""], ["", "definition gap :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"gap i t \\<equiv> pdec2 (the (eval r_state [t, i]))\""], ["", "lemma state_at_0:\n  \"block i 0 = list_encode [i, 0]\"\n  \"gap i 0 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. block i 0 = Partial_Recursive.list_encode [i, 0] &&& gap i 0 = 1", "unfolding block_def gap_def r_state_at_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1\n     (the (Some (prod_encode (Partial_Recursive.list_encode [i, 0], 1)))) =\n    Partial_Recursive.list_encode [i, 0] &&&\n    pdec2\n     (the (Some (prod_encode (Partial_Recursive.list_encode [i, 0], 1)))) =\n    1", "by simp_all"], ["", "text \\<open>Some lemmas describing the behavior of blocks and gaps in\none iteration of the process:\\<close>"], ["", "lemma state_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\"\n    and \"gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)])) &&&\n    gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "have \"eval r_state [Suc t, i] =\n      eval (Cn 3 r_next [Id 3 1]) [t, the (eval r_state [t, i]), i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_state [Suc t, i] =\n    eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i]", "using r_state_recfn r_next_recfn totalE[OF r_state_total r_state_recfn, of \"[t, i]\"]"], ["proof (prove)\nusing this:\n  recfn 2 r_state\n  recfn 1 r_next\n  length [t, i] = 2 \\<Longrightarrow> eval r_state [t, i] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_state [Suc t, i] =\n    eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i]", "by (simp add: r_state_def)"], ["proof (state)\nthis:\n  eval r_state [Suc t, i] =\n  eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "also"], ["proof (state)\nthis:\n  eval r_state [Suc t, i] =\n  eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "have \"... = eval r_next [the (eval r_state [t, i])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i] =\n    eval r_next [the (eval r_state [t, i])]", "using r_next_recfn"], ["proof (prove)\nusing this:\n  recfn 1 r_next\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i] =\n    eval r_next [the (eval r_state [t, i])]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i] =\n  eval r_next [the (eval r_state [t, i])]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "also"], ["proof (state)\nthis:\n  eval (Cn 3 r_next [recf.Id 3 1]) [t, the (eval r_state [t, i]), i] =\n  eval r_next [the (eval r_state [t, i])]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "have \"... = eval r_next [prod_encode (b, k)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_next [the (eval r_state [t, i])] =\n    eval r_next [prod_encode (b, k)]", "using assms block_def gap_def"], ["proof (prove)\nusing this:\n  b = block i t\n  k = gap i t\n  block ?i ?t \\<equiv> pdec1 (the (eval r_state [?t, ?i]))\n  gap ?i ?t \\<equiv> pdec2 (the (eval r_state [?t, ?i]))\n\ngoal (1 subgoal):\n 1. eval r_next [the (eval r_state [t, i])] =\n    eval r_next [prod_encode (b, k)]", "by simp"], ["proof (state)\nthis:\n  eval r_next [the (eval r_state [t, i])] = eval r_next [prod_encode (b, k)]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "finally"], ["proof (chain)\npicking this:\n  eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]", "have \"eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]\""], ["proof (prove)\nusing this:\n  eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]\n\ngoal (1 subgoal):\n 1. eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]", "."], ["proof (state)\nthis:\n  eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]\n\ngoal (2 subgoals):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n 2. gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "then"], ["proof (chain)\npicking this:\n  eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]", "show\n    \"block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\"\n    \"gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))\""], ["proof (prove)\nusing this:\n  eval r_state [Suc t, i] = eval r_next [prod_encode (b, k)]\n\ngoal (1 subgoal):\n 1. block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)])) &&&\n    gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))", "by (simp add: block_def, simp add: gap_def)"], ["proof (state)\nthis:\n  block i (Suc t) = pdec1 (the (eval r_next [prod_encode (b, k)]))\n  gap i (Suc t) = pdec2 (the (eval r_next [prod_encode (b, k)]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gap_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"change_on_0 b k \\<Longrightarrow> gap i (Suc t) = e_length b\"\n    and \"change_on_1 b k \\<Longrightarrow> gap i (Suc t) = e_length b\"\n    and \"change_on_neither b k\\<Longrightarrow> gap i (Suc t) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (change_on_0 b k \\<Longrightarrow> gap i (Suc t) = e_length b) &&&\n    (change_on_1 b k \\<Longrightarrow> gap i (Suc t) = e_length b) &&&\n    (change_on_neither b k \\<Longrightarrow> gap i (Suc t) = k)", "using assms r_next state_Suc"], ["proof (prove)\nusing this:\n  b = block i t\n  k = gap i t\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc (e_update ?b ?k 1) 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, ?k)\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) =\n                    pdec1 (the (eval r_next [prod_encode (?b, ?k)]))\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) =\n                    pdec2 (the (eval r_next [prod_encode (?b, ?k)]))\n\ngoal (1 subgoal):\n 1. (change_on_0 b k \\<Longrightarrow> gap i (Suc t) = e_length b) &&&\n    (change_on_1 b k \\<Longrightarrow> gap i (Suc t) = e_length b) &&&\n    (change_on_neither b k \\<Longrightarrow> gap i (Suc t) = k)", "by simp_all"], ["", "lemma block_Suc:\n  assumes \"b = block i t\" and \"k = gap i t\"\n  shows \"change_on_0 b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0\"\n    and \"change_on_1 b k \\<Longrightarrow> block i (Suc t) = e_snoc (e_update b k 1) 0\"\n    and \"change_on_neither b k\\<Longrightarrow> block i (Suc t) = e_snoc b 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (change_on_0 b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0) &&&\n    (change_on_1 b k \\<Longrightarrow>\n     block i (Suc t) = e_snoc (e_update b k 1) 0) &&&\n    (change_on_neither b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0)", "using assms r_next state_Suc"], ["proof (prove)\nusing this:\n  b = block i t\n  k = gap i t\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc (e_update ?b ?k 1) 0, e_length ?b)\n  \\<lbrakk>?arg = prod_encode (?b, ?k); change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> eval r_next [?arg] \\<down>=\n                    prod_encode (e_snoc ?b 0, ?k)\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) =\n                    pdec1 (the (eval r_next [prod_encode (?b, ?k)]))\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) =\n                    pdec2 (the (eval r_next [prod_encode (?b, ?k)]))\n\ngoal (1 subgoal):\n 1. (change_on_0 b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0) &&&\n    (change_on_1 b k \\<Longrightarrow>\n     block i (Suc t) = e_snoc (e_update b k 1) 0) &&&\n    (change_on_neither b k \\<Longrightarrow> block i (Suc t) = e_snoc b 0)", "by simp_all"], ["", "text \\<open>Non-gap positions in the block remain unchanged after an\niteration.\\<close>"], ["", "lemma block_stable:\n  assumes \"j < e_length (block i t)\" and \"j \\<noteq> gap i t\"\n  shows \"e_nth (block i t) j = e_nth (block i (Suc t)) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (block i t) j = e_nth (block i (Suc t)) j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e_nth (block i t) j = e_nth (block i (Suc t)) j", "from change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. e_nth (block i t) j = e_nth (block i (Suc t)) j", "using assms block_Suc gap_Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  j < e_length (block i t)\n  j \\<noteq> gap i t\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc (e_update ?b ?k 1) 0\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = ?k\n\ngoal (1 subgoal):\n 1. e_nth (block i t) j = e_nth (block i (Suc t)) j", "by (cases, (simp_all add: nth_append))"], ["proof (state)\nthis:\n  e_nth (block i t) j = e_nth (block i (Suc t)) j\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next are some properties of @{term block} and @{term gap}.\\<close>"], ["", "lemma gap_in_block: \"gap i t < e_length (block i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. gap i 0 < e_length (block i 0)\n 2. \\<And>t.\n       gap i t < e_length (block i t) \\<Longrightarrow>\n       gap i (Suc t) < e_length (block i (Suc t))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. gap i 0 < e_length (block i 0)\n 2. \\<And>t.\n       gap i t < e_length (block i t) \\<Longrightarrow>\n       gap i (Suc t) < e_length (block i (Suc t))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i 0 < e_length (block i 0)", "by (simp add: state_at_0)"], ["proof (state)\nthis:\n  gap i 0 < e_length (block i 0)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t < e_length (block i t) \\<Longrightarrow>\n       gap i (Suc t) < e_length (block i (Suc t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t < e_length (block i t) \\<Longrightarrow>\n       gap i (Suc t) < e_length (block i (Suc t))", "case (Suc t)"], ["proof (state)\nthis:\n  gap i t < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t < e_length (block i t) \\<Longrightarrow>\n       gap i (Suc t) < e_length (block i (Suc t))", "with change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  gap i t < e_length (block i t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  gap i t < e_length (block i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) < e_length (block i (Suc t))", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_0 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 2. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_1 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 3. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "case on_0"], ["proof (state)\nthis:\n  change_on_0 (block i t) (gap i t)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_0 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 2. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_1 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 3. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "then"], ["proof (chain)\npicking this:\n  change_on_0 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) < e_length (block i (Suc t))", "by (simp add: block_Suc(1) gap_Suc(1))"], ["proof (state)\nthis:\n  gap i (Suc t) < e_length (block i (Suc t))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_1 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 2. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_1 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 2. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "case on_1"], ["proof (state)\nthis:\n  change_on_1 (block i t) (gap i t)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_1 (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))\n 2. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "then"], ["proof (chain)\npicking this:\n  change_on_1 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) < e_length (block i (Suc t))", "by (simp add: block_Suc(2) gap_Suc(2))"], ["proof (state)\nthis:\n  gap i (Suc t) < e_length (block i (Suc t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "case neither"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i t < e_length (block i t);\n     change_on_neither (block i t) (gap i t)\\<rbrakk>\n    \\<Longrightarrow> gap i (Suc t) < e_length (block i (Suc t))", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) < e_length (block i (Suc t))", "using Suc.IH block_Suc(3) gap_Suc(3)"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n  gap i t < e_length (block i t)\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = ?k\n\ngoal (1 subgoal):\n 1. gap i (Suc t) < e_length (block i (Suc t))", "by force"], ["proof (state)\nthis:\n  gap i (Suc t) < e_length (block i (Suc t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i (Suc t) < e_length (block i (Suc t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma length_block: \"e_length (block i t) = Suc (Suc t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (block i t) = Suc (Suc t)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (block i 0) = Suc (Suc 0)\n 2. \\<And>t.\n       e_length (block i t) = Suc (Suc t) \\<Longrightarrow>\n       e_length (block i (Suc t)) = Suc (Suc (Suc t))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. e_length (block i 0) = Suc (Suc 0)\n 2. \\<And>t.\n       e_length (block i t) = Suc (Suc t) \\<Longrightarrow>\n       e_length (block i (Suc t)) = Suc (Suc (Suc t))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (block i 0) = Suc (Suc 0)", "by (simp add: state_at_0)"], ["proof (state)\nthis:\n  e_length (block i 0) = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_length (block i t) = Suc (Suc t) \\<Longrightarrow>\n       e_length (block i (Suc t)) = Suc (Suc (Suc t))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_length (block i t) = Suc (Suc t) \\<Longrightarrow>\n       e_length (block i (Suc t)) = Suc (Suc (Suc t))", "case (Suc t)"], ["proof (state)\nthis:\n  e_length (block i t) = Suc (Suc t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_length (block i t) = Suc (Suc t) \\<Longrightarrow>\n       e_length (block i (Suc t)) = Suc (Suc (Suc t))", "with change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  e_length (block i t) = Suc (Suc t)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  e_length (block i t) = Suc (Suc t)\n\ngoal (1 subgoal):\n 1. e_length (block i (Suc t)) = Suc (Suc (Suc t))", "by (cases, simp_all add: block_Suc gap_Suc)"], ["proof (state)\nthis:\n  e_length (block i (Suc t)) = Suc (Suc (Suc t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gap_gr0: \"gap i t > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gap i t", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < gap i 0\n 2. \\<And>t. 0 < gap i t \\<Longrightarrow> 0 < gap i (Suc t)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. 0 < gap i 0\n 2. \\<And>t. 0 < gap i t \\<Longrightarrow> 0 < gap i (Suc t)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gap i 0", "by (simp add: state_at_0)"], ["proof (state)\nthis:\n  0 < gap i 0\n\ngoal (1 subgoal):\n 1. \\<And>t. 0 < gap i t \\<Longrightarrow> 0 < gap i (Suc t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. 0 < gap i t \\<Longrightarrow> 0 < gap i (Suc t)", "case (Suc t)"], ["proof (state)\nthis:\n  0 < gap i t\n\ngoal (1 subgoal):\n 1. \\<And>t. 0 < gap i t \\<Longrightarrow> 0 < gap i (Suc t)", "with change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < gap i t", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < gap i t\n\ngoal (1 subgoal):\n 1. 0 < gap i (Suc t)", "using length_block"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  0 < gap i t\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. 0 < gap i (Suc t)", "by (cases, simp_all add: block_Suc gap_Suc)"], ["proof (state)\nthis:\n  0 < gap i (Suc t)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hd_block: \"e_hd (block i t) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd (block i t) = i", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. e_hd (block i 0) = i\n 2. \\<And>t.\n       e_hd (block i t) = i \\<Longrightarrow> e_hd (block i (Suc t)) = i", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. e_hd (block i 0) = i\n 2. \\<And>t.\n       e_hd (block i t) = i \\<Longrightarrow> e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd (block i 0) = i", "by (simp add: state_at_0)"], ["proof (state)\nthis:\n  e_hd (block i 0) = i\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_hd (block i t) = i \\<Longrightarrow> e_hd (block i (Suc t)) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_hd (block i t) = i \\<Longrightarrow> e_hd (block i (Suc t)) = i", "case (Suc t)"], ["proof (state)\nthis:\n  e_hd (block i t) = i\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_hd (block i t) = i \\<Longrightarrow> e_hd (block i (Suc t)) = i", "from change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "case on_0"], ["proof (state)\nthis:\n  change_on_0 (block i t) (gap i t)\n\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:\n  change_on_0 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "using Suc block_Suc(1) length_block"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n  e_hd (block i t) = i\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "by (metis e_hd_snoc gap_Suc(1) gap_gr0)"], ["proof (state)\nthis:\n  e_hd (block i (Suc t)) = i\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "case on_1"], ["proof (state)\nthis:\n  change_on_1 (block i t) (gap i t)\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "let ?b = \"block i t\" and ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "have \"?k > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gap i t", "using gap_gr0 Suc"], ["proof (prove)\nusing this:\n  0 < gap ?i ?t\n  e_hd (block i t) = i\n\ngoal (1 subgoal):\n 1. 0 < gap i t", "by simp"], ["proof (state)\nthis:\n  0 < gap i t\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:\n  0 < gap i t", "have \"e_nth (e_update ?b ?k 1) 0 = e_nth ?b 0\""], ["proof (prove)\nusing this:\n  0 < gap i t\n\ngoal (1 subgoal):\n 1. e_nth (e_update (block i t) (gap i t) 1) 0 = e_nth (block i t) 0", "by simp"], ["proof (state)\nthis:\n  e_nth (e_update (block i t) (gap i t) 1) 0 = e_nth (block i t) 0\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:\n  e_nth (e_update (block i t) (gap i t) 1) 0 = e_nth (block i t) 0", "have *: \"e_hd (e_update ?b ?k 1) = e_hd ?b\""], ["proof (prove)\nusing this:\n  e_nth (e_update (block i t) (gap i t) 1) 0 = e_nth (block i t) 0\n\ngoal (1 subgoal):\n 1. e_hd (e_update (block i t) (gap i t) 1) = e_hd (block i t)", "using e_hd_nth0 gap_Suc(2)[of _ i t] gap_gr0 on_1"], ["proof (prove)\nusing this:\n  e_nth (e_update (block i t) (gap i t) 1) 0 = e_nth (block i t) 0\n  e_hd ?e = e_nth ?e 0\n  \\<lbrakk>?b = block i t; ?k = gap i t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap i (Suc t) = e_length ?b\n  0 < gap ?i ?t\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. e_hd (e_update (block i t) (gap i t) 1) = e_hd (block i t)", "by (metis e_length_update)"], ["proof (state)\nthis:\n  e_hd (e_update (block i t) (gap i t) 1) = e_hd (block i t)\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "from on_1"], ["proof (chain)\npicking this:\n  change_on_1 (block i t) (gap i t)", "have \"block i (Suc t) = e_snoc (e_update ?b ?k 1) 0\""], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0", "by (simp add: block_Suc(2))"], ["proof (state)\nthis:\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "using e_hd_0 e_hd_snoc Suc length_block \\<open>?k > 0\\<close> *"], ["proof (prove)\nusing this:\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n  e_hd 0 = 0\n  0 < e_length ?b \\<Longrightarrow> e_hd (e_snoc ?b ?x) = e_hd ?b\n  e_hd (block i t) = i\n  e_length (block ?i ?t) = Suc (Suc ?t)\n  0 < gap i t\n  e_hd (e_update (block i t) (gap i t) 1) = e_hd (block i t)\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "by (metis e_length_update gap_Suc(2) gap_gr0 on_1)"], ["proof (state)\nthis:\n  e_hd (block i (Suc t)) = i\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "case neither"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_hd (block i (Suc t)) = i", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "using Suc block_Suc(3) length_block"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n  e_hd (block i t) = i\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_hd (block i (Suc t)) = i", "by simp"], ["proof (state)\nthis:\n  e_hd (block i (Suc t)) = i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_hd (block i (Suc t)) = i\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Formally, a block always ends in zero, even if it ends in a gap.\\<close>"], ["", "lemma last_block: \"e_nth (block i t) (gap i t) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (block i t) (gap i t) = 0", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. e_nth (block i 0) (gap i 0) = 0\n 2. \\<And>t.\n       e_nth (block i t) (gap i t) = 0 \\<Longrightarrow>\n       e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. e_nth (block i 0) (gap i 0) = 0\n 2. \\<And>t.\n       e_nth (block i t) (gap i t) = 0 \\<Longrightarrow>\n       e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_nth (block i 0) (gap i 0) = 0", "by (simp add: state_at_0)"], ["proof (state)\nthis:\n  e_nth (block i 0) (gap i 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_nth (block i t) (gap i t) = 0 \\<Longrightarrow>\n       e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_nth (block i t) (gap i t) = 0 \\<Longrightarrow>\n       e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "case (Suc t)"], ["proof (state)\nthis:\n  e_nth (block i t) (gap i t) = 0\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       e_nth (block i t) (gap i t) = 0 \\<Longrightarrow>\n       e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "from change_conditions[of \"block i t\" \"gap i t\"]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "case on_0"], ["proof (state)\nthis:\n  change_on_0 (block i t) (gap i t)\n\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "then"], ["proof (chain)\npicking this:\n  change_on_0 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "using Suc"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n  e_nth (block i t) (gap i t) = 0\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "by (simp add: block_Suc(1) gap_Suc(1))"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "case on_1"], ["proof (state)\nthis:\n  change_on_1 (block i t) (gap i t)\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "then"], ["proof (chain)\npicking this:\n  change_on_1 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "using Suc"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n  e_nth (block i t) (gap i t) = 0\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "by (simp add: block_Suc(2) gap_Suc(2) nth_append)"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "case neither"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "have\n      \"block i (Suc t) = e_snoc (block i t) 0\"\n      \"gap i (Suc t) = gap i t\""], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0 &&& gap i (Suc t) = gap i t", "by (simp_all add: gap_Suc(3) block_Suc(3))"], ["proof (state)\nthis:\n  block i (Suc t) = e_snoc (block i t) 0\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "then"], ["proof (chain)\npicking this:\n  block i (Suc t) = e_snoc (block i t) 0\n  gap i (Suc t) = gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  block i (Suc t) = e_snoc (block i t) 0\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "using Suc gap_in_block"], ["proof (prove)\nusing this:\n  block i (Suc t) = e_snoc (block i t) 0\n  gap i (Suc t) = gap i t\n  e_nth (block i t) (gap i t) = 0\n  gap ?i ?t < e_length (block ?i ?t)\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) (gap i (Suc t)) = 0", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) (gap i (Suc t)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gap_le_Suc: \"gap i t \\<le> gap i (Suc t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t \\<le> gap i (Suc t)", "using change_conditions[of \"block i t\" \"gap i t\"]\n    gap_Suc gap_in_block less_imp_le[of \"gap i t\" \"e_length (block i t)\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = ?k\n  gap ?i ?t < e_length (block ?i ?t)\n  gap i t < e_length (block i t) \\<Longrightarrow>\n  gap i t \\<le> e_length (block i t)\n\ngoal (1 subgoal):\n 1. gap i t \\<le> gap i (Suc t)", "by (cases) simp_all"], ["", "lemma gap_monotone:\n  assumes \"t\\<^sub>1 \\<le> t\\<^sub>2\"\n  shows \"gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2", "have \"gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + 0)\n 2. \\<And>j.\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j) \\<Longrightarrow>\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + 0)\n 2. \\<And>j.\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j) \\<Longrightarrow>\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + 0)", "by simp"], ["proof (state)\nthis:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + 0)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j) \\<Longrightarrow>\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j) \\<Longrightarrow>\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "case (Suc j)"], ["proof (state)\nthis:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j) \\<Longrightarrow>\n       gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "then"], ["proof (chain)\npicking this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)", "show ?case"], ["proof (prove)\nusing this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)\n\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "using gap_le_Suc dual_order.trans"], ["proof (prove)\nusing this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + j)\n  gap ?i ?t \\<le> gap ?i (Suc ?t)\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)", "by fastforce"], ["proof (state)\nthis:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + ?j)\n\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2", "then"], ["proof (chain)\npicking this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + ?j)", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + ?j)\n\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2", "using assms le_Suc_ex"], ["proof (prove)\nusing this:\n  gap i t\\<^sub>1 \\<le> gap i (t\\<^sub>1 + ?j)\n  t\\<^sub>1 \\<le> t\\<^sub>2\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  gap i t\\<^sub>1 \\<le> gap i t\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We need some lemmas relating the shape of the next state\nto the hypothesis change conditions in Steps 1, 2, and 3.\\<close>"], ["", "lemma state_change_on_neither:\n  assumes \"gap i (Suc t) = gap i t\"\n  shows \"change_on_neither (block i t) (gap i t)\"\n    and \"block i (Suc t) = e_snoc (block i t) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) &&&\n    block i (Suc t) = e_snoc (block i t) 0", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_neither (block i t) (gap i t)\n 2. block i (Suc t) = e_snoc (block i t) 0", "let ?b = \"block i t\" and ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_neither (block i t) (gap i t)\n 2. block i (Suc t) = e_snoc (block i t) 0", "have \"?k < e_length ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "using gap_in_block"], ["proof (prove)\nusing this:\n  gap ?i ?t < e_length (block ?i ?t)\n\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "by simp"], ["proof (state)\nthis:\n  gap i t < e_length (block i t)\n\ngoal (2 subgoals):\n 1. change_on_neither (block i t) (gap i t)\n 2. block i (Suc t) = e_snoc (block i t) 0", "from change_conditions[of ?b ?k]"], ["proof (chain)\npicking this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"change_on_neither (block i t) (gap i t)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>change_on_0 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_1 (block i t) (gap i t) \\<Longrightarrow> ?thesis;\n   change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "case on_0"], ["proof (state)\nthis:\n  change_on_0 (block i t) (gap i t)\n\ngoal (3 subgoals):\n 1. change_on_0 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 2. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 3. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "then"], ["proof (chain)\npicking this:\n  change_on_0 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "using \\<open>?k < e_length ?b\\<close> assms gap_Suc(1)"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n  gap i t < e_length (block i t)\n  gap i (Suc t) = gap i t\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "by auto"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "case on_1"], ["proof (state)\nthis:\n  change_on_1 (block i t) (gap i t)\n\ngoal (2 subgoals):\n 1. change_on_1 (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)\n 2. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "then"], ["proof (chain)\npicking this:\n  change_on_1 (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "using assms gap_Suc(2)"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n  gap i (Suc t) = gap i t\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "by auto"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "case neither"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow>\n    change_on_neither (block i t) (gap i t)", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t)", "by simp"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "show \"block i (Suc t) = e_snoc (block i t) 0\""], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0", "using block_Suc(3)"], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t;\n   change_on_neither ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0", "by simp"], ["proof (state)\nthis:\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_change_on_either:\n  assumes \"gap i (Suc t) \\<noteq> gap i t\"\n  shows \"\\<not> change_on_neither (block i t) (gap i t)\"\n    and \"gap i (Suc t) = e_length (block i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i t) (gap i t) &&&\n    gap i (Suc t) = e_length (block i t)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> change_on_neither (block i t) (gap i t)\n 2. gap i (Suc t) = e_length (block i t)", "let ?b = \"block i t\" and ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> change_on_neither (block i t) (gap i t)\n 2. gap i (Suc t) = e_length (block i t)", "show \"\\<not> change_on_neither (block i t) (gap i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i t) (gap i t)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow> False", "assume \"change_on_neither (block i t) (gap i t)\""], ["proof (state)\nthis:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i t) (gap i t)", "have \"gap i (Suc t) = ?k\""], ["proof (prove)\nusing this:\n  change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = gap i t", "by (simp add: gap_Suc(3))"], ["proof (state)\nthis:\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. change_on_neither (block i t) (gap i t) \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  gap i (Suc t) \\<noteq> gap i t\n  gap i (Suc t) = gap i t", "show False"], ["proof (prove)\nusing this:\n  gap i (Suc t) \\<noteq> gap i t\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t)", "then"], ["proof (chain)\npicking this:\n  \\<not> change_on_neither (block i t) (gap i t)", "show \"gap i (Suc t) = e_length (block i t)\""], ["proof (prove)\nusing this:\n  \\<not> change_on_neither (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t)", "using gap_Suc(1) gap_Suc(2)"], ["proof (prove)\nusing this:\n  \\<not> change_on_neither (block i t) (gap i t)\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t)", "by blast"], ["proof (state)\nthis:\n  gap i (Suc t) = e_length (block i t)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next up is the definition of $\\tau$. In every iteration the\nprocess determines $\\tau_i(x)$ for some $x$ either by appending 0 to the\ncurrent block $b$, or by filling the current gap $k$. In the former case,\nthe value is determined for $x = |b|$, in the latter for $x = k$.\\<close>"], ["", "text \\<open>For $i$ and $x$ the function @{term r_dettime} computes in which\niteration the process for $i$ determines the value $\\tau_i(x)$. This is the\nfirst iteration in which the block is long enough to contain position $x$ and\nin which $x$ is not the gap. If $\\tau_i(x)$ is never determined, because Case~2 is\nreached with $k = x$, then @{term r_dettime} diverges.\\<close>"], ["", "abbreviation determined :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n  \"determined i x \\<equiv> \\<exists>t. x < e_length (block i t) \\<and> x \\<noteq> gap i t\""], ["", "lemma determined_0: \"determined i 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determined i 0", "using gap_gr0[of i 0] gap_in_block[of i 0]"], ["proof (prove)\nusing this:\n  0 < gap i 0\n  gap i 0 < e_length (block i 0)\n\ngoal (1 subgoal):\n 1. determined i 0", "by force"], ["", "definition \"r_dettime \\<equiv>\n  Mn 2\n   (Cn 3 r_and\n     [Cn 3 r_less\n       [Id 3 2, Cn 3 r_length [Cn 3 r_pdec1 [Cn 3 r_state [Id 3 0, Id 3 1]]]],\n      Cn 3 r_neq\n       [Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [Id 3 0, Id 3 1]]]])\""], ["", "lemma r_dettime_recfn: \"recfn 2 r_dettime\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_dettime", "unfolding r_dettime_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Mn 2\n       (Cn 3 r_and\n         [Cn 3 r_less\n           [recf.Id 3 2,\n            Cn 3 r_length\n             [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n          Cn 3 r_neq\n           [recf.Id 3 2,\n            Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]))", "using r_state_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_state\n\ngoal (1 subgoal):\n 1. recfn 2\n     (Mn 2\n       (Cn 3 r_and\n         [Cn 3 r_less\n           [recf.Id 3 2,\n            Cn 3 r_length\n             [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n          Cn 3 r_neq\n           [recf.Id 3 2,\n            Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]))", "by simp"], ["", "abbreviation dettime :: partial2 where\n  \"dettime i x \\<equiv> eval r_dettime [i, x]\""], ["", "lemma r_dettime:\n  shows \"determined i x \\<Longrightarrow> dettime i x \\<down>= (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\"\n    and \"\\<not> determined i x \\<Longrightarrow> dettime i x \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (determined i x \\<Longrightarrow>\n     dettime i x \\<down>=\n     (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)) &&&\n    (\\<not> determined i x \\<Longrightarrow> dettime i x \\<up>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "define f where \"f =\n   (Cn 3 r_and\n     [Cn 3 r_less\n       [Id 3 2, Cn 3 r_length [Cn 3 r_pdec1 [Cn 3 r_state [Id 3 0, Id 3 1]]]],\n      Cn 3 r_neq\n       [Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [Id 3 0, Id 3 1]]]])\""], ["proof (state)\nthis:\n  f =\n  Cn 3 r_and\n   [Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n    Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "then"], ["proof (chain)\npicking this:\n  f =\n  Cn 3 r_and\n   [Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n    Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]", "have \"r_dettime = Mn 2 f\""], ["proof (prove)\nusing this:\n  f =\n  Cn 3 r_and\n   [Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n    Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]\n\ngoal (1 subgoal):\n 1. r_dettime = Mn 2 f", "unfolding f_def r_dettime_def"], ["proof (prove)\nusing this:\n  Cn 3 r_and\n   [Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n    Cn 3 r_neq\n     [recf.Id 3 2,\n      Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]] =\n  Cn 3 r_and\n   [Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n    Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]\n\ngoal (1 subgoal):\n 1. Mn 2\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]]) =\n    Mn 2\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])", "by simp"], ["proof (state)\nthis:\n  r_dettime = Mn 2 f\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "have \"recfn 3 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])", "using r_state_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_state\n\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])", "by simp"], ["proof (state)\nthis:\n  recfn 3 f\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "then"], ["proof (chain)\npicking this:\n  recfn 3 f", "have \"total f\""], ["proof (prove)\nusing this:\n  recfn 3 f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total f", "unfolding f_def"], ["proof (prove)\nusing this:\n  recfn 3\n   (Cn 3 r_and\n     [Cn 3 r_less\n       [recf.Id 3 2,\n        Cn 3 r_length\n         [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n      Cn 3 r_neq\n       [recf.Id 3 2,\n        Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])", "using Cn_total r_state_total Mn_free_imp_total"], ["proof (prove)\nusing this:\n  recfn 3\n   (Cn 3 r_and\n     [Cn 3 r_less\n       [recf.Id 3 2,\n        Cn 3 r_length\n         [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n      Cn 3 r_neq\n       [recf.Id 3 2,\n        Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  Partial_Recursive.total r_state\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total f\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "have f: \"eval f [t, i, x] \\<down>= (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "let ?b = \"Cn 3 r_pdec1 [Cn 3 r_state [Id 3 0, Id 3 1]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "let ?k = \"Cn 3 r_pdec2 [Cn 3 r_state [Id 3 0, Id 3 1]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "have \"eval ?b [t, i, x] \\<down>= pdec1 (the (eval r_state [t, i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    pdec1 (the (eval r_state [t, i]))", "using r_state_recfn r_state_total"], ["proof (prove)\nusing this:\n  recfn 2 r_state\n  Partial_Recursive.total r_state\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    pdec1 (the (eval r_state [t, i]))", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec1 (the (eval r_state [t, i]))\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "then"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec1 (the (eval r_state [t, i]))", "have b: \"eval ?b [t, i, x] \\<down>= block i t\""], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec1 (the (eval r_state [t, i]))\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    block i t", "using block_def"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec1 (the (eval r_state [t, i]))\n  block ?i ?t \\<equiv> pdec1 (the (eval r_state [?t, ?i]))\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    block i t", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  block i t\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "have \"eval ?k [t, i, x] \\<down>= pdec2 (the (eval r_state [t, i]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    pdec2 (the (eval r_state [t, i]))", "using r_state_recfn r_state_total"], ["proof (prove)\nusing this:\n  recfn 2 r_state\n  Partial_Recursive.total r_state\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    pdec2 (the (eval r_state [t, i]))", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec2 (the (eval r_state [t, i]))\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "then"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec2 (the (eval r_state [t, i]))", "have k: \"eval ?k [t, i, x] \\<down>= gap i t\""], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec2 (the (eval r_state [t, i]))\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    gap i t", "using gap_def"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  pdec2 (the (eval r_state [t, i]))\n  gap ?i ?t \\<equiv> pdec2 (the (eval r_state [?t, ?i]))\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n     [t, i, x] \\<down>=\n    gap i t", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  gap i t\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "have \"eval\n          (Cn 3 r_neq [Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [Id 3 0, Id 3 1]]])\n          [t, i, x] \\<down>=\n       (if x \\<noteq> gap i t then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_neq\n       [recf.Id 3 2,\n        Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n     [t, i, x] \\<down>=\n    (if x \\<noteq> gap i t then 0 else 1)", "using b k r_state_recfn r_state_total"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  block i t\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  gap i t\n  recfn 2 r_state\n  Partial_Recursive.total r_state\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_neq\n       [recf.Id 3 2,\n        Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n     [t, i, x] \\<down>=\n    (if x \\<noteq> gap i t then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "moreover"], ["proof (state)\nthis:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "have \"eval\n          (Cn 3 r_less\n            [Id 3 2, Cn 3 r_length [Cn 3 r_pdec1 [Cn 3 r_state [Id 3 0, Id 3 1]]]])\n          [t, i, x] \\<down>=\n       (if x < e_length (block i t) then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_less\n       [recf.Id 3 2,\n        Cn 3 r_length\n         [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n     [t, i, x] \\<down>=\n    (if x < e_length (block i t) then 0 else 1)", "using b k r_state_recfn r_state_total"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  block i t\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  gap i t\n  recfn 2 r_state\n  Partial_Recursive.total r_state\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_less\n       [recf.Id 3 2,\n        Cn 3 r_length\n         [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n     [t, i, x] \\<down>=\n    (if x < e_length (block i t) then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n   [t, i, x] \\<down>=\n  (if x < e_length (block i t) then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "ultimately"], ["proof (chain)\npicking this:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n  eval\n   (Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n   [t, i, x] \\<down>=\n  (if x < e_length (block i t) then 0 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n  eval\n   (Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n   [t, i, x] \\<down>=\n  (if x < e_length (block i t) then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval f [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "unfolding f_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n  eval\n   (Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n   [t, i, x] \\<down>=\n  (if x < e_length (block i t) then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n     [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "using b k r_state_recfn r_state_total"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 r_neq\n     [recf.Id 3 2, Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]])\n   [t, i, x] \\<down>=\n  (if x \\<noteq> gap i t then 0 else 1)\n  eval\n   (Cn 3 r_less\n     [recf.Id 3 2,\n      Cn 3 r_length\n       [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n   [t, i, x] \\<down>=\n  (if x < e_length (block i t) then 0 else 1)\n  eval (Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  block i t\n  eval (Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]])\n   [t, i, x] \\<down>=\n  gap i t\n  recfn 2 r_state\n  Partial_Recursive.total r_state\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_less\n         [recf.Id 3 2,\n          Cn 3 r_length\n           [Cn 3 r_pdec1 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]],\n        Cn 3 r_neq\n         [recf.Id 3 2,\n          Cn 3 r_pdec2 [Cn 3 r_state [recf.Id 3 0, recf.Id 3 1]]]])\n     [t, i, x] \\<down>=\n    (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  eval f [t, i, x] \\<down>=\n  (if x < e_length (block i t) \\<and> x \\<noteq> gap i t then 0 else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "{"], ["proof (state)\nthis:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "assume \"determined i x\""], ["proof (state)\nthis:\n  determined i x\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "with f"], ["proof (chain)\npicking this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  determined i x", "have \"\\<exists>t. eval f [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  determined i x\n\ngoal (1 subgoal):\n 1. \\<exists>t. eval f [t, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  \\<exists>t. eval f [t, i, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. eval f [t, i, x] \\<down>= 0", "have \"dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)\""], ["proof (prove)\nusing this:\n  \\<exists>t. eval f [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)", "using \\<open>total f\\<close> \\<open>r_dettime = Mn 2 f\\<close> r_dettime_recfn \\<open>recfn 3 f\\<close>\n        eval_Mn_total[of 2 f \"[i, x]\"]"], ["proof (prove)\nusing this:\n  \\<exists>t. eval f [t, i, x] \\<down>= 0\n  Partial_Recursive.total f\n  r_dettime = Mn 2 f\n  recfn 2 r_dettime\n  recfn 3 f\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 f);\n   Partial_Recursive.total f\\<rbrakk>\n  \\<Longrightarrow> eval (Mn 2 f) [i, x] =\n                    (if \\<exists>z. eval f [z, i, x] \\<down>= 0\n                     then Some (LEAST z. eval f [z, i, x] \\<down>= 0)\n                     else None)\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)", "by simp"], ["proof (state)\nthis:\n  dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)\n\ngoal (2 subgoals):\n 1. determined i x \\<Longrightarrow>\n    dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n 2. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "then"], ["proof (chain)\npicking this:\n  dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)", "show \"dettime i x \\<down>= (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\""], ["proof (prove)\nusing this:\n  dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)", "using f"], ["proof (prove)\nusing this:\n  dettime i x \\<down>= (LEAST t. eval f [t, i, x] \\<down>= 0)\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>=\n    (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)", "by simp"], ["proof (state)\nthis:\n  dettime i x \\<down>=\n  (LEAST t. x < e_length (block i t) \\<and> x \\<noteq> gap i t)\n\ngoal (1 subgoal):\n 1. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "assume \"\\<not> determined i x\""], ["proof (state)\nthis:\n  \\<not> determined i x\n\ngoal (1 subgoal):\n 1. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "with f"], ["proof (chain)\npicking this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  \\<not> determined i x", "have \"\\<not> (\\<exists>t. eval f [t, i, x] \\<down>= 0)\""], ["proof (prove)\nusing this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  \\<not> determined i x\n\ngoal (1 subgoal):\n 1. \\<nexists>t. eval f [t, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  \\<nexists>t. eval f [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "then"], ["proof (chain)\npicking this:\n  \\<nexists>t. eval f [t, i, x] \\<down>= 0", "have \"dettime i x \\<up>\""], ["proof (prove)\nusing this:\n  \\<nexists>t. eval f [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. dettime i x \\<up>", "using \\<open>total f\\<close> \\<open>r_dettime = Mn 2 f\\<close> r_dettime_recfn \\<open>recfn 3 f\\<close>\n        eval_Mn_total[of 2 f \"[i, x]\"]"], ["proof (prove)\nusing this:\n  \\<nexists>t. eval f [t, i, x] \\<down>= 0\n  Partial_Recursive.total f\n  r_dettime = Mn 2 f\n  recfn 2 r_dettime\n  recfn 3 f\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 f);\n   Partial_Recursive.total f\\<rbrakk>\n  \\<Longrightarrow> eval (Mn 2 f) [i, x] =\n                    (if \\<exists>z. eval f [z, i, x] \\<down>= 0\n                     then Some (LEAST z. eval f [z, i, x] \\<down>= 0)\n                     else None)\n\ngoal (1 subgoal):\n 1. dettime i x \\<up>", "by simp"], ["proof (state)\nthis:\n  dettime i x \\<up>\n\ngoal (1 subgoal):\n 1. \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>", "with f"], ["proof (chain)\npicking this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  dettime i x \\<up>", "show \"dettime i x \\<up>\""], ["proof (prove)\nusing this:\n  eval f [?t, i, x] \\<down>=\n  (if x < e_length (block i ?t) \\<and> x \\<noteq> gap i ?t then 0 else 1)\n  dettime i x \\<up>\n\ngoal (1 subgoal):\n 1. dettime i x \\<up>", "by simp"], ["proof (state)\nthis:\n  dettime i x \\<up>\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_dettimeI:\n  assumes \"x < e_length (block i t) \\<and> x \\<noteq> gap i t\"\n    and \"\\<And>T. x < e_length (block i T) \\<and> x \\<noteq> gap i T \\<Longrightarrow> t \\<le> T\"\n  shows \"dettime i x \\<down>= t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "let ?P = \"\\<lambda>T. x < e_length (block i T) \\<and> x \\<noteq> gap i T\""], ["proof (state)\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "have \"determined i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. determined i x", "using assms(1)"], ["proof (prove)\nusing this:\n  x < e_length (block i t) \\<and> x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. determined i x", "by auto"], ["proof (state)\nthis:\n  determined i x\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "moreover"], ["proof (state)\nthis:\n  determined i x\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "have \"Least ?P = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t", "using assms Least_equality[of ?P t]"], ["proof (prove)\nusing this:\n  x < e_length (block i t) \\<and> x \\<noteq> gap i t\n  x < e_length (block i ?T) \\<and> x \\<noteq> gap i ?T \\<Longrightarrow>\n  t \\<le> ?T\n  \\<lbrakk>x < e_length (block i t) \\<and> x \\<noteq> gap i t;\n   \\<And>y.\n      x < e_length (block i y) \\<and> x \\<noteq> gap i y \\<Longrightarrow>\n      t \\<le> y\\<rbrakk>\n  \\<Longrightarrow> (LEAST T.\n                        x < e_length (block i T) \\<and>\n                        x \\<noteq> gap i T) =\n                    t\n\ngoal (1 subgoal):\n 1. (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t", "by simp"], ["proof (state)\nthis:\n  (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "ultimately"], ["proof (chain)\npicking this:\n  determined i x\n  (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t", "show ?thesis"], ["proof (prove)\nusing this:\n  determined i x\n  (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "using r_dettime"], ["proof (prove)\nusing this:\n  determined i x\n  (LEAST T. x < e_length (block i T) \\<and> x \\<noteq> gap i T) = t\n  determined ?i ?x \\<Longrightarrow>\n  dettime ?i ?x \\<down>=\n  (LEAST t. ?x < e_length (block ?i t) \\<and> ?x \\<noteq> gap ?i t)\n  \\<not> determined ?i ?x \\<Longrightarrow> dettime ?i ?x \\<up>\n\ngoal (1 subgoal):\n 1. dettime i x \\<down>= t", "by simp"], ["proof (state)\nthis:\n  dettime i x \\<down>= t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_dettime_0: \"dettime i 0 \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dettime i 0 \\<down>= 0", "using r_dettimeI[of _ i 0] determined_0 gap_gr0[of i 0] gap_in_block[of i 0]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x < e_length (block i 0) \\<and> ?x \\<noteq> gap i 0;\n   \\<And>T.\n      ?x < e_length (block i T) \\<and> ?x \\<noteq> gap i T \\<Longrightarrow>\n      0 \\<le> T\\<rbrakk>\n  \\<Longrightarrow> dettime i ?x \\<down>= 0\n  determined ?i 0\n  0 < gap i 0\n  gap i 0 < e_length (block i 0)\n\ngoal (1 subgoal):\n 1. dettime i 0 \\<down>= 0", "by fastforce"], ["", "text \\<open>Computing the value of $\\tau_i(x)$ works by running the process\n@{term r_state} for @{term \"dettime i x\"} iterations and taking the value at\nindex $x$ of the resulting block.\\<close>"], ["", "definition \"r_tau \\<equiv> Cn 2 r_nth [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, Id 2 0]], Id 2 1]\""], ["", "lemma r_tau_recfn: \"recfn 2 r_tau\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_tau", "unfolding r_tau_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])", "using r_dettime_recfn r_state_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_dettime\n  recfn 2 r_state\n\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])", "by simp"], ["", "abbreviation tau :: partial2 (\"\\<tau>\") where\n  \"\\<tau> i x \\<equiv> eval r_tau [i, x]\""], ["", "lemma tau_in_P2: \"\\<tau> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<in> \\<P>\\<^sup>2", "using r_tau_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_tau\n\ngoal (1 subgoal):\n 1. \\<tau> \\<in> \\<P>\\<^sup>2", "by auto"], ["", "lemma tau_diverg:\n  assumes \"\\<not> determined i x\"\n  shows \"\\<tau> i x \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<up>", "unfolding r_tau_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])\n     [i, x] \\<up>", "using assms r_dettime r_dettime_recfn r_state_recfn"], ["proof (prove)\nusing this:\n  \\<not> determined i x\n  determined ?i ?x \\<Longrightarrow>\n  dettime ?i ?x \\<down>=\n  (LEAST t. ?x < e_length (block ?i t) \\<and> ?x \\<noteq> gap ?i t)\n  \\<not> determined ?i ?x \\<Longrightarrow> dettime ?i ?x \\<up>\n  recfn 2 r_dettime\n  recfn 2 r_state\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])\n     [i, x] \\<up>", "by simp"], ["", "lemma tau_converg:\n  assumes \"determined i x\"\n  shows \"\\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "from assms"], ["proof (chain)\npicking this:\n  determined i x", "obtain t where t: \"dettime i x \\<down>= t\""], ["proof (prove)\nusing this:\n  determined i x\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        dettime i x \\<down>= t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_dettime(1)"], ["proof (prove)\nusing this:\n  determined i x\n  determined ?i ?x \\<Longrightarrow>\n  dettime ?i ?x \\<down>=\n  (LEAST t. ?x < e_length (block ?i t) \\<and> ?x \\<noteq> gap ?i t)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        dettime i x \\<down>= t \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  dettime i x \\<down>= t\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "then"], ["proof (chain)\npicking this:\n  dettime i x \\<down>= t", "have \"eval (Cn 2 r_state [r_dettime, Id 2 0]) [i, x] = eval r_state [t, i]\""], ["proof (prove)\nusing this:\n  dettime i x \\<down>= t\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] =\n    eval r_state [t, i]", "using r_state_recfn r_dettime_recfn"], ["proof (prove)\nusing this:\n  dettime i x \\<down>= t\n  recfn 2 r_state\n  recfn 2 r_dettime\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] =\n    eval r_state [t, i]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] = eval r_state [t, i]\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "moreover"], ["proof (state)\nthis:\n  eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] = eval r_state [t, i]\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "have \"eval r_state [t, i] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_state [t, i] \\<down>", "using r_state_total r_state_recfn"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_state\n  recfn 2 r_state\n\ngoal (1 subgoal):\n 1. eval r_state [t, i] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_state [t, i] \\<down>\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] = eval r_state [t, i]\n  eval r_state [t, i] \\<down>", "have \"eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, Id 2 0]]) [i, x] =\n      eval r_pdec1 [the (eval r_state [t, i])]\""], ["proof (prove)\nusing this:\n  eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] = eval r_state [t, i]\n  eval r_state [t, i] \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n    eval r_pdec1 [the (eval r_state [t, i])]", "using r_state_recfn r_dettime_recfn"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_state [r_dettime, recf.Id 2 0]) [i, x] = eval r_state [t, i]\n  eval r_state [t, i] \\<down>\n  recfn 2 r_state\n  recfn 2 r_dettime\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n    eval r_pdec1 [the (eval r_state [t, i])]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n  eval r_pdec1 [the (eval r_state [t, i])]\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "then"], ["proof (chain)\npicking this:\n  eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n  eval r_pdec1 [the (eval r_state [t, i])]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n  eval r_pdec1 [the (eval r_state [t, i])]\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x", "unfolding r_tau_def"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n  eval r_pdec1 [the (eval r_state [t, i])]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])\n     [i, x] \\<down>=\n    e_nth (block i (the (dettime i x))) x", "using r_state_recfn r_dettime_recfn t block_def"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]]) [i, x] =\n  eval r_pdec1 [the (eval r_state [t, i])]\n  recfn 2 r_state\n  recfn 2 r_dettime\n  dettime i x \\<down>= t\n  block ?i ?t \\<equiv> pdec1 (the (eval r_state [?t, ?i]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_nth\n       [Cn 2 r_pdec1 [Cn 2 r_state [r_dettime, recf.Id 2 0]], recf.Id 2 1])\n     [i, x] \\<down>=\n    e_nth (block i (the (dettime i x))) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tau_converg':\n  assumes \"dettime i x \\<down>= t\"\n  shows \"\\<tau> i x \\<down>= e_nth (block i t) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "using assms tau_converg[of x i] r_dettime(2)[of x i]"], ["proof (prove)\nusing this:\n  dettime i x \\<down>= t\n  determined i x \\<Longrightarrow>\n  \\<tau> i x \\<down>= e_nth (block i (the (dettime i x))) x\n  \\<not> determined i x \\<Longrightarrow> dettime i x \\<up>\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "by fastforce"], ["", "lemma tau_at_0: \"\\<tau> i 0 \\<down>= i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= i", "have \"\\<tau> i 0 \\<down>= e_nth (block i 0) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= e_nth (block i 0) 0", "using tau_converg'[OF r_dettime_0]"], ["proof (prove)\nusing this:\n  \\<tau> ?i 0 \\<down>= e_nth (block ?i 0) 0\n\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= e_nth (block i 0) 0", "by simp"], ["proof (state)\nthis:\n  \\<tau> i 0 \\<down>= e_nth (block i 0) 0\n\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= i", "then"], ["proof (chain)\npicking this:\n  \\<tau> i 0 \\<down>= e_nth (block i 0) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> i 0 \\<down>= e_nth (block i 0) 0\n\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= i", "using block_def"], ["proof (prove)\nusing this:\n  \\<tau> i 0 \\<down>= e_nth (block i 0) 0\n  block ?i ?t \\<equiv> pdec1 (the (eval r_state [?t, ?i]))\n\ngoal (1 subgoal):\n 1. \\<tau> i 0 \\<down>= i", "by (simp add: r_state_at_0)"], ["proof (state)\nthis:\n  \\<tau> i 0 \\<down>= i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_unchanged:\n  assumes \"gap i t - 1 \\<le> y\" and \"y \\<le> t\"\n  shows \"gap i t = gap i y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t = gap i y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gap i t = gap i y", "have \"gap i t = gap i (gap i t - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t = gap i (gap i t - 1)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. gap i 0 = gap i (gap i 0 - 1)\n 2. \\<And>t.\n       gap i t = gap i (gap i t - 1) \\<Longrightarrow>\n       gap i (Suc t) = gap i (gap i (Suc t) - 1)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. gap i 0 = gap i (gap i 0 - 1)\n 2. \\<And>t.\n       gap i t = gap i (gap i t - 1) \\<Longrightarrow>\n       gap i (Suc t) = gap i (gap i (Suc t) - 1)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i 0 = gap i (gap i 0 - 1)", "by (simp add: gap_def r_state_at_0)"], ["proof (state)\nthis:\n  gap i 0 = gap i (gap i 0 - 1)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t = gap i (gap i t - 1) \\<Longrightarrow>\n       gap i (Suc t) = gap i (gap i (Suc t) - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t = gap i (gap i t - 1) \\<Longrightarrow>\n       gap i (Suc t) = gap i (gap i (Suc t) - 1)", "case (Suc t)"], ["proof (state)\nthis:\n  gap i t = gap i (gap i t - 1)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       gap i t = gap i (gap i t - 1) \\<Longrightarrow>\n       gap i (Suc t) = gap i (gap i (Suc t) - 1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i (Suc t) = gap i (gap i (Suc t) - 1)", "proof (cases \"gap i (Suc t) = t + 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. gap i (Suc t) = t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)\n 2. gap i (Suc t) \\<noteq> t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)", "case True"], ["proof (state)\nthis:\n  gap i (Suc t) = t + 2\n\ngoal (2 subgoals):\n 1. gap i (Suc t) = t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)\n 2. gap i (Suc t) \\<noteq> t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) = t + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i (Suc t) = t + 2\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = gap i (gap i (Suc t) - 1)", "by simp"], ["proof (state)\nthis:\n  gap i (Suc t) = gap i (gap i (Suc t) - 1)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)", "case False"], ["proof (state)\nthis:\n  gap i (Suc t) \\<noteq> t + 2\n\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> t + 2 \\<Longrightarrow>\n    gap i (Suc t) = gap i (gap i (Suc t) - 1)", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) \\<noteq> t + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i (Suc t) \\<noteq> t + 2\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = gap i (gap i (Suc t) - 1)", "using Suc state_change_on_either(2) length_block"], ["proof (prove)\nusing this:\n  gap i (Suc t) \\<noteq> t + 2\n  gap i t = gap i (gap i t - 1)\n  gap ?i (Suc ?t) \\<noteq> gap ?i ?t \\<Longrightarrow>\n  gap ?i (Suc ?t) = e_length (block ?i ?t)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = gap i (gap i (Suc t) - 1)", "by force"], ["proof (state)\nthis:\n  gap i (Suc t) = gap i (gap i (Suc t) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i (Suc t) = gap i (gap i (Suc t) - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i t = gap i (gap i t - 1)\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "moreover"], ["proof (state)\nthis:\n  gap i t = gap i (gap i t - 1)\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "have \"gap i (gap i t - 1) \\<le> gap i y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i (gap i t - 1) \\<le> gap i y", "using assms(1) gap_monotone"], ["proof (prove)\nusing this:\n  gap i t - 1 \\<le> y\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. gap i (gap i t - 1) \\<le> gap i y", "by simp"], ["proof (state)\nthis:\n  gap i (gap i t - 1) \\<le> gap i y\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "moreover"], ["proof (state)\nthis:\n  gap i (gap i t - 1) \\<le> gap i y\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "have \"gap i y \\<le> gap i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i y \\<le> gap i t", "using assms(2) gap_monotone"], ["proof (prove)\nusing this:\n  y \\<le> t\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. gap i y \\<le> gap i t", "by simp"], ["proof (state)\nthis:\n  gap i y \\<le> gap i t\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "ultimately"], ["proof (chain)\npicking this:\n  gap i t = gap i (gap i t - 1)\n  gap i (gap i t - 1) \\<le> gap i y\n  gap i y \\<le> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i t = gap i (gap i t - 1)\n  gap i (gap i t - 1) \\<le> gap i y\n  gap i y \\<le> gap i t\n\ngoal (1 subgoal):\n 1. gap i t = gap i y", "by simp"], ["proof (state)\nthis:\n  gap i t = gap i y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The values of the non-gap indices $x$ of every block created in\nthe diagonalization process equal $\\tau_i(x)$.\\<close>"], ["", "lemma tau_eq_state:\n  assumes \"j < e_length (block i t)\" and \"j \\<noteq> gap i t\"\n  shows \"\\<tau> i j \\<down>= e_nth (block i t) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i t) j", "using assms"], ["proof (prove)\nusing this:\n  j < e_length (block i t)\n  j \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i t) j", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>j < e_length (block i 0); j \\<noteq> gap i 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i 0) j\n 2. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case 0"], ["proof (state)\nthis:\n  j < e_length (block i 0)\n  j \\<noteq> gap i 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < e_length (block i 0); j \\<noteq> gap i 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i 0) j\n 2. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j < e_length (block i 0)\n  j \\<noteq> gap i 0", "have \"j = 0\""], ["proof (prove)\nusing this:\n  j < e_length (block i 0)\n  j \\<noteq> gap i 0\n\ngoal (1 subgoal):\n 1. j = 0", "using gap_gr0[of i 0] gap_in_block[of i 0] length_block[of i 0]"], ["proof (prove)\nusing this:\n  j < e_length (block i 0)\n  j \\<noteq> gap i 0\n  0 < gap i 0\n  gap i 0 < e_length (block i 0)\n  e_length (block i 0) = Suc (Suc 0)\n\ngoal (1 subgoal):\n 1. j = 0", "by simp"], ["proof (state)\nthis:\n  j = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < e_length (block i 0); j \\<noteq> gap i 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i 0) j\n 2. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j = 0", "have \"\\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i (the (dettime i 0))) 0\""], ["proof (prove)\nusing this:\n  j = 0\n\ngoal (1 subgoal):\n 1. \\<tau> (e_hd (block i t)) j \\<down>=\n    e_nth (block i (the (dettime i 0))) 0", "using determined_0 tau_converg hd_block"], ["proof (prove)\nusing this:\n  j = 0\n  determined ?i 0\n  determined ?i ?x \\<Longrightarrow>\n  \\<tau> ?i ?x \\<down>= e_nth (block ?i (the (dettime ?i ?x))) ?x\n  e_hd (block ?i ?t) = ?i\n\ngoal (1 subgoal):\n 1. \\<tau> (e_hd (block i t)) j \\<down>=\n    e_nth (block i (the (dettime i 0))) 0", "by simp"], ["proof (state)\nthis:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i (the (dettime i 0))) 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < e_length (block i 0); j \\<noteq> gap i 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i 0) j\n 2. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i (the (dettime i 0))) 0", "have \"\\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0\""], ["proof (prove)\nusing this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i (the (dettime i 0))) 0\n\ngoal (1 subgoal):\n 1. \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0", "using r_dettime_0"], ["proof (prove)\nusing this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i (the (dettime i 0))) 0\n  dettime ?i 0 \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0", "by simp"], ["proof (state)\nthis:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>j < e_length (block i 0); j \\<noteq> gap i 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i 0) j\n 2. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0", "show ?case"], ["proof (prove)\nusing this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i 0) j", "using \\<open>j = 0\\<close> r_dettime_0 tau_converg'"], ["proof (prove)\nusing this:\n  \\<tau> (e_hd (block i t)) j \\<down>= e_nth (block i 0) 0\n  j = 0\n  dettime ?i 0 \\<down>= 0\n  dettime ?i ?x \\<down>= ?t \\<Longrightarrow>\n  \\<tau> ?i ?x \\<down>= e_nth (block ?i ?t) ?x\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i 0) j", "by simp"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i 0) j\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case (Suc t)"], ["proof (state)\nthis:\n  \\<lbrakk>j < e_length (block i t); j \\<noteq> gap i t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "let ?b = \"block i t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "let ?bb = \"block i (Suc t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "let ?k = \"gap i t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "let ?kk = \"gap i (Suc t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>\\<lbrakk>j < e_length (block i t);\n                 j \\<noteq> gap i t\\<rbrakk>\n                \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j;\n        j < e_length (block i (Suc t)); j \\<noteq> gap i (Suc t)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "proof (cases \"?kk = ?k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. gap i (Suc t) = gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case kk_eq_k: True"], ["proof (state)\nthis:\n  gap i (Suc t) = gap i t\n\ngoal (2 subgoals):\n 1. gap i (Suc t) = gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) = gap i t", "have bb_b0: \"?bb = e_snoc ?b 0\""], ["proof (prove)\nusing this:\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0", "using state_change_on_neither"], ["proof (prove)\nusing this:\n  gap i (Suc t) = gap i t\n  gap ?i (Suc ?t) = gap ?i ?t \\<Longrightarrow>\n  change_on_neither (block ?i ?t) (gap ?i ?t)\n  gap ?i (Suc ?t) = gap ?i ?t \\<Longrightarrow>\n  block ?i (Suc ?t) = e_snoc (block ?i ?t) 0\n\ngoal (1 subgoal):\n 1. block i (Suc t) = e_snoc (block i t) 0", "by simp"], ["proof (state)\nthis:\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (2 subgoals):\n 1. gap i (Suc t) = gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "show \"\\<tau> i j \\<down>= e_nth ?bb j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "proof (cases \"j < e_length ?b\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case True"], ["proof (state)\nthis:\n  j < e_length (block i t)\n\ngoal (2 subgoals):\n 1. j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j < e_length (block i t)", "have \"e_nth ?bb j = e_nth ?b j\""], ["proof (prove)\nusing this:\n  j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) j = e_nth (block i t) j", "using bb_b0"], ["proof (prove)\nusing this:\n  j < e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) j = e_nth (block i t) j", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) j = e_nth (block i t) j\n\ngoal (2 subgoals):\n 1. j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "moreover"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) j = e_nth (block i t) j\n\ngoal (2 subgoals):\n 1. j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "have \"j \\<noteq> ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<noteq> gap i t", "using Suc kk_eq_k"], ["proof (prove)\nusing this:\n  \\<lbrakk>j < e_length (block i t); j \\<noteq> gap i t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n  gap i (Suc t) = gap i t\n\ngoal (1 subgoal):\n 1. j \\<noteq> gap i t", "by simp"], ["proof (state)\nthis:\n  j \\<noteq> gap i t\n\ngoal (2 subgoals):\n 1. j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "ultimately"], ["proof (chain)\npicking this:\n  e_nth (block i (Suc t)) j = e_nth (block i t) j\n  j \\<noteq> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  e_nth (block i (Suc t)) j = e_nth (block i t) j\n  j \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "using Suc True"], ["proof (prove)\nusing this:\n  e_nth (block i (Suc t)) j = e_nth (block i t) j\n  j \\<noteq> gap i t\n  \\<lbrakk>j < e_length (block i t); j \\<noteq> gap i t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n  j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "by simp"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case False"], ["proof (state)\nthis:\n  \\<not> j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  \\<not> j < e_length (block i t)", "have j: \"j = e_length ?b\""], ["proof (prove)\nusing this:\n  \\<not> j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. j = e_length (block i t)", "using Suc.prems(1) length_block"], ["proof (prove)\nusing this:\n  \\<not> j < e_length (block i t)\n  j < e_length (block i (Suc t))\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. j = e_length (block i t)", "by auto"], ["proof (state)\nthis:\n  j = e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j = e_length (block i t)", "have \"e_nth ?bb j = 0\""], ["proof (prove)\nusing this:\n  j = e_length (block i t)\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) j = 0", "using bb_b0"], ["proof (prove)\nusing this:\n  j = e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (1 subgoal):\n 1. e_nth (block i (Suc t)) j = 0", "by simp"], ["proof (state)\nthis:\n  e_nth (block i (Suc t)) j = 0\n\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "have \"dettime i j \\<down>= Suc t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dettime i j \\<down>= Suc t", "proof (rule r_dettimeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)\n 2. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "show \"j < e_length ?bb \\<and> j \\<noteq> ?kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)", "using Suc.prems(1,2)"], ["proof (prove)\nusing this:\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)", "by linarith"], ["proof (state)\nthis:\n  j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "show \"\\<And>T. j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow> Suc t \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "using length_block j"], ["proof (prove)\nusing this:\n  e_length (block ?i ?t) = Suc (Suc ?t)\n  j = e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "by simp"], ["proof (state)\nthis:\n  j < e_length (block i ?T) \\<and> j \\<noteq> gap i ?T \\<Longrightarrow>\n  Suc t \\<le> ?T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dettime i j \\<down>= Suc t\n\ngoal (1 subgoal):\n 1. \\<not> j < e_length (block i t) \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "with tau_converg'"], ["proof (chain)\npicking this:\n  dettime ?i ?x \\<down>= ?t \\<Longrightarrow>\n  \\<tau> ?i ?x \\<down>= e_nth (block ?i ?t) ?x\n  dettime i j \\<down>= Suc t", "show ?thesis"], ["proof (prove)\nusing this:\n  dettime ?i ?x \\<down>= ?t \\<Longrightarrow>\n  \\<tau> ?i ?x \\<down>= e_nth (block ?i ?t) ?x\n  dettime i j \\<down>= Suc t\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "by simp"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case False"], ["proof (state)\nthis:\n  gap i (Suc t) \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) \\<noteq> gap i t", "have kk_lenb: \"?kk = e_length ?b\""], ["proof (prove)\nusing this:\n  gap i (Suc t) \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t)", "using state_change_on_either"], ["proof (prove)\nusing this:\n  gap i (Suc t) \\<noteq> gap i t\n  gap ?i (Suc ?t) \\<noteq> gap ?i ?t \\<Longrightarrow>\n  \\<not> change_on_neither (block ?i ?t) (gap ?i ?t)\n  gap ?i (Suc ?t) \\<noteq> gap ?i ?t \\<Longrightarrow>\n  gap ?i (Suc ?t) = e_length (block ?i ?t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t)", "by simp"], ["proof (state)\nthis:\n  gap i (Suc t) = e_length (block i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) = e_length (block i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i (Suc t) = e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "proof (cases \"j = ?k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t); j = gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case j_eq_k: True"], ["proof (state)\nthis:\n  j = gap i t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t); j = gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "have \"dettime i j \\<down>= Suc t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dettime i j \\<down>= Suc t", "proof (rule r_dettimeI)"], ["proof (state)\ngoal (2 subgoals):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)\n 2. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "show \"j < e_length ?bb \\<and> j \\<noteq> ?kk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)", "using Suc.prems(1,2)"], ["proof (prove)\nusing this:\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)", "by simp"], ["proof (state)\nthis:\n  j < e_length (block i (Suc t)) \\<and> j \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       j < e_length (block i T) \\<and> j \\<noteq> gap i T \\<Longrightarrow>\n       Suc t \\<le> T", "show \"Suc t \\<le> T\" if \"j < e_length (block i T) \\<and> j \\<noteq> gap i T\" for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc t \\<le> T", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Suc t \\<le> T \\<Longrightarrow> False", "assume \"\\<not> (Suc t \\<le> T)\""], ["proof (state)\nthis:\n  \\<not> Suc t \\<le> T\n\ngoal (1 subgoal):\n 1. \\<not> Suc t \\<le> T \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> Suc t \\<le> T", "have \"T < Suc t\""], ["proof (prove)\nusing this:\n  \\<not> Suc t \\<le> T\n\ngoal (1 subgoal):\n 1. T < Suc t", "by simp"], ["proof (state)\nthis:\n  T < Suc t\n\ngoal (1 subgoal):\n 1. \\<not> Suc t \\<le> T \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  T < Suc t", "show False"], ["proof (prove)\nusing this:\n  T < Suc t\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"T < ?k - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  T < gap i t - 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  T < gap i t - 1", "have \"e_length (block i T) = T + 2\""], ["proof (prove)\nusing this:\n  T < gap i t - 1\n\ngoal (1 subgoal):\n 1. e_length (block i T) = T + 2", "using length_block"], ["proof (prove)\nusing this:\n  T < gap i t - 1\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_length (block i T) = T + 2", "by simp"], ["proof (state)\nthis:\n  e_length (block i T) = T + 2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e_length (block i T) = T + 2", "have \"e_length (block i T) < ?k + 1\""], ["proof (prove)\nusing this:\n  e_length (block i T) = T + 2\n\ngoal (1 subgoal):\n 1. e_length (block i T) < gap i t + 1", "using True"], ["proof (prove)\nusing this:\n  e_length (block i T) = T + 2\n  T < gap i t - 1\n\ngoal (1 subgoal):\n 1. e_length (block i T) < gap i t + 1", "by simp"], ["proof (state)\nthis:\n  e_length (block i T) < gap i t + 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e_length (block i T) < gap i t + 1", "have \"e_length (block i T) \\<le> ?k\""], ["proof (prove)\nusing this:\n  e_length (block i T) < gap i t + 1\n\ngoal (1 subgoal):\n 1. e_length (block i T) \\<le> gap i t", "by simp"], ["proof (state)\nthis:\n  e_length (block i T) \\<le> gap i t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e_length (block i T) \\<le> gap i t", "have \"e_length (block i T) \\<le> j\""], ["proof (prove)\nusing this:\n  e_length (block i T) \\<le> gap i t\n\ngoal (1 subgoal):\n 1. e_length (block i T) \\<le> j", "using j_eq_k"], ["proof (prove)\nusing this:\n  e_length (block i T) \\<le> gap i t\n  j = gap i t\n\ngoal (1 subgoal):\n 1. e_length (block i T) \\<le> j", "by simp"], ["proof (state)\nthis:\n  e_length (block i T) \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>T < Suc t; T < gap i t - 1\\<rbrakk> \\<Longrightarrow> False\n 2. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  e_length (block i T) \\<le> j", "show False"], ["proof (prove)\nusing this:\n  e_length (block i T) \\<le> j\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  e_length (block i T) \\<le> j\n  j < e_length (block i T) \\<and> j \\<noteq> gap i T\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> T < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> T < gap i t - 1", "have \"?k - 1 \\<le> T\" and \"T \\<le> t\""], ["proof (prove)\nusing this:\n  \\<not> T < gap i t - 1\n\ngoal (1 subgoal):\n 1. gap i t - 1 \\<le> T &&& T \\<le> t", "using \\<open>T < Suc t\\<close>"], ["proof (prove)\nusing this:\n  \\<not> T < gap i t - 1\n  T < Suc t\n\ngoal (1 subgoal):\n 1. gap i t - 1 \\<le> T &&& T \\<le> t", "by simp_all"], ["proof (state)\nthis:\n  gap i t - 1 \\<le> T\n  T \\<le> t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "with state_unchanged"], ["proof (chain)\npicking this:\n  \\<lbrakk>gap ?i ?t - 1 \\<le> ?y; ?y \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> gap ?i ?t = gap ?i ?y\n  gap i t - 1 \\<le> T\n  T \\<le> t", "have \"gap i t = gap i T\""], ["proof (prove)\nusing this:\n  \\<lbrakk>gap ?i ?t - 1 \\<le> ?y; ?y \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> gap ?i ?t = gap ?i ?y\n  gap i t - 1 \\<le> T\n  T \\<le> t\n\ngoal (1 subgoal):\n 1. gap i t = gap i T", "by blast"], ["proof (state)\nthis:\n  gap i t = gap i T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>T < Suc t; \\<not> T < gap i t - 1\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  gap i t = gap i T", "show False"], ["proof (prove)\nusing this:\n  gap i t = gap i T\n\ngoal (1 subgoal):\n 1. False", "using j_eq_k that"], ["proof (prove)\nusing this:\n  gap i t = gap i T\n  j = gap i t\n  j < e_length (block i T) \\<and> j \\<noteq> gap i T\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  j < e_length (block i ?T) \\<and> j \\<noteq> gap i ?T \\<Longrightarrow>\n  Suc t \\<le> ?T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dettime i j \\<down>= Suc t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t); j = gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n 2. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  dettime i j \\<down>= Suc t", "show ?thesis"], ["proof (prove)\nusing this:\n  dettime i j \\<down>= Suc t\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "using tau_converg'"], ["proof (prove)\nusing this:\n  dettime i j \\<down>= Suc t\n  dettime ?i ?x \\<down>= ?t \\<Longrightarrow>\n  \\<tau> ?i ?x \\<down>= e_nth (block ?i ?t) ?x\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "by simp"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "case False"], ["proof (state)\nthis:\n  j \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j \\<noteq> gap i t", "have \"j < e_length ?b\""], ["proof (prove)\nusing this:\n  j \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. j < e_length (block i t)", "using kk_lenb Suc.prems(1,2) length_block"], ["proof (prove)\nusing this:\n  j \\<noteq> gap i t\n  gap i (Suc t) = e_length (block i t)\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. j < e_length (block i t)", "by auto"], ["proof (state)\nthis:\n  j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>gap i (Suc t) = e_length (block i t);\n     j \\<noteq> gap i t\\<rbrakk>\n    \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "then"], ["proof (chain)\npicking this:\n  j < e_length (block i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  j < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "using Suc False block_stable"], ["proof (prove)\nusing this:\n  j < e_length (block i t)\n  \\<lbrakk>j < e_length (block i t); j \\<noteq> gap i t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> i j \\<down>= e_nth (block i t) j\n  j < e_length (block i (Suc t))\n  j \\<noteq> gap i (Suc t)\n  j \\<noteq> gap i t\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> e_nth (block ?i ?t) ?j = e_nth (block ?i (Suc ?t)) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i (Suc t)) j", "by fastforce"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> i j \\<down>= e_nth (block i (Suc t)) j\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tau_eq_state':\n  assumes \"j < t + 2\" and \" j \\<noteq> gap i t\"\n  shows \"\\<tau> i j \\<down>= e_nth (block i t) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i t) j", "using assms tau_eq_state length_block"], ["proof (prove)\nusing this:\n  j < t + 2\n  j \\<noteq> gap i t\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. \\<tau> i j \\<down>= e_nth (block i t) j", "by simp"], ["", "text \\<open>We now consider the two cases described in the proof sketch.\nIn Case~2 there is a gap that never gets filled, or equivalently there is\na rightmost gap.\\<close>"], ["", "abbreviation \"case_two i \\<equiv> (\\<exists>t. \\<forall>T. gap i T \\<le> gap i t)\""], ["", "abbreviation \"case_one i \\<equiv> \\<not> case_two i\""], ["", "text \\<open>Another characterization of Case~2 is that from some iteration on\nonly @{term change_on_neither} holds.\\<close>"], ["", "lemma case_two_iff_forever_neither:\n  \"case_two i \\<longleftrightarrow> (\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. case_two i =\n    (\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n 2. \\<exists>t.\n       \\<forall>T\\<ge>t.\n          change_on_neither (block i T) (gap i T) \\<Longrightarrow>\n    case_two i", "assume \"\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\""], ["proof (state)\nthis:\n  \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n 2. \\<exists>t.\n       \\<forall>T\\<ge>t.\n          change_on_neither (block i T) (gap i T) \\<Longrightarrow>\n    case_two i", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "obtain t where t: \"\\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\""], ["proof (prove)\nusing this:\n  \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<forall>T\\<ge>t.\n           change_on_neither (block i T) (gap i T) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n 2. \\<exists>t.\n       \\<forall>T\\<ge>t.\n          change_on_neither (block i T) (gap i T) \\<Longrightarrow>\n    case_two i", "have \"(gap i T) \\<le> (gap i t)\" for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i T \\<le> gap i t", "proof (cases \"T \\<le> t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n 2. \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t", "case True"], ["proof (state)\nthis:\n  T \\<le> t\n\ngoal (2 subgoals):\n 1. T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n 2. \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t", "then"], ["proof (chain)\npicking this:\n  T \\<le> t", "show ?thesis"], ["proof (prove)\nusing this:\n  T \\<le> t\n\ngoal (1 subgoal):\n 1. gap i T \\<le> gap i t", "using gap_monotone"], ["proof (prove)\nusing this:\n  T \\<le> t\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. gap i T \\<le> gap i t", "by simp"], ["proof (state)\nthis:\n  gap i T \\<le> gap i t\n\ngoal (1 subgoal):\n 1. \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t", "case False"], ["proof (state)\nthis:\n  \\<not> T \\<le> t\n\ngoal (1 subgoal):\n 1. \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t", "then"], ["proof (chain)\npicking this:\n  \\<not> T \\<le> t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> T \\<le> t\n\ngoal (1 subgoal):\n 1. gap i T \\<le> gap i t", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> 0 \\<le> t \\<Longrightarrow> gap i 0 \\<le> gap i t\n 2. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "case 0"], ["proof (state)\nthis:\n  \\<not> 0 \\<le> t\n\ngoal (2 subgoals):\n 1. \\<not> 0 \\<le> t \\<Longrightarrow> gap i 0 \\<le> gap i t\n 2. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 \\<le> t", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> 0 \\<le> t\n\ngoal (1 subgoal):\n 1. gap i 0 \\<le> gap i t", "by simp"], ["proof (state)\nthis:\n  gap i 0 \\<le> gap i t\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "case (Suc T)"], ["proof (state)\nthis:\n  \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n  \\<not> Suc T \\<le> t\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "with t"], ["proof (chain)\npicking this:\n  \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n  \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n  \\<not> Suc T \\<le> t", "have \"change_on_neither ((block i T)) ((gap i T))\""], ["proof (prove)\nusing this:\n  \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n  \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n  \\<not> Suc T \\<le> t\n\ngoal (1 subgoal):\n 1. change_on_neither (block i T) (gap i T)", "by simp"], ["proof (state)\nthis:\n  change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<And>T.\n       \\<lbrakk>\\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t;\n        \\<not> Suc T \\<le> t\\<rbrakk>\n       \\<Longrightarrow> gap i (Suc T) \\<le> gap i t", "then"], ["proof (chain)\npicking this:\n  change_on_neither (block i T) (gap i T)", "show ?case"], ["proof (prove)\nusing this:\n  change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. gap i (Suc T) \\<le> gap i t", "using Suc.IH state_change_on_either(1)[of i T] gap_monotone[of T t i]"], ["proof (prove)\nusing this:\n  change_on_neither (block i T) (gap i T)\n  \\<not> T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n  gap i (Suc T) \\<noteq> gap i T \\<Longrightarrow>\n  \\<not> change_on_neither (block i T) (gap i T)\n  T \\<le> t \\<Longrightarrow> gap i T \\<le> gap i t\n\ngoal (1 subgoal):\n 1. gap i (Suc T) \\<le> gap i t", "by metis"], ["proof (state)\nthis:\n  gap i (Suc T) \\<le> gap i t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i T \\<le> gap i t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gap i ?T \\<le> gap i t\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n 2. \\<exists>t.\n       \\<forall>T\\<ge>t.\n          change_on_neither (block i T) (gap i T) \\<Longrightarrow>\n    case_two i", "then"], ["proof (chain)\npicking this:\n  gap i ?T \\<le> gap i t", "show \"\\<exists>t. \\<forall>T. gap i T \\<le> gap i t\""], ["proof (prove)\nusing this:\n  gap i ?T \\<le> gap i t\n\ngoal (1 subgoal):\n 1. case_two i", "by auto"], ["proof (state)\nthis:\n  case_two i\n\ngoal (1 subgoal):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "assume \"\\<exists>t. \\<forall>T. gap i T \\<le> gap i t\""], ["proof (state)\nthis:\n  case_two i\n\ngoal (1 subgoal):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "then"], ["proof (chain)\npicking this:\n  case_two i", "obtain t where t: \"\\<forall>T. gap i T \\<le> gap i t\""], ["proof (prove)\nusing this:\n  case_two i\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<forall>T. gap i T \\<le> gap i t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>T. gap i T \\<le> gap i t\n\ngoal (1 subgoal):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "have \"change_on_neither (block i T) (gap i T)\" if \"T\\<ge>t\" for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_on_neither (block i T) (gap i T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. change_on_neither (block i T) (gap i T)", "have T: \"(gap i T) \\<ge> (gap i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t \\<le> gap i T", "using gap_monotone that"], ["proof (prove)\nusing this:\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n  t \\<le> T\n\ngoal (1 subgoal):\n 1. gap i t \\<le> gap i T", "by simp"], ["proof (state)\nthis:\n  gap i t \\<le> gap i T\n\ngoal (1 subgoal):\n 1. change_on_neither (block i T) (gap i T)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. change_on_neither (block i T) (gap i T)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i T) (gap i T) \\<Longrightarrow> False", "assume \"\\<not> change_on_neither (block i T) (gap i T)\""], ["proof (state)\nthis:\n  \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i T) (gap i T) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> change_on_neither (block i T) (gap i T)", "have \"change_on_0 (block i T) (gap i T) \\<or> change_on_1 (block i T) (gap i T)\""], ["proof (prove)\nusing this:\n  \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. change_on_0 (block i T) (gap i T) \\<or>\n    change_on_1 (block i T) (gap i T)", "by simp"], ["proof (state)\nthis:\n  change_on_0 (block i T) (gap i T) \\<or> change_on_1 (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i T) (gap i T) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  change_on_0 (block i T) (gap i T) \\<or> change_on_1 (block i T) (gap i T)", "have \"gap i (Suc T) > gap i T\""], ["proof (prove)\nusing this:\n  change_on_0 (block i T) (gap i T) \\<or> change_on_1 (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. gap i T < gap i (Suc T)", "using gap_le_Suc[of i] state_change_on_either(2)[of i] state_change_on_neither(1)[of i]\n          dual_order.strict_iff_order"], ["proof (prove)\nusing this:\n  change_on_0 (block i T) (gap i T) \\<or> change_on_1 (block i T) (gap i T)\n  gap i ?t \\<le> gap i (Suc ?t)\n  gap i (Suc ?t) \\<noteq> gap i ?t \\<Longrightarrow>\n  gap i (Suc ?t) = e_length (block i ?t)\n  gap i (Suc ?t) = gap i ?t \\<Longrightarrow>\n  change_on_neither (block i ?t) (gap i ?t)\n  (?b < ?a) = (?b \\<le> ?a \\<and> ?a \\<noteq> ?b)\n\ngoal (1 subgoal):\n 1. gap i T < gap i (Suc T)", "by blast"], ["proof (state)\nthis:\n  gap i T < gap i (Suc T)\n\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i T) (gap i T) \\<Longrightarrow> False", "with T"], ["proof (chain)\npicking this:\n  gap i t \\<le> gap i T\n  gap i T < gap i (Suc T)", "have \"gap i (Suc T) > gap i t\""], ["proof (prove)\nusing this:\n  gap i t \\<le> gap i T\n  gap i T < gap i (Suc T)\n\ngoal (1 subgoal):\n 1. gap i t < gap i (Suc T)", "by simp"], ["proof (state)\nthis:\n  gap i t < gap i (Suc T)\n\ngoal (1 subgoal):\n 1. \\<not> change_on_neither (block i T) (gap i T) \\<Longrightarrow> False", "with t"], ["proof (chain)\npicking this:\n  \\<forall>T. gap i T \\<le> gap i t\n  gap i t < gap i (Suc T)", "show False"], ["proof (prove)\nusing this:\n  \\<forall>T. gap i T \\<le> gap i t\n  gap i t < gap i (Suc T)\n\ngoal (1 subgoal):\n 1. False", "using not_le"], ["proof (prove)\nusing this:\n  \\<forall>T. gap i T \\<le> gap i t\n  gap i t < gap i (Suc T)\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_on_neither (block i T) (gap i T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<le> ?T \\<Longrightarrow> change_on_neither (block i ?T) (gap i ?T)\n\ngoal (1 subgoal):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "then"], ["proof (chain)\npicking this:\n  t \\<le> ?T \\<Longrightarrow> change_on_neither (block i ?T) (gap i ?T)", "show \"\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\""], ["proof (prove)\nusing this:\n  t \\<le> ?T \\<Longrightarrow> change_on_neither (block i ?T) (gap i ?T)\n\ngoal (1 subgoal):\n 1. \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block i T) (gap i T)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In Case~1, $\\tau_i$ is total.\\<close>"], ["", "lemma case_one_tau_total:\n  assumes \"case_one i\"\n  shows \"\\<tau> i x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "proof (cases \"x = gap i x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "case True"], ["proof (state)\nthis:\n  x = gap i x\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "from assms"], ["proof (chain)\npicking this:\n  case_one i", "have \"\\<forall>t. \\<exists>T. gap i T > gap i t\""], ["proof (prove)\nusing this:\n  case_one i\n\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>T. gap i t < gap i T", "using le_less_linear gap_def[of i x]"], ["proof (prove)\nusing this:\n  case_one i\n  ?x \\<le> ?y \\<or> ?y < ?x\n  gap i x \\<equiv> pdec2 (the (eval r_state [x, i]))\n\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>T. gap i t < gap i T", "by blast"], ["proof (state)\nthis:\n  \\<forall>t. \\<exists>T. gap i t < gap i T\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<forall>t. \\<exists>T. gap i t < gap i T", "obtain T where T: \"gap i T > gap i x\""], ["proof (prove)\nusing this:\n  \\<forall>t. \\<exists>T. gap i t < gap i T\n\ngoal (1 subgoal):\n 1. (\\<And>T. gap i x < gap i T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gap i x < gap i T\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  gap i x < gap i T", "have \"T > x\""], ["proof (prove)\nusing this:\n  gap i x < gap i T\n\ngoal (1 subgoal):\n 1. x < T", "using gap_monotone leD le_less_linear"], ["proof (prove)\nusing this:\n  gap i x < gap i T\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n  ?y \\<le> ?x \\<Longrightarrow> \\<not> ?x < ?y\n  ?x \\<le> ?y \\<or> ?y < ?x\n\ngoal (1 subgoal):\n 1. x < T", "by blast"], ["proof (state)\nthis:\n  x < T\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  x < T", "have \"x < T + 2\""], ["proof (prove)\nusing this:\n  x < T\n\ngoal (1 subgoal):\n 1. x < T + 2", "by simp"], ["proof (state)\nthis:\n  x < T + 2\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "moreover"], ["proof (state)\nthis:\n  x < T + 2\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "from T True"], ["proof (chain)\npicking this:\n  gap i x < gap i T\n  x = gap i x", "have \"x \\<noteq> gap i T\""], ["proof (prove)\nusing this:\n  gap i x < gap i T\n  x = gap i x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i T", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> gap i T\n\ngoal (2 subgoals):\n 1. x = gap i x \\<Longrightarrow> \\<tau> i x \\<down>\n 2. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "ultimately"], ["proof (chain)\npicking this:\n  x < T + 2\n  x \\<noteq> gap i T", "show ?thesis"], ["proof (prove)\nusing this:\n  x < T + 2\n  x \\<noteq> gap i T\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "using tau_eq_state'"], ["proof (prove)\nusing this:\n  x < T + 2\n  x \\<noteq> gap i T\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "case False"], ["proof (state)\nthis:\n  x \\<noteq> gap i x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "moreover"], ["proof (state)\nthis:\n  x \\<noteq> gap i x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "have \"x < x + 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < x + 2", "by simp"], ["proof (state)\nthis:\n  x < x + 2\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x \\<Longrightarrow> \\<tau> i x \\<down>", "ultimately"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i x\n  x < x + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i x\n  x < x + 2\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "using tau_eq_state'"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i x\n  x < x + 2\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "by blast"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In Case~2, $\\tau_i$ is undefined only at the gap that never gets filled.\\<close>"], ["", "lemma case_two_tau_not_quite_total:\n  assumes \"\\<forall>T. gap i T \\<le> gap i t\"\n  shows \"\\<tau> i (gap i t) \\<up>\"\n    and \"x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i (gap i t) \\<up> &&&\n    (x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> i (gap i t) \\<up>\n 2. x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>", "let ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> i (gap i t) \\<up>\n 2. x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>", "have \"\\<not> determined i ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> determined i (gap i t)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "assume \"determined i ?k\""], ["proof (state)\nthis:\n  determined i (gap i t)\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  determined i (gap i t)", "obtain T where T: \"?k < e_length (block i T) \\<and> ?k \\<noteq> gap i T\""], ["proof (prove)\nusing this:\n  determined i (gap i t)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        gap i t < e_length (block i T) \\<and>\n        gap i t \\<noteq> gap i T \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  \\<forall>T. gap i T \\<le> gap i t\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T", "have snd_le: \"gap i T < ?k\""], ["proof (prove)\nusing this:\n  \\<forall>T. gap i T \\<le> gap i t\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T\n\ngoal (1 subgoal):\n 1. gap i T < gap i t", "by (simp add: dual_order.strict_iff_order)"], ["proof (state)\nthis:\n  gap i T < gap i t\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  gap i T < gap i t", "have \"T < t\""], ["proof (prove)\nusing this:\n  gap i T < gap i t\n\ngoal (1 subgoal):\n 1. T < t", "using gap_monotone"], ["proof (prove)\nusing this:\n  gap i T < gap i t\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. T < t", "by (metis leD le_less_linear)"], ["proof (state)\nthis:\n  T < t\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "from T length_block"], ["proof (chain)\npicking this:\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T\n  e_length (block ?i ?t) = Suc (Suc ?t)", "have \"?k < T + 2\""], ["proof (prove)\nusing this:\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. gap i t < T + 2", "by simp"], ["proof (state)\nthis:\n  gap i t < T + 2\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  gap i t < T + 2\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "have \"?k \\<noteq> T + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t \\<noteq> T + 1", "using T state_change_on_either(2) \\<open>T < t\\<close> state_unchanged"], ["proof (prove)\nusing this:\n  gap i t < e_length (block i T) \\<and> gap i t \\<noteq> gap i T\n  gap ?i (Suc ?t) \\<noteq> gap ?i ?t \\<Longrightarrow>\n  gap ?i (Suc ?t) = e_length (block ?i ?t)\n  T < t\n  \\<lbrakk>gap ?i ?t - 1 \\<le> ?y; ?y \\<le> ?t\\<rbrakk>\n  \\<Longrightarrow> gap ?i ?t = gap ?i ?y\n\ngoal (1 subgoal):\n 1. gap i t \\<noteq> T + 1", "by (metis Suc_eq_plus1 Suc_leI add_diff_cancel_right' le_add1 nat_neq_iff)"], ["proof (state)\nthis:\n  gap i t \\<noteq> T + 1\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  gap i t < T + 2\n  gap i t \\<noteq> T + 1", "have \"?k \\<le> T\""], ["proof (prove)\nusing this:\n  gap i t < T + 2\n  gap i t \\<noteq> T + 1\n\ngoal (1 subgoal):\n 1. gap i t \\<le> T", "by simp"], ["proof (state)\nthis:\n  gap i t \\<le> T\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  gap i t \\<le> T", "have \"gap i T = gap i ?k\""], ["proof (prove)\nusing this:\n  gap i t \\<le> T\n\ngoal (1 subgoal):\n 1. gap i T = gap i (gap i t)", "using state_unchanged[of i T \"?k\"] \\<open>?k < T + 2\\<close> snd_le"], ["proof (prove)\nusing this:\n  gap i t \\<le> T\n  \\<lbrakk>gap i T - 1 \\<le> gap i t; gap i t \\<le> T\\<rbrakk>\n  \\<Longrightarrow> gap i T = gap i (gap i t)\n  gap i t < T + 2\n  gap i T < gap i t\n\ngoal (1 subgoal):\n 1. gap i T = gap i (gap i t)", "by simp"], ["proof (state)\nthis:\n  gap i T = gap i (gap i t)\n\ngoal (1 subgoal):\n 1. determined i (gap i t) \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  gap i T = gap i (gap i t)", "show False"], ["proof (prove)\nusing this:\n  gap i T = gap i (gap i t)\n\ngoal (1 subgoal):\n 1. False", "by (metis diff_le_self state_unchanged leD nat_le_linear gap_monotone snd_le)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> determined i (gap i t)\n\ngoal (2 subgoals):\n 1. \\<tau> i (gap i t) \\<up>\n 2. x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>", "with tau_diverg"], ["proof (chain)\npicking this:\n  \\<not> determined ?i ?x \\<Longrightarrow> \\<tau> ?i ?x \\<up>\n  \\<not> determined i (gap i t)", "show \"\\<tau> i ?k \\<up>\""], ["proof (prove)\nusing this:\n  \\<not> determined ?i ?x \\<Longrightarrow> \\<tau> ?i ?x \\<up>\n  \\<not> determined i (gap i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i (gap i t) \\<up>", "by simp"], ["proof (state)\nthis:\n  \\<tau> i (gap i t) \\<up>\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>", "assume \"x \\<noteq> ?k\""], ["proof (state)\nthis:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow> \\<tau> i x \\<down>", "show \"\\<tau> i x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "proof (cases \"x < t + 2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>\n 2. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "case True"], ["proof (state)\nthis:\n  x < t + 2\n\ngoal (2 subgoals):\n 1. x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>\n 2. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "with \\<open>x \\<noteq> ?k\\<close> tau_eq_state'"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n  x < t + 2", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n  x < t + 2\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>\n\ngoal (1 subgoal):\n 1. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "case False"], ["proof (state)\nthis:\n  \\<not> x < t + 2\n\ngoal (1 subgoal):\n 1. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<not> x < t + 2", "have \"gap i x = ?k\""], ["proof (prove)\nusing this:\n  \\<not> x < t + 2\n\ngoal (1 subgoal):\n 1. gap i x = gap i t", "using assms"], ["proof (prove)\nusing this:\n  \\<not> x < t + 2\n  \\<forall>T. gap i T \\<le> gap i t\n\ngoal (1 subgoal):\n 1. gap i x = gap i t", "by (simp add: dual_order.antisym gap_monotone)"], ["proof (state)\nthis:\n  gap i x = gap i t\n\ngoal (1 subgoal):\n 1. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "with \\<open>x \\<noteq> ?k\\<close>"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t\n  gap i x = gap i t", "have \"x \\<noteq> gap i x\""], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  gap i x = gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i x", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> gap i x\n\ngoal (1 subgoal):\n 1. \\<not> x < t + 2 \\<Longrightarrow> \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "using tau_eq_state'[of x x]"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i x\n  \\<lbrakk>x < x + 2; x \\<noteq> gap ?i x\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i x \\<down>= e_nth (block ?i x) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_two_tau_almost_total:\n  assumes \"\\<exists>t. \\<forall>T. gap i T \\<le> gap i t\" (is \"\\<exists>t. ?P t\")\n  shows \"\\<tau> i (gap i (Least ?P)) \\<up>\"\n    and \"x \\<noteq> gap i (Least ?P) \\<Longrightarrow> \\<tau> i x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up> &&&\n    (x \\<noteq>\n     gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n     \\<tau> i x \\<down>)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up>\n 2. x \\<noteq>\n    gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n    \\<tau> i x \\<down>", "from assms"], ["proof (chain)\npicking this:\n  case_two i", "have \"?P (Least ?P)\""], ["proof (prove)\nusing this:\n  case_two i\n\ngoal (1 subgoal):\n 1. \\<forall>T.\n       gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "using LeastI_ex[of ?P]"], ["proof (prove)\nusing this:\n  case_two i\n  case_two i \\<Longrightarrow>\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<forall>T.\n       gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "by simp"], ["proof (state)\nthis:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (2 subgoals):\n 1. \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up>\n 2. x \\<noteq>\n    gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n    \\<tau> i x \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "show \"\\<tau> i (gap i (Least ?P)) \\<up>\" and \"x \\<noteq> gap i (Least ?P) \\<Longrightarrow> \\<tau> i x \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up> &&&\n    (x \\<noteq>\n     gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n     \\<tau> i x \\<down>)", "using case_two_tau_not_quite_total"], ["proof (prove)\nusing this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<forall>T. gap ?i T \\<le> gap ?i ?t \\<Longrightarrow>\n  \\<tau> ?i (gap ?i ?t) \\<up>\n  \\<lbrakk>\\<forall>T. gap ?i T \\<le> gap ?i ?t;\n   ?x \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?x \\<down>\n\ngoal (1 subgoal):\n 1. \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up> &&&\n    (x \\<noteq>\n     gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n     \\<tau> i x \\<down>)", "by simp_all"], ["proof (state)\nthis:\n  \\<tau> i (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) \\<up>\n  x \\<noteq>\n  gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n  \\<tau> i x \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Some more properties of $\\tau$.\\<close>"], ["", "lemma init_tau_gap: \"(\\<tau> i) \\<triangleright> (gap i t - 1) = e_take (gap i t) (block i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i \\<triangleright> (gap i t - 1) = e_take (gap i t) (block i t)", "proof (intro initI')"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)\n 2. \\<And>x.\n       x < Suc (gap i t - 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "show 1: \"e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "have \"gap i t > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < gap i t", "using gap_gr0"], ["proof (prove)\nusing this:\n  0 < gap ?i ?t\n\ngoal (1 subgoal):\n 1. 0 < gap i t", "by simp"], ["proof (state)\nthis:\n  0 < gap i t\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "moreover"], ["proof (state)\nthis:\n  0 < gap i t\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "have \"gap i t < e_length (block i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "using gap_in_block"], ["proof (prove)\nusing this:\n  gap ?i ?t < e_length (block ?i ?t)\n\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "by simp"], ["proof (state)\nthis:\n  gap i t < e_length (block i t)\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "ultimately"], ["proof (chain)\npicking this:\n  0 < gap i t\n  gap i t < e_length (block i t)", "have \"e_length (e_take (gap i t) (block i t)) = gap i t\""], ["proof (prove)\nusing this:\n  0 < gap i t\n  gap i t < e_length (block i t)\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = gap i t", "by simp"], ["proof (state)\nthis:\n  e_length (e_take (gap i t) (block i t)) = gap i t\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "then"], ["proof (chain)\npicking this:\n  e_length (e_take (gap i t) (block i t)) = gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  e_length (e_take (gap i t) (block i t)) = gap i t\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "using gap_gr0"], ["proof (prove)\nusing this:\n  e_length (e_take (gap i t) (block i t)) = gap i t\n  0 < gap ?i ?t\n\ngoal (1 subgoal):\n 1. e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)", "by simp"], ["proof (state)\nthis:\n  e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < Suc (gap i t - 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "show \"\\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x\" if \"x < Suc (gap i t - 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "have x_le: \"x < gap i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < gap i t", "using that gap_gr0"], ["proof (prove)\nusing this:\n  x < Suc (gap i t - 1)\n  0 < gap ?i ?t\n\ngoal (1 subgoal):\n 1. x < gap i t", "by simp"], ["proof (state)\nthis:\n  x < gap i t\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "then"], ["proof (chain)\npicking this:\n  x < gap i t", "have \"x < e_length (block i t)\""], ["proof (prove)\nusing this:\n  x < gap i t\n\ngoal (1 subgoal):\n 1. x < e_length (block i t)", "using gap_in_block less_trans"], ["proof (prove)\nusing this:\n  x < gap i t\n  gap ?i ?t < e_length (block ?i ?t)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. x < e_length (block i t)", "by blast"], ["proof (state)\nthis:\n  x < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "then"], ["proof (chain)\npicking this:\n  x < e_length (block i t)", "have *: \"\\<tau> i x \\<down>= e_nth (block i t) x\""], ["proof (prove)\nusing this:\n  x < e_length (block i t)\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "using x_le tau_eq_state"], ["proof (prove)\nusing this:\n  x < e_length (block i t)\n  x < gap i t\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "by auto"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i t) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "have \"x < e_length (e_take (gap i t) (block i t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < e_length (e_take (gap i t) (block i t))", "using x_le 1"], ["proof (prove)\nusing this:\n  x < gap i t\n  e_length (e_take (gap i t) (block i t)) = Suc (gap i t - 1)\n\ngoal (1 subgoal):\n 1. x < e_length (e_take (gap i t) (block i t))", "by simp"], ["proof (state)\nthis:\n  x < e_length (e_take (gap i t) (block i t))\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "then"], ["proof (chain)\npicking this:\n  x < e_length (e_take (gap i t) (block i t))", "have \"e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x\""], ["proof (prove)\nusing this:\n  x < e_length (e_take (gap i t) (block i t))\n\ngoal (1 subgoal):\n 1. e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x", "using x_le"], ["proof (prove)\nusing this:\n  x < e_length (e_take (gap i t) (block i t))\n  x < gap i t\n\ngoal (1 subgoal):\n 1. e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x", "by simp"], ["proof (state)\nthis:\n  e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "then"], ["proof (chain)\npicking this:\n  e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "using *"], ["proof (prove)\nusing this:\n  e_nth (block i t) x = e_nth (e_take (gap i t) (block i t)) x\n  \\<tau> i x \\<down>= e_nth (block i t) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (e_take (gap i t) (block i t)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < Suc (gap i t - 1) \\<Longrightarrow>\n  \\<tau> i ?x \\<down>= e_nth (e_take (gap i t) (block i t)) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_on_0_init_tau:\n  assumes \"change_on_0 (block i t) (gap i t)\"\n  shows \"(\\<tau> i) \\<triangleright> (t + 1) = block i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i \\<triangleright> (t + 1) = block i t", "proof (intro initI')"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (block i t) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (block i t) x", "let ?b = \"block i t\" and ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (block i t) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (block i t) x", "show \"e_length (block i t) = Suc (t + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (block i t) = Suc (t + 1)", "using length_block"], ["proof (prove)\nusing this:\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_length (block i t) = Suc (t + 1)", "by simp"], ["proof (state)\nthis:\n  e_length (block i t) = Suc (t + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (block i t) x", "show \"(\\<tau> i) x \\<down>= e_nth (block i t) x\" if \"x < Suc (t + 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "proof (cases \"x = ?k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> \\<tau> i x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "case True"], ["proof (state)\nthis:\n  x = gap i t\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> \\<tau> i x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "have \"gap i (Suc t) = e_length ?b\" and b: \"block i (Suc t) = e_snoc ?b 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t) &&&\n    block i (Suc t) = e_snoc (block i t) 0", "using gap_Suc(1) block_Suc(1) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_0 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc ?b 0\n  change_on_0 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t) &&&\n    block i (Suc t) = e_snoc (block i t) 0", "by simp_all"], ["proof (state)\nthis:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> \\<tau> i x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0", "have \"x < e_length (block i (Suc t))\" \"x \\<noteq> gap i (Suc t)\""], ["proof (prove)\nusing this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (1 subgoal):\n 1. x < e_length (block i (Suc t)) &&& x \\<noteq> gap i (Suc t)", "using that length_block"], ["proof (prove)\nusing this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (block i t) 0\n  x < Suc (t + 1)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. x < e_length (block i (Suc t)) &&& x \\<noteq> gap i (Suc t)", "by simp_all"], ["proof (state)\nthis:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> \\<tau> i x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)", "have \"\\<tau> i x \\<down>= e_nth (block i (Suc t)) x\""], ["proof (prove)\nusing this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "using tau_eq_state"], ["proof (prove)\nusing this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> \\<tau> i x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "using that assms b"], ["proof (prove)\nusing this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n  x < Suc (t + 1)\n  change_on_0 (block i t) (gap i t)\n  block i (Suc t) = e_snoc (block i t) 0\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i t) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "using that assms tau_eq_state'"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  x < Suc (t + 1)\n  change_on_0 (block i t) (gap i t)\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i t) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i t) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < Suc (t + 1) \\<Longrightarrow>\n  \\<tau> i ?x \\<down>= e_nth (block i t) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_on_0_hyp_change:\n  assumes \"change_on_0 (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "using assms hd_block init_tau_gap change_on_0_init_tau"], ["proof (prove)\nusing this:\n  change_on_0 (block i t) (gap i t)\n  e_hd (block ?i ?t) = ?i\n  \\<tau> ?i \\<triangleright> (gap ?i ?t - 1) =\n  e_take (gap ?i ?t) (block ?i ?t)\n  change_on_0 (block ?i ?t) (gap ?i ?t) \\<Longrightarrow>\n  \\<tau> ?i \\<triangleright> (?t + 1) = block ?i ?t\n\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "by simp"], ["", "lemma change_on_1_init_tau:\n  assumes \"change_on_1 (block i t) (gap i t)\"\n  shows \"(\\<tau> i) \\<triangleright>  (t + 1) = e_update (block i t) (gap i t) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i \\<triangleright> (t + 1) = e_update (block i t) (gap i t) 1", "proof (intro initI')"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "let ?b = \"block i t\" and ?k = \"gap i t\""], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "show \"e_length (e_update ?b ?k 1) = Suc (t + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)", "using length_block"], ["proof (prove)\nusing this:\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)", "by simp"], ["proof (state)\nthis:\n  e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "show \"(\\<tau> i) x \\<down>= e_nth (e_update ?b ?k 1) x\" if \"x < Suc (t + 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "proof (cases \"x = ?k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "case True"], ["proof (state)\nthis:\n  x = gap i t\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "have \"gap i (Suc t) = e_length ?b\" and b: \"block i (Suc t) = e_snoc (e_update ?b ?k 1) 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t) &&&\n    block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0", "using gap_Suc(2) block_Suc(2) assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> gap ?i (Suc ?t) = e_length ?b\n  \\<lbrakk>?b = block ?i ?t; ?k = gap ?i ?t; change_on_1 ?b ?k\\<rbrakk>\n  \\<Longrightarrow> block ?i (Suc ?t) = e_snoc (e_update ?b ?k 1) 0\n  change_on_1 (block i t) (gap i t)\n\ngoal (1 subgoal):\n 1. gap i (Suc t) = e_length (block i t) &&&\n    block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0", "by simp_all"], ["proof (state)\nthis:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "then"], ["proof (chain)\npicking this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0", "have \"x < e_length (block i (Suc t))\" \"x \\<noteq> gap i (Suc t)\""], ["proof (prove)\nusing this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n\ngoal (1 subgoal):\n 1. x < e_length (block i (Suc t)) &&& x \\<noteq> gap i (Suc t)", "using that length_block"], ["proof (prove)\nusing this:\n  gap i (Suc t) = e_length (block i t)\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n  x < Suc (t + 1)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. x < e_length (block i (Suc t)) &&& x \\<noteq> gap i (Suc t)", "by simp_all"], ["proof (state)\nthis:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "then"], ["proof (chain)\npicking this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)", "have \"\\<tau> i x \\<down>= e_nth (block i (Suc t)) x\""], ["proof (prove)\nusing this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "using tau_eq_state"], ["proof (prove)\nusing this:\n  x < e_length (block i (Suc t))\n  x \\<noteq> gap i (Suc t)\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "then"], ["proof (chain)\npicking this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "using that assms b nth_append"], ["proof (prove)\nusing this:\n  \\<tau> i x \\<down>= e_nth (block i (Suc t)) x\n  x < Suc (t + 1)\n  change_on_1 (block i t) (gap i t)\n  block i (Suc t) = e_snoc (e_update (block i t) (gap i t) 1) 0\n  (?xs @ ?ys) ! ?n =\n  (if ?n < length ?xs then ?xs ! ?n else ?ys ! (?n - length ?xs))\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "using that assms tau_eq_state'"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  x < Suc (t + 1)\n  change_on_1 (block i t) (gap i t)\n  \\<lbrakk>?j < ?t + 2; ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n\ngoal (1 subgoal):\n 1. \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "by simp"], ["proof (state)\nthis:\n  \\<tau> i x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < Suc (t + 1) \\<Longrightarrow>\n  \\<tau> i ?x \\<down>= e_nth (e_update (block i t) (gap i t) 1) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_on_1_hyp_change:\n  assumes \"change_on_1 (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "using assms hd_block init_tau_gap change_on_1_init_tau"], ["proof (prove)\nusing this:\n  change_on_1 (block i t) (gap i t)\n  e_hd (block ?i ?t) = ?i\n  \\<tau> ?i \\<triangleright> (gap ?i ?t - 1) =\n  e_take (gap ?i ?t) (block ?i ?t)\n  change_on_1 (block ?i ?t) (gap ?i ?t) \\<Longrightarrow>\n  \\<tau> ?i \\<triangleright> (?t + 1) = e_update (block ?i ?t) (gap ?i ?t) 1\n\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "by simp"], ["", "lemma change_on_either_hyp_change:\n  assumes \"\\<not> change_on_neither (block i t) (gap i t)\"\n  shows \"\\<sigma> i ((\\<tau> i) \\<triangleright> (t + 1)) \\<noteq> \\<sigma> i ((\\<tau> i) \\<triangleright> (gap i t - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "using assms change_on_0_hyp_change change_on_1_hyp_change"], ["proof (prove)\nusing this:\n  \\<not> change_on_neither (block i t) (gap i t)\n  change_on_0 (block ?i ?t) (gap ?i ?t) \\<Longrightarrow>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (?t + 1)) \\<noteq>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (gap ?i ?t - 1))\n  change_on_1 (block ?i ?t) (gap ?i ?t) \\<Longrightarrow>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (?t + 1)) \\<noteq>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (gap ?i ?t - 1))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (t + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i t - 1))", "by auto"], ["", "lemma filled_gap_0_init_tau:\n  assumes \"f\\<^sub>0 = (\\<tau> i)((gap i t):=Some 0)\"\n  shows \"f\\<^sub>0 \\<triangleright> (t + 1) = block i t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>0 \\<triangleright> (t + 1) = block i t", "proof (intro initI')"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (block i t) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       f\\<^sub>0 x \\<down>= e_nth (block i t) x", "show len: \"e_length (block i t) = Suc (t + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (block i t) = Suc (t + 1)", "using assms length_block"], ["proof (prove)\nusing this:\n  f\\<^sub>0 = \\<tau> i(gap i t \\<mapsto> 0)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_length (block i t) = Suc (t + 1)", "by auto"], ["proof (state)\nthis:\n  e_length (block i t) = Suc (t + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       f\\<^sub>0 x \\<down>= e_nth (block i t) x", "show \"f\\<^sub>0 x \\<down>= e_nth (block i t) x\" if \"x < Suc (t + 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>0 x \\<down>= e_nth (block i t) x", "proof (cases \"x = gap i t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> f\\<^sub>0 x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>0 x \\<down>= e_nth (block i t) x", "case True"], ["proof (state)\nthis:\n  x = gap i t\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow> f\\<^sub>0 x \\<down>= e_nth (block i t) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>0 x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  x = gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  x = gap i t\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 x \\<down>= e_nth (block i t) x", "using assms last_block"], ["proof (prove)\nusing this:\n  x = gap i t\n  f\\<^sub>0 = \\<tau> i(gap i t \\<mapsto> 0)\n  e_nth (block ?i ?t) (gap ?i ?t) = 0\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 x \\<down>= e_nth (block i t) x", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>0 x \\<down>= e_nth (block i t) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>0 x \\<down>= e_nth (block i t) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>0 x \\<down>= e_nth (block i t) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>0 x \\<down>= e_nth (block i t) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 x \\<down>= e_nth (block i t) x", "using assms len tau_eq_state that"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  f\\<^sub>0 = \\<tau> i(gap i t \\<mapsto> 0)\n  e_length (block i t) = Suc (t + 1)\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n  x < Suc (t + 1)\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 x \\<down>= e_nth (block i t) x", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>0 x \\<down>= e_nth (block i t) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < Suc (t + 1) \\<Longrightarrow>\n  f\\<^sub>0 ?x \\<down>= e_nth (block i t) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma filled_gap_1_init_tau:\n  assumes \"f\\<^sub>1 = (\\<tau> i)((gap i t):=Some 1)\"\n  shows \"f\\<^sub>1 \\<triangleright> (t + 1) = e_update (block i t) (gap i t) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>1 \\<triangleright> (t + 1) = e_update (block i t) (gap i t) 1", "proof (intro initI')"], ["proof (state)\ngoal (2 subgoals):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n 2. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "show len: \"e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)", "using e_length_update length_block"], ["proof (prove)\nusing this:\n  e_length (e_update ?b ?k ?v) = e_length ?b\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)", "by simp"], ["proof (state)\nthis:\n  e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < Suc (t + 1) \\<Longrightarrow>\n       f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "show \"f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\" if \"x < Suc (t + 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "proof (cases \"x = gap i t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "case True"], ["proof (state)\nthis:\n  x = gap i t\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "moreover"], ["proof (state)\nthis:\n  x = gap i t\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "have \"gap i t < e_length (block i t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "using gap_in_block"], ["proof (prove)\nusing this:\n  gap ?i ?t < e_length (block ?i ?t)\n\ngoal (1 subgoal):\n 1. gap i t < e_length (block i t)", "by simp"], ["proof (state)\nthis:\n  gap i t < e_length (block i t)\n\ngoal (2 subgoals):\n 1. x = gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n 2. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "ultimately"], ["proof (chain)\npicking this:\n  x = gap i t\n  gap i t < e_length (block i t)", "show ?thesis"], ["proof (prove)\nusing this:\n  x = gap i t\n  gap i t < e_length (block i t)\n\ngoal (1 subgoal):\n 1. f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "using assms"], ["proof (prove)\nusing this:\n  x = gap i t\n  gap i t < e_length (block i t)\n  f\\<^sub>1 = \\<tau> i(gap i t \\<mapsto> 1)\n\ngoal (1 subgoal):\n 1. f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "by simp"], ["proof (state)\nthis:\n  f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "case False"], ["proof (state)\nthis:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. x \\<noteq> gap i t \\<Longrightarrow>\n    f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> gap i t", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n\ngoal (1 subgoal):\n 1. f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "using assms len tau_eq_state that"], ["proof (prove)\nusing this:\n  x \\<noteq> gap i t\n  f\\<^sub>1 = \\<tau> i(gap i t \\<mapsto> 1)\n  e_length (e_update (block i t) (gap i t) 1) = Suc (t + 1)\n  \\<lbrakk>?j < e_length (block ?i ?t); ?j \\<noteq> gap ?i ?t\\<rbrakk>\n  \\<Longrightarrow> \\<tau> ?i ?j \\<down>= e_nth (block ?i ?t) ?j\n  x < Suc (t + 1)\n\ngoal (1 subgoal):\n 1. f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>1 x \\<down>= e_nth (e_update (block i t) (gap i t) 1) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x < Suc (t + 1) \\<Longrightarrow>\n  f\\<^sub>1 ?x \\<down>= e_nth (e_update (block i t) (gap i t) 1) ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The separating class\\<close>"], ["", "text \\<open>Next we define the sets $V_i$ from the introductory proof sketch\n(page~\\pageref{s:lim_bc}).\\<close>"], ["", "definition V_bclim :: \"nat \\<Rightarrow> partial1 set\" where\n  \"V_bclim i \\<equiv>\n    if case_two i\n    then let k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n         in {(\\<tau> i)(k:=Some 0), (\\<tau> i)(k:=Some 1)}\n    else {\\<tau> i}\""], ["", "lemma V_subseteq_R1: \"V_bclim i \\<subseteq> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i \\<subseteq> \\<R>", "proof (cases \"case_two i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "case True"], ["proof (state)\nthis:\n  case_two i\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "define k where \"k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\""], ["proof (state)\nthis:\n  k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "have \"\\<tau> i \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i \\<in> \\<P>", "using tau_in_P2 P2_proj_P1"], ["proof (prove)\nusing this:\n  \\<tau> \\<in> \\<P>\\<^sup>2\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<Longrightarrow> ?\\<psi> ?i \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<tau> i \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  \\<tau> i \\<in> \\<P>\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<tau> i \\<in> \\<P>", "have \"(\\<tau> i)(k:=Some 0) \\<in> \\<P>\" and \"(\\<tau> i)(k:=Some 1) \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  \\<tau> i \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<tau> i(k \\<mapsto> 0) \\<in> \\<P> &&&\n    \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>", "using P1_update_P1"], ["proof (prove)\nusing this:\n  \\<tau> i \\<in> \\<P>\n  ?f \\<in> \\<P> \\<Longrightarrow> ?f(?x := ?z) \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<tau> i(k \\<mapsto> 0) \\<in> \\<P> &&&\n    \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>", "by simp_all"], ["proof (state)\nthis:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<P>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "moreover"], ["proof (state)\nthis:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<P>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "have \"total1 ((\\<tau> i)(k:=Some v))\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. total1 (\\<tau> i(k \\<mapsto> v))", "using case_two_tau_almost_total(2)[OF True] k_def total1_def"], ["proof (prove)\nusing this:\n  ?x \\<noteq>\n  gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<Longrightarrow>\n  \\<tau> i ?x \\<down>\n  k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. total1 (\\<tau> i(k \\<mapsto> v))", "by simp"], ["proof (state)\nthis:\n  total1 (\\<tau> i(k \\<mapsto> ?v))\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<P>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>\n  total1 (\\<tau> i(k \\<mapsto> ?v))", "have \"(\\<tau> i)(k:=Some 0) \\<in> \\<R>\" and \"(\\<tau> i)(k:=Some 1) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<P>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>\n  total1 (\\<tau> i(k \\<mapsto> ?v))\n\ngoal (1 subgoal):\n 1. \\<tau> i(k \\<mapsto> 0) \\<in> \\<R> &&&\n    \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>", "using P1_total_imp_R1"], ["proof (prove)\nusing this:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<P>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<P>\n  total1 (\\<tau> i(k \\<mapsto> ?v))\n  \\<lbrakk>?f \\<in> \\<P>; total1 ?f\\<rbrakk> \\<Longrightarrow> ?f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<tau> i(k \\<mapsto> 0) \\<in> \\<R> &&&\n    \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>", "by simp_all"], ["proof (state)\nthis:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<R>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "moreover"], ["proof (state)\nthis:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<R>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "have \"V_bclim i = {(\\<tau> i)(k:=Some 0), (\\<tau> i)(k:=Some 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}", "using True V_bclim_def k_def"], ["proof (prove)\nusing this:\n  case_two i\n  V_bclim ?i \\<equiv>\n  if case_two ?i\n  then let k = gap ?i (LEAST t. \\<forall>T. gap ?i T \\<le> gap ?i t)\n       in {\\<tau> ?i(k \\<mapsto> 0), \\<tau> ?i(k \\<mapsto> 1)}\n  else {\\<tau> ?i}\n  k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>\n 2. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<R>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> i(k \\<mapsto> 0) \\<in> \\<R>\n  \\<tau> i(k \\<mapsto> 1) \\<in> \\<R>\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n\ngoal (1 subgoal):\n 1. V_bclim i \\<subseteq> \\<R>", "by simp"], ["proof (state)\nthis:\n  V_bclim i \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "case False"], ["proof (state)\nthis:\n  case_one i\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "have \"V_bclim i = {\\<tau> i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i}", "unfolding V_bclim_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if case_two i\n     then let k = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n          in {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n     else {\\<tau> i}) =\n    {\\<tau> i}", "by (simp add: False)"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i}\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "moreover"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i}\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "have \"\\<tau> i \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> i \\<in> \\<R>", "using total1I case_one_tau_total[OF False] tau_in_P2 P2_proj_P1[of \\<tau>] P1_total_imp_R1"], ["proof (prove)\nusing this:\n  (\\<And>x. ?f x \\<down>) \\<Longrightarrow> total1 ?f\n  \\<tau> i ?x \\<down>\n  \\<tau> \\<in> \\<P>\\<^sup>2\n  \\<tau> \\<in> \\<P>\\<^sup>2 \\<Longrightarrow> \\<tau> ?i \\<in> \\<P>\n  \\<lbrakk>?f \\<in> \\<P>; total1 ?f\\<rbrakk> \\<Longrightarrow> ?f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<tau> i \\<in> \\<R>", "by simp"], ["proof (state)\nthis:\n  \\<tau> i \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow> V_bclim i \\<subseteq> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  V_bclim i = {\\<tau> i}\n  \\<tau> i \\<in> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  V_bclim i = {\\<tau> i}\n  \\<tau> i \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. V_bclim i \\<subseteq> \\<R>", "by simp"], ["proof (state)\nthis:\n  V_bclim i \\<subseteq> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_one_imp_gap_unbounded:\n  assumes \"case_one i\"\n  shows \"\\<exists>t. gap i t - 1 > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. n < gap i t - 1", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>t. 0 < gap i t - 1\n 2. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>t. 0 < gap i t - 1\n 2. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. 0 < gap i t - 1", "using assms gap_gr0[of i] state_at_0(2)[of i]"], ["proof (prove)\nusing this:\n  case_one i\n  0 < gap i ?t\n  gap i 0 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>t. 0 < gap i t - 1", "by (metis diff_is_0_eq gr_zeroI)"], ["proof (state)\nthis:\n  \\<exists>t. 0 < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "case (Suc n)"], ["proof (state)\nthis:\n  \\<exists>t. n < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. n < gap i t - 1", "obtain t where t: \"gap i t - 1 > n\""], ["proof (prove)\nusing this:\n  \\<exists>t. n < gap i t - 1\n\ngoal (1 subgoal):\n 1. (\\<And>t. n < gap i t - 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "moreover"], ["proof (state)\nthis:\n  n < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "from assms"], ["proof (chain)\npicking this:\n  case_one i", "have \"\\<forall>t. \\<exists>T. gap i T > gap i t\""], ["proof (prove)\nusing this:\n  case_one i\n\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>T. gap i t < gap i T", "using leI"], ["proof (prove)\nusing this:\n  case_one i\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<forall>t. \\<exists>T. gap i t < gap i T", "by blast"], ["proof (state)\nthis:\n  \\<forall>t. \\<exists>T. gap i t < gap i T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "ultimately"], ["proof (chain)\npicking this:\n  n < gap i t - 1\n  \\<forall>t. \\<exists>T. gap i t < gap i T", "obtain T where \"gap i T > gap i t\""], ["proof (prove)\nusing this:\n  n < gap i t - 1\n  \\<forall>t. \\<exists>T. gap i t < gap i T\n\ngoal (1 subgoal):\n 1. (\\<And>T. gap i t < gap i T \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  gap i t < gap i T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "then"], ["proof (chain)\npicking this:\n  gap i t < gap i T", "have \"gap i T - 1 > gap i t - 1\""], ["proof (prove)\nusing this:\n  gap i t < gap i T\n\ngoal (1 subgoal):\n 1. gap i t - 1 < gap i T - 1", "using gap_gr0[of i]"], ["proof (prove)\nusing this:\n  gap i t < gap i T\n  0 < gap i ?t\n\ngoal (1 subgoal):\n 1. gap i t - 1 < gap i T - 1", "by (simp add: Suc_le_eq diff_less_mono)"], ["proof (state)\nthis:\n  gap i t - 1 < gap i T - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "with t"], ["proof (chain)\npicking this:\n  n < gap i t - 1\n  gap i t - 1 < gap i T - 1", "have \"gap i T - 1 > Suc n\""], ["proof (prove)\nusing this:\n  n < gap i t - 1\n  gap i t - 1 < gap i T - 1\n\ngoal (1 subgoal):\n 1. Suc n < gap i T - 1", "by simp"], ["proof (state)\nthis:\n  Suc n < gap i T - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>t. n < gap i t - 1 \\<Longrightarrow>\n       \\<exists>t. Suc n < gap i t - 1", "then"], ["proof (chain)\npicking this:\n  Suc n < gap i T - 1", "show ?case"], ["proof (prove)\nusing this:\n  Suc n < gap i T - 1\n\ngoal (1 subgoal):\n 1. \\<exists>t. Suc n < gap i t - 1", "by auto"], ["proof (state)\nthis:\n  \\<exists>t. Suc n < gap i t - 1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_one_imp_not_learn_lim_V:\n  assumes \"case_one i\"\n  shows \"\\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "have V_bclim: \"V_bclim i = {\\<tau> i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i}", "using assms V_bclim_def"], ["proof (prove)\nusing this:\n  case_one i\n  V_bclim ?i \\<equiv>\n  if case_two ?i\n  then let k = gap ?i (LEAST t. \\<forall>T. gap ?i T \\<le> gap ?i t)\n       in {\\<tau> ?i(k \\<mapsto> 0), \\<tau> ?i(k \\<mapsto> 1)}\n  else {\\<tau> ?i}\n\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i}", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i}\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "have \"\\<exists>m\\<^sub>1>n. \\<exists>m\\<^sub>2>n. (\\<sigma> i) ((\\<tau> i) \\<triangleright> m\\<^sub>1) \\<noteq> (\\<sigma> i) ((\\<tau> i) \\<triangleright> m\\<^sub>2)\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "obtain t where t: \"gap i t - 1 > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. n < gap i t - 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using case_one_imp_gap_unbounded[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>t. ?n < gap i t - 1\n\ngoal (1 subgoal):\n 1. (\\<And>t. n < gap i t - 1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  n < gap i t - 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "have \"\\<forall>t. \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t.\n       \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)", "using assms case_two_iff_forever_neither"], ["proof (prove)\nusing this:\n  case_one i\n  case_two ?i =\n  (\\<exists>t. \\<forall>T\\<ge>t. change_on_neither (block ?i T) (gap ?i T))\n\ngoal (1 subgoal):\n 1. \\<forall>t.\n       \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)", "by blast"], ["proof (state)\nthis:\n  \\<forall>t.\n     \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  n < gap i t - 1\n  \\<forall>t.\n     \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)", "obtain T where T: \"T \\<ge> t\" \"\\<not> change_on_neither (block i T) (gap i T)\""], ["proof (prove)\nusing this:\n  n < gap i t - 1\n  \\<forall>t.\n     \\<exists>T\\<ge>t. \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. (\\<And>T.\n        \\<lbrakk>t \\<le> T;\n         \\<not> change_on_neither (block i T) (gap i T)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t \\<le> T\n  \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  t \\<le> T\n  \\<not> change_on_neither (block i T) (gap i T)", "have \"(\\<sigma> i) ((\\<tau> i) \\<triangleright> (T + 1)) \\<noteq> (\\<sigma> i) ((\\<tau> i) \\<triangleright> (gap i T - 1))\""], ["proof (prove)\nusing this:\n  t \\<le> T\n  \\<not> change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))", "using change_on_either_hyp_change"], ["proof (prove)\nusing this:\n  t \\<le> T\n  \\<not> change_on_neither (block i T) (gap i T)\n  \\<not> change_on_neither (block ?i ?t) (gap ?i ?t) \\<Longrightarrow>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (?t + 1)) \\<noteq>\n  \\<sigma> ?i (\\<tau> ?i \\<triangleright> (gap ?i ?t - 1))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n    \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))", "by simp"], ["proof (state)\nthis:\n  \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n  \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n  \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "have \"gap i T - 1 > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < gap i T - 1", "using t T(1) gap_monotone"], ["proof (prove)\nusing this:\n  n < gap i t - 1\n  t \\<le> T\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n\ngoal (1 subgoal):\n 1. n < gap i T - 1", "by (simp add: diff_le_mono less_le_trans)"], ["proof (state)\nthis:\n  n < gap i T - 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "moreover"], ["proof (state)\nthis:\n  n < gap i T - 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "have \"T + 1 > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < T + 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < T + 1", "have \"gap i T - 1 \\<le> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gap i T - 1 \\<le> T", "using gap_in_block length_block"], ["proof (prove)\nusing this:\n  gap ?i ?t < e_length (block ?i ?t)\n  e_length (block ?i ?t) = Suc (Suc ?t)\n\ngoal (1 subgoal):\n 1. gap i T - 1 \\<le> T", "by (simp add: le_diff_conv less_Suc_eq_le)"], ["proof (state)\nthis:\n  gap i T - 1 \\<le> T\n\ngoal (1 subgoal):\n 1. n < T + 1", "then"], ["proof (chain)\npicking this:\n  gap i T - 1 \\<le> T", "show ?thesis"], ["proof (prove)\nusing this:\n  gap i T - 1 \\<le> T\n\ngoal (1 subgoal):\n 1. n < T + 1", "using \\<open>gap i T - 1 > n\\<close>"], ["proof (prove)\nusing this:\n  gap i T - 1 \\<le> T\n  n < gap i T - 1\n\ngoal (1 subgoal):\n 1. n < T + 1", "by simp"], ["proof (state)\nthis:\n  n < T + 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < T + 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n  \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))\n  n < gap i T - 1\n  n < T + 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> i (\\<tau> i \\<triangleright> (T + 1)) \\<noteq>\n  \\<sigma> i (\\<tau> i \\<triangleright> (gap i T - 1))\n  n < gap i T - 1\n  n < T + 1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n          \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<^sub>1>n.\n     \\<exists>m\\<^sub>2>n.\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<^sub>1>?n.\n     \\<exists>m\\<^sub>2>?n.\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "with infinite_hyp_changes_not_Lim V_bclim"], ["proof (chain)\npicking this:\n  \\<lbrakk>?f \\<in> ?U;\n   \\<forall>n.\n      \\<exists>m\\<^sub>1>n.\n         \\<exists>m\\<^sub>2>n.\n            ?s (?f \\<triangleright> m\\<^sub>1) \\<noteq>\n            ?s (?f \\<triangleright> m\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<not> learn_lim ?\\<psi> ?U ?s\n  V_bclim i = {\\<tau> i}\n  \\<exists>m\\<^sub>1>?n.\n     \\<exists>m\\<^sub>2>?n.\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> ?U;\n   \\<forall>n.\n      \\<exists>m\\<^sub>1>n.\n         \\<exists>m\\<^sub>2>n.\n            ?s (?f \\<triangleright> m\\<^sub>1) \\<noteq>\n            ?s (?f \\<triangleright> m\\<^sub>2)\\<rbrakk>\n  \\<Longrightarrow> \\<not> learn_lim ?\\<psi> ?U ?s\n  V_bclim i = {\\<tau> i}\n  \\<exists>m\\<^sub>1>?n.\n     \\<exists>m\\<^sub>2>?n.\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>1) \\<noteq>\n        \\<sigma> i (\\<tau> i \\<triangleright> m\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "by simp"], ["proof (state)\nthis:\n  \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_two_imp_not_learn_lim_V:\n  assumes \"case_two i\"\n  shows \"\\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "let ?P = \"\\<lambda>t. \\<forall>T. (gap i T) \\<le> (gap i t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "let ?t = \"LEAST t. ?P t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "let ?k = \"gap i ?t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "let ?b = \"e_take ?k (block i ?t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "have t: \"\\<forall>T. gap i T \\<le> gap i ?t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>T.\n       gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "using assms LeastI_ex[of ?P]"], ["proof (prove)\nusing this:\n  case_two i\n  case_two i \\<Longrightarrow>\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<forall>T.\n       gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "by simp"], ["proof (state)\nthis:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "then"], ["proof (chain)\npicking this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "have neither: \"\\<forall>T\\<ge>?t. change_on_neither (block i T) (gap i T)\""], ["proof (prove)\nusing this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n       change_on_neither (block i T) (gap i T)", "using gap_le_Suc gap_monotone state_change_on_neither(1)"], ["proof (prove)\nusing this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  gap ?i ?t \\<le> gap ?i (Suc ?t)\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n  gap ?i (Suc ?t) = gap ?i ?t \\<Longrightarrow>\n  change_on_neither (block ?i ?t) (gap ?i ?t)\n\ngoal (1 subgoal):\n 1. \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n       change_on_neither (block i T) (gap i T)", "by (metis (no_types, lifting) antisym)"], ["proof (state)\nthis:\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "have gap_T: \"\\<forall>T\\<ge>?t. gap i T = ?k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n       gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "using t gap_monotone antisym_conv"], ["proof (prove)\nusing this:\n  \\<forall>T.\n     gap i T \\<le> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  ?t\\<^sub>1 \\<le> ?t\\<^sub>2 \\<Longrightarrow>\n  gap ?i ?t\\<^sub>1 \\<le> gap ?i ?t\\<^sub>2\n  ?y \\<le> ?x \\<Longrightarrow> (?x \\<le> ?y) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n       gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)", "by blast"], ["proof (state)\nthis:\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "define f\\<^sub>0 where \"f\\<^sub>0 = (\\<tau> i)(?k:=Some 0)\""], ["proof (state)\nthis:\n  f\\<^sub>0 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 0)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "define f\\<^sub>1 where \"f\\<^sub>1 = (\\<tau> i)(?k:=Some 1)\""], ["proof (state)\nthis:\n  f\\<^sub>1 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 1)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "proof (rule same_hyp_for_two_not_Lim)"], ["proof (state)\ngoal (5 subgoals):\n 1. ?f\\<^sub>1 \\<in> V_bclim i\n 2. ?f\\<^sub>2 \\<in> V_bclim i\n 3. ?f\\<^sub>1 \\<noteq> ?f\\<^sub>2\n 4. \\<forall>n\\<ge>?n\\<^sub>1.\n       \\<sigma> i (?f\\<^sub>1 \\<triangleright> n) = ?h\n 5. \\<forall>n\\<ge>?n\\<^sub>2.\n       \\<sigma> i (?f\\<^sub>2 \\<triangleright> n) = ?h", "show \"f\\<^sub>0 \\<in> V_bclim i\" and \"f\\<^sub>1 \\<in> V_bclim i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>0 \\<in> V_bclim i &&& f\\<^sub>1 \\<in> V_bclim i", "using assms V_bclim_def f\\<^sub>0_def f\\<^sub>1_def"], ["proof (prove)\nusing this:\n  case_two i\n  V_bclim ?i \\<equiv>\n  if case_two ?i\n  then let k = gap ?i (LEAST t. \\<forall>T. gap ?i T \\<le> gap ?i t)\n       in {\\<tau> ?i(k \\<mapsto> 0), \\<tau> ?i(k \\<mapsto> 1)}\n  else {\\<tau> ?i}\n  f\\<^sub>0 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 0)\n  f\\<^sub>1 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 1)\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 \\<in> V_bclim i &&& f\\<^sub>1 \\<in> V_bclim i", "by (simp_all add: Let_def)"], ["proof (state)\nthis:\n  f\\<^sub>0 \\<in> V_bclim i\n  f\\<^sub>1 \\<in> V_bclim i\n\ngoal (3 subgoals):\n 1. f\\<^sub>0 \\<noteq> f\\<^sub>1\n 2. \\<forall>n\\<ge>?n\\<^sub>1.\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) = ?h\n 3. \\<forall>n\\<ge>?n\\<^sub>2.\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) = ?h", "show \"f\\<^sub>0 \\<noteq> f\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sub>0 \\<noteq> f\\<^sub>1", "using f\\<^sub>0_def f\\<^sub>1_def"], ["proof (prove)\nusing this:\n  f\\<^sub>0 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 0)\n  f\\<^sub>1 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 1)\n\ngoal (1 subgoal):\n 1. f\\<^sub>0 \\<noteq> f\\<^sub>1", "by (meson map_upd_eqD1 zero_neq_one)"], ["proof (state)\nthis:\n  f\\<^sub>0 \\<noteq> f\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<forall>n\\<ge>?n\\<^sub>1.\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) = ?h\n 2. \\<forall>n\\<ge>?n\\<^sub>2.\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) = ?h", "show \"\\<forall>n\\<ge>Suc ?t. \\<sigma> i (f\\<^sub>0 \\<triangleright> n) = \\<sigma> i ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (block i T) = \\<sigma> i (e_take ?k (block i T))\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i (block i T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i T))", "using that gap_T neither hd_block"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     change_on_neither (block i T) (gap i T)\n  e_hd (block ?i ?t) = ?i\n\ngoal (1 subgoal):\n 1. \\<sigma> i (block i T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i T))", "by metis"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))", "have \"\\<sigma> i (block i T) = \\<sigma> i ?b\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (block i T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting) init_tau_gap gap_T that)"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (f\\<^sub>0 \\<triangleright> (T + 1)) = \\<sigma> i ?b\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>0 \\<triangleright> (T + 1)) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "using filled_gap_0_init_tau[of f\\<^sub>0 i T] f\\<^sub>0_def gap_T that"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (block i ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n  f\\<^sub>0 = \\<tau> i(gap i T \\<mapsto> 0) \\<Longrightarrow>\n  f\\<^sub>0 \\<triangleright> (T + 1) = block i T\n  f\\<^sub>0 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 0)\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>0 \\<triangleright> (T + 1)) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (f\\<^sub>0 \\<triangleright> T) = \\<sigma> i ?b\" if \"T \\<ge> Suc ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>0 \\<triangleright> T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "using that"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>0 \\<triangleright> T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting) Suc_eq_plus1 Suc_le_D Suc_le_mono)"], ["proof (state)\nthis:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>0 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by simp"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n     \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n     \\<sigma> i\n      (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n        (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n     \\<sigma> i (f\\<^sub>0 \\<triangleright> n) =\n     \\<sigma> i\n      (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n        (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>?n\\<^sub>2.\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "show \"\\<forall>n\\<ge>Suc ?t. \\<sigma> i (f\\<^sub>1 \\<triangleright> n) = \\<sigma> i ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (e_update (block i T) ?k 1) = \\<sigma> i (e_take ?k (block i T))\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> i\n     (e_update (block i T)\n       (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i T))", "using neither"], ["proof (prove)\nusing this:\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     change_on_neither (block i T) (gap i T)\n\ngoal (1 subgoal):\n 1. \\<sigma> i\n     (e_update (block i T)\n       (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i T))", "by (metis (no_types, lifting) hd_block gap_T that)"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))", "have \"\\<sigma> i (e_update (block i T) ?k 1) = \\<sigma> i ?b\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))\n\ngoal (1 subgoal):\n 1. \\<sigma> i\n     (e_update (block i T)\n       (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "using that init_tau_gap[of i] gap_T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i ?T))\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n  \\<tau> i \\<triangleright> (gap i ?t - 1) = e_take (gap i ?t) (block i ?t)\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. \\<sigma> i\n     (e_update (block i T)\n       (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (f\\<^sub>1 \\<triangleright> (T + 1)) = \\<sigma> i ?b\" if \"T \\<ge> ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>1 \\<triangleright> (T + 1)) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "using filled_gap_1_init_tau[of f\\<^sub>1 i T] f\\<^sub>1_def gap_T that"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i\n   (e_update (block i ?T)\n     (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)) 1) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n  f\\<^sub>1 = \\<tau> i(gap i T \\<mapsto> 1) \\<Longrightarrow>\n  f\\<^sub>1 \\<triangleright> (T + 1) = e_update (block i T) (gap i T) 1\n  f\\<^sub>1 = \\<tau> i(gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \n  \\<mapsto> 1)\n  \\<forall>T\\<ge>LEAST t. \\<forall>T. gap i T \\<le> gap i t.\n     gap i T = gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>1 \\<triangleright> (T + 1)) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "have \"\\<sigma> i (f\\<^sub>1 \\<triangleright> T) = \\<sigma> i ?b\" if \"T \\<ge> Suc ?t\" for T"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>1 \\<triangleright> T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "using that"], ["proof (prove)\nusing this:\n  (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> (?T + 1)) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t) \\<le> T\n\ngoal (1 subgoal):\n 1. \\<sigma> i (f\\<^sub>1 \\<triangleright> T) =\n    \\<sigma> i\n     (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n       (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by (metis (no_types, lifting) Suc_eq_plus1 Suc_le_D Suc_le_mono)"], ["proof (state)\nthis:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "then"], ["proof (chain)\npicking this:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n  \\<le> ?T \\<Longrightarrow>\n  \\<sigma> i (f\\<^sub>1 \\<triangleright> ?T) =\n  \\<sigma> i\n   (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n     (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n       \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n       \\<sigma> i\n        (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n          (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))", "by simp"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n     \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n     \\<sigma> i\n      (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n        (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>Suc (LEAST t. \\<forall>T. gap i T \\<le> gap i t).\n     \\<sigma> i (f\\<^sub>1 \\<triangleright> n) =\n     \\<sigma> i\n      (e_take (gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t))\n        (block i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary not_learn_lim_V: \"\\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "using case_one_imp_not_learn_lim_V case_two_imp_not_learn_lim_V"], ["proof (prove)\nusing this:\n  case_one ?i \\<Longrightarrow>\n  \\<not> learn_lim \\<phi> (V_bclim ?i) (\\<sigma> ?i)\n  case_two ?i \\<Longrightarrow>\n  \\<not> learn_lim \\<phi> (V_bclim ?i) (\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "by (cases \"case_two i\") simp_all"], ["", "text \\<open>Next we define the separating class.\\<close>"], ["", "definition V_BCLIM :: \"partial1 set\" (\"V\\<^bsub>BC-LIM\\<^esub>\") where\n  \"V\\<^bsub>BC-LIM\\<^esub> \\<equiv> \\<Union>i. V_bclim i\""], ["", "lemma V_BCLIM_R1: \"V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>", "using V_BCLIM_def V_subseteq_R1"], ["proof (prove)\nusing this:\n  V\\<^bsub>BC-LIM\\<^esub> \\<equiv> \\<Union> (range V_bclim)\n  V_bclim ?i \\<subseteq> \\<R>\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>", "by auto"], ["", "lemma V_BCLIM_not_in_Lim: \"V\\<^bsub>BC-LIM\\<^esub> \\<notin> LIM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<notin> LIM", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "assume \"V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM\""], ["proof (state)\nthis:\n  V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM", "obtain s where s: \"learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\""], ["proof (prove)\nusing this:\n  V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using learn_lim_wrt_goedel[OF goedel_numbering_phi] Lim_def"], ["proof (prove)\nusing this:\n  V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow>\n  \\<exists>t. learn_lim \\<phi> ?U t\n  LIM \\<equiv> {U. \\<exists>\\<psi> s. learn_lim \\<psi> U s}\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "obtain i where \"\\<phi> i = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. \\<phi> i = s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using s learn_limE(1) phi_universal"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>?f \\<in> \\<P>;\n   \\<And>i. \\<phi> i = ?f \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i. \\<phi> i = s \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<phi> i = s\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n  \\<phi> i = s", "have \"learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<lambda>x. eval r_sigma [i, x])\""], ["proof (prove)\nusing this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n  \\<phi> i = s\n\ngoal (1 subgoal):\n 1. learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)", "using learn_lim_sigma"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> s\n  \\<phi> i = s\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)", "by simp"], ["proof (state)\nthis:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "have \"V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>", "using V_BCLIM_def"], ["proof (prove)\nusing this:\n  V\\<^bsub>BC-LIM\\<^esub> \\<equiv> \\<Union> (range V_bclim)\n\ngoal (1 subgoal):\n 1. V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>", "by auto"], ["proof (state)\nthis:\n  V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)\n  V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>", "have \"learn_lim \\<phi> (V_bclim i) (\\<lambda>x. eval r_sigma [i, x])\""], ["proof (prove)\nusing this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)\n  V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>\n\ngoal (1 subgoal):\n 1. learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "using learn_lim_closed_subseteq"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> V\\<^bsub>BC-LIM\\<^esub> (\\<sigma> i)\n  V_bclim i \\<subseteq> V\\<^bsub>BC-LIM\\<^esub>\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?V \\<subseteq> ?U\\<rbrakk>\n  \\<Longrightarrow> learn_lim ?\\<psi> ?V ?s\n\ngoal (1 subgoal):\n 1. learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "by simp"], ["proof (state)\nthis:\n  learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. V\\<^bsub>BC-LIM\\<^esub> \\<in> LIM \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  learn_lim \\<phi> (V_bclim i) (\\<sigma> i)", "show False"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\n\ngoal (1 subgoal):\n 1. False", "using not_learn_lim_V"], ["proof (prove)\nusing this:\n  learn_lim \\<phi> (V_bclim i) (\\<sigma> i)\n  \\<not> learn_lim \\<phi> (V_bclim ?i) (\\<sigma> ?i)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The separating class is in BC\\<close>"], ["", "text \\<open>In order to show @{term \"V\\<^bsub>BC-LIM\\<^esub> \\<in> BC\"} we\ndefine a hypothesis space that for every function $\\tau_i$ and every list $b$\nof numbers contains a copy of $\\tau_i$ with the first $|b|$ values replaced\nby $b$.\\<close>"], ["", "definition psitau :: partial2 (\"\\<psi>\\<^sup>\\<tau>\") where\n  \"\\<psi>\\<^sup>\\<tau> b x \\<equiv> (if x < e_length b then Some (e_nth b x) else \\<tau> (e_hd b) x)\""], ["", "lemma psitau_in_P2: \"\\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "define r where \"r \\<equiv>\n    Cn 2\n     (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [Id 2 0], Id 2 1]))\n     [Cn 2 r_less [Id 2 1, Cn 2 r_length [Id 2 0]], Id 2 0, Id 2 1]\""], ["proof (state)\nthis:\n  r \\<equiv>\n  Cn 2 (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  r \\<equiv>\n  Cn 2 (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n    recf.Id 2 1]", "have \"recfn 2 r\""], ["proof (prove)\nusing this:\n  r \\<equiv>\n  Cn 2 (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. recfn 2 r", "using r_tau_recfn"], ["proof (prove)\nusing this:\n  r \\<equiv>\n  Cn 2 (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n    recf.Id 2 1]\n  recfn 2 r_tau\n\ngoal (1 subgoal):\n 1. recfn 2 r", "by simp"], ["proof (state)\nthis:\n  recfn 2 r\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  recfn 2 r\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "have \"eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x\" for b x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "let ?f = \"Cn 2 r_tau [Cn 2 r_hd [Id 2 0], Id 2 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "have \"recfn 2 r_nth\" \"recfn 2 ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_nth &&&\n    recfn 2 (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1])", "using r_tau_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_tau\n\ngoal (1 subgoal):\n 1. recfn 2 r_nth &&&\n    recfn 2 (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1])", "by simp_all"], ["proof (state)\nthis:\n  recfn 2 r_nth\n  recfn 2 (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "then"], ["proof (chain)\npicking this:\n  recfn 2 r_nth\n  recfn 2 (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1])", "have \"eval (r_lifz r_nth ?f) [c, b, x] =\n        (if c = 0 then eval r_nth [b, x] else eval ?f [b, x])\" for c"], ["proof (prove)\nusing this:\n  recfn 2 r_nth\n  recfn 2 (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n     [c, b, x] =\n    (if c = 0 then eval r_nth [b, x]\n     else eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x])", "by simp"], ["proof (state)\nthis:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then eval r_nth [b, x]\n   else eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x])\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "moreover"], ["proof (state)\nthis:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then eval r_nth [b, x]\n   else eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x])\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "have \"eval r_nth [b, x] \\<down>= e_nth b x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nth [b, x] \\<down>= e_nth b x", "by simp"], ["proof (state)\nthis:\n  eval r_nth [b, x] \\<down>= e_nth b x\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "moreover"], ["proof (state)\nthis:\n  eval r_nth [b, x] \\<down>= e_nth b x\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "have \"eval ?f [b, x] = \\<tau> (e_hd b) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x] =\n    \\<tau> (e_hd b) x", "using r_tau_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_tau\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x] =\n    \\<tau> (e_hd b) x", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x] =\n  \\<tau> (e_hd b) x\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then eval r_nth [b, x]\n   else eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x])\n  eval r_nth [b, x] \\<down>= e_nth b x\n  eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x] =\n  \\<tau> (e_hd b) x", "have \"eval (r_lifz r_nth ?f) [c, b, x] =\n        (if c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\" for c"], ["proof (prove)\nusing this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then eval r_nth [b, x]\n   else eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x])\n  eval r_nth [b, x] \\<down>= e_nth b x\n  eval (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]) [b, x] =\n  \\<tau> (e_hd b) x\n\ngoal (1 subgoal):\n 1. eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n     [c, b, x] =\n    (if c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)", "by simp"], ["proof (state)\nthis:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "moreover"], ["proof (state)\nthis:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "have \"eval (Cn 2 r_less [Id 2 1, Cn 2 r_length [Id 2 0]]) [b, x] \\<down>=\n        (if x < e_length b then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n     [b, x] \\<down>=\n    (if x < e_length b then 0 else 1)", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n   [b, x] \\<down>=\n  (if x < e_length b then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n  eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n   [b, x] \\<down>=\n  (if x < e_length b then 0 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n  eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n   [b, x] \\<down>=\n  (if x < e_length b then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x", "unfolding r_def psitau_def"], ["proof (prove)\nusing this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n  eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n   [b, x] \\<down>=\n  (if x < e_length b then 0 else 1)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2\n       (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n       [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n        recf.Id 2 1])\n     [b, x] =\n    (if x < e_length b then Some (e_nth b x) else \\<tau> (e_hd b) x)", "using r_tau_recfn"], ["proof (prove)\nusing this:\n  eval (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n   [?c, b, x] =\n  (if ?c = 0 then Some (e_nth b x) else \\<tau> (e_hd b) x)\n  eval (Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]])\n   [b, x] \\<down>=\n  (if x < e_length b then 0 else 1)\n  recfn 2 r_tau\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2\n       (r_lifz r_nth (Cn 2 r_tau [Cn 2 r_hd [recf.Id 2 0], recf.Id 2 1]))\n       [Cn 2 r_less [recf.Id 2 1, Cn 2 r_length [recf.Id 2 0]], recf.Id 2 0,\n        recf.Id 2 1])\n     [b, x] =\n    (if x < e_length b then Some (e_nth b x) else \\<tau> (e_hd b) x)", "by simp"], ["proof (state)\nthis:\n  eval r [b, x] = \\<psi>\\<^sup>\\<tau> b x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r [?b, ?x] = \\<psi>\\<^sup>\\<tau> ?b ?x\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  recfn 2 r\n  eval r [?b, ?x] = \\<psi>\\<^sup>\\<tau> ?b ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 2 r\n  eval r [?b, ?x] = \\<psi>\\<^sup>\\<tau> ?b ?x\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma psitau_init:\n  \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "let ?e = \"f \\<triangleright> n\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "have \"e_length ?e = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (f \\<triangleright> n) = Suc n", "by simp"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> n) = Suc n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "moreover"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> n) = Suc n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "have \"x < Suc n \\<Longrightarrow> e_nth ?e x = the (f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)", "by simp"], ["proof (state)\nthis:\n  x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "moreover"], ["proof (state)\nthis:\n  x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "have \"e_hd ?e = the (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd (f \\<triangleright> n) = the (f 0)", "using hd_init"], ["proof (prove)\nusing this:\n  e_hd (?f \\<triangleright> ?n) = the (?f 0)\n\ngoal (1 subgoal):\n 1. e_hd (f \\<triangleright> n) = the (f 0)", "by simp"], ["proof (state)\nthis:\n  e_hd (f \\<triangleright> n) = the (f 0)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "ultimately"], ["proof (chain)\npicking this:\n  e_length (f \\<triangleright> n) = Suc n\n  x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)\n  e_hd (f \\<triangleright> n) = the (f 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  e_length (f \\<triangleright> n) = Suc n\n  x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)\n  e_hd (f \\<triangleright> n) = the (f 0)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "using psitau_def"], ["proof (prove)\nusing this:\n  e_length (f \\<triangleright> n) = Suc n\n  x < Suc n \\<Longrightarrow> e_nth (f \\<triangleright> n) x = the (f x)\n  e_hd (f \\<triangleright> n) = the (f 0)\n  \\<psi>\\<^sup>\\<tau> ?b ?x \\<equiv>\n  if ?x < e_length ?b then Some (e_nth ?b ?x) else \\<tau> (e_hd ?b) ?x\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n    (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)", "by simp"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x =\n  (if x < Suc n then Some (the (f x)) else \\<tau> (the (f 0)) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The class @{term V_BCLIM} can be learned BC-style in the\nhypothesis space @{term psitau} by the identity function.\\<close>"], ["", "lemma learn_bc_V_BCLIM: \"learn_bc \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_bc \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some", "proof (rule learn_bcI)"], ["proof (state)\ngoal (2 subgoals):\n 1. environment \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\n 2. \\<And>f.\n       f \\<in> V\\<^bsub>BC-LIM\\<^esub> \\<Longrightarrow>\n       \\<exists>n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "show \"environment \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some", "using identity_in_R1 V_BCLIM_R1 psitau_in_P2"], ["proof (prove)\nusing this:\n  Some \\<in> \\<R>\n  V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>\n  \\<psi>\\<^sup>\\<tau> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some", "by auto"], ["proof (state)\nthis:\n  environment \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> V\\<^bsub>BC-LIM\\<^esub> \\<Longrightarrow>\n       \\<exists>n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "show \"\\<exists>n\\<^sub>0. \\<forall>n\\<ge>n\\<^sub>0. \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\" if \"f \\<in> V\\<^bsub>BC-LIM\\<^esub>\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "from that V_BCLIM_def"], ["proof (chain)\npicking this:\n  f \\<in> V\\<^bsub>BC-LIM\\<^esub>\n  V\\<^bsub>BC-LIM\\<^esub> \\<equiv> \\<Union> (range V_bclim)", "obtain i where i: \"f \\<in> V_bclim i\""], ["proof (prove)\nusing this:\n  f \\<in> V\\<^bsub>BC-LIM\\<^esub>\n  V\\<^bsub>BC-LIM\\<^esub> \\<equiv> \\<Union> (range V_bclim)\n\ngoal (1 subgoal):\n 1. (\\<And>i. f \\<in> V_bclim i \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> V_bclim i\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "proof (cases \"case_two i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "case True"], ["proof (state)\nthis:\n  case_two i\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "let ?P = \"\\<lambda>t. \\<forall>T. (gap i T) \\<le> (gap i t)\""], ["proof (state)\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "let ?lmin = \"LEAST t. ?P t\""], ["proof (state)\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "define k where \"k \\<equiv> gap i ?lmin\""], ["proof (state)\nthis:\n  k \\<equiv> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "have V_bclim: \"V_bclim i = {(\\<tau> i)(k:=Some 0), (\\<tau> i)(k:=Some 1)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}", "using True V_bclim_def k_def"], ["proof (prove)\nusing this:\n  case_two i\n  V_bclim ?i \\<equiv>\n  if case_two ?i\n  then let k = gap ?i (LEAST t. \\<forall>T. gap ?i T \\<le> gap ?i t)\n       in {\\<tau> ?i(k \\<mapsto> 0), \\<tau> ?i(k \\<mapsto> 1)}\n  else {\\<tau> ?i}\n  k \\<equiv> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}", "by (simp add: Let_def)"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "moreover"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "have \"0 < k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < k", "using gap_gr0[of i] k_def"], ["proof (prove)\nusing this:\n  0 < gap i ?t\n  k \\<equiv> gap i (LEAST t. \\<forall>T. gap i T \\<le> gap i t)\n\ngoal (1 subgoal):\n 1. 0 < k", "by simp"], ["proof (state)\nthis:\n  0 < k\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "ultimately"], ["proof (chain)\npicking this:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n  0 < k", "have \"f 0 \\<down>= i\""], ["proof (prove)\nusing this:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n  0 < k\n\ngoal (1 subgoal):\n 1. f 0 \\<down>= i", "using tau_at_0[of i] i"], ["proof (prove)\nusing this:\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n  0 < k\n  \\<tau> i 0 \\<down>= i\n  f \\<in> V_bclim i\n\ngoal (1 subgoal):\n 1. f 0 \\<down>= i", "by auto"], ["proof (state)\nthis:\n  f 0 \\<down>= i\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "have \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) = f\" if \"n \\<ge> k\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "show \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "proof (cases \"x \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "case True"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "using R1_imp_total1 V_subseteq_R1 i psitau_init"], ["proof (prove)\nusing this:\n  x \\<le> n\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  V_bclim ?i \\<subseteq> \\<R>\n  f \\<in> V_bclim i\n  \\<psi>\\<^sup>\\<tau> (?f \\<triangleright> ?n) ?x =\n  (if ?x < Suc ?n then Some (the (?f ?x)) else \\<tau> (the (?f 0)) ?x)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "by fastforce"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<not> x \\<le> n", "have \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x", "using psitau_init"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n  \\<psi>\\<^sup>\\<tau> (?f \\<triangleright> ?n) ?x =\n  (if ?x < Suc ?n then Some (the (?f ?x)) else \\<tau> (the (?f 0)) ?x)\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x", "by simp"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x", "have \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x\""], ["proof (prove)\nusing this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x", "using \\<open>f 0 \\<down>= i\\<close>"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> (the (f 0)) x\n  f 0 \\<down>= i\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x", "by simp"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "moreover"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "have \"f x = \\<tau> i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x = \\<tau> i x", "using False V_bclim i that"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n  V_bclim i = {\\<tau> i(k \\<mapsto> 0), \\<tau> i(k \\<mapsto> 1)}\n  f \\<in> V_bclim i\n  k \\<le> n\n\ngoal (1 subgoal):\n 1. f x = \\<tau> i x", "by auto"], ["proof (state)\nthis:\n  f x = \\<tau> i x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "ultimately"], ["proof (chain)\npicking this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x\n  f x = \\<tau> i x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = \\<tau> i x\n  f x = \\<tau> i x\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "by simp"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<le> ?n \\<Longrightarrow>\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f\n\ngoal (2 subgoals):\n 1. case_two i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n 2. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  k \\<le> ?n \\<Longrightarrow>\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> ?n \\<Longrightarrow>\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "case False"], ["proof (state)\nthis:\n  case_one i\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  case_one i", "have \"V_bclim i = {\\<tau> i}\""], ["proof (prove)\nusing this:\n  case_one i\n\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i}", "using V_bclim_def"], ["proof (prove)\nusing this:\n  case_one i\n  V_bclim ?i \\<equiv>\n  if case_two ?i\n  then let k = gap ?i (LEAST t. \\<forall>T. gap ?i T \\<le> gap ?i t)\n       in {\\<tau> ?i(k \\<mapsto> 0), \\<tau> ?i(k \\<mapsto> 1)}\n  else {\\<tau> ?i}\n\ngoal (1 subgoal):\n 1. V_bclim i = {\\<tau> i}", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  V_bclim i = {\\<tau> i}\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  V_bclim i = {\\<tau> i}", "have f: \"f = \\<tau> i\""], ["proof (prove)\nusing this:\n  V_bclim i = {\\<tau> i}\n\ngoal (1 subgoal):\n 1. f = \\<tau> i", "using i"], ["proof (prove)\nusing this:\n  V_bclim i = {\\<tau> i}\n  f \\<in> V_bclim i\n\ngoal (1 subgoal):\n 1. f = \\<tau> i", "by simp"], ["proof (state)\nthis:\n  f = \\<tau> i\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "have \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) = f\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) = f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "show \"\\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "proof (cases \"x \\<le> n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "case True"], ["proof (state)\nthis:\n  x \\<le> n\n\ngoal (2 subgoals):\n 1. x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n 2. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "then"], ["proof (chain)\npicking this:\n  x \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "using R1_imp_total1 V_BCLIM_R1 psitau_init that"], ["proof (prove)\nusing this:\n  x \\<le> n\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  V\\<^bsub>BC-LIM\\<^esub> \\<subseteq> \\<R>\n  \\<psi>\\<^sup>\\<tau> (?f \\<triangleright> ?n) ?x =\n  (if ?x < Suc ?n then Some (the (?f ?x)) else \\<tau> (the (?f 0)) ?x)\n  f \\<in> V\\<^bsub>BC-LIM\\<^esub>\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "by auto"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> n \\<Longrightarrow>\n    \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<not> x \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> n\n\ngoal (1 subgoal):\n 1. \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x", "by (simp add: f psitau_init tau_at_0)"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> n) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f\n\ngoal (1 subgoal):\n 1. case_one i \\<Longrightarrow>\n    \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi>\\<^sup>\\<tau> (f \\<triangleright> ?n) = f\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f", "by simp"], ["proof (state)\nthis:\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi>\\<^sup>\\<tau> (the (Some (f \\<triangleright> n))) = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> V\\<^bsub>BC-LIM\\<^esub> \\<Longrightarrow>\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi>\\<^sup>\\<tau> (the (Some (?f \\<triangleright> n))) = ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, the main result of this section:\\<close>"], ["", "theorem Lim_subset_BC: \"LIM \\<subset> BC\""], ["proof (prove)\ngoal (1 subgoal):\n 1. LIM \\<subset> BC", "using learn_bc_V_BCLIM BC_def Lim_subseteq_BC V_BCLIM_not_in_Lim"], ["proof (prove)\nusing this:\n  learn_bc \\<psi>\\<^sup>\\<tau> V\\<^bsub>BC-LIM\\<^esub> Some\n  BC \\<equiv> {U. \\<exists>\\<psi> s. learn_bc \\<psi> U s}\n  LIM \\<subseteq> BC\n  V\\<^bsub>BC-LIM\\<^esub> \\<notin> LIM\n\ngoal (1 subgoal):\n 1. LIM \\<subset> BC", "by auto"], ["", "end"]]}