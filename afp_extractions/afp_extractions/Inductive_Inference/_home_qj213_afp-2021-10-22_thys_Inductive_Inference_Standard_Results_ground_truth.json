{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/Standard_Results.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma r_univ_almost_kleene_nf:\n  \"r_univ \\<simeq>\n   (let u = Cn 3 r_dec [r_result];\n        t = Cn 3 r_not [r_result]\n    in Cn 2 u [Mn 2 t, Id 2 0, Id 2 1])\"", "lemma r_nf_t_prim: \"prim_recfn 3 r_nf_t\"", "lemma r_nf_u_prim: \"prim_recfn 1 r_nf_u\"", "lemma r_nf_t_0:\n  assumes \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\"\n    and \"pdec2 y = prod_encode (i, x)\"\n  shows \"eval r_nf_t [y, i, x] \\<down>= 0\"", "lemma r_nf_t_1:\n  assumes \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0 \\<or> pdec2 y \\<noteq> prod_encode (i, x)\"\n  shows \"eval r_nf_t [y, i, x] \\<down>= 1\"", "lemma r_normal_form_recfn: \"recfn 2 r_normal_form\"", "lemma r_univ_exteq_r_normal_form: \"r_univ \\<simeq> r_normal_form\"", "theorem normal_form:\n  assumes \"recfn n f\"\n  obtains i where \"\\<forall>x. e_length x = n \\<longrightarrow> eval r_normal_form [i, x] = eval f (list_decode x)\"", "lemma count_Mn_zero_iff_prim: \"count_Mn f = 0 \\<longleftrightarrow> Mn_free f\"", "lemma count_Mn_normal_form: \"count_Mn r_normal_form = 1\"", "lemma one_Mn_suffices:\n  assumes \"recfn n f\"\n  shows \"\\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f\"", "lemma code_const1: \"code_const1 c = encode (r_const c)\"", "lemma r_code_const1_aux_prim: \"prim_recfn 3 r_code_const1_aux\"", "lemma r_code_const1_aux:\n  \"eval r_code_const1_aux [i, r, c] \\<down>= quad_encode 3 1 1 (singleton_encode r)\"", "lemma r_code_const1_prim: \"prim_recfn 1 r_code_const1\"", "lemma r_code_const1: \"eval r_code_const1 [c] \\<down>= code_const1 c\"", "lemma code_constn: \"code_constn (Suc n) c = encode (r_constn n c)\"", "lemma r_code_constn_prim: \"prim_recfn 1 (r_code_constn n)\"", "lemma r_code_constn: \"eval (r_code_constn n) [c] \\<down>= code_constn n c\"", "lemma code_id: \"encode (Id m n) = code_id m n\"", "lemma smn:\n  assumes \"n > 0\"\n  shows \"smn n p cs = encode\n   (Cn n\n     (r_universal (n + length cs))\n     (r_constn (n - 1) p # map (r_constn (n - 1)) cs @ (map (Id n) [0..<n])))\"", "lemma r_smn_aux_prim: \"n > 0 \\<Longrightarrow> prim_recfn (Suc m) (r_smn_aux n m)\"", "lemma r_smn_aux:\n  assumes \"n > 0\" and \"length cs = m\"\n  shows \"eval (r_smn_aux n m) (p # cs) \\<down>=\n    list_encode (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\"", "lemma r_smn_prim [simp]: \"n > 0 \\<Longrightarrow> prim_recfn (Suc m) (r_smn n m)\"", "lemma r_smn:\n  assumes \"n > 0\" and \"length cs = m\"\n  shows \"eval (r_smn n m) (p # cs) \\<down>= smn n p cs\"", "lemma map_eval_Some_the:\n  assumes \"map (\\<lambda>g. eval g xs) gs = map Some ys\"\n  shows \"map (\\<lambda>g. the (eval g xs)) gs = ys\"", "lemma smn_lemma:\n  assumes \"n > 0\" and len_cs: \"length cs = m\" and len_xs: \"length xs = n\"\n  shows \"eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) ((the (eval (r_smn n m) (p # cs))) # xs)\"", "theorem smn_theorem:\n  assumes \"n > 0\"\n  shows \"\\<exists>s. prim_recfn (Suc m) s \\<and>\n    (\\<forall>p cs xs. length cs = m \\<and> length xs = n \\<longrightarrow>\n        eval (r_universal (m + n)) (p # cs @ xs) =\n        eval (r_universal n) ((the (eval s (p # cs))) # xs))\"", "lemma numbering_translation:\n  assumes \"recfn 2 psi\"\n  obtains c where\n    \"recfn 1 c\"\n    \"total c\"\n    \"\\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\"", "lemma s11_inj: \"inj (\\<lambda>x. smn 1 p [x])\"", "lemma r_univuniv_recfn: \"recfn 2 r_univuniv\"", "lemma r_univuniv_converg:\n  assumes \"eval r_phi [x, x] \\<down>\"\n  shows \"eval r_univuniv [x, y] = eval r_phi [the (eval r_phi [x, x]), y]\"", "theorem rogers_fixed_point_theorem:\n  fixes k :: nat\n  assumes \"recfn 1 f\" and \"total f\"\n  shows \"\\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]\"", "theorem kleene_fixed_point_theorem:\n  fixes k :: nat\n  assumes \"recfn 2 psi\"\n  shows \"\\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\"", "lemma r_univuniv2_recfn: \"recfn 3 r_univuniv2\"", "lemma r_univuniv2_converg:\n  assumes \"eval (r_universal 2) [u, u, x] \\<down>\"\n  shows \"eval r_univuniv2 [u, x, y] = eval r_phi [the (eval (r_universal 2) [u, u, x]), y]\"", "theorem kleene_fixed_point_theorem_2:\n  assumes \"recfn 2 f\" and \"total f\"\n  shows \"\\<exists>n.\n    recfn 1 n \\<and>\n    total n \\<and>\n    (\\<forall>x y. eval r_phi [(the (eval n [x])), y] = eval r_phi [(the (eval f [the (eval n [x]), x])), y])\"", "theorem smullyan_double_fixed_point_theorem:\n  assumes \"recfn 2 g\" and \"total g\" and \"recfn 2 h\" and \"total h\"\n  shows \"\\<exists>m n.\n    (\\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n    (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])\"", "theorem halting_problem_phi_undecidable: \"\\<not> decidable {x. eval r_phi [x, x] \\<down>}\"\n  (is \"\\<not> decidable ?K\")", "lemma decidable_complement: \"decidable X \\<Longrightarrow> decidable (- X)\"", "lemma r_contains_prim: \"prim_recfn 1 (r_contains xs)\"", "lemma r_contains: \"eval (r_contains xs) [x] \\<down>= (if x \\<in> set xs then 1 else 0)\"", "lemma finite_set_decidable: \"finite X \\<Longrightarrow> decidable X\"", "lemma semidecidable_iff_domain:\n  \"semidecidable X \\<longleftrightarrow> (\\<exists>f. recfn 1 f \\<and> (\\<forall>x. eval f [x] \\<down> \\<longleftrightarrow> x \\<in> X))\"", "lemma decidable_imp_semidecidable: \"decidable X \\<Longrightarrow> semidecidable X\"", "theorem recursively_enumerable_iff_semidecidable:\n  \"recursively_enumerable X \\<longleftrightarrow> semidecidable X\"", "lemma semidecidable_decidable:\n  assumes \"semidecidable X\" and \"semidecidable (- X)\"\n  shows \"decidable X\"", "theorem decidable_iff_semidecidable_complement:\n  \"decidable X \\<longleftrightarrow> semidecidable X \\<and> semidecidable (- X)\"", "lemma index_set_closed_in:\n  assumes \"index_set I\" and \"i \\<in> I\" and \"\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\"\n  shows \"j \\<in> I\"", "lemma index_set_closed_not_in:\n  assumes \"index_set I\" and \"i \\<notin> I\" and \"\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\"\n  shows \"j \\<notin> I\"", "theorem rice_theorem:\n  assumes \"index_set I\" and \"I \\<noteq> UNIV\" and \"I \\<noteq> {}\"\n  shows \"\\<not> decidable I\"", "lemma total1I [intro]: \"(\\<And>x. f x \\<down>) \\<Longrightarrow> total1 f\"", "lemma total2I [intro]: \"(\\<And>x y. f x y \\<down>) \\<Longrightarrow> total2 f\"", "lemma total1E [dest, simp]: \"total1 f \\<Longrightarrow> f x \\<down>\"", "lemma total2E [dest, simp]: \"total2 f \\<Longrightarrow> f x y \\<down>\"", "lemma R1_imp_P1 [simp, elim]: \"f \\<in> \\<R> \\<Longrightarrow> f \\<in> \\<P>\"", "lemma R2_imp_P2 [simp, elim]: \"f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> f \\<in> \\<P>\\<^sup>2\"", "lemma Prim1_imp_R1 [simp, elim]: \"f \\<in> Prim1 \\<Longrightarrow> f \\<in> \\<R>\"", "lemma Prim2_imp_R2 [simp, elim]: \"f \\<in> Prim2 \\<Longrightarrow> f \\<in> \\<R>\\<^sup>2\"", "lemma P1E [elim]:\n  assumes \"f \\<in> \\<P>\"\n  obtains r where \"recfn 1 r\" and \"\\<forall>x. eval r [x] = f x\"", "lemma P2E [elim]:\n  assumes \"f \\<in> \\<P>\\<^sup>2\"\n  obtains r where \"recfn 2 r\" and \"\\<forall>x y. eval r [x, y] = f x y\"", "lemma P1I [intro]:\n  assumes \"recfn 1 r\" and \"(\\<lambda>x. eval r [x]) = f\"\n  shows \"f \\<in> \\<P>\"", "lemma P2I [intro]:\n  assumes \"recfn 2 r\" and \"\\<And>x y. eval r [x, y] = f x y\"\n  shows \"f \\<in> \\<P>\\<^sup>2\"", "lemma R1I [intro]:\n  assumes \"recfn 1 r\" and \"total r\" and \"\\<And>x. eval r [x] = f x\"\n  shows \"f \\<in> \\<R>\"", "lemma R1E [elim]:\n  assumes \"f \\<in> \\<R>\"\n  obtains r where \"recfn 1 r\" and \"total r\" and \"f = (\\<lambda>x. eval r [x])\"", "lemma R2I [intro]:\n  assumes \"recfn 2 r\" and \"total r\" and \"\\<And>x y. eval r [x, y] = f x y\"\n  shows \"f \\<in> \\<R>\\<^sup>2\"", "lemma R1_SOME:\n  assumes \"f \\<in> \\<R>\"\n    and \"r = (SOME r'. recfn 1 r' \\<and>  total r' \\<and> f = (\\<lambda>x. eval r' [x]))\"\n      (is \"r = (SOME r'. ?P r')\")\n  shows \"recfn 1 r\"\n    and \"\\<And>x. eval r [x] \\<down>\"\n    and \"\\<And>x. f x = eval r [x]\"\n    and \"f = (\\<lambda>x. eval r [x])\"", "lemma R2E [elim]:\n  assumes \"f \\<in> \\<R>\\<^sup>2\"\n  obtains r where \"recfn 2 r\" and \"total r\" and \"f = (\\<lambda>x\\<^sub>1 x\\<^sub>2. eval r [x\\<^sub>1, x\\<^sub>2])\"", "lemma R1_imp_total1 [simp]: \"f \\<in> \\<R> \\<Longrightarrow> total1 f\"", "lemma R2_imp_total2 [simp]: \"f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> total2 f\"", "lemma Prim1I [intro]:\n  assumes \"prim_recfn 1 r\" and \"\\<And>x. f x = eval r [x]\"\n  shows \"f \\<in> Prim1\"", "lemma Prim2I [intro]:\n  assumes \"prim_recfn 2 r\" and \"\\<And>x y. f x y = eval r [x, y]\"\n  shows \"f \\<in> Prim2\"", "lemma P1_total_imp_R1 [intro]:\n  assumes \"f \\<in> \\<P>\" and \"total1 f\"\n  shows \"f \\<in> \\<R>\"", "lemma P2_total_imp_R2 [intro]:\n  assumes \"f \\<in> \\<P>\\<^sup>2 \" and \"total2 f\"\n  shows \"f \\<in> \\<R>\\<^sup>2\"", "lemma identity_in_R1: \"Some \\<in> \\<R>\"", "lemma P2_proj_P1 [simp, elim]:\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  shows \"\\<psi> i \\<in> \\<P>\"", "lemma R2_proj_R1 [simp, elim]:\n  assumes \"\\<psi> \\<in> \\<R>\\<^sup>2\"\n  shows \"\\<psi> i \\<in> \\<R>\"", "lemma const_in_Prim1: \"(\\<lambda>_. Some c) \\<in> Prim1\"", "lemma concat_P1_P1:\n  assumes \"f \\<in> \\<P>\" and \"g \\<in> \\<P>\"\n  shows \"(\\<lambda>x. if g x \\<down> \\<and> f (the (g x)) \\<down> then Some (the (f (the (g x)))) else None) \\<in> \\<P>\"\n    (is \"?h \\<in> \\<P>\")", "lemma P1_update_P1:\n  assumes \"f \\<in> \\<P>\"\n  shows \"f(x:=z) \\<in> \\<P>\"", "lemma swap_P2:\n  assumes \"f \\<in> \\<P>\\<^sup>2\"\n  shows \"(\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2\"", "lemma swap_R2:\n  assumes \"f \\<in> \\<R>\\<^sup>2\"\n  shows \"(\\<lambda>x y. f y x) \\<in> \\<R>\\<^sup>2\"", "lemma skip_P1:\n  assumes \"f \\<in> \\<P>\"\n  shows \"(\\<lambda>x. f (x + n)) \\<in> \\<P>\"", "lemma skip_R1:\n  assumes \"f \\<in> \\<R>\"\n  shows \"(\\<lambda>x. f (x + n)) \\<in> \\<R>\"", "lemma goedel_numbering_P2:\n  assumes \"goedel_numbering \\<psi>\"\n  shows \"\\<psi> \\<in> \\<P>\\<^sup>2\"", "lemma goedel_numberingE:\n  assumes \"goedel_numbering \\<psi>\" and \"\\<chi> \\<in> \\<P>\\<^sup>2\"\n  obtains c where \"c \\<in> \\<R>\" and \"\\<forall>i. \\<chi> i = \\<psi> (the (c i))\"", "lemma goedel_numbering_universal:\n  assumes \"goedel_numbering \\<psi>\" and \"f \\<in> \\<P>\"\n  shows \"\\<exists>i. \\<psi> i = f\"", "lemma phi_in_P2: \"\\<phi> \\<in> \\<P>\\<^sup>2\"", "lemma numbering_translation_for_phi:\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  shows \"\\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))\"", "theorem kleene_fixed_point:\n  fixes k :: nat\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  obtains i where \"i \\<ge> k\" and \"\\<phi> i = \\<psi> i\"", "theorem smullyan_double_fixed_point:\n  assumes \"g \\<in> \\<R>\\<^sup>2\" and \"h \\<in> \\<R>\\<^sup>2\"\n  obtains m n where \"\\<phi> m = \\<phi> (the (g m n))\" and \"\\<phi> n = \\<phi> (the (h m n))\""], "translations": [["", "lemma r_univ_almost_kleene_nf:\n  \"r_univ \\<simeq>\n   (let u = Cn 3 r_dec [r_result];\n        t = Cn 3 r_not [r_result]\n    in Cn 2 u [Mn 2 t, Id 2 0, Id 2 1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_univ \\<simeq>\n    (let u = Cn 3 r_dec [r_result]; t = Cn 3 r_not [r_result]\n     in Cn 2 u [Mn 2 t, recf.Id 2 0, recf.Id 2 1])", "unfolding r_univ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Cn 2 r_dec\n     [Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]] \\<simeq>\n    (let u = Cn 3 r_dec [r_result]; t = Cn 3 r_not [r_result]\n     in Cn 2 u [Mn 2 t, recf.Id 2 0, recf.Id 2 1])", "by (rule exteqI) simp_all"], ["", "text \\<open>We can remedy the wrong arity with some encoding and\nprojecting.\\<close>"], ["", "definition r_nf_t :: recf where\n  \"r_nf_t \\<equiv> Cn 3 r_and\n    [Cn 3 r_eq [Cn 3 r_pdec2 [Id 3 0], Cn 3 r_prod_encode [Id 3 1, Id 3 2]],\n     Cn 3 r_not\n      [Cn 3 r_result\n        [Cn 3 r_pdec1 [Id 3 0],\n         Cn 3 r_pdec12 [Id 3 0],\n         Cn 3 r_pdec22 [Id 3 0]]]]\""], ["", "lemma r_nf_t_prim: \"prim_recfn 3 r_nf_t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_nf_t", "unfolding r_nf_t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_and\n       [Cn 3 r_eq\n         [Cn 3 r_pdec2 [recf.Id 3 0],\n          Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n        Cn 3 r_not\n         [Cn 3 r_result\n           [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n            Cn 3 r_pdec22 [recf.Id 3 0]]]])", "by simp"], ["", "definition r_nf_u :: recf where\n  \"r_nf_u \\<equiv> Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]]\""], ["", "lemma r_nf_u_prim: \"prim_recfn 1 r_nf_u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_nf_u", "unfolding r_nf_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]])", "by simp"], ["", "lemma r_nf_t_0:\n  assumes \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\"\n    and \"pdec2 y = prod_encode (i, x)\"\n  shows \"eval r_nf_t [y, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 0", "unfolding r_nf_t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_eq\n         [Cn 3 r_pdec2 [recf.Id 3 0],\n          Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n        Cn 3 r_not\n         [Cn 3 r_result\n           [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n            Cn 3 r_pdec22 [recf.Id 3 0]]]])\n     [y, i, x] \\<down>=\n    0", "using assms"], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n  pdec2 y = prod_encode (i, x)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_eq\n         [Cn 3 r_pdec2 [recf.Id 3 0],\n          Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n        Cn 3 r_not\n         [Cn 3 r_result\n           [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n            Cn 3 r_pdec22 [recf.Id 3 0]]]])\n     [y, i, x] \\<down>=\n    0", "by auto"], ["", "lemma r_nf_t_1:\n  assumes \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0 \\<or> pdec2 y \\<noteq> prod_encode (i, x)\"\n  shows \"eval r_nf_t [y, i, x] \\<down>= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 1", "unfolding r_nf_t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_eq\n         [Cn 3 r_pdec2 [recf.Id 3 0],\n          Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n        Cn 3 r_not\n         [Cn 3 r_result\n           [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n            Cn 3 r_pdec22 [recf.Id 3 0]]]])\n     [y, i, x] \\<down>=\n    1", "using assms r_result_total"], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0 \\<or>\n  pdec2 y \\<noteq> prod_encode (i, x)\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_and\n       [Cn 3 r_eq\n         [Cn 3 r_pdec2 [recf.Id 3 0],\n          Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n        Cn 3 r_not\n         [Cn 3 r_result\n           [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n            Cn 3 r_pdec22 [recf.Id 3 0]]]])\n     [y, i, x] \\<down>=\n    1", "by auto"], ["", "text \\<open>The next function is just as universal as @{term r_univ}, but\nsatisfies the conditions of the Kleene normal form theorem because the\nouter funtion @{term r_nf_u} is unary.\\<close>"], ["", "definition \"r_normal_form \\<equiv> Cn 2 r_nf_u [Mn 2 r_nf_t]\""], ["", "lemma r_normal_form_recfn: \"recfn 2 r_normal_form\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_normal_form", "unfolding r_normal_form_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_nf_u [Mn 2 r_nf_t])", "using r_nf_u_prim r_nf_t_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_nf_u\n  prim_recfn 3 r_nf_t\n\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_nf_u [Mn 2 r_nf_t])", "by simp"], ["", "lemma r_univ_exteq_r_normal_form: \"r_univ \\<simeq> r_normal_form\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_univ \\<simeq> r_normal_form", "proof (rule exteqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. arity r_univ = arity r_normal_form\n 2. \\<And>xs.\n       length xs = arity r_univ \\<Longrightarrow>\n       eval r_univ xs = eval r_normal_form xs", "show arity: \"arity r_univ = arity r_normal_form\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity r_univ = arity r_normal_form", "using r_normal_form_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_normal_form\n\ngoal (1 subgoal):\n 1. arity r_univ = arity r_normal_form", "by simp"], ["proof (state)\nthis:\n  arity r_univ = arity r_normal_form\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       length xs = arity r_univ \\<Longrightarrow>\n       eval r_univ xs = eval r_normal_form xs", "show \"eval r_univ xs = eval r_normal_form xs\" if \"length xs = arity r_univ\" for xs"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "have \"length xs = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs = 2", "using that"], ["proof (prove)\nusing this:\n  length xs = arity r_univ\n\ngoal (1 subgoal):\n 1. length xs = 2", "by simp"], ["proof (state)\nthis:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "then"], ["proof (chain)\npicking this:\n  length xs = 2", "obtain i x where ix: \"[i, x] = xs\""], ["proof (prove)\nusing this:\n  length xs = 2\n\ngoal (1 subgoal):\n 1. (\\<And>i x. [i, x] = xs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (smt Suc_length_conv length_0_conv numeral_2_eq_2)"], ["proof (state)\nthis:\n  [i, x] = xs\n\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "have \"eval r_univ [i, x] = eval r_normal_form [i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval r_normal_form [i, x]", "proof (cases \"\\<forall>t. eval r_result [t, i, x] \\<down>= 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>t. eval r_result [t, i, x] \\<down>= 0 \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]\n 2. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "case True"], ["proof (state)\nthis:\n  \\<forall>t. eval r_result [t, i, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. \\<forall>t. eval r_result [t, i, x] \\<down>= 0 \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]\n 2. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  \\<forall>t. eval r_result [t, i, x] \\<down>= 0", "have \"eval r_univ [i, x] \\<up>\""], ["proof (prove)\nusing this:\n  \\<forall>t. eval r_result [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<up>", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  \\<forall>t. eval r_result [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<up>\n\ngoal (2 subgoals):\n 1. \\<forall>t. eval r_result [t, i, x] \\<down>= 0 \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]\n 2. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "moreover"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<up>\n\ngoal (2 subgoals):\n 1. \\<forall>t. eval r_result [t, i, x] \\<down>= 0 \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]\n 2. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"eval r_normal_form [i, x] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] \\<up>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] \\<up>", "have \"eval r_nf_t [y, i, x] \\<down>= 1\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 1", "using True r_nf_t_1[of y i x]"], ["proof (prove)\nusing this:\n  \\<forall>t. eval r_result [t, i, x] \\<down>= 0\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0 \\<or>\n  pdec2 y \\<noteq> prod_encode (i, x) \\<Longrightarrow>\n  eval r_nf_t [y, i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 1", "by fastforce"], ["proof (state)\nthis:\n  eval r_nf_t [?y, i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] \\<up>", "then"], ["proof (chain)\npicking this:\n  eval r_nf_t [?y, i, x] \\<down>= 1", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_nf_t [?y, i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] \\<up>", "unfolding r_normal_form_def"], ["proof (prove)\nusing this:\n  eval r_nf_t [?y, i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_nf_u [Mn 2 r_nf_t]) [i, x] \\<up>", "using r_nf_u_prim r_nf_t_prim"], ["proof (prove)\nusing this:\n  eval r_nf_t [?y, i, x] \\<down>= 1\n  prim_recfn 1 r_nf_u\n  prim_recfn 3 r_nf_t\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_nf_u [Mn 2 r_nf_t]) [i, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_normal_form [i, x] \\<up>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_normal_form [i, x] \\<up>\n\ngoal (2 subgoals):\n 1. \\<forall>t. eval r_result [t, i, x] \\<down>= 0 \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]\n 2. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "ultimately"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<up>\n  eval r_normal_form [i, x] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<up>\n  eval r_normal_form [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval r_normal_form [i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval r_normal_form [i, x]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t. eval r_result [t, i, x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>t. eval r_result [t, i, x] \\<down>= 0)", "have \"\\<exists>t. eval r_result [t, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>t. eval r_result [t, i, x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. \\<exists>t. eval r_result [t, i, x] \\<down>\\<noteq> 0", "by (simp add: r_result_total)"], ["proof (state)\nthis:\n  \\<exists>t. eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. eval r_result [t, i, x] \\<down>\\<noteq> 0", "obtain t where \"eval r_result [t, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>t. eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        eval r_result [t, i, x] \\<down>\\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0", "have \"eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0", "using r_nf_t_0"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n  \\<lbrakk>eval r_result [pdec1 ?y, pdec12 ?y, pdec22 ?y] \\<down>\\<noteq> 0;\n   pdec2 ?y = prod_encode (?i, ?x)\\<rbrakk>\n  \\<Longrightarrow> eval r_nf_t [?y, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0", "obtain y where y: \"eval (Mn 2 r_nf_t) [i, x] \\<down>= y\""], ["proof (prove)\nusing this:\n  eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eval (Mn 2 r_nf_t) [i, x] \\<down>= y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_nf_t_prim Mn_free_imp_total"], ["proof (prove)\nusing this:\n  eval r_nf_t [triple_encode t i x, i, x] \\<down>= 0\n  prim_recfn 3 r_nf_t\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eval (Mn 2 r_nf_t) [i, x] \\<down>= y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eval (Mn 2 r_nf_t) [i, x] \\<down>= y\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 r_nf_t) [i, x] \\<down>= y", "have \"eval r_nf_t [y, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval (Mn 2 r_nf_t) [i, x] \\<down>= y\n\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 0", "using r_nf_t_prim Mn_free_imp_total eval_Mn_convergE(2)[of 2 r_nf_t \"[i, x]\" y]"], ["proof (prove)\nusing this:\n  eval (Mn 2 r_nf_t) [i, x] \\<down>= y\n  prim_recfn 3 r_nf_t\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 r_nf_t);\n   eval (Mn 2 r_nf_t) [i, x] \\<down>= y\\<rbrakk>\n  \\<Longrightarrow> eval r_nf_t [y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_nf_t [y, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval r_nf_t [y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_nf_t [y, i, x] \\<down>= 0", "have r_result: \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\"\n        and pdec2: \"pdec2 y = prod_encode (i, x)\""], ["proof (prove)\nusing this:\n  eval r_nf_t [y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0 &&&\n    pdec2 y = prod_encode (i, x)", "using r_nf_t_0[of y i x] r_nf_t_1[of y i x] r_result_total"], ["proof (prove)\nusing this:\n  eval r_nf_t [y, i, x] \\<down>= 0\n  \\<lbrakk>eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0;\n   pdec2 y = prod_encode (i, x)\\<rbrakk>\n  \\<Longrightarrow> eval r_nf_t [y, i, x] \\<down>= 0\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0 \\<or>\n  pdec2 y \\<noteq> prod_encode (i, x) \\<Longrightarrow>\n  eval r_nf_t [y, i, x] \\<down>= 1\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0 &&&\n    pdec2 y = prod_encode (i, x)", "by auto"], ["proof (state)\nthis:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n  pdec2 y = prod_encode (i, x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n  pdec2 y = prod_encode (i, x)", "have \"eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n  pdec2 y = prod_encode (i, x)\n\ngoal (1 subgoal):\n 1. eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0", "obtain v where v:\n          \"eval r_univ [pdec12 y, pdec22 y] \\<down>= v\"\n          \"eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>eval r_univ [pdec12 y, pdec22 y] \\<down>= v;\n         eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result r_result_bivalent'[of \"pdec12 y\" \"pdec22 y\" _ \"pdec1 y\"]\n          r_result_diverg'[of \"pdec12 y\" \"pdec22 y\" \"pdec1 y\"]"], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, i, x] \\<down>\\<noteq> 0\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n  eval r_univ [pdec12 y, pdec22 y] \\<down>= ?v \\<Longrightarrow>\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc ?v \\<or>\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0\n  eval r_univ [pdec12 y, pdec22 y] \\<up> \\<Longrightarrow>\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>eval r_univ [pdec12 y, pdec22 y] \\<down>= v;\n         eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_univ [pdec12 y, pdec22 y] \\<down>= v\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"eval r_normal_form [i, x] = eval r_nf_u [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] = eval r_nf_u [y]", "unfolding r_normal_form_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_nf_u [Mn 2 r_nf_t]) [i, x] = eval r_nf_u [y]", "using y r_nf_t_prim r_nf_u_prim"], ["proof (prove)\nusing this:\n  eval (Mn 2 r_nf_t) [i, x] \\<down>= y\n  prim_recfn 3 r_nf_t\n  prim_recfn 1 r_nf_u\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_nf_u [Mn 2 r_nf_t]) [i, x] = eval r_nf_u [y]", "by simp"], ["proof (state)\nthis:\n  eval r_normal_form [i, x] = eval r_nf_u [y]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "also"], ["proof (state)\nthis:\n  eval r_normal_form [i, x] = eval r_nf_u [y]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"... = eval r_dec [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_nf_u [y] =\n    eval r_dec\n     [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]", "unfolding r_nf_u_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]]) [y] =\n    eval r_dec\n     [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]", "using r_result"], ["proof (prove)\nusing this:\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]]) [y] =\n    eval r_dec\n     [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]", "by simp"], ["proof (state)\nthis:\n  eval r_nf_u [y] =\n  eval r_dec [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "also"], ["proof (state)\nthis:\n  eval r_nf_u [y] =\n  eval r_dec [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"... = eval r_dec [Suc v]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dec\n     [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])] =\n    eval r_dec [Suc v]", "using v"], ["proof (prove)\nusing this:\n  eval r_univ [pdec12 y, pdec22 y] \\<down>= v\n  eval r_result [pdec1 y, pdec12 y, pdec22 y] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_dec\n     [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])] =\n    eval r_dec [Suc v]", "by simp"], ["proof (state)\nthis:\n  eval r_dec\n   [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])] =\n  eval r_dec [Suc v]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "also"], ["proof (state)\nthis:\n  eval r_dec\n   [the (eval (Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]) [y])] =\n  eval r_dec [Suc v]\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"... \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dec [Suc v] \\<down>= v", "by simp"], ["proof (state)\nthis:\n  eval r_dec [Suc v] \\<down>= v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "finally"], ["proof (chain)\npicking this:\n  eval r_normal_form [i, x] \\<down>= v", "have \"eval r_normal_form [i, x] \\<down>= v\""], ["proof (prove)\nusing this:\n  eval r_normal_form [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. eval r_normal_form [i, x] \\<down>= v", "."], ["proof (state)\nthis:\n  eval r_normal_form [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "moreover"], ["proof (state)\nthis:\n  eval r_normal_form [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "have \"eval r_univ [i, x] \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down>= v", "using v(1) pdec2"], ["proof (prove)\nusing this:\n  eval r_univ [pdec12 y, pdec22 y] \\<down>= v\n  pdec2 y = prod_encode (i, x)\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down>= v", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t.\n               eval r_result [t, i, x] \\<down>= 0) \\<Longrightarrow>\n    eval r_univ [i, x] = eval r_normal_form [i, x]", "ultimately"], ["proof (chain)\npicking this:\n  eval r_normal_form [i, x] \\<down>= v\n  eval r_univ [i, x] \\<down>= v", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_normal_form [i, x] \\<down>= v\n  eval r_univ [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval r_normal_form [i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval r_normal_form [i, x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval r_normal_form [i, x]\n\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "with ix"], ["proof (chain)\npicking this:\n  [i, x] = xs\n  eval r_univ [i, x] = eval r_normal_form [i, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  [i, x] = xs\n  eval r_univ [i, x] = eval r_normal_form [i, x]\n\ngoal (1 subgoal):\n 1. eval r_univ xs = eval r_normal_form xs", "by simp"], ["proof (state)\nthis:\n  eval r_univ xs = eval r_normal_form xs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ?xs = arity r_univ \\<Longrightarrow>\n  eval r_univ ?xs = eval r_normal_form ?xs\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem normal_form:\n  assumes \"recfn n f\"\n  obtains i where \"\\<forall>x. e_length x = n \\<longrightarrow> eval r_normal_form [i, x] = eval f (list_decode x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x.\n           e_length x = n \\<longrightarrow>\n           eval r_normal_form [i, x] =\n           eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x.\n           e_length x = n \\<longrightarrow>\n           eval r_normal_form [i, x] =\n           eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"eval r_normal_form [encode f, x] = eval f (list_decode x)\" if \"e_length x = n\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_normal_form [encode f, x] =\n    eval f (Partial_Recursive.list_decode x)", "using r_univ_exteq_r_normal_form assms that exteq_def r_univ'"], ["proof (prove)\nusing this:\n  r_univ \\<simeq> r_normal_form\n  recfn n f\n  e_length x = n\n  ?f \\<simeq> ?g \\<equiv>\n  arity ?f = arity ?g \\<and>\n  (\\<forall>xs.\n      length xs = arity ?f \\<longrightarrow> eval ?f xs = eval ?g xs)\n  recfn (e_length ?x) ?f \\<Longrightarrow>\n  eval r_univ [encode ?f, ?x] = eval ?f (Partial_Recursive.list_decode ?x)\n\ngoal (1 subgoal):\n 1. eval r_normal_form [encode f, x] =\n    eval f (Partial_Recursive.list_decode x)", "by auto"], ["proof (state)\nthis:\n  e_length ?x = n \\<Longrightarrow>\n  eval r_normal_form [encode f, ?x] =\n  eval f (Partial_Recursive.list_decode ?x)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x.\n           e_length x = n \\<longrightarrow>\n           eval r_normal_form [i, x] =\n           eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  e_length ?x = n \\<Longrightarrow>\n  eval r_normal_form [encode f, ?x] =\n  eval f (Partial_Recursive.list_decode ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  e_length ?x = n \\<Longrightarrow>\n  eval r_normal_form [encode f, ?x] =\n  eval f (Partial_Recursive.list_decode ?x)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  e_length ?x = n \\<Longrightarrow>\n  eval r_normal_form [encode f, ?x] =\n  eval f (Partial_Recursive.list_decode ?x)\n  \\<forall>x.\n     e_length x = n \\<longrightarrow>\n     eval r_normal_form [?i, x] =\n     eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As a consequence of the normal form theorem every partial\nrecursive function can be represented with exactly one application of the\n$\\mu$-operator.\\<close>"], ["", "fun count_Mn :: \"recf \\<Rightarrow> nat\" where\n  \"count_Mn Z = 0\"\n| \"count_Mn S = 0\"\n| \"count_Mn (Id m n) = 0\"\n| \"count_Mn (Cn n f gs) = count_Mn f + sum_list (map count_Mn gs)\"\n| \"count_Mn (Pr n f g) = count_Mn f + count_Mn g\"\n| \"count_Mn (Mn n f) = Suc (count_Mn f)\""], ["", "lemma count_Mn_zero_iff_prim: \"count_Mn f = 0 \\<longleftrightarrow> Mn_free f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (count_Mn f = 0) = Mn_free f", "by (induction f) auto"], ["", "text \\<open>The normal form has only one $\\mu$-recursion.\\<close>"], ["", "lemma count_Mn_normal_form: \"count_Mn r_normal_form = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_Mn r_normal_form = 1", "unfolding r_normal_form_def r_nf_u_def r_nf_t_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_Mn\n     (Cn 2 (Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]])\n       [Mn 2\n         (Cn 3 r_and\n           [Cn 3 r_eq\n             [Cn 3 r_pdec2 [recf.Id 3 0],\n              Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n            Cn 3 r_not\n             [Cn 3 r_result\n               [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n                Cn 3 r_pdec22 [recf.Id 3 0]]]])]) =\n    1", "using count_Mn_zero_iff_prim"], ["proof (prove)\nusing this:\n  (count_Mn ?f = 0) = Mn_free ?f\n\ngoal (1 subgoal):\n 1. count_Mn\n     (Cn 2 (Cn 1 r_dec [Cn 1 r_result [r_pdec1, r_pdec12, r_pdec22]])\n       [Mn 2\n         (Cn 3 r_and\n           [Cn 3 r_eq\n             [Cn 3 r_pdec2 [recf.Id 3 0],\n              Cn 3 r_prod_encode [recf.Id 3 1, recf.Id 3 2]],\n            Cn 3 r_not\n             [Cn 3 r_result\n               [Cn 3 r_pdec1 [recf.Id 3 0], Cn 3 r_pdec12 [recf.Id 3 0],\n                Cn 3 r_pdec22 [recf.Id 3 0]]]])]) =\n    1", "by simp"], ["", "lemma one_Mn_suffices:\n  assumes \"recfn n f\"\n  shows \"\\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "have \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using assms wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  recfn n f\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "obtain i where i:\n    \"\\<forall>x. e_length x = n \\<longrightarrow> eval r_normal_form [i, x] = eval f (list_decode x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x.\n           e_length x = n \\<longrightarrow>\n           eval r_normal_form [i, x] =\n           eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using normal_form[OF assms(1)]"], ["proof (prove)\nusing this:\n  (\\<And>i.\n      \\<forall>x.\n         e_length x = n \\<longrightarrow>\n         eval r_normal_form [i, x] =\n         eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>x.\n           e_length x = n \\<longrightarrow>\n           eval r_normal_form [i, x] =\n           eval f (Partial_Recursive.list_decode x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x.\n     e_length x = n \\<longrightarrow>\n     eval r_normal_form [i, x] = eval f (Partial_Recursive.list_decode x)\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "define g where \"g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]\""], ["proof (state)\nthis:\n  g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "then"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]", "have \"recfn n g\""], ["proof (prove)\nusing this:\n  g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]\n\ngoal (1 subgoal):\n 1. recfn n g", "using r_normal_form_recfn \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]\n  recfn 2 r_normal_form\n  0 < n\n\ngoal (1 subgoal):\n 1. recfn n g", "by simp"], ["proof (state)\nthis:\n  recfn n g\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "then"], ["proof (chain)\npicking this:\n  recfn n g", "have \"g \\<simeq> f\""], ["proof (prove)\nusing this:\n  recfn n g\n\ngoal (1 subgoal):\n 1. g \\<simeq> f", "using g_def r_list_encode i assms"], ["proof (prove)\nusing this:\n  recfn n g\n  g \\<equiv> Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_list_encode ?n) ?xs \\<down>= Partial_Recursive.list_encode ?xs\n  \\<forall>x.\n     e_length x = n \\<longrightarrow>\n     eval r_normal_form [i, x] = eval f (Partial_Recursive.list_decode x)\n  recfn n f\n\ngoal (1 subgoal):\n 1. g \\<simeq> f", "by (intro exteqI) simp_all"], ["proof (state)\nthis:\n  g \\<simeq> f\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "moreover"], ["proof (state)\nthis:\n  g \\<simeq> f\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "have \"count_Mn g = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. count_Mn g = 1", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. count_Mn\n     (Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]) =\n    1", "using count_Mn_normal_form count_Mn_zero_iff_prim"], ["proof (prove)\nusing this:\n  count_Mn r_normal_form = 1\n  (count_Mn ?f = 0) = Mn_free ?f\n\ngoal (1 subgoal):\n 1. count_Mn\n     (Cn n r_normal_form [r_constn (n - 1) i, r_list_encode (n - 1)]) =\n    1", "by simp"], ["proof (state)\nthis:\n  count_Mn g = 1\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "ultimately"], ["proof (chain)\npicking this:\n  g \\<simeq> f\n  count_Mn g = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<simeq> f\n  count_Mn g = 1\n\ngoal (1 subgoal):\n 1. \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f", "by auto"], ["proof (state)\nthis:\n  \\<exists>g. count_Mn g = 1 \\<and> g \\<simeq> f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The previous lemma could have been obtained without @{term\n\"r_normal_form\"} directly from @{term \"r_univ\"}.\\<close>"], ["", "section \\<open>The $s$-$m$-$n$ theorem\\<close>"], ["", "text \\<open>For all $m, n > 0$ there is an $(m + 1)$-ary primitive recursive\nfunction $s^m_n$ with\n\\[\n  \\varphi_p^{(m + n)}(c_1, \\dots,c_m, x_1, \\dots, x_n) =\n  \\varphi_{s^m_n(p, c_1, \\dots,c_m)}^{(n)}(x_1, \\dots, x_n)\n\\]\nfor all $p, c_1, \\ldots, c_m, x_1, \\ldots, x_n$. Here, $\\varphi^{(n)}$ is a\nfunction universal for $n$-ary partial recursive functions, which we will\nrepresent by @{term \"r_universal n\"}\\<close>"], ["", "text \\<open>The $s^m_n$ functions compute codes of functions. We start simple:\ncomputing codes of the unary constant functions.\\<close>"], ["", "fun code_const1 :: \"nat \\<Rightarrow> nat\" where\n  \"code_const1 0 = 0\"\n| \"code_const1 (Suc c) = quad_encode 3 1 1 (singleton_encode (code_const1 c))\""], ["", "lemma code_const1: \"code_const1 c = encode (r_const c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code_const1 c = encode (r_const c)", "by (induction c) simp_all"], ["", "definition \"r_code_const1_aux \\<equiv>\n  Cn 3 r_prod_encode\n    [r_constn 2 3,\n      Cn 3 r_prod_encode\n        [r_constn 2 1,\n          Cn 3 r_prod_encode\n            [r_constn 2 1, Cn 3 r_singleton_encode [Id 3 1]]]]\""], ["", "lemma r_code_const1_aux_prim: \"prim_recfn 3 r_code_const1_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_code_const1_aux", "by (simp_all add: r_code_const1_aux_def)"], ["", "lemma r_code_const1_aux:\n  \"eval r_code_const1_aux [i, r, c] \\<down>= quad_encode 3 1 1 (singleton_encode r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_code_const1_aux [i, r, c] \\<down>=\n    quad_encode 3 1 1 (singleton_encode r)", "by (simp add: r_code_const1_aux_def)"], ["", "definition \"r_code_const1 \\<equiv> r_shrink (Pr 1 Z r_code_const1_aux)\""], ["", "lemma r_code_const1_prim: \"prim_recfn 1 r_code_const1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_code_const1", "by (simp_all add: r_code_const1_def r_code_const1_aux_prim)"], ["", "lemma r_code_const1: \"eval r_code_const1 [c] \\<down>= code_const1 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_code_const1 [c] \\<down>= code_const1 c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_code_const1 [c] \\<down>= code_const1 c", "let ?h = \"Pr 1 Z r_code_const1_aux\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_code_const1 [c] \\<down>= code_const1 c", "have \"eval ?h [c, x] \\<down>= code_const1 c\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 1 Z r_code_const1_aux) [c, x] \\<down>= code_const1 c", "using r_code_const1_aux r_code_const1_def"], ["proof (prove)\nusing this:\n  eval r_code_const1_aux [?i, ?r, ?c] \\<down>=\n  quad_encode 3 1 1 (singleton_encode ?r)\n  r_code_const1 \\<equiv> r_shrink (Pr 1 Z r_code_const1_aux)\n\ngoal (1 subgoal):\n 1. eval (Pr 1 Z r_code_const1_aux) [c, x] \\<down>= code_const1 c", "by (induction c) (simp_all add: r_code_const1_aux_prim)"], ["proof (state)\nthis:\n  eval (Pr 1 Z r_code_const1_aux) [c, ?x] \\<down>= code_const1 c\n\ngoal (1 subgoal):\n 1. eval r_code_const1 [c] \\<down>= code_const1 c", "then"], ["proof (chain)\npicking this:\n  eval (Pr 1 Z r_code_const1_aux) [c, ?x] \\<down>= code_const1 c", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Pr 1 Z r_code_const1_aux) [c, ?x] \\<down>= code_const1 c\n\ngoal (1 subgoal):\n 1. eval r_code_const1 [c] \\<down>= code_const1 c", "by (simp add: r_code_const1_def r_code_const1_aux_prim)"], ["proof (state)\nthis:\n  eval r_code_const1 [c] \\<down>= code_const1 c\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Functions that compute codes of higher-arity constant functions:\\<close>"], ["", "definition code_constn :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"code_constn n c \\<equiv>\n    if n = 1 then code_const1 c\n    else quad_encode 3 n (code_const1 c) (singleton_encode (triple_encode 2 n 0))\""], ["", "lemma code_constn: \"code_constn (Suc n) c = encode (r_constn n c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. code_constn (Suc n) c = encode (r_constn n c)", "unfolding code_constn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if Suc n = 1 then code_const1 c\n     else quad_encode 3 (Suc n) (code_const1 c)\n           (singleton_encode (triple_encode 2 (Suc n) 0))) =\n    encode (r_constn n c)", "using code_const1 r_constn_def"], ["proof (prove)\nusing this:\n  code_const1 ?c = encode (r_const ?c)\n  r_constn ?n ?c \\<equiv>\n  if ?n = 0 then r_const ?c else r_dummy ?n (r_const ?c)\n\ngoal (1 subgoal):\n 1. (if Suc n = 1 then code_const1 c\n     else quad_encode 3 (Suc n) (code_const1 c)\n           (singleton_encode (triple_encode 2 (Suc n) 0))) =\n    encode (r_constn n c)", "by (cases \"n = 0\") simp_all"], ["", "definition r_code_constn :: \"nat \\<Rightarrow> recf\" where\n  \"r_code_constn n \\<equiv>\n     if n = 1 then r_code_const1\n     else\n       Cn 1 r_prod_encode\n        [r_const 3,\n         Cn 1 r_prod_encode\n          [r_const n,\n           Cn 1 r_prod_encode\n            [r_code_const1,\n             Cn 1 r_singleton_encode\n              [Cn 1 r_prod_encode\n                [r_const 2, Cn 1 r_prod_encode [r_const n, Z]]]]]]\""], ["", "lemma r_code_constn_prim: \"prim_recfn 1 (r_code_constn n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_code_constn n)", "by (simp_all add: r_code_constn_def r_code_const1_prim)"], ["", "lemma r_code_constn: \"eval (r_code_constn n) [c] \\<down>= code_constn n c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_code_constn n) [c] \\<down>= code_constn n c", "by (auto simp add: r_code_constn_def r_code_const1 code_constn_def r_code_const1_prim)"], ["", "text \\<open>Computing codes of $m$-ary projections:\\<close>"], ["", "definition code_id :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"code_id m n \\<equiv> triple_encode 2 m n\""], ["", "lemma code_id: \"encode (Id m n) = code_id m n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (recf.Id m n) = code_id m n", "unfolding code_id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (recf.Id m n) = triple_encode 2 m n", "by simp"], ["", "text \\<open>The functions $s^m_n$ are represented by the following function.\nThe value $m$ corresponds to the length of @{term \"cs\"}.\\<close>"], ["", "definition smn :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat list \\<Rightarrow> nat\" where\n  \"smn n p cs \\<equiv> quad_encode\n     3\n     n\n     (encode (r_universal (n + length cs)))\n     (list_encode (code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]))\""], ["", "lemma smn:\n  assumes \"n > 0\"\n  shows \"smn n p cs = encode\n   (Cn n\n     (r_universal (n + length cs))\n     (r_constn (n - 1) p # map (r_constn (n - 1)) cs @ (map (Id n) [0..<n])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "let ?p = \"r_constn (n - 1) p\""], ["proof (state)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "let ?gs1 = \"map (r_constn (n - 1)) cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "let ?gs2 = \"map (Id n) [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "let ?gs = \"?p # ?gs1 @ ?gs2\""], ["proof (state)\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have \"map encode ?gs1 = map (code_constn n) cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map encode (map (r_constn (n - 1)) cs) = map (code_constn n) cs", "by (intro nth_equalityI; auto; metis code_constn assms Suc_pred)"], ["proof (state)\nthis:\n  map encode (map (r_constn (n - 1)) cs) = map (code_constn n) cs\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "moreover"], ["proof (state)\nthis:\n  map encode (map (r_constn (n - 1)) cs) = map (code_constn n) cs\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have \"map encode ?gs2 = map (code_id n) [0..<n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map encode (map (recf.Id n) [0..<n]) = map (code_id n) [0..<n]", "by (rule nth_equalityI) (auto simp add: code_id_def)"], ["proof (state)\nthis:\n  map encode (map (recf.Id n) [0..<n]) = map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "moreover"], ["proof (state)\nthis:\n  map encode (map (recf.Id n) [0..<n]) = map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have \"encode ?p = code_constn n p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode (r_constn (n - 1) p) = code_constn n p", "using assms code_constn[of \"n - 1\" p]"], ["proof (prove)\nusing this:\n  0 < n\n  code_constn (Suc (n - 1)) p = encode (r_constn (n - 1) p)\n\ngoal (1 subgoal):\n 1. encode (r_constn (n - 1) p) = code_constn n p", "by simp"], ["proof (state)\nthis:\n  encode (r_constn (n - 1) p) = code_constn n p\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "ultimately"], ["proof (chain)\npicking this:\n  map encode (map (r_constn (n - 1)) cs) = map (code_constn n) cs\n  map encode (map (recf.Id n) [0..<n]) = map (code_id n) [0..<n]\n  encode (r_constn (n - 1) p) = code_constn n p", "have \"map encode ?gs =\n      code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]\""], ["proof (prove)\nusing this:\n  map encode (map (r_constn (n - 1)) cs) = map (code_constn n) cs\n  map encode (map (recf.Id n) [0..<n]) = map (code_id n) [0..<n]\n  encode (r_constn (n - 1) p) = code_constn n p\n\ngoal (1 subgoal):\n 1. map encode\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n    code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]", "by simp"], ["proof (state)\nthis:\n  map encode\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "then"], ["proof (chain)\npicking this:\n  map encode\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]", "show ?thesis"], ["proof (prove)\nusing this:\n  map encode\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. smn n p cs =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "unfolding smn_def"], ["proof (prove)\nusing this:\n  map encode\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. quad_encode 3 n (encode (r_universal (n + length cs)))\n     (Partial_Recursive.list_encode\n       (code_constn n p #\n        map (code_constn n) cs @ map (code_id n) [0..<n])) =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "using assms encode.simps(4)"], ["proof (prove)\nusing this:\n  map encode\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  code_constn n p # map (code_constn n) cs @ map (code_id n) [0..<n]\n  0 < n\n  encode (Cn ?n ?f ?gs) =\n  quad_encode 3 ?n (encode ?f)\n   (Partial_Recursive.list_encode (map encode ?gs))\n\ngoal (1 subgoal):\n 1. quad_encode 3 n (encode (r_universal (n + length cs)))\n     (Partial_Recursive.list_encode\n       (code_constn n p #\n        map (code_constn n) cs @ map (code_id n) [0..<n])) =\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by presburger"], ["proof (state)\nthis:\n  smn n p cs =\n  encode\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next function is to help us define @{typ recf}s corresponding\nto the $s^m_n$ functions. It maps $m + 1$ arguments $p, c_1, \\ldots, c_m$ to\nan encoded list of length $m + n + 1$. The list comprises the $m + 1$ codes\nof the $n$-ary constants $p, c_1, \\ldots, c_m$ and the $n$ codes for all\n$n$-ary projections.\\<close>"], ["", "definition r_smn_aux :: \"nat \\<Rightarrow> nat \\<Rightarrow> recf\" where\n  \"r_smn_aux n m \\<equiv>\n     Cn (Suc m)\n      (r_list_encode (m + n))\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [Id (Suc m) i]) [0..<Suc m] @\n       map (\\<lambda>i. r_constn m (code_id n i)) [0..<n])\""], ["", "lemma r_smn_aux_prim: \"n > 0 \\<Longrightarrow> prim_recfn (Suc m) (r_smn_aux n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> prim_recfn (Suc m) (r_smn_aux n m)", "by (auto simp add: r_smn_aux_def r_code_constn_prim)"], ["", "lemma r_smn_aux:\n  assumes \"n > 0\" and \"length cs = m\"\n  shows \"eval (r_smn_aux n m) (p # cs) \\<down>=\n    list_encode (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "let ?xs = \"map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [Id (Suc m) i]) [0..<Suc m]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "let ?ys = \"map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have len_xs: \"length ?xs = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) =\n    Suc m", "by simp"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  Suc m\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have map_xs: \"map (\\<lambda>g. eval g (p # cs)) ?xs = map Some (map (code_constn n) (p # cs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) =\n    map Some (map (code_constn n) (p # cs))", "proof (intro nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map (\\<lambda>g. eval g (p # cs))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m])) =\n    length (map Some (map (code_constn n) (p # cs)))\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "show len: \"length (map (\\<lambda>g. eval g (p # cs)) ?xs) =\n        length (map Some (map (code_constn n) (p # cs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>g. eval g (p # cs))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m])) =\n    length (map Some (map (code_constn n) (p # cs)))", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  length (map Some (map (code_constn n) (p # cs)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "have \"map (\\<lambda>g. eval g (p # cs)) ?xs ! i = map Some (map (code_constn n) (p # cs)) ! i\"\n        if \"i < Suc m\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "have \"map (\\<lambda>g. eval g (p # cs)) ?xs ! i = (\\<lambda>g. eval g (p # cs)) (?xs ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    eval\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] !\n      i)\n     (p # cs)", "using len_xs that"], ["proof (prove)\nusing this:\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  Suc m\n  i < Suc m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    eval\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] !\n      i)\n     (p # cs)", "by (metis nth_map)"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  eval\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] !\n    i)\n   (p # cs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "also"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  eval\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] !\n    i)\n   (p # cs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "have \"... = eval (Cn (Suc m) (r_code_constn n) [Id (Suc m) i]) (p # cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] !\n      i)\n     (p # cs) =\n    eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs)", "using that len_xs"], ["proof (prove)\nusing this:\n  i < Suc m\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  Suc m\n\ngoal (1 subgoal):\n 1. eval\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] !\n      i)\n     (p # cs) =\n    eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs)", "by (metis (no_types, lifting) add.left_neutral length_map nth_map nth_upt)"], ["proof (state)\nthis:\n  eval\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] !\n    i)\n   (p # cs) =\n  eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "also"], ["proof (state)\nthis:\n  eval\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] !\n    i)\n   (p # cs) =\n  eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "have \"... = eval (r_code_constn n) [the (eval (Id (Suc m) i) (p # cs))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs) =\n    eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))]", "using r_code_constn_prim assms(2) that"], ["proof (prove)\nusing this:\n  prim_recfn 1 (r_code_constn ?n)\n  length cs = m\n  i < Suc m\n\ngoal (1 subgoal):\n 1. eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs) =\n    eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))]", "by simp"], ["proof (state)\nthis:\n  eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs) =\n  eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "also"], ["proof (state)\nthis:\n  eval (Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i]) (p # cs) =\n  eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "have \"... = eval (r_code_constn n) [(p # cs) ! i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))] =\n    eval (r_code_constn n) [(p # cs) ! i]", "using len that"], ["proof (prove)\nusing this:\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  length (map Some (map (code_constn n) (p # cs)))\n  i < Suc m\n\ngoal (1 subgoal):\n 1. eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))] =\n    eval (r_code_constn n) [(p # cs) ! i]", "by simp"], ["proof (state)\nthis:\n  eval (r_code_constn n) [the (eval (recf.Id (Suc m) i) (p # cs))] =\n  eval (r_code_constn n) [(p # cs) ! i]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  eval (r_code_constn n) [(p # cs) ! i]", "have \"map (\\<lambda>g. eval g (p # cs)) ?xs ! i \\<down>= code_constn n ((p # cs) ! i)\""], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  eval (r_code_constn n) [(p # cs) ! i]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i \\<down>=\n    code_constn n ((p # cs) ! i)", "using r_code_constn"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  eval (r_code_constn n) [(p # cs) ! i]\n  eval (r_code_constn ?n) [?c] \\<down>= code_constn ?n ?c\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i \\<down>=\n    code_constn n ((p # cs) ! i)", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i \\<down>=\n  code_constn n ((p # cs) ! i)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "then"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i \\<down>=\n  code_constn n ((p # cs) ! i)", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i \\<down>=\n  code_constn n ((p # cs) ! i)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "using len_xs len that"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i \\<down>=\n  code_constn n ((p # cs) ! i)\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  Suc m\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  length (map Some (map (code_constn n) (p # cs)))\n  i < Suc m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m]) !\n    i =\n    map Some (map (code_constn n) (p # cs)) ! i", "by (metis length_map nth_map)"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  i =\n  map Some (map (code_constn n) (p # cs)) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < Suc m \\<Longrightarrow>\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  ?i =\n  map Some (map (code_constn n) (p # cs)) ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "moreover"], ["proof (state)\nthis:\n  ?i < Suc m \\<Longrightarrow>\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  ?i =\n  map Some (map (code_constn n) (p # cs)) ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "have \"length (map (\\<lambda>g. eval g (p # cs)) ?xs) = Suc m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>g. eval g (p # cs))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m])) =\n    Suc m", "by simp"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "ultimately"], ["proof (chain)\npicking this:\n  ?i < Suc m \\<Longrightarrow>\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  ?i =\n  map Some (map (code_constn n) (p # cs)) ! ?i\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  Suc m", "show \"\\<And>i. i < length (map (\\<lambda>g. eval g (p # cs)) ?xs) \\<Longrightarrow>\n        map (\\<lambda>g. eval g (p # cs)) ?xs ! i =\n        map Some (map (code_constn n) (p # cs)) ! i\""], ["proof (prove)\nusing this:\n  ?i < Suc m \\<Longrightarrow>\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  ?i =\n  map Some (map (code_constn n) (p # cs)) ! ?i\n  length\n   (map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m])) =\n  Suc m\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. eval g (p # cs))\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m])) \\<Longrightarrow>\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i =\n       map Some (map (code_constn n) (p # cs)) ! i", "by simp"], ["proof (state)\nthis:\n  ?i < length\n        (map (\\<lambda>g. eval g (p # cs))\n          (map (\\<lambda>i.\n                   Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n            [0..<Suc m])) \\<Longrightarrow>\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) !\n  ?i =\n  map Some (map (code_constn n) (p # cs)) ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"map (\\<lambda>g. eval g (p # cs)) ?ys = map Some (map (code_id n) [0..<n])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    map Some (map (code_id n) [0..<n])", "using assms(2)"], ["proof (prove)\nusing this:\n  length cs = m\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    map Some (map (code_id n) [0..<n])", "by (intro nth_equalityI; auto)"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_id n) [0..<n])", "have \"map (\\<lambda>g. eval g (p # cs)) (?xs @ ?ys) =\n      map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\""], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. eval g (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "by (metis map_append)"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "moreover"], ["proof (state)\nthis:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"map (\\<lambda>x. the (eval x (p # cs))) (?xs @ ?ys) =\n      map the (map (\\<lambda>x. eval x (p # cs)) (?xs @ ?ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>x. the (eval x (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    map the\n     (map (\\<lambda>x. eval x (p # cs))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>x. the (eval x (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map the\n   (map (\\<lambda>x. eval x (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "ultimately"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n  map (\\<lambda>x. the (eval x (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map the\n   (map (\\<lambda>x. eval x (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "have *: \"map (\\<lambda>g. the (eval g (p # cs))) (?xs @ ?ys) =\n      (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\""], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map Some (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n  map (\\<lambda>x. the (eval x (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map the\n   (map (\\<lambda>x. eval x (p # cs))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    map (code_constn n) (p # cs) @ map (code_id n) [0..<n]", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map (code_constn n) (p # cs) @ map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"\\<forall>i<length ?xs. eval (?xs ! i) (p # cs) = map (\\<lambda>g. eval g (p # cs)) ?xs ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map (\\<lambda>i.\n                         Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                  [0..<Suc m]).\n       eval\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m] !\n         i)\n        (p # cs) =\n       map (\\<lambda>g. eval g (p # cs))\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m]) !\n       i", "by (metis nth_map)"], ["proof (state)\nthis:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map (\\<lambda>g. eval g (p # cs))\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m]) !\n     i\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map (\\<lambda>g. eval g (p # cs))\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m]) !\n     i", "have\n    \"\\<forall>i<length ?xs. eval (?xs ! i) (p # cs) = map Some (map (code_constn n) (p # cs)) ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map (\\<lambda>g. eval g (p # cs))\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m]) !\n     i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map (\\<lambda>i.\n                         Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                  [0..<Suc m]).\n       eval\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m] !\n         i)\n        (p # cs) =\n       map Some (map (code_constn n) (p # cs)) ! i", "using map_xs"], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map (\\<lambda>g. eval g (p # cs))\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m]) !\n     i\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map (\\<lambda>i.\n                         Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                  [0..<Suc m]).\n       eval\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m] !\n         i)\n        (p # cs) =\n       map Some (map (code_constn n) (p # cs)) ! i", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map Some (map (code_constn n) (p # cs)) ! i\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map Some (map (code_constn n) (p # cs)) ! i", "have \"\\<forall>i<length ?xs. eval (?xs ! i) (p # cs) \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map Some (map (code_constn n) (p # cs)) ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map (\\<lambda>i.\n                         Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                  [0..<Suc m]).\n       eval\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m] !\n         i)\n        (p # cs) \\<down>", "using assms map_xs"], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) =\n     map Some (map (code_constn n) (p # cs)) ! i\n  0 < n\n  length cs = m\n  map (\\<lambda>g. eval g (p # cs))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m]) =\n  map Some (map (code_constn n) (p # cs))\n\ngoal (1 subgoal):\n 1. \\<forall>i<length\n                (map (\\<lambda>i.\n                         Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                  [0..<Suc m]).\n       eval\n        (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n          [0..<Suc m] !\n         i)\n        (p # cs) \\<down>", "by (metis length_map nth_map option.simps(3))"], ["proof (state)\nthis:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) \\<down>", "have xs_converg: \"\\<forall>z\\<in>set ?xs. eval z (p # cs) \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length\n              (map (\\<lambda>i.\n                       Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n                [0..<Suc m]).\n     eval\n      (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n        [0..<Suc m] !\n       i)\n      (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set (map (\\<lambda>i.\n                                Cn (Suc m) (r_code_constn n)\n                                 [recf.Id (Suc m) i])\n                         [0..<Suc m]).\n       eval z (p # cs) \\<down>", "by (metis in_set_conv_nth)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m]).\n     eval z (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"\\<forall>i<length ?ys. eval (?ys ! i) (p # cs) = map (\\<lambda>x. eval x (p # cs)) ?ys ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n        (p # cs) =\n       map (\\<lambda>x. eval x (p # cs))\n        (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) !\n       i", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map (\\<lambda>x. eval x (p # cs))\n      (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) !\n     i\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map (\\<lambda>x. eval x (p # cs))\n      (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) !\n     i", "have\n    \"\\<forall>i<length ?ys. eval (?ys ! i) (p # cs) = map Some (map (code_id n) [0..<n]) ! i\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map (\\<lambda>x. eval x (p # cs))\n      (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) !\n     i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n        (p # cs) =\n       map Some (map (code_id n) [0..<n]) ! i", "using assms(2)"], ["proof (prove)\nusing this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map (\\<lambda>x. eval x (p # cs))\n      (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) !\n     i\n  length cs = m\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n        (p # cs) =\n       map Some (map (code_id n) [0..<n]) ! i", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map Some (map (code_id n) [0..<n]) ! i\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map Some (map (code_id n) [0..<n]) ! i", "have \"\\<forall>i<length ?ys. eval (?ys ! i) (p # cs) \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) =\n     map Some (map (code_id n) [0..<n]) ! i\n\ngoal (1 subgoal):\n 1. \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n        (p # cs) \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) \\<down>", "have \"\\<forall>z\\<in>set (?xs @ ?ys). eval z (p # cs) \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set (map (\\<lambda>i.\n                                Cn (Suc m) (r_code_constn n)\n                                 [recf.Id (Suc m) i])\n                         [0..<Suc m] @\n                        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval z (p # cs) \\<down>", "using xs_converg"], ["proof (prove)\nusing this:\n  \\<forall>i<length (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval (map (\\<lambda>i. r_constn m (code_id n i)) [0..<n] ! i)\n      (p # cs) \\<down>\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m]).\n     eval z (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set (map (\\<lambda>i.\n                                Cn (Suc m) (r_code_constn n)\n                                 [recf.Id (Suc m) i])\n                         [0..<Suc m] @\n                        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n       eval z (p # cs) \\<down>", "by auto"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "moreover"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"recfn (length (p # cs)) (Cn (Suc m) (r_list_encode (m + n)) (?xs @ ?ys))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length (p # cs))\n     (Cn (Suc m) (r_list_encode (m + n))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "using assms r_code_constn_prim"], ["proof (prove)\nusing this:\n  0 < n\n  length cs = m\n  prim_recfn 1 (r_code_constn ?n)\n\ngoal (1 subgoal):\n 1. recfn (length (p # cs))\n     (Cn (Suc m) (r_list_encode (m + n))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "by auto"], ["proof (state)\nthis:\n  recfn (length (p # cs))\n   (Cn (Suc m) (r_list_encode (m + n))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n  recfn (length (p # cs))\n   (Cn (Suc m) (r_list_encode (m + n))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "have \"eval (r_smn_aux n m) (p # cs) =\n      eval (r_list_encode (m + n)) (map (\\<lambda>g. the (eval g (p # cs))) (?xs @ ?ys))\""], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n  recfn (length (p # cs))\n   (Cn (Suc m) (r_list_encode (m + n))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) =\n    eval (r_list_encode (m + n))\n     (map (\\<lambda>g. the (eval g (p # cs)))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "unfolding r_smn_aux_def"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n  recfn (length (p # cs))\n   (Cn (Suc m) (r_list_encode (m + n))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc m) (r_list_encode (m + n))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n     (p # cs) =\n    eval (r_list_encode (m + n))\n     (map (\\<lambda>g. the (eval g (p # cs)))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>z\\<in>set (map (\\<lambda>i.\n                              Cn (Suc m) (r_code_constn n)\n                               [recf.Id (Suc m) i])\n                       [0..<Suc m] @\n                      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]).\n     eval z (p # cs) \\<down>\n  recfn (length (p # cs))\n   (Cn (Suc m) (r_list_encode (m + n))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n  0 < n\n  length cs = m\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc m) (r_list_encode (m + n))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n     (p # cs) =\n    eval (r_list_encode (m + n))\n     (map (\\<lambda>g. the (eval g (p # cs)))\n       (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n         [0..<Suc m] @\n        map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "by simp"], ["proof (state)\nthis:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (\\<lambda>g. the (eval g (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "then"], ["proof (chain)\npicking this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (\\<lambda>g. the (eval g (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))", "have \"eval (r_smn_aux n m) (p # cs) =\n      eval (r_list_encode (m + n)) (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\""], ["proof (prove)\nusing this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (\\<lambda>g. the (eval g (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) =\n    eval (r_list_encode (m + n))\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "using *"], ["proof (prove)\nusing this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (\\<lambda>g. the (eval g (p # cs)))\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]))\n  map (\\<lambda>g. the (eval g (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map (code_constn n) (p # cs) @ map (code_id n) [0..<n]\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) =\n    eval (r_list_encode (m + n))\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "by metis"], ["proof (state)\nthis:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "moreover"], ["proof (state)\nthis:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "have \"length (?xs @ ?ys) = Suc (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n       [0..<Suc m] @\n      map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n    Suc (m + n)", "by simp"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  Suc (m + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "using r_list_encode * assms(1)"], ["proof (prove)\nusing this:\n  eval (r_smn_aux n m) (p # cs) =\n  eval (r_list_encode (m + n))\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n  length\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  Suc (m + n)\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_list_encode ?n) ?xs \\<down>= Partial_Recursive.list_encode ?xs\n  map (\\<lambda>g. the (eval g (p # cs)))\n   (map (\\<lambda>i. Cn (Suc m) (r_code_constn n) [recf.Id (Suc m) i])\n     [0..<Suc m] @\n    map (\\<lambda>i. r_constn m (code_id n i)) [0..<n]) =\n  map (code_constn n) (p # cs) @ map (code_id n) [0..<n]\n  0 < n\n\ngoal (1 subgoal):\n 1. eval (r_smn_aux n m) (p # cs) \\<down>=\n    Partial_Recursive.list_encode\n     (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])", "by (metis (no_types, lifting) length_map)"], ["proof (state)\nthis:\n  eval (r_smn_aux n m) (p # cs) \\<down>=\n  Partial_Recursive.list_encode\n   (map (code_constn n) (p # cs) @ map (code_id n) [0..<n])\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For all $m, n > 0$, the @{typ recf} corresponding to $s^m_n$ is\ngiven by the next function.\\<close>"], ["", "definition r_smn :: \"nat \\<Rightarrow> nat \\<Rightarrow> recf\" where\n \"r_smn n m \\<equiv>\n    Cn (Suc m) r_prod_encode\n     [r_constn m 3,\n      Cn (Suc m) r_prod_encode\n       [r_constn m n,\n        Cn (Suc m) r_prod_encode\n          [r_constn m (encode (r_universal (n + m))), r_smn_aux n m]]]\""], ["", "lemma r_smn_prim [simp]: \"n > 0 \\<Longrightarrow> prim_recfn (Suc m) (r_smn n m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> prim_recfn (Suc m) (r_smn n m)", "by (simp_all add: r_smn_def r_smn_aux_prim)"], ["", "lemma r_smn:\n  assumes \"n > 0\" and \"length cs = m\"\n  shows \"eval (r_smn n m) (p # cs) \\<down>= smn n p cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_smn n m) (p # cs) \\<down>= smn n p cs", "using assms r_smn_def r_smn_aux smn_def r_smn_aux_prim"], ["proof (prove)\nusing this:\n  0 < n\n  length cs = m\n  r_smn ?n ?m \\<equiv>\n  Cn (Suc ?m) r_prod_encode\n   [r_constn ?m 3,\n    Cn (Suc ?m) r_prod_encode\n     [r_constn ?m ?n,\n      Cn (Suc ?m) r_prod_encode\n       [r_constn ?m (encode (r_universal (?n + ?m))), r_smn_aux ?n ?m]]]\n  \\<lbrakk>0 < ?n; length ?cs = ?m\\<rbrakk>\n  \\<Longrightarrow> eval (r_smn_aux ?n ?m) (?p # ?cs) \\<down>=\n                    Partial_Recursive.list_encode\n                     (map (code_constn ?n) (?p # ?cs) @\n                      map (code_id ?n) [0..<?n])\n  smn ?n ?p ?cs \\<equiv>\n  quad_encode 3 ?n (encode (r_universal (?n + length ?cs)))\n   (Partial_Recursive.list_encode\n     (code_constn ?n ?p #\n      map (code_constn ?n) ?cs @ map (code_id ?n) [0..<?n]))\n  0 < ?n \\<Longrightarrow> prim_recfn (Suc ?m) (r_smn_aux ?n ?m)\n\ngoal (1 subgoal):\n 1. eval (r_smn n m) (p # cs) \\<down>= smn n p cs", "by simp"], ["", "lemma map_eval_Some_the:\n  assumes \"map (\\<lambda>g. eval g xs) gs = map Some ys\"\n  shows \"map (\\<lambda>g. the (eval g xs)) gs = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs)) gs = ys", "using assms"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. eval g xs) gs = map Some ys\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs)) gs = ys", "by (metis (no_types, lifting) length_map nth_equalityI nth_map option.sel)"], ["", "text \\<open>The essential part of the $s$-$m$-$n$ theorem: For all $m, n > 0$\nthe function $s^m_n$ satisfies\n\\[\n  \\varphi_p^{(m + n)}(c_1, \\dots,c_m, x_1, \\dots, x_n) =\n  \\varphi_{s^m_n(p, c_1, \\dots,c_m)}^{(n)}(x_1, \\dots, x_n)\n\\] for all $p, c_i, x_j$.\\<close>"], ["", "lemma smn_lemma:\n  assumes \"n > 0\" and len_cs: \"length cs = m\" and len_xs: \"length xs = n\"\n  shows \"eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) ((the (eval (r_smn n m) (p # cs))) # xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "let ?s = \"r_smn n m\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "let ?f = \"Cn n\n    (r_universal (n + length cs))\n    (r_constn (n - 1) p # map (r_constn (n - 1)) cs @ (map (Id n) [0..<n]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "have \"eval ?s (p # cs) \\<down>= smn n p cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_smn n m) (p # cs) \\<down>= smn n p cs", "using assms r_smn"], ["proof (prove)\nusing this:\n  0 < n\n  length cs = m\n  length xs = n\n  \\<lbrakk>0 < ?n; length ?cs = ?m\\<rbrakk>\n  \\<Longrightarrow> eval (r_smn ?n ?m) (?p # ?cs) \\<down>= smn ?n ?p ?cs\n\ngoal (1 subgoal):\n 1. eval (r_smn n m) (p # cs) \\<down>= smn n p cs", "by simp"], ["proof (state)\nthis:\n  eval (r_smn n m) (p # cs) \\<down>= smn n p cs\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "then"], ["proof (chain)\npicking this:\n  eval (r_smn n m) (p # cs) \\<down>= smn n p cs", "have eval_s: \"eval ?s (p # cs) \\<down>= encode ?f\""], ["proof (prove)\nusing this:\n  eval (r_smn n m) (p # cs) \\<down>= smn n p cs\n\ngoal (1 subgoal):\n 1. eval (r_smn n m) (p # cs) \\<down>=\n    encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by (simp add: assms(1) smn)"], ["proof (state)\nthis:\n  eval (r_smn n m) (p # cs) \\<down>=\n  encode\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "have \"recfn n ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn n\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "using len_cs assms"], ["proof (prove)\nusing this:\n  length cs = m\n  0 < n\n  length cs = m\n  length xs = n\n\ngoal (1 subgoal):\n 1. recfn n\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by auto"], ["proof (state)\nthis:\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "then"], ["proof (chain)\npicking this:\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have *: \"eval (r_universal n) ((encode ?f) # xs) = eval ?f xs\""], ["proof (prove)\nusing this:\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal n)\n     (encode\n       (Cn n (r_universal (n + length cs))\n         (r_constn (n - 1) p #\n          map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) #\n      xs) =\n    eval\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n     xs", "using r_universal[of ?f n, OF _ len_xs]"], ["proof (prove)\nusing this:\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @\n      map (recf.Id n) [0..<n])) \\<Longrightarrow>\n  eval (r_universal n)\n   (encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) #\n    xs) =\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs\n\ngoal (1 subgoal):\n 1. eval (r_universal n)\n     (encode\n       (Cn n (r_universal (n + length cs))\n         (r_constn (n - 1) p #\n          map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) #\n      xs) =\n    eval\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n     xs", "by simp"], ["proof (state)\nthis:\n  eval (r_universal n)\n   (encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) #\n    xs) =\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "let ?gs = \"r_constn (n - 1) p # map (r_constn (n - 1)) cs @ map (Id n) [0..<n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "have \"\\<forall>g\\<in>set ?gs. eval g xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (r_constn (n - 1) p #\n                        map (r_constn (n - 1)) cs @\n                        map (recf.Id n) [0..<n]).\n       eval g xs \\<down>", "using len_cs len_xs assms"], ["proof (prove)\nusing this:\n  length cs = m\n  length xs = n\n  0 < n\n  length cs = m\n  length xs = n\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>set (r_constn (n - 1) p #\n                        map (r_constn (n - 1)) cs @\n                        map (recf.Id n) [0..<n]).\n       eval g xs \\<down>", "by auto"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set (r_constn (n - 1) p #\n                      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]).\n     eval g xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "then"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>set (r_constn (n - 1) p #\n                      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]).\n     eval g xs \\<down>", "have \"eval ?f xs =\n      eval (r_universal (n + length cs)) (map (\\<lambda>g. the (eval g xs)) ?gs)\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set (r_constn (n - 1) p #\n                      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]).\n     eval g xs \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n     xs =\n    eval (r_universal (n + length cs))\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "using len_cs len_xs assms \\<open>recfn n ?f\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set (r_constn (n - 1) p #\n                      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]).\n     eval g xs \\<down>\n  length cs = m\n  length xs = n\n  0 < n\n  length cs = m\n  length xs = n\n  recfn n\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n     xs =\n    eval (r_universal (n + length cs))\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (n + length cs))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (n + length cs))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have \"eval ?f xs = eval (r_universal (m + n)) (map (\\<lambda>g. the (eval g xs)) ?gs)\""], ["proof (prove)\nusing this:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (n + length cs))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n     xs =\n    eval (r_universal (m + n))\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by (simp add: len_cs add.commute)"], ["proof (state)\nthis:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "have \"eval (r_universal n) ((the (eval ?s (p # cs))) # xs) =\n      eval (r_universal (m + n)) (map (\\<lambda>g. the (eval g xs)) ?gs)\""], ["proof (prove)\nusing this:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n    eval (r_universal (m + n))\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "using eval_s *"], ["proof (prove)\nusing this:\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n  eval (r_smn n m) (p # cs) \\<down>=\n  encode\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n  eval (r_universal n)\n   (encode\n     (Cn n (r_universal (n + length cs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) #\n    xs) =\n  eval\n   (Cn n (r_universal (n + length cs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n   xs\n\ngoal (1 subgoal):\n 1. eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n    eval (r_universal (m + n))\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))", "by simp"], ["proof (state)\nthis:\n  eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "moreover"], ["proof (state)\nthis:\n  eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "have \"map (\\<lambda>g. the (eval g xs)) ?gs = p # cs @ xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n    p # cs @ xs", "proof (intro nth_equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. length\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n    length (p # cs @ xs)\n 2. \\<And>i.\n       i < length\n            (map (\\<lambda>g. the (eval g xs))\n              (r_constn (n - 1) p #\n               map (r_constn (n - 1)) cs @\n               map (recf.Id n) [0..<n])) \\<Longrightarrow>\n       map (\\<lambda>g. the (eval g xs))\n        (r_constn (n - 1) p #\n         map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n       i =\n       (p # cs @ xs) ! i", "show \"length (map (\\<lambda>g. the (eval g xs)) ?gs) = length (p # cs @ xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n    length (p # cs @ xs)", "by (simp add: len_xs)"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  length (p # cs @ xs)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. the (eval g xs))\n              (r_constn (n - 1) p #\n               map (r_constn (n - 1)) cs @\n               map (recf.Id n) [0..<n])) \\<Longrightarrow>\n       map (\\<lambda>g. the (eval g xs))\n        (r_constn (n - 1) p #\n         map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n       i =\n       (p # cs @ xs) ! i", "have len: \"length (map (\\<lambda>g. the (eval g xs)) ?gs) = Suc (m + n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length\n     (map (\\<lambda>g. the (eval g xs))\n       (r_constn (n - 1) p #\n        map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n    Suc (m + n)", "by (simp add: len_cs)"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. the (eval g xs))\n              (r_constn (n - 1) p #\n               map (r_constn (n - 1)) cs @\n               map (recf.Id n) [0..<n])) \\<Longrightarrow>\n       map (\\<lambda>g. the (eval g xs))\n        (r_constn (n - 1) p #\n         map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n       i =\n       (p # cs @ xs) ! i", "moreover"], ["proof (state)\nthis:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. the (eval g xs))\n              (r_constn (n - 1) p #\n               map (r_constn (n - 1)) cs @\n               map (recf.Id n) [0..<n])) \\<Longrightarrow>\n       map (\\<lambda>g. the (eval g xs))\n        (r_constn (n - 1) p #\n         map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n       i =\n       (p # cs @ xs) ! i", "have \"map (\\<lambda>g. the (eval g xs)) ?gs ! i = (p # cs @ xs) ! i\"\n      if \"i < Suc (m + n)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "from that"], ["proof (chain)\npicking this:\n  i < Suc (m + n)", "consider \"i = 0\" | \"i > 0 \\<and> i < Suc m\" | \"Suc m \\<le> i \\<and> i < Suc (m + n)\""], ["proof (prove)\nusing this:\n  i < Suc (m + n)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis;\n     0 < i \\<and> i < Suc m \\<Longrightarrow> thesis;\n     Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using not_le_imp_less"], ["proof (prove)\nusing this:\n  i < Suc (m + n)\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = 0 \\<Longrightarrow> thesis;\n     0 < i \\<and> i < Suc m \\<Longrightarrow> thesis;\n     Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis;\n   0 < i \\<and> i < Suc m \\<Longrightarrow> ?thesis;\n   Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis;\n   0 < i \\<and> i < Suc m \\<Longrightarrow> ?thesis;\n   Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>i = 0 \\<Longrightarrow> ?thesis;\n   0 < i \\<and> i < Suc m \\<Longrightarrow> ?thesis;\n   Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 3. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "case 1"], ["proof (state)\nthis:\n  i = 0\n\ngoal (3 subgoals):\n 1. i = 0 \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 3. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  i = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  i = 0\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "using assms(1) len_xs"], ["proof (prove)\nusing this:\n  i = 0\n  0 < n\n  length xs = n\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "by simp"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "case 2"], ["proof (state)\nthis:\n  0 < i \\<and> i < Suc m\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  0 < i \\<and> i < Suc m", "have \"?gs ! i = (map (r_constn (n - 1)) cs) ! (i - 1)\""], ["proof (prove)\nusing this:\n  0 < i \\<and> i < Suc m\n\ngoal (1 subgoal):\n 1. (r_constn (n - 1) p #\n     map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    map (r_constn (n - 1)) cs ! (i - 1)", "using len_cs"], ["proof (prove)\nusing this:\n  0 < i \\<and> i < Suc m\n  length cs = m\n\ngoal (1 subgoal):\n 1. (r_constn (n - 1) p #\n     map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    map (r_constn (n - 1)) cs ! (i - 1)", "by (metis One_nat_def Suc_less_eq Suc_pred length_map\n            less_numeral_extra(3) nth_Cons' nth_append)"], ["proof (state)\nthis:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (r_constn (n - 1)) cs ! (i - 1)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (r_constn (n - 1)) cs ! (i - 1)", "have \"map (\\<lambda>g. the (eval g xs)) ?gs ! i =\n            (\\<lambda>g. the (eval g xs)) ((map (r_constn (n - 1)) cs) ! (i - 1))\""], ["proof (prove)\nusing this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (r_constn (n - 1)) cs ! (i - 1)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs)", "using len"], ["proof (prove)\nusing this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (r_constn (n - 1)) cs ! (i - 1)\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs)", "by (metis length_map nth_map that)"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = the (eval ((r_constn (n - 1) (cs ! (i - 1)))) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs) =\n    the (eval (r_constn (n - 1) (cs ! (i - 1))) xs)", "using 2 len_cs"], ["proof (prove)\nusing this:\n  0 < i \\<and> i < Suc m\n  length cs = m\n\ngoal (1 subgoal):\n 1. the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs) =\n    the (eval (r_constn (n - 1) (cs ! (i - 1))) xs)", "by auto"], ["proof (state)\nthis:\n  the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs) =\n  the (eval (r_constn (n - 1) (cs ! (i - 1))) xs)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  the (eval (map (r_constn (n - 1)) cs ! (i - 1)) xs) =\n  the (eval (r_constn (n - 1) (cs ! (i - 1))) xs)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = cs ! (i - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (eval (r_constn (n - 1) (cs ! (i - 1))) xs) = cs ! (i - 1)", "using r_constn len_xs assms(1)"], ["proof (prove)\nusing this:\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_constn ?n ?c) ?xs \\<down>= ?c\n  length xs = n\n  0 < n\n\ngoal (1 subgoal):\n 1. the (eval (r_constn (n - 1) (cs ! (i - 1))) xs) = cs ! (i - 1)", "by simp"], ["proof (state)\nthis:\n  the (eval (r_constn (n - 1) (cs ! (i - 1))) xs) = cs ! (i - 1)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  the (eval (r_constn (n - 1) (cs ! (i - 1))) xs) = cs ! (i - 1)\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = (p # cs @ xs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cs ! (i - 1) = (p # cs @ xs) ! i", "using 2 len_cs"], ["proof (prove)\nusing this:\n  0 < i \\<and> i < Suc m\n  length cs = m\n\ngoal (1 subgoal):\n 1. cs ! (i - 1) = (p # cs @ xs) ! i", "by (metis diff_Suc_1 less_Suc_eq_0_disj less_numeral_extra(3) nth_Cons' nth_append)"], ["proof (state)\nthis:\n  cs ! (i - 1) = (p # cs @ xs) ! i\n\ngoal (2 subgoals):\n 1. 0 < i \\<and> i < Suc m \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i\n 2. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "."], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "case 3"], ["proof (state)\nthis:\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  Suc m \\<le> i \\<and> i < Suc (m + n)", "have \"?gs ! i = (map (Id n) [0..<n]) ! (i - Suc m)\""], ["proof (prove)\nusing this:\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n\ngoal (1 subgoal):\n 1. (r_constn (n - 1) p #\n     map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    map (recf.Id n) [0..<n] ! (i - Suc m)", "using len_cs"], ["proof (prove)\nusing this:\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n  length cs = m\n\ngoal (1 subgoal):\n 1. (r_constn (n - 1) p #\n     map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    map (recf.Id n) [0..<n] ! (i - Suc m)", "by (simp; metis (no_types, lifting) One_nat_def Suc_less_eq add_leE\n            plus_1_eq_Suc diff_diff_left length_map not_le nth_append\n            ordered_cancel_comm_monoid_diff_class.add_diff_inverse)"], ["proof (state)\nthis:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (recf.Id n) [0..<n] ! (i - Suc m)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "then"], ["proof (chain)\npicking this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (recf.Id n) [0..<n] ! (i - Suc m)", "have \"map (\\<lambda>g. the (eval g xs)) ?gs ! i =\n            (\\<lambda>g. the (eval g xs)) ((map (Id n) [0..<n]) ! (i - Suc m))\""], ["proof (prove)\nusing this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (recf.Id n) [0..<n] ! (i - Suc m)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs)", "using len"], ["proof (prove)\nusing this:\n  (r_constn (n - 1) p #\n   map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  map (recf.Id n) [0..<n] ! (i - Suc m)\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs)", "by (metis length_map nth_map that)"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = the (eval ((Id n (i - Suc m))) xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs) =\n    the (eval (recf.Id n (i - Suc m)) xs)", "using 3 len_cs"], ["proof (prove)\nusing this:\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n  length cs = m\n\ngoal (1 subgoal):\n 1. the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs) =\n    the (eval (recf.Id n (i - Suc m)) xs)", "by auto"], ["proof (state)\nthis:\n  the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs) =\n  the (eval (recf.Id n (i - Suc m)) xs)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  the (eval (map (recf.Id n) [0..<n] ! (i - Suc m)) xs) =\n  the (eval (recf.Id n (i - Suc m)) xs)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = xs ! (i - Suc m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (eval (recf.Id n (i - Suc m)) xs) = xs ! (i - Suc m)", "using len_xs 3"], ["proof (prove)\nusing this:\n  length xs = n\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n\ngoal (1 subgoal):\n 1. the (eval (recf.Id n (i - Suc m)) xs) = xs ! (i - Suc m)", "by auto"], ["proof (state)\nthis:\n  the (eval (recf.Id n (i - Suc m)) xs) = xs ! (i - Suc m)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "also"], ["proof (state)\nthis:\n  the (eval (recf.Id n (i - Suc m)) xs) = xs ! (i - Suc m)\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "have \"... = (p # cs @ xs) ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs ! (i - Suc m) = (p # cs @ xs) ! i", "using len_cs len_xs 3"], ["proof (prove)\nusing this:\n  length cs = m\n  length xs = n\n  Suc m \\<le> i \\<and> i < Suc (m + n)\n\ngoal (1 subgoal):\n 1. xs ! (i - Suc m) = (p # cs @ xs) ! i", "by (metis diff_Suc_1 diff_diff_left less_Suc_eq_0_disj not_le nth_Cons'\n            nth_append plus_1_eq_Suc)"], ["proof (state)\nthis:\n  xs ! (i - Suc m) = (p # cs @ xs) ! i\n\ngoal (1 subgoal):\n 1. Suc m \\<le> i \\<and> i < Suc (m + n) \\<Longrightarrow>\n    map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "finally"], ["proof (chain)\npicking this:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "."], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  i =\n  (p # cs @ xs) ! i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < Suc (m + n) \\<Longrightarrow>\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  ?i =\n  (p # cs @ xs) ! ?i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length\n            (map (\\<lambda>g. the (eval g xs))\n              (r_constn (n - 1) p #\n               map (r_constn (n - 1)) cs @\n               map (recf.Id n) [0..<n])) \\<Longrightarrow>\n       map (\\<lambda>g. the (eval g xs))\n        (r_constn (n - 1) p #\n         map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n       i =\n       (p # cs @ xs) ! i", "ultimately"], ["proof (chain)\npicking this:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n  ?i < Suc (m + n) \\<Longrightarrow>\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  ?i =\n  (p # cs @ xs) ! ?i", "show \"map (\\<lambda>g. the (eval g xs)) ?gs ! i = (p # cs @ xs) ! i\"\n        if \"i < length (map (\\<lambda>g. the (eval g xs)) ?gs)\" for i"], ["proof (prove)\nusing this:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n  ?i < Suc (m + n) \\<Longrightarrow>\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  ?i =\n  (p # cs @ xs) ! ?i\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "using that"], ["proof (prove)\nusing this:\n  length\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n])) =\n  Suc (m + n)\n  ?i < Suc (m + n) \\<Longrightarrow>\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  ?i =\n  (p # cs @ xs) ! ?i\n  i < length\n       (map (\\<lambda>g. the (eval g xs))\n         (r_constn (n - 1) p #\n          map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n\ngoal (1 subgoal):\n 1. map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n    i =\n    (p # cs @ xs) ! i", "by simp"], ["proof (state)\nthis:\n  ?i < length\n        (map (\\<lambda>g. the (eval g xs))\n          (r_constn (n - 1) p #\n           map (r_constn (n - 1)) cs @\n           map (recf.Id n) [0..<n])) \\<Longrightarrow>\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) !\n  ?i =\n  (p # cs @ xs) ! ?i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  p # cs @ xs\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  p # cs @ xs", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs) =\n  eval (r_universal (m + n))\n   (map (\\<lambda>g. the (eval g xs))\n     (r_constn (n - 1) p #\n      map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]))\n  map (\\<lambda>g. the (eval g xs))\n   (r_constn (n - 1) p #\n    map (r_constn (n - 1)) cs @ map (recf.Id n) [0..<n]) =\n  p # cs @ xs\n\ngoal (1 subgoal):\n 1. eval (r_universal (m + n)) (p # cs @ xs) =\n    eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)", "by simp"], ["proof (state)\nthis:\n  eval (r_universal (m + n)) (p # cs @ xs) =\n  eval (r_universal n) (the (eval (r_smn n m) (p # cs)) # xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem smn_theorem:\n  assumes \"n > 0\"\n  shows \"\\<exists>s. prim_recfn (Suc m) s \\<and>\n    (\\<forall>p cs xs. length cs = m \\<and> length xs = n \\<longrightarrow>\n        eval (r_universal (m + n)) (p # cs @ xs) =\n        eval (r_universal n) ((the (eval s (p # cs))) # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prim_recfn (Suc m) s \\<and>\n       (\\<forall>p cs xs.\n           length cs = m \\<and> length xs = n \\<longrightarrow>\n           eval (r_universal (m + n)) (p # cs @ xs) =\n           eval (r_universal n) (the (eval s (p # cs)) # xs))", "using smn_lemma exI[of _ \"r_smn n m\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; length ?cs = ?m; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal (?m + ?n)) (?p # ?cs @ ?xs) =\n                    eval (r_universal ?n)\n                     (the (eval (r_smn ?n ?m) (?p # ?cs)) # ?xs)\n  ?P (r_smn n m) \\<Longrightarrow> \\<exists>x. ?P x\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<exists>s.\n       prim_recfn (Suc m) s \\<and>\n       (\\<forall>p cs xs.\n           length cs = m \\<and> length xs = n \\<longrightarrow>\n           eval (r_universal (m + n)) (p # cs @ xs) =\n           eval (r_universal n) (the (eval s (p # cs)) # xs))", "by simp"], ["", "text \\<open>For every numbering, that is, binary partial recursive function,\n$\\psi$ there is a total recursive function $c$ that translates $\\psi$-indices\ninto $\\varphi$-indices.\\<close>"], ["", "lemma numbering_translation:\n  assumes \"recfn 2 psi\"\n  obtains c where\n    \"recfn 1 c\"\n    \"total c\"\n    \"\\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?p = \"encode psi\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define c where \"c = Cn 1 (r_smn 1 1) [r_const ?p, Id 1 0]\""], ["proof (state)\nthis:\n  c = Cn 1 (r_smn 1 1) [r_const (encode psi), recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  c = Cn 1 (r_smn 1 1) [r_const (encode psi), recf.Id 1 0]", "have \"prim_recfn 1 c\""], ["proof (prove)\nusing this:\n  c = Cn 1 (r_smn 1 1) [r_const (encode psi), recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. prim_recfn 1 c", "by simp"], ["proof (state)\nthis:\n  prim_recfn 1 c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  prim_recfn 1 c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from this"], ["proof (chain)\npicking this:\n  prim_recfn 1 c", "have \"total c\""], ["proof (prove)\nusing this:\n  prim_recfn 1 c\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total c", "by auto"], ["proof (state)\nthis:\n  Partial_Recursive.total c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  Partial_Recursive.total c\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"eval r_phi [the (eval c [i]), x] = eval psi [i, x]\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "have \"eval c [i] = eval (r_smn 1 1) [?p, i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval c [i] = eval (r_smn 1 1) [encode psi, i]", "using c_def"], ["proof (prove)\nusing this:\n  c = Cn 1 (r_smn 1 1) [r_const (encode psi), recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. eval c [i] = eval (r_smn 1 1) [encode psi, i]", "by simp"], ["proof (state)\nthis:\n  eval c [i] = eval (r_smn 1 1) [encode psi, i]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "then"], ["proof (chain)\npicking this:\n  eval c [i] = eval (r_smn 1 1) [encode psi, i]", "have \"eval (r_universal 1) [the (eval c [i]), x] =\n        eval (r_universal 1) [the (eval (r_smn 1 1) [?p, i]), x]\""], ["proof (prove)\nusing this:\n  eval c [i] = eval (r_smn 1 1) [encode psi, i]\n\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval c [i]), x] =\n    eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x]", "by simp"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval c [i]), x] =\n  eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "also"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval c [i]), x] =\n  eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "have \"... = eval (r_universal (1 + 1)) (?p # [i] @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x] =\n    eval (r_universal (1 + 1)) (encode psi # [i] @ [x])", "using smn_lemma[of 1 \"[i]\" 1 \"[x]\" ?p]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 1; length [i] = 1; length [x] = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal (1 + 1)) (encode psi # [i] @ [x]) =\n                    eval (r_universal 1)\n                     [the (eval (r_smn 1 1) [encode psi, i]), x]\n\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x] =\n    eval (r_universal (1 + 1)) (encode psi # [i] @ [x])", "by simp"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x] =\n  eval (r_universal (1 + 1)) (encode psi # [i] @ [x])\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "also"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval (r_smn 1 1) [encode psi, i]), x] =\n  eval (r_universal (1 + 1)) (encode psi # [i] @ [x])\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "have \"... = eval (r_universal 2) [?p, i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal (1 + 1)) (encode psi # [i] @ [x]) =\n    eval (r_universal 2) [encode psi, i, x]", "by (metis append_eq_Cons_conv nat_1_add_1)"], ["proof (state)\nthis:\n  eval (r_universal (1 + 1)) (encode psi # [i] @ [x]) =\n  eval (r_universal 2) [encode psi, i, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "also"], ["proof (state)\nthis:\n  eval (r_universal (1 + 1)) (encode psi # [i] @ [x]) =\n  eval (r_universal 2) [encode psi, i, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "have \"... = eval psi [i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 2) [encode psi, i, x] = eval psi [i, x]", "using r_universal[OF assms, of \"[i, x]\"]"], ["proof (prove)\nusing this:\n  length [i, x] = 2 \\<Longrightarrow>\n  eval (r_universal 2) [encode psi, i, x] = eval psi [i, x]\n\ngoal (1 subgoal):\n 1. eval (r_universal 2) [encode psi, i, x] = eval psi [i, x]", "by simp"], ["proof (state)\nthis:\n  eval (r_universal 2) [encode psi, i, x] = eval psi [i, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "finally"], ["proof (chain)\npicking this:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]", "have \"eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]\""], ["proof (prove)\nusing this:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]\n\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]", "."], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "then"], ["proof (chain)\npicking this:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "using r_phi_def"], ["proof (prove)\nusing this:\n  eval (r_universal 1) [the (eval c [i]), x] = eval psi [i, x]\n  r_phi \\<equiv> r_universal 1\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval c [i]), x] = eval psi [i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval c [i]), x] = eval psi [i, x]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_phi [the (eval c [?i]), ?x] = eval psi [?i, ?x]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  prim_recfn 1 c\n  Partial_Recursive.total c\n  eval r_phi [the (eval c [?i]), ?x] = eval psi [?i, ?x]", "show ?thesis"], ["proof (prove)\nusing this:\n  prim_recfn 1 c\n  Partial_Recursive.total c\n  eval r_phi [the (eval c [?i]), ?x] = eval psi [?i, ?x]\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  prim_recfn 1 c\n  Partial_Recursive.total c\n  eval r_phi [the (eval c [?i]), ?x] = eval psi [?i, ?x]\n  \\<lbrakk>recfn 1 ?c; Partial_Recursive.total ?c;\n   \\<forall>i x.\n      eval psi [i, x] = eval r_phi [the (eval ?c [i]), x]\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Fixed-point theorems\\<close>"], ["", "text \\<open>Fixed-point theorems (also known as recursion theorems) come in\nmany shapes. We prove the minimum we need for Chapter~\\ref{c:iirf}.\\<close>"], ["", "subsection \\<open>Rogers's fixed-point theorem\\<close>"], ["", "text \\<open>In this section we prove a theorem that Rogers~\\cite{Rogers87}\ncredits to Kleene, but admits that it is a special case and not the original\nformulation. We follow Wikipedia~\\cite{wiki-krt} and call it the Rogers's\nfixed-point theorem.\\<close>"], ["", "lemma s11_inj: \"inj (\\<lambda>x. smn 1 p [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj (\\<lambda>x. smn 1 p [x])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x\\<^sub>1 x\\<^sub>2 :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume \"smn 1 p [x\\<^sub>1] = smn 1 p [x\\<^sub>2]\""], ["proof (state)\nthis:\n  smn 1 p [x\\<^sub>1] = smn 1 p [x\\<^sub>2]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  smn 1 p [x\\<^sub>1] = smn 1 p [x\\<^sub>2]", "have \"list_encode [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n      list_encode [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\""], ["proof (prove)\nusing this:\n  smn 1 p [x\\<^sub>1] = smn 1 p [x\\<^sub>2]\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode\n     [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n    Partial_Recursive.list_encode\n     [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "using smn_def"], ["proof (prove)\nusing this:\n  smn 1 p [x\\<^sub>1] = smn 1 p [x\\<^sub>2]\n  smn ?n ?p ?cs \\<equiv>\n  quad_encode 3 ?n (encode (r_universal (?n + length ?cs)))\n   (Partial_Recursive.list_encode\n     (code_constn ?n ?p #\n      map (code_constn ?n) ?cs @ map (code_id ?n) [0..<?n]))\n\ngoal (1 subgoal):\n 1. Partial_Recursive.list_encode\n     [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n    Partial_Recursive.list_encode\n     [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "by (simp add: prod_encode_eq)"], ["proof (state)\nthis:\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "have \"[code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n      [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\""], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\n\ngoal (1 subgoal):\n 1. [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n    [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "using list_decode_encode"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  Partial_Recursive.list_encode\n   [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n    [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "by metis"], ["proof (state)\nthis:\n  [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]", "have \"code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2\""], ["proof (prove)\nusing this:\n  [code_constn 1 p, code_constn 1 x\\<^sub>1, code_id 1 0] =\n  [code_constn 1 p, code_constn 1 x\\<^sub>2, code_id 1 0]\n\ngoal (1 subgoal):\n 1. code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV;\n        smn 1 p [x] = smn 1 p [y]\\<rbrakk>\n       \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2", "show \"x\\<^sub>1 = x\\<^sub>2\""], ["proof (prove)\nusing this:\n  code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2\n\ngoal (1 subgoal):\n 1. x\\<^sub>1 = x\\<^sub>2", "using code_const1 code_constn code_constn_def encode_injective r_constn"], ["proof (prove)\nusing this:\n  code_constn 1 x\\<^sub>1 = code_constn 1 x\\<^sub>2\n  code_const1 ?c = encode (r_const ?c)\n  code_constn (Suc ?n) ?c = encode (r_constn ?n ?c)\n  code_constn ?n ?c \\<equiv>\n  if ?n = 1 then code_const1 ?c\n  else quad_encode 3 ?n (code_const1 ?c)\n        (singleton_encode (triple_encode 2 ?n 0))\n  encode ?f = encode ?g \\<Longrightarrow> ?f = ?g\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_constn ?n ?c) ?xs \\<down>= ?c\n\ngoal (1 subgoal):\n 1. x\\<^sub>1 = x\\<^sub>2", "by (metis One_nat_def length_Cons list.size(3) option.simps(1))"], ["proof (state)\nthis:\n  x\\<^sub>1 = x\\<^sub>2\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_univuniv \\<equiv> Cn 2 r_phi [Cn 2 r_phi [Id 2 0, Id 2 0], Id 2 1]\""], ["", "lemma r_univuniv_recfn: \"recfn 2 r_univuniv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_univuniv", "by (simp add: r_univuniv_def)"], ["", "lemma r_univuniv_converg:\n  assumes \"eval r_phi [x, x] \\<down>\"\n  shows \"eval r_univuniv [x, y] = eval r_phi [the (eval r_phi [x, x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univuniv [x, y] = eval r_phi [the (eval r_phi [x, x]), y]", "unfolding r_univuniv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_phi [Cn 2 r_phi [recf.Id 2 0, recf.Id 2 0], recf.Id 2 1])\n     [x, y] =\n    eval r_phi [the (eval r_phi [x, x]), y]", "using assms r_univuniv_recfn r_phi_recfn"], ["proof (prove)\nusing this:\n  eval r_phi [x, x] \\<down>\n  recfn 2 r_univuniv\n  recfn 2 r_phi\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_phi [Cn 2 r_phi [recf.Id 2 0, recf.Id 2 0], recf.Id 2 1])\n     [x, y] =\n    eval r_phi [the (eval r_phi [x, x]), y]", "by simp"], ["", "text \\<open>Strictly speaking this is a generalization of Rogers's theorem in\nthat it shows the existence of infinitely many fixed-points. In conventional\nterms it says that for every total recursive $f$ and $k \\in \\mathbb{N}$ there is\nan $n \\geq k$ with $\\varphi_n = \\varphi_{f(n)}$.\\<close>"], ["", "theorem rogers_fixed_point_theorem:\n  fixes k :: nat\n  assumes \"recfn 1 f\" and \"total f\"\n  shows \"\\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "let ?p = \"encode r_univuniv\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "define h where \"h = Cn 1 (r_smn 1 1) [r_const ?p, Id 1 0]\""], ["proof (state)\nthis:\n  h = Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  h = Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]", "have \"prim_recfn 1 h\""], ["proof (prove)\nusing this:\n  h = Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. prim_recfn 1 h", "by simp"], ["proof (state)\nthis:\n  prim_recfn 1 h\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  prim_recfn 1 h", "have \"total h\""], ["proof (prove)\nusing this:\n  prim_recfn 1 h\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total h", "by blast"], ["proof (state)\nthis:\n  Partial_Recursive.total h\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"eval h [x] = eval (Cn 1 (r_smn 1 1) [r_const ?p, Id 1 0]) [x]\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [x] =\n    eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [x]", "unfolding h_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [x] =\n    eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [x]", "by simp"], ["proof (state)\nthis:\n  eval h [?x] =\n  eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [?x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval h [?x] =\n  eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [?x]", "have h: \"the (eval h [x]) = smn 1 ?p [x]\" for x"], ["proof (prove)\nusing this:\n  eval h [?x] =\n  eval (Cn 1 (r_smn 1 1) [r_const (encode r_univuniv), recf.Id 1 0]) [?x]\n\ngoal (1 subgoal):\n 1. the (eval h [x]) = smn 1 (encode r_univuniv) [x]", "by (simp add: r_smn)"], ["proof (state)\nthis:\n  the (eval h [?x]) = smn 1 (encode r_univuniv) [?x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "have \"eval r_phi [the (eval h [x]), y] = eval r_phi [smn 1 ?p [x], y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] =\n    eval r_phi [smn 1 (encode r_univuniv) [x], y]", "using h"], ["proof (prove)\nusing this:\n  the (eval h [?x]) = smn 1 (encode r_univuniv) [?x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] =\n    eval r_phi [smn 1 (encode r_univuniv) [x], y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [x]), y] =\n  eval r_phi [smn 1 (encode r_univuniv) [x], y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "also"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [x]), y] =\n  eval r_phi [smn 1 (encode r_univuniv) [x], y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "have \"... = eval r_phi [the (eval (r_smn 1 1) [?p, x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [smn 1 (encode r_univuniv) [x], y] =\n    eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y]", "by (simp add: r_smn)"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_univuniv) [x], y] =\n  eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "also"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_univuniv) [x], y] =\n  eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "have \"... = eval (r_universal 2) [?p, x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y] =\n    eval (r_universal 2) [encode r_univuniv, x, y]", "using r_phi_def smn_lemma[of 1 \"[x]\" 1 \"[y]\" ?p]"], ["proof (prove)\nusing this:\n  r_phi \\<equiv> r_universal 1\n  \\<lbrakk>0 < 1; length [x] = 1; length [y] = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal (1 + 1))\n                     (encode r_univuniv # [x] @ [y]) =\n                    eval (r_universal 1)\n                     [the (eval (r_smn 1 1) [encode r_univuniv, x]), y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y] =\n    eval (r_universal 2) [encode r_univuniv, x, y]", "by (metis Cons_eq_append_conv One_nat_def Suc_1 length_Cons\n        less_numeral_extra(1) list.size(3) plus_1_eq_Suc)"], ["proof (state)\nthis:\n  eval r_phi [the (eval (r_smn 1 1) [encode r_univuniv, x]), y] =\n  eval (r_universal 2) [encode r_univuniv, x, y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "finally"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [x]), y] =\n  eval (r_universal 2) [encode r_univuniv, x, y]", "show \"eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]\""], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [x]), y] =\n  eval (r_universal 2) [encode r_univuniv, x, y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "using r_universal r_univuniv_recfn"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [x]), y] =\n  eval (r_universal 2) [encode r_univuniv, x, y]\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n  recfn 2 r_univuniv\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [x]), y] = eval r_univuniv [x, y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [?x]), ?y] = eval r_univuniv [?x, ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [?x]), ?y] = eval r_univuniv [?x, ?y]", "have *: \"eval r_phi [the (eval h [x]), y] = eval r_phi [the (eval r_phi [x, x]), y]\"\n      if \"eval r_phi [x, x] \\<down>\" for x y"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [?x]), ?y] = eval r_univuniv [?x, ?y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] =\n    eval r_phi [the (eval r_phi [x, x]), y]", "using r_univuniv_converg that"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [?x]), ?y] = eval r_univuniv [?x, ?y]\n  eval r_phi [?x, ?x] \\<down> \\<Longrightarrow>\n  eval r_univuniv [?x, ?y] = eval r_phi [the (eval r_phi [?x, ?x]), ?y]\n  eval r_phi [x, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [x]), y] =\n    eval r_phi [the (eval r_phi [x, x]), y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [?x, ?x] \\<down> \\<Longrightarrow>\n  eval r_phi [the (eval h [?x]), ?y] =\n  eval r_phi [the (eval r_phi [?x, ?x]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "let ?fh = \"Cn 1 f [h]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"recfn 1 ?fh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 f [h])", "using \\<open>prim_recfn 1 h\\<close> assms"], ["proof (prove)\nusing this:\n  prim_recfn 1 h\n  recfn 1 f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 f [h])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 f [h])\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  recfn 1 (Cn 1 f [h])", "have \"infinite {r. recfn 1 r \\<and> r \\<simeq> ?fh}\""], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 f [h])\n\ngoal (1 subgoal):\n 1. infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "using exteq_infinite[of ?fh 1]"], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 f [h])\n  recfn 1 (Cn 1 f [h]) \\<Longrightarrow>\n  infinite {g. recfn 1 g \\<and> g \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "by simp"], ["proof (state)\nthis:\n  infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "have \"infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> ?fh})\" (is \"infinite ?E\")"], ["proof (prove)\nusing this:\n  infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})", "using encode_injective"], ["proof (prove)\nusing this:\n  infinite {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n  encode ?f = encode ?g \\<Longrightarrow> ?f = ?g\n\ngoal (1 subgoal):\n 1. infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})", "by (meson finite_imageD inj_onI)"], ["proof (state)\nthis:\n  infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})", "have \"infinite ((\\<lambda>x. smn 1 ?p [x]) ` ?E)\""], ["proof (prove)\nusing this:\n  infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n\ngoal (1 subgoal):\n 1. infinite\n     ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n      encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})", "using s11_inj[of ?p]"], ["proof (prove)\nusing this:\n  infinite (encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n  inj (\\<lambda>x. smn 1 (encode r_univuniv) [x])\n\ngoal (1 subgoal):\n 1. infinite\n     ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n      encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})", "by (simp add: finite_image_iff inj_on_subset)"], ["proof (state)\nthis:\n  infinite\n   ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n    encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "moreover"], ["proof (state)\nthis:\n  infinite\n   ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n    encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"(\\<lambda>x. smn 1 ?p [x]) ` ?E = {smn 1 ?p [encode r] |r. recfn 1 r \\<and> r \\<simeq> ?fh}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n    encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]} =\n    {smn 1 (encode r_univuniv) [encode r] |r.\n     recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n  encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]} =\n  {smn 1 (encode r_univuniv) [encode r] |r.\n   recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "ultimately"], ["proof (chain)\npicking this:\n  infinite\n   ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n    encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n  (\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n  encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]} =\n  {smn 1 (encode r_univuniv) [encode r] |r.\n   recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "have \"infinite {smn 1 ?p [encode r] |r. recfn 1 r \\<and> r \\<simeq> ?fh}\""], ["proof (prove)\nusing this:\n  infinite\n   ((\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n    encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]})\n  (\\<lambda>x. smn 1 (encode r_univuniv) [x]) `\n  encode ` {r. recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]} =\n  {smn 1 (encode r_univuniv) [encode r] |r.\n   recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. infinite\n     {smn 1 (encode r_univuniv) [encode r] |r.\n      recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "by simp"], ["proof (state)\nthis:\n  infinite\n   {smn 1 (encode r_univuniv) [encode r] |r.\n    recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  infinite\n   {smn 1 (encode r_univuniv) [encode r] |r.\n    recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "obtain n where \"n \\<ge> k\" \"n \\<in> {smn 1 ?p [encode r] |r. recfn 1 r \\<and> r \\<simeq> ?fh}\""], ["proof (prove)\nusing this:\n  infinite\n   {smn 1 (encode r_univuniv) [encode r] |r.\n    recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>k \\<le> n;\n         n \\<in> {smn 1 (encode r_univuniv) [encode r] |r.\n                  recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson finite_nat_set_iff_bounded_le le_cases)"], ["proof (state)\nthis:\n  k \\<le> n\n  n \\<in> {smn 1 (encode r_univuniv) [encode r] |r.\n           recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  k \\<le> n\n  n \\<in> {smn 1 (encode r_univuniv) [encode r] |r.\n           recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}", "obtain r where r: \"recfn 1 r\" \"n = smn 1 ?p [encode r]\" \"recfn 1 r \\<and> r \\<simeq> ?fh\""], ["proof (prove)\nusing this:\n  k \\<le> n\n  n \\<in> {smn 1 (encode r_univuniv) [encode r] |r.\n           recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; n = smn 1 (encode r_univuniv) [encode r];\n         recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r\n  n = smn 1 (encode r_univuniv) [encode r]\n  recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  recfn 1 r\n  n = smn 1 (encode r_univuniv) [encode r]\n  recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]", "have eval_r: \"eval r [encode r] = eval ?fh [encode r]\""], ["proof (prove)\nusing this:\n  recfn 1 r\n  n = smn 1 (encode r_univuniv) [encode r]\n  recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]\n\ngoal (1 subgoal):\n 1. eval r [encode r] = eval (Cn 1 f [h]) [encode r]", "by (simp add: exteq_def)"], ["proof (state)\nthis:\n  eval r [encode r] = eval (Cn 1 f [h]) [encode r]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r [encode r] = eval (Cn 1 f [h]) [encode r]", "have eval_r': \"eval r [encode r] = eval f [the (eval h [encode r])]\""], ["proof (prove)\nusing this:\n  eval r [encode r] = eval (Cn 1 f [h]) [encode r]\n\ngoal (1 subgoal):\n 1. eval r [encode r] = eval f [the (eval h [encode r])]", "using assms \\<open>total h\\<close> \\<open>prim_recfn 1 h\\<close>"], ["proof (prove)\nusing this:\n  eval r [encode r] = eval (Cn 1 f [h]) [encode r]\n  recfn 1 f\n  Partial_Recursive.total f\n  Partial_Recursive.total h\n  prim_recfn 1 h\n\ngoal (1 subgoal):\n 1. eval r [encode r] = eval f [the (eval h [encode r])]", "by simp"], ["proof (state)\nthis:\n  eval r [encode r] = eval f [the (eval h [encode r])]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r [encode r] = eval f [the (eval h [encode r])]", "have \"eval r [encode r] \\<down>\""], ["proof (prove)\nusing this:\n  eval r [encode r] = eval f [the (eval h [encode r])]\n\ngoal (1 subgoal):\n 1. eval r [encode r] \\<down>", "using  \\<open>prim_recfn 1 h\\<close> assms(1,2)"], ["proof (prove)\nusing this:\n  eval r [encode r] = eval f [the (eval h [encode r])]\n  prim_recfn 1 h\n  recfn 1 f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. eval r [encode r] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r [encode r] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r [encode r] \\<down>", "have \"eval r_phi [encode r, encode r] \\<down>\""], ["proof (prove)\nusing this:\n  eval r [encode r] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [encode r, encode r] \\<down>", "by (simp add: \\<open>recfn 1 r\\<close> r_phi)"], ["proof (state)\nthis:\n  eval r_phi [encode r, encode r] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r_phi [encode r, encode r] \\<down>", "have \"eval r_phi [the (eval h [encode r]), y] =\n      eval r_phi [(the (eval r_phi [encode r, encode r])), y]\"\n      for y"], ["proof (prove)\nusing this:\n  eval r_phi [encode r, encode r] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [encode r]), y] =\n    eval r_phi [the (eval r_phi [encode r, encode r]), y]", "using *"], ["proof (prove)\nusing this:\n  eval r_phi [encode r, encode r] \\<down>\n  eval r_phi [?x, ?x] \\<down> \\<Longrightarrow>\n  eval r_phi [the (eval h [?x]), ?y] =\n  eval r_phi [the (eval r_phi [?x, ?x]), ?y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [encode r]), y] =\n    eval r_phi [the (eval r_phi [encode r, encode r]), y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r_phi [encode r, encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r_phi [encode r, encode r]), ?y]", "have \"eval r_phi [the (eval h [encode r]), y] =\n      eval r_phi [(the (eval r [encode r])), y]\"\n      for y"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r_phi [encode r, encode r]), ?y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [encode r]), y] =\n    eval r_phi [the (eval r [encode r]), y]", "by (simp add: \\<open>recfn 1 r\\<close> r_phi)"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "moreover"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"n = the (eval h [encode r])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = the (eval h [encode r])", "by (simp add: h r(2))"], ["proof (state)\nthis:\n  n = the (eval h [encode r])\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "ultimately"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r [encode r]), ?y]\n  n = the (eval h [encode r])", "have \"eval r_phi [n, y] = eval r_phi [the (eval r [encode r]), y]\" for y"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [encode r]), ?y] =\n  eval r_phi [the (eval r [encode r]), ?y]\n  n = the (eval h [encode r])\n\ngoal (1 subgoal):\n 1. eval r_phi [n, y] = eval r_phi [the (eval r [encode r]), y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [n, ?y] = eval r_phi [the (eval r [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "then"], ["proof (chain)\npicking this:\n  eval r_phi [n, ?y] = eval r_phi [the (eval r [encode r]), ?y]", "have \"eval r_phi [n, y] = eval r_phi [the (eval ?fh [encode r]), y]\" for y"], ["proof (prove)\nusing this:\n  eval r_phi [n, ?y] = eval r_phi [the (eval r [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. eval r_phi [n, y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), y]", "using r"], ["proof (prove)\nusing this:\n  eval r_phi [n, ?y] = eval r_phi [the (eval r [encode r]), ?y]\n  recfn 1 r\n  n = smn 1 (encode r_univuniv) [encode r]\n  recfn 1 r \\<and> r \\<simeq> Cn 1 f [h]\n\ngoal (1 subgoal):\n 1. eval r_phi [n, y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), y]", "by (simp add: eval_r)"], ["proof (state)\nthis:\n  eval r_phi [n, ?y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "moreover"], ["proof (state)\nthis:\n  eval r_phi [n, ?y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "have \"eval ?fh [encode r] = eval f [n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 f [h]) [encode r] = eval f [n]", "using eval_r eval_r' \\<open>n = the (eval h [encode r])\\<close>"], ["proof (prove)\nusing this:\n  eval r [encode r] = eval (Cn 1 f [h]) [encode r]\n  eval r [encode r] = eval f [the (eval h [encode r])]\n  n = the (eval h [encode r])\n\ngoal (1 subgoal):\n 1. eval (Cn 1 f [h]) [encode r] = eval f [n]", "by auto"], ["proof (state)\nthis:\n  eval (Cn 1 f [h]) [encode r] = eval f [n]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "ultimately"], ["proof (chain)\npicking this:\n  eval r_phi [n, ?y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), ?y]\n  eval (Cn 1 f [h]) [encode r] = eval f [n]", "have \"eval r_phi [n, y] = eval r_phi [the (eval f [n]), y]\" for y"], ["proof (prove)\nusing this:\n  eval r_phi [n, ?y] = eval r_phi [the (eval (Cn 1 f [h]) [encode r]), ?y]\n  eval (Cn 1 f [h]) [encode r] = eval f [n]\n\ngoal (1 subgoal):\n 1. eval r_phi [n, y] = eval r_phi [the (eval f [n]), y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [n, ?y] = eval r_phi [the (eval f [n]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "with \\<open>n \\<ge> k\\<close>"], ["proof (chain)\npicking this:\n  k \\<le> n\n  eval r_phi [n, ?y] = eval r_phi [the (eval f [n]), ?y]", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> n\n  eval r_phi [n, ?y] = eval r_phi [the (eval f [n]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k.\n       \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>k.\n     \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval f [n]), x]\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Kleene's fixed-point theorem\\<close>"], ["", "text \\<open>The next theorem is what Rogers~\\cite[p.~214]{Rogers87} calls\nKleene's version of what we call Rogers's fixed-point theorem. More precisely\nthis would be Kleene's \\emph{second} fixed-point theorem, but since we do not\ncover the first one, we leave out the number.\\<close>"], ["", "theorem kleene_fixed_point_theorem:\n  fixes k :: nat\n  assumes \"recfn 2 psi\"\n  shows \"\\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "from numbering_translation[OF assms]"], ["proof (chain)\npicking this:\n  (\\<And>c.\n      \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n       \\<forall>i x.\n          eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where c:\n    \"recfn 1 c\"\n    \"total c\"\n    \"\\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\""], ["proof (prove)\nusing this:\n  (\\<And>c.\n      \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n       \\<forall>i x.\n          eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 c\n  Partial_Recursive.total c\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "then"], ["proof (chain)\npicking this:\n  recfn 1 c\n  Partial_Recursive.total c\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]", "obtain n where \"n \\<ge> k\" and \"\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]\""], ["proof (prove)\nusing this:\n  recfn 1 c\n  Partial_Recursive.total c\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>k \\<le> n;\n         \\<forall>x.\n            eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rogers_fixed_point_theorem"], ["proof (prove)\nusing this:\n  recfn 1 c\n  Partial_Recursive.total c\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\n  \\<lbrakk>recfn 1 ?f; Partial_Recursive.total ?f\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n\\<ge>?k.\n                       \\<forall>x.\n                          eval r_phi [n, x] =\n                          eval r_phi [the (eval ?f [n]), x]\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<lbrakk>k \\<le> n;\n         \\<forall>x.\n            eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<le> n\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "with c(3)"], ["proof (chain)\npicking this:\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\n  k \\<le> n\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]", "have \"\\<forall>x. eval r_phi [n, x] = eval psi [n, x]\""], ["proof (prove)\nusing this:\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval c [i]), x]\n  k \\<le> n\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval c [n]), x]\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "with \\<open>n \\<ge> k\\<close>"], ["proof (chain)\npicking this:\n  k \\<le> n\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  k \\<le> n\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<ge>k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Kleene's fixed-point theorem can be generalized to arbitrary\narities. But we need to generalize it only to binary functions in order to\nshow Smullyan's double fixed-point theorem in\nSection~\\ref{s:smullyan}.\\<close>"], ["", "definition \"r_univuniv2 \\<equiv>\n  Cn 3 r_phi [Cn 3 (r_universal 2) [Id 3 0, Id 3 0, Id 3 1], Id 3 2]\""], ["", "lemma r_univuniv2_recfn: \"recfn 3 r_univuniv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_univuniv2", "by (simp add: r_univuniv2_def)"], ["", "lemma r_univuniv2_converg:\n  assumes \"eval (r_universal 2) [u, u, x] \\<down>\"\n  shows \"eval r_univuniv2 [u, x, y] = eval r_phi [the (eval (r_universal 2) [u, u, x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univuniv2 [u, x, y] =\n    eval r_phi [the (eval (r_universal 2) [u, u, x]), y]", "unfolding r_univuniv2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_phi\n       [Cn 3 (r_universal 2) [recf.Id 3 0, recf.Id 3 0, recf.Id 3 1],\n        recf.Id 3 2])\n     [u, x, y] =\n    eval r_phi [the (eval (r_universal 2) [u, u, x]), y]", "using assms r_univuniv2_recfn"], ["proof (prove)\nusing this:\n  eval (r_universal 2) [u, u, x] \\<down>\n  recfn 3 r_univuniv2\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_phi\n       [Cn 3 (r_universal 2) [recf.Id 3 0, recf.Id 3 0, recf.Id 3 1],\n        recf.Id 3 2])\n     [u, x, y] =\n    eval r_phi [the (eval (r_universal 2) [u, u, x]), y]", "by simp"], ["", "theorem kleene_fixed_point_theorem_2:\n  assumes \"recfn 2 f\" and \"total f\"\n  shows \"\\<exists>n.\n    recfn 1 n \\<and>\n    total n \\<and>\n    (\\<forall>x y. eval r_phi [(the (eval n [x])), y] = eval r_phi [(the (eval f [the (eval n [x]), x])), y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "let ?p = \"encode r_univuniv2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "let ?s = \"r_smn 1 2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "define h where \"h = Cn 2 ?s [r_dummy 1 (r_const ?p), Id 2 0, Id 2 1]\""], ["proof (state)\nthis:\n  h =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "then"], ["proof (chain)\npicking this:\n  h =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1]", "have [simp]: \"prim_recfn 2 h\""], ["proof (prove)\nusing this:\n  h =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. prim_recfn 2 h", "by simp"], ["proof (state)\nthis:\n  prim_recfn 2 h\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "{"], ["proof (state)\nthis:\n  prim_recfn 2 h\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "fix u x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"eval h [u, x] = eval (Cn 2 ?s [r_dummy 1 (r_const ?p), Id 2 0, Id 2 1]) [u, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [u, x] =\n    eval\n     (Cn 2 (r_smn 1 2)\n       [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1])\n     [u, x]", "using h_def"], ["proof (prove)\nusing this:\n  h =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. eval h [u, x] =\n    eval\n     (Cn 2 (r_smn 1 2)\n       [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1])\n     [u, x]", "by simp"], ["proof (state)\nthis:\n  eval h [u, x] =\n  eval\n   (Cn 2 (r_smn 1 2)\n     [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1])\n   [u, x]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "then"], ["proof (chain)\npicking this:\n  eval h [u, x] =\n  eval\n   (Cn 2 (r_smn 1 2)\n     [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1])\n   [u, x]", "have \"the (eval h [u, x]) = smn 1 ?p [u, x]\""], ["proof (prove)\nusing this:\n  eval h [u, x] =\n  eval\n   (Cn 2 (r_smn 1 2)\n     [r_dummy 1 (r_const (encode r_univuniv2)), recf.Id 2 0, recf.Id 2 1])\n   [u, x]\n\ngoal (1 subgoal):\n 1. the (eval h [u, x]) = smn 1 (encode r_univuniv2) [u, x]", "by (simp add: r_smn)"], ["proof (state)\nthis:\n  the (eval h [u, x]) = smn 1 (encode r_univuniv2) [u, x]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "then"], ["proof (chain)\npicking this:\n  the (eval h [u, x]) = smn 1 (encode r_univuniv2) [u, x]", "have \"eval r_phi [the (eval h [u, x]), y] = eval r_phi [smn 1 ?p [u, x], y]\""], ["proof (prove)\nusing this:\n  the (eval h [u, x]) = smn 1 (encode r_univuniv2) [u, x]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [u, x]), y] =\n    eval r_phi [smn 1 (encode r_univuniv2) [u, x], y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [u, x]), y] =\n  eval r_phi [smn 1 (encode r_univuniv2) [u, x], y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [u, x]), y] =\n  eval r_phi [smn 1 (encode r_univuniv2) [u, x], y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... =\n      eval r_phi\n        [encode (Cn 1 (r_universal 3) (r_constn 0 ?p # r_constn 0 u # r_constn 0 x # [Id 1 0])),\n         y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [smn 1 (encode r_univuniv2) [u, x], y] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n          recf.Id 1 0]),\n      y]", "using smn[of 1 ?p \"[u, x]\"]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  smn 1 (encode r_univuniv2) [u, x] =\n  encode\n   (Cn 1 (r_universal (1 + length [u, x]))\n     (r_constn (1 - 1) (encode r_univuniv2) #\n      map (r_constn (1 - 1)) [u, x] @ map (recf.Id 1) [0..<1]))\n\ngoal (1 subgoal):\n 1. eval r_phi [smn 1 (encode r_univuniv2) [u, x], y] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n          recf.Id 1 0]),\n      y]", "by (simp add: numeral_3_eq_3)"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_univuniv2) [u, x], y] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n        recf.Id 1 0]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_univuniv2) [u, x], y] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n        recf.Id 1 0]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... =\n      eval r_phi\n        [encode (Cn 1 (r_universal 3) (r_const ?p # r_const u # r_const x # [Id 1 0])), y]\"\n        (is \"_ = eval r_phi [encode ?f, y]\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n          recf.Id 1 0]),\n      y] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n      y]", "by (simp add: r_constn_def)"], ["proof (state)\nthis:\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n        recf.Id 1 0]),\n    y] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_constn 0 (encode r_univuniv2), r_constn 0 u, r_constn 0 x,\n        recf.Id 1 0]),\n    y] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... = eval ?f [y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n      y] =\n    eval\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n     [y]", "using r_phi'[of ?f]"], ["proof (prove)\nusing this:\n  recfn 1\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x,\n      recf.Id 1 0]) \\<Longrightarrow>\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n    ?x] =\n  eval\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n   [?x]\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n      y] =\n    eval\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n     [y]", "by auto"], ["proof (state)\nthis:\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n    y] =\n  eval\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n   [y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0]),\n    y] =\n  eval\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n   [y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... = eval (r_universal 3) [?p, u, x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n     [y] =\n    eval (r_universal 3) [encode r_univuniv2, u, x, y]", "using r_univuniv2_recfn r_universal r_phi"], ["proof (prove)\nusing this:\n  recfn 3 r_univuniv2\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n  \\<lbrakk>?i = encode ?f; recfn 1 ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_phi [?i, ?x] = eval ?f [?x]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n     [y] =\n    eval (r_universal 3) [encode r_univuniv2, u, x, y]", "by auto"], ["proof (state)\nthis:\n  eval\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n   [y] =\n  eval (r_universal 3) [encode r_univuniv2, u, x, y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval\n   (Cn 1 (r_universal 3)\n     [r_const (encode r_univuniv2), r_const u, r_const x, recf.Id 1 0])\n   [y] =\n  eval (r_universal 3) [encode r_univuniv2, u, x, y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... = eval r_univuniv2 [u, x, y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 3) [encode r_univuniv2, u, x, y] =\n    eval r_univuniv2 [u, x, y]", "using r_universal"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (r_universal 3) [encode r_univuniv2, u, x, y] =\n    eval r_univuniv2 [u, x, y]", "by (simp add: r_universal r_univuniv2_recfn)"], ["proof (state)\nthis:\n  eval (r_universal 3) [encode r_univuniv2, u, x, y] =\n  eval r_univuniv2 [u, x, y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "finally"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [u, x]), y] = eval r_univuniv2 [u, x, y]", "have \"eval r_phi [the (eval h [u, x]), y] =  eval r_univuniv2 [u, x, y]\""], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [u, x]), y] = eval r_univuniv2 [u, x, y]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [u, x]), y] = eval r_univuniv2 [u, x, y]", "."], ["proof (state)\nthis:\n  eval r_phi [the (eval h [u, x]), y] = eval r_univuniv2 [u, x, y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "}"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [?u2, ?x2]), ?y2] =\n  eval r_univuniv2 [?u2, ?x2, ?y2]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "then"], ["proof (chain)\npicking this:\n  eval r_phi [the (eval h [?u2, ?x2]), ?y2] =\n  eval r_univuniv2 [?u2, ?x2, ?y2]", "have *: \"eval r_phi [the (eval h [u, x]), y] =\n      eval r_phi [the (eval (r_universal 2) [u, u, x]), y]\"\n      if \"eval (r_universal 2) [u, u, x] \\<down>\" for u x y"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [?u2, ?x2]), ?y2] =\n  eval r_univuniv2 [?u2, ?x2, ?y2]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [u, x]), y] =\n    eval r_phi [the (eval (r_universal 2) [u, u, x]), y]", "using r_univuniv2_converg that"], ["proof (prove)\nusing this:\n  eval r_phi [the (eval h [?u2, ?x2]), ?y2] =\n  eval r_univuniv2 [?u2, ?x2, ?y2]\n  eval (r_universal 2) [?u, ?u, ?x] \\<down> \\<Longrightarrow>\n  eval r_univuniv2 [?u, ?x, ?y] =\n  eval r_phi [the (eval (r_universal 2) [?u, ?u, ?x]), ?y]\n  eval (r_universal 2) [u, u, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [u, x]), y] =\n    eval r_phi [the (eval (r_universal 2) [u, u, x]), y]", "by simp"], ["proof (state)\nthis:\n  eval (r_universal 2) [?u, ?u, ?x] \\<down> \\<Longrightarrow>\n  eval r_phi [the (eval h [?u, ?x]), ?y] =\n  eval r_phi [the (eval (r_universal 2) [?u, ?u, ?x]), ?y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "let ?fh = \"Cn 2 f [h, Id 2 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "let ?e = \"encode ?fh\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"recfn 2 ?fh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 f [h, recf.Id 2 1])", "using assms"], ["proof (prove)\nusing this:\n  recfn 2 f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 f [h, recf.Id 2 1])", "by simp"], ["proof (state)\nthis:\n  recfn 2 (Cn 2 f [h, recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"total h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total h", "by auto"], ["proof (state)\nthis:\n  Partial_Recursive.total h\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.total h", "have \"total ?fh\""], ["proof (prove)\nusing this:\n  Partial_Recursive.total h\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1])", "using assms Cn_total totalI2[of ?fh]"], ["proof (prove)\nusing this:\n  Partial_Recursive.total h\n  recfn 2 f\n  Partial_Recursive.total f\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  \\<lbrakk>recfn 2 (Cn 2 f [h, recf.Id 2 1]);\n   \\<And>x y. eval (Cn 2 f [h, recf.Id 2 1]) [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1])", "by fastforce"], ["proof (state)\nthis:\n  Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "let ?n = \"Cn 1 h [r_const ?e, Id 1 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"recfn 1 ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])", "using assms"], ["proof (prove)\nusing this:\n  recfn 2 f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "moreover"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"total ?n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])", "using \\<open>total h\\<close> totalI1[of ?n]"], ["proof (prove)\nusing this:\n  Partial_Recursive.total h\n  \\<lbrakk>recfn 1\n            (Cn 1 h\n              [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0]);\n   \\<And>x.\n      eval\n       (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n       [x] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total\n                     (Cn 1 h\n                       [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                        recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total\n     (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total\n   (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "moreover"], ["proof (state)\nthis:\n  Partial_Recursive.total\n   (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "{"], ["proof (state)\nthis:\n  Partial_Recursive.total\n   (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"eval r_phi [(the (eval ?n [x])), y] = eval r_phi [(the (eval h [?e, x])), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval\n            (Cn 1 h\n              [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n            [x]),\n      y] =\n    eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [x]),\n    y] =\n  eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [x]),\n    y] =\n  eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... = eval r_phi [the (eval (r_universal 2) [?e, ?e, x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y] =\n    eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y]", "using * r_universal[of _ 2] totalE[of ?fh 2] \\<open>total ?fh\\<close> \\<open>recfn 2 ?fh\\<close>"], ["proof (prove)\nusing this:\n  eval (r_universal 2) [?u, ?u, ?x] \\<down> \\<Longrightarrow>\n  eval r_phi [the (eval h [?u, ?x]), ?y] =\n  eval r_phi [the (eval (r_universal 2) [?u, ?u, ?x]), ?y]\n  \\<lbrakk>recfn 2 ?f; length ?xs = 2\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal 2) (encode ?f # ?xs) = eval ?f ?xs\n  \\<lbrakk>Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1]);\n   recfn 2 (Cn 2 f [h, recf.Id 2 1]); length ?xs = 2\\<rbrakk>\n  \\<Longrightarrow> eval (Cn 2 f [h, recf.Id 2 1]) ?xs \\<down>\n  Partial_Recursive.total (Cn 2 f [h, recf.Id 2 1])\n  recfn 2 (Cn 2 f [h, recf.Id 2 1])\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y] =\n    eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y]", "by (metis length_Cons list.size(3) numeral_2_eq_2)"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y] =\n  eval r_phi\n   [the (eval (r_universal 2)\n          [encode (Cn 2 f [h, recf.Id 2 1]),\n           encode (Cn 2 f [h, recf.Id 2 1]), x]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), y] =\n  eval r_phi\n   [the (eval (r_universal 2)\n          [encode (Cn 2 f [h, recf.Id 2 1]),\n           encode (Cn 2 f [h, recf.Id 2 1]), x]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... = eval r_phi [the (eval f [the (eval h [?e, x]), x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "have \"eval (r_universal 2) [?e, ?e, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 2)\n     [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]),\n      x] \\<down>", "using totalE[OF \\<open>total ?fh\\<close>] \\<open>recfn 2 ?fh\\<close> r_universal"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn ?n (Cn 2 f [h, recf.Id 2 1]); length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (Cn 2 f [h, recf.Id 2 1]) ?xs \\<down>\n  recfn 2 (Cn 2 f [h, recf.Id 2 1])\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (r_universal 2)\n     [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]),\n      x] \\<down>", "by (metis length_Cons list.size(3) numeral_2_eq_2)"], ["proof (state)\nthis:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]),\n    x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "moreover"], ["proof (state)\nthis:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]),\n    x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "have \"eval (r_universal 2) [?e, ?e, x] = eval ?fh [?e, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 2)\n     [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]),\n      x] =\n    eval (Cn 2 f [h, recf.Id 2 1]) [encode (Cn 2 f [h, recf.Id 2 1]), x]", "by (metis \\<open>recfn 2 ?fh\\<close> length_Cons list.size(3) numeral_2_eq_2 r_universal)"], ["proof (state)\nthis:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]), x] =\n  eval (Cn 2 f [h, recf.Id 2 1]) [encode (Cn 2 f [h, recf.Id 2 1]), x]\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "then"], ["proof (chain)\npicking this:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]), x] =\n  eval (Cn 2 f [h, recf.Id 2 1]) [encode (Cn 2 f [h, recf.Id 2 1]), x]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]), x] =\n  eval (Cn 2 f [h, recf.Id 2 1]) [encode (Cn 2 f [h, recf.Id 2 1]), x]\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "using assms \\<open>total h\\<close>"], ["proof (prove)\nusing this:\n  eval (r_universal 2)\n   [encode (Cn 2 f [h, recf.Id 2 1]), encode (Cn 2 f [h, recf.Id 2 1]), x] =\n  eval (Cn 2 f [h, recf.Id 2 1]) [encode (Cn 2 f [h, recf.Id 2 1]), x]\n  recfn 2 f\n  Partial_Recursive.total f\n  Partial_Recursive.total h\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval (r_universal 2)\n            [encode (Cn 2 f [h, recf.Id 2 1]),\n             encode (Cn 2 f [h, recf.Id 2 1]), x]),\n      y] =\n    eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval (r_universal 2)\n          [encode (Cn 2 f [h, recf.Id 2 1]),\n           encode (Cn 2 f [h, recf.Id 2 1]), x]),\n    y] =\n  eval r_phi\n   [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]), y]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval (r_universal 2)\n          [encode (Cn 2 f [h, recf.Id 2 1]),\n           encode (Cn 2 f [h, recf.Id 2 1]), x]),\n    y] =\n  eval r_phi\n   [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]), y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "also"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval (r_universal 2)\n          [encode (Cn 2 f [h, recf.Id 2 1]),\n           encode (Cn 2 f [h, recf.Id 2 1]), x]),\n    y] =\n  eval r_phi\n   [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]), y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "have \"... =  eval r_phi [(the (eval f [the (eval ?n [x]), x])), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n      y] =\n    eval r_phi\n     [the (eval f\n            [the (eval\n                   (Cn 1 h\n                     [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                      recf.Id 1 0])\n                   [x]),\n             x]),\n      y]", "by simp"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval f [the (eval h [encode (Cn 2 f [h, recf.Id 2 1]), x]), x]),\n    y] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [x]),\n           x]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "finally"], ["proof (chain)\npicking this:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [x]),\n    y] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [x]),\n           x]),\n    y]", "have \"eval r_phi [(the (eval ?n [x])), y] =\n      eval r_phi [(the (eval f [the (eval ?n [x]), x])), y]\""], ["proof (prove)\nusing this:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [x]),\n    y] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [x]),\n           x]),\n    y]\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [the (eval\n            (Cn 1 h\n              [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n            [x]),\n      y] =\n    eval r_phi\n     [the (eval f\n            [the (eval\n                   (Cn 1 h\n                     [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                      recf.Id 1 0])\n                   [x]),\n             x]),\n      y]", "."], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [x]),\n    y] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [x]),\n           x]),\n    y]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "}"], ["proof (state)\nthis:\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [?x2]),\n    ?y2] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [?x2]),\n           ?x2]),\n    ?y2]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n  Partial_Recursive.total\n   (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [?x2]),\n    ?y2] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [?x2]),\n           ?x2]),\n    ?y2]", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n  Partial_Recursive.total\n   (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n  eval r_phi\n   [the (eval\n          (Cn 1 h [r_const (encode (Cn 2 f [h, recf.Id 2 1])), recf.Id 1 0])\n          [?x2]),\n    ?y2] =\n  eval r_phi\n   [the (eval f\n          [the (eval\n                 (Cn 1 h\n                   [r_const (encode (Cn 2 f [h, recf.Id 2 1])),\n                    recf.Id 1 0])\n                 [?x2]),\n           ?x2]),\n    ?y2]\n\ngoal (1 subgoal):\n 1. \\<exists>n.\n       recfn 1 n \\<and>\n       Partial_Recursive.total n \\<and>\n       (\\<forall>x y.\n           eval r_phi [the (eval n [x]), y] =\n           eval r_phi [the (eval f [the (eval n [x]), x]), y])", "by blast"], ["proof (state)\nthis:\n  \\<exists>n.\n     recfn 1 n \\<and>\n     Partial_Recursive.total n \\<and>\n     (\\<forall>x y.\n         eval r_phi [the (eval n [x]), y] =\n         eval r_phi [the (eval f [the (eval n [x]), x]), y])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Smullyan's double fixed-point theorem\\label{s:smullyan}\\<close>"], ["", "theorem smullyan_double_fixed_point_theorem:\n  assumes \"recfn 2 g\" and \"total g\" and \"recfn 2 h\" and \"total h\"\n  shows \"\\<exists>m n.\n    (\\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n    (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "obtain m where\n    \"recfn 1 m\" and\n    \"total m\" and\n    m: \"\\<forall>x y. eval r_phi [the (eval m [x]), y] =\n      eval r_phi [the (eval g [the (eval m [x]), x]), y]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>recfn 1 m; Partial_Recursive.total m;\n         \\<forall>x y.\n            eval r_phi [the (eval m [x]), y] =\n            eval r_phi [the (eval g [the (eval m [x]), x]), y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using kleene_fixed_point_theorem_2[of g] assms(1,2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn 2 g; Partial_Recursive.total g\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n.\n                       recfn 1 n \\<and>\n                       Partial_Recursive.total n \\<and>\n                       (\\<forall>x y.\n                           eval r_phi [the (eval n [x]), y] =\n                           eval r_phi\n                            [the (eval g [the (eval n [x]), x]), y])\n  recfn 2 g\n  Partial_Recursive.total g\n\ngoal (1 subgoal):\n 1. (\\<And>m.\n        \\<lbrakk>recfn 1 m; Partial_Recursive.total m;\n         \\<forall>x y.\n            eval r_phi [the (eval m [x]), y] =\n            eval r_phi [the (eval g [the (eval m [x]), x]), y]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 m\n  Partial_Recursive.total m\n  \\<forall>x y.\n     eval r_phi [the (eval m [x]), y] =\n     eval r_phi [the (eval g [the (eval m [x]), x]), y]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "define k where \"k = Cn 1 h [m, Id 1 0]\""], ["proof (state)\nthis:\n  k = Cn 1 h [m, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "then"], ["proof (chain)\npicking this:\n  k = Cn 1 h [m, recf.Id 1 0]", "have \"recfn 1 k\""], ["proof (prove)\nusing this:\n  k = Cn 1 h [m, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 k", "using \\<open>recfn 1 m\\<close> assms(3)"], ["proof (prove)\nusing this:\n  k = Cn 1 h [m, recf.Id 1 0]\n  recfn 1 m\n  recfn 2 h\n\ngoal (1 subgoal):\n 1. recfn 1 k", "by simp"], ["proof (state)\nthis:\n  recfn 1 k\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "have \"total (Id 1 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (recf.Id 1 0)", "by (simp add: Mn_free_imp_total)"], ["proof (state)\nthis:\n  Partial_Recursive.total (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.total (recf.Id 1 0)", "have \"total k\""], ["proof (prove)\nusing this:\n  Partial_Recursive.total (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total k", "using \\<open>total m\\<close> assms(4) Cn_total k_def \\<open>recfn 1 k\\<close>"], ["proof (prove)\nusing this:\n  Partial_Recursive.total (recf.Id 1 0)\n  Partial_Recursive.total m\n  Partial_Recursive.total h\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  k = Cn 1 h [m, recf.Id 1 0]\n  recfn 1 k\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total k", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total k\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "obtain n where n: \"\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval k [n]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x.\n           eval r_phi [n, x] =\n           eval r_phi [the (eval k [n]), x] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using rogers_fixed_point_theorem[of k] \\<open>recfn 1 k\\<close> \\<open>total k\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn 1 k; Partial_Recursive.total k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n\\<ge>?k.\n                       \\<forall>x.\n                          eval r_phi [n, x] =\n                          eval r_phi [the (eval k [n]), x]\n  recfn 1 k\n  Partial_Recursive.total k\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x.\n           eval r_phi [n, x] =\n           eval r_phi [the (eval k [n]), x] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval k [n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "obtain mm where mm: \"eval m [n] \\<down>= mm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mm.\n        eval m [n] \\<down>= mm \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>total m\\<close> \\<open>recfn 1 m\\<close>"], ["proof (prove)\nusing this:\n  Partial_Recursive.total m\n  recfn 1 m\n\ngoal (1 subgoal):\n 1. (\\<And>mm.\n        eval m [n] \\<down>= mm \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eval m [n] \\<down>= mm\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "then"], ["proof (chain)\npicking this:\n  eval m [n] \\<down>= mm", "have \"\\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]\""], ["proof (prove)\nusing this:\n  eval m [n] \\<down>= mm\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]", "by (metis m option.sel)"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "moreover"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "have \"\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]", "using k_def assms(3) \\<open>total m\\<close> \\<open>recfn 1 m\\<close> mm n"], ["proof (prove)\nusing this:\n  k = Cn 1 h [m, recf.Id 1 0]\n  recfn 2 h\n  Partial_Recursive.total m\n  recfn 1 m\n  eval m [n] \\<down>= mm\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval k [n]), x]\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [mm, x] = eval r_phi [the (eval g [mm, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [mm, n]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       (\\<forall>x.\n           eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n       (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])", "by blast"], ["proof (state)\nthis:\n  \\<exists>m n.\n     (\\<forall>x.\n         eval r_phi [m, x] = eval r_phi [the (eval g [m, n]), x]) \\<and>\n     (\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval h [m, n]), x])\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Decidable and recursively enumerable sets\\label{s:decidable}\\<close>"], ["", "text \\<open>We defined @{term decidable} already back in\nSection~\\ref{s:halting}: @{thm[display] decidable_def}\\<close>"], ["", "text \\<open>The next theorem is adapted from @{thm[source]\nhalting_problem_undecidable}.\\<close>"], ["", "theorem halting_problem_phi_undecidable: \"\\<not> decidable {x. eval r_phi [x, x] \\<down>}\"\n  (is \"\\<not> decidable ?K\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> decidable {x. eval r_phi [x, x] \\<down>}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "assume \"decidable ?K\""], ["proof (state)\nthis:\n  decidable {x. eval r_phi [x, x] \\<down>}\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  decidable {x. eval r_phi [x, x] \\<down>}", "obtain f where \"recfn 1 f\" and f: \"\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?K then 1 else 0)\""], ["proof (prove)\nusing this:\n  decidable {x. eval r_phi [x, x] \\<down>}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>=\n            (if x \\<in> {x. eval r_phi [x, x] \\<down>} then 1\n             else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decidable_def"], ["proof (prove)\nusing this:\n  decidable {x. eval r_phi [x, x] \\<down>}\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>=\n            (if x \\<in> {x. eval r_phi [x, x] \\<down>} then 1\n             else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x.\n     eval f [x] \\<down>=\n     (if x \\<in> {x. eval r_phi [x, x] \\<down>} then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "define g where \"g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\""], ["proof (state)\nthis:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. recfn 1 g", "using \\<open>recfn 1 f\\<close> r_ifeq_else_diverg_recfn"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n  recfn 1 f\n  recfn 3 r_ifeq_else_diverg\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by simp"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  recfn 1 g", "obtain i where i: \"eval r_phi [i, x] = eval g [x]\" for x"], ["proof (prove)\nusing this:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (\\<And>x. eval r_phi [i, x] = eval g [x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_phi'"], ["proof (prove)\nusing this:\n  recfn 1 g\n  recfn 1 ?f \\<Longrightarrow> eval r_phi [encode ?f, ?x] = eval ?f [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (\\<And>x. eval r_phi [i, x] = eval g [x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_phi [i, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "from g_def"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]", "have \"eval g [x] = (if x \\<notin> ?K then Some 0 else None)\" for x"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n\ngoal (1 subgoal):\n 1. eval g [x] =\n    (if x \\<notin> {x. eval r_phi [x, x] \\<down>} then Some 0 else None)", "using r_ifeq_else_diverg_recfn \\<open>recfn 1 f\\<close> f"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_ifeq_else_diverg [f, Z, Z]\n  recfn 3 r_ifeq_else_diverg\n  recfn 1 f\n  \\<forall>x.\n     eval f [x] \\<down>=\n     (if x \\<in> {x. eval r_phi [x, x] \\<down>} then 1 else 0)\n\ngoal (1 subgoal):\n 1. eval g [x] =\n    (if x \\<notin> {x. eval r_phi [x, x] \\<down>} then Some 0 else None)", "by simp"], ["proof (state)\nthis:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval r_phi [x, x] \\<down>} then Some 0 else None)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval r_phi [x, x] \\<down>} then Some 0 else None)", "have \"eval g [i] \\<down> \\<longleftrightarrow> i \\<notin> ?K\""], ["proof (prove)\nusing this:\n  eval g [?x] =\n  (if ?x \\<notin> {x. eval r_phi [x, x] \\<down>} then Some 0 else None)\n\ngoal (1 subgoal):\n 1. (eval g [i] \\<down>) = (i \\<notin> {x. eval r_phi [x, x] \\<down>})", "by simp"], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (i \\<notin> {x. eval r_phi [x, x] \\<down>})\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (i \\<notin> {x. eval r_phi [x, x] \\<down>})\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "have \"... \\<longleftrightarrow> eval r_phi [i, i] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i \\<notin> {x. eval r_phi [x, x] \\<down>}) = (eval r_phi [i, i] \\<up>)", "by simp"], ["proof (state)\nthis:\n  (i \\<notin> {x. eval r_phi [x, x] \\<down>}) = (eval r_phi [i, i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (i \\<notin> {x. eval r_phi [x, x] \\<down>}) = (eval r_phi [i, i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "have \"... \\<longleftrightarrow> eval g [i] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval r_phi [i, i] \\<up>) = (eval g [i] \\<up>)", "using i"], ["proof (prove)\nusing this:\n  eval r_phi [i, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. (eval r_phi [i, i] \\<up>) = (eval g [i] \\<up>)", "by simp"], ["proof (state)\nthis:\n  (eval r_phi [i, i] \\<up>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)", "have \"eval g [i] \\<down> \\<longleftrightarrow> eval g [i] \\<up>\""], ["proof (prove)\nusing this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. (eval g [i] \\<down>) = (eval g [i] \\<up>)", "."], ["proof (state)\nthis:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. decidable {x. eval r_phi [x, x] \\<down>} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)", "show False"], ["proof (prove)\nusing this:\n  (eval g [i] \\<down>) = (eval g [i] \\<up>)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decidable_complement: \"decidable X \\<Longrightarrow> decidable (- X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "assume \"decidable X\""], ["proof (state)\nthis:\n  decidable X\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "then"], ["proof (chain)\npicking this:\n  decidable X", "obtain f where f: \"recfn 1 f\" \"\\<forall>x. eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\""], ["proof (prove)\nusing this:\n  decidable X\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decidable_def"], ["proof (prove)\nusing this:\n  decidable X\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x. eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "define g where \"g = Cn 1 r_not [f]\""], ["proof (state)\nthis:\n  g = Cn 1 r_not [f]\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "then"], ["proof (chain)\npicking this:\n  g = Cn 1 r_not [f]", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g = Cn 1 r_not [f]\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by (simp add: f(1))"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "moreover"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "have \"eval g [x] \\<down>= (if x \\<in> X then 0 else 1)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [x] \\<down>= (if x \\<in> X then 0 else 1)", "by (simp add: g_def f)"], ["proof (state)\nthis:\n  eval g [?x] \\<down>= (if ?x \\<in> X then 0 else 1)\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> decidable (- X)", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 g\n  eval g [?x] \\<down>= (if ?x \\<in> X then 0 else 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 g\n  eval g [?x] \\<down>= (if ?x \\<in> X then 0 else 1)\n\ngoal (1 subgoal):\n 1. decidable (- X)", "using decidable_def"], ["proof (prove)\nusing this:\n  recfn 1 g\n  eval g [?x] \\<down>= (if ?x \\<in> X then 0 else 1)\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. decidable (- X)", "by auto"], ["proof (state)\nthis:\n  decidable (- X)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finite sets are decidable.\\<close>"], ["", "fun r_contains :: \"nat list \\<Rightarrow> recf\" where\n  \"r_contains [] = Z\"\n| \"r_contains (x # xs) = Cn 1 r_ifeq [Id 1 0, r_const x, r_const 1, r_contains xs]\""], ["", "lemma r_contains_prim: \"prim_recfn 1 (r_contains xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (r_contains xs)", "by (induction xs) auto"], ["", "lemma r_contains: \"eval (r_contains xs) [x] \\<down>= (if x \\<in> set xs then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_contains xs) [x] \\<down>= (if x \\<in> set xs then 1 else 0)", "proof (induction xs arbitrary: x)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       eval (r_contains []) [x] \\<down>= (if x \\<in> set [] then 1 else 0)\n 2. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>x.\n       eval (r_contains []) [x] \\<down>= (if x \\<in> set [] then 1 else 0)\n 2. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_contains []) [x] \\<down>= (if x \\<in> set [] then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  eval (r_contains []) [x] \\<down>= (if x \\<in> set [] then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "case (Cons a xs)"], ["proof (state)\nthis:\n  eval (r_contains xs) [?x] \\<down>= (if ?x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "have \"eval (r_contains (a # xs)) [x] = eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_contains (a # xs)) [x] =\n    eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])]", "using r_contains_prim prim_recfn_total"], ["proof (prove)\nusing this:\n  prim_recfn 1 (r_contains ?xs)\n  prim_recfn ?n ?f \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. eval (r_contains (a # xs)) [x] =\n    eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])]", "by simp"], ["proof (state)\nthis:\n  eval (r_contains (a # xs)) [x] =\n  eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])]\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "also"], ["proof (state)\nthis:\n  eval (r_contains (a # xs)) [x] =\n  eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])]\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "have \"... \\<down>= (if x = a then 1 else if x \\<in> set xs then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])] \\<down>=\n    (if x = a then 1 else if x \\<in> set xs then 1 else 0)", "using Cons.IH"], ["proof (prove)\nusing this:\n  eval (r_contains xs) [?x] \\<down>= (if ?x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])] \\<down>=\n    (if x = a then 1 else if x \\<in> set xs then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])] \\<down>=\n  (if x = a then 1 else if x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "also"], ["proof (state)\nthis:\n  eval r_ifeq [x, a, 1, the (eval (r_contains xs) [x])] \\<down>=\n  (if x = a then 1 else if x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "have \"... \\<down>= (if x = a \\<or> x \\<in> set xs then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (if x = a then 1 else if x \\<in> set xs then 1 else 0) \\<down>=\n    (if x = a \\<or> x \\<in> set xs then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  Some (if x = a then 1 else if x \\<in> set xs then 1 else 0) \\<down>=\n  (if x = a \\<or> x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<And>a xs x.\n       (\\<And>x.\n           eval (r_contains xs) [x] \\<down>=\n           (if x \\<in> set xs then 1 else 0)) \\<Longrightarrow>\n       eval (r_contains (a # xs)) [x] \\<down>=\n       (if x \\<in> set (a # xs) then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  eval (r_contains (a # xs)) [x] \\<down>=\n  (if x = a \\<or> x \\<in> set xs then 1 else 0)", "show ?case"], ["proof (prove)\nusing this:\n  eval (r_contains (a # xs)) [x] \\<down>=\n  (if x = a \\<or> x \\<in> set xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. eval (r_contains (a # xs)) [x] \\<down>=\n    (if x \\<in> set (a # xs) then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  eval (r_contains (a # xs)) [x] \\<down>=\n  (if x \\<in> set (a # xs) then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma finite_set_decidable: \"finite X \\<Longrightarrow> decidable X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "fix X :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "assume \"finite X\""], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "then"], ["proof (chain)\npicking this:\n  finite X", "obtain xs where \"X = set xs\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. (\\<And>xs. X = set xs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using finite_list"], ["proof (prove)\nusing this:\n  finite X\n  finite ?A \\<Longrightarrow> \\<exists>xs. set xs = ?A\n\ngoal (1 subgoal):\n 1. (\\<And>xs. X = set xs \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  X = set xs\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "then"], ["proof (chain)\npicking this:\n  X = set xs", "have \"\\<forall>x. eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)\""], ["proof (prove)\nusing this:\n  X = set xs\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)", "using r_contains"], ["proof (prove)\nusing this:\n  X = set xs\n  eval (r_contains ?xs) [?x] \\<down>= (if ?x \\<in> set ?xs then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. finite X \\<Longrightarrow> decidable X", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)", "show \"decidable X\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable X", "using decidable_def r_contains_prim"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (r_contains xs) [x] \\<down>= (if x \\<in> X then 1 else 0)\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n  prim_recfn 1 (r_contains ?xs)\n\ngoal (1 subgoal):\n 1. decidable X", "by blast"], ["proof (state)\nthis:\n  decidable X\n\ngoal:\nNo subgoals!", "qed"], ["", "definition semidecidable :: \"nat set \\<Rightarrow> bool\" where\n  \"semidecidable X \\<equiv> (\\<exists>f. recfn 1 f \\<and> (\\<forall>x. eval f [x] = (if x \\<in> X then Some 1 else None)))\""], ["", "text \\<open>The semidecidable sets are the domains of partial recursive functions.\\<close>"], ["", "lemma semidecidable_iff_domain:\n  \"semidecidable X \\<longleftrightarrow> (\\<exists>f. recfn 1 f \\<and> (\\<forall>x. eval f [x] \\<down> \\<longleftrightarrow> x \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semidecidable X =\n    (\\<exists>f.\n        recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. semidecidable X \\<Longrightarrow>\n    \\<exists>f.\n       recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n 2. \\<exists>f.\n       recfn 1 f \\<and>\n       (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)) \\<Longrightarrow>\n    semidecidable X", "show \"semidecidable X \\<Longrightarrow> \\<exists>f. recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semidecidable X \\<Longrightarrow>\n    \\<exists>f.\n       recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))", "using semidecidable_def"], ["proof (prove)\nusing this:\n  semidecidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] = (if x \\<in> ?X then Some 1 else None))\n\ngoal (1 subgoal):\n 1. semidecidable X \\<Longrightarrow>\n    \\<exists>f.\n       recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))", "by (metis option.distinct(1))"], ["proof (state)\nthis:\n  semidecidable X \\<Longrightarrow>\n  \\<exists>f.\n     recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       recfn 1 f \\<and>\n       (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)) \\<Longrightarrow>\n    semidecidable X", "show \"semidecidable X\" if \"\\<exists>f. recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. semidecidable X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. semidecidable X", "from that"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))", "obtain f where f: \"recfn 1 f\" \"\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n\ngoal (1 subgoal):\n 1. semidecidable X", "let ?g = \"Cn 1 (r_const 1) [f]\""], ["proof (state)\ngoal (1 subgoal):\n 1. semidecidable X", "have \"recfn 1 ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 (r_const 1) [f])", "using f(1)"], ["proof (prove)\nusing this:\n  recfn 1 f\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 (r_const 1) [f])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 (r_const 1) [f])\n\ngoal (1 subgoal):\n 1. semidecidable X", "moreover"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 (r_const 1) [f])\n\ngoal (1 subgoal):\n 1. semidecidable X", "have \"\\<forall>x. eval ?g [x] = (if x \\<in> X then Some 1 else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       eval (Cn 1 (r_const 1) [f]) [x] =\n       (if x \\<in> X then Some 1 else None)", "using f"], ["proof (prove)\nusing this:\n  recfn 1 f\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       eval (Cn 1 (r_const 1) [f]) [x] =\n       (if x \\<in> X then Some 1 else None)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x.\n     eval (Cn 1 (r_const 1) [f]) [x] = (if x \\<in> X then Some 1 else None)\n\ngoal (1 subgoal):\n 1. semidecidable X", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 (Cn 1 (r_const 1) [f])\n  \\<forall>x.\n     eval (Cn 1 (r_const 1) [f]) [x] = (if x \\<in> X then Some 1 else None)", "show \"semidecidable X\""], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 (r_const 1) [f])\n  \\<forall>x.\n     eval (Cn 1 (r_const 1) [f]) [x] = (if x \\<in> X then Some 1 else None)\n\ngoal (1 subgoal):\n 1. semidecidable X", "using semidecidable_def"], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 (r_const 1) [f])\n  \\<forall>x.\n     eval (Cn 1 (r_const 1) [f]) [x] = (if x \\<in> X then Some 1 else None)\n  semidecidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] = (if x \\<in> ?X then Some 1 else None))\n\ngoal (1 subgoal):\n 1. semidecidable X", "by blast"], ["proof (state)\nthis:\n  semidecidable X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)) \\<Longrightarrow>\n  semidecidable ?X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decidable_imp_semidecidable: \"decidable X \\<Longrightarrow> semidecidable X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "assume \"decidable X\""], ["proof (state)\nthis:\n  decidable X\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  decidable X", "obtain f where f: \"recfn 1 f\" \"\\<forall>x. eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\""], ["proof (prove)\nusing this:\n  decidable X\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decidable_def"], ["proof (prove)\nusing this:\n  decidable X\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x.\n            eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x. eval f [x] \\<down>= (if x \\<in> X then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "define g where \"g = Cn 1 r_ifeq_else_diverg [f, r_const 1, r_const 1]\""], ["proof (state)\nthis:\n  g = Cn 1 r_ifeq_else_diverg [f, r_const 1, r_const 1]\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  g = Cn 1 r_ifeq_else_diverg [f, r_const 1, r_const 1]", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g = Cn 1 r_ifeq_else_diverg [f, r_const 1, r_const 1]\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by (simp add: f(1))"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "have \"eval g [x] = eval r_ifeq_else_diverg [if x \\<in> X then 1 else 0, 1, 1]\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [x] = eval r_ifeq_else_diverg [if x \\<in> X then 1 else 0, 1, 1]", "by (simp add: g_def f)"], ["proof (state)\nthis:\n  eval g [?x] = eval r_ifeq_else_diverg [if ?x \\<in> X then 1 else 0, 1, 1]\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  eval g [?x] = eval r_ifeq_else_diverg [if ?x \\<in> X then 1 else 0, 1, 1]", "have \"\\<And>x. x \\<in> X \\<Longrightarrow> eval g [x] \\<down>= 1\" and \"\\<And>x. x \\<notin> X \\<Longrightarrow> eval g [x] \\<up>\""], ["proof (prove)\nusing this:\n  eval g [?x] = eval r_ifeq_else_diverg [if ?x \\<in> X then 1 else 0, 1, 1]\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> X \\<Longrightarrow> eval g [x] \\<down>= 1) &&&\n    (\\<And>x. x \\<notin> X \\<Longrightarrow> eval g [x] \\<up>)", "by simp_all"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> eval g [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval g [?x] \\<up>\n\ngoal (1 subgoal):\n 1. decidable X \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> eval g [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval g [?x] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> eval g [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval g [?x] \\<up>\n\ngoal (1 subgoal):\n 1. semidecidable X", "using \\<open>recfn 1 g\\<close> semidecidable_def"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> eval g [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval g [?x] \\<up>\n  recfn 1 g\n  semidecidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] = (if x \\<in> ?X then Some 1 else None))\n\ngoal (1 subgoal):\n 1. semidecidable X", "by auto"], ["proof (state)\nthis:\n  semidecidable X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A set is recursively enumerable if it is empty or the image of a\ntotal recursive function.\\<close>"], ["", "definition recursively_enumerable :: \"nat set \\<Rightarrow> bool\" where\n  \"recursively_enumerable X \\<equiv>\n     X = {} \\<or> (\\<exists>f. recfn 1 f \\<and> total f \\<and> X = {the (eval f [x]) |x. x \\<in> UNIV})\""], ["", "theorem recursively_enumerable_iff_semidecidable:\n  \"recursively_enumerable X \\<longleftrightarrow> semidecidable X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recursively_enumerable X = semidecidable X", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. recursively_enumerable X \\<Longrightarrow> semidecidable X\n 2. semidecidable X \\<Longrightarrow> recursively_enumerable X", "show \"semidecidable X\" if \"recursively_enumerable X\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. semidecidable X", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> semidecidable X\n 2. \\<not> ?P \\<Longrightarrow> semidecidable X", "assume \"X = {}\""], ["proof (state)\nthis:\n  X = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> semidecidable X\n 2. \\<not> ?P \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  X = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  X = {}\n\ngoal (1 subgoal):\n 1. semidecidable X", "using finite_set_decidable decidable_imp_semidecidable\n        recursively_enumerable_def semidecidable_def"], ["proof (prove)\nusing this:\n  X = {}\n  finite ?X \\<Longrightarrow> decidable ?X\n  decidable ?X \\<Longrightarrow> semidecidable ?X\n  recursively_enumerable ?X \\<equiv>\n  ?X = {} \\<or>\n  (\\<exists>f.\n      recfn 1 f \\<and>\n      Partial_Recursive.total f \\<and>\n      ?X = {the (eval f [x]) |x. x \\<in> UNIV})\n  semidecidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] = (if x \\<in> ?X then Some 1 else None))\n\ngoal (1 subgoal):\n 1. semidecidable X", "by blast"], ["proof (state)\nthis:\n  semidecidable X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "assume \"X \\<noteq> {}\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "with that"], ["proof (chain)\npicking this:\n  recursively_enumerable X\n  X \\<noteq> {}", "obtain f where f: \"recfn 1 f\" \"total f\" \"X = {the (eval f [x]) |x. x \\<in> UNIV}\""], ["proof (prove)\nusing this:\n  recursively_enumerable X\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f; Partial_Recursive.total f;\n         X = {the (eval f [x]) |x. x \\<in> UNIV}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using recursively_enumerable_def"], ["proof (prove)\nusing this:\n  recursively_enumerable X\n  X \\<noteq> {}\n  recursively_enumerable ?X \\<equiv>\n  ?X = {} \\<or>\n  (\\<exists>f.\n      recfn 1 f \\<and>\n      Partial_Recursive.total f \\<and>\n      ?X = {the (eval f [x]) |x. x \\<in> UNIV})\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f; Partial_Recursive.total f;\n         X = {the (eval f [x]) |x. x \\<in> UNIV}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 1 f\n  Partial_Recursive.total f\n  X = {the (eval f [x]) |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "define h where \"h = Cn 2 r_eq [Cn 2 f [Id 2 0], Id 2 1]\""], ["proof (state)\nthis:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]", "have \"recfn 2 h\""], ["proof (prove)\nusing this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. recfn 2 h", "using f(1)"], ["proof (prove)\nusing this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n  recfn 1 f\n\ngoal (1 subgoal):\n 1. recfn 2 h", "by simp"], ["proof (state)\nthis:\n  recfn 2 h\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "from h_def"], ["proof (chain)\npicking this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]", "have h: \"eval h [x, y] \\<down>= 0 \\<longleftrightarrow> the (eval f [x]) = y\" for x y"], ["proof (prove)\nusing this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. (eval h [x, y] \\<down>= 0) = (the (eval f [x]) = y)", "using f(1,2)"], ["proof (prove)\nusing this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n  recfn 1 f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. (eval h [x, y] \\<down>= 0) = (the (eval f [x]) = y)", "by simp"], ["proof (state)\nthis:\n  (eval h [?x, ?y] \\<down>= 0) = (the (eval f [?x]) = ?y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "from h_def \\<open>recfn 2 h\\<close> totalI2 f(2)"], ["proof (chain)\npicking this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n  recfn 2 h\n  \\<lbrakk>recfn 2 ?f; \\<And>x y. eval ?f [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  Partial_Recursive.total f", "have \"total h\""], ["proof (prove)\nusing this:\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n  recfn 2 h\n  \\<lbrakk>recfn 2 ?f; \\<And>x y. eval ?f [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total h", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total h\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "define g where \"g = Mn 1 h\""], ["proof (state)\nthis:\n  g = Mn 1 h\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  g = Mn 1 h", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g = Mn 1 h\n\ngoal (1 subgoal):\n 1. recfn 1 g", "using h_def f(1)"], ["proof (prove)\nusing this:\n  g = Mn 1 h\n  h = Cn 2 r_eq [Cn 2 f [recf.Id 2 0], recf.Id 2 1]\n  recfn 1 f\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by simp"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  recfn 1 g", "have \"eval g [y] =\n      (if (\\<exists>x. eval h [x, y] \\<down>= 0 \\<and> (\\<forall>x'<x. eval h [x', y] \\<down>))\n       then Some (LEAST x. eval h [x, y] \\<down>= 0)\n       else None)\" for y"], ["proof (prove)\nusing this:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. eval g [y] =\n    (if \\<exists>x.\n           eval h [x, y] \\<down>= 0 \\<and>\n           (\\<forall>x'<x. eval h [x', y] \\<down>)\n     then Some (LEAST x. eval h [x, y] \\<down>= 0) else None)", "using g_def \\<open>total h\\<close> f(2)"], ["proof (prove)\nusing this:\n  recfn 1 g\n  g = Mn 1 h\n  Partial_Recursive.total h\n  Partial_Recursive.total f\n\ngoal (1 subgoal):\n 1. eval g [y] =\n    (if \\<exists>x.\n           eval h [x, y] \\<down>= 0 \\<and>\n           (\\<forall>x'<x. eval h [x', y] \\<down>)\n     then Some (LEAST x. eval h [x, y] \\<down>= 0) else None)", "by simp"], ["proof (state)\nthis:\n  eval g [?y] =\n  (if \\<exists>x.\n         eval h [x, ?y] \\<down>= 0 \\<and>\n         (\\<forall>x'<x. eval h [x', ?y] \\<down>)\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  eval g [?y] =\n  (if \\<exists>x.\n         eval h [x, ?y] \\<down>= 0 \\<and>\n         (\\<forall>x'<x. eval h [x', ?y] \\<down>)\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)", "have \"eval g [y] =\n      (if \\<exists>x. eval h [x, y] \\<down>= 0\n       then Some (LEAST x. eval h [x, y] \\<down>= 0)\n       else None)\" for y"], ["proof (prove)\nusing this:\n  eval g [?y] =\n  (if \\<exists>x.\n         eval h [x, ?y] \\<down>= 0 \\<and>\n         (\\<forall>x'<x. eval h [x', ?y] \\<down>)\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. eval g [y] =\n    (if \\<exists>x. eval h [x, y] \\<down>= 0\n     then Some (LEAST x. eval h [x, y] \\<down>= 0) else None)", "using \\<open>total h\\<close> \\<open>recfn 2 h\\<close>"], ["proof (prove)\nusing this:\n  eval g [?y] =\n  (if \\<exists>x.\n         eval h [x, ?y] \\<down>= 0 \\<and>\n         (\\<forall>x'<x. eval h [x', ?y] \\<down>)\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)\n  Partial_Recursive.total h\n  recfn 2 h\n\ngoal (1 subgoal):\n 1. eval g [y] =\n    (if \\<exists>x. eval h [x, y] \\<down>= 0\n     then Some (LEAST x. eval h [x, y] \\<down>= 0) else None)", "by simp"], ["proof (state)\nthis:\n  eval g [?y] =\n  (if \\<exists>x. eval h [x, ?y] \\<down>= 0\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "then"], ["proof (chain)\npicking this:\n  eval g [?y] =\n  (if \\<exists>x. eval h [x, ?y] \\<down>= 0\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)", "have \"eval g [y] \\<down> \\<longleftrightarrow> (\\<exists>x. eval h [x, y] \\<down>= 0)\" for y"], ["proof (prove)\nusing this:\n  eval g [?y] =\n  (if \\<exists>x. eval h [x, ?y] \\<down>= 0\n   then Some (LEAST x. eval h [x, ?y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. (eval g [y] \\<down>) = (\\<exists>x. eval h [x, y] \\<down>= 0)", "by simp"], ["proof (state)\nthis:\n  (eval g [?y] \\<down>) = (\\<exists>x. eval h [x, ?y] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "with h"], ["proof (chain)\npicking this:\n  (eval h [?x, ?y] \\<down>= 0) = (the (eval f [?x]) = ?y)\n  (eval g [?y] \\<down>) = (\\<exists>x. eval h [x, ?y] \\<down>= 0)", "have \"eval g [y] \\<down> \\<longleftrightarrow> (\\<exists>x. the (eval f [x]) = y)\" for y"], ["proof (prove)\nusing this:\n  (eval h [?x, ?y] \\<down>= 0) = (the (eval f [?x]) = ?y)\n  (eval g [?y] \\<down>) = (\\<exists>x. eval h [x, ?y] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. (eval g [y] \\<down>) = (\\<exists>x. the (eval f [x]) = y)", "by simp"], ["proof (state)\nthis:\n  (eval g [?y] \\<down>) = (\\<exists>x. the (eval f [x]) = ?y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "with f(3)"], ["proof (chain)\npicking this:\n  X = {the (eval f [x]) |x. x \\<in> UNIV}\n  (eval g [?y] \\<down>) = (\\<exists>x. the (eval f [x]) = ?y)", "have \"eval g [y] \\<down> \\<longleftrightarrow> y \\<in> X\" for y"], ["proof (prove)\nusing this:\n  X = {the (eval f [x]) |x. x \\<in> UNIV}\n  (eval g [?y] \\<down>) = (\\<exists>x. the (eval f [x]) = ?y)\n\ngoal (1 subgoal):\n 1. (eval g [y] \\<down>) = (y \\<in> X)", "by auto"], ["proof (state)\nthis:\n  (eval g [?y] \\<down>) = (?y \\<in> X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> semidecidable X", "with \\<open>recfn 1 g\\<close> semidecidable_iff_domain"], ["proof (chain)\npicking this:\n  recfn 1 g\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))\n  (eval g [?y] \\<down>) = (?y \\<in> X)", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 g\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))\n  (eval g [?y] \\<down>) = (?y \\<in> X)\n\ngoal (1 subgoal):\n 1. semidecidable X", "by auto"], ["proof (state)\nthis:\n  semidecidable X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  recursively_enumerable ?X \\<Longrightarrow> semidecidable ?X\n\ngoal (1 subgoal):\n 1. semidecidable X \\<Longrightarrow> recursively_enumerable X", "show \"recursively_enumerable X\" if \"semidecidable X\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. recursively_enumerable X", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> recursively_enumerable X\n 2. \\<not> ?P \\<Longrightarrow> recursively_enumerable X", "assume \"X = {}\""], ["proof (state)\nthis:\n  X = {}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> recursively_enumerable X\n 2. \\<not> ?P \\<Longrightarrow> recursively_enumerable X", "then"], ["proof (chain)\npicking this:\n  X = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  X = {}\n\ngoal (1 subgoal):\n 1. recursively_enumerable X", "using recursively_enumerable_def"], ["proof (prove)\nusing this:\n  X = {}\n  recursively_enumerable ?X \\<equiv>\n  ?X = {} \\<or>\n  (\\<exists>f.\n      recfn 1 f \\<and>\n      Partial_Recursive.total f \\<and>\n      ?X = {the (eval f [x]) |x. x \\<in> UNIV})\n\ngoal (1 subgoal):\n 1. recursively_enumerable X", "by simp"], ["proof (state)\nthis:\n  recursively_enumerable X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "assume \"X \\<noteq> {}\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "then"], ["proof (chain)\npicking this:\n  X \\<noteq> {}", "obtain x\\<^sub>0 where \"x\\<^sub>0 \\<in> X\""], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x\\<^sub>0.\n        x\\<^sub>0 \\<in> X \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  x\\<^sub>0 \\<in> X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "from that semidecidable_iff_domain"], ["proof (chain)\npicking this:\n  semidecidable X\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))", "obtain f where f: \"recfn 1 f\" \"\\<forall>x. eval f [x] \\<down> \\<longleftrightarrow> x \\<in> X\""], ["proof (prove)\nusing this:\n  semidecidable X\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>recfn 1 f;\n         \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "let ?i = \"encode f\""], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "have i: \"\\<And>x. eval f [x] = eval r_phi [?i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. eval f [x] = eval r_phi [encode f, x]", "using r_phi' f(1)"], ["proof (prove)\nusing this:\n  recfn 1 ?f \\<Longrightarrow> eval r_phi [encode ?f, ?x] = eval ?f [?x]\n  recfn 1 f\n\ngoal (1 subgoal):\n 1. \\<And>x. eval f [x] = eval r_phi [encode f, x]", "by simp"], ["proof (state)\nthis:\n  eval f [?x] = eval r_phi [encode f, ?x]\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "with \\<open>x\\<^sub>0 \\<in> X\\<close> f(2)"], ["proof (chain)\npicking this:\n  x\\<^sub>0 \\<in> X\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n  eval f [?x] = eval r_phi [encode f, ?x]", "have \"eval r_phi [?i, x\\<^sub>0] \\<down>\""], ["proof (prove)\nusing this:\n  x\\<^sub>0 \\<in> X\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n  eval f [?x] = eval r_phi [encode f, ?x]\n\ngoal (1 subgoal):\n 1. eval r_phi [encode f, x\\<^sub>0] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_phi [encode f, x\\<^sub>0] \\<down>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "then"], ["proof (chain)\npicking this:\n  eval r_phi [encode f, x\\<^sub>0] \\<down>", "obtain g where g: \"recfn 1 g\" \"total g\" \"\\<forall>x. eval r_phi [?i, x] \\<down> = (\\<exists>y. eval g [y] \\<down>= x)\""], ["proof (prove)\nusing this:\n  eval r_phi [encode f, x\\<^sub>0] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>recfn 1 g; Partial_Recursive.total g;\n         \\<forall>x.\n            (eval r_phi [encode f, x] \\<down>) =\n            (\\<exists>y. eval g [y] \\<down>= x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using f(1) nonempty_domain_enumerable"], ["proof (prove)\nusing this:\n  eval r_phi [encode f, x\\<^sub>0] \\<down>\n  recfn 1 f\n  eval r_phi [?i, ?x\\<^sub>0] \\<down> \\<Longrightarrow>\n  \\<exists>g.\n     recfn 1 g \\<and>\n     Partial_Recursive.total g \\<and>\n     (\\<forall>x.\n         (eval r_phi [?i, x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= x))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>recfn 1 g; Partial_Recursive.total g;\n         \\<forall>x.\n            (eval r_phi [encode f, x] \\<down>) =\n            (\\<exists>y. eval g [y] \\<down>= x)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 1 g\n  Partial_Recursive.total g\n  \\<forall>x.\n     (eval r_phi [encode f, x] \\<down>) =\n     (\\<exists>y. eval g [y] \\<down>= x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "with f(2) i"], ["proof (chain)\npicking this:\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n  eval f [?x] = eval r_phi [encode f, ?x]\n  recfn 1 g\n  Partial_Recursive.total g\n  \\<forall>x.\n     (eval r_phi [encode f, x] \\<down>) =\n     (\\<exists>y. eval g [y] \\<down>= x)", "have \"\\<forall>x. x \\<in> X = (\\<exists>y. eval g [y] \\<down>= x)\""], ["proof (prove)\nusing this:\n  \\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)\n  eval f [?x] = eval r_phi [encode f, ?x]\n  recfn 1 g\n  Partial_Recursive.total g\n  \\<forall>x.\n     (eval r_phi [encode f, x] \\<down>) =\n     (\\<exists>y. eval g [y] \\<down>= x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<in> X) = (\\<exists>y. eval g [y] \\<down>= x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. eval g [y] \\<down>= x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. eval g [y] \\<down>= x)", "have \"\\<forall>x. x \\<in> X = (\\<exists>y. the (eval g [y]) = x)\""], ["proof (prove)\nusing this:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. eval g [y] \\<down>= x)\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<in> X) = (\\<exists>y. the (eval g [y]) = x)", "using totalE[OF g(2) g(1)]"], ["proof (prove)\nusing this:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. eval g [y] \\<down>= x)\n  length ?xs = 1 \\<Longrightarrow> eval g ?xs \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>x. (x \\<in> X) = (\\<exists>y. the (eval g [y]) = x)", "by (metis One_nat_def length_Cons list.size(3) option.collapse option.sel)"], ["proof (state)\nthis:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. the (eval g [y]) = x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. the (eval g [y]) = x)", "have \"X = {the (eval g [y]) |y. y \\<in> UNIV}\""], ["proof (prove)\nusing this:\n  \\<forall>x. (x \\<in> X) = (\\<exists>y. the (eval g [y]) = x)\n\ngoal (1 subgoal):\n 1. X = {the (eval g [y]) |y. y \\<in> UNIV}", "by auto"], ["proof (state)\nthis:\n  X = {the (eval g [y]) |y. y \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> recursively_enumerable X", "with g(1,2)"], ["proof (chain)\npicking this:\n  recfn 1 g\n  Partial_Recursive.total g\n  X = {the (eval g [y]) |y. y \\<in> UNIV}", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 g\n  Partial_Recursive.total g\n  X = {the (eval g [y]) |y. y \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. recursively_enumerable X", "using recursively_enumerable_def"], ["proof (prove)\nusing this:\n  recfn 1 g\n  Partial_Recursive.total g\n  X = {the (eval g [y]) |y. y \\<in> UNIV}\n  recursively_enumerable ?X \\<equiv>\n  ?X = {} \\<or>\n  (\\<exists>f.\n      recfn 1 f \\<and>\n      Partial_Recursive.total f \\<and>\n      ?X = {the (eval f [x]) |x. x \\<in> UNIV})\n\ngoal (1 subgoal):\n 1. recursively_enumerable X", "by auto"], ["proof (state)\nthis:\n  recursively_enumerable X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  semidecidable ?X \\<Longrightarrow> recursively_enumerable ?X\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next goal is to show that a set is decidable iff. it and its\ncomplement are semidecidable. For this we use the concurrent evaluation\nfunction.\\<close>"], ["", "lemma semidecidable_decidable:\n  assumes \"semidecidable X\" and \"semidecidable (- X)\"\n  shows \"decidable X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decidable X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable X", "obtain f where f: \"recfn 1 f \\<and> (\\<forall>x. eval f [x] \\<down> \\<longleftrightarrow> x \\<in> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        recfn 1 f \\<and>\n        (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) semidecidable_iff_domain"], ["proof (prove)\nusing this:\n  semidecidable X\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        recfn 1 f \\<and>\n        (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n\ngoal (1 subgoal):\n 1. decidable X", "let ?i = \"encode f\""], ["proof (state)\ngoal (1 subgoal):\n 1. decidable X", "obtain g where g: \"recfn 1 g \\<and> (\\<forall>x. eval g [x] \\<down> \\<longleftrightarrow> x \\<in> (- X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g.\n        recfn 1 g \\<and>\n        (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) semidecidable_iff_domain"], ["proof (prove)\nusing this:\n  semidecidable (- X)\n  semidecidable ?X =\n  (\\<exists>f.\n      recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> ?X)))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        recfn 1 g \\<and>\n        (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 g \\<and> (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X))\n\ngoal (1 subgoal):\n 1. decidable X", "let ?j = \"encode g\""], ["proof (state)\ngoal (1 subgoal):\n 1. decidable X", "define d where \"d = Cn 1 r_pdec1 [Cn 1 r_parallel [r_const ?j, r_const ?i, Id 1 0]]\""], ["proof (state)\nthis:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n\ngoal (1 subgoal):\n 1. decidable X", "then"], ["proof (chain)\npicking this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]", "have \"recfn 1 d\""], ["proof (prove)\nusing this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n\ngoal (1 subgoal):\n 1. recfn 1 d", "by (simp add: d_def)"], ["proof (state)\nthis:\n  recfn 1 d\n\ngoal (1 subgoal):\n 1. decidable X", "have *: \"\\<And>x. eval r_phi [?i, x] = eval f [x]\" \"\\<And>x. eval r_phi [?j, x] = eval g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. eval r_phi [encode f, x] = eval f [x]) &&&\n    (\\<And>x. eval r_phi [encode g, x] = eval g [x])", "using f g r_phi'"], ["proof (prove)\nusing this:\n  recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n  recfn 1 g \\<and> (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X))\n  recfn 1 ?f \\<Longrightarrow> eval r_phi [encode ?f, ?x] = eval ?f [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>x. eval r_phi [encode f, x] = eval f [x]) &&&\n    (\\<And>x. eval r_phi [encode g, x] = eval g [x])", "by simp_all"], ["proof (state)\nthis:\n  eval r_phi [encode f, ?x] = eval f [?x]\n  eval r_phi [encode g, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. decidable X", "have \"eval d [x] \\<down>= 1\" if \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "have \"eval f [x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f [x] \\<down>", "using f that"], ["proof (prove)\nusing this:\n  recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval f [x] \\<down>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "moreover"], ["proof (state)\nthis:\n  eval f [x] \\<down>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "have \"eval g [x] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [x] \\<up>", "using g that"], ["proof (prove)\nusing this:\n  recfn 1 g \\<and> (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X))\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. eval g [x] \\<up>", "by blast"], ["proof (state)\nthis:\n  eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "ultimately"], ["proof (chain)\npicking this:\n  eval f [x] \\<down>\n  eval g [x] \\<up>", "have \"eval r_parallel [?j, ?i, x] \\<down>= prod_encode (1, the (eval f [x]))\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down>\n  eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_parallel [encode g, encode f, x] \\<down>=\n    prod_encode (1, the (eval f [x]))", "using * r_parallel(3)"], ["proof (prove)\nusing this:\n  eval f [x] \\<down>\n  eval g [x] \\<up>\n  eval r_phi [encode f, ?x] = eval f [?x]\n  eval r_phi [encode g, ?x] = eval g [?x]\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?g [?x] \\<down> \\<and> eval ?f [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n\ngoal (1 subgoal):\n 1. eval r_parallel [encode g, encode f, x] \\<down>=\n    prod_encode (1, the (eval f [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (1, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "with d_def"], ["proof (chain)\npicking this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (1, the (eval f [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (1, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  eval d [x] \\<down>= 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> eval d [?x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. decidable X", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> eval d [?x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. decidable X", "have \"eval d [x] \\<down>= 0\" if \"x \\<notin> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "have \"eval g [x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [x] \\<down>", "using g that"], ["proof (prove)\nusing this:\n  recfn 1 g \\<and> (\\<forall>x. (eval g [x] \\<down>) = (x \\<in> - X))\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. eval g [x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval g [x] \\<down>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "moreover"], ["proof (state)\nthis:\n  eval g [x] \\<down>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "have \"eval f [x] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f [x] \\<up>", "using f that"], ["proof (prove)\nusing this:\n  recfn 1 f \\<and> (\\<forall>x. (eval f [x] \\<down>) = (x \\<in> X))\n  x \\<notin> X\n\ngoal (1 subgoal):\n 1. eval f [x] \\<up>", "by blast"], ["proof (state)\nthis:\n  eval f [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "ultimately"], ["proof (chain)\npicking this:\n  eval g [x] \\<down>\n  eval f [x] \\<up>", "have \"eval r_parallel [?j, ?i, x] \\<down>= prod_encode (0, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  eval g [x] \\<down>\n  eval f [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_parallel [encode g, encode f, x] \\<down>=\n    prod_encode (0, the (eval g [x]))", "using * r_parallel(2)"], ["proof (prove)\nusing this:\n  eval g [x] \\<down>\n  eval f [x] \\<up>\n  eval r_phi [encode f, ?x] = eval f [?x]\n  eval r_phi [encode g, ?x] = eval g [?x]\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?f [?x] \\<down> \\<and> eval ?g [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x]))\n\ngoal (1 subgoal):\n 1. eval r_parallel [encode g, encode f, x] \\<down>=\n    prod_encode (0, the (eval g [x]))", "by blast"], ["proof (state)\nthis:\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (0, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "with d_def"], ["proof (chain)\npicking this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (0, the (eval g [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  d =\n  Cn 1 r_pdec1\n   [Cn 1 r_parallel [r_const (encode g), r_const (encode f), recf.Id 1 0]]\n  eval r_parallel [encode g, encode f, x] \\<down>=\n  prod_encode (0, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval d [x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval d [x] \\<down>= 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<notin> X \\<Longrightarrow> eval d [?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. decidable X", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> X \\<Longrightarrow> eval d [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval d [?x] \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> eval d [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval d [?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. decidable X", "using decidable_def \\<open>recfn 1 d\\<close>"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> eval d [?x] \\<down>= 1\n  ?x \\<notin> X \\<Longrightarrow> eval d [?x] \\<down>= 0\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n  recfn 1 d\n\ngoal (1 subgoal):\n 1. decidable X", "by auto"], ["proof (state)\nthis:\n  decidable X\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem decidable_iff_semidecidable_complement:\n  \"decidable X \\<longleftrightarrow> semidecidable X \\<and> semidecidable (- X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decidable X = (semidecidable X \\<and> semidecidable (- X))", "using semidecidable_decidable decidable_imp_semidecidable decidable_complement"], ["proof (prove)\nusing this:\n  \\<lbrakk>semidecidable ?X; semidecidable (- ?X)\\<rbrakk>\n  \\<Longrightarrow> decidable ?X\n  decidable ?X \\<Longrightarrow> semidecidable ?X\n  decidable ?X \\<Longrightarrow> decidable (- ?X)\n\ngoal (1 subgoal):\n 1. decidable X = (semidecidable X \\<and> semidecidable (- X))", "by blast"], ["", "section \\<open>Rice's theorem\\<close>"], ["", "definition index_set :: \"nat set \\<Rightarrow> bool\" where\n  \"index_set I \\<equiv> \\<forall>i j. i \\<in> I \\<and> (\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]) \\<longrightarrow> j \\<in> I\""], ["", "lemma index_set_closed_in:\n  assumes \"index_set I\" and \"i \\<in> I\" and \"\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\"\n  shows \"j \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<in> I", "using index_set_def assms"], ["proof (prove)\nusing this:\n  index_set ?I \\<equiv>\n  \\<forall>i j.\n     i \\<in> ?I \\<and>\n     (\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]) \\<longrightarrow>\n     j \\<in> ?I\n  index_set I\n  i \\<in> I\n  \\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\n\ngoal (1 subgoal):\n 1. j \\<in> I", "by simp"], ["", "lemma index_set_closed_not_in:\n  assumes \"index_set I\" and \"i \\<notin> I\" and \"\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\"\n  shows \"j \\<notin> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j \\<notin> I", "using index_set_def assms"], ["proof (prove)\nusing this:\n  index_set ?I \\<equiv>\n  \\<forall>i j.\n     i \\<in> ?I \\<and>\n     (\\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]) \\<longrightarrow>\n     j \\<in> ?I\n  index_set I\n  i \\<notin> I\n  \\<forall>x. eval r_phi [i, x] = eval r_phi [j, x]\n\ngoal (1 subgoal):\n 1. j \\<notin> I", "by metis"], ["", "theorem rice_theorem:\n  assumes \"index_set I\" and \"I \\<noteq> UNIV\" and \"I \\<noteq> {}\"\n  shows \"\\<not> decidable I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> decidable I", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "assume \"decidable I\""], ["proof (state)\nthis:\n  decidable I\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  decidable I", "obtain d where d: \"recfn 1 d\" \"\\<forall>i. eval d [i] \\<down>= (if i \\<in> I then 1 else 0)\""], ["proof (prove)\nusing this:\n  decidable I\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>recfn 1 d;\n         \\<forall>i.\n            eval d [i] \\<down>= (if i \\<in> I then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using decidable_def"], ["proof (prove)\nusing this:\n  decidable I\n  decidable ?X \\<equiv>\n  \\<exists>f.\n     recfn 1 f \\<and>\n     (\\<forall>x. eval f [x] \\<down>= (if x \\<in> ?X then 1 else 0))\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>recfn 1 d;\n         \\<forall>i.\n            eval d [i] \\<down>= (if i \\<in> I then 1 else 0)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 d\n  \\<forall>i. eval d [i] \\<down>= (if i \\<in> I then 1 else 0)\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "obtain j\\<^sub>1 j\\<^sub>2 where \"j\\<^sub>1 \\<notin> I\" and \"j\\<^sub>2 \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j\\<^sub>1 j\\<^sub>2.\n        \\<lbrakk>j\\<^sub>1 \\<notin> I; j\\<^sub>2 \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2,3)"], ["proof (prove)\nusing this:\n  I \\<noteq> UNIV\n  I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>j\\<^sub>1 j\\<^sub>2.\n        \\<lbrakk>j\\<^sub>1 \\<notin> I; j\\<^sub>2 \\<in> I\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j\\<^sub>1 \\<notin> I\n  j\\<^sub>2 \\<in> I\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "let ?if = \"Cn 2 r_ifz [Cn 2 d [Id 2 0], r_dummy 1 (r_const j\\<^sub>2), r_dummy 1 (r_const j\\<^sub>1)]\""], ["proof (state)\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "define psi where \"psi = Cn 2 r_phi [?if, Id 2 1] \""], ["proof (state)\nthis:\n  psi =\n  Cn 2 r_phi\n   [Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)],\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  psi =\n  Cn 2 r_phi\n   [Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)],\n    recf.Id 2 1]", "have \"recfn 2 psi\""], ["proof (prove)\nusing this:\n  psi =\n  Cn 2 r_phi\n   [Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)],\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. recfn 2 psi", "by (simp add: d)"], ["proof (state)\nthis:\n  recfn 2 psi\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "have \"eval ?if [x, y] = Some (if x \\<in> I then j\\<^sub>1 else j\\<^sub>2)\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_ifz\n       [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n        r_dummy 1 (r_const j\\<^sub>1)])\n     [x, y] \\<down>=\n    (if x \\<in> I then j\\<^sub>1 else j\\<^sub>2)", "by (simp add: d)"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)])\n   [?x, ?y] \\<down>=\n  (if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2)\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)])\n   [?x, ?y] \\<down>=\n  (if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2)\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "have \"eval psi [x, y] = eval (Cn 2 r_phi [?if, Id 2 1]) [x, y]\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval psi [x, y] =\n    eval\n     (Cn 2 r_phi\n       [Cn 2 r_ifz\n         [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n          r_dummy 1 (r_const j\\<^sub>1)],\n        recf.Id 2 1])\n     [x, y]", "using psi_def"], ["proof (prove)\nusing this:\n  psi =\n  Cn 2 r_phi\n   [Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)],\n    recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. eval psi [x, y] =\n    eval\n     (Cn 2 r_phi\n       [Cn 2 r_ifz\n         [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n          r_dummy 1 (r_const j\\<^sub>1)],\n        recf.Id 2 1])\n     [x, y]", "by simp"], ["proof (state)\nthis:\n  eval psi [?x, ?y] =\n  eval\n   (Cn 2 r_phi\n     [Cn 2 r_ifz\n       [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n        r_dummy 1 (r_const j\\<^sub>1)],\n      recf.Id 2 1])\n   [?x, ?y]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  eval\n   (Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)])\n   [?x, ?y] \\<down>=\n  (if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2)\n  eval psi [?x, ?y] =\n  eval\n   (Cn 2 r_phi\n     [Cn 2 r_ifz\n       [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n        r_dummy 1 (r_const j\\<^sub>1)],\n      recf.Id 2 1])\n   [?x, ?y]", "have psi: \"eval psi [x, y] = eval r_phi [if x \\<in> I then j\\<^sub>1 else j\\<^sub>2, y]\" for x y"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_ifz\n     [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n      r_dummy 1 (r_const j\\<^sub>1)])\n   [?x, ?y] \\<down>=\n  (if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2)\n  eval psi [?x, ?y] =\n  eval\n   (Cn 2 r_phi\n     [Cn 2 r_ifz\n       [Cn 2 d [recf.Id 2 0], r_dummy 1 (r_const j\\<^sub>2),\n        r_dummy 1 (r_const j\\<^sub>1)],\n      recf.Id 2 1])\n   [?x, ?y]\n\ngoal (1 subgoal):\n 1. eval psi [x, y] =\n    eval r_phi [if x \\<in> I then j\\<^sub>1 else j\\<^sub>2, y]", "by (simp add: d)"], ["proof (state)\nthis:\n  eval psi [?x, ?y] =\n  eval r_phi [if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2, ?y]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval psi [?x, ?y] =\n  eval r_phi [if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2, ?y]", "have in_I: \"eval psi [x, y] = eval r_phi [j\\<^sub>1, y]\" if \"x \\<in> I\" for x y"], ["proof (prove)\nusing this:\n  eval psi [?x, ?y] =\n  eval r_phi [if ?x \\<in> I then j\\<^sub>1 else j\\<^sub>2, ?y]\n\ngoal (1 subgoal):\n 1. eval psi [x, y] = eval r_phi [j\\<^sub>1, y]", "by (simp add: that)"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow>\n  eval psi [?x, ?y] = eval r_phi [j\\<^sub>1, ?y]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "have not_in_I: \"eval psi [x, y] = eval r_phi [j\\<^sub>2, y]\" if \"x \\<notin> I\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval psi [x, y] = eval r_phi [j\\<^sub>2, y]", "by (simp add: psi that)"], ["proof (state)\nthis:\n  ?x \\<notin> I \\<Longrightarrow>\n  eval psi [?x, ?y] = eval r_phi [j\\<^sub>2, ?y]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "obtain n where n: \"\\<forall>x. eval r_phi [n, x] = eval psi [n, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x. eval r_phi [n, x] = eval psi [n, x] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using kleene_fixed_point_theorem[OF \\<open>recfn 2 psi\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>n\\<ge>?k. \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x. eval r_phi [n, x] = eval psi [n, x] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n\ngoal (1 subgoal):\n 1. decidable I \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "assume \"n \\<in> I\""], ["proof (state)\nthis:\n  n \\<in> I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n \\<in> I", "have \"\\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]\""], ["proof (prove)\nusing this:\n  n \\<in> I\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]", "using n in_I"], ["proof (prove)\nusing this:\n  n \\<in> I\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n  ?x \\<in> I \\<Longrightarrow>\n  eval psi [?x, ?y] = eval r_phi [j\\<^sub>1, ?y]\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]", "have \"n \\<notin> I\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]\n\ngoal (1 subgoal):\n 1. n \\<notin> I", "using \\<open>j\\<^sub>1 \\<notin> I\\<close> index_set_closed_not_in[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>1, x]\n  j\\<^sub>1 \\<notin> I\n  \\<lbrakk>?i \\<notin> I;\n   \\<forall>x. eval r_phi [?i, x] = eval r_phi [?j, x]\\<rbrakk>\n  \\<Longrightarrow> ?j \\<notin> I\n\ngoal (1 subgoal):\n 1. n \\<notin> I", "by simp"], ["proof (state)\nthis:\n  n \\<notin> I\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> False\n 2. \\<not> ?P \\<Longrightarrow> False", "with \\<open>n \\<in> I\\<close>"], ["proof (chain)\npicking this:\n  n \\<in> I\n  n \\<notin> I", "show False"], ["proof (prove)\nusing this:\n  n \\<in> I\n  n \\<notin> I\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. n \\<notin> I \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<notin> I \\<Longrightarrow> False", "assume \"n \\<notin> I\""], ["proof (state)\nthis:\n  n \\<notin> I\n\ngoal (1 subgoal):\n 1. n \\<notin> I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  n \\<notin> I", "have \"\\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]\""], ["proof (prove)\nusing this:\n  n \\<notin> I\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]", "using n not_in_I"], ["proof (prove)\nusing this:\n  n \\<notin> I\n  \\<forall>x. eval r_phi [n, x] = eval psi [n, x]\n  ?x \\<notin> I \\<Longrightarrow>\n  eval psi [?x, ?y] = eval r_phi [j\\<^sub>2, ?y]\n\ngoal (1 subgoal):\n 1. \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]\n\ngoal (1 subgoal):\n 1. n \\<notin> I \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]", "have \"n \\<in> I\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]\n\ngoal (1 subgoal):\n 1. n \\<in> I", "using \\<open>j\\<^sub>2 \\<in> I\\<close> index_set_closed_in[OF assms(1)]"], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [j\\<^sub>2, x]\n  j\\<^sub>2 \\<in> I\n  \\<lbrakk>?i \\<in> I;\n   \\<forall>x. eval r_phi [?i, x] = eval r_phi [?j, x]\\<rbrakk>\n  \\<Longrightarrow> ?j \\<in> I\n\ngoal (1 subgoal):\n 1. n \\<in> I", "by simp"], ["proof (state)\nthis:\n  n \\<in> I\n\ngoal (1 subgoal):\n 1. n \\<notin> I \\<Longrightarrow> False", "with \\<open>n \\<notin> I\\<close>"], ["proof (chain)\npicking this:\n  n \\<notin> I\n  n \\<in> I", "show False"], ["proof (prove)\nusing this:\n  n \\<notin> I\n  n \\<in> I\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Partial recursive functions as actual functions\\label{s:alternative}\\<close>"], ["", "text \\<open>A well-formed @{typ recf} describes an algorithm. Usually,\nhowever, partial recursive functions are considered to be partial functions,\nthat is, right-unique binary relations. This distinction did not matter much\nuntil now, because we were mostly concerned with the \\emph{existence} of\npartial recursive functions, which is equivalent to the existence of\nalgorithms. Whenever it did matter, we could use the extensional equivalence\n@{term \"exteq\"}. In Chapter~\\ref{c:iirf}, however, we will deal with sets of\nfunctions and sets of sets of functions.\n\nFor illustration consider the singleton set containing only the unary zero\nfunction. It could be expressed by @{term \"{Z}\"}, but this would not contain\n@{term[names_short] \"Cn 1 (Id 1 0) [Z]\"}, which computes the same function.\nThe alternative representation as @{term \"{f. f \\<simeq> Z}\"} is not a\nsingleton set. Another alternative would be to identify partial recursive\nfunctions with the equivalence classes of @{term \"exteq\"}. This would work\nfor all arities. But since we will only need unary and binary functions, we\ncan go for the less general but simpler alternative of regarding partial\nrecursive functions as certain functions of types @{typ \"nat \\<Rightarrow>\nnat option\"} and @{typ \"nat \\<Rightarrow> nat \\<Rightarrow> nat option\"}.\nWith this notation we can represent the aforementioned set by @{term\n\"{\\<lambda>_. Some (0::nat)}\"} and express that the function @{term \"\\<lambda>_.\nSome (0::nat)\"} is total recursive.\n\nIn addition terms get shorter, for instance, @{term \"eval r_func [i, x]\"}\nbecomes @{term \"func i x\"}.\\<close>"], ["", "subsection \\<open>The definitions\\<close>"], ["", "type_synonym partial1 = \"nat \\<Rightarrow> nat option\""], ["", "type_synonym partial2 = \"nat \\<Rightarrow> nat \\<Rightarrow> nat option\""], ["", "definition total1 :: \"partial1 \\<Rightarrow> bool\" where\n  \"total1 f \\<equiv> \\<forall>x. f x \\<down>\""], ["", "definition total2 :: \"partial2 \\<Rightarrow> bool\" where\n  \"total2 f \\<equiv> \\<forall>x y. f x y \\<down>\""], ["", "lemma total1I [intro]: \"(\\<And>x. f x \\<down>) \\<Longrightarrow> total1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<down>) \\<Longrightarrow> total1 f", "using total1_def"], ["proof (prove)\nusing this:\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<down>) \\<Longrightarrow> total1 f", "by simp"], ["", "lemma total2I [intro]: \"(\\<And>x y. f x y \\<down>) \\<Longrightarrow> total2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. f x y \\<down>) \\<Longrightarrow> total2 f", "using total2_def"], ["proof (prove)\nusing this:\n  total2 ?f \\<equiv> \\<forall>x y. ?f x y \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>x y. f x y \\<down>) \\<Longrightarrow> total2 f", "by simp"], ["", "lemma total1E [dest, simp]: \"total1 f \\<Longrightarrow> f x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total1 f \\<Longrightarrow> f x \\<down>", "using total1_def"], ["proof (prove)\nusing this:\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. total1 f \\<Longrightarrow> f x \\<down>", "by simp"], ["", "lemma total2E [dest, simp]: \"total2 f \\<Longrightarrow> f x y \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total2 f \\<Longrightarrow> f x y \\<down>", "using total2_def"], ["proof (prove)\nusing this:\n  total2 ?f \\<equiv> \\<forall>x y. ?f x y \\<down>\n\ngoal (1 subgoal):\n 1. total2 f \\<Longrightarrow> f x y \\<down>", "by simp"], ["", "definition P1 :: \"partial1 set\" (\"\\<P>\") where\n  \"\\<P> \\<equiv> {\\<lambda>x. eval r [x] |r. recfn 1 r}\""], ["", "definition P2 :: \"partial2 set\" (\"\\<P>\\<^sup>2\") where\n  \"\\<P>\\<^sup>2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. recfn 2 r}\""], ["", "definition R1 :: \"partial1 set\" (\"\\<R>\") where\n  \"\\<R> \\<equiv> {\\<lambda>x. eval r [x] |r. recfn 1 r \\<and> total r}\""], ["", "definition R2 :: \"partial2 set\" (\"\\<R>\\<^sup>2\") where\n  \"\\<R>\\<^sup>2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. recfn 2 r \\<and> total r}\""], ["", "definition Prim1 :: \"partial1 set\" where\n  \"Prim1 \\<equiv> {\\<lambda>x. eval r [x] |r. prim_recfn 1 r}\""], ["", "definition Prim2 :: \"partial2 set\" where\n  \"Prim2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. prim_recfn 2 r}\""], ["", "lemma R1_imp_P1 [simp, elim]: \"f \\<in> \\<R> \\<Longrightarrow> f \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<Longrightarrow> f \\<in> \\<P>", "using R1_def P1_def"], ["proof (prove)\nusing this:\n  \\<R> \\<equiv>\n  {\\<lambda>x. eval r [x] |r. recfn 1 r \\<and> Partial_Recursive.total r}\n  \\<P> \\<equiv> {\\<lambda>x. eval r [x] |r. recfn 1 r}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<Longrightarrow> f \\<in> \\<P>", "by auto"], ["", "lemma R2_imp_P2 [simp, elim]: \"f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> f \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> f \\<in> \\<P>\\<^sup>2", "using R2_def P2_def"], ["proof (prove)\nusing this:\n  \\<R>\\<^sup>2 \\<equiv>\n  {\\<lambda>x y. eval r [x, y] |r.\n   recfn 2 r \\<and> Partial_Recursive.total r}\n  \\<P>\\<^sup>2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. recfn 2 r}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> f \\<in> \\<P>\\<^sup>2", "by auto"], ["", "lemma Prim1_imp_R1 [simp, elim]: \"f \\<in> Prim1 \\<Longrightarrow> f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Prim1 \\<Longrightarrow> f \\<in> \\<R>", "unfolding Prim1_def R1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x. eval r [x] |r. prim_recfn 1 r} \\<Longrightarrow>\n    f \\<in> {\\<lambda>x. eval r [x] |r.\n             recfn 1 r \\<and> Partial_Recursive.total r}", "by auto"], ["", "lemma Prim2_imp_R2 [simp, elim]: \"f \\<in> Prim2 \\<Longrightarrow> f \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Prim2 \\<Longrightarrow> f \\<in> \\<R>\\<^sup>2", "unfolding Prim2_def R2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x y. eval r [x, y] |r.\n             prim_recfn 2 r} \\<Longrightarrow>\n    f \\<in> {\\<lambda>x y. eval r [x, y] |r.\n             recfn 2 r \\<and> Partial_Recursive.total r}", "by auto"], ["", "lemma P1E [elim]:\n  assumes \"f \\<in> \\<P>\"\n  obtains r where \"recfn 1 r\" and \"\\<forall>x. eval r [x] = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; \\<forall>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms P1_def"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n  \\<P> \\<equiv> {\\<lambda>x. eval r [x] |r. recfn 1 r}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; \\<forall>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "lemma P2E [elim]:\n  assumes \"f \\<in> \\<P>\\<^sup>2\"\n  obtains r where \"recfn 2 r\" and \"\\<forall>x y. eval r [x, y] = f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; \\<forall>x y. eval r [x, y] = f x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms P2_def"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\\<^sup>2\n  \\<P>\\<^sup>2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. recfn 2 r}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; \\<forall>x y. eval r [x, y] = f x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["", "lemma P1I [intro]:\n  assumes \"recfn 1 r\" and \"(\\<lambda>x. eval r [x]) = f\"\n  shows \"f \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<P>", "using assms P1_def"], ["proof (prove)\nusing this:\n  recfn 1 r\n  (\\<lambda>x. eval r [x]) = f\n  \\<P> \\<equiv> {\\<lambda>x. eval r [x] |r. recfn 1 r}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<P>", "by auto"], ["", "lemma P2I [intro]:\n  assumes \"recfn 2 r\" and \"\\<And>x y. eval r [x, y] = f x y\"\n  shows \"f \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<P>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<in> \\<P>\\<^sup>2", "have \"(\\<lambda>x y. eval r [x, y]) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. eval r [x, y]) = f", "using assms(2)"], ["proof (prove)\nusing this:\n  eval r [?x, ?y] = f ?x ?y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. eval r [x, y]) = f", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x y. eval r [x, y]) = f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<P>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x y. eval r [x, y]) = f", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. eval r [x, y]) = f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<P>\\<^sup>2", "using assms(1) P2_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x y. eval r [x, y]) = f\n  recfn 2 r\n  \\<P>\\<^sup>2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. recfn 2 r}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<P>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<P>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R1I [intro]:\n  assumes \"recfn 1 r\" and \"total r\" and \"\\<And>x. eval r [x] = f x\"\n  shows \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "unfolding R1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x. eval r [x] |r.\n             recfn 1 r \\<and> Partial_Recursive.total r}", "using CollectI[of \"\\<lambda>f. \\<exists>r. f = (\\<lambda>x. eval r [x]) \\<and> recfn 1 r \\<and> total r\" f] assms"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     f = (\\<lambda>x. eval r [x]) \\<and>\n     recfn 1 r \\<and> Partial_Recursive.total r \\<Longrightarrow>\n  f \\<in> {\\<lambda>x. eval r [x] |r.\n           recfn 1 r \\<and> Partial_Recursive.total r}\n  recfn 1 r\n  Partial_Recursive.total r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x. eval r [x] |r.\n             recfn 1 r \\<and> Partial_Recursive.total r}", "by metis"], ["", "lemma R1E [elim]:\n  assumes \"f \\<in> \\<R>\"\n  obtains r where \"recfn 1 r\" and \"total r\" and \"f = (\\<lambda>x. eval r [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n         f = (\\<lambda>x. eval r [x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms R1_def"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<R> \\<equiv>\n  {\\<lambda>x. eval r [x] |r. recfn 1 r \\<and> Partial_Recursive.total r}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n         f = (\\<lambda>x. eval r [x])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma R2I [intro]:\n  assumes \"recfn 2 r\" and \"total r\" and \"\\<And>x y. eval r [x, y] = f x y\"\n  shows \"f \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2", "unfolding R2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x y. eval r [x, y] |r.\n             recfn 2 r \\<and> Partial_Recursive.total r}", "using CollectI[of \"\\<lambda>f. \\<exists>r. f = (\\<lambda>x y. eval r [x, y]) \\<and> recfn 2 r \\<and> total r\" f] assms"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     f = (\\<lambda>x y. eval r [x, y]) \\<and>\n     recfn 2 r \\<and> Partial_Recursive.total r \\<Longrightarrow>\n  f \\<in> {\\<lambda>x y. eval r [x, y] |r.\n           recfn 2 r \\<and> Partial_Recursive.total r}\n  recfn 2 r\n  Partial_Recursive.total r\n  eval r [?x, ?y] = f ?x ?y\n\ngoal (1 subgoal):\n 1. f \\<in> {\\<lambda>x y. eval r [x, y] |r.\n             recfn 2 r \\<and> Partial_Recursive.total r}", "by metis"], ["", "lemma R1_SOME:\n  assumes \"f \\<in> \\<R>\"\n    and \"r = (SOME r'. recfn 1 r' \\<and>  total r' \\<and> f = (\\<lambda>x. eval r' [x]))\"\n      (is \"r = (SOME r'. ?P r')\")\n  shows \"recfn 1 r\"\n    and \"\\<And>x. eval r [x] \\<down>\"\n    and \"\\<And>x. f x = eval r [x]\"\n    and \"f = (\\<lambda>x. eval r [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (recfn 1 r &&& (\\<And>x. eval r [x] \\<down>)) &&&\n    (\\<And>x. f x = eval r [x]) &&& f = (\\<lambda>x. eval r [x])", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. recfn 1 r\n 2. \\<And>x. eval r [x] \\<down>\n 3. \\<And>x. f x = eval r [x]\n 4. f = (\\<lambda>x. eval r [x])", "obtain r' where \"?P r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        recfn 1 r' \\<and>\n        Partial_Recursive.total r' \\<and>\n        f = (\\<lambda>x. eval r' [x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using R1E[OF assms(1)]"], ["proof (prove)\nusing this:\n  (\\<And>r.\n      \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n       f = (\\<lambda>x. eval r [x])\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>r'.\n        recfn 1 r' \\<and>\n        Partial_Recursive.total r' \\<and>\n        f = (\\<lambda>x. eval r' [x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r' \\<and>\n  Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x])\n\ngoal (4 subgoals):\n 1. recfn 1 r\n 2. \\<And>x. eval r [x] \\<down>\n 3. \\<And>x. f x = eval r [x]\n 4. f = (\\<lambda>x. eval r [x])", "then"], ["proof (chain)\npicking this:\n  recfn 1 r' \\<and>\n  Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x])", "show \"recfn 1 r\" \"\\<And>b. eval r [b] \\<down>\" \"\\<And>x. f x = eval r [x]\""], ["proof (prove)\nusing this:\n  recfn 1 r' \\<and>\n  Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x])\n\ngoal (1 subgoal):\n 1. recfn 1 r &&&\n    (\\<And>b. eval r [b] \\<down>) &&& (\\<And>x. f x = eval r [x])", "using someI[of ?P r'] assms(2) totalE[of r]"], ["proof (prove)\nusing this:\n  recfn 1 r' \\<and>\n  Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x])\n  recfn 1 r' \\<and>\n  Partial_Recursive.total r' \\<and>\n  f = (\\<lambda>x. eval r' [x]) \\<Longrightarrow>\n  recfn 1\n   (SOME r'.\n       recfn 1 r' \\<and>\n       Partial_Recursive.total r' \\<and>\n       f = (\\<lambda>x. eval r' [x])) \\<and>\n  Partial_Recursive.total\n   (SOME r'.\n       recfn 1 r' \\<and>\n       Partial_Recursive.total r' \\<and>\n       f = (\\<lambda>x. eval r' [x])) \\<and>\n  f =\n  (\\<lambda>x.\n      eval\n       (SOME r'.\n           recfn 1 r' \\<and>\n           Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x]))\n       [x])\n  r =\n  (SOME r'.\n      recfn 1 r' \\<and>\n      Partial_Recursive.total r' \\<and> f = (\\<lambda>x. eval r' [x]))\n  \\<lbrakk>Partial_Recursive.total r; recfn ?n r; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval r ?xs \\<down>\n\ngoal (1 subgoal):\n 1. recfn 1 r &&&\n    (\\<And>b. eval r [b] \\<down>) &&& (\\<And>x. f x = eval r [x])", "by (auto, metis)"], ["proof (state)\nthis:\n  recfn 1 r\n  eval r [?b] \\<down>\n  f ?x = eval r [?x]\n\ngoal (1 subgoal):\n 1. f = (\\<lambda>x. eval r [x])", "then"], ["proof (chain)\npicking this:\n  recfn 1 r\n  eval r [?b] \\<down>\n  f ?x = eval r [?x]", "show \"f = (\\<lambda>x. eval r [x])\""], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r [?b] \\<down>\n  f ?x = eval r [?x]\n\ngoal (1 subgoal):\n 1. f = (\\<lambda>x. eval r [x])", "by auto"], ["proof (state)\nthis:\n  f = (\\<lambda>x. eval r [x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R2E [elim]:\n  assumes \"f \\<in> \\<R>\\<^sup>2\"\n  obtains r where \"recfn 2 r\" and \"total r\" and \"f = (\\<lambda>x\\<^sub>1 x\\<^sub>2. eval r [x\\<^sub>1, x\\<^sub>2])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; Partial_Recursive.total r;\n         f =\n         (\\<lambda>x\\<^sub>1 x\\<^sub>2.\n             eval r [x\\<^sub>1, x\\<^sub>2])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms R2_def"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\\<^sup>2\n  \\<R>\\<^sup>2 \\<equiv>\n  {\\<lambda>x y. eval r [x, y] |r.\n   recfn 2 r \\<and> Partial_Recursive.total r}\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; Partial_Recursive.total r;\n         f =\n         (\\<lambda>x\\<^sub>1 x\\<^sub>2.\n             eval r [x\\<^sub>1, x\\<^sub>2])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma R1_imp_total1 [simp]: \"f \\<in> \\<R> \\<Longrightarrow> total1 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<Longrightarrow> total1 f", "using total1I"], ["proof (prove)\nusing this:\n  (\\<And>x. ?f x \\<down>) \\<Longrightarrow> total1 ?f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<Longrightarrow> total1 f", "by fastforce"], ["", "lemma R2_imp_total2 [simp]: \"f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> total2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> total2 f", "using totalE"], ["proof (prove)\nusing this:\n  \\<lbrakk>Partial_Recursive.total ?f; recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval ?f ?xs \\<down>\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2 \\<Longrightarrow> total2 f", "by fastforce"], ["", "lemma Prim1I [intro]:\n  assumes \"prim_recfn 1 r\" and \"\\<And>x. f x = eval r [x]\"\n  shows \"f \\<in> Prim1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Prim1", "using assms Prim1_def"], ["proof (prove)\nusing this:\n  prim_recfn 1 r\n  f ?x = eval r [?x]\n  Prim1 \\<equiv> {\\<lambda>x. eval r [x] |r. prim_recfn 1 r}\n\ngoal (1 subgoal):\n 1. f \\<in> Prim1", "by blast"], ["", "lemma Prim2I [intro]:\n  assumes \"prim_recfn 2 r\" and \"\\<And>x y. f x y = eval r [x, y]\"\n  shows \"f \\<in> Prim2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> Prim2", "using assms Prim2_def"], ["proof (prove)\nusing this:\n  prim_recfn 2 r\n  f ?x ?y = eval r [?x, ?y]\n  Prim2 \\<equiv> {\\<lambda>x y. eval r [x, y] |r. prim_recfn 2 r}\n\ngoal (1 subgoal):\n 1. f \\<in> Prim2", "by blast"], ["", "lemma P1_total_imp_R1 [intro]:\n  assumes \"f \\<in> \\<P>\" and \"total1 f\"\n  shows \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using assms totalI1"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n  total1 f\n  \\<lbrakk>recfn 1 ?f; \\<And>x. eval ?f [x] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by force"], ["", "lemma P2_total_imp_R2 [intro]:\n  assumes \"f \\<in> \\<P>\\<^sup>2 \" and \"total2 f\"\n  shows \"f \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2", "using assms totalI2"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\\<^sup>2\n  total2 f\n  \\<lbrakk>recfn 2 ?f; \\<And>x y. eval ?f [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2", "by force"], ["", "subsection \\<open>Some simple properties\\<close>"], ["", "text \\<open>In order to show that a @{typ partial1} or @{typ partial2}\nfunction is in @{term \"\\<P>\"}, @{term \"\\<P>\\<^sup>2\"}, @{term \"\\<R>\"}, @{term\n\"\\<R>\\<^sup>2\"}, @{term \"Prim1\"}, or @{term \"Prim2\"} we will usually have to\nfind a suitable @{typ recf}. But for some simple or frequent cases this\nsection provides shortcuts.\\<close>"], ["", "lemma identity_in_R1: \"Some \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "have \"\\<forall>x. eval (Id 1 0) [x] \\<down>= x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. eval (recf.Id 1 0) [x] \\<down>= x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. eval (recf.Id 1 0) [x] \\<down>= x\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "moreover"], ["proof (state)\nthis:\n  \\<forall>x. eval (recf.Id 1 0) [x] \\<down>= x\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "have \"recfn 1 (Id 1 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (recf.Id 1 0)", "by simp"], ["proof (state)\nthis:\n  recfn 1 (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "moreover"], ["proof (state)\nthis:\n  recfn 1 (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "have \"total (Id 1 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (recf.Id 1 0)", "by (simp add: totalI1)"], ["proof (state)\nthis:\n  Partial_Recursive.total (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x. eval (recf.Id 1 0) [x] \\<down>= x\n  recfn 1 (recf.Id 1 0)\n  Partial_Recursive.total (recf.Id 1 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. eval (recf.Id 1 0) [x] \\<down>= x\n  recfn 1 (recf.Id 1 0)\n  Partial_Recursive.total (recf.Id 1 0)\n\ngoal (1 subgoal):\n 1. Some \\<in> \\<R>", "by blast"], ["proof (state)\nthis:\n  Some \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_proj_P1 [simp, elim]:\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  shows \"\\<psi> i \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "from assms"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> \\<P>\\<^sup>2", "obtain u where u: \"recfn 2 u\" \"(\\<lambda>x\\<^sub>1 x\\<^sub>2. eval u [x\\<^sub>1, x\\<^sub>2]) = \\<psi>\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>u.\n        \\<lbrakk>recfn 2 u;\n         (\\<lambda>x\\<^sub>1 x\\<^sub>2. eval u [x\\<^sub>1, x\\<^sub>2]) =\n         \\<psi>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 u\n  (\\<lambda>x\\<^sub>1 x\\<^sub>2. eval u [x\\<^sub>1, x\\<^sub>2]) = \\<psi>\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "define v where \"v \\<equiv> Cn 1 u [r_const i, Id 1 0]\""], ["proof (state)\nthis:\n  v \\<equiv> Cn 1 u [r_const i, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  v \\<equiv> Cn 1 u [r_const i, recf.Id 1 0]", "have \"recfn 1 v\" \"(\\<lambda>x. eval v [x]) = \\<psi> i\""], ["proof (prove)\nusing this:\n  v \\<equiv> Cn 1 u [r_const i, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 v &&& (\\<lambda>x. eval v [x]) = \\<psi> i", "using u"], ["proof (prove)\nusing this:\n  v \\<equiv> Cn 1 u [r_const i, recf.Id 1 0]\n  recfn 2 u\n  (\\<lambda>x\\<^sub>1 x\\<^sub>2. eval u [x\\<^sub>1, x\\<^sub>2]) = \\<psi>\n\ngoal (1 subgoal):\n 1. recfn 1 v &&& (\\<lambda>x. eval v [x]) = \\<psi> i", "by auto"], ["proof (state)\nthis:\n  recfn 1 v\n  (\\<lambda>x. eval v [x]) = \\<psi> i\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  recfn 1 v\n  (\\<lambda>x. eval v [x]) = \\<psi> i", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 v\n  (\\<lambda>x. eval v [x]) = \\<psi> i\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  \\<psi> i \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma R2_proj_R1 [simp, elim]:\n  assumes \"\\<psi> \\<in> \\<R>\\<^sup>2\"\n  shows \"\\<psi> i \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "from assms"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> \\<R>\\<^sup>2", "have \"\\<psi> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  \\<psi> \\<in> \\<P>\\<^sup>2", "have \"\\<psi> i \\<in> \\<P>\""], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  \\<psi> i \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "moreover"], ["proof (state)\nthis:\n  \\<psi> i \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "have \"total1 (\\<psi> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total1 (\\<psi> i)", "using assms"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. total1 (\\<psi> i)", "by (simp add: total1I)"], ["proof (state)\nthis:\n  total1 (\\<psi> i)\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "ultimately"], ["proof (chain)\npicking this:\n  \\<psi> i \\<in> \\<P>\n  total1 (\\<psi> i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> i \\<in> \\<P>\n  total1 (\\<psi> i)\n\ngoal (1 subgoal):\n 1. \\<psi> i \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  \\<psi> i \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_in_Prim1: \"(\\<lambda>_. Some c) \\<in> Prim1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "define r where \"r = r_const c\""], ["proof (state)\nthis:\n  r = r_const c\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "then"], ["proof (chain)\npicking this:\n  r = r_const c", "have \"\\<And>x. eval r [x] = Some c\""], ["proof (prove)\nusing this:\n  r = r_const c\n\ngoal (1 subgoal):\n 1. \\<And>x. eval r [x] \\<down>= c", "by simp"], ["proof (state)\nthis:\n  eval r [?x] \\<down>= c\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "moreover"], ["proof (state)\nthis:\n  eval r [?x] \\<down>= c\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "have \"recfn 1 r\" \"Mn_free r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r &&& Mn_free r", "using r_def"], ["proof (prove)\nusing this:\n  r = r_const c\n\ngoal (1 subgoal):\n 1. recfn 1 r &&& Mn_free r", "by simp_all"], ["proof (state)\nthis:\n  recfn 1 r\n  Mn_free r\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "ultimately"], ["proof (chain)\npicking this:\n  eval r [?x] \\<down>= c\n  recfn 1 r\n  Mn_free r", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r [?x] \\<down>= c\n  recfn 1 r\n  Mn_free r\n\ngoal (1 subgoal):\n 1. (\\<lambda>_. Some c) \\<in> Prim1", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_. Some c) \\<in> Prim1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma concat_P1_P1:\n  assumes \"f \\<in> \\<P>\" and \"g \\<in> \\<P>\"\n  shows \"(\\<lambda>x. if g x \\<down> \\<and> f (the (g x)) \\<down> then Some (the (f (the (g x)))) else None) \\<in> \\<P>\"\n    (is \"?h \\<in> \\<P>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "obtain rf where rf: \"recfn 1 rf\" \"\\<forall>x. eval rf [x] = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rf.\n        \\<lbrakk>recfn 1 rf; \\<forall>x. eval rf [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(1)"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>rf.\n        \\<lbrakk>recfn 1 rf; \\<forall>x. eval rf [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 rf\n  \\<forall>x. eval rf [x] = f x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "obtain rg where rg: \"recfn 1 rg\" \"\\<forall>x. eval rg [x] = g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rg.\n        \\<lbrakk>recfn 1 rg; \\<forall>x. eval rg [x] = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  g \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>rg.\n        \\<lbrakk>recfn 1 rg; \\<forall>x. eval rg [x] = g x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 rg\n  \\<forall>x. eval rg [x] = g x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "let ?rh = \"Cn 1 rf [rg]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "have \"recfn 1 ?rh\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 rf [rg])", "using rf(1) rg(1)"], ["proof (prove)\nusing this:\n  recfn 1 rf\n  recfn 1 rg\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 rf [rg])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 rf [rg])\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "moreover"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 rf [rg])\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "have \"eval ?rh [x] = ?h x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 rf [rg]) [x] =\n    (if g x \\<down> \\<and> f (the (g x)) \\<down>\n     then Some (the (f (the (g x)))) else None)", "using rf rg"], ["proof (prove)\nusing this:\n  recfn 1 rf\n  \\<forall>x. eval rf [x] = f x\n  recfn 1 rg\n  \\<forall>x. eval rg [x] = g x\n\ngoal (1 subgoal):\n 1. eval (Cn 1 rf [rg]) [x] =\n    (if g x \\<down> \\<and> f (the (g x)) \\<down>\n     then Some (the (f (the (g x)))) else None)", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 rf [rg]) [?x] =\n  (if g ?x \\<down> \\<and> f (the (g ?x)) \\<down>\n   then Some (the (f (the (g ?x)))) else None)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 (Cn 1 rf [rg])\n  eval (Cn 1 rf [rg]) [?x] =\n  (if g ?x \\<down> \\<and> f (the (g ?x)) \\<down>\n   then Some (the (f (the (g ?x)))) else None)", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 rf [rg])\n  eval (Cn 1 rf [rg]) [?x] =\n  (if g ?x \\<down> \\<and> f (the (g ?x)) \\<down>\n   then Some (the (f (the (g ?x)))) else None)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        if g x \\<down> \\<and> f (the (g x)) \\<down>\n        then Some (the (f (the (g x)))) else None)\n    \\<in> \\<P>", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      if g x \\<down> \\<and> f (the (g x)) \\<down>\n      then Some (the (f (the (g x)))) else None)\n  \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_update_P1:\n  assumes \"f \\<in> \\<P>\"\n  shows \"f(x:=z) \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f(x := z) \\<in> \\<P>", "proof (cases z)"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "case None"], ["proof (state)\nthis:\n  z \\<up>\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "define re where \"re \\<equiv> Mn 1 (r_constn 1 1)\""], ["proof (state)\nthis:\n  re \\<equiv> Mn 1 (r_constn 1 1)\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "from assms"], ["proof (chain)\npicking this:\n  f \\<in> \\<P>", "obtain r where r: \"recfn 1 r\" \"(\\<lambda>u. eval r [u]) = f\""], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; (\\<lambda>u. eval r [u]) = f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r\n  (\\<lambda>u. eval r [u]) = f\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "define r' where \"r' = Cn 1 (r_lifz re r) [Cn 1 r_eq [Id 1 0, r_const x], Id 1 0]\""], ["proof (state)\nthis:\n  r' = Cn 1 (r_lifz re r) [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "have \"recfn 1 r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r'", "using r(1) r'_def re_def"], ["proof (prove)\nusing this:\n  recfn 1 r\n  r' = Cn 1 (r_lifz re r) [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n  re \\<equiv> Mn 1 (r_constn 1 1)\n\ngoal (1 subgoal):\n 1. recfn 1 r'", "by simp"], ["proof (state)\nthis:\n  recfn 1 r'\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  recfn 1 r'", "have \"eval r' [u] = eval (r_lifz re r) [if u = x then 0 else 1, u]\" for u"], ["proof (prove)\nusing this:\n  recfn 1 r'\n\ngoal (1 subgoal):\n 1. eval r' [u] = eval (r_lifz re r) [if u = x then 0 else 1, u]", "using r'_def"], ["proof (prove)\nusing this:\n  recfn 1 r'\n  r' = Cn 1 (r_lifz re r) [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. eval r' [u] = eval (r_lifz re r) [if u = x then 0 else 1, u]", "by simp"], ["proof (state)\nthis:\n  eval r' [?u] = eval (r_lifz re r) [if ?u = x then 0 else 1, ?u]\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with r(1)"], ["proof (chain)\npicking this:\n  recfn 1 r\n  eval r' [?u] = eval (r_lifz re r) [if ?u = x then 0 else 1, ?u]", "have \"eval r' [u] = (if u = x then None else eval r [u])\" for u"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r' [?u] = eval (r_lifz re r) [if ?u = x then 0 else 1, ?u]\n\ngoal (1 subgoal):\n 1. eval r' [u] = (if u = x then None else eval r [u])", "using re_def re_def"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r' [?u] = eval (r_lifz re r) [if ?u = x then 0 else 1, ?u]\n  re \\<equiv> Mn 1 (r_constn 1 1)\n  re \\<equiv> Mn 1 (r_constn 1 1)\n\ngoal (1 subgoal):\n 1. eval r' [u] = (if u = x then None else eval r [u])", "by simp"], ["proof (state)\nthis:\n  eval r' [?u] = (if ?u = x then None else eval r [?u])\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with r(2)"], ["proof (chain)\npicking this:\n  (\\<lambda>u. eval r [u]) = f\n  eval r' [?u] = (if ?u = x then None else eval r [?u])", "have \"eval r' [u] = (f(x:=None)) u\" for u"], ["proof (prove)\nusing this:\n  (\\<lambda>u. eval r [u]) = f\n  eval r' [?u] = (if ?u = x then None else eval r [?u])\n\ngoal (1 subgoal):\n 1. eval r' [u] = (f(x := None)) u", "by auto"], ["proof (state)\nthis:\n  eval r' [?u] = (f(x := None)) ?u\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  eval r' [?u] = (f(x := None)) ?u", "have \"(\\<lambda>u. eval r' [u]) = f(x:=None)\""], ["proof (prove)\nusing this:\n  eval r' [?u] = (f(x := None)) ?u\n\ngoal (1 subgoal):\n 1. (\\<lambda>u. eval r' [u]) = f(x := None)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>u. eval r' [u]) = f(x := None)\n\ngoal (2 subgoals):\n 1. z \\<up> \\<Longrightarrow> f(x := z) \\<in> \\<P>\n 2. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with None \\<open>recfn 1 r'\\<close>"], ["proof (chain)\npicking this:\n  z \\<up>\n  recfn 1 r'\n  (\\<lambda>u. eval r' [u]) = f(x := None)", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<up>\n  recfn 1 r'\n  (\\<lambda>u. eval r' [u]) = f(x := None)\n\ngoal (1 subgoal):\n 1. f(x := z) \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  f(x := z) \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "case (Some y)"], ["proof (state)\nthis:\n  z \\<down>= y\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "from assms"], ["proof (chain)\npicking this:\n  f \\<in> \\<P>", "obtain r where r: \"recfn 1 r\" \"(\\<lambda>u. eval r [u]) = f\""], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; (\\<lambda>u. eval r [u]) = f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r\n  (\\<lambda>u. eval r [u]) = f\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "define r' where\n    \"r' \\<equiv> Cn 1 (r_lifz (r_const y) r) [Cn 1 r_eq [Id 1 0, r_const x], Id 1 0]\""], ["proof (state)\nthis:\n  r' \\<equiv>\n  Cn 1 (r_lifz (r_const y) r)\n   [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "have \"recfn 1 r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r'", "using r(1) r'_def"], ["proof (prove)\nusing this:\n  recfn 1 r\n  r' \\<equiv>\n  Cn 1 (r_lifz (r_const y) r)\n   [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 r'", "by simp"], ["proof (state)\nthis:\n  recfn 1 r'\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  recfn 1 r'", "have \"eval r' [u] = eval (r_lifz (r_const y) r) [if u = x then 0 else 1, u]\" for u"], ["proof (prove)\nusing this:\n  recfn 1 r'\n\ngoal (1 subgoal):\n 1. eval r' [u] = eval (r_lifz (r_const y) r) [if u = x then 0 else 1, u]", "using r'_def"], ["proof (prove)\nusing this:\n  recfn 1 r'\n  r' \\<equiv>\n  Cn 1 (r_lifz (r_const y) r)\n   [Cn 1 r_eq [recf.Id 1 0, r_const x], recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. eval r' [u] = eval (r_lifz (r_const y) r) [if u = x then 0 else 1, u]", "by simp"], ["proof (state)\nthis:\n  eval r' [?u] = eval (r_lifz (r_const y) r) [if ?u = x then 0 else 1, ?u]\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with r(1)"], ["proof (chain)\npicking this:\n  recfn 1 r\n  eval r' [?u] = eval (r_lifz (r_const y) r) [if ?u = x then 0 else 1, ?u]", "have \"eval r' [u] = (if u = x then Some y else eval r [u])\" for u"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r' [?u] = eval (r_lifz (r_const y) r) [if ?u = x then 0 else 1, ?u]\n\ngoal (1 subgoal):\n 1. eval r' [u] = (if u = x then Some y else eval r [u])", "by simp"], ["proof (state)\nthis:\n  eval r' [?u] = (if ?u = x then Some y else eval r [?u])\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with r(2)"], ["proof (chain)\npicking this:\n  (\\<lambda>u. eval r [u]) = f\n  eval r' [?u] = (if ?u = x then Some y else eval r [?u])", "have \"eval r' [u] = (f(x:=Some y)) u\" for u"], ["proof (prove)\nusing this:\n  (\\<lambda>u. eval r [u]) = f\n  eval r' [?u] = (if ?u = x then Some y else eval r [?u])\n\ngoal (1 subgoal):\n 1. eval r' [u] = (f(x \\<mapsto> y)) u", "by auto"], ["proof (state)\nthis:\n  eval r' [?u] = (f(x \\<mapsto> y)) ?u\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "then"], ["proof (chain)\npicking this:\n  eval r' [?u] = (f(x \\<mapsto> y)) ?u", "have \"(\\<lambda>u. eval r' [u]) = f(x:=Some y)\""], ["proof (prove)\nusing this:\n  eval r' [?u] = (f(x \\<mapsto> y)) ?u\n\ngoal (1 subgoal):\n 1. (\\<lambda>u. eval r' [u]) = f(x \\<mapsto> y)", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>u. eval r' [u]) = f(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. \\<And>a. z \\<down>= a \\<Longrightarrow> f(x := z) \\<in> \\<P>", "with Some \\<open>recfn 1 r'\\<close>"], ["proof (chain)\npicking this:\n  z \\<down>= y\n  recfn 1 r'\n  (\\<lambda>u. eval r' [u]) = f(x \\<mapsto> y)", "show ?thesis"], ["proof (prove)\nusing this:\n  z \\<down>= y\n  recfn 1 r'\n  (\\<lambda>u. eval r' [u]) = f(x \\<mapsto> y)\n\ngoal (1 subgoal):\n 1. f(x := z) \\<in> \\<P>", "by auto"], ["proof (state)\nthis:\n  f(x := z) \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_P2:\n  assumes \"f \\<in> \\<P>\\<^sup>2\"\n  shows \"(\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "obtain r where r: \"recfn 2 r\" \"\\<And>x y. eval r [x, y] = f x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; \\<And>x y. eval r [x, y] = f x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 2 r; \\<And>x y. eval r [x, y] = f x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 r\n  eval r [?x, ?y] = f ?x ?y\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  recfn 2 r\n  eval r [?x, ?y] = f ?x ?y", "have \"eval (r_swap r) [x, y] = f y x\" for x y"], ["proof (prove)\nusing this:\n  recfn 2 r\n  eval r [?x, ?y] = f ?x ?y\n\ngoal (1 subgoal):\n 1. eval (r_swap r) [x, y] = f y x", "by simp"], ["proof (state)\nthis:\n  eval (r_swap r) [?x, ?y] = f ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "moreover"], ["proof (state)\nthis:\n  eval (r_swap r) [?x, ?y] = f ?y ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "have \"recfn 2 (r_swap r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_swap r)", "using r_swap_recfn r(1)"], ["proof (prove)\nusing this:\n  recfn 2 ?f \\<Longrightarrow> recfn 2 (r_swap ?f)\n  recfn 2 r\n\ngoal (1 subgoal):\n 1. recfn 2 (r_swap r)", "by simp"], ["proof (state)\nthis:\n  recfn 2 (r_swap r)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_swap r) [?x, ?y] = f ?y ?x\n  recfn 2 (r_swap r)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_swap r) [?x, ?y] = f ?y ?x\n  recfn 2 (r_swap r)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma swap_R2:\n  assumes \"f \\<in> \\<R>\\<^sup>2\"\n  shows \"(\\<lambda>x y. f y x) \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<R>\\<^sup>2", "using swap_P2[of f] assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\\<^sup>2 \\<Longrightarrow>\n  (\\<lambda>x y. f y x) \\<in> \\<P>\\<^sup>2\n  f \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<lambda>x y. f y x) \\<in> \\<R>\\<^sup>2", "by (meson P2_total_imp_R2 R2_imp_P2 R2_imp_total2 total2E total2I)"], ["", "lemma skip_P1:\n  assumes \"f \\<in> \\<P>\"\n  shows \"(\\<lambda>x. f (x + n)) \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "obtain r where r: \"recfn 1 r\" \"\\<And>x. eval r [x] = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; \\<And>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 1 r; \\<And>x. eval r [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "let ?s = \"Cn 1 r [Cn 1 r_add [Id 1 0, r_const n]]\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "have \"recfn 1 ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]])", "using r"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]])", "by simp"], ["proof (state)\nthis:\n  recfn 1 (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]])\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "have \"eval ?s [x] = eval r [x + n]\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [x] = eval r [x + n]", "using r"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r [?x] = f ?x\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [x] = eval r [x + n]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = eval r [?x + n]\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "with r"], ["proof (chain)\npicking this:\n  recfn 1 r\n  eval r [?x] = f ?x\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = eval r [?x + n]", "have \"eval ?s [x] = f (x + n)\" for x"], ["proof (prove)\nusing this:\n  recfn 1 r\n  eval r [?x] = f ?x\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = eval r [?x + n]\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [x] = f (x + n)", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = f (?x + n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "with \\<open>recfn 1 ?s\\<close>"], ["proof (chain)\npicking this:\n  recfn 1 (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]])\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = f (?x + n)", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]])\n  eval (Cn 1 r [Cn 1 r_add [recf.Id 1 0, r_const n]]) [?x] = f (?x + n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<P>", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x. f (x + n)) \\<in> \\<P>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma skip_R1:\n  assumes \"f \\<in> \\<R>\"\n  shows \"(\\<lambda>x. f (x + n)) \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<R>", "using assms skip_P1 R1_imp_total1 total1_def"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  ?f \\<in> \\<P> \\<Longrightarrow> (\\<lambda>x. ?f (x + ?n)) \\<in> \\<P>\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. f (x + n)) \\<in> \\<R>", "by auto"], ["", "subsection \\<open>The G?del numbering @{term \\<phi>}\\label{s:goedel_numbering}\\<close>"], ["", "text \\<open>While the term \\emph{G?del numbering} is often used generically for\nmappings between natural numbers and mathematical concepts, the inductive\ninference literature uses it in a more specific sense. There it is equivalent\nto the notion of acceptable numbering~\\cite{Rogers87}: For every numbering\nthere is a recursive function mapping the numbering's indices to equivalent\nones of a G?del numbering.\\<close>"], ["", "definition goedel_numbering :: \"partial2 \\<Rightarrow> bool\" where\n  \"goedel_numbering \\<psi> \\<equiv> \\<psi> \\<in> \\<P>\\<^sup>2 \\<and> (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = \\<psi> (the (c i)))\""], ["", "lemma goedel_numbering_P2:\n  assumes \"goedel_numbering \\<psi>\"\n  shows \"\\<psi> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2", "using goedel_numbering_def assms"], ["proof (prove)\nusing this:\n  goedel_numbering ?\\<psi> \\<equiv>\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<and>\n  (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2.\n      \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = ?\\<psi> (the (c i)))\n  goedel_numbering \\<psi>\n\ngoal (1 subgoal):\n 1. \\<psi> \\<in> \\<P>\\<^sup>2", "by simp"], ["", "lemma goedel_numberingE:\n  assumes \"goedel_numbering \\<psi>\" and \"\\<chi> \\<in> \\<P>\\<^sup>2\"\n  obtains c where \"c \\<in> \\<R>\" and \"\\<forall>i. \\<chi> i = \\<psi> (the (c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<R>;\n         \\<forall>i. \\<chi> i = \\<psi> (the (c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms goedel_numbering_def"], ["proof (prove)\nusing this:\n  goedel_numbering \\<psi>\n  \\<chi> \\<in> \\<P>\\<^sup>2\n  goedel_numbering ?\\<psi> \\<equiv>\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<and>\n  (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2.\n      \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = ?\\<psi> (the (c i)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<R>;\n         \\<forall>i. \\<chi> i = \\<psi> (the (c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma goedel_numbering_universal:\n  assumes \"goedel_numbering \\<psi>\" and \"f \\<in> \\<P>\"\n  shows \"\\<exists>i. \\<psi> i = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "define \\<chi> :: partial2 where \"\\<chi> = (\\<lambda>i. f)\""], ["proof (state)\nthis:\n  \\<chi> = (\\<lambda>i. f)\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "have \"\\<chi> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "obtain rf where rf: \"recfn 1 rf\" \"\\<And>x. eval rf [x] = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rf.\n        \\<lbrakk>recfn 1 rf; \\<And>x. eval rf [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. (\\<And>rf.\n        \\<lbrakk>recfn 1 rf; \\<And>x. eval rf [x] = f x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 rf\n  eval rf [?x] = f ?x\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "define r where \"r = Cn 2 rf [Id 2 1]\""], ["proof (state)\nthis:\n  r = Cn 2 rf [recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "then"], ["proof (chain)\npicking this:\n  r = Cn 2 rf [recf.Id 2 1]", "have r: \"recfn 2 r\" \"\\<And>i x. eval r [i, x] = eval rf [x]\""], ["proof (prove)\nusing this:\n  r = Cn 2 rf [recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. recfn 2 r &&& (\\<And>i x. eval r [i, x] = eval rf [x])", "using rf(1)"], ["proof (prove)\nusing this:\n  r = Cn 2 rf [recf.Id 2 1]\n  recfn 1 rf\n\ngoal (1 subgoal):\n 1. recfn 2 r &&& (\\<And>i x. eval r [i, x] = eval rf [x])", "by simp_all"], ["proof (state)\nthis:\n  recfn 2 r\n  eval r [?i, ?x] = eval rf [?x]\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "with rf(2)"], ["proof (chain)\npicking this:\n  eval rf [?x] = f ?x\n  recfn 2 r\n  eval r [?i, ?x] = eval rf [?x]", "have \"\\<And>i x. eval r [i, x] = f x\""], ["proof (prove)\nusing this:\n  eval rf [?x] = f ?x\n  recfn 2 r\n  eval r [?i, ?x] = eval rf [?x]\n\ngoal (1 subgoal):\n 1. \\<And>i x. eval r [i, x] = f x", "by simp"], ["proof (state)\nthis:\n  eval r [?i, ?x] = f ?x\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "with r(1)"], ["proof (chain)\npicking this:\n  recfn 2 r\n  eval r [?i, ?x] = f ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 2 r\n  eval r [?i, ?x] = f ?x\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "using \\<chi>_def"], ["proof (prove)\nusing this:\n  recfn 2 r\n  eval r [?i, ?x] = f ?x\n  \\<chi> = (\\<lambda>i. f)\n\ngoal (1 subgoal):\n 1. \\<chi> \\<in> \\<P>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  \\<chi> \\<in> \\<P>\\<^sup>2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<chi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "then"], ["proof (chain)\npicking this:\n  \\<chi> \\<in> \\<P>\\<^sup>2", "obtain c where \"c \\<in> \\<R>\" and \"\\<forall>i. \\<chi> i = \\<psi> (the (c i))\""], ["proof (prove)\nusing this:\n  \\<chi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<R>;\n         \\<forall>i. \\<chi> i = \\<psi> (the (c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using goedel_numbering_def assms(1)"], ["proof (prove)\nusing this:\n  \\<chi> \\<in> \\<P>\\<^sup>2\n  goedel_numbering ?\\<psi> \\<equiv>\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<and>\n  (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2.\n      \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = ?\\<psi> (the (c i)))\n  goedel_numbering \\<psi>\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<R>;\n         \\<forall>i. \\<chi> i = \\<psi> (the (c i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> \\<R>\n  \\<forall>i. \\<chi> i = \\<psi> (the (c i))\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "with \\<chi>_def"], ["proof (chain)\npicking this:\n  \\<chi> = (\\<lambda>i. f)\n  c \\<in> \\<R>\n  \\<forall>i. \\<chi> i = \\<psi> (the (c i))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<chi> = (\\<lambda>i. f)\n  c \\<in> \\<R>\n  \\<forall>i. \\<chi> i = \\<psi> (the (c i))\n\ngoal (1 subgoal):\n 1. \\<exists>i. \\<psi> i = f", "by auto"], ["proof (state)\nthis:\n  \\<exists>i. \\<psi> i = f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Our standard G?del numbering is based on @{term r_phi}:\\<close>"], ["", "definition phi :: partial2 (\"\\<phi>\") where\n  \"\\<phi> i x \\<equiv> eval r_phi [i, x]\""], ["", "lemma phi_in_P2: \"\\<phi> \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<P>\\<^sup>2", "unfolding phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i x. eval r_phi [i, x]) \\<in> \\<P>\\<^sup>2", "using r_phi_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_phi\n\ngoal (1 subgoal):\n 1. (\\<lambda>i x. eval r_phi [i, x]) \\<in> \\<P>\\<^sup>2", "by blast"], ["", "text \\<open>Indices of any numbering can be translated into equivalent indices\nof @{term phi}, which thus is a G?del numbering.\\<close>"], ["", "lemma numbering_translation_for_phi:\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  shows \"\\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "obtain psi where psi: \"recfn 2 psi\" \"\\<And>i x. eval psi [i, x] = \\<psi> i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>psi.\n        \\<lbrakk>recfn 2 psi;\n         \\<And>i x. eval psi [i, x] = \\<psi> i x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>psi.\n        \\<lbrakk>recfn 2 psi;\n         \\<And>i x. eval psi [i, x] = \\<psi> i x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 psi\n  eval psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "with numbering_translation"], ["proof (chain)\npicking this:\n  \\<lbrakk>recfn 2 ?psi;\n   \\<And>c.\n      \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n       \\<forall>i x.\n          eval ?psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  recfn 2 psi\n  eval psi [?i, ?x] = \\<psi> ?i ?x", "obtain b where\n    \"recfn 1 b\" \"total b\" \"\\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\""], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn 2 ?psi;\n   \\<And>c.\n      \\<lbrakk>recfn 1 c; Partial_Recursive.total c;\n       \\<forall>i x.\n          eval ?psi [i, x] = eval r_phi [the (eval c [i]), x]\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  recfn 2 psi\n  eval psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>recfn 1 b; Partial_Recursive.total b;\n         \\<forall>i x.\n            eval psi [i, x] = eval r_phi [the (eval b [i]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "moreover"], ["proof (state)\nthis:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "from this"], ["proof (chain)\npicking this:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]", "obtain c where c: \"c \\<in> \\<R>\" \"\\<forall>i. c i = eval b [i]\""], ["proof (prove)\nusing this:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> \\<R>; \\<forall>i. c i = eval b [i]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fast"], ["proof (state)\nthis:\n  c \\<in> \\<R>\n  \\<forall>i. c i = eval b [i]\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n  c \\<in> \\<R>\n  \\<forall>i. c i = eval b [i]", "have \"\\<psi> i x = \\<phi> (the (c i)) x\" for i x"], ["proof (prove)\nusing this:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n  c \\<in> \\<R>\n  \\<forall>i. c i = eval b [i]\n\ngoal (1 subgoal):\n 1. \\<psi> i x = \\<phi> (the (c i)) x", "using phi_def psi(2)"], ["proof (prove)\nusing this:\n  recfn 1 b\n  Partial_Recursive.total b\n  \\<forall>i x. eval psi [i, x] = eval r_phi [the (eval b [i]), x]\n  c \\<in> \\<R>\n  \\<forall>i. c i = eval b [i]\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  eval psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. \\<psi> i x = \\<phi> (the (c i)) x", "by presburger"], ["proof (state)\nthis:\n  \\<psi> ?i ?x = \\<phi> (the (c ?i)) ?x\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "then"], ["proof (chain)\npicking this:\n  \\<psi> ?i ?x = \\<phi> (the (c ?i)) ?x", "have \"\\<psi> i = \\<phi> (the (c i))\" for i"], ["proof (prove)\nusing this:\n  \\<psi> ?i ?x = \\<phi> (the (c ?i)) ?x\n\ngoal (1 subgoal):\n 1. \\<psi> i = \\<phi> (the (c i))", "by auto"], ["proof (state)\nthis:\n  \\<psi> ?i = \\<phi> (the (c ?i))\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "then"], ["proof (chain)\npicking this:\n  \\<psi> ?i = \\<phi> (the (c ?i))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> ?i = \\<phi> (the (c ?i))\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "using c(1)"], ["proof (prove)\nusing this:\n  \\<psi> ?i = \\<phi> (the (c ?i))\n  c \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))", "by blast"], ["proof (state)\nthis:\n  \\<exists>c\\<in>\\<R>. \\<forall>i. \\<psi> i = \\<phi> (the (c i))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary goedel_numbering_phi: \"goedel_numbering \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. goedel_numbering \\<phi>", "unfolding goedel_numbering_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<P>\\<^sup>2 \\<and>\n    (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2.\n        \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = \\<phi> (the (c i)))", "using numbering_translation_for_phi phi_in_P2"], ["proof (prove)\nusing this:\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<Longrightarrow>\n  \\<exists>c\\<in>\\<R>. \\<forall>i. ?\\<psi> i = \\<phi> (the (c i))\n  \\<phi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<phi> \\<in> \\<P>\\<^sup>2 \\<and>\n    (\\<forall>\\<chi>\\<in>\\<P>\\<^sup>2.\n        \\<exists>c\\<in>\\<R>. \\<forall>i. \\<chi> i = \\<phi> (the (c i)))", "by simp"], ["", "corollary phi_universal:\n  assumes \"f \\<in> \\<P>\"\n  obtains i where \"\\<phi> i = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. \\<phi> i = f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using goedel_numbering_universal[OF goedel_numbering_phi assms]"], ["proof (prove)\nusing this:\n  \\<exists>i. \\<phi> i = f\n\ngoal (1 subgoal):\n 1. (\\<And>i. \\<phi> i = f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "subsection \\<open>Fixed-point theorems\\<close>"], ["", "text \\<open>The fixed-point theorems look somewhat cleaner in the new\nnotation. We will only need the following ones in the next chapter.\\<close>"], ["", "theorem kleene_fixed_point:\n  fixes k :: nat\n  assumes \"\\<psi> \\<in> \\<P>\\<^sup>2\"\n  obtains i where \"i \\<ge> k\" and \"\\<phi> i = \\<psi> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain r_psi where r_psi: \"recfn 2 r_psi\" \"\\<And>i x. eval r_psi [i, x] = \\<psi> i x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r_psi.\n        \\<lbrakk>recfn 2 r_psi;\n         \\<And>i x. eval r_psi [i, x] = \\<psi> i x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<psi> \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>r_psi.\n        \\<lbrakk>recfn 2 r_psi;\n         \\<And>i x. eval r_psi [i, x] = \\<psi> i x\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 r_psi\n  eval r_psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  recfn 2 r_psi\n  eval r_psi [?i, ?x] = \\<psi> ?i ?x", "obtain i where i: \"i \\<ge> k\" \"\\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\""], ["proof (prove)\nusing this:\n  recfn 2 r_psi\n  eval r_psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i;\n         \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using kleene_fixed_point_theorem"], ["proof (prove)\nusing this:\n  recfn 2 r_psi\n  eval r_psi [?i, ?x] = \\<psi> ?i ?x\n  recfn 2 ?psi \\<Longrightarrow>\n  \\<exists>n\\<ge>?k. \\<forall>x. eval r_phi [n, x] = eval ?psi [n, x]\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i;\n         \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  k \\<le> i\n  \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  k \\<le> i\n  \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]", "have \"\\<forall>x. \\<phi> i x = \\<psi> i x\""], ["proof (prove)\nusing this:\n  k \\<le> i\n  \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<phi> i x = \\<psi> i x", "using phi_def r_psi"], ["proof (prove)\nusing this:\n  k \\<le> i\n  \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  recfn 2 r_psi\n  eval r_psi [?i, ?x] = \\<psi> ?i ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x. \\<phi> i x = \\<psi> i x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x. \\<phi> i x = \\<psi> i x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>k \\<le> i; \\<phi> i = \\<psi> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. \\<phi> i x = \\<psi> i x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<phi> i x = \\<psi> i x\n\ngoal (1 subgoal):\n 1. thesis", "using i that"], ["proof (prove)\nusing this:\n  \\<forall>x. \\<phi> i x = \\<psi> i x\n  k \\<le> i\n  \\<forall>x. eval r_phi [i, x] = eval r_psi [i, x]\n  \\<lbrakk>k \\<le> ?i; \\<phi> ?i = \\<psi> ?i\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem smullyan_double_fixed_point:\n  assumes \"g \\<in> \\<R>\\<^sup>2\" and \"h \\<in> \\<R>\\<^sup>2\"\n  obtains m n where \"\\<phi> m = \\<phi> (the (g m n))\" and \"\\<phi> n = \\<phi> (the (h m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain rg where rg: \"recfn 2 rg\" \"total rg\" \"g = (\\<lambda>x y. eval rg [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rg.\n        \\<lbrakk>recfn 2 rg; Partial_Recursive.total rg;\n         g = (\\<lambda>x y. eval rg [x, y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R2E[OF assms(1)]"], ["proof (prove)\nusing this:\n  (\\<And>r.\n      \\<lbrakk>recfn 2 r; Partial_Recursive.total r;\n       g =\n       (\\<lambda>x\\<^sub>1 x\\<^sub>2.\n           eval r [x\\<^sub>1, x\\<^sub>2])\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rg.\n        \\<lbrakk>recfn 2 rg; Partial_Recursive.total rg;\n         g = (\\<lambda>x y. eval rg [x, y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain rh where rh: \"recfn 2 rh\" \"total rh\" \"h = (\\<lambda>x y. eval rh [x, y])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rh.\n        \\<lbrakk>recfn 2 rh; Partial_Recursive.total rh;\n         h = (\\<lambda>x y. eval rh [x, y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R2E[OF assms(2)]"], ["proof (prove)\nusing this:\n  (\\<And>r.\n      \\<lbrakk>recfn 2 r; Partial_Recursive.total r;\n       h =\n       (\\<lambda>x\\<^sub>1 x\\<^sub>2.\n           eval r [x\\<^sub>1, x\\<^sub>2])\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rh.\n        \\<lbrakk>recfn 2 rh; Partial_Recursive.total rh;\n         h = (\\<lambda>x y. eval rh [x, y])\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 2 rh\n  Partial_Recursive.total rh\n  h = (\\<lambda>x y. eval rh [x, y])\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n  recfn 2 rh\n  Partial_Recursive.total rh\n  h = (\\<lambda>x y. eval rh [x, y])", "obtain m n where\n    \"\\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval rg [m, n]), x]\"\n    \"\\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval rh [m, n]), x]\""], ["proof (prove)\nusing this:\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n  recfn 2 rh\n  Partial_Recursive.total rh\n  h = (\\<lambda>x y. eval rh [x, y])\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<forall>x.\n                    eval r_phi [m, x] =\n                    eval r_phi [the (eval rg [m, n]), x];\n         \\<forall>x.\n            eval r_phi [n, x] =\n            eval r_phi [the (eval rh [m, n]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using smullyan_double_fixed_point_theorem[of rg rh]"], ["proof (prove)\nusing this:\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n  recfn 2 rh\n  Partial_Recursive.total rh\n  h = (\\<lambda>x y. eval rh [x, y])\n  \\<lbrakk>recfn 2 rg; Partial_Recursive.total rg; recfn 2 rh;\n   Partial_Recursive.total rh\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m n.\n                       (\\<forall>x.\n                           eval r_phi [m, x] =\n                           eval r_phi [the (eval rg [m, n]), x]) \\<and>\n                       (\\<forall>x.\n                           eval r_phi [n, x] =\n                           eval r_phi [the (eval rh [m, n]), x])\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<forall>x.\n                    eval r_phi [m, x] =\n                    eval r_phi [the (eval rg [m, n]), x];\n         \\<forall>x.\n            eval r_phi [n, x] =\n            eval r_phi [the (eval rh [m, n]), x]\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval rg [m, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval rh [m, n]), x]\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval rg [m, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval rh [m, n]), x]", "have \"\\<phi> m = \\<phi> (the (g m n))\" and \"\\<phi> n = \\<phi> (the (h m n))\""], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval rg [m, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval rh [m, n]), x]\n\ngoal (1 subgoal):\n 1. \\<phi> m = \\<phi> (the (g m n)) &&& \\<phi> n = \\<phi> (the (h m n))", "using phi_def rg rh"], ["proof (prove)\nusing this:\n  \\<forall>x. eval r_phi [m, x] = eval r_phi [the (eval rg [m, n]), x]\n  \\<forall>x. eval r_phi [n, x] = eval r_phi [the (eval rh [m, n]), x]\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  recfn 2 rg\n  Partial_Recursive.total rg\n  g = (\\<lambda>x y. eval rg [x, y])\n  recfn 2 rh\n  Partial_Recursive.total rh\n  h = (\\<lambda>x y. eval rh [x, y])\n\ngoal (1 subgoal):\n 1. \\<phi> m = \\<phi> (the (g m n)) &&& \\<phi> n = \\<phi> (the (h m n))", "by auto"], ["proof (state)\nthis:\n  \\<phi> m = \\<phi> (the (g m n))\n  \\<phi> n = \\<phi> (the (h m n))\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (g m n));\n         \\<phi> n = \\<phi> (the (h m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  \\<phi> m = \\<phi> (the (g m n))\n  \\<phi> n = \\<phi> (the (h m n))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> m = \\<phi> (the (g m n))\n  \\<phi> n = \\<phi> (the (h m n))\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<phi> m = \\<phi> (the (g m n))\n  \\<phi> n = \\<phi> (the (h m n))\n  \\<lbrakk>\\<phi> ?m = \\<phi> (the (g ?m ?n));\n   \\<phi> ?n = \\<phi> (the (h ?m ?n))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by simp"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}