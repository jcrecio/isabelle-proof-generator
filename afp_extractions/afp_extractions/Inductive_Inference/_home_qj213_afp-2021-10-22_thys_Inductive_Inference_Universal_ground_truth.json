{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/Universal.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma step_reachable [intro]:\n  assumes \"step x = y\"\n  shows \"reachable x y\"", "lemma reachable_transitive [trans]:\n  assumes \"reachable x y\" and \"reachable y z\"\n  shows \"reachable x z\"", "lemma reachable_refl: \"reachable x x\"", "lemma step_empty_stack:\n  assumes \"fst x = []\"\n  shows \"fst (step x) = []\"", "lemma reachable_empty_stack:\n  assumes \"fst x = []\" and \"reachable x y\"\n  shows \"fst y = []\"", "lemma reachable_nonterminating:\n  assumes \"reachable x y\" and \"nonterminating y\"\n  shows \"nonterminating x\"", "lemma valid_frame: \"valid (s # ss) \\<Longrightarrow> valid ss \\<and> recfn (length (fst (snd s))) (fst s)\"", "lemma valid_ConsE: \"valid ((f, xs, locs) # rest) \\<Longrightarrow> valid rest \\<and> recfn (length xs) f\"", "lemma valid_ConsI: \"valid rest \\<Longrightarrow> recfn (length xs) f \\<Longrightarrow> valid ((f, xs, locs) # rest)\"", "lemma step_valid: \"valid stack \\<Longrightarrow> valid (fst (step (stack, rv)))\"", "lemma correct_convergI:\n  assumes \"eval f xs \\<down>\" and \"reachable ((f, xs, ls) # rest, None) (rest, eval f xs)\"\n  shows \"correct ((f, xs, ls) # rest, None)\"", "lemma correct_convergE:\n  assumes \"correct ((f, xs, ls) # rest, None)\" and \"eval f xs \\<down>\"\n  shows \"reachable ((f, xs, ls) # rest, None) (rest, eval f xs)\"", "lemma reachable_Cn:\n  assumes \"valid (((Cn n f gs), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>g xs rest.\n      g \\<in> set gs \\<Longrightarrow> valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n    and \"\\<forall>i<k. eval (gs ! i) xs \\<down>\"\n    and \"k \\<le> length gs\"\n  shows \"reachable\n    (?stack, None)\n    ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest, None)\"", "lemma step_Cn_correct:\n  assumes \"valid (((Cn n f gs), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>g xs rest.\n      g \\<in> set gs \\<Longrightarrow> valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\"", "lemma trace_length: \"length (trace n f g xs x) = Suc x\"", "lemma trace_hd: \"hd (trace n f g xs x) = the (eval (Pr n f g) (x # xs))\"", "lemma trace_Suc:\n  \"trace n f g xs (Suc x) = (the (eval (Pr n f g) (Suc x # xs))) # (trace n f g xs x)\"", "lemma reachable_Pr:\n  assumes \"valid (((Pr n f g), x # xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>xs rest. valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n    and \"y \\<le> x\"\n    and \"eval (Pr n f g) (y # xs) \\<down>\"\n  shows \"reachable (?stack, None) ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\"", "lemma step_Pr_correct:\n  assumes \"valid (((Pr n f g), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>xs rest. valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\"", "lemma reachable_Mn:\n  assumes \"valid ((Mn n f, xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}\"\n  shows \"reachable (?stack, None) ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\"", "lemma iterate_step_empty_stack: \"iterate t step ([], rv) = ([], rv)\"", "lemma reachable_iterate_step_empty_stack:\n  assumes \"reachable cfg ([], rv)\"\n  shows \"\\<exists>t. iterate t step cfg = ([], rv) \\<and> (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])\"", "lemma step_Mn_correct:\n  assumes \"valid ((Mn n f, xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\"", "theorem step_correct:\n  assumes \"valid ((f, xs, []) # rest)\"\n  shows \"correct ((f, xs, []) # rest, None)\"", "lemma prod_encode_gr1: \"a > 1 \\<Longrightarrow> prod_encode (a, x) > 1\"", "lemma encode_not_Z_or_S: \"encode f = prod_encode (a, b) \\<Longrightarrow> a > 1 \\<Longrightarrow> f \\<noteq> Z \\<and> f \\<noteq> S\"", "lemma encode_injective: \"encode f = encode g \\<Longrightarrow> f = g\"", "lemma encode_kind_0: \"encode_kind (encode Z) = 0\"", "lemma encode_kind_1: \"encode_kind (encode S) = 1\"", "lemma encode_kind_2: \"encode_kind (encode (Id m n)) = 2\"", "lemma encode_kind_3: \"encode_kind (encode (Cn n f gs)) = 3\"", "lemma encode_kind_4: \"encode_kind (encode (Pr n f g)) = 4\"", "lemma encode_kind_5: \"encode_kind (encode (Mn n f)) = 5\"", "lemmas encode_kind_n =\n  encode_kind_0 encode_kind_1 encode_kind_2 encode_kind_3 encode_kind_4 encode_kind_5", "lemma encode_kind_Cn:\n  assumes \"encode_kind (encode f) = 3\"\n  shows \"\\<exists>n f' gs. f = Cn n f' gs\"", "lemma encode_kind_Pr:\n  assumes \"encode_kind (encode f) = 4\"\n  shows \"\\<exists>n f' g. f = Pr n f' g\"", "lemma encode_kind_Mn:\n  assumes \"encode_kind (encode f) = 5\"\n  shows \"\\<exists>n g. f = Mn n g\"", "lemma pdec2_encode_Id: \"pdec2 (encode (Id m n)) = prod_encode (m, n)\"", "lemma pdec2_encode_Pr: \"pdec2 (encode (Pr n f g)) = triple_encode n (encode f) (encode g)\"", "lemma encode_frame:\n  \"encode_frame (f, xs, ls) = triple_encode (encode f) (list_encode xs) (list_encode ls)\"", "lemma encode_config:\n  \"encode_config (ss, rv) = prod_encode (list_encode (map encode_frame ss), encode_option rv)\"", "lemma e2rv_rv [simp]:\n  \"e2rv (encode_config (ss, rv)) = (if rv \\<up> then 0 else Suc (the rv))\"", "lemma e2stack_stack [simp]:\n  \"e2stack (encode_config (ss, rv)) = list_encode (map encode_frame ss)\"", "lemma e2tail_tail [simp]:\n  \"e2tail (encode_config (s # ss, rv)) = list_encode (map encode_frame ss)\"", "lemma e2frame_frame [simp]:\n  \"e2frame (encode_config (s # ss, rv)) = encode_frame s\"", "lemma e2i_f [simp]:\n  \"e2i (encode_config ((f, xs, ls) # ss, rv)) = encode f\"", "lemma e2xs_xs [simp]:\n  \"e2xs (encode_config ((f, xs, ls) # ss, rv)) = list_encode xs\"", "lemma e2ls_ls [simp]:\n  \"e2ls (encode_config ((f, xs, ls) # ss, rv)) = list_encode ls\"", "lemma e2lenas_lenas [simp]:\n  \"e2lenas (encode_config ((f, xs, ls) # ss, rv)) = length xs\"", "lemma e2lenls_lenls [simp]:\n  \"e2lenls (encode_config ((f, xs, ls) # ss, rv)) = length ls\"", "lemma e2stack_0_iff_Nil:\n  assumes \"e = encode_config (ss, rv)\"\n  shows \"e2stack e = 0 \\<longleftrightarrow>  ss = []\"", "lemma e2ls_0_iff_Nil [simp]: \"list_decode (e2ls e) = [] \\<longleftrightarrow> e2ls e = 0\"", "lemma estep_Cn:\n  assumes \"c = (((Cn n f gs, xs, ls) # fs), rv)\"\n  shows \"estep_Cn (encode_config c) = encode_config (step c)\"", "lemma estep_Pr1:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls \\<noteq> Suc (hd xs)\"\n    and \"rv \\<noteq> None\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\"", "lemma estep_Pr2:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls \\<noteq> Suc (hd xs)\"\n    and \"rv = None\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\"", "lemma estep_Pr3:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls = Suc (hd xs)\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\"", "lemma estep_Pr4:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\" and \"ls = []\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\"", "lemma estep_Pr:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\"", "lemma estep_Mn:\n  assumes \"c = (((Mn n f, xs, ls) # fs), rv)\"\n  shows \"estep_Mn (encode_config c) = encode_config (step c)\"", "lemma estep_Z:\n  assumes \"c = (((Z, xs, ls) # fs), rv)\"\n  shows \"estep (encode_config c) = encode_config (step c)\"", "lemma estep_S:\n  assumes \"c = (((S, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (fst (hd (fst c)))\"\n  shows \"estep (encode_config c) = encode_config (step c)\"", "lemma estep_Id:\n  assumes \"c = (((Id m n, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (fst (hd (fst c)))\"\n  shows \"estep (encode_config c) = encode_config (step c)\"", "lemma estep:\n  assumes \"valid (fst c)\"\n  shows \"estep (encode_config c) = encode_config (step c)\"", "lemma r_e2stack_prim: \"prim_recfn 1 r_e2stack\"", "lemma r_e2stack [simp]: \"eval r_e2stack [e] \\<down>= e2stack e\"", "lemma r_e2rv_prim: \"prim_recfn 1 r_e2rv\"", "lemma r_e2rv [simp]: \"eval r_e2rv [e] \\<down>= e2rv e\"", "lemma r_e2tail_prim: \"prim_recfn 1 r_e2tail\"", "lemma r_e2tail [simp]: \"eval r_e2tail [e] \\<down>= e2tail e\"", "lemma r_e2frame_prim: \"prim_recfn 1 r_e2frame\"", "lemma r_e2frame [simp]: \"eval r_e2frame [e] \\<down>= e2frame e\"", "lemma r_e2i_prim: \"prim_recfn 1 r_e2i\"", "lemma r_e2i [simp]: \"eval r_e2i [e] \\<down>= e2i e\"", "lemma r_e2xs_prim: \"prim_recfn 1 r_e2xs\"", "lemma r_e2xs [simp]: \"eval r_e2xs [e] \\<down>= e2xs e\"", "lemma r_e2ls_prim: \"prim_recfn 1 r_e2ls\"", "lemma r_e2ls [simp]: \"eval r_e2ls [e] \\<down>= e2ls e\"", "lemma r_e2lenls_prim: \"prim_recfn 1 r_e2lenls\"", "lemma r_e2lenls [simp]: \"eval r_e2lenls [e] \\<down>= e2lenls e\"", "lemma r_kind_prim: \"prim_recfn 1 r_kind\"", "lemma r_kind: \"eval r_kind [e] \\<down>= encode_kind e\"", "lemmas helpers_for_r_step_prim =\n  r_e2i_prim\n  r_e2lenls_prim\n  r_e2ls_prim\n  r_e2rv_prim\n  r_e2xs_prim\n  r_e2stack_prim\n  r_e2tail_prim\n  r_e2frame_prim", "lemma r_step_Id:\n  \"eval r_step_Id [e] \\<down>= prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))\"", "lemma r_step_Cn_prim: \"prim_recfn 1 r_step_Cn\"", "lemma r_step_Cn: \"eval r_step_Cn [e] \\<down>= estep_Cn e\"", "lemma r_step_Pr_prim: \"prim_recfn 1 r_step_Pr\"", "lemma r_step_Pr: \"eval r_step_Pr [e] \\<down>= estep_Pr e\"", "lemma r_step_Mn_prim: \"prim_recfn 1 r_step_Mn\"", "lemma r_step_Mn: \"eval r_step_Mn [e] \\<down>= estep_Mn e\"", "lemma r_step_prim: \"prim_recfn 1 r_step\"", "lemma r_step: \"eval r_step [e] \\<down>= estep e\"", "theorem r_step_equiv_step:\n  assumes \"valid (fst c)\"\n  shows \"eval r_step [encode_config c] \\<down>= encode_config (step c)\"", "lemma r_leap_prim [simp]: \"prim_recfn 3 r_leap\"", "lemma r_leap_total: \"eval r_leap [t, i, x] \\<down>\"", "lemma r_leap:\n  assumes \"i = encode f\" and \"recfn (e_length x) f\"\n  shows \"eval r_leap [t, i, x] \\<down>= encode_config (iterate t step ([(f, list_decode x, [])], None))\"", "lemma step_leaves_empty_stack_empty:\n  assumes \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"iterate (t + t') step ([(f, list_decode x, [])], None) = ([], Some v)\"", "lemma r_result_prim [simp]: \"prim_recfn 3 r_result\"", "lemma r_result_total: \"total r_result\"", "lemma r_result_empty_stack_None:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], None)\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\"", "lemma r_result_empty_stack_Some:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"eval r_result [t, i, x] \\<down>= Suc v\"", "lemma r_result_empty_stack_stays:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"eval r_result [t + t', i, x] \\<down>= Suc v\"", "lemma r_result_nonempty_stack:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"fst (iterate t step ([(f, list_decode x, [])], None)) \\<noteq> []\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\"", "lemma r_result_Suc:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n    (is \"?cfg = _\")", "lemma r_result_converg:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval f (list_decode x) \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n    (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\"", "lemma r_result_diverg:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval f (list_decode x) \\<up>\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\"", "lemma r_univ_recfn [simp]: \"recfn 2 r_univ\"", "theorem r_univ:\n  assumes \"i = encode f\" and \"recfn (e_length x) f\"\n  shows \"eval r_univ [i, x] = eval f (list_decode x)\"", "theorem r_univ':\n  assumes \"recfn (e_length x) f\"\n  shows \"eval r_univ [encode f, x] = eval f (list_decode x)\"", "lemma r_universal_recfn [simp]: \"n > 0 \\<Longrightarrow> recfn (Suc n) (r_universal n)\"", "lemma r_universal:\n  assumes \"recfn n f\" and \"length xs = n\"\n  shows \"eval (r_universal n) (encode f # xs) = eval f xs\"", "lemma r_result1_prim [simp]: \"prim_recfn 3 r_result1\"", "lemma r_result1_total: \"total r_result1\"", "lemma r_result1 [simp]:\n  \"eval r_result1 [t, i, x] = eval r_result [t, i, singleton_encode x]\"", "lemma r_phi_recfn [simp]: \"recfn 2 r_phi\"", "theorem r_phi:\n  assumes \"i = encode f\" and \"recfn 1 f\"\n  shows \"eval r_phi [i, x] = eval f [x]\"", "lemma r_phi'': \"eval r_phi [i, x] = eval r_univ [i, singleton_encode x]\"", "lemma r_lazyifzero_recfn: \"recfn (Suc (Suc n)) (r_lazyifzero n j\\<^sub>1 j\\<^sub>2)\"", "lemma r_lazyifzero:\n  assumes \"length xs = Suc n\"\n    and \"j\\<^sub>1 = encode f\\<^sub>1\"\n    and \"j\\<^sub>2 = encode f\\<^sub>2\"\n    and \"recfn (Suc n) f\\<^sub>1\"\n    and \"recfn (Suc n) f\\<^sub>2\"\n  shows \"eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) = (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)\"", "lemma r_lifz_recfn [simp]:\n  assumes \"recfn n f\" and \"recfn n g\"\n  shows \"recfn (Suc n) (r_lifz f g)\"", "lemma r_lifz [simp]:\n  assumes \"length xs = n\" and \"recfn n f\" and \"recfn n g\"\n  shows \"eval (r_lifz f g) (c # xs) = (if c = 0 then eval f xs else eval g xs)\"", "lemma r_leap_Suc: \"eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]\"", "lemma r_leap_Suc_saturating:\n  assumes \"pdec1 (the (eval r_leap [t, i, x])) = 0\"\n  shows \"eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\"", "lemma r_result_Suc_saturating:\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result [Suc t, i, x] \\<down>= Suc v\"", "lemma r_result_saturating:\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result [t + d, i, x] \\<down>= Suc v\"", "lemma r_result_converg':\n  assumes \"eval r_univ [i, x] \\<down>= v\"\n  shows \"\\<exists>t. (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and> (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\"", "lemma r_result_diverg':\n  assumes \"eval r_univ [i, x] \\<up>\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\"", "lemma r_result_bivalent':\n  assumes \"eval r_univ [i, x] \\<down>= v\"\n  shows \"eval r_result [t, i, x] \\<down>= Suc v \\<or> eval r_result [t, i, x] \\<down>= 0\"", "lemma r_result_Some':\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_univ [i, x] \\<down>= v\"", "lemma r_result1_converg':\n  assumes \"eval r_phi [i, x] \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n    (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)\"", "lemma r_result1_diverg':\n  assumes \"eval r_phi [i, x] \\<up>\"\n  shows \"eval r_result1 [t, i, x] \\<down>= 0\"", "lemma r_result1_Some':\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_phi [i, x] \\<down>= v\"", "lemma r_dovetail_prim: \"prim_recfn 2 r_dovetail\"", "lemma r_dovetail:\n  \"eval r_dovetail [i, z] \\<down>=\n    (if the (eval r_result1 [pdec2 z, i, pdec1 z]) > 0 then 0 else 1)\"", "lemma r_dovedelay_prim: \"prim_recfn 3 r_dovedelay\"", "lemma r_dovedelay:\n  \"eval r_dovedelay [z, i, y] \\<down>=\n    (if the (eval r_result1 [pdec2 z, i, pdec1 z]) > 0 \\<and> y \\<le> z then 0 else 1)\"", "lemma r_enumdom_recfn [simp]: \"recfn 2 r_enumdom\"", "lemma r_enumdom [simp]:\n  \"eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)\"", "lemma r_enumdom_empty_domain:\n  assumes \"\\<And>x. eval r_phi [i, x] \\<up>\"\n  shows \"\\<And>y. eval r_enumdom [i, y] \\<up>\"", "lemma r_enumdom_nonempty_domain:\n  assumes \"eval r_phi [i, x\\<^sub>0] \\<down>\"\n  shows \"\\<And>y. eval r_enumdom [i, y] \\<down>\"\n    and \"\\<And>x. eval r_phi [i, x] \\<down> \\<longleftrightarrow> (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)\"", "lemma nonempty_domain_enumerable:\n  assumes \"eval r_phi [i, x\\<^sub>0] \\<down>\"\n  shows \"\\<exists>g. recfn 1 g \\<and> total g \\<and> (\\<forall>x. eval r_phi [i, x] \\<down> \\<longleftrightarrow> (\\<exists>y. eval g [y] \\<down>= x))\"", "lemma r_both_prim [simp]: \"prim_recfn 4 r_both\"", "lemma r_both:\n  assumes \"\\<And>x. eval r_phi [i, x] = eval f [x]\"\n    and \"\\<And>x. eval r_phi [j, x] = eval g [x]\"\n  shows \"eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\"\n    and \"\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0; eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk> \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\"\n    and \"eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\"\n    and \"\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0; eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk> \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\"", "lemma r_parallel_recfn [simp]: \"recfn 3 r_parallel\"", "lemma r_parallel:\n  assumes \"\\<And>x. eval r_phi [i, x] = eval f [x]\"\n    and \"\\<And>x. eval r_phi [j, x] = eval g [x]\"\n  shows \"eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow> eval r_parallel [i, j, x] \\<up>\"\n    and \"eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\"\n    and \"eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\"\n    and \"eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], "translations": [["", "lemma step_reachable [intro]:\n  assumes \"step x = y\"\n  shows \"reachable x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable x y", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. iterate t step x = y", "using assms"], ["proof (prove)\nusing this:\n  step x = y\n\ngoal (1 subgoal):\n 1. \\<exists>t. iterate t step x = y", "by (metis iterate.simps(1,2) comp_id)"], ["", "lemma reachable_transitive [trans]:\n  assumes \"reachable x y\" and \"reachable y z\"\n  shows \"reachable x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable x z", "using assms iterate_additive[where ?f=step] reachable_def"], ["proof (prove)\nusing this:\n  reachable x y\n  reachable y z\n  \\<lbrakk>iterate ?t\\<^sub>1 step ?x = ?y;\n   iterate ?t\\<^sub>2 step ?y = ?z\\<rbrakk>\n  \\<Longrightarrow> iterate (?t\\<^sub>1 + ?t\\<^sub>2) step ?x = ?z\n  reachable ?x ?y \\<equiv> \\<exists>t. iterate t step ?x = ?y\n\ngoal (1 subgoal):\n 1. reachable x z", "by metis"], ["", "lemma reachable_refl: \"reachable x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable x x", "unfolding reachable_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t. iterate t step x = x", "by (metis iterate.simps(1) eq_id_iff)"], ["", "text \\<open>From a final configuration, that is, when the stack is empty,\nonly final configurations are reachable.\\<close>"], ["", "lemma step_empty_stack:\n  assumes \"fst x = []\"\n  shows \"fst (step x) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (step x) = []", "using assms"], ["proof (prove)\nusing this:\n  fst x = []\n\ngoal (1 subgoal):\n 1. fst (step x) = []", "by (metis prod.collapse step.simps(1))"], ["", "lemma reachable_empty_stack:\n  assumes \"fst x = []\" and \"reachable x y\"\n  shows \"fst y = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst y = []", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst y = []", "have \"fst (iterate t step x) = []\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (iterate t step x) = []", "using assms step_empty_stack"], ["proof (prove)\nusing this:\n  fst x = []\n  reachable x y\n  fst ?x = [] \\<Longrightarrow> fst (step ?x) = []\n\ngoal (1 subgoal):\n 1. fst (iterate t step x) = []", "by (induction t) simp_all"], ["proof (state)\nthis:\n  fst (iterate ?t step x) = []\n\ngoal (1 subgoal):\n 1. fst y = []", "then"], ["proof (chain)\npicking this:\n  fst (iterate ?t step x) = []", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (iterate ?t step x) = []\n\ngoal (1 subgoal):\n 1. fst y = []", "using reachable_def assms(2)"], ["proof (prove)\nusing this:\n  fst (iterate ?t step x) = []\n  reachable ?x ?y \\<equiv> \\<exists>t. iterate t step ?x = ?y\n  reachable x y\n\ngoal (1 subgoal):\n 1. fst y = []", "by auto"], ["proof (state)\nthis:\n  fst y = []\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation nonterminating :: \"configuration \\<Rightarrow> bool\" where\n  \"nonterminating x \\<equiv> \\<forall>t. fst (iterate t step x) \\<noteq> []\""], ["", "lemma reachable_nonterminating:\n  assumes \"reachable x y\" and \"nonterminating y\"\n  shows \"nonterminating x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonterminating x", "from assms(1)"], ["proof (chain)\npicking this:\n  reachable x y", "obtain t\\<^sub>1 where t1: \"iterate t\\<^sub>1 step x = y\""], ["proof (prove)\nusing this:\n  reachable x y\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>1.\n        iterate t\\<^sub>1 step x = y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using reachable_def"], ["proof (prove)\nusing this:\n  reachable x y\n  reachable ?x ?y \\<equiv> \\<exists>t. iterate t step ?x = ?y\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>1.\n        iterate t\\<^sub>1 step x = y \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  iterate t\\<^sub>1 step x = y\n\ngoal (1 subgoal):\n 1. nonterminating x", "have \"fst (iterate t step x) \\<noteq> []\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (iterate t step x) \\<noteq> []", "proof (cases \"t \\<le> t\\<^sub>1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<le> t\\<^sub>1 \\<Longrightarrow> fst (iterate t step x) \\<noteq> []\n 2. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "case True"], ["proof (state)\nthis:\n  t \\<le> t\\<^sub>1\n\ngoal (2 subgoals):\n 1. t \\<le> t\\<^sub>1 \\<Longrightarrow> fst (iterate t step x) \\<noteq> []\n 2. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  t \\<le> t\\<^sub>1", "show ?thesis"], ["proof (prove)\nusing this:\n  t \\<le> t\\<^sub>1\n\ngoal (1 subgoal):\n 1. fst (iterate t step x) \\<noteq> []", "using t1 assms(2) reachable_def reachable_empty_stack iterate_additive'"], ["proof (prove)\nusing this:\n  t \\<le> t\\<^sub>1\n  iterate t\\<^sub>1 step x = y\n  nonterminating y\n  reachable ?x ?y \\<equiv> \\<exists>t. iterate t step ?x = ?y\n  \\<lbrakk>fst ?x = []; reachable ?x ?y\\<rbrakk>\n  \\<Longrightarrow> fst ?y = []\n  iterate (?t\\<^sub>1 + ?t\\<^sub>2) ?f ?x =\n  iterate ?t\\<^sub>2 ?f (iterate ?t\\<^sub>1 ?f ?x)\n\ngoal (1 subgoal):\n 1. fst (iterate t step x) \\<noteq> []", "by (metis le_Suc_ex)"], ["proof (state)\nthis:\n  fst (iterate t step x) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "case False"], ["proof (state)\nthis:\n  \\<not> t \\<le> t\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  \\<not> t \\<le> t\\<^sub>1", "have \"iterate t step x = iterate (t\\<^sub>1 + (t - t\\<^sub>1)) step x\""], ["proof (prove)\nusing this:\n  \\<not> t \\<le> t\\<^sub>1\n\ngoal (1 subgoal):\n 1. iterate t step x = iterate (t\\<^sub>1 + (t - t\\<^sub>1)) step x", "by simp"], ["proof (state)\nthis:\n  iterate t step x = iterate (t\\<^sub>1 + (t - t\\<^sub>1)) step x\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  iterate t step x = iterate (t\\<^sub>1 + (t - t\\<^sub>1)) step x", "have \"iterate t step x = iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)\""], ["proof (prove)\nusing this:\n  iterate t step x = iterate (t\\<^sub>1 + (t - t\\<^sub>1)) step x\n\ngoal (1 subgoal):\n 1. iterate t step x =\n    iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)", "by (simp add: iterate_additive')"], ["proof (state)\nthis:\n  iterate t step x = iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  iterate t step x = iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)", "have \"iterate t step x = iterate (t - t\\<^sub>1) step y\""], ["proof (prove)\nusing this:\n  iterate t step x = iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)\n\ngoal (1 subgoal):\n 1. iterate t step x = iterate (t - t\\<^sub>1) step y", "using t1"], ["proof (prove)\nusing this:\n  iterate t step x = iterate (t - t\\<^sub>1) step (iterate t\\<^sub>1 step x)\n  iterate t\\<^sub>1 step x = y\n\ngoal (1 subgoal):\n 1. iterate t step x = iterate (t - t\\<^sub>1) step y", "by simp"], ["proof (state)\nthis:\n  iterate t step x = iterate (t - t\\<^sub>1) step y\n\ngoal (1 subgoal):\n 1. \\<not> t \\<le> t\\<^sub>1 \\<Longrightarrow>\n    fst (iterate t step x) \\<noteq> []", "then"], ["proof (chain)\npicking this:\n  iterate t step x = iterate (t - t\\<^sub>1) step y", "show \"fst (iterate t step x) \\<noteq> []\""], ["proof (prove)\nusing this:\n  iterate t step x = iterate (t - t\\<^sub>1) step y\n\ngoal (1 subgoal):\n 1. fst (iterate t step x) \\<noteq> []", "using assms(2)"], ["proof (prove)\nusing this:\n  iterate t step x = iterate (t - t\\<^sub>1) step y\n  nonterminating y\n\ngoal (1 subgoal):\n 1. fst (iterate t step x) \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  fst (iterate t step x) \\<noteq> []\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (iterate ?t step x) \\<noteq> []\n\ngoal (1 subgoal):\n 1. nonterminating x", "then"], ["proof (chain)\npicking this:\n  fst (iterate ?t step x) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (iterate ?t step x) \\<noteq> []\n\ngoal (1 subgoal):\n 1. nonterminating x", ".."], ["proof (state)\nthis:\n  nonterminating x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The function @{term step} is underdefined, for example, when the\ntop frame contains a non-well-formed @{typ recf} or too few arguments. All is\nwell, though, if every frame contains a well-formed @{typ recf} whose arity\nmatches the number of arguments. Such stacks will be called\n\\emph{valid}.\\<close>"], ["", "definition valid :: \"frame list \\<Rightarrow> bool\" where\n  \"valid stack \\<equiv> \\<forall>s\\<in>set stack. recfn (length (fst (snd s))) (fst s)\""], ["", "lemma valid_frame: \"valid (s # ss) \\<Longrightarrow> valid ss \\<and> recfn (length (fst (snd s))) (fst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (s # ss) \\<Longrightarrow>\n    valid ss \\<and> recfn (length (fst (snd s))) (fst s)", "using valid_def"], ["proof (prove)\nusing this:\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (s # ss) \\<Longrightarrow>\n    valid ss \\<and> recfn (length (fst (snd s))) (fst s)", "by simp"], ["", "lemma valid_ConsE: \"valid ((f, xs, locs) # rest) \\<Longrightarrow> valid rest \\<and> recfn (length xs) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid ((f, xs, locs) # rest) \\<Longrightarrow>\n    valid rest \\<and> recfn (length xs) f", "using valid_def"], ["proof (prove)\nusing this:\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid ((f, xs, locs) # rest) \\<Longrightarrow>\n    valid rest \\<and> recfn (length xs) f", "by simp"], ["", "lemma valid_ConsI: \"valid rest \\<Longrightarrow> recfn (length xs) f \\<Longrightarrow> valid ((f, xs, locs) # rest)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>valid rest; recfn (length xs) f\\<rbrakk>\n    \\<Longrightarrow> valid ((f, xs, locs) # rest)", "using valid_def"], ["proof (prove)\nusing this:\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>valid rest; recfn (length xs) f\\<rbrakk>\n    \\<Longrightarrow> valid ((f, xs, locs) # rest)", "by simp"], ["", "text \\<open>Stacks in initial configurations are valid, and performing a step\nmaintains the validity of the stack.\\<close>"], ["", "lemma step_valid: \"valid stack \\<Longrightarrow> valid (fst (step (stack, rv)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid stack \\<Longrightarrow> valid (fst (step (stack, rv)))", "proof (cases stack)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>valid stack; stack = []\\<rbrakk>\n    \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "case Nil"], ["proof (state)\nthis:\n  stack = []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>valid stack; stack = []\\<rbrakk>\n    \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  stack = []", "show ?thesis"], ["proof (prove)\nusing this:\n  stack = []\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using valid_def"], ["proof (prove)\nusing this:\n  stack = []\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by simp"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "case (Cons s ss)"], ["proof (state)\nthis:\n  stack = s # ss\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "assume valid: \"valid stack\""], ["proof (state)\nthis:\n  valid stack\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  valid stack", "have *: \"valid ss \\<and> recfn (length (fst (snd s))) (fst s)\""], ["proof (prove)\nusing this:\n  valid stack\n\ngoal (1 subgoal):\n 1. valid ss \\<and> recfn (length (fst (snd s))) (fst s)", "using valid_frame Cons"], ["proof (prove)\nusing this:\n  valid stack\n  valid (?s # ?ss) \\<Longrightarrow>\n  valid ?ss \\<and> recfn (length (fst (snd ?s))) (fst ?s)\n  stack = s # ss\n\ngoal (1 subgoal):\n 1. valid ss \\<and> recfn (length (fst (snd s))) (fst s)", "by simp"], ["proof (state)\nthis:\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>valid stack; stack = a # list\\<rbrakk>\n       \\<Longrightarrow> valid (fst (step (stack, rv)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "proof (cases \"fst s\")"], ["proof (state)\ngoal (6 subgoals):\n 1. fst s = Z \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. fst s = S \\<Longrightarrow> valid (fst (step (stack, rv)))\n 3. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 5. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 6. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case Z"], ["proof (state)\nthis:\n  fst s = Z\n\ngoal (6 subgoals):\n 1. fst s = Z \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. fst s = S \\<Longrightarrow> valid (fst (step (stack, rv)))\n 3. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 5. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 6. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = Z", "show ?thesis"], ["proof (prove)\nusing this:\n  fst s = Z\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using Cons valid *"], ["proof (prove)\nusing this:\n  fst s = Z\n  stack = s # ss\n  valid stack\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (metis fstI prod.collapse step.simps(2))"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (5 subgoals):\n 1. fst s = S \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 5. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. fst s = S \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 5. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case S"], ["proof (state)\nthis:\n  fst s = S\n\ngoal (5 subgoals):\n 1. fst s = S \\<Longrightarrow> valid (fst (step (stack, rv)))\n 2. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 5. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = S", "show ?thesis"], ["proof (prove)\nusing this:\n  fst s = S\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using Cons valid *"], ["proof (prove)\nusing this:\n  fst s = S\n  stack = s # ss\n  valid stack\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (metis fst_conv prod.collapse step.simps(3))"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case Id"], ["proof (state)\nthis:\n  fst s = recf.Id x31_ x32_\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       fst s = recf.Id x31 x32 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 4. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = recf.Id x31_ x32_", "show ?thesis"], ["proof (prove)\nusing this:\n  fst s = recf.Id x31_ x32_\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using Cons valid *"], ["proof (prove)\nusing this:\n  fst s = recf.Id x31_ x32_\n  stack = s # ss\n  valid stack\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (metis fstI prod.collapse step.simps(4))"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case (Cn n f gs)"], ["proof (state)\nthis:\n  fst s = Cn n f gs\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = Cn n f gs", "obtain xs ls where \"s = (Cn n f gs, xs, ls)\""], ["proof (prove)\nusing this:\n  fst s = Cn n f gs\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Cn n f gs, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  fst s = Cn n f gs\n  stack = s # ss\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Cn n f gs, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  s = (Cn n f gs, xs, ls)\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "moreover"], ["proof (state)\nthis:\n  s = (Cn n f gs, xs, ls)\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "consider\n        \"length ls = length gs \\<and> rv \\<up>\"\n      | \"length ls = length gs \\<and> rv \\<down>\"\n      | \"length ls < length gs \\<and> rv \\<up>\"\n      | \"length ls \\<noteq> length gs \\<and> rv \\<down>\"\n      | \"length ls > length gs \\<and> rv \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ls = length gs \\<and> rv \\<up> \\<Longrightarrow> thesis;\n     length ls = length gs \\<and> rv \\<down> \\<Longrightarrow> thesis;\n     length ls < length gs \\<and> rv \\<up> \\<Longrightarrow> thesis;\n     length ls \\<noteq> length gs \\<and> rv \\<down> \\<Longrightarrow>\n     thesis;\n     length gs < length ls \\<and> rv \\<up> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length ls = length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls < length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length gs < length ls \\<and> rv \\<up> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       fst s = Cn x41 x42 x43 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 3. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "ultimately"], ["proof (chain)\npicking this:\n  s = (Cn n f gs, xs, ls)\n  \\<lbrakk>length ls = length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls < length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length gs < length ls \\<and> rv \\<up> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  s = (Cn n f gs, xs, ls)\n  \\<lbrakk>length ls = length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls < length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length gs < length ls \\<and> rv \\<up> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using valid Cons valid_def"], ["proof (prove)\nusing this:\n  s = (Cn n f gs, xs, ls)\n  \\<lbrakk>length ls = length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls < length gs \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> length gs \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length gs < length ls \\<and> rv \\<up> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  valid stack\n  stack = s # ss\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (cases) auto"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case (Pr n f g)"], ["proof (state)\nthis:\n  fst s = Pr n f g\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = Pr n f g", "obtain xs ls where s: \"s = (Pr n f g, xs, ls)\""], ["proof (prove)\nusing this:\n  fst s = Pr n f g\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Pr n f g, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  fst s = Pr n f g\n  stack = s # ss\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Pr n f g, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  s = (Pr n f g, xs, ls)\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "consider\n        \"length ls = 0 \\<and> rv \\<up>\"\n      | \"length ls = 0 \\<and> rv \\<down>\"\n      | \"length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs)\"\n      | \"length ls \\<noteq> 0 \\<and> length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up>\"\n      | \"length ls \\<noteq> 0 \\<and> length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ls = 0 \\<and> rv \\<up> \\<Longrightarrow> thesis;\n     length ls = 0 \\<and> rv \\<down> \\<Longrightarrow> thesis;\n     length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs) \\<Longrightarrow>\n     thesis;\n     length ls \\<noteq> 0 \\<and>\n     length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up> \\<Longrightarrow>\n     thesis;\n     length ls \\<noteq> 0 \\<and>\n     length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length ls = 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs) \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up> \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       fst s = Pr x51 x52 x53 \\<Longrightarrow>\n       valid (fst (step (stack, rv)))\n 2. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ls = 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs) \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up> \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ls = 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs) \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up> \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using Cons * valid_def s"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ls = 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls = 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> length ls = Suc (hd xs) \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<up> \\<Longrightarrow>\n   ?thesis;\n   length ls \\<noteq> 0 \\<and>\n   length ls \\<noteq> Suc (hd xs) \\<and> rv \\<down> \\<Longrightarrow>\n   ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  stack = s # ss\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n  s = (Pr n f g, xs, ls)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (cases) auto"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "case (Mn n f)"], ["proof (state)\nthis:\n  fst s = Mn n f\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  fst s = Mn n f", "obtain xs ls where s: \"s = (Mn n f, xs, ls)\""], ["proof (prove)\nusing this:\n  fst s = Mn n f\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Mn n f, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  fst s = Mn n f\n  stack = s # ss\n\ngoal (1 subgoal):\n 1. (\\<And>xs ls.\n        s = (Mn n f, xs, ls) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  s = (Mn n f, xs, ls)\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "consider\n        \"length ls = 0\"\n      | \"length ls \\<noteq> 0 \\<and> rv \\<up>\"\n      | \"length ls \\<noteq> 0 \\<and> rv \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length ls = 0 \\<Longrightarrow> thesis;\n     length ls \\<noteq> 0 \\<and> rv \\<up> \\<Longrightarrow> thesis;\n     length ls \\<noteq> 0 \\<and> rv \\<down> \\<Longrightarrow>\n     thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>length ls = 0 \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       fst s = Mn x61 x62 \\<Longrightarrow> valid (fst (step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>length ls = 0 \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ls = 0 \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "using Cons * valid_def s"], ["proof (prove)\nusing this:\n  \\<lbrakk>length ls = 0 \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<up> \\<Longrightarrow> ?thesis;\n   length ls \\<noteq> 0 \\<and> rv \\<down> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  stack = s # ss\n  valid ss \\<and> recfn (length (fst (snd s))) (fst s)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n  s = (Mn n f, xs, ls)\n\ngoal (1 subgoal):\n 1. valid (fst (step (stack, rv)))", "by (cases) auto"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  valid (fst (step (stack, rv)))\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary iterate_step_valid:\n  assumes \"valid stack\"\n  shows \"valid (fst (iterate t step (stack, rv)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (fst (iterate t step (stack, rv)))", "using assms"], ["proof (prove)\nusing this:\n  valid stack\n\ngoal (1 subgoal):\n 1. valid (fst (iterate t step (stack, rv)))", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. valid stack \\<Longrightarrow> valid (fst (iterate 0 step (stack, rv)))\n 2. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "case 0"], ["proof (state)\nthis:\n  valid stack\n\ngoal (2 subgoals):\n 1. valid stack \\<Longrightarrow> valid (fst (iterate 0 step (stack, rv)))\n 2. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "then"], ["proof (chain)\npicking this:\n  valid stack", "show ?case"], ["proof (prove)\nusing this:\n  valid stack\n\ngoal (1 subgoal):\n 1. valid (fst (iterate 0 step (stack, rv)))", "by simp"], ["proof (state)\nthis:\n  valid (fst (iterate 0 step (stack, rv)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "case (Suc t)"], ["proof (state)\nthis:\n  valid stack \\<Longrightarrow> valid (fst (iterate t step (stack, rv)))\n  valid stack\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "moreover"], ["proof (state)\nthis:\n  valid stack \\<Longrightarrow> valid (fst (iterate t step (stack, rv)))\n  valid stack\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "have \"iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))", "by simp"], ["proof (state)\nthis:\n  iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<lbrakk>valid stack \\<Longrightarrow>\n                valid (fst (iterate t step (stack, rv)));\n        valid stack\\<rbrakk>\n       \\<Longrightarrow> valid (fst (iterate (Suc t) step (stack, rv)))", "ultimately"], ["proof (chain)\npicking this:\n  valid stack \\<Longrightarrow> valid (fst (iterate t step (stack, rv)))\n  valid stack\n  iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))", "show ?case"], ["proof (prove)\nusing this:\n  valid stack \\<Longrightarrow> valid (fst (iterate t step (stack, rv)))\n  valid stack\n  iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))\n\ngoal (1 subgoal):\n 1. valid (fst (iterate (Suc t) step (stack, rv)))", "using step_valid valid_def"], ["proof (prove)\nusing this:\n  valid stack \\<Longrightarrow> valid (fst (iterate t step (stack, rv)))\n  valid stack\n  iterate (Suc t) step (stack, rv) = step (iterate t step (stack, rv))\n  valid ?stack \\<Longrightarrow> valid (fst (step (?stack, ?rv)))\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. valid (fst (iterate (Suc t) step (stack, rv)))", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  valid (fst (iterate (Suc t) step (stack, rv)))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Correctness of the step function\\<close>"], ["", "text \\<open>The function @{term step} works correctly for a @{typ recf} $f$\non arguments @{term xs} in some configuration if (1) in case $f$ converges, @{term\nstep} reaches a configuration with the topmost frame popped and @{term \"eval\nf xs\"} in the register, and (2) in case $f$ diverges, @{term step} does not\nreach a final configuration.\\<close>"], ["", "fun correct :: \"configuration \\<Rightarrow> bool\" where\n  \"correct ([], r) = True\"\n| \"correct ((f, xs, ls) # rest, r) =\n    (if eval f xs \\<down> then reachable ((f, xs, ls) # rest, r) (rest, eval f xs)\n     else nonterminating ((f, xs, ls) # rest, None))\""], ["", "lemma correct_convergI:\n  assumes \"eval f xs \\<down>\" and \"reachable ((f, xs, ls) # rest, None) (rest, eval f xs)\"\n  shows \"correct ((f, xs, ls) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct ((f, xs, ls) # rest, None)", "using assms"], ["proof (prove)\nusing this:\n  eval f xs \\<down>\n  reachable ((f, xs, ls) # rest, None) (rest, eval f xs)\n\ngoal (1 subgoal):\n 1. correct ((f, xs, ls) # rest, None)", "by auto"], ["", "lemma correct_convergE:\n  assumes \"correct ((f, xs, ls) # rest, None)\" and \"eval f xs \\<down>\"\n  shows \"reachable ((f, xs, ls) # rest, None) (rest, eval f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((f, xs, ls) # rest, None) (rest, eval f xs)", "using assms"], ["proof (prove)\nusing this:\n  correct ((f, xs, ls) # rest, None)\n  eval f xs \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((f, xs, ls) # rest, None) (rest, eval f xs)", "by simp"], ["", "text \\<open>The correctness proof for @{term step} is by structural induction\non the @{typ recf} in the top frame. The base cases @{term Z}, @{term S},\nand @{term[names_short] Id} are simple. For @{text \"X = Cn, Pr, Mn\"}, the\nlemmas named @{text reachable_X} show which configurations are reachable for\n@{typ recf}s of shape @{text X}. Building on those, the lemmas named @{text\nstep_X_correct} show @{term step}'s correctness for @{text X}.\\<close>"], ["", "lemma reachable_Cn:\n  assumes \"valid (((Cn n f gs), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>g xs rest.\n      g \\<in> set gs \\<Longrightarrow> valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n    and \"\\<forall>i<k. eval (gs ! i) xs \\<down>\"\n    and \"k \\<le> length gs\"\n  shows \"reachable\n    (?stack, None)\n    ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using assms(4,5)"], ["proof (prove)\nusing this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n  k \\<le> length gs\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "proof (induction k)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<0. eval (gs ! i) xs \\<down>;\n     0 \\<le> length gs\\<rbrakk>\n    \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                       ((Cn n f gs, xs,\n                         take 0 (map (\\<lambda>g. the (eval g xs)) gs)) #\n                        rest,\n                        None)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "case 0"], ["proof (state)\nthis:\n  \\<forall>i<0. eval (gs ! i) xs \\<down>\n  0 \\<le> length gs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>i<0. eval (gs ! i) xs \\<down>;\n     0 \\<le> length gs\\<rbrakk>\n    \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                       ((Cn n f gs, xs,\n                         take 0 (map (\\<lambda>g. the (eval g xs)) gs)) #\n                        rest,\n                        None)\n 2. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<0. eval (gs ! i) xs \\<down>\n  0 \\<le> length gs", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>i<0. eval (gs ! i) xs \\<down>\n  0 \\<le> length gs\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take 0 (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using reachable_refl"], ["proof (prove)\nusing this:\n  \\<forall>i<0. eval (gs ! i) xs \\<down>\n  0 \\<le> length gs\n  reachable ?x ?x\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take 0 (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take 0 (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "case (Suc k)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "let ?ys = \"map (\\<lambda>g. the (eval g xs)) gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs", "have \"k < length gs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. k < length gs", "by simp"], ["proof (state)\nthis:\n  k < length gs\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "have valid: \"recfn (length xs) (Cn n f gs)\" \"valid rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn n f gs) &&& valid rest", "using assms(1) valid_ConsE[of \"(Cn n f gs)\"]"], ["proof (prove)\nusing this:\n  valid ((Cn n f gs, xs, []) # rest)\n  valid ((Cn n f gs, ?xs, ?locs) # ?rest) \\<Longrightarrow>\n  valid ?rest \\<and> recfn (length ?xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn n f gs) &&& valid rest", "by simp_all"], ["proof (state)\nthis:\n  recfn (length xs) (Cn n f gs)\n  valid rest\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "from Suc"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs", "have \"reachable (?stack, None) ((Cn n f gs, xs, take k ?ys) # rest, None)\"\n      (is \"_ (?stack1, None)\")"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "have \"reachable ... ((gs ! k, xs, []) # ?stack1, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! k, xs, []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using step_reachable \\<open>k < length gs\\<close>"], ["proof (prove)\nusing this:\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n  k < length gs\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! k, xs, []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by (auto simp: min_absorb2)"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((gs ! k, xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((gs ! k, xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "have \"reachable ... (?stack1, eval (gs ! k) xs)\"\n      (is \"_ (_, ?rv)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((gs ! k, xs, []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)", "using Suc.prems(1) \\<open>k < length gs\\<close> assms(3) valid valid_ConsI"], ["proof (prove)\nusing this:\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  k < length gs\n  \\<lbrakk>?g \\<in> set gs; valid ((?g, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?g, ?xs, []) # ?rest, None)\n  recfn (length xs) (Cn n f gs)\n  valid rest\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. reachable\n     ((gs ! k, xs, []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((gs ! k, xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((gs ! k, xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "have \"reachable ... ((Cn n f gs, xs, (take (Suc k) ?ys)) # rest, None)\"\n      (is \"_ (?stack2, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "have \"step (?stack1, ?rv) = ((Cn n f gs, xs, (take k ?ys) @ [the ?rv]) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs) =\n    ((Cn n f gs, xs,\n      take k (map (\\<lambda>g. the (eval g xs)) gs) @\n      [the (eval (gs ! k) xs)]) #\n     rest,\n     None)", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n   k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n  \\<forall>i<Suc k. eval (gs ! i) xs \\<down>\n  Suc k \\<le> length gs\n\ngoal (1 subgoal):\n 1. step\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs) =\n    ((Cn n f gs, xs,\n      take k (map (\\<lambda>g. the (eval g xs)) gs) @\n      [the (eval (gs ! k) xs)]) #\n     rest,\n     None)", "by auto"], ["proof (state)\nthis:\n  step\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs) =\n  ((Cn n f gs, xs,\n    take k (map (\\<lambda>g. the (eval g xs)) gs) @\n    [the (eval (gs ! k) xs)]) #\n   rest,\n   None)\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "also"], ["proof (state)\nthis:\n  step\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs) =\n  ((Cn n f gs, xs,\n    take k (map (\\<lambda>g. the (eval g xs)) gs) @\n    [the (eval (gs ! k) xs)]) #\n   rest,\n   None)\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "have \"... = ((Cn n f gs, xs, (take (Suc k) ?ys)) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Cn n f gs, xs,\n      take k (map (\\<lambda>g. the (eval g xs)) gs) @\n      [the (eval (gs ! k) xs)]) #\n     rest,\n     None) =\n    ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n     rest,\n     None)", "by (simp add: \\<open>k < length gs\\<close> take_Suc_conv_app_nth)"], ["proof (state)\nthis:\n  ((Cn n f gs, xs,\n    take k (map (\\<lambda>g. the (eval g xs)) gs) @\n    [the (eval (gs ! k) xs)]) #\n   rest,\n   None) =\n  ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n   rest,\n   None)\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "finally"], ["proof (chain)\npicking this:\n  step\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs) =\n  ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n   rest,\n   None)", "show ?thesis"], ["proof (prove)\nusing this:\n  step\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs) =\n  ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n   rest,\n   None)\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "using step_reachable"], ["proof (prove)\nusing this:\n  step\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs) =\n  ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n   rest,\n   None)\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      eval (gs ! k) xs)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs)\n   ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    eval (gs ! k) xs)\n   ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>\\<lbrakk>\\<forall>i<k. eval (gs ! i) xs \\<down>;\n                 k \\<le> length gs\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Cn n f gs, xs, []) # rest, None)\n                                   ((Cn n f gs, xs,\n                                     take k\n(map (\\<lambda>g. the (eval g xs)) gs)) #\n                                    rest,\n                                    None);\n        \\<forall>i<Suc k. eval (gs ! i) xs \\<down>;\n        Suc k \\<le> length gs\\<rbrakk>\n       \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                          ((Cn n f gs, xs,\n                            take (Suc k)\n                             (map (\\<lambda>g. the (eval g xs)) gs)) #\n                           rest,\n                           None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)", "show \"reachable (?stack, None) (?stack2, None)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "."], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take (Suc k) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_Cn_correct:\n  assumes \"valid (((Cn n f gs), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>g xs rest.\n      g \\<in> set gs \\<Longrightarrow> valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "have valid: \"recfn (length xs) (Cn n f gs)\" \"valid rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn n f gs) &&& valid rest", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. recfn (length xs) (Cn n f gs) &&& valid rest", "by auto"], ["proof (state)\nthis:\n  recfn (length xs) (Cn n f gs)\n  valid rest\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "let ?ys = \"map (\\<lambda>g. the (eval g xs)) gs\""], ["proof (state)\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "consider\n      (diverg_f) \"\\<forall>g\\<in>set gs. eval g xs \\<down>\" and \"eval f ?ys \\<up>\"\n    | (diverg_gs) \"\\<exists>g\\<in>set gs. eval g xs \\<up>\"\n    | (converg) \"eval (Cn n f gs) xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n              eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow> thesis;\n     eval (Cn n f gs) xs \\<down> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n              eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow> thesis;\n     eval (Cn n f gs) xs \\<down> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n            eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow> ?thesis1;\n   eval (Cn n f gs) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n            eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow> ?thesis1;\n   eval (Cn n f gs) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n            eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow> ?thesis1;\n   eval (Cn n f gs) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "case diverg_f"], ["proof (state)\nthis:\n  \\<forall>g\\<in>set gs. eval g xs \\<down>\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>g\\<in>set gs. eval g xs \\<down>\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>", "have \"\\<forall>i<length gs. eval (gs ! i) xs \\<down>\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>set gs. eval g xs \\<down>\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>i<length gs. eval (gs ! i) xs \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>", "have \"reachable (?stack, None) ((Cn n f gs, xs, ?ys) # rest, None)\"\n        (is \"_ (?stack1, None)\")"], ["proof (prove)\nusing this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)", "using reachable_Cn[OF assms, where ?k=\"length gs\"]"], ["proof (prove)\nusing this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n  \\<lbrakk>\\<And>xs rest.\n              valid ((f, xs, []) # rest) \\<Longrightarrow>\n              valid ((f, xs, []) # rest);\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> g \\<in> set gs;\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> valid ((g, xs, []) # rest);\n   \\<forall>i<length gs. eval (gs ! i) xs \\<down>;\n   length gs \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take (length gs)\n                        (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable ... ((f, ?ys, []) # ?stack1, None)\" (is \"_ (?stack2, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "by (simp add: step_reachable)"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)", "have \"reachable (?stack, None) (?stack2, None)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "."], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"nonterminating (?stack2, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "using diverg_f(2) assms(2)[of ?ys ?stack1] valid_ConsE[OF assms(1)] valid_ConsI"], ["proof (prove)\nusing this:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\n  valid\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) #\n    rest) \\<Longrightarrow>\n  correct\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n  valid rest \\<and> recfn (length xs) (Cn n f gs)\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  nonterminating\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n  nonterminating\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n  nonterminating\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating ((Cn n f gs, xs, []) # rest, None)", "using reachable_nonterminating"], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n  nonterminating\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n  \\<lbrakk>reachable ?x ?y; nonterminating ?y\\<rbrakk>\n  \\<Longrightarrow> nonterminating ?x\n\ngoal (1 subgoal):\n 1. nonterminating ((Cn n f gs, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"eval (Cn n f gs) xs \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<up>", "using diverg_f(2) assms(1) eval_Cn valid_ConsE"], ["proof (prove)\nusing this:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\n  valid ((Cn n f gs, xs, []) # rest)\n  recfn (length ?xs) (Cn ?n ?f ?gs) \\<Longrightarrow>\n  eval (Cn ?n ?f ?gs) ?xs =\n  (if \\<forall>g\\<in>set ?gs. eval g ?xs \\<down>\n   then eval ?f (map (\\<lambda>g. the (eval g ?xs)) ?gs) else None)\n  valid ((?f, ?xs, ?locs) # ?rest) \\<Longrightarrow>\n  valid ?rest \\<and> recfn (length ?xs) ?f\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<up>", "by presburger"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs \\<up>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<forall>g\\<in>set gs. eval g xs \\<down>;\n     eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Cn n f gs, xs, []) # rest, None)\n 2. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 3. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n  eval (Cn n f gs) xs \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n  eval (Cn n f gs) xs \\<up>\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Cn n f gs, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "case diverg_gs"], ["proof (state)\nthis:\n  \\<exists>g\\<in>set gs. eval g xs \\<up>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<exists>g\\<in>set gs. eval g xs \\<up>", "have ex_i: \"\\<exists>i<length gs. eval (gs ! i) xs \\<up>\""], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>set gs. eval g xs \\<up>\n\ngoal (1 subgoal):\n 1. \\<exists>i<length gs. eval (gs ! i) xs \\<up>", "using in_set_conv_nth[of _ gs]"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>set gs. eval g xs \\<up>\n  (?x \\<in> set gs) = (\\<exists>i<length gs. gs ! i = ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>i<length gs. eval (gs ! i) xs \\<up>", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length gs. eval (gs ! i) xs \\<up>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "define k where \"k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)\" (is \"_ = Least ?P\")"], ["proof (state)\nthis:\n  k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)", "have gs_k: \"eval (gs ! k) xs \\<up>\""], ["proof (prove)\nusing this:\n  k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)\n\ngoal (1 subgoal):\n 1. eval (gs ! k) xs \\<up>", "using LeastI_ex[OF ex_i]"], ["proof (prove)\nusing this:\n  k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)\n  (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>) < length gs \\<and>\n  eval (gs ! (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>))\n   xs \\<up>\n\ngoal (1 subgoal):\n 1. eval (gs ! k) xs \\<up>", "by simp"], ["proof (state)\nthis:\n  eval (gs ! k) xs \\<up>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"\\<forall>i<k. eval (gs ! i) xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<k. eval (gs ! i) xs \\<down>", "using k_def not_less_Least[of _ ?P] LeastI_ex[OF ex_i]"], ["proof (prove)\nusing this:\n  k = (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>)\n  ?k < (LEAST x.\n           x < length gs \\<and> eval (gs ! x) xs \\<up>) \\<Longrightarrow>\n  \\<not> (?k < length gs \\<and> eval (gs ! ?k) xs \\<up>)\n  (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>) < length gs \\<and>\n  eval (gs ! (LEAST i. i < length gs \\<and> eval (gs ! i) xs \\<up>))\n   xs \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>i<k. eval (gs ! i) xs \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "from this"], ["proof (chain)\npicking this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>", "have \"k < length gs\""], ["proof (prove)\nusing this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n\ngoal (1 subgoal):\n 1. k < length gs", "using ex_i less_le_trans not_le"], ["proof (prove)\nusing this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n  \\<exists>i<length gs. eval (gs ! i) xs \\<up>\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  (\\<not> ?x \\<le> ?y) = (?y < ?x)\n\ngoal (1 subgoal):\n 1. k < length gs", "by blast"], ["proof (state)\nthis:\n  k < length gs\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n  k < length gs", "have \"reachable (?stack, None) ((Cn n f gs, xs, take k ?ys) # rest, None)\""], ["proof (prove)\nusing this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n  k < length gs\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using reachable_Cn[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>i<k. eval (gs ! i) xs \\<down>\n  k < length gs\n  \\<lbrakk>\\<And>xs rest.\n              valid ((f, xs, []) # rest) \\<Longrightarrow>\n              valid ((f, xs, []) # rest);\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> g \\<in> set gs;\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> valid ((g, xs, []) # rest);\n   \\<forall>i<?k. eval (gs ! i) xs \\<down>; ?k \\<le> length gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn n f gs, xs, []) # rest, None)\n                     ((Cn n f gs, xs,\n                       take ?k (map (\\<lambda>g. the (eval g xs)) gs)) #\n                      rest,\n                      None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable ...\n      ((gs ! (length (take k ?ys)), xs, []) # (Cn n f gs, xs, take k ?ys) # rest, None)\"\n      (is \"_ (?stack1, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "have \"length (take k ?ys) < length gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take k (map (\\<lambda>g. the (eval g xs)) gs)) < length gs", "by (simp add: \\<open>k < length gs\\<close> less_imp_le_nat min_less_iff_disj)"], ["proof (state)\nthis:\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) < length gs\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "then"], ["proof (chain)\npicking this:\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) < length gs", "show ?thesis"], ["proof (prove)\nusing this:\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) < length gs\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using step_reachable"], ["proof (prove)\nusing this:\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) < length gs\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)", "have \"reachable (?stack, None) (?stack1, None)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "."], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"nonterminating (?stack1, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "have \"recfn (length xs) (gs ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length xs) (gs ! k)", "using \\<open>k < length gs\\<close> valid(1)"], ["proof (prove)\nusing this:\n  k < length gs\n  recfn (length xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. recfn (length xs) (gs ! k)", "by simp"], ["proof (state)\nthis:\n  recfn (length xs) (gs ! k)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "then"], ["proof (chain)\npicking this:\n  recfn (length xs) (gs ! k)", "have \"correct (?stack1, None)\""], ["proof (prove)\nusing this:\n  recfn (length xs) (gs ! k)\n\ngoal (1 subgoal):\n 1. correct\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using \\<open>k < length gs\\<close> nth_mem valid valid_ConsI\n          assms(3)[of \"gs ! (length (take k ?ys))\" xs]"], ["proof (prove)\nusing this:\n  recfn (length xs) (gs ! k)\n  k < length gs\n  ?n < length ?xs \\<Longrightarrow> ?xs ! ?n \\<in> set ?xs\n  recfn (length xs) (Cn n f gs)\n  valid rest\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n  \\<lbrakk>gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs))\n           \\<in> set gs;\n   valid\n    ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n     ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct\n                     ((gs !\n                       length\n                        (take k (map (\\<lambda>g. the (eval g xs)) gs)),\n                       xs, []) #\n                      ?rest,\n                      None)\n\ngoal (1 subgoal):\n 1. correct\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  correct\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "moreover"], ["proof (state)\nthis:\n  correct\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "have \"length (take k ?ys) = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (take k (map (\\<lambda>g. the (eval g xs)) gs)) = k", "by (simp add: \\<open>k < length gs\\<close> less_imp_le_nat min_absorb2)"], ["proof (state)\nthis:\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) = k\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "ultimately"], ["proof (chain)\npicking this:\n  correct\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) = k", "show ?thesis"], ["proof (prove)\nusing this:\n  correct\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) = k\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "using gs_k"], ["proof (prove)\nusing this:\n  correct\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  length (take k (map (\\<lambda>g. the (eval g xs)) gs)) = k\n  eval (gs ! k) xs \\<up>\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs,\n       []) #\n      (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  nonterminating\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonterminating\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  nonterminating\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  nonterminating\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating ((Cn n f gs, xs, []) # rest, None)", "using reachable_nonterminating"], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  nonterminating\n   ((gs ! length (take k (map (\\<lambda>g. the (eval g xs)) gs)), xs, []) #\n    (Cn n f gs, xs, take k (map (\\<lambda>g. the (eval g xs)) gs)) # rest,\n    None)\n  \\<lbrakk>reachable ?x ?y; nonterminating ?y\\<rbrakk>\n  \\<Longrightarrow> nonterminating ?x\n\ngoal (1 subgoal):\n 1. nonterminating ((Cn n f gs, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"eval (Cn n f gs) xs \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<up>", "using diverg_gs valid"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>set gs. eval g xs \\<up>\n  recfn (length xs) (Cn n f gs)\n  valid rest\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<up>", "by fastforce"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs \\<up>\n\ngoal (2 subgoals):\n 1. \\<exists>g\\<in>set gs. eval g xs \\<up> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)\n 2. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n  eval (Cn n f gs) xs \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Cn n f gs, xs, []) # rest, None)\n  eval (Cn n f gs) xs \\<up>\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Cn n f gs, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "case converg"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval (Cn n f gs) xs \\<down>", "have f: \"eval f ?ys \\<down>\" and g: \"\\<And>g. g \\<in> set gs \\<Longrightarrow> eval g xs \\<down>\""], ["proof (prove)\nusing this:\n  eval (Cn n f gs) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down> &&&\n    (\\<And>g. g \\<in> set gs \\<Longrightarrow> eval g xs \\<down>)", "using valid(1)"], ["proof (prove)\nusing this:\n  eval (Cn n f gs) xs \\<down>\n  recfn (length xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down> &&&\n    (\\<And>g. g \\<in> set gs \\<Longrightarrow> eval g xs \\<down>)", "by (metis eval_Cn)+"], ["proof (state)\nthis:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down>\n  ?g1 \\<in> set gs \\<Longrightarrow> eval ?g1 xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down>\n  ?g1 \\<in> set gs \\<Longrightarrow> eval ?g1 xs \\<down>", "have \"\\<forall>i<length gs. eval (gs ! i) xs \\<down>\""], ["proof (prove)\nusing this:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down>\n  ?g1 \\<in> set gs \\<Longrightarrow> eval ?g1 xs \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>i<length gs. eval (gs ! i) xs \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>", "have \"reachable (?stack, None) ((Cn n f gs, xs, take (length gs) ?ys) # rest, None)\""], ["proof (prove)\nusing this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs,\n       take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "using reachable_Cn assms"], ["proof (prove)\nusing this:\n  \\<forall>i<length gs. eval (gs ! i) xs \\<down>\n  \\<lbrakk>valid ((Cn ?n ?f ?gs, ?xs, []) # ?rest);\n   \\<And>xs rest.\n      valid ((?f, xs, []) # rest) \\<Longrightarrow>\n      correct ((?f, xs, []) # rest, None);\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set ?gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> correct ((g, xs, []) # rest, None);\n   \\<forall>i<?k. eval (?gs ! i) ?xs \\<down>; ?k \\<le> length ?gs\\<rbrakk>\n  \\<Longrightarrow> reachable ((Cn ?n ?f ?gs, ?xs, []) # ?rest, None)\n                     ((Cn ?n ?f ?gs, ?xs,\n                       take ?k (map (\\<lambda>g. the (eval g ?xs)) ?gs)) #\n                      ?rest,\n                      None)\n  valid ((Cn n f gs, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  \\<lbrakk>?g \\<in> set gs; valid ((?g, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?g, ?xs, []) # ?rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     ((Cn n f gs, xs,\n       take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)", "by blast"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs,\n     take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   ((Cn n f gs, xs,\n     take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable ... ((Cn n f gs, xs, ?ys) # rest, None)\" (is \"_ (?stack1, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs,\n       take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n      rest,\n      None)\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)", "by (simp add: reachable_refl)"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs,\n     take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs,\n     take (length gs) (map (\\<lambda>g. the (eval g xs)) gs)) #\n    rest,\n    None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable ... ((f, ?ys, []) # ?stack1, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "using step_reachable"], ["proof (prove)\nusing this:\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest, None)\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable ... (?stack1, eval f ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      eval f (map (\\<lambda>g. the (eval g xs)) gs))", "using assms(2)[of \"?ys\"] correct_convergE valid f valid_ConsI"], ["proof (prove)\nusing this:\n  valid\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, map (\\<lambda>g. the (eval g xs)) gs, []) # ?rest, None)\n  \\<lbrakk>correct ((?f, ?xs, ?ls) # ?rest, None);\n   eval ?f ?xs \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((?f, ?xs, ?ls) # ?rest, None)\n                     (?rest, eval ?f ?xs)\n  recfn (length xs) (Cn n f gs)\n  valid rest\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down>\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. reachable\n     ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n      (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      None)\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      eval f (map (\\<lambda>g. the (eval g xs)) gs))", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((f, map (\\<lambda>g. the (eval g xs)) gs, []) #\n    (Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    None)\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"reachable (?stack1, eval f ?ys) (rest, eval f ?ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      eval f (map (\\<lambda>g. the (eval g xs)) gs))\n     (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))", "using f"], ["proof (prove)\nusing this:\n  eval f (map (\\<lambda>g. the (eval g xs)) gs) \\<down>\n\ngoal (1 subgoal):\n 1. reachable\n     ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n      eval f (map (\\<lambda>g. the (eval g xs)) gs))\n     (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((Cn n f gs, xs, map (\\<lambda>g. the (eval g xs)) gs) # rest,\n    eval f (map (\\<lambda>g. the (eval g xs)) gs))\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))", "have \"reachable (?stack, None) (rest, eval f ?ys)\""], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. reachable ((Cn n f gs, xs, []) # rest, None)\n     (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))", "."], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "have \"eval (Cn n f gs) xs = eval f ?ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)", "using g valid(1)"], ["proof (prove)\nusing this:\n  ?g1 \\<in> set gs \\<Longrightarrow> eval ?g1 xs \\<down>\n  recfn (length xs) (Cn n f gs)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)", "by auto"], ["proof (state)\nthis:\n  eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)\n\ngoal (1 subgoal):\n 1. eval (Cn n f gs) xs \\<down> \\<Longrightarrow>\n    correct ((Cn n f gs, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n  eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n  eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "using converg correct_convergI"], ["proof (prove)\nusing this:\n  reachable ((Cn n f gs, xs, []) # rest, None)\n   (rest, eval f (map (\\<lambda>g. the (eval g xs)) gs))\n  eval (Cn n f gs) xs = eval f (map (\\<lambda>g. the (eval g xs)) gs)\n  eval (Cn n f gs) xs \\<down>\n  \\<lbrakk>eval ?f ?xs \\<down>;\n   reachable ((?f, ?xs, ?ls) # ?rest, None) (?rest, eval ?f ?xs)\\<rbrakk>\n  \\<Longrightarrow> correct ((?f, ?xs, ?ls) # ?rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Cn n f gs, xs, []) # rest, None)", "by auto"], ["proof (state)\nthis:\n  correct ((Cn n f gs, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  correct ((Cn n f gs, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>During the execution of a frame with a partial recursive function\nof shape @{term \"Pr n f g\"} and arguments @{term \"x # xs\"}, the list of local\nvariables collects all the function values up to @{term x} in reversed\norder. We call such a list a @{term trace} for short.\\<close>"], ["", "definition trace :: \"nat \\<Rightarrow> recf \\<Rightarrow> recf \\<Rightarrow> nat list \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n  \"trace n f g xs x \\<equiv> map (\\<lambda>y. the (eval (Pr n f g) (y # xs))) (rev [0..<Suc x])\""], ["", "lemma trace_length: \"length (trace n f g xs x) = Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace n f g xs x) = Suc x", "using trace_def"], ["proof (prove)\nusing this:\n  trace ?n ?f ?g ?xs ?x \\<equiv>\n  map (\\<lambda>y. the (eval (Pr ?n ?f ?g) (y # ?xs))) (rev [0..<Suc ?x])\n\ngoal (1 subgoal):\n 1. length (trace n f g xs x) = Suc x", "by simp"], ["", "lemma trace_hd: \"hd (trace n f g xs x) = the (eval (Pr n f g) (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (trace n f g xs x) = the (eval (Pr n f g) (x # xs))", "using trace_def"], ["proof (prove)\nusing this:\n  trace ?n ?f ?g ?xs ?x \\<equiv>\n  map (\\<lambda>y. the (eval (Pr ?n ?f ?g) (y # ?xs))) (rev [0..<Suc ?x])\n\ngoal (1 subgoal):\n 1. hd (trace n f g xs x) = the (eval (Pr n f g) (x # xs))", "by simp"], ["", "lemma trace_Suc:\n  \"trace n f g xs (Suc x) = (the (eval (Pr n f g) (Suc x # xs))) # (trace n f g xs x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace n f g xs (Suc x) =\n    the (eval (Pr n f g) (Suc x # xs)) # trace n f g xs x", "using trace_def"], ["proof (prove)\nusing this:\n  trace ?n ?f ?g ?xs ?x \\<equiv>\n  map (\\<lambda>y. the (eval (Pr ?n ?f ?g) (y # ?xs))) (rev [0..<Suc ?x])\n\ngoal (1 subgoal):\n 1. trace n f g xs (Suc x) =\n    the (eval (Pr n f g) (Suc x # xs)) # trace n f g xs x", "by simp"], ["", "lemma reachable_Pr:\n  assumes \"valid (((Pr n f g), x # xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>xs rest. valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n    and \"y \\<le> x\"\n    and \"eval (Pr n f g) (y # xs) \\<down>\"\n  shows \"reachable (?stack, None) ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)", "using assms(4,5)"], ["proof (prove)\nusing this:\n  y \\<le> x\n  eval (Pr n f g) (y # xs) \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)", "proof (induction y)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> x\n  eval (Pr n f g) (0 # xs) \\<down>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have valid: \"recfn (length (x # xs)) (Pr n f g)\" \"valid rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length (x # xs)) (Pr n f g) &&& valid rest", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length (x # xs)) (Pr n f g)\n\ngoal (1 subgoal):\n 1. recfn (length (x # xs)) (Pr n f g) &&& valid rest", "by simp_all"], ["proof (state)\nthis:\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest", "have f: \"eval f xs \\<down>\""], ["proof (prove)\nusing this:\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "using 0"], ["proof (prove)\nusing this:\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n  0 \\<le> x\n  eval (Pr n f g) (0 # xs) \\<down>\n\ngoal (1 subgoal):\n 1. eval f xs \\<down>", "by simp"], ["proof (state)\nthis:\n  eval f xs \\<down>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "let ?as = \"x # xs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable (?stack, None) ((f, xs, []) # ((Pr n f g), ?as, []) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)", "using step_reachable"], ["proof (prove)\nusing this:\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)", "by auto"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable ... (?stack, eval f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, []) # rest, eval f xs)", "using assms(2)[of xs \"((Pr n f g), ?as, []) # rest\"]\n      correct_convergE[OF _ f] f valid valid_ConsI"], ["proof (prove)\nusing this:\n  valid ((f, xs, []) # (Pr n f g, x # xs, []) # rest) \\<Longrightarrow>\n  correct ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n  correct ((f, xs, ?ls) # ?rest, None) \\<Longrightarrow>\n  reachable ((f, xs, ?ls) # ?rest, None) (?rest, eval f xs)\n  eval f xs \\<down>\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. reachable ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, []) # rest, eval f xs)", "by simp"], ["proof (state)\nthis:\n  reachable ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, []) # rest, eval f xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((f, xs, []) # (Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, []) # rest, eval f xs)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable ... ((Pr n f g, ?as, [the (eval f xs)]) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, eval f xs)\n     ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)", "using step_reachable valid(1) f"], ["proof (prove)\nusing this:\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n  recfn (length (x # xs)) (Pr n f g)\n  eval f xs \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, eval f xs)\n     ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)", "by auto"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, eval f xs)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)", "have \"reachable (?stack, None) ((Pr n f g, ?as, [the (eval f xs)]) # rest, None)\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)", "."], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 \\<le> x; eval (Pr n f g) (0 # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                       ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n 2. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)", "show ?case"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)", "using trace_def valid(1)"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, [the (eval f xs)]) # rest, None)\n  trace ?n ?f ?g ?xs ?x \\<equiv>\n  map (\\<lambda>y. the (eval (Pr ?n ?f ?g) (y # ?xs))) (rev [0..<Suc ?x])\n  recfn (length (x # xs)) (Pr n f g)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, trace n f g xs 0) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "case (Suc y)"], ["proof (state)\nthis:\n  \\<lbrakk>y \\<le> x; eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n  Suc y \\<le> x\n  eval (Pr n f g) (Suc y # xs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have valid: \"recfn (length (x # xs)) (Pr n f g)\" \"valid rest\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length (x # xs)) (Pr n f g) &&& valid rest", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length (x # xs)) (Pr n f g)\n\ngoal (1 subgoal):\n 1. recfn (length (x # xs)) (Pr n f g) &&& valid rest", "by simp_all"], ["proof (state)\nthis:\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "let ?ls = \"trace n f g xs y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have lenls: \"length ?ls = Suc y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace n f g xs y) = Suc y", "using trace_length"], ["proof (prove)\nusing this:\n  length (trace ?n ?f ?g ?xs ?x) = Suc ?x\n\ngoal (1 subgoal):\n 1. length (trace n f g xs y) = Suc y", "by auto"], ["proof (state)\nthis:\n  length (trace n f g xs y) = Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "moreover"], ["proof (state)\nthis:\n  length (trace n f g xs y) = Suc y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have hdls: \"hd ?ls = the (eval (Pr n f g) (y # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))", "using Suc trace_hd"], ["proof (prove)\nusing this:\n  \\<lbrakk>y \\<le> x; eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n  Suc y \\<le> x\n  eval (Pr n f g) (Suc y # xs) \\<down>\n  hd (trace ?n ?f ?g ?xs ?x) = the (eval (Pr ?n ?f ?g) (?x # ?xs))\n\ngoal (1 subgoal):\n 1. hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))", "by auto"], ["proof (state)\nthis:\n  hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "ultimately"], ["proof (chain)\npicking this:\n  length (trace n f g xs y) = Suc y\n  hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))", "have g:\n    \"eval g (y # hd ?ls # xs) \\<down>\"\n    \"eval (Pr n f g) (Suc y # xs) = eval g (y # hd ?ls # xs)\""], ["proof (prove)\nusing this:\n  length (trace n f g xs y) = Suc y\n  hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))\n\ngoal (1 subgoal):\n 1. eval g (y # hd (trace n f g xs y) # xs) \\<down> &&&\n    eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)", "using eval_Pr_Suc_converg hdls valid(1) Suc"], ["proof (prove)\nusing this:\n  length (trace n f g xs y) = Suc y\n  hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (Suc ?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval ?g\n                     (?x #\n                      the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs) \\<down>\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (Suc ?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (Suc ?x # ?xs) =\n                    eval ?g (?x # the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs)\n  hd (trace n f g xs y) = the (eval (Pr n f g) (y # xs))\n  recfn (length (x # xs)) (Pr n f g)\n  \\<lbrakk>y \\<le> x; eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n  Suc y \\<le> x\n  eval (Pr n f g) (Suc y # xs) \\<down>\n\ngoal (1 subgoal):\n 1. eval g (y # hd (trace n f g xs y) # xs) \\<down> &&&\n    eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)", "by simp_all"], ["proof (state)\nthis:\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)", "have \"reachable (?stack, None) ((Pr n f g, x # xs, ?ls) # rest, None)\"\n      (is \"_ (?stack1, None)\")"], ["proof (prove)\nusing this:\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)", "using Suc valid(1)"], ["proof (prove)\nusing this:\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)\n  \\<lbrakk>y \\<le> x; eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n  Suc y \\<le> x\n  eval (Pr n f g) (Suc y # xs) \\<down>\n  recfn (length (x # xs)) (Pr n f g)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest, None)", "by fastforce"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable ... ((g, y # hd ?ls # xs, []) # (Pr n f g, x # xs, ?ls) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n     ((g, y # hd (trace n f g xs y) # xs, []) #\n      (Pr n f g, x # xs, trace n f g xs y) # rest,\n      None)", "using Suc.prems lenls"], ["proof (prove)\nusing this:\n  Suc y \\<le> x\n  eval (Pr n f g) (Suc y # xs) \\<down>\n  length (trace n f g xs y) = Suc y\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n     ((g, y # hd (trace n f g xs y) # xs, []) #\n      (Pr n f g, x # xs, trace n f g xs y) # rest,\n      None)", "by fastforce"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n   ((g, y # hd (trace n f g xs y) # xs, []) #\n    (Pr n f g, x # xs, trace n f g xs y) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, trace n f g xs y) # rest, None)\n   ((g, y # hd (trace n f g xs y) # xs, []) #\n    (Pr n f g, x # xs, trace n f g xs y) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable ... (?stack1, eval g (y # hd ?ls # xs))\"\n      (is \"_ (_, ?rv)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((g, y # hd (trace n f g xs y) # xs, []) #\n      (Pr n f g, x # xs, trace n f g xs y) # rest,\n      None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest,\n      eval g (y # hd (trace n f g xs y) # xs))", "using assms(3) g(1) valid valid_ConsI"], ["proof (prove)\nusing this:\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  recfn (length (x # xs)) (Pr n f g)\n  valid rest\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. reachable\n     ((g, y # hd (trace n f g xs y) # xs, []) #\n      (Pr n f g, x # xs, trace n f g xs y) # rest,\n      None)\n     ((Pr n f g, x # xs, trace n f g xs y) # rest,\n      eval g (y # hd (trace n f g xs y) # xs))", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((g, y # hd (trace n f g xs y) # xs, []) #\n    (Pr n f g, x # xs, trace n f g xs y) # rest,\n    None)\n   ((Pr n f g, x # xs, trace n f g xs y) # rest,\n    eval g (y # hd (trace n f g xs y) # xs))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable\n   ((g, y # hd (trace n f g xs y) # xs, []) #\n    (Pr n f g, x # xs, trace n f g xs y) # rest,\n    None)\n   ((Pr n f g, x # xs, trace n f g xs y) # rest,\n    eval g (y # hd (trace n f g xs y) # xs))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"reachable ... ((Pr n f g, x # xs, (the ?rv) # ?ls) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable\n     ((Pr n f g, x # xs, trace n f g xs y) # rest,\n      eval g (y # hd (trace n f g xs y) # xs))\n     ((Pr n f g, x # xs,\n       the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n      rest,\n      None)", "using Suc.prems(1) g(1) lenls"], ["proof (prove)\nusing this:\n  Suc y \\<le> x\n  eval g (y # hd (trace n f g xs y) # xs) \\<down>\n  length (trace n f g xs y) = Suc y\n\ngoal (1 subgoal):\n 1. reachable\n     ((Pr n f g, x # xs, trace n f g xs y) # rest,\n      eval g (y # hd (trace n f g xs y) # xs))\n     ((Pr n f g, x # xs,\n       the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n      rest,\n      None)", "by auto"], ["proof (state)\nthis:\n  reachable\n   ((Pr n f g, x # xs, trace n f g xs y) # rest,\n    eval g (y # hd (trace n f g xs y) # xs))\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)", "have \"reachable (?stack, None) ((Pr n f g, x # xs, (the ?rv) # ?ls) # rest, None)\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs,\n       the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n      rest,\n      None)", "."], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "have \"trace n f g xs (Suc y) = (the ?rv) # ?ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trace n f g xs (Suc y) =\n    the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y", "using g(2) trace_Suc"], ["proof (prove)\nusing this:\n  eval (Pr n f g) (Suc y # xs) = eval g (y # hd (trace n f g xs y) # xs)\n  trace ?n ?f ?g ?xs (Suc ?x) =\n  the (eval (Pr ?n ?f ?g) (Suc ?x # ?xs)) # trace ?n ?f ?g ?xs ?x\n\ngoal (1 subgoal):\n 1. trace n f g xs (Suc y) =\n    the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y", "by simp"], ["proof (state)\nthis:\n  trace n f g xs (Suc y) =\n  the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<lbrakk>y \\<le> x;\n                 eval (Pr n f g) (y # xs) \\<down>\\<rbrakk>\n                \\<Longrightarrow> reachable\n                                   ((Pr n f g, x # xs, []) # rest, None)\n                                   ((Pr n f g, x # xs, trace n f g xs y) #\n                                    rest,\n                                    None);\n        Suc y \\<le> x; eval (Pr n f g) (Suc y # xs) \\<down>\\<rbrakk>\n       \\<Longrightarrow> reachable ((Pr n f g, x # xs, []) # rest, None)\n                          ((Pr n f g, x # xs, trace n f g xs (Suc y)) #\n                           rest,\n                           None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n  trace n f g xs (Suc y) =\n  the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y", "show ?case"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs,\n     the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y) #\n    rest,\n    None)\n  trace n f g xs (Suc y) =\n  the (eval g (y # hd (trace n f g xs y) # xs)) # trace n f g xs y\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, x # xs, []) # rest, None)\n     ((Pr n f g, x # xs, trace n f g xs (Suc y)) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Pr n f g, x # xs, []) # rest, None)\n   ((Pr n f g, x # xs, trace n f g xs (Suc y)) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_Pr_correct:\n  assumes \"valid (((Pr n f g), xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<And>xs rest. valid ((g, xs, []) # rest) \\<Longrightarrow> correct ((g, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "have valid: \"valid rest\" \"recfn (length xs) (Pr n f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Pr n f g)", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Pr n f g)", "by simp_all"], ["proof (state)\nthis:\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid rest\n  recfn (length xs) (Pr n f g)", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "obtain y ys where y_ys: \"xs = y # ys\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using list.exhaust_sel"], ["proof (prove)\nusing this:\n  0 < length xs\n  \\<lbrakk>?list = [] \\<Longrightarrow> ?P;\n   ?list = hd ?list # tl ?list \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>y ys. xs = y # ys \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "let ?t = \"trace n f g ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "consider\n      (converg) \"eval (Pr n f g) xs \\<down>\"\n    | (diverg_f) \"eval (Pr n f g) xs \\<up>\" and \"eval f ys \\<up>\"\n    | (diverg) \"eval (Pr n f g) xs \\<up>\" and \"eval f ys \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<down> \\<Longrightarrow> thesis;\n     \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>eval (Pr n f g) xs \\<down> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>eval (Pr n f g) xs \\<down> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>eval (Pr n f g) xs \\<down> \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "case converg"], ["proof (state)\nthis:\n  eval (Pr n f g) xs \\<down>\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval (Pr n f g) xs \\<down>", "have \"\\<And>z. z \\<le> y \\<Longrightarrow> reachable (?stack, None) (((Pr n f g), xs, ?t z) # rest, None)\""], ["proof (prove)\nusing this:\n  eval (Pr n f g) xs \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<le> y \\<Longrightarrow>\n       reachable ((Pr n f g, xs, []) # rest, None)\n        ((Pr n f g, xs, trace n f g ys z) # rest, None)", "using assms valid"], ["proof (prove)\nusing this:\n  eval (Pr n f g) xs \\<down>\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z \\<le> y \\<Longrightarrow>\n       reachable ((Pr n f g, xs, []) # rest, None)\n        ((Pr n f g, xs, trace n f g ys z) # rest, None)", "by (simp add: eval_Pr_converg_le reachable_Pr y_ys)"], ["proof (state)\nthis:\n  ?z1 \\<le> y \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?z1) # rest, None)\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  ?z1 \\<le> y \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?z1) # rest, None)", "have \"reachable (?stack, None) (((Pr n f g), xs, ?t y) # rest, None)\""], ["proof (prove)\nusing this:\n  ?z1 \\<le> y \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?z1) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((Pr n f g, xs, trace n f g ys y) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys y) # rest, None)\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys y) # rest, None)\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"reachable (((Pr n f g), xs, ?t y) # rest, None) (rest, Some (hd (?t y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n     (rest, Some (hd (trace n f g ys y)))", "using trace_length step_reachable y_ys"], ["proof (prove)\nusing this:\n  length (trace ?n ?f ?g ?xs ?x) = Suc ?x\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n     (rest, Some (hd (trace n f g ys y)))", "by fastforce"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys y) # rest, None)\n  reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))", "have \"reachable (?stack, None) (rest, Some (hd (?t y)))\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys y) # rest, None)\n  reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     (rest, Some (hd (trace n f g ys y)))", "using reachable_transitive"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys y) # rest, None)\n  reachable ((Pr n f g, xs, trace n f g ys y) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n  \\<lbrakk>reachable ?x ?y; reachable ?y ?z\\<rbrakk>\n  \\<Longrightarrow> reachable ?x ?z\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     (rest, Some (hd (trace n f g ys y)))", "by blast"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n\ngoal (3 subgoals):\n 1. eval (Pr n f g) xs \\<down> \\<Longrightarrow>\n    correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 3. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "using assms(1) trace_hd converg y_ys"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   (rest, Some (hd (trace n f g ys y)))\n  valid ((Pr n f g, xs, []) # rest)\n  hd (trace ?n ?f ?g ?xs ?x) = the (eval (Pr ?n ?f ?g) (?x # ?xs))\n  eval (Pr n f g) xs \\<down>\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Pr n f g, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "case diverg_f"], ["proof (state)\nthis:\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<up>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have *: \"step (?stack, None) = ((f, ys, []) # ((Pr n f g), xs, []) # tl ?stack, None)\"\n        (is \"_ = (?stack1, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, []) # rest, None) =\n    ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n     None)", "using assms(1,2) y_ys"], ["proof (prove)\nusing this:\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, []) # rest, None) =\n    ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n     None)", "by simp"], ["proof (state)\nthis:\n  step ((Pr n f g, xs, []) # rest, None) =\n  ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  step ((Pr n f g, xs, []) # rest, None) =\n  ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)", "have \"reachable (?stack, None) (?stack1, None)\""], ["proof (prove)\nusing this:\n  step ((Pr n f g, xs, []) # rest, None) =\n  ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n      None)", "using step_reachable"], ["proof (prove)\nusing this:\n  step ((Pr n f g, xs, []) # rest, None) =\n  ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n      None)", "by force"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"nonterminating (?stack1, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating\n     ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n      None)", "using assms diverg_f valid valid_ConsI *"], ["proof (prove)\nusing this:\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<up>\n  valid rest\n  recfn (length xs) (Pr n f g)\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n  step ((Pr n f g, xs, []) # rest, None) =\n  ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest),\n      None)", "by auto"], ["proof (state)\nthis:\n  nonterminating\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n  nonterminating\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n  nonterminating\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n\ngoal (1 subgoal):\n 1. nonterminating ((Pr n f g, xs, []) # rest, None)", "using reachable_nonterminating"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n  nonterminating\n   ((f, ys, []) # (Pr n f g, xs, []) # tl ((Pr n f g, xs, []) # rest), None)\n  \\<lbrakk>reachable ?x ?y; nonterminating ?y\\<rbrakk>\n  \\<Longrightarrow> nonterminating ?x\n\ngoal (1 subgoal):\n 1. nonterminating ((Pr n f g, xs, []) # rest, None)", "by blast"], ["proof (state)\nthis:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "using diverg_f(1) assms(1)"], ["proof (prove)\nusing this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n  eval (Pr n f g) xs \\<up>\n  valid ((Pr n f g, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Pr n f g, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "case diverg"], ["proof (state)\nthis:\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<down>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "let ?h = \"\\<lambda>z. the (eval (Pr n f g) (z # ys))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "let ?Q = \"\\<lambda>z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"?Q 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < y \\<and> eval (Pr n f g) (0 # ys) \\<down>", "using assms diverg neq0_conv y_ys valid"], ["proof (prove)\nusing this:\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<down>\n  (?n \\<noteq> 0) = (0 < ?n)\n  xs = y # ys\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. 0 < y \\<and> eval (Pr n f g) (0 # ys) \\<down>", "by fastforce"], ["proof (state)\nthis:\n  0 < y \\<and> eval (Pr n f g) (0 # ys) \\<down>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "define zmax where \"zmax = Greatest ?Q\""], ["proof (state)\nthis:\n  zmax = (GREATEST z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  zmax = (GREATEST z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)", "have \"?Q zmax\""], ["proof (prove)\nusing this:\n  zmax = (GREATEST z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)\n\ngoal (1 subgoal):\n 1. zmax < y \\<and> eval (Pr n f g) (zmax # ys) \\<down>", "using \\<open>?Q 0\\<close> GreatestI_nat[of ?Q 0 y]"], ["proof (prove)\nusing this:\n  zmax = (GREATEST z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)\n  0 < y \\<and> eval (Pr n f g) (0 # ys) \\<down>\n  \\<lbrakk>0 < y \\<and> eval (Pr n f g) (0 # ys) \\<down>;\n   \\<And>ya.\n      ya < y \\<and> eval (Pr n f g) (ya # ys) \\<down> \\<Longrightarrow>\n      ya \\<le> y\\<rbrakk>\n  \\<Longrightarrow> (GREATEST z.\n                        z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)\n                    < y \\<and>\n                    eval (Pr n f g)\n                     ((GREATEST z.\n                          z < y \\<and> eval (Pr n f g) (z # ys) \\<down>) #\n                      ys) \\<down>\n\ngoal (1 subgoal):\n 1. zmax < y \\<and> eval (Pr n f g) (zmax # ys) \\<down>", "by simp"], ["proof (state)\nthis:\n  zmax < y \\<and> eval (Pr n f g) (zmax # ys) \\<down>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have le_zmax: \"\\<And>z. ?Q z \\<Longrightarrow> z \\<le> zmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z.\n       z < y \\<and> eval (Pr n f g) (z # ys) \\<down> \\<Longrightarrow>\n       z \\<le> zmax", "using Greatest_le_nat[of ?Q _ y] zmax_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?k < y \\<and> eval (Pr n f g) (?k # ys) \\<down>;\n   \\<And>ya.\n      ya < y \\<and> eval (Pr n f g) (ya # ys) \\<down> \\<Longrightarrow>\n      ya \\<le> y\\<rbrakk>\n  \\<Longrightarrow> ?k \\<le> (GREATEST z.\n                                 z < y \\<and>\n                                 eval (Pr n f g) (z # ys) \\<down>)\n  zmax = (GREATEST z. z < y \\<and> eval (Pr n f g) (z # ys) \\<down>)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       z < y \\<and> eval (Pr n f g) (z # ys) \\<down> \\<Longrightarrow>\n       z \\<le> zmax", "by simp"], ["proof (state)\nthis:\n  ?z1 < y \\<and> eval (Pr n f g) (?z1 # ys) \\<down> \\<Longrightarrow>\n  ?z1 \\<le> zmax\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have len: \"length (?t zmax) < Suc y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace n f g ys zmax) < Suc y", "by (simp add: \\<open>?Q zmax\\<close> trace_length)"], ["proof (state)\nthis:\n  length (trace n f g ys zmax) < Suc y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"eval (Pr n f g) (y # ys) \\<down>\" if \"y \\<le> zmax\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr n f g) (y # ys) \\<down>", "using that zmax_def \\<open>?Q zmax\\<close> assms eval_Pr_converg_le[of n f g ys zmax y] valid y_ys"], ["proof (prove)\nusing this:\n  y \\<le> zmax\n  zmax = (GREATEST z. z < y__ \\<and> eval (Pr n f g) (z # ys) \\<down>)\n  zmax < y__ \\<and> eval (Pr n f g) (zmax # ys) \\<down>\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  \\<lbrakk>recfn (Suc n) (Pr n f g); n = length ys;\n   eval (Pr n f g) (zmax # ys) \\<down>; y \\<le> zmax\\<rbrakk>\n  \\<Longrightarrow> eval (Pr n f g) (y # ys) \\<down>\n  valid rest\n  recfn (length xs) (Pr n f g)\n  xs = y__ # ys\n\ngoal (1 subgoal):\n 1. eval (Pr n f g) (y # ys) \\<down>", "by simp"], ["proof (state)\nthis:\n  ?y1 \\<le> zmax \\<Longrightarrow> eval (Pr n f g) (?y1 # ys) \\<down>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  ?y1 \\<le> zmax \\<Longrightarrow> eval (Pr n f g) (?y1 # ys) \\<down>", "have \"reachable (?stack, None) (((Pr n f g), xs, ?t y) # rest, None)\"\n        if \"y \\<le> zmax\" for y"], ["proof (prove)\nusing this:\n  ?y1 \\<le> zmax \\<Longrightarrow> eval (Pr n f g) (?y1 # ys) \\<down>\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((Pr n f g, xs, trace n f g ys y) # rest, None)", "using that \\<open>?Q zmax\\<close> diverg y_ys assms reachable_Pr"], ["proof (prove)\nusing this:\n  ?y1 \\<le> zmax \\<Longrightarrow> eval (Pr n f g) (?y1 # ys) \\<down>\n  y \\<le> zmax\n  zmax < y__ \\<and> eval (Pr n f g) (zmax # ys) \\<down>\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<down>\n  xs = y__ # ys\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  \\<lbrakk>valid ((Pr ?n ?f ?g, ?x # ?xs, []) # ?rest);\n   \\<And>xs rest.\n      valid ((?f, xs, []) # rest) \\<Longrightarrow>\n      correct ((?f, xs, []) # rest, None);\n   \\<And>xs rest.\n      valid ((?g, xs, []) # rest) \\<Longrightarrow>\n      correct ((?g, xs, []) # rest, None);\n   ?y \\<le> ?x; eval (Pr ?n ?f ?g) (?y # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((Pr ?n ?f ?g, ?x # ?xs, []) # ?rest, None)\n                     ((Pr ?n ?f ?g, ?x # ?xs, trace ?n ?f ?g ?xs ?y) #\n                      ?rest,\n                      None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((Pr n f g, xs, trace n f g ys y) # rest, None)", "by simp"], ["proof (state)\nthis:\n  ?y1 \\<le> zmax \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?y1) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  ?y1 \\<le> zmax \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?y1) # rest, None)", "have \"reachable (?stack, None) (((Pr n f g), xs, ?t zmax) # rest, None)\"\n        (is \"reachable _ (?stack1, None)\")"], ["proof (prove)\nusing this:\n  ?y1 \\<le> zmax \\<Longrightarrow>\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys ?y1) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((Pr n f g, xs, trace n f g ys zmax) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys zmax) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((Pr n f g, xs, trace n f g ys zmax) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"reachable ...\n        ((g, zmax # ?h zmax # tl xs, []) # (Pr n f g, xs, ?t zmax) # rest, None)\"\n        (is \"_ (?stack2, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, trace n f g ys zmax) # rest, None)\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "proof (rule step_reachable)"], ["proof (state)\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "have \"length (?t zmax) \\<noteq> Suc (hd xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace n f g ys zmax) \\<noteq> Suc (hd xs)", "using len y_ys"], ["proof (prove)\nusing this:\n  length (trace n f g ys zmax) < Suc y\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. length (trace n f g ys zmax) \\<noteq> Suc (hd xs)", "by simp"], ["proof (state)\nthis:\n  length (trace n f g ys zmax) \\<noteq> Suc (hd xs)\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "moreover"], ["proof (state)\nthis:\n  length (trace n f g ys zmax) \\<noteq> Suc (hd xs)\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "have \"hd (?t zmax) = ?h zmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))", "using trace_hd"], ["proof (prove)\nusing this:\n  hd (trace ?n ?f ?g ?xs ?x) = the (eval (Pr ?n ?f ?g) (?x # ?xs))\n\ngoal (1 subgoal):\n 1. hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))", "by auto"], ["proof (state)\nthis:\n  hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "moreover"], ["proof (state)\nthis:\n  hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "have \"length (?t zmax) = Suc zmax\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (trace n f g ys zmax) = Suc zmax", "using trace_length"], ["proof (prove)\nusing this:\n  length (trace ?n ?f ?g ?xs ?x) = Suc ?x\n\ngoal (1 subgoal):\n 1. length (trace n f g ys zmax) = Suc zmax", "by simp"], ["proof (state)\nthis:\n  length (trace n f g ys zmax) = Suc zmax\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "ultimately"], ["proof (chain)\npicking this:\n  length (trace n f g ys zmax) \\<noteq> Suc (hd xs)\n  hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))\n  length (trace n f g ys zmax) = Suc zmax", "show \"step (?stack1, None) = (?stack2, None)\""], ["proof (prove)\nusing this:\n  length (trace n f g ys zmax) \\<noteq> Suc (hd xs)\n  hd (trace n f g ys zmax) = the (eval (Pr n f g) (zmax # ys))\n  length (trace n f g ys zmax) = Suc zmax\n\ngoal (1 subgoal):\n 1. step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n    ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n     (Pr n f g, xs, trace n f g ys zmax) # rest,\n     None)", "by auto"], ["proof (state)\nthis:\n  step ((Pr n f g, xs, trace n f g ys zmax) # rest, None) =\n  ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n   (Pr n f g, xs, trace n f g ys zmax) # rest,\n   None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, trace n f g ys zmax) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)", "have \"reachable (?stack, None) (?stack2, None)\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. reachable ((Pr n f g, xs, []) # rest, None)\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "."], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "have \"nonterminating (?stack2, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "have \"correct (?stack2, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "using y_ys assms valid_ConsI valid"], ["proof (prove)\nusing this:\n  xs = y # ys\n  valid ((Pr n f g, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid ((g, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((g, ?xs, []) # ?rest, None)\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. correct\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  correct\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "moreover"], ["proof (state)\nthis:\n  correct\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "have \"eval g (zmax # ?h zmax # ys) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>", "using \\<open>?Q zmax\\<close> diverg le_zmax len less_Suc_eq trace_length y_ys valid"], ["proof (prove)\nusing this:\n  zmax < y \\<and> eval (Pr n f g) (zmax # ys) \\<down>\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<down>\n  ?z1 < y \\<and> eval (Pr n f g) (?z1 # ys) \\<down> \\<Longrightarrow>\n  ?z1 \\<le> zmax\n  length (trace n f g ys zmax) < Suc y\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n  length (trace ?n ?f ?g ?xs ?x) = Suc ?x\n  xs = y # ys\n  valid rest\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>", "by fastforce"], ["proof (state)\nthis:\n  eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "ultimately"], ["proof (chain)\npicking this:\n  correct\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  correct\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "using y_ys"], ["proof (prove)\nusing this:\n  correct\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  eval g (zmax # the (eval (Pr n f g) (zmax # ys)) # ys) \\<up>\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. nonterminating\n     ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n      (Pr n f g, xs, trace n f g ys zmax) # rest,\n      None)", "by simp"], ["proof (state)\nthis:\n  nonterminating\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonterminating\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  nonterminating\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  nonterminating\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n\ngoal (1 subgoal):\n 1. nonterminating ((Pr n f g, xs, []) # rest, None)", "using reachable_nonterminating"], ["proof (prove)\nusing this:\n  reachable ((Pr n f g, xs, []) # rest, None)\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  nonterminating\n   ((g, zmax # the (eval (Pr n f g) (zmax # ys)) # tl xs, []) #\n    (Pr n f g, xs, trace n f g ys zmax) # rest,\n    None)\n  \\<lbrakk>reachable ?x ?y; nonterminating ?y\\<rbrakk>\n  \\<Longrightarrow> nonterminating ?x\n\ngoal (1 subgoal):\n 1. nonterminating ((Pr n f g, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval (Pr n f g) xs \\<up>; eval f ys \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Pr n f g, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "using diverg assms(1)"], ["proof (prove)\nusing this:\n  nonterminating ((Pr n f g, xs, []) # rest, None)\n  eval (Pr n f g) xs \\<up>\n  eval f ys \\<down>\n  valid ((Pr n f g, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Pr n f g, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Pr n f g, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  correct ((Pr n f g, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachable_Mn:\n  assumes \"valid ((Mn n f, xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n    and \"\\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}\"\n  shows \"reachable (?stack, None) ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "using assms(3)"], ["proof (prove)\nusing this:\n  \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "proof (induction z)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n    reachable ((Mn n f, xs, []) # rest, None)\n     ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n 2. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "case 0"], ["proof (state)\nthis:\n  \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (2 subgoals):\n 1. \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n    reachable ((Mn n f, xs, []) # rest, None)\n     ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n 2. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0}", "have \"step (?stack, None) = ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\""], ["proof (prove)\nusing this:\n  \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. step ((Mn n f, xs, []) # rest, None) =\n    ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0}\n  valid ((Mn n f, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. step ((Mn n f, xs, []) # rest, None) =\n    ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  step ((Mn n f, xs, []) # rest, None) =\n  ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<forall>y<0. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n    reachable ((Mn n f, xs, []) # rest, None)\n     ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n 2. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  step ((Mn n f, xs, []) # rest, None) =\n  ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)", "show ?case"], ["proof (prove)\nusing this:\n  step ((Mn n f, xs, []) # rest, None) =\n  ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)", "using step_reachable assms(1)"], ["proof (prove)\nusing this:\n  step ((Mn n f, xs, []) # rest, None) =\n  ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n  valid ((Mn n f, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)", "by force"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, 0 # xs, []) # (Mn n f, xs, [0]) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "case (Suc z)"], ["proof (state)\nthis:\n  \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n  \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "have valid: \"valid rest\" \"recfn (length xs) (Mn n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Mn n f)", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length xs) (Mn n f)\n\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Mn n f)", "by auto"], ["proof (state)\nthis:\n  valid rest\n  recfn (length xs) (Mn n f)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "have f: \"eval f (z # xs) \\<notin> {None, Some 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<notin> {None, Some 0}", "using Suc"], ["proof (prove)\nusing this:\n  \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n  \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<notin> {None, Some 0}", "by simp"], ["proof (state)\nthis:\n  eval f (z # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "have \"reachable (?stack, None) ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "using Suc"], ["proof (prove)\nusing this:\n  \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n  \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "have \"reachable ... ((Mn n f, xs, [z]) # rest, eval f (z # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n     ((Mn n f, xs, [z]) # rest, eval f (z # xs))", "using f assms(2)[of \"z # xs\"] valid correct_convergE valid_ConsI"], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<notin> {None, Some 0}\n  valid ((f, z # xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, z # xs, []) # ?rest, None)\n  valid rest\n  recfn (length xs) (Mn n f)\n  \\<lbrakk>correct ((?f, ?xs, ?ls) # ?rest, None);\n   eval ?f ?xs \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((?f, ?xs, ?ls) # ?rest, None)\n                     (?rest, eval ?f ?xs)\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n     ((Mn n f, xs, [z]) # rest, eval f (z # xs))", "by auto"], ["proof (state)\nthis:\n  reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n   ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "also"], ["proof (state)\nthis:\n  reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n   ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "have \"reachable ... ((f, (Suc z) # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\"\n      (is \"_  (?stack1, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n     ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "using step_reachable f"], ["proof (prove)\nusing this:\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n  eval f (z # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n     ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "by force"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "have \"reachable (?stack, None) (?stack1, None)\""], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "."], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       \\<lbrakk>\\<forall>y<z.\n                   eval f (y # xs) \\<notin> {None, Some 0} \\<Longrightarrow>\n                reachable ((Mn n f, xs, []) # rest, None)\n                 ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None);\n        \\<forall>y<Suc z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n       \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                          ((f, Suc z # xs, []) #\n                           (Mn n f, xs, [Suc z]) # rest,\n                           None)", "then"], ["proof (chain)\npicking this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "show ?case"], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z # xs, []) # (Mn n f, xs, [Suc z]) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma iterate_step_empty_stack: \"iterate t step ([], rv) = ([], rv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate t step ([], rv) = ([], rv)", "using step_empty_stack"], ["proof (prove)\nusing this:\n  fst ?x = [] \\<Longrightarrow> fst (step ?x) = []\n\ngoal (1 subgoal):\n 1. iterate t step ([], rv) = ([], rv)", "by (induction t) simp_all"], ["", "lemma reachable_iterate_step_empty_stack:\n  assumes \"reachable cfg ([], rv)\"\n  shows \"\\<exists>t. iterate t step cfg = ([], rv) \\<and> (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "let ?P = \"\\<lambda>t. iterate t step cfg = ([], rv)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "from assms"], ["proof (chain)\npicking this:\n  reachable cfg ([], rv)", "have \"\\<exists>t. ?P t\""], ["proof (prove)\nusing this:\n  reachable cfg ([], rv)\n\ngoal (1 subgoal):\n 1. \\<exists>t. iterate t step cfg = ([], rv)", "by (simp add: reachable_def)"], ["proof (state)\nthis:\n  \\<exists>t. iterate t step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "moreover"], ["proof (state)\nthis:\n  \\<exists>t. iterate t step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "define tmin where \"tmin = Least ?P\""], ["proof (state)\nthis:\n  tmin = (LEAST t. iterate t step cfg = ([], rv))\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>t. iterate t step cfg = ([], rv)\n  tmin = (LEAST t. iterate t step cfg = ([], rv))", "have \"?P tmin\""], ["proof (prove)\nusing this:\n  \\<exists>t. iterate t step cfg = ([], rv)\n  tmin = (LEAST t. iterate t step cfg = ([], rv))\n\ngoal (1 subgoal):\n 1. iterate tmin step cfg = ([], rv)", "using LeastI_ex[of ?P]"], ["proof (prove)\nusing this:\n  \\<exists>t. iterate t step cfg = ([], rv)\n  tmin = (LEAST t. iterate t step cfg = ([], rv))\n  \\<exists>x. iterate x step cfg = ([], rv) \\<Longrightarrow>\n  iterate (LEAST t. iterate t step cfg = ([], rv)) step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. iterate tmin step cfg = ([], rv)", "by simp"], ["proof (state)\nthis:\n  iterate tmin step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "have \"fst (iterate t' step cfg) \\<noteq> []\" if \"t' < tmin\" for t'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) \\<noteq> []", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "assume \"fst (iterate t' step cfg) = []\""], ["proof (state)\nthis:\n  fst (iterate t' step cfg) = []\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fst (iterate t' step cfg) = []", "obtain v where v: \"iterate t' step cfg = ([], v)\""], ["proof (prove)\nusing this:\n  fst (iterate t' step cfg) = []\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        iterate t' step cfg = ([], v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust_sel)"], ["proof (state)\nthis:\n  iterate t' step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  iterate t' step cfg = ([], v)", "have \"iterate t'' step ([], v) = ([], v)\" for t''"], ["proof (prove)\nusing this:\n  iterate t' step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. iterate t'' step ([], v) = ([], v)", "using iterate_step_empty_stack"], ["proof (prove)\nusing this:\n  iterate t' step cfg = ([], v)\n  iterate ?t step ([], ?rv) = ([], ?rv)\n\ngoal (1 subgoal):\n 1. iterate t'' step ([], v) = ([], v)", "by simp"], ["proof (state)\nthis:\n  iterate ?t'' step ([], v) = ([], v)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  iterate ?t'' step ([], v) = ([], v)", "have \"iterate (t' + t'') step cfg = ([], v)\" for t''"], ["proof (prove)\nusing this:\n  iterate ?t'' step ([], v) = ([], v)\n\ngoal (1 subgoal):\n 1. iterate (t' + t'') step cfg = ([], v)", "using v iterate_additive"], ["proof (prove)\nusing this:\n  iterate ?t'' step ([], v) = ([], v)\n  iterate t' step cfg = ([], v)\n  \\<lbrakk>iterate ?t\\<^sub>1 ?f ?x = ?y;\n   iterate ?t\\<^sub>2 ?f ?y = ?z\\<rbrakk>\n  \\<Longrightarrow> iterate (?t\\<^sub>1 + ?t\\<^sub>2) ?f ?x = ?z\n\ngoal (1 subgoal):\n 1. iterate (t' + t'') step cfg = ([], v)", "by fast"], ["proof (state)\nthis:\n  iterate (t' + ?t'') step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  iterate (t' + ?t'') step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "obtain t'' where \"t' + t'' = tmin\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t''. t' + t'' = tmin \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>t' < tmin\\<close> less_imp_add_positive"], ["proof (prove)\nusing this:\n  t' < tmin\n  ?i < ?j \\<Longrightarrow> \\<exists>k>0. ?i + k = ?j\n\ngoal (1 subgoal):\n 1. (\\<And>t''. t' + t'' = tmin \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  t' + t'' = tmin\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  iterate (t' + ?t'') step cfg = ([], v)\n  t' + t'' = tmin", "have \"iterate tmin step cfg = ([], v)\""], ["proof (prove)\nusing this:\n  iterate (t' + ?t'') step cfg = ([], v)\n  t' + t'' = tmin\n\ngoal (1 subgoal):\n 1. iterate tmin step cfg = ([], v)", "by auto"], ["proof (state)\nthis:\n  iterate tmin step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  iterate tmin step cfg = ([], v)", "have \"v = rv\""], ["proof (prove)\nusing this:\n  iterate tmin step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. v = rv", "using \\<open>?P tmin\\<close>"], ["proof (prove)\nusing this:\n  iterate tmin step cfg = ([], v)\n  iterate tmin step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. v = rv", "by simp"], ["proof (state)\nthis:\n  v = rv\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v = rv", "have \"iterate t' step cfg = ([], rv)\""], ["proof (prove)\nusing this:\n  v = rv\n\ngoal (1 subgoal):\n 1. iterate t' step cfg = ([], rv)", "using v"], ["proof (prove)\nusing this:\n  v = rv\n  iterate t' step cfg = ([], v)\n\ngoal (1 subgoal):\n 1. iterate t' step cfg = ([], rv)", "by simp"], ["proof (state)\nthis:\n  iterate t' step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  iterate t' step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "have \"\\<forall>t'<tmin. \\<not> ?P t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t'<tmin. iterate t' step cfg \\<noteq> ([], rv)", "unfolding tmin_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t'<LEAST t. iterate t step cfg = ([], rv).\n       iterate t' step cfg \\<noteq> ([], rv)", "using not_less_Least[of _ ?P]"], ["proof (prove)\nusing this:\n  ?k < (LEAST x. iterate x step cfg = ([], rv)) \\<Longrightarrow>\n  iterate ?k step cfg \\<noteq> ([], rv)\n\ngoal (1 subgoal):\n 1. \\<forall>t'<LEAST t. iterate t step cfg = ([], rv).\n       iterate t' step cfg \\<noteq> ([], rv)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'<tmin. iterate t' step cfg \\<noteq> ([], rv)\n\ngoal (1 subgoal):\n 1. fst (iterate t' step cfg) = [] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  iterate t' step cfg = ([], rv)\n  \\<forall>t'<tmin. iterate t' step cfg \\<noteq> ([], rv)", "show False"], ["proof (prove)\nusing this:\n  iterate t' step cfg = ([], rv)\n  \\<forall>t'<tmin. iterate t' step cfg \\<noteq> ([], rv)\n\ngoal (1 subgoal):\n 1. False", "using that"], ["proof (prove)\nusing this:\n  iterate t' step cfg = ([], rv)\n  \\<forall>t'<tmin. iterate t' step cfg \\<noteq> ([], rv)\n  t' < tmin\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t' < tmin \\<Longrightarrow> fst (iterate ?t' step cfg) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "then"], ["proof (chain)\npicking this:\n  ?t' < tmin \\<Longrightarrow> fst (iterate ?t' step cfg) \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  ?t' < tmin \\<Longrightarrow> fst (iterate ?t' step cfg) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "using \\<open>?P tmin\\<close>"], ["proof (prove)\nusing this:\n  ?t' < tmin \\<Longrightarrow> fst (iterate ?t' step cfg) \\<noteq> []\n  iterate tmin step cfg = ([], rv)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       iterate t step cfg = ([], rv) \\<and>\n       (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])", "by auto"], ["proof (state)\nthis:\n  \\<exists>t.\n     iterate t step cfg = ([], rv) \\<and>\n     (\\<forall>t'<t. fst (iterate t' step cfg) \\<noteq> [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_Mn_correct:\n  assumes \"valid ((Mn n f, xs, []) # rest)\" (is \"valid ?stack\")\n    and \"\\<And>xs rest. valid ((f, xs, []) # rest) \\<Longrightarrow> correct ((f, xs, []) # rest, None)\"\n  shows \"correct (?stack, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "have valid: \"valid rest\" \"recfn (length xs) (Mn n f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Mn n f)", "using valid_ConsE[OF assms(1)]"], ["proof (prove)\nusing this:\n  valid rest \\<and> recfn (length xs) (Mn n f)\n\ngoal (1 subgoal):\n 1. valid rest &&& recfn (length xs) (Mn n f)", "by auto"], ["proof (state)\nthis:\n  valid rest\n  recfn (length xs) (Mn n f)\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "consider\n      (diverg) \"eval (Mn n f) xs \\<up>\" and \"\\<forall>z. eval f (z # xs) \\<down>\"\n    | (diverg_f) \"eval (Mn n f) xs \\<up>\" and \"\\<exists>z. eval f (z # xs) \\<up>\"\n    | (converg) \"eval (Mn n f) xs \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>eval (Mn n f) xs \\<up>;\n              \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>eval (Mn n f) xs \\<up>;\n      \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     eval (Mn n f) xs \\<down> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by fast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>eval (Mn n f) xs \\<up>;\n            \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Mn n f) xs \\<up>;\n    \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   eval (Mn n f) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>eval (Mn n f) xs \\<up>;\n            \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Mn n f) xs \\<up>;\n    \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   eval (Mn n f) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>eval (Mn n f) xs \\<up>;\n            \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n           \\<Longrightarrow> ?thesis1;\n   \\<lbrakk>eval (Mn n f) xs \\<up>;\n    \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n   \\<Longrightarrow> ?thesis1;\n   eval (Mn n f) xs \\<down> \\<Longrightarrow> ?thesis1\\<rbrakk>\n  \\<Longrightarrow> ?thesis1\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "case diverg"], ["proof (state)\nthis:\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>", "have \"\\<forall>z. eval f (z # xs) \\<noteq> Some 0\""], ["proof (prove)\nusing this:\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>z. eval f (z # xs) \\<noteq> Some 0", "using eval_Mn_diverg[OF valid(2)]"], ["proof (prove)\nusing this:\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n  (\\<nexists>z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>)) =\n  (eval (Mn n f) xs \\<up>)\n\ngoal (1 subgoal):\n 1. \\<forall>z. eval f (z # xs) \\<noteq> Some 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>z. eval f (z # xs) \\<noteq> Some 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>z. eval f (z # xs) \\<noteq> Some 0", "have \"\\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}\" for z"], ["proof (prove)\nusing this:\n  \\<forall>z. eval f (z # xs) \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}", "using diverg"], ["proof (prove)\nusing this:\n  \\<forall>z. eval f (z # xs) \\<noteq> Some 0\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>y<z. eval f (y # xs) \\<notin> {None, Some 0}", "by simp"], ["proof (state)\nthis:\n  \\<forall>y<?z1. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  \\<forall>y<?z1. eval f (y # xs) \\<notin> {None, Some 0}", "have reach_z:\n      \"\\<And>z. reachable (?stack, None) ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\""], ["proof (prove)\nusing this:\n  \\<forall>y<?z1. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       reachable ((Mn n f, xs, []) # rest, None)\n        ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "using reachable_Mn[OF assms] diverg"], ["proof (prove)\nusing this:\n  \\<forall>y<?z1. eval f (y # xs) \\<notin> {None, Some 0}\n  \\<lbrakk>\\<And>xs rest.\n              valid ((f, xs, []) # rest) \\<Longrightarrow>\n              valid ((f, xs, []) # rest);\n   \\<forall>y<?z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n  \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                     ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>z.\n       reachable ((Mn n f, xs, []) # rest, None)\n        ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, ?z1 # xs, []) # (Mn n f, xs, [?z1]) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "define h :: \"nat \\<Rightarrow> configuration\" where\n      \"h z \\<equiv> ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\" for z"], ["proof (state)\nthis:\n  h ?z \\<equiv> ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  h ?z \\<equiv> ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)", "have h_inj: \"\\<And>x y. x \\<noteq> y \\<Longrightarrow> h x \\<noteq> h y\" and z_neq_Nil: \"\\<And>z. fst (h z) \\<noteq> []\""], ["proof (prove)\nusing this:\n  h ?z \\<equiv> ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n\ngoal (1 subgoal):\n 1. (\\<And>x y. x \\<noteq> y \\<Longrightarrow> h x \\<noteq> h y) &&&\n    (\\<And>z. fst (h z) \\<noteq> [])", "by simp_all"], ["proof (state)\nthis:\n  ?x1 \\<noteq> ?y1 \\<Longrightarrow> h ?x1 \\<noteq> h ?y1\n  fst (h ?z1) \\<noteq> []\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have z: \"\\<exists>z\\<^sub>0. \\<forall>z>z\\<^sub>0. \\<not> (\\<exists>t'\\<le>t. iterate t' step (?stack, None) = h z)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>t.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>0.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n 2. \\<And>t.\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z) \\<Longrightarrow>\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>Suc t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>0.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n 2. \\<And>t.\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z) \\<Longrightarrow>\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>Suc t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>0.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "by (metis h_inj le_zero_eq less_not_refl3)"], ["proof (state)\nthis:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>0.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z) \\<Longrightarrow>\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>Suc t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z) \\<Longrightarrow>\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>Suc t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z)", "case (Suc t)"], ["proof (state)\nthis:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>t.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z) \\<Longrightarrow>\n       \\<exists>z\\<^sub>0.\n          \\<forall>z>z\\<^sub>0.\n             \\<not> (\\<exists>t'\\<le>Suc t.\n                        iterate t' step ((Mn n f, xs, []) # rest, None) =\n                        h z)", "then"], ["proof (chain)\npicking this:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>t.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>t.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>Suc t.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "using h_inj"], ["proof (prove)\nusing this:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>t.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n  ?x1 \\<noteq> ?y1 \\<Longrightarrow> h ?x1 \\<noteq> h ?y1\n\ngoal (1 subgoal):\n 1. \\<exists>z\\<^sub>0.\n       \\<forall>z>z\\<^sub>0.\n          \\<not> (\\<exists>t'\\<le>Suc t.\n                     iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "by (metis (no_types, hide_lams) le_Suc_eq less_not_refl3 less_trans)"], ["proof (state)\nthis:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>Suc t.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>?t1.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating ((Mn n f, xs, []) # rest, None)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "assume \"\\<not> nonterminating (?stack, None)\""], ["proof (state)\nthis:\n  \\<not> nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> nonterminating ((Mn n f, xs, []) # rest, None)", "obtain t where t: \"fst (iterate t step (?stack, None)) = []\""], ["proof (prove)\nusing this:\n  \\<not> nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        fst (iterate t step ((Mn n f, xs, []) # rest, None)) =\n        [] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  fst (iterate t step ((Mn n f, xs, []) # rest, None)) = []\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  fst (iterate t step ((Mn n f, xs, []) # rest, None)) = []", "obtain z\\<^sub>0 where \"\\<forall>z>z\\<^sub>0. \\<not> (\\<exists>t'\\<le>t. iterate t' step (?stack, None) = h z)\""], ["proof (prove)\nusing this:\n  fst (iterate t step ((Mn n f, xs, []) # rest, None)) = []\n\ngoal (1 subgoal):\n 1. (\\<And>z\\<^sub>0.\n        \\<forall>z>z\\<^sub>0.\n           \\<not> (\\<exists>t'\\<le>t.\n                      iterate t' step ((Mn n f, xs, []) # rest, None) =\n                      h z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using z"], ["proof (prove)\nusing this:\n  fst (iterate t step ((Mn n f, xs, []) # rest, None)) = []\n  \\<exists>z\\<^sub>0.\n     \\<forall>z>z\\<^sub>0.\n        \\<not> (\\<exists>t'\\<le>?t1.\n                   iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. (\\<And>z\\<^sub>0.\n        \\<forall>z>z\\<^sub>0.\n           \\<not> (\\<exists>t'\\<le>t.\n                      iterate t' step ((Mn n f, xs, []) # rest, None) =\n                      h z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>z>z\\<^sub>0.\n     \\<not> (\\<exists>t'\\<le>t.\n                iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>z>z\\<^sub>0.\n     \\<not> (\\<exists>t'\\<le>t.\n                iterate t' step ((Mn n f, xs, []) # rest, None) = h z)", "have not_h: \"\\<forall>t'\\<le>t. iterate t' step (?stack, None) \\<noteq> h (Suc z\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>z>z\\<^sub>0.\n     \\<not> (\\<exists>t'\\<le>t.\n                iterate t' step ((Mn n f, xs, []) # rest, None) = h z)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<le>t.\n       iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n       h (Suc z\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t'\\<le>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "have \"\\<forall>t'\\<ge>t. fst (iterate t' step (?stack, None)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []", "using t iterate_step_empty_stack iterate_additive'[of t]"], ["proof (prove)\nusing this:\n  fst (iterate t step ((Mn n f, xs, []) # rest, None)) = []\n  iterate ?t step ([], ?rv) = ([], ?rv)\n  iterate (t + ?t\\<^sub>2) ?f ?x = iterate ?t\\<^sub>2 ?f (iterate t ?f ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []", "by (metis le_Suc_ex prod.exhaust_sel)"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t.\n     fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<ge>t.\n     fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []", "have \"\\<forall>t'\\<ge>t. iterate t' step (?stack, None) \\<noteq> h (Suc z\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t.\n     fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n       h (Suc z\\<^sub>0)", "using z_neq_Nil"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t.\n     fst (iterate t' step ((Mn n f, xs, []) # rest, None)) = []\n  fst (h ?z1) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n       h (Suc z\\<^sub>0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<ge>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)", "have \"\\<forall>t'. iterate t' step (?stack, None) \\<noteq> h (Suc z\\<^sub>0)\""], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>t'.\n       iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n       h (Suc z\\<^sub>0)", "using not_h nat_le_linear"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n  \\<forall>t'\\<le>t.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n  ?m \\<le> ?n \\<or> ?n \\<le> ?m\n\ngoal (1 subgoal):\n 1. \\<forall>t'.\n       iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n       h (Suc z\\<^sub>0)", "by auto"], ["proof (state)\nthis:\n  \\<forall>t'.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<forall>t'.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)", "have \"\\<not> reachable (?stack, None) (h (Suc z\\<^sub>0))\""], ["proof (prove)\nusing this:\n  \\<forall>t'.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))", "using reachable_def"], ["proof (prove)\nusing this:\n  \\<forall>t'.\n     iterate t' step ((Mn n f, xs, []) # rest, None) \\<noteq>\n     h (Suc z\\<^sub>0)\n  reachable ?x ?y \\<equiv> \\<exists>t. iterate t step ?x = ?y\n\ngoal (1 subgoal):\n 1. \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))", "by simp"], ["proof (state)\nthis:\n  \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))\n\ngoal (1 subgoal):\n 1. \\<not> nonterminating ((Mn n f, xs, []) # rest, None) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))", "show False"], ["proof (prove)\nusing this:\n  \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))\n\ngoal (1 subgoal):\n 1. False", "using reach_z[of \"Suc z\\<^sub>0\"] h_def"], ["proof (prove)\nusing this:\n  \\<not> reachable ((Mn n f, xs, []) # rest, None) (h (Suc z\\<^sub>0))\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, Suc z\\<^sub>0 # xs, []) # (Mn n f, xs, [Suc z\\<^sub>0]) # rest,\n    None)\n  h ?z \\<equiv> ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<forall>z. eval f (z # xs) \\<down>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 3. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  nonterminating ((Mn n f, xs, []) # rest, None)", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "using diverg"], ["proof (prove)\nusing this:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n  eval (Mn n f) xs \\<up>\n  \\<forall>z. eval f (z # xs) \\<down>\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Mn n f, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "case diverg_f"], ["proof (state)\nthis:\n  eval (Mn n f) xs \\<up>\n  \\<exists>z. eval f (z # xs) \\<up>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "let ?P = \"\\<lambda>z. eval f (z # xs) \\<up>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "define zmin where \"zmin \\<equiv> Least ?P\""], ["proof (state)\nthis:\n  zmin \\<equiv> LEAST z. eval f (z # xs) \\<up>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  zmin \\<equiv> LEAST z. eval f (z # xs) \\<up>", "have \"\\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\""], ["proof (prove)\nusing this:\n  zmin \\<equiv> LEAST z. eval f (z # xs) \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}", "using diverg_f eval_Mn_diverg[OF valid(2)] less_trans not_less_Least[of _ ?P]"], ["proof (prove)\nusing this:\n  zmin \\<equiv> LEAST z. eval f (z # xs) \\<up>\n  eval (Mn n f) xs \\<up>\n  \\<exists>z. eval f (z # xs) \\<up>\n  (\\<nexists>z.\n      eval f (z # xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval f (y # xs) \\<down>)) =\n  (eval (Mn n f) xs \\<up>)\n  \\<lbrakk>?x < ?y; ?y < ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  ?k < (LEAST x. eval f (x # xs) \\<up>) \\<Longrightarrow>\n  eval f (?k # xs) \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}", "by blast"], ["proof (state)\nthis:\n  \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have f_zmin: \"eval f (zmin # xs) \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f (zmin # xs) \\<up>", "using diverg_f LeastI_ex[of ?P] zmin_def"], ["proof (prove)\nusing this:\n  eval (Mn n f) xs \\<up>\n  \\<exists>z. eval f (z # xs) \\<up>\n  \\<exists>x. eval f (x # xs) \\<up> \\<Longrightarrow>\n  eval f ((LEAST z. eval f (z # xs) \\<up>) # xs) \\<up>\n  zmin \\<equiv> LEAST z. eval f (z # xs) \\<up>\n\ngoal (1 subgoal):\n 1. eval f (zmin # xs) \\<up>", "by simp"], ["proof (state)\nthis:\n  eval f (zmin # xs) \\<up>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\n  eval f (zmin # xs) \\<up>", "have\n      \"reachable (?stack, None) ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\"\n        (is \"reachable _ (?stack1, None)\")"], ["proof (prove)\nusing this:\n  \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\n  eval f (zmin # xs) \\<up>\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)", "using reachable_Mn[OF assms]"], ["proof (prove)\nusing this:\n  \\<forall>y<zmin. eval f (y # xs) \\<notin> {None, Some 0}\n  eval f (zmin # xs) \\<up>\n  \\<lbrakk>\\<And>xs rest.\n              valid ((f, xs, []) # rest) \\<Longrightarrow>\n              valid ((f, xs, []) # rest);\n   \\<forall>y<?z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n  \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                     ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "moreover"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have \"nonterminating (?stack1, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)", "using f_zmin assms valid diverg_f valid_ConsI"], ["proof (prove)\nusing this:\n  eval f (zmin # xs) \\<up>\n  valid ((Mn n f, xs, []) # rest)\n  valid ((f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, ?xs, []) # ?rest, None)\n  valid rest\n  recfn (length xs) (Mn n f)\n  eval (Mn n f) xs \\<up>\n  \\<exists>z. eval f (z # xs) \\<up>\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n\ngoal (1 subgoal):\n 1. nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)", "by auto"], ["proof (state)\nthis:\n  nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "ultimately"], ["proof (chain)\npicking this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n  nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n  nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n\ngoal (1 subgoal):\n 1. nonterminating ((Mn n f, xs, []) # rest, None)", "using reachable_nonterminating"], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n  nonterminating ((f, zmin # xs, []) # (Mn n f, xs, [zmin]) # rest, None)\n  \\<lbrakk>reachable ?x ?y; nonterminating ?y\\<rbrakk>\n  \\<Longrightarrow> nonterminating ?x\n\ngoal (1 subgoal):\n 1. nonterminating ((Mn n f, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval (Mn n f) xs \\<up>;\n     \\<exists>z. eval f (z # xs) \\<up>\\<rbrakk>\n    \\<Longrightarrow> correct ((Mn n f, xs, []) # rest, None)\n 2. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  nonterminating ((Mn n f, xs, []) # rest, None)", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "using diverg_f"], ["proof (prove)\nusing this:\n  nonterminating ((Mn n f, xs, []) # rest, None)\n  eval (Mn n f) xs \\<up>\n  \\<exists>z. eval f (z # xs) \\<up>\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Mn n f, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "case converg"], ["proof (state)\nthis:\n  eval (Mn n f) xs \\<down>\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval (Mn n f) xs \\<down>", "obtain z where z: \"eval (Mn n f) xs \\<down>= z\""], ["proof (prove)\nusing this:\n  eval (Mn n f) xs \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        eval (Mn n f) xs \\<down>= z \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (Mn n f) xs \\<down>= z\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have f_z: \"eval f (z # xs) \\<down>= 0\"\n      and f_less_z: \"\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 &&&\n    (\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0)", "using eval_Mn_convergE(2,3)[OF valid(2) z]"], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0\n  ?y < z \\<Longrightarrow> eval f (?y # xs) \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval f (z # xs) \\<down>= 0 &&&\n    (\\<And>y. y < z \\<Longrightarrow> eval f (y # xs) \\<down>\\<noteq> 0)", "by simp_all"], ["proof (state)\nthis:\n  eval f (z # xs) \\<down>= 0\n  ?y1 < z \\<Longrightarrow> eval f (?y1 # xs) \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  eval f (z # xs) \\<down>= 0\n  ?y1 < z \\<Longrightarrow> eval f (?y1 # xs) \\<down>\\<noteq> 0", "have\n      \"reachable (?stack, None) ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\""], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0\n  ?y1 < z \\<Longrightarrow> eval f (?y1 # xs) \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "using reachable_Mn[OF assms]"], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0\n  ?y1 < z \\<Longrightarrow> eval f (?y1 # xs) \\<down>\\<noteq> 0\n  \\<lbrakk>\\<And>xs rest.\n              valid ((f, xs, []) # rest) \\<Longrightarrow>\n              valid ((f, xs, []) # rest);\n   \\<forall>y<?z. eval f (y # xs) \\<notin> {None, Some 0}\\<rbrakk>\n  \\<Longrightarrow> reachable ((Mn n f, xs, []) # rest, None)\n                     ((f, ?z # xs, []) # (Mn n f, xs, [?z]) # rest, None)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None)\n     ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)", "by simp"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None)\n   ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have \"reachable ... ((Mn n f, xs, [z]) # rest, eval f (z # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n     ((Mn n f, xs, [z]) # rest, eval f (z # xs))", "using assms(2)[of \"z # xs\"] valid f_z valid_ConsI correct_convergE"], ["proof (prove)\nusing this:\n  valid ((f, z # xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f, z # xs, []) # ?rest, None)\n  valid rest\n  recfn (length xs) (Mn n f)\n  eval f (z # xs) \\<down>= 0\n  \\<lbrakk>valid ?rest; recfn (length ?xs) ?f\\<rbrakk>\n  \\<Longrightarrow> valid ((?f, ?xs, ?locs) # ?rest)\n  \\<lbrakk>correct ((?f, ?xs, ?ls) # ?rest, None);\n   eval ?f ?xs \\<down>\\<rbrakk>\n  \\<Longrightarrow> reachable ((?f, ?xs, ?ls) # ?rest, None)\n                     (?rest, eval ?f ?xs)\n\ngoal (1 subgoal):\n 1. reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n     ((Mn n f, xs, [z]) # rest, eval f (z # xs))", "by auto"], ["proof (state)\nthis:\n  reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n   ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "also"], ["proof (state)\nthis:\n  reachable ((f, z # xs, []) # (Mn n f, xs, [z]) # rest, None)\n   ((Mn n f, xs, [z]) # rest, eval f (z # xs))\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "have \"reachable ... (rest, Some z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs)) (rest, Some z)", "using f_z f_less_z step_reachable"], ["proof (prove)\nusing this:\n  eval f (z # xs) \\<down>= 0\n  ?y1 < z \\<Longrightarrow> eval f (?y1 # xs) \\<down>\\<noteq> 0\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs)) (rest, Some z)", "by auto"], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, [z]) # rest, eval f (z # xs)) (rest, Some z)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "finally"], ["proof (chain)\npicking this:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)", "have \"reachable (?stack, None) (rest, Some z)\""], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)\n\ngoal (1 subgoal):\n 1. reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)", "."], ["proof (state)\nthis:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)\n\ngoal (1 subgoal):\n 1. eval (Mn n f) xs \\<down> \\<Longrightarrow>\n    correct ((Mn n f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)", "show ?thesis"], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "using z"], ["proof (prove)\nusing this:\n  reachable ((Mn n f, xs, []) # rest, None) (rest, Some z)\n  eval (Mn n f) xs \\<down>= z\n\ngoal (1 subgoal):\n 1. correct ((Mn n f, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Mn n f, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  correct ((Mn n f, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem step_correct:\n  assumes \"valid ((f, xs, []) # rest)\"\n  shows \"correct ((f, xs, []) # rest, None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. correct ((f, xs, []) # rest, None)", "using assms"], ["proof (prove)\nusing this:\n  valid ((f, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((f, xs, []) # rest, None)", "proof (induction f arbitrary: xs rest)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>xs rest.\n       valid ((Z, xs, []) # rest) \\<Longrightarrow>\n       correct ((Z, xs, []) # rest, None)\n 2. \\<And>xs rest.\n       valid ((S, xs, []) # rest) \\<Longrightarrow>\n       correct ((S, xs, []) # rest, None)\n 3. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 4. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 5. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 6. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case Z"], ["proof (state)\nthis:\n  valid ((Z, xs, []) # rest)\n\ngoal (6 subgoals):\n 1. \\<And>xs rest.\n       valid ((Z, xs, []) # rest) \\<Longrightarrow>\n       correct ((Z, xs, []) # rest, None)\n 2. \\<And>xs rest.\n       valid ((S, xs, []) # rest) \\<Longrightarrow>\n       correct ((S, xs, []) # rest, None)\n 3. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 4. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 5. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 6. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((Z, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((Z, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Z, xs, []) # rest, None)", "using valid_ConsE[of Z] step_reachable"], ["proof (prove)\nusing this:\n  valid ((Z, xs, []) # rest)\n  valid ((Z, ?xs, ?locs) # ?rest) \\<Longrightarrow>\n  valid ?rest \\<and> recfn (length ?xs) Z\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. correct ((Z, xs, []) # rest, None)", "by auto"], ["proof (state)\nthis:\n  correct ((Z, xs, []) # rest, None)\n\ngoal (5 subgoals):\n 1. \\<And>xs rest.\n       valid ((S, xs, []) # rest) \\<Longrightarrow>\n       correct ((S, xs, []) # rest, None)\n 2. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 3. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 4. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 5. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>xs rest.\n       valid ((S, xs, []) # rest) \\<Longrightarrow>\n       correct ((S, xs, []) # rest, None)\n 2. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 3. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 4. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 5. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case S"], ["proof (state)\nthis:\n  valid ((S, xs, []) # rest)\n\ngoal (5 subgoals):\n 1. \\<And>xs rest.\n       valid ((S, xs, []) # rest) \\<Longrightarrow>\n       correct ((S, xs, []) # rest, None)\n 2. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 3. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 4. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 5. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((S, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((S, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((S, xs, []) # rest, None)", "using valid_ConsE[of S] step_reachable"], ["proof (prove)\nusing this:\n  valid ((S, xs, []) # rest)\n  valid ((S, ?xs, ?locs) # ?rest) \\<Longrightarrow>\n  valid ?rest \\<and> recfn (length ?xs) S\n  step ?x = ?y \\<Longrightarrow> reachable ?x ?y\n\ngoal (1 subgoal):\n 1. correct ((S, xs, []) # rest, None)", "by auto"], ["proof (state)\nthis:\n  correct ((S, xs, []) # rest, None)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 2. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 3. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 4. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 2. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 3. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 4. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case (Id m n)"], ["proof (state)\nthis:\n  valid ((recf.Id m n, xs, []) # rest)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 xs rest.\n       valid ((recf.Id x1 x2, xs, []) # rest) \\<Longrightarrow>\n       correct ((recf.Id x1 x2, xs, []) # rest, None)\n 2. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 3. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 4. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((recf.Id m n, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((recf.Id m n, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((recf.Id m n, xs, []) # rest, None)", "using valid_ConsE[of \"Id m n\"]"], ["proof (prove)\nusing this:\n  valid ((recf.Id m n, xs, []) # rest)\n  valid ((recf.Id m n, ?xs, ?locs) # ?rest) \\<Longrightarrow>\n  valid ?rest \\<and> recfn (length ?xs) (recf.Id m n)\n\ngoal (1 subgoal):\n 1. correct ((recf.Id m n, xs, []) # rest, None)", "by auto"], ["proof (state)\nthis:\n  correct ((recf.Id m n, xs, []) # rest, None)\n\ngoal (3 subgoals):\n 1. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 2. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 3. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 2. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 3. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case Cn"], ["proof (state)\nthis:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  \\<lbrakk>?x3a \\<in> set x3_; valid ((?x3a, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?x3a, ?xs, []) # ?rest, None)\n  valid ((Cn x1_ f_ x3_, xs, []) # rest)\n\ngoal (3 subgoals):\n 1. \\<And>x1 f x3 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        \\<And>x3a xs rest.\n           \\<lbrakk>x3a \\<in> set x3; valid ((x3a, xs, []) # rest)\\<rbrakk>\n           \\<Longrightarrow> correct ((x3a, xs, []) # rest, None);\n        valid ((Cn x1 f x3, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Cn x1 f x3, xs, []) # rest, None)\n 2. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 3. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  \\<lbrakk>?x3a \\<in> set x3_; valid ((?x3a, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?x3a, ?xs, []) # ?rest, None)\n  valid ((Cn x1_ f_ x3_, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  \\<lbrakk>?x3a \\<in> set x3_; valid ((?x3a, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?x3a, ?xs, []) # ?rest, None)\n  valid ((Cn x1_ f_ x3_, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Cn x1_ f_ x3_, xs, []) # rest, None)", "using step_Cn_correct"], ["proof (prove)\nusing this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  \\<lbrakk>?x3a \\<in> set x3_; valid ((?x3a, ?xs, []) # ?rest)\\<rbrakk>\n  \\<Longrightarrow> correct ((?x3a, ?xs, []) # ?rest, None)\n  valid ((Cn x1_ f_ x3_, xs, []) # rest)\n  \\<lbrakk>valid ((Cn ?n ?f ?gs, ?xs, []) # ?rest);\n   \\<And>xs rest.\n      valid ((?f, xs, []) # rest) \\<Longrightarrow>\n      correct ((?f, xs, []) # rest, None);\n   \\<And>g xs rest.\n      \\<lbrakk>g \\<in> set ?gs; valid ((g, xs, []) # rest)\\<rbrakk>\n      \\<Longrightarrow> correct ((g, xs, []) # rest, None)\\<rbrakk>\n  \\<Longrightarrow> correct ((Cn ?n ?f ?gs, ?xs, []) # ?rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Cn x1_ f_ x3_, xs, []) # rest, None)", "by presburger"], ["proof (state)\nthis:\n  correct ((Cn x1_ f_ x3_, xs, []) # rest, None)\n\ngoal (2 subgoals):\n 1. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 2. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 2. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case Pr"], ["proof (state)\nthis:\n  valid ((f1_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f1_, ?xs, []) # ?rest, None)\n  valid ((f2_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f2_, ?xs, []) # ?rest, None)\n  valid ((Pr x1_ f1_ f2_, xs, []) # rest)\n\ngoal (2 subgoals):\n 1. \\<And>x1 f1 f2 xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f1, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f1, xs, []) # rest, None);\n        \\<And>xs rest.\n           valid ((f2, xs, []) # rest) \\<Longrightarrow>\n           correct ((f2, xs, []) # rest, None);\n        valid ((Pr x1 f1 f2, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Pr x1 f1 f2, xs, []) # rest, None)\n 2. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((f1_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f1_, ?xs, []) # ?rest, None)\n  valid ((f2_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f2_, ?xs, []) # ?rest, None)\n  valid ((Pr x1_ f1_ f2_, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((f1_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f1_, ?xs, []) # ?rest, None)\n  valid ((f2_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f2_, ?xs, []) # ?rest, None)\n  valid ((Pr x1_ f1_ f2_, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Pr x1_ f1_ f2_, xs, []) # rest, None)", "using step_Pr_correct"], ["proof (prove)\nusing this:\n  valid ((f1_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f1_, ?xs, []) # ?rest, None)\n  valid ((f2_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f2_, ?xs, []) # ?rest, None)\n  valid ((Pr x1_ f1_ f2_, xs, []) # rest)\n  \\<lbrakk>valid ((Pr ?n ?f ?g, ?xs, []) # ?rest);\n   \\<And>xs rest.\n      valid ((?f, xs, []) # rest) \\<Longrightarrow>\n      correct ((?f, xs, []) # rest, None);\n   \\<And>xs rest.\n      valid ((?g, xs, []) # rest) \\<Longrightarrow>\n      correct ((?g, xs, []) # rest, None)\\<rbrakk>\n  \\<Longrightarrow> correct ((Pr ?n ?f ?g, ?xs, []) # ?rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Pr x1_ f1_ f2_, xs, []) # rest, None)", "by simp"], ["proof (state)\nthis:\n  correct ((Pr x1_ f1_ f2_, xs, []) # rest, None)\n\ngoal (1 subgoal):\n 1. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "case Mn"], ["proof (state)\nthis:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  valid ((Mn x1_ f_, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. \\<And>x1 f xs rest.\n       \\<lbrakk>\\<And>xs rest.\n                   valid ((f, xs, []) # rest) \\<Longrightarrow>\n                   correct ((f, xs, []) # rest, None);\n        valid ((Mn x1 f, xs, []) # rest)\\<rbrakk>\n       \\<Longrightarrow> correct ((Mn x1 f, xs, []) # rest, None)", "then"], ["proof (chain)\npicking this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  valid ((Mn x1_ f_, xs, []) # rest)", "show ?case"], ["proof (prove)\nusing this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  valid ((Mn x1_ f_, xs, []) # rest)\n\ngoal (1 subgoal):\n 1. correct ((Mn x1_ f_, xs, []) # rest, None)", "using step_Mn_correct"], ["proof (prove)\nusing this:\n  valid ((f_, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((f_, ?xs, []) # ?rest, None)\n  valid ((Mn x1_ f_, xs, []) # rest)\n  \\<lbrakk>valid ((Mn ?n ?f, ?xs, []) # ?rest);\n   \\<And>xs rest.\n      valid ((?f, xs, []) # rest) \\<Longrightarrow>\n      correct ((?f, xs, []) # rest, None)\\<rbrakk>\n  \\<Longrightarrow> correct ((Mn ?n ?f, ?xs, []) # ?rest, None)\n\ngoal (1 subgoal):\n 1. correct ((Mn x1_ f_, xs, []) # rest, None)", "by presburger"], ["proof (state)\nthis:\n  correct ((Mn x1_ f_, xs, []) # rest, None)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Encoding partial recursive functions\\label{s:recf_enc}\\<close>"], ["", "text \\<open>In this section we define an injective, but not surjective,\nmapping from @{typ recf}s to natural numbers.\\<close>"], ["", "abbreviation triple_encode :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n   \"triple_encode x y z \\<equiv> prod_encode (x, prod_encode (y, z))\""], ["", "abbreviation quad_encode :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n   \"quad_encode w x y z \\<equiv> prod_encode (w, prod_encode (x, prod_encode (y, z)))\""], ["", "fun encode :: \"recf \\<Rightarrow> nat\" where\n  \"encode Z = 0\"\n| \"encode S = 1\"\n| \"encode (Id m n) = triple_encode 2 m n\"\n| \"encode (Cn n f gs) = quad_encode 3 n (encode f) (list_encode (map encode gs))\"\n| \"encode (Pr n f g) = quad_encode 4 n (encode f) (encode g)\"\n| \"encode (Mn n f) = triple_encode 5 n (encode f)\""], ["", "lemma prod_encode_gr1: \"a > 1 \\<Longrightarrow> prod_encode (a, x) > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < a \\<Longrightarrow> 1 < prod_encode (a, x)", "using le_prod_encode_1 less_le_trans"], ["proof (prove)\nusing this:\n  ?a \\<le> prod_encode (?a, ?b)\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n\ngoal (1 subgoal):\n 1. 1 < a \\<Longrightarrow> 1 < prod_encode (a, x)", "by blast"], ["", "lemma encode_not_Z_or_S: \"encode f = prod_encode (a, b) \\<Longrightarrow> a > 1 \\<Longrightarrow> f \\<noteq> Z \\<and> f \\<noteq> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>encode f = prod_encode (a, b); 1 < a\\<rbrakk>\n    \\<Longrightarrow> f \\<noteq> Z \\<and> f \\<noteq> S", "by (metis encode.simps(1) encode.simps(2) less_numeral_extra(4) not_one_less_zero\n    prod_encode_gr1)"], ["", "lemma encode_injective: \"encode f = encode g \\<Longrightarrow> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode f = encode g \\<Longrightarrow> f = g", "proof (induction g arbitrary: f)"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>f. encode f = encode Z \\<Longrightarrow> f = Z\n 2. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 3. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 4. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 5. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 6. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case Z"], ["proof (state)\nthis:\n  encode f = encode Z\n\ngoal (6 subgoals):\n 1. \\<And>f. encode f = encode Z \\<Longrightarrow> f = Z\n 2. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 3. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 4. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 5. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 6. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "have \"\\<And>a x. a > 1 \\<Longrightarrow> prod_encode (a, x) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x. 1 < a \\<Longrightarrow> 0 < prod_encode (a, x)", "using prod_encode_gr1"], ["proof (prove)\nusing this:\n  1 < ?a \\<Longrightarrow> 1 < prod_encode (?a, ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a x. 1 < a \\<Longrightarrow> 0 < prod_encode (a, x)", "by (meson less_one less_trans)"], ["proof (state)\nthis:\n  1 < ?a \\<Longrightarrow> 0 < prod_encode (?a, ?x)\n\ngoal (6 subgoals):\n 1. \\<And>f. encode f = encode Z \\<Longrightarrow> f = Z\n 2. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 3. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 4. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 5. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 6. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  1 < ?a \\<Longrightarrow> 0 < prod_encode (?a, ?x)", "have \"f \\<noteq> Z \\<Longrightarrow> encode f > 0\""], ["proof (prove)\nusing this:\n  1 < ?a \\<Longrightarrow> 0 < prod_encode (?a, ?x)\n\ngoal (1 subgoal):\n 1. f \\<noteq> Z \\<Longrightarrow> 0 < encode f", "by (cases f) auto"], ["proof (state)\nthis:\n  f \\<noteq> Z \\<Longrightarrow> 0 < encode f\n\ngoal (6 subgoals):\n 1. \\<And>f. encode f = encode Z \\<Longrightarrow> f = Z\n 2. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 3. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 4. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 5. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 6. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  f \\<noteq> Z \\<Longrightarrow> 0 < encode f", "have \"encode f = 0 \\<Longrightarrow> f = Z\""], ["proof (prove)\nusing this:\n  f \\<noteq> Z \\<Longrightarrow> 0 < encode f\n\ngoal (1 subgoal):\n 1. encode f = 0 \\<Longrightarrow> f = Z", "by fastforce"], ["proof (state)\nthis:\n  encode f = 0 \\<Longrightarrow> f = Z\n\ngoal (6 subgoals):\n 1. \\<And>f. encode f = encode Z \\<Longrightarrow> f = Z\n 2. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 3. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 4. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 5. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 6. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode f = 0 \\<Longrightarrow> f = Z", "show ?case"], ["proof (prove)\nusing this:\n  encode f = 0 \\<Longrightarrow> f = Z\n\ngoal (1 subgoal):\n 1. f = Z", "using Z"], ["proof (prove)\nusing this:\n  encode f = 0 \\<Longrightarrow> f = Z\n  encode f = encode Z\n\ngoal (1 subgoal):\n 1. f = Z", "by simp"], ["proof (state)\nthis:\n  f = Z\n\ngoal (5 subgoals):\n 1. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 2. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 3. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 4. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 5. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 2. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 3. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 4. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 5. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case S"], ["proof (state)\nthis:\n  encode f = encode S\n\ngoal (5 subgoals):\n 1. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 2. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 3. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 4. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 5. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "have \"\\<And>a x. a > 1 \\<Longrightarrow> prod_encode (a, x) \\<noteq> Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x. 1 < a \\<Longrightarrow> prod_encode (a, x) \\<noteq> Suc 0", "using prod_encode_gr1"], ["proof (prove)\nusing this:\n  1 < ?a \\<Longrightarrow> 1 < prod_encode (?a, ?x)\n\ngoal (1 subgoal):\n 1. \\<And>a x. 1 < a \\<Longrightarrow> prod_encode (a, x) \\<noteq> Suc 0", "by (metis One_nat_def less_numeral_extra(4))"], ["proof (state)\nthis:\n  1 < ?a \\<Longrightarrow> prod_encode (?a, ?x) \\<noteq> Suc 0\n\ngoal (5 subgoals):\n 1. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 2. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 3. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 4. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 5. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  1 < ?a \\<Longrightarrow> prod_encode (?a, ?x) \\<noteq> Suc 0", "have \"encode f = 1 \\<Longrightarrow> f = S\""], ["proof (prove)\nusing this:\n  1 < ?a \\<Longrightarrow> prod_encode (?a, ?x) \\<noteq> Suc 0\n\ngoal (1 subgoal):\n 1. encode f = 1 \\<Longrightarrow> f = S", "by (cases f) auto"], ["proof (state)\nthis:\n  encode f = 1 \\<Longrightarrow> f = S\n\ngoal (5 subgoals):\n 1. \\<And>f. encode f = encode S \\<Longrightarrow> f = S\n 2. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 3. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 4. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 5. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode f = 1 \\<Longrightarrow> f = S", "show ?case"], ["proof (prove)\nusing this:\n  encode f = 1 \\<Longrightarrow> f = S\n\ngoal (1 subgoal):\n 1. f = S", "using S"], ["proof (prove)\nusing this:\n  encode f = 1 \\<Longrightarrow> f = S\n  encode f = encode S\n\ngoal (1 subgoal):\n 1. f = S", "by simp"], ["proof (state)\nthis:\n  f = S\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 2. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 3. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 4. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 2. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 3. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 4. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case Id"], ["proof (state)\nthis:\n  encode f = encode (recf.Id x1_ x2_)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 2. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 3. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 4. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode f = encode (recf.Id x1_ x2_)", "obtain z where *: \"encode f = prod_encode (2, z)\""], ["proof (prove)\nusing this:\n  encode f = encode (recf.Id x1_ x2_)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        encode f = prod_encode (2, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  encode f = prod_encode (2, z)\n\ngoal (4 subgoals):\n 1. \\<And>x1 x2 f.\n       encode f = encode (recf.Id x1 x2) \\<Longrightarrow> f = recf.Id x1 x2\n 2. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 3. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 4. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = recf.Id x1_ x2_", "using Id"], ["proof (prove)\nusing this:\n  encode f = encode (recf.Id x1_ x2_)\n\ngoal (1 subgoal):\n 1. f = recf.Id x1_ x2_", "by (cases f) (simp_all add: * encode_not_Z_or_S prod_encode_eq)"], ["proof (state)\nthis:\n  f = recf.Id x1_ x2_\n\ngoal (3 subgoals):\n 1. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 2. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 3. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 2. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 3. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case Cn"], ["proof (state)\nthis:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  \\<lbrakk>?x3a \\<in> set x3_; encode ?f = encode ?x3a\\<rbrakk>\n  \\<Longrightarrow> ?f = ?x3a\n  encode f = encode (Cn x1_ g_ x3_)\n\ngoal (3 subgoals):\n 1. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 2. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 3. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  \\<lbrakk>?x3a \\<in> set x3_; encode ?f = encode ?x3a\\<rbrakk>\n  \\<Longrightarrow> ?f = ?x3a\n  encode f = encode (Cn x1_ g_ x3_)", "obtain z where *: \"encode f = prod_encode (3, z)\""], ["proof (prove)\nusing this:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  \\<lbrakk>?x3a \\<in> set x3_; encode ?f = encode ?x3a\\<rbrakk>\n  \\<Longrightarrow> ?f = ?x3a\n  encode f = encode (Cn x1_ g_ x3_)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        encode f = prod_encode (3, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  encode f = prod_encode (3, z)\n\ngoal (3 subgoals):\n 1. \\<And>x1 g x3 f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        \\<And>x3a f.\n           \\<lbrakk>x3a \\<in> set x3; encode f = encode x3a\\<rbrakk>\n           \\<Longrightarrow> f = x3a;\n        encode f = encode (Cn x1 g x3)\\<rbrakk>\n       \\<Longrightarrow> f = Cn x1 g x3\n 2. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 3. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "proof (cases f)"], ["proof (state)\ngoal (6 subgoals):\n 1. f = Z \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. f = S \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 5. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 6. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case Z"], ["proof (state)\nthis:\n  f = Z\n\ngoal (6 subgoals):\n 1. f = Z \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. f = S \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 5. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 6. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = Z", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Z\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using * encode_not_Z_or_S"], ["proof (prove)\nusing this:\n  f = Z\n  encode f = prod_encode (3, z)\n  \\<lbrakk>encode ?f = prod_encode (?a, ?b); 1 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<noteq> Z \\<and> ?f \\<noteq> S\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by simp"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 5. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 5. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case S"], ["proof (state)\nthis:\n  f = S\n\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 5. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = S", "show ?thesis"], ["proof (prove)\nusing this:\n  f = S\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using * encode_not_Z_or_S"], ["proof (prove)\nusing this:\n  f = S\n  encode f = prod_encode (3, z)\n  \\<lbrakk>encode ?f = prod_encode (?a, ?b); 1 < ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<noteq> Z \\<and> ?f \\<noteq> S\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by simp"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case Id"], ["proof (state)\nthis:\n  f = recf.Id x31_ x32_\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32. f = recf.Id x31 x32 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 4. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = recf.Id x31_ x32_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = recf.Id x31_ x32_\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using *"], ["proof (prove)\nusing this:\n  f = recf.Id x31_ x32_\n  encode f = prod_encode (3, z)\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by (simp add: prod_encode_eq)"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case Cn"], ["proof (state)\nthis:\n  f = Cn x41_ x42_ x43_\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 3. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = Cn x41_ x42_ x43_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Cn x41_ x42_ x43_\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using * Cn.IH Cn.prems list_decode_encode"], ["proof (prove)\nusing this:\n  f = Cn x41_ x42_ x43_\n  encode f = prod_encode (3, z)\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  \\<lbrakk>?x3a \\<in> set x3_; encode ?f = encode ?x3a\\<rbrakk>\n  \\<Longrightarrow> ?f = ?x3a\n  encode f = encode (Cn x1_ g_ x3_)\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by (smt encode.simps(4) fst_conv list.inj_map_strong prod_encode_eq snd_conv)"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case Pr"], ["proof (state)\nthis:\n  f = Pr x51_ x52_ x53_\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow> f = Cn x1_ g_ x3_\n 2. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = Pr x51_ x52_ x53_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Pr x51_ x52_ x53_\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using *"], ["proof (prove)\nusing this:\n  f = Pr x51_ x52_ x53_\n  encode f = prod_encode (3, z)\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by (simp add: prod_encode_eq)"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "case Mn"], ["proof (state)\nthis:\n  f = Mn x61_ x62_\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62. f = Mn x61 x62 \\<Longrightarrow> f = Cn x1_ g_ x3_", "then"], ["proof (chain)\npicking this:\n  f = Mn x61_ x62_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Mn x61_ x62_\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "using *"], ["proof (prove)\nusing this:\n  f = Mn x61_ x62_\n  encode f = prod_encode (3, z)\n\ngoal (1 subgoal):\n 1. f = Cn x1_ g_ x3_", "by (simp add: prod_encode_eq)"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = Cn x1_ g_ x3_\n\ngoal (2 subgoals):\n 1. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 2. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 2. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case Pr"], ["proof (state)\nthis:\n  encode ?f = encode g1_ \\<Longrightarrow> ?f = g1_\n  encode ?f = encode g2_ \\<Longrightarrow> ?f = g2_\n  encode f = encode (Pr x1_ g1_ g2_)\n\ngoal (2 subgoals):\n 1. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 2. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode ?f = encode g1_ \\<Longrightarrow> ?f = g1_\n  encode ?f = encode g2_ \\<Longrightarrow> ?f = g2_\n  encode f = encode (Pr x1_ g1_ g2_)", "obtain z where *: \"encode f = prod_encode (4, z)\""], ["proof (prove)\nusing this:\n  encode ?f = encode g1_ \\<Longrightarrow> ?f = g1_\n  encode ?f = encode g2_ \\<Longrightarrow> ?f = g2_\n  encode f = encode (Pr x1_ g1_ g2_)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        encode f = prod_encode (4, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  encode f = prod_encode (4, z)\n\ngoal (2 subgoals):\n 1. \\<And>x1 g1 g2 f.\n       \\<lbrakk>\\<And>f. encode f = encode g1 \\<Longrightarrow> f = g1;\n        \\<And>f. encode f = encode g2 \\<Longrightarrow> f = g2;\n        encode f = encode (Pr x1 g1 g2)\\<rbrakk>\n       \\<Longrightarrow> f = Pr x1 g1 g2\n 2. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = Pr x1_ g1_ g2_", "using Pr"], ["proof (prove)\nusing this:\n  encode ?f = encode g1_ \\<Longrightarrow> ?f = g1_\n  encode ?f = encode g2_ \\<Longrightarrow> ?f = g2_\n  encode f = encode (Pr x1_ g1_ g2_)\n\ngoal (1 subgoal):\n 1. f = Pr x1_ g1_ g2_", "by (cases f) (simp_all add: * encode_not_Z_or_S prod_encode_eq)"], ["proof (state)\nthis:\n  f = Pr x1_ g1_ g2_\n\ngoal (1 subgoal):\n 1. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "case Mn"], ["proof (state)\nthis:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  encode f = encode (Mn x1_ g_)\n\ngoal (1 subgoal):\n 1. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "then"], ["proof (chain)\npicking this:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  encode f = encode (Mn x1_ g_)", "obtain z where *: \"encode f = prod_encode (5, z)\""], ["proof (prove)\nusing this:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  encode f = encode (Mn x1_ g_)\n\ngoal (1 subgoal):\n 1. (\\<And>z.\n        encode f = prod_encode (5, z) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by simp"], ["proof (state)\nthis:\n  encode f = prod_encode (5, z)\n\ngoal (1 subgoal):\n 1. \\<And>x1 g f.\n       \\<lbrakk>\\<And>f. encode f = encode g \\<Longrightarrow> f = g;\n        encode f = encode (Mn x1 g)\\<rbrakk>\n       \\<Longrightarrow> f = Mn x1 g", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. f = Mn x1_ g_", "using Mn"], ["proof (prove)\nusing this:\n  encode ?f = encode g_ \\<Longrightarrow> ?f = g_\n  encode f = encode (Mn x1_ g_)\n\ngoal (1 subgoal):\n 1. f = Mn x1_ g_", "by (cases f) (simp_all add: * encode_not_Z_or_S prod_encode_eq)"], ["proof (state)\nthis:\n  f = Mn x1_ g_\n\ngoal:\nNo subgoals!", "qed"], ["", "definition encode_kind :: \"nat \\<Rightarrow> nat\" where\n  \"encode_kind e \\<equiv> if e = 0 then 0 else if e = 1 then 1 else pdec1 e\""], ["", "lemma encode_kind_0: \"encode_kind (encode Z) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode Z) = 0", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode Z = 0 then 0\n     else if encode Z = 1 then 1 else pdec1 (encode Z)) =\n    0", "by simp"], ["", "lemma encode_kind_1: \"encode_kind (encode S) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode S) = 1", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode S = 0 then 0\n     else if encode S = 1 then 1 else pdec1 (encode S)) =\n    1", "by simp"], ["", "lemma encode_kind_2: \"encode_kind (encode (Id m n)) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode (recf.Id m n)) = 2", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode (recf.Id m n) = 0 then 0\n     else if encode (recf.Id m n) = 1 then 1\n          else pdec1 (encode (recf.Id m n))) =\n    2", "by (metis encode.simps(1-3) encode_injective fst_conv prod_encode_inverse\n    recf.simps(16) recf.simps(8))"], ["", "lemma encode_kind_3: \"encode_kind (encode (Cn n f gs)) = 3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode (Cn n f gs)) = 3", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode (Cn n f gs) = 0 then 0\n     else if encode (Cn n f gs) = 1 then 1\n          else pdec1 (encode (Cn n f gs))) =\n    3", "by (metis encode.simps(1,2,4) encode_injective fst_conv prod_encode_inverse\n    recf.simps(10) recf.simps(18))"], ["", "lemma encode_kind_4: \"encode_kind (encode (Pr n f g)) = 4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode (Pr n f g)) = 4", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode (Pr n f g) = 0 then 0\n     else if encode (Pr n f g) = 1 then 1 else pdec1 (encode (Pr n f g))) =\n    4", "by (metis encode.simps(1,2,5) encode_injective fst_conv prod_encode_inverse\n    recf.simps(12) recf.simps(20))"], ["", "lemma encode_kind_5: \"encode_kind (encode (Mn n f)) = 5\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (encode (Mn n f)) = 5", "unfolding encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if encode (Mn n f) = 0 then 0\n     else if encode (Mn n f) = 1 then 1 else pdec1 (encode (Mn n f))) =\n    5", "by (metis encode.simps(1,2,6) encode_injective fst_conv prod_encode_inverse\n    recf.simps(14) recf.simps(22))"], ["", "lemmas encode_kind_n =\n  encode_kind_0 encode_kind_1 encode_kind_2 encode_kind_3 encode_kind_4 encode_kind_5"], ["", "lemma encode_kind_Cn:\n  assumes \"encode_kind (encode f) = 3\"\n  shows \"\\<exists>n f' gs. f = Cn n f' gs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n f' gs. f = Cn n f' gs", "using assms encode_kind_n"], ["proof (prove)\nusing this:\n  encode_kind (encode f) = 3\n  encode_kind (encode Z) = 0\n  encode_kind (encode S) = 1\n  encode_kind (encode (recf.Id ?m ?n)) = 2\n  encode_kind (encode (Cn ?n ?f ?gs)) = 3\n  encode_kind (encode (Pr ?n ?f ?g)) = 4\n  encode_kind (encode (Mn ?n ?f)) = 5\n\ngoal (1 subgoal):\n 1. \\<exists>n f' gs. f = Cn n f' gs", "by (cases f) auto"], ["", "lemma encode_kind_Pr:\n  assumes \"encode_kind (encode f) = 4\"\n  shows \"\\<exists>n f' g. f = Pr n f' g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n f' g. f = Pr n f' g", "using assms encode_kind_n"], ["proof (prove)\nusing this:\n  encode_kind (encode f) = 4\n  encode_kind (encode Z) = 0\n  encode_kind (encode S) = 1\n  encode_kind (encode (recf.Id ?m ?n)) = 2\n  encode_kind (encode (Cn ?n ?f ?gs)) = 3\n  encode_kind (encode (Pr ?n ?f ?g)) = 4\n  encode_kind (encode (Mn ?n ?f)) = 5\n\ngoal (1 subgoal):\n 1. \\<exists>n f' g. f = Pr n f' g", "by (cases f) auto"], ["", "lemma encode_kind_Mn:\n  assumes \"encode_kind (encode f) = 5\"\n  shows \"\\<exists>n g. f = Mn n g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n g. f = Mn n g", "using assms encode_kind_n"], ["proof (prove)\nusing this:\n  encode_kind (encode f) = 5\n  encode_kind (encode Z) = 0\n  encode_kind (encode S) = 1\n  encode_kind (encode (recf.Id ?m ?n)) = 2\n  encode_kind (encode (Cn ?n ?f ?gs)) = 3\n  encode_kind (encode (Pr ?n ?f ?g)) = 4\n  encode_kind (encode (Mn ?n ?f)) = 5\n\ngoal (1 subgoal):\n 1. \\<exists>n g. f = Mn n g", "by (cases f) auto"], ["", "lemma pdec2_encode_Id: \"pdec2 (encode (Id m n)) = prod_encode (m, n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 (encode (recf.Id m n)) = prod_encode (m, n)", "by simp"], ["", "lemma pdec2_encode_Pr: \"pdec2 (encode (Pr n f g)) = triple_encode n (encode f) (encode g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 (encode (Pr n f g)) = triple_encode n (encode f) (encode g)", "by simp"], ["", "subsection \\<open>The step function on encoded configurations\\label{s:step_enc}\\<close>"], ["", "text \\<open>In this section we construct a function @{text \"estep :: nat\n\\<Rightarrow> nat\"} that is equivalent to the function @{text \"step ::\nconfiguration \\<Rightarrow> configuration\"} except that it applies to encoded\nconfigurations. We start by defining an encoding for configurations.\\<close>"], ["", "definition encode_frame :: \"frame \\<Rightarrow> nat\" where\n  \"encode_frame s \\<equiv>\n    triple_encode (encode (fst s)) (list_encode (fst (snd s))) (list_encode (snd (snd s)))\""], ["", "lemma encode_frame:\n  \"encode_frame (f, xs, ls) = triple_encode (encode f) (list_encode xs) (list_encode ls)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_frame (f, xs, ls) =\n    triple_encode (encode f) (Partial_Recursive.list_encode xs)\n     (Partial_Recursive.list_encode ls)", "unfolding encode_frame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. triple_encode (encode (fst (f, xs, ls)))\n     (Partial_Recursive.list_encode (fst (snd (f, xs, ls))))\n     (Partial_Recursive.list_encode (snd (snd (f, xs, ls)))) =\n    triple_encode (encode f) (Partial_Recursive.list_encode xs)\n     (Partial_Recursive.list_encode ls)", "by simp"], ["", "abbreviation encode_option :: \"nat option \\<Rightarrow> nat\" where\n  \"encode_option x \\<equiv> if x = None then 0 else Suc (the x)\""], ["", "definition encode_config :: \"configuration \\<Rightarrow> nat\" where\n  \"encode_config cfg \\<equiv>\n     prod_encode (list_encode (map encode_frame (fst cfg)), encode_option (snd cfg))\""], ["", "lemma encode_config:\n  \"encode_config (ss, rv) = prod_encode (list_encode (map encode_frame ss), encode_option rv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_config (ss, rv) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame ss), encode_option rv)", "unfolding encode_config_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame (fst (ss, rv))),\n      encode_option (snd (ss, rv))) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame ss), encode_option rv)", "by simp"], ["", "text \\<open>Various projections from encoded configurations:\\<close>"], ["", "definition e2stack where \"e2stack e \\<equiv> pdec1 e\""], ["", "definition e2rv where \"e2rv e \\<equiv> pdec2 e\""], ["", "definition e2tail where \"e2tail e \\<equiv> e_tl (e2stack e)\""], ["", "definition e2frame where \"e2frame e \\<equiv> e_hd (e2stack e)\""], ["", "definition e2i where \"e2i e \\<equiv> pdec1 (e2frame e)\""], ["", "definition e2xs where \"e2xs e \\<equiv> pdec12 (e2frame e)\""], ["", "definition e2ls where \"e2ls e \\<equiv> pdec22 (e2frame e)\""], ["", "definition e2lenas where \"e2lenas e \\<equiv> e_length (e2xs e)\""], ["", "definition e2lenls where \"e2lenls e \\<equiv> e_length (e2ls e)\""], ["", "lemma e2rv_rv [simp]:\n  \"e2rv (encode_config (ss, rv)) = (if rv \\<up> then 0 else Suc (the rv))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2rv (encode_config (ss, rv)) = encode_option rv", "unfolding e2rv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec2 (encode_config (ss, rv)) = encode_option rv", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. pdec2 (encode_config (ss, rv)) = encode_option rv", "by simp"], ["", "lemma e2stack_stack [simp]:\n  \"e2stack (encode_config (ss, rv)) = list_encode (map encode_frame ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2stack (encode_config (ss, rv)) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "unfolding e2stack_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 (encode_config (ss, rv)) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. pdec1 (encode_config (ss, rv)) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "by simp"], ["", "lemma e2tail_tail [simp]:\n  \"e2tail (encode_config (s # ss, rv)) = list_encode (map encode_frame ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2tail (encode_config (s # ss, rv)) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "unfolding e2tail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_tl (e2stack (encode_config (s # ss, rv))) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. e_tl (e2stack (encode_config (s # ss, rv))) =\n    Partial_Recursive.list_encode (map encode_frame ss)", "by fastforce"], ["", "lemma e2frame_frame [simp]:\n  \"e2frame (encode_config (s # ss, rv)) = encode_frame s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2frame (encode_config (s # ss, rv)) = encode_frame s", "unfolding e2frame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. e_hd (e2stack (encode_config (s # ss, rv))) = encode_frame s", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. e_hd (e2stack (encode_config (s # ss, rv))) = encode_frame s", "by fastforce"], ["", "lemma e2i_f [simp]:\n  \"e2i (encode_config ((f, xs, ls) # ss, rv)) = encode f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2i (encode_config ((f, xs, ls) # ss, rv)) = encode f", "unfolding e2i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 (e2frame (encode_config ((f, xs, ls) # ss, rv))) = encode f", "using encode_config e2frame_frame encode_frame"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n  e2frame (encode_config (?s # ?ss, ?rv)) = encode_frame ?s\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. pdec1 (e2frame (encode_config ((f, xs, ls) # ss, rv))) = encode f", "by force"], ["", "lemma e2xs_xs [simp]:\n  \"e2xs (encode_config ((f, xs, ls) # ss, rv)) = list_encode xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2xs (encode_config ((f, xs, ls) # ss, rv)) =\n    Partial_Recursive.list_encode xs", "using e2xs_def e2frame_frame encode_frame"], ["proof (prove)\nusing this:\n  e2xs ?e \\<equiv> pdec12 (e2frame ?e)\n  e2frame (encode_config (?s # ?ss, ?rv)) = encode_frame ?s\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. e2xs (encode_config ((f, xs, ls) # ss, rv)) =\n    Partial_Recursive.list_encode xs", "by force"], ["", "lemma e2ls_ls [simp]:\n  \"e2ls (encode_config ((f, xs, ls) # ss, rv)) = list_encode ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2ls (encode_config ((f, xs, ls) # ss, rv)) =\n    Partial_Recursive.list_encode ls", "using e2ls_def e2frame_frame encode_frame"], ["proof (prove)\nusing this:\n  e2ls ?e \\<equiv> pdec22 (e2frame ?e)\n  e2frame (encode_config (?s # ?ss, ?rv)) = encode_frame ?s\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. e2ls (encode_config ((f, xs, ls) # ss, rv)) =\n    Partial_Recursive.list_encode ls", "by force"], ["", "lemma e2lenas_lenas [simp]:\n  \"e2lenas (encode_config ((f, xs, ls) # ss, rv)) = length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2lenas (encode_config ((f, xs, ls) # ss, rv)) = length xs", "using e2lenas_def e2frame_frame encode_frame"], ["proof (prove)\nusing this:\n  e2lenas ?e \\<equiv> e_length (e2xs ?e)\n  e2frame (encode_config (?s # ?ss, ?rv)) = encode_frame ?s\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. e2lenas (encode_config ((f, xs, ls) # ss, rv)) = length xs", "by simp"], ["", "lemma e2lenls_lenls [simp]:\n  \"e2lenls (encode_config ((f, xs, ls) # ss, rv)) = length ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e2lenls (encode_config ((f, xs, ls) # ss, rv)) = length ls", "using e2lenls_def e2frame_frame encode_frame"], ["proof (prove)\nusing this:\n  e2lenls ?e \\<equiv> e_length (e2ls ?e)\n  e2frame (encode_config (?s # ?ss, ?rv)) = encode_frame ?s\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. e2lenls (encode_config ((f, xs, ls) # ss, rv)) = length ls", "by simp"], ["", "lemma e2stack_0_iff_Nil:\n  assumes \"e = encode_config (ss, rv)\"\n  shows \"e2stack e = 0 \\<longleftrightarrow>  ss = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (e2stack e = 0) = (ss = [])", "using assms"], ["proof (prove)\nusing this:\n  e = encode_config (ss, rv)\n\ngoal (1 subgoal):\n 1. (e2stack e = 0) = (ss = [])", "by (metis list_encode.simps(1) e2stack_stack list_encode_0 map_is_Nil_conv)"], ["", "lemma e2ls_0_iff_Nil [simp]: \"list_decode (e2ls e) = [] \\<longleftrightarrow> e2ls e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Partial_Recursive.list_decode (e2ls e) = []) = (e2ls e = 0)", "by (metis list_decode.simps(1) list_encode_decode)"], ["", "text \\<open>We now define @{text eterm} piecemeal by considering the more\ncomplicated cases @{text Cn}, @{text Pr}, and @{text Mn} separately.\\<close>"], ["", "definition \"estep_Cn e \\<equiv>\n  if e2lenls e = e_length (pdec222 (e2i e))\n  then if e2rv e = 0\n       then prod_encode (e_cons (triple_encode (pdec122 (e2i e)) (e2ls e) 0) (e2stack e), 0)\n       else prod_encode (e2tail e, e2rv e)\n  else if e2rv e = 0\n       then if e2lenls e < e_length (pdec222 (e2i e))\n            then prod_encode\n              (e_cons\n                (triple_encode (e_nth (pdec222 (e2i e)) (e2lenls e)) (e2xs e) 0)\n                (e2stack e),\n               0)\n            else prod_encode (e2tail e, e2rv e)\n       else prod_encode\n         (e_cons\n           (triple_encode (e2i e) (e2xs e) (e_snoc (e2ls e) (e2rv e - 1)))\n           (e2tail e),\n          0)\""], ["", "lemma estep_Cn:\n  assumes \"c = (((Cn n f gs, xs, ls) # fs), rv)\"\n  shows \"estep_Cn (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Cn (encode_config c) = encode_config (step c)", "using encode_frame"], ["proof (prove)\nusing this:\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. estep_Cn (encode_config c) = encode_config (step c)", "by (simp add: assms estep_Cn_def, simp add: encode_config assms)"], ["", "definition \"estep_Pr e \\<equiv>\n  if e2ls e = 0\n  then if e2rv e = 0\n       then prod_encode\n         (e_cons (triple_encode (pdec122 (e2i e)) (e_tl (e2xs e)) 0) (e2stack e),\n          0)\n       else prod_encode\n         (e_cons (triple_encode (e2i e) (e2xs e) (singleton_encode (e2rv e - 1))) (e2tail e),\n          0)\n  else if e2lenls e = Suc (e_hd (e2xs e))\n       then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n       else if e2rv e = 0\n            then prod_encode\n              (e_cons\n                (triple_encode\n                  (pdec222 (e2i e))\n                  (e_cons (e2lenls e - 1) (e_cons (e_hd (e2ls e)) (e_tl (e2xs e))))\n                  0)\n                (e2stack e),\n                0)\n            else prod_encode\n              (e_cons\n                (triple_encode (e2i e) (e2xs e) (e_cons (e2rv e - 1) (e2ls e))) (e2tail e),\n                0)\""], ["", "lemma estep_Pr1:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls \\<noteq> Suc (hd xs)\"\n    and \"rv \\<noteq> None\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "from assms(5)"], ["proof (chain)\npicking this:\n  recfn (length xs) (Pr n f g)", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "have eq: \"hd xs = e_hd (e2xs ?e)\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "using assms e_hd_def"], ["proof (prove)\nusing this:\n  0 < length xs\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<down>\n  recfn (length xs) (Pr n f g)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "by auto"], ["proof (state)\nthis:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"step c = ((Pr n f g, xs, (the rv) # ls) # fs, None)\"\n      (is \"step c = (?t # ?ss, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step c = ((Pr n f g, xs, the rv # ls) # fs, None)", "using assms"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<down>\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. step c = ((Pr n f g, xs, the rv # ls) # fs, None)", "by simp"], ["proof (state)\nthis:\n  step c = ((Pr n f g, xs, the rv # ls) # fs, None)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  step c = ((Pr n f g, xs, the rv # ls) # fs, None)", "have \"encode_config (step c) =\n      prod_encode (list_encode (map encode_frame (?t # ?ss)), 0)\""], ["proof (prove)\nusing this:\n  step c = ((Pr n f g, xs, the rv # ls) # fs, None)\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n      0)", "using encode_config"], ["proof (prove)\nusing this:\n  step c = ((Pr n f g, xs, the rv # ls) # fs, None)\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n      0)", "by simp"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... =\n      prod_encode (e_cons (encode_frame ?t) (list_encode (map encode_frame (?ss))), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (Partial_Recursive.list_encode (map encode_frame fs)),\n      0)", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (Partial_Recursive.list_encode (map encode_frame fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame ((Pr n f g, xs, the rv # ls) # fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (Partial_Recursive.list_encode (map encode_frame fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode (e_cons (encode_frame ?t) (e2tail ?e), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (Partial_Recursive.list_encode (map encode_frame fs)),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (e2tail (encode_config c)),\n      0)", "using assms(1)"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (Partial_Recursive.list_encode (map encode_frame fs)),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (e2tail (encode_config c)),\n      0)", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (Partial_Recursive.list_encode (map encode_frame fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (e2tail (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (Partial_Recursive.list_encode (map encode_frame fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (e2tail (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode\n      (e_cons\n        (triple_encode (e2i ?e) (e2xs ?e) (e_cons (e2rv ?e - 1) (e2ls ?e)))\n        (e2tail ?e),\n       0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n       (e2tail (encode_config c)),\n      0) =\n    prod_encode\n     (e_cons\n       (triple_encode (e2i (encode_config c)) (e2xs (encode_config c))\n         (e_cons (e2rv (encode_config c) - 1) (e2ls (encode_config c))))\n       (e2tail (encode_config c)),\n      0)", "by (simp add: assms encode_frame)"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (Pr n f g, xs, the rv # ls))\n     (e2tail (encode_config c)),\n    0) =\n  prod_encode\n   (e_cons\n     (triple_encode (e2i (encode_config c)) (e2xs (encode_config c))\n       (e_cons (e2rv (encode_config c) - 1) (e2ls (encode_config c))))\n     (e2tail (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "finally"], ["proof (chain)\npicking this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (e2i (encode_config c)) (e2xs (encode_config c))\n       (e_cons (e2rv (encode_config c) - 1) (e2ls (encode_config c))))\n     (e2tail (encode_config c)),\n    0)", "show ?thesis"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (e2i (encode_config c)) (e2xs (encode_config c))\n       (e_cons (e2rv (encode_config c) - 1) (e2ls (encode_config c))))\n     (e2tail (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "using assms eq estep_Pr_def"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (e2i (encode_config c)) (e2xs (encode_config c))\n       (e_cons (e2rv (encode_config c) - 1) (e2ls (encode_config c))))\n     (e2tail (encode_config c)),\n    0)\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<down>\n  recfn (length xs) (Pr n f g)\n  hd xs = e_hd (e2xs (encode_config c))\n  estep_Pr ?e \\<equiv>\n  if e2ls ?e = 0\n  then if e2rv ?e = 0\n       then prod_encode\n             (e_cons (triple_encode (pdec122 (e2i ?e)) (e_tl (e2xs ?e)) 0)\n               (e2stack ?e),\n              0)\n       else prod_encode\n             (e_cons\n               (triple_encode (e2i ?e) (e2xs ?e)\n                 (singleton_encode (e2rv ?e - 1)))\n               (e2tail ?e),\n              0)\n  else if e2lenls ?e = Suc (e_hd (e2xs ?e))\n       then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else if e2rv ?e = 0\n            then prod_encode\n                  (e_cons\n                    (triple_encode (pdec222 (e2i ?e))\n                      (e_cons (e2lenls ?e - 1)\n                        (e_cons (e_hd (e2ls ?e)) (e_tl (e2xs ?e))))\n                      0)\n                    (e2stack ?e),\n                   0)\n            else prod_encode\n                  (e_cons\n                    (triple_encode (e2i ?e) (e2xs ?e)\n                      (e_cons (e2rv ?e - 1) (e2ls ?e)))\n                    (e2tail ?e),\n                   0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "by auto"], ["proof (state)\nthis:\n  estep_Pr (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma estep_Pr2:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls \\<noteq> Suc (hd xs)\"\n    and \"rv = None\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "from assms(5)"], ["proof (chain)\npicking this:\n  recfn (length xs) (Pr n f g)", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "have eq: \"hd xs = e_hd (e2xs ?e)\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "using assms e_hd_def"], ["proof (prove)\nusing this:\n  0 < length xs\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<up>\n  recfn (length xs) (Pr n f g)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "by auto"], ["proof (state)\nthis:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"step c = ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs, None)\"\n      (is \"step c = (?t # ?ss, None)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. step c =\n    ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs,\n     None)", "using assms"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<up>\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. step c =\n    ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs,\n     None)", "by simp"], ["proof (state)\nthis:\n  step c =\n  ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs, None)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  step c =\n  ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs, None)", "have \"encode_config (step c) =\n      prod_encode (list_encode (map encode_frame (?t # ?ss)), 0)\""], ["proof (prove)\nusing this:\n  step c =\n  ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs, None)\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame\n         ((g, (length ls - 1) # hd ls # tl xs, []) #\n          (Pr n f g, xs, ls) # fs)),\n      0)", "using encode_config"], ["proof (prove)\nusing this:\n  step c =\n  ((g, (length ls - 1) # hd ls # tl xs, []) # (Pr n f g, xs, ls) # fs, None)\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame\n         ((g, (length ls - 1) # hd ls # tl xs, []) #\n          (Pr n f g, xs, ls) # fs)),\n      0)", "by simp"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame\n       ((g, (length ls - 1) # hd ls # tl xs, []) #\n        (Pr n f g, xs, ls) # fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame\n       ((g, (length ls - 1) # hd ls # tl xs, []) #\n        (Pr n f g, xs, ls) # fs)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... =\n      prod_encode (e_cons (encode_frame ?t) (list_encode (map encode_frame (?ss))), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode\n       (map encode_frame\n         ((g, (length ls - 1) # hd ls # tl xs, []) #\n          (Pr n f g, xs, ls) # fs)),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (Partial_Recursive.list_encode\n         (map encode_frame ((Pr n f g, xs, ls) # fs))),\n      0)", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame\n       ((g, (length ls - 1) # hd ls # tl xs, []) #\n        (Pr n f g, xs, ls) # fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, ls) # fs))),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode\n     (map encode_frame\n       ((g, (length ls - 1) # hd ls # tl xs, []) #\n        (Pr n f g, xs, ls) # fs)),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, ls) # fs))),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode (e_cons (encode_frame ?t) (e2stack ?e), 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (Partial_Recursive.list_encode\n         (map encode_frame ((Pr n f g, xs, ls) # fs))),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (e2stack (encode_config c)),\n      0)", "using assms(1)"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (Partial_Recursive.list_encode\n         (map encode_frame ((Pr n f g, xs, ls) # fs))),\n      0) =\n    prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (e2stack (encode_config c)),\n      0)", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, ls) # fs))),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (e2stack (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (Partial_Recursive.list_encode\n       (map encode_frame ((Pr n f g, xs, ls) # fs))),\n    0) =\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (e2stack (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode\n    (e_cons\n      (triple_encode\n        (pdec222 (e2i ?e))\n        (e_cons (e2lenls ?e - 1) (e_cons (e_hd (e2ls ?e)) (e_tl (e2xs ?e))))\n        0)\n      (e2stack ?e),\n     0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (e2stack (encode_config c)),\n      0) =\n    prod_encode\n     (e_cons\n       (triple_encode (pdec222 (e2i (encode_config c)))\n         (e_cons (e2lenls (encode_config c) - 1)\n           (e_cons (e_hd (e2ls (encode_config c)))\n             (e_tl (e2xs (encode_config c)))))\n         0)\n       (e2stack (encode_config c)),\n      0)", "using assms(1,2) encode_frame[of g \"(length ls - 1) # hd ls # tl xs\" \"[]\"]\n      pdec2_encode_Pr[of n f g] e2xs_xs e2i_f e2lenls_lenls e2ls_ls e_hd"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  encode_frame (g, (length ls - 1) # hd ls # tl xs, []) =\n  triple_encode (encode g)\n   (Partial_Recursive.list_encode ((length ls - 1) # hd ls # tl xs))\n   (Partial_Recursive.list_encode [])\n  pdec2 (encode (Pr n f g)) = triple_encode n (encode f) (encode g)\n  e2xs (encode_config ((?f, ?xs, ?ls) # ?ss, ?rv)) =\n  Partial_Recursive.list_encode ?xs\n  e2i (encode_config ((?f, ?xs, ?ls) # ?ss, ?rv)) = encode ?f\n  e2lenls (encode_config ((?f, ?xs, ?ls) # ?ss, ?rv)) = length ?ls\n  e2ls (encode_config ((?f, ?xs, ?ls) # ?ss, ?rv)) =\n  Partial_Recursive.list_encode ?ls\n  Partial_Recursive.list_decode ?e = ?x # ?xs \\<Longrightarrow> e_hd ?e = ?x\n\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n       (e2stack (encode_config c)),\n      0) =\n    prod_encode\n     (e_cons\n       (triple_encode (pdec222 (e2i (encode_config c)))\n         (e_cons (e2lenls (encode_config c) - 1)\n           (e_cons (e_hd (e2ls (encode_config c)))\n             (e_tl (e2xs (encode_config c)))))\n         0)\n       (e2stack (encode_config c)),\n      0)", "by (metis list_encode.simps(1) list.collapse list_decode_encode\n      prod_encode_inverse snd_conv)"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons (encode_frame (g, (length ls - 1) # hd ls # tl xs, []))\n     (e2stack (encode_config c)),\n    0) =\n  prod_encode\n   (e_cons\n     (triple_encode (pdec222 (e2i (encode_config c)))\n       (e_cons (e2lenls (encode_config c) - 1)\n         (e_cons (e_hd (e2ls (encode_config c)))\n           (e_tl (e2xs (encode_config c)))))\n       0)\n     (e2stack (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "finally"], ["proof (chain)\npicking this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (pdec222 (e2i (encode_config c)))\n       (e_cons (e2lenls (encode_config c) - 1)\n         (e_cons (e_hd (e2ls (encode_config c)))\n           (e_tl (e2xs (encode_config c)))))\n       0)\n     (e2stack (encode_config c)),\n    0)", "show ?thesis"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (pdec222 (e2i (encode_config c)))\n       (e_cons (e2lenls (encode_config c) - 1)\n         (e_cons (e_hd (e2ls (encode_config c)))\n           (e_tl (e2xs (encode_config c)))))\n       0)\n     (e2stack (encode_config c)),\n    0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "using assms eq estep_Pr_def"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e_cons\n     (triple_encode (pdec222 (e2i (encode_config c)))\n       (e_cons (e2lenls (encode_config c) - 1)\n         (e_cons (e_hd (e2ls (encode_config c)))\n           (e_tl (e2xs (encode_config c)))))\n       0)\n     (e2stack (encode_config c)),\n    0)\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls \\<noteq> Suc (hd xs)\n  rv \\<up>\n  recfn (length xs) (Pr n f g)\n  hd xs = e_hd (e2xs (encode_config c))\n  estep_Pr ?e \\<equiv>\n  if e2ls ?e = 0\n  then if e2rv ?e = 0\n       then prod_encode\n             (e_cons (triple_encode (pdec122 (e2i ?e)) (e_tl (e2xs ?e)) 0)\n               (e2stack ?e),\n              0)\n       else prod_encode\n             (e_cons\n               (triple_encode (e2i ?e) (e2xs ?e)\n                 (singleton_encode (e2rv ?e - 1)))\n               (e2tail ?e),\n              0)\n  else if e2lenls ?e = Suc (e_hd (e2xs ?e))\n       then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else if e2rv ?e = 0\n            then prod_encode\n                  (e_cons\n                    (triple_encode (pdec222 (e2i ?e))\n                      (e_cons (e2lenls ?e - 1)\n                        (e_cons (e_hd (e2ls ?e)) (e_tl (e2xs ?e))))\n                      0)\n                    (e2stack ?e),\n                   0)\n            else prod_encode\n                  (e_cons\n                    (triple_encode (e2i ?e) (e2xs ?e)\n                      (e_cons (e2rv ?e - 1) (e2ls ?e)))\n                    (e2tail ?e),\n                   0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "by auto"], ["proof (state)\nthis:\n  estep_Pr (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma estep_Pr3:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"ls \\<noteq> []\"\n    and \"length ls = Suc (hd xs)\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "from assms(4)"], ["proof (chain)\npicking this:\n  recfn (length xs) (Pr n f g)", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "have \"hd xs = e_hd (e2xs ?e)\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "using assms e_hd_def"], ["proof (prove)\nusing this:\n  0 < length xs\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls = Suc (hd xs)\n  recfn (length xs) (Pr n f g)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "by auto"], ["proof (state)\nthis:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  hd xs = e_hd (e2xs (encode_config c))", "have \"(length ls = Suc (hd xs)) = (e2lenls ?e = Suc (e_hd (e2xs ?e)))\""], ["proof (prove)\nusing this:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. (length ls = Suc (hd xs)) =\n    (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))", "using assms"], ["proof (prove)\nusing this:\n  hd xs = e_hd (e2xs (encode_config c))\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls = Suc (hd xs)\n  recfn (length xs) (Pr n f g)\n\ngoal (1 subgoal):\n 1. (length ls = Suc (hd xs)) =\n    (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))", "by simp"], ["proof (state)\nthis:\n  (length ls = Suc (hd xs)) =\n  (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  (length ls = Suc (hd xs)) =\n  (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))", "have *: \"estep_Pr ?e = prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\""], ["proof (prove)\nusing this:\n  (length ls = Suc (hd xs)) =\n  (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "using assms estep_Pr_def"], ["proof (prove)\nusing this:\n  (length ls = Suc (hd xs)) =\n  (e2lenls (encode_config c) = Suc (e_hd (e2xs (encode_config c))))\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls = Suc (hd xs)\n  recfn (length xs) (Pr n f g)\n  estep_Pr ?e \\<equiv>\n  if e2ls ?e = 0\n  then if e2rv ?e = 0\n       then prod_encode\n             (e_cons (triple_encode (pdec122 (e2i ?e)) (e_tl (e2xs ?e)) 0)\n               (e2stack ?e),\n              0)\n       else prod_encode\n             (e_cons\n               (triple_encode (e2i ?e) (e2xs ?e)\n                 (singleton_encode (e2rv ?e - 1)))\n               (e2tail ?e),\n              0)\n  else if e2lenls ?e = Suc (e_hd (e2xs ?e))\n       then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else if e2rv ?e = 0\n            then prod_encode\n                  (e_cons\n                    (triple_encode (pdec222 (e2i ?e))\n                      (e_cons (e2lenls ?e - 1)\n                        (e_cons (e_hd (e2ls ?e)) (e_tl (e2xs ?e))))\n                      0)\n                    (e2stack ?e),\n                   0)\n            else prod_encode\n                  (e_cons\n                    (triple_encode (e2i ?e) (e2xs ?e)\n                      (e_cons (e2rv ?e - 1) (e2ls ?e)))\n                    (e2tail ?e),\n                   0)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "by auto"], ["proof (state)\nthis:\n  estep_Pr (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"step c = (fs, Some (hd ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step c = (fs, Some (hd ls))", "using assms(1,2,3)"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  length ls = Suc (hd xs)\n\ngoal (1 subgoal):\n 1. step c = (fs, Some (hd ls))", "by simp"], ["proof (state)\nthis:\n  step c = (fs, Some (hd ls))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  step c = (fs, Some (hd ls))", "have \"encode_config (step c) =\n      prod_encode (list_encode (map encode_frame fs), encode_option (Some (hd ls)))\""], ["proof (prove)\nusing this:\n  step c = (fs, Some (hd ls))\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (hd ls)))", "using encode_config"], ["proof (prove)\nusing this:\n  step c = (fs, Some (hd ls))\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (hd ls)))", "by simp"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (hd ls)))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (hd ls)))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... =\n      prod_encode (list_encode (map encode_frame fs), encode_option (Some (e_hd (e2ls ?e))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (hd ls))) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (e_hd (e2ls (encode_config c)))))", "using assms(1,2) e_hd_def"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  ls \\<noteq> []\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (hd ls))) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (e_hd (e2ls (encode_config c)))))", "by auto"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (hd ls))) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (e_hd (e2ls (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (hd ls))) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (e_hd (e2ls (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode (list_encode (map encode_frame fs), Suc (e_hd (e2ls ?e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      encode_option (Some (e_hd (e2ls (encode_config c))))) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      Suc (e_hd (e2ls (encode_config c))))", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (e_hd (e2ls (encode_config c))))) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (e_hd (e2ls (encode_config c))))) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "have \"... = prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      Suc (e_hd (e2ls (encode_config c)))) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "using assms(1)"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs),\n      Suc (e_hd (e2ls (encode_config c)))) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    Suc (e_hd (e2ls (encode_config c)))) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "finally"], ["proof (chain)\npicking this:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "have \"encode_config (step c) = prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\""], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. encode_config (step c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "."], ["proof (state)\nthis:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "show ?thesis"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "using estep_Pr_def *"], ["proof (prove)\nusing this:\n  encode_config (step c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n  estep_Pr ?e \\<equiv>\n  if e2ls ?e = 0\n  then if e2rv ?e = 0\n       then prod_encode\n             (e_cons (triple_encode (pdec122 (e2i ?e)) (e_tl (e2xs ?e)) 0)\n               (e2stack ?e),\n              0)\n       else prod_encode\n             (e_cons\n               (triple_encode (e2i ?e) (e2xs ?e)\n                 (singleton_encode (e2rv ?e - 1)))\n               (e2tail ?e),\n              0)\n  else if e2lenls ?e = Suc (e_hd (e2xs ?e))\n       then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else if e2rv ?e = 0\n            then prod_encode\n                  (e_cons\n                    (triple_encode (pdec222 (e2i ?e))\n                      (e_cons (e2lenls ?e - 1)\n                        (e_cons (e_hd (e2ls ?e)) (e_tl (e2xs ?e))))\n                      0)\n                    (e2stack ?e),\n                   0)\n            else prod_encode\n                  (e_cons\n                    (triple_encode (e2i ?e) (e2xs ?e)\n                      (e_cons (e2rv ?e - 1) (e2ls ?e)))\n                    (e2tail ?e),\n                   0)\n  estep_Pr (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "by presburger"], ["proof (state)\nthis:\n  estep_Pr (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma estep_Pr4:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\" and \"ls = []\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "using encode_frame"], ["proof (prove)\nusing this:\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "by (simp add: assms estep_Pr_def, simp add: encode_config assms)"], ["", "lemma estep_Pr:\n  assumes \"c = (((Pr n f g, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (Pr n f g)\"\n  shows \"estep_Pr (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "using assms estep_Pr1 estep_Pr2 estep_Pr3 estep_Pr4"], ["proof (prove)\nusing this:\n  c = ((Pr n f g, xs, ls) # fs, rv)\n  recfn (length xs) (Pr n f g)\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv); ?ls \\<noteq> [];\n   length ?ls \\<noteq> Suc (hd ?xs); ?rv \\<down>;\n   recfn (length ?xs) (Pr ?n ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv); ?ls \\<noteq> [];\n   length ?ls \\<noteq> Suc (hd ?xs); ?rv \\<up>;\n   recfn (length ?xs) (Pr ?n ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv); ?ls \\<noteq> [];\n   length ?ls = Suc (hd ?xs); recfn (length ?xs) (Pr ?n ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv); ?ls = []\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n\ngoal (1 subgoal):\n 1. estep_Pr (encode_config c) = encode_config (step c)", "by auto"], ["", "definition \"estep_Mn e \\<equiv>\n  if e2ls e = 0\n  then prod_encode\n    (e_cons\n      (triple_encode (pdec22 (e2i e)) (e_cons 0 (e2xs e)) 0)\n      (e_cons\n        (triple_encode (e2i e) (e2xs e) (singleton_encode 0))\n        (e2tail e)),\n     0)\n  else if e2rv e = 1\n       then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n       else prod_encode\n        (e_cons\n          (triple_encode (pdec22 (e2i e)) (e_cons (Suc (e_hd (e2ls e))) (e2xs e)) 0)\n          (e_cons\n            (triple_encode (e2i e) (e2xs e) (singleton_encode (Suc (e_hd (e2ls e)))))\n            (e2tail e)),\n        0)\""], ["", "lemma estep_Mn:\n  assumes \"c = (((Mn n f, xs, ls) # fs), rv)\"\n  shows \"estep_Mn (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "consider \"ls \\<noteq> []\" and \"rv \\<noteq> Some 0\" | \"ls \\<noteq> []\" and \"rv = Some 0\" | \"ls = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n             \\<Longrightarrow> thesis;\n     \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n     \\<Longrightarrow> thesis;\n     ls = [] \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   ls = [] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   ls = [] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n           \\<Longrightarrow> ?thesis;\n   \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n   \\<Longrightarrow> ?thesis;\n   ls = [] \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "proof (cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "case 1"], ["proof (state)\nthis:\n  ls \\<noteq> []\n  rv \\<noteq> Some 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  ls \\<noteq> []\n  rv \\<noteq> Some 0", "have step_c: \"step c =\n       ((f, (Suc (hd ls)) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\"\n        (is \"step c = ?cfg\")"], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  rv \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. step c =\n    ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)", "using assms"], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  rv \\<noteq> Some 0\n  c = ((Mn n f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. step c =\n    ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)", "by simp"], ["proof (state)\nthis:\n  step c =\n  ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"estep_Mn ?e =\n      prod_encode\n        (e_cons\n          (triple_encode (encode f) (e_cons (Suc (hd ls)) (list_encode xs)) 0)\n          (e_cons\n            (triple_encode (encode (Mn n f)) (list_encode xs) (singleton_encode (Suc (hd ls))))\n            (list_encode (map encode_frame fs))),\n        0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) =\n    prod_encode\n     (e_cons\n       (triple_encode (encode f)\n         (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n       (e_cons\n         (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n           (singleton_encode (Suc (hd ls))))\n         (Partial_Recursive.list_encode (map encode_frame fs))),\n      0)", "using 1 assms e_hd_def estep_Mn_def"], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  rv \\<noteq> Some 0\n  c = ((Mn n f, xs, ls) # fs, rv)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n  estep_Mn ?e \\<equiv>\n  if e2ls ?e = 0\n  then prod_encode\n        (e_cons (triple_encode (pdec22 (e2i ?e)) (e_cons 0 (e2xs ?e)) 0)\n          (e_cons (triple_encode (e2i ?e) (e2xs ?e) (singleton_encode 0))\n            (e2tail ?e)),\n         0)\n  else if e2rv ?e = 1 then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else prod_encode\n             (e_cons\n               (triple_encode (pdec22 (e2i ?e))\n                 (e_cons (Suc (e_hd (e2ls ?e))) (e2xs ?e)) 0)\n               (e_cons\n                 (triple_encode (e2i ?e) (e2xs ?e)\n                   (singleton_encode (Suc (e_hd (e2ls ?e)))))\n                 (e2tail ?e)),\n              0)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) =\n    prod_encode\n     (e_cons\n       (triple_encode (encode f)\n         (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n       (e_cons\n         (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n           (singleton_encode (Suc (hd ls))))\n         (Partial_Recursive.list_encode (map encode_frame fs))),\n      0)", "by auto"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) =\n  prod_encode\n   (e_cons\n     (triple_encode (encode f)\n       (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n     (e_cons\n       (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n         (singleton_encode (Suc (hd ls))))\n       (Partial_Recursive.list_encode (map encode_frame fs))),\n    0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) =\n  prod_encode\n   (e_cons\n     (triple_encode (encode f)\n       (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n     (e_cons\n       (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n         (singleton_encode (Suc (hd ls))))\n       (Partial_Recursive.list_encode (map encode_frame fs))),\n    0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"... = encode_config ?cfg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons\n       (triple_encode (encode f)\n         (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n       (e_cons\n         (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n           (singleton_encode (Suc (hd ls))))\n         (Partial_Recursive.list_encode (map encode_frame fs))),\n      0) =\n    encode_config\n     ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (e_cons\n       (triple_encode (encode f)\n         (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n       (e_cons\n         (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n           (singleton_encode (Suc (hd ls))))\n         (Partial_Recursive.list_encode (map encode_frame fs))),\n      0) =\n    encode_config\n     ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)", "by (simp add: encode_frame)"], ["proof (state)\nthis:\n  prod_encode\n   (e_cons\n     (triple_encode (encode f)\n       (e_cons (Suc (hd ls)) (Partial_Recursive.list_encode xs)) 0)\n     (e_cons\n       (triple_encode (encode (Mn n f)) (Partial_Recursive.list_encode xs)\n         (singleton_encode (Suc (hd ls))))\n       (Partial_Recursive.list_encode (map encode_frame fs))),\n    0) =\n  encode_config\n   ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<noteq> Some 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 3. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "finally"], ["proof (chain)\npicking this:\n  estep_Mn (encode_config c) =\n  encode_config\n   ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)", "show ?thesis"], ["proof (prove)\nusing this:\n  estep_Mn (encode_config c) =\n  encode_config\n   ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "using step_c"], ["proof (prove)\nusing this:\n  estep_Mn (encode_config c) =\n  encode_config\n   ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\n  step c =\n  ((f, Suc (hd ls) # xs, []) # (Mn n f, xs, [Suc (hd ls)]) # fs, None)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) = encode_config (step c)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "case 2"], ["proof (state)\nthis:\n  ls \\<noteq> []\n  rv \\<down>= 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"estep_Mn ?e = prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "using 2 assms estep_Mn_def"], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  rv \\<down>= 0\n  c = ((Mn n f, xs, ls) # fs, rv)\n  estep_Mn ?e \\<equiv>\n  if e2ls ?e = 0\n  then prod_encode\n        (e_cons (triple_encode (pdec22 (e2i ?e)) (e_cons 0 (e2xs ?e)) 0)\n          (e_cons (triple_encode (e2i ?e) (e2xs ?e) (singleton_encode 0))\n            (e2tail ?e)),\n         0)\n  else if e2rv ?e = 1 then prod_encode (e2tail ?e, Suc (e_hd (e2ls ?e)))\n       else prod_encode\n             (e_cons\n               (triple_encode (pdec22 (e2i ?e))\n                 (e_cons (Suc (e_hd (e2ls ?e))) (e2xs ?e)) 0)\n               (e_cons\n                 (triple_encode (e2i ?e) (e2xs ?e)\n                   (singleton_encode (Suc (e_hd (e2ls ?e)))))\n                 (e2tail ?e)),\n              0)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))", "by auto"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"... = prod_encode (e2tail ?e, Suc (hd ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c)))) =\n    prod_encode (e2tail (encode_config c), Suc (hd ls))", "using 2 assms e_hd_def"], ["proof (prove)\nusing this:\n  ls \\<noteq> []\n  rv \\<down>= 0\n  c = ((Mn n f, xs, ls) # fs, rv)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c)))) =\n    prod_encode (e2tail (encode_config c), Suc (hd ls))", "by auto"], ["proof (state)\nthis:\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c)))) =\n  prod_encode (e2tail (encode_config c), Suc (hd ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode\n   (e2tail (encode_config c), Suc (e_hd (e2ls (encode_config c)))) =\n  prod_encode (e2tail (encode_config c), Suc (hd ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"... = prod_encode (list_encode (map encode_frame fs), Suc (hd ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode (e2tail (encode_config c), Suc (hd ls)) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls))", "using assms"], ["proof (prove)\nusing this:\n  c = ((Mn n f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. prod_encode (e2tail (encode_config c), Suc (hd ls)) =\n    prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls))", "by simp"], ["proof (state)\nthis:\n  prod_encode (e2tail (encode_config c), Suc (hd ls)) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "also"], ["proof (state)\nthis:\n  prod_encode (e2tail (encode_config c), Suc (hd ls)) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "have \"... = encode_config (fs, Some (hd ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls)) =\n    encode_config (fs, Some (hd ls))", "using encode_config"], ["proof (prove)\nusing this:\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n\ngoal (1 subgoal):\n 1. prod_encode\n     (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls)) =\n    encode_config (fs, Some (hd ls))", "by simp"], ["proof (state)\nthis:\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs), Suc (hd ls)) =\n  encode_config (fs, Some (hd ls))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>ls \\<noteq> []; rv \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> estep_Mn (encode_config c) = encode_config (step c)\n 2. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "finally"], ["proof (chain)\npicking this:\n  estep_Mn (encode_config c) = encode_config (fs, Some (hd ls))", "show ?thesis"], ["proof (prove)\nusing this:\n  estep_Mn (encode_config c) = encode_config (fs, Some (hd ls))\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "using 2 assms"], ["proof (prove)\nusing this:\n  estep_Mn (encode_config c) = encode_config (fs, Some (hd ls))\n  ls \\<noteq> []\n  rv \\<down>= 0\n  c = ((Mn n f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) = encode_config (step c)\n\ngoal (1 subgoal):\n 1. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "case 3"], ["proof (state)\nthis:\n  ls = []\n\ngoal (1 subgoal):\n 1. ls = [] \\<Longrightarrow>\n    estep_Mn (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  ls = []", "show ?thesis"], ["proof (prove)\nusing this:\n  ls = []\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "using assms encode_frame"], ["proof (prove)\nusing this:\n  ls = []\n  c = ((Mn n f, xs, ls) # fs, rv)\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. estep_Mn (encode_config c) = encode_config (step c)", "by (simp add: estep_Mn_def, simp add: encode_config)"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  estep_Mn (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"estep e \\<equiv>\n  if e2stack e = 0 then prod_encode (0, e2rv e)\n  else if e2i e = 0 then prod_encode (e2tail e, 1)\n  else if e2i e = 1 then prod_encode (e2tail e, Suc (Suc (e_hd (e2xs e))))\n  else if encode_kind (e2i e) = 2 then\n    prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))\n  else if encode_kind (e2i e) = 3 then estep_Cn e\n  else if encode_kind (e2i e) = 4 then estep_Pr e\n  else if encode_kind (e2i e) = 5 then estep_Mn e\n  else 0\""], ["", "lemma estep_Z:\n  assumes \"c = (((Z, xs, ls) # fs), rv)\"\n  shows \"estep (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using encode_frame"], ["proof (prove)\nusing this:\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by (simp add: assms estep_def, simp add: encode_config assms)"], ["", "lemma estep_S:\n  assumes \"c = (((S, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (fst (hd (fst c)))\"\n  shows \"estep (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "from assms"], ["proof (chain)\npicking this:\n  c = ((S, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))", "have \"length xs > 0\""], ["proof (prove)\nusing this:\n  c = ((S, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))\n\ngoal (1 subgoal):\n 1. 0 < length xs", "by auto"], ["proof (state)\nthis:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  0 < length xs", "have eq: \"hd xs = e_hd (e2xs ?e)\""], ["proof (prove)\nusing this:\n  0 < length xs\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "using assms(1) e_hd_def"], ["proof (prove)\nusing this:\n  0 < length xs\n  c = ((S, xs, ls) # fs, rv)\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. hd xs = e_hd (e2xs (encode_config c))", "by auto"], ["proof (state)\nthis:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  hd xs = e_hd (e2xs (encode_config c))", "have \"estep ?e = prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\""], ["proof (prove)\nusing this:\n  hd xs = e_hd (e2xs (encode_config c))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))", "using assms(1) estep_def"], ["proof (prove)\nusing this:\n  hd xs = e_hd (e2xs (encode_config c))\n  c = ((S, xs, ls) # fs, rv)\n  estep ?e \\<equiv>\n  if e2stack ?e = 0 then prod_encode (0, e2rv ?e)\n  else if e2i ?e = 0 then prod_encode (e2tail ?e, 1)\n       else if e2i ?e = 1\n            then prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\n            else if encode_kind (e2i ?e) = 2\n                 then prod_encode\n                       (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\n                 else if encode_kind (e2i ?e) = 3 then estep_Cn ?e\n                      else if encode_kind (e2i ?e) = 4 then estep_Pr ?e\n                           else if encode_kind (e2i ?e) = 5 then estep_Mn ?e\n                                else 0\n\ngoal (1 subgoal):\n 1. estep (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "moreover"], ["proof (state)\nthis:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "have \"step c = (fs, Some (Suc (hd xs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step c = (fs, Some (Suc (hd xs)))", "using assms(1)"], ["proof (prove)\nusing this:\n  c = ((S, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. step c = (fs, Some (Suc (hd xs)))", "by simp"], ["proof (state)\nthis:\n  step c = (fs, Some (Suc (hd xs)))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "ultimately"], ["proof (chain)\npicking this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))\n  step c = (fs, Some (Suc (hd xs)))", "show ?thesis"], ["proof (prove)\nusing this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))\n  step c = (fs, Some (Suc (hd xs)))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using assms(1) eq estep_def encode_config[of fs \"Some (Suc (hd xs))\"]"], ["proof (prove)\nusing this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c), Suc (Suc (e_hd (e2xs (encode_config c)))))\n  step c = (fs, Some (Suc (hd xs)))\n  c = ((S, xs, ls) # fs, rv)\n  hd xs = e_hd (e2xs (encode_config c))\n  estep ?e \\<equiv>\n  if e2stack ?e = 0 then prod_encode (0, e2rv ?e)\n  else if e2i ?e = 0 then prod_encode (e2tail ?e, 1)\n       else if e2i ?e = 1\n            then prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\n            else if encode_kind (e2i ?e) = 2\n                 then prod_encode\n                       (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\n                 else if encode_kind (e2i ?e) = 3 then estep_Cn ?e\n                      else if encode_kind (e2i ?e) = 4 then estep_Pr ?e\n                           else if encode_kind (e2i ?e) = 5 then estep_Mn ?e\n                                else 0\n  encode_config (fs, Some (Suc (hd xs))) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (Suc (hd xs))))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma estep_Id:\n  assumes \"c = (((Id m n, xs, ls) # fs), rv)\"\n    and \"recfn (length xs) (fst (hd (fst c)))\"\n  shows \"estep (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "let ?e = \"encode_config c\""], ["proof (state)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "from assms"], ["proof (chain)\npicking this:\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))", "have \"length xs = m\" and \"m > 0\""], ["proof (prove)\nusing this:\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))\n\ngoal (1 subgoal):\n 1. length xs = m &&& 0 < m", "by auto"], ["proof (state)\nthis:\n  length xs = m\n  0 < m\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  length xs = m\n  0 < m", "have eq: \"xs ! n = e_nth (e2xs ?e) n\""], ["proof (prove)\nusing this:\n  length xs = m\n  0 < m\n\ngoal (1 subgoal):\n 1. xs ! n = e_nth (e2xs (encode_config c)) n", "using assms e_hd_def"], ["proof (prove)\nusing this:\n  length xs = m\n  0 < m\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))\n  e_hd ?e \\<equiv>\n  if ?e = 0 then 0 else hd (Partial_Recursive.list_decode ?e)\n\ngoal (1 subgoal):\n 1. xs ! n = e_nth (e2xs (encode_config c)) n", "by auto"], ["proof (state)\nthis:\n  xs ! n = e_nth (e2xs (encode_config c)) n\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "moreover"], ["proof (state)\nthis:\n  xs ! n = e_nth (e2xs (encode_config c)) n\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "have \"encode_kind (e2i ?e) = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. encode_kind (e2i (encode_config c)) = 2", "using assms(1) encode_kind_2"], ["proof (prove)\nusing this:\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  encode_kind (encode (recf.Id ?m ?n)) = 2\n\ngoal (1 subgoal):\n 1. encode_kind (e2i (encode_config c)) = 2", "by auto"], ["proof (state)\nthis:\n  encode_kind (e2i (encode_config c)) = 2\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "ultimately"], ["proof (chain)\npicking this:\n  xs ! n = e_nth (e2xs (encode_config c)) n\n  encode_kind (e2i (encode_config c)) = 2", "have \"estep ?e =\n      prod_encode (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\""], ["proof (prove)\nusing this:\n  xs ! n = e_nth (e2xs (encode_config c)) n\n  encode_kind (e2i (encode_config c)) = 2\n\ngoal (1 subgoal):\n 1. estep (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c),\n      Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))", "using assms estep_def encode_kind_def"], ["proof (prove)\nusing this:\n  xs ! n = e_nth (e2xs (encode_config c)) n\n  encode_kind (e2i (encode_config c)) = 2\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  recfn (length xs) (fst (hd (fst c)))\n  estep ?e \\<equiv>\n  if e2stack ?e = 0 then prod_encode (0, e2rv ?e)\n  else if e2i ?e = 0 then prod_encode (e2tail ?e, 1)\n       else if e2i ?e = 1\n            then prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\n            else if encode_kind (e2i ?e) = 2\n                 then prod_encode\n                       (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\n                 else if encode_kind (e2i ?e) = 3 then estep_Cn ?e\n                      else if encode_kind (e2i ?e) = 4 then estep_Pr ?e\n                           else if encode_kind (e2i ?e) = 5 then estep_Mn ?e\n                                else 0\n  encode_kind ?e \\<equiv>\n  if ?e = 0 then 0 else if ?e = 1 then 1 else pdec1 ?e\n\ngoal (1 subgoal):\n 1. estep (encode_config c) =\n    prod_encode\n     (e2tail (encode_config c),\n      Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))", "by auto"], ["proof (state)\nthis:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c),\n    Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "moreover"], ["proof (state)\nthis:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c),\n    Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "have \"step c = (fs, Some (xs ! n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step c = (fs, Some (xs ! n))", "using assms(1)"], ["proof (prove)\nusing this:\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. step c = (fs, Some (xs ! n))", "by simp"], ["proof (state)\nthis:\n  step c = (fs, Some (xs ! n))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "ultimately"], ["proof (chain)\npicking this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c),\n    Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))\n  step c = (fs, Some (xs ! n))", "show ?thesis"], ["proof (prove)\nusing this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c),\n    Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))\n  step c = (fs, Some (xs ! n))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using assms(1) eq encode_config[of fs \"Some (xs ! n)\"]"], ["proof (prove)\nusing this:\n  estep (encode_config c) =\n  prod_encode\n   (e2tail (encode_config c),\n    Suc (e_nth (e2xs (encode_config c)) (pdec22 (e2i (encode_config c)))))\n  step c = (fs, Some (xs ! n))\n  c = ((recf.Id m n, xs, ls) # fs, rv)\n  xs ! n = e_nth (e2xs (encode_config c)) n\n  encode_config (fs, Some (xs ! n)) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame fs),\n    encode_option (Some (xs ! n)))\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma estep:\n  assumes \"valid (fst c)\"\n  shows \"estep (encode_config c) = encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "proof (cases \"fst c\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst c = [] \\<Longrightarrow>\n    estep (encode_config c) = encode_config (step c)\n 2. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Nil"], ["proof (state)\nthis:\n  fst c = []\n\ngoal (2 subgoals):\n 1. fst c = [] \\<Longrightarrow>\n    estep (encode_config c) = encode_config (step c)\n 2. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  fst c = []", "show ?thesis"], ["proof (prove)\nusing this:\n  fst c = []\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_def"], ["proof (prove)\nusing this:\n  fst c = []\n  estep ?e \\<equiv>\n  if e2stack ?e = 0 then prod_encode (0, e2rv ?e)\n  else if e2i ?e = 0 then prod_encode (e2tail ?e, 1)\n       else if e2i ?e = 1\n            then prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\n            else if encode_kind (e2i ?e) = 2\n                 then prod_encode\n                       (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\n                 else if encode_kind (e2i ?e) = 3 then estep_Cn ?e\n                      else if encode_kind (e2i ?e) = 4 then estep_Pr ?e\n                           else if encode_kind (e2i ?e) = 5 then estep_Mn ?e\n                                else 0\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by (metis list_encode.simps(1) e2rv_def e2stack_stack encode_config_def\n      map_is_Nil_conv prod.collapse prod_encode_inverse snd_conv step.simps(1))"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case (Cons s fs)"], ["proof (state)\nthis:\n  fst c = s # fs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  fst c = s # fs", "obtain f xs ls rv where c: \"c = ((f, xs, ls) # fs, rv)\""], ["proof (prove)\nusing this:\n  fst c = s # fs\n\ngoal (1 subgoal):\n 1. (\\<And>f xs ls rv.\n        c = ((f, xs, ls) # fs, rv) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.exhaust_sel)"], ["proof (state)\nthis:\n  c = ((f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "with assms valid_def"], ["proof (chain)\npicking this:\n  valid (fst c)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n  c = ((f, xs, ls) # fs, rv)", "have lenas: \"recfn (length xs) f\""], ["proof (prove)\nusing this:\n  valid (fst c)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n  c = ((f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. recfn (length xs) f", "by simp"], ["proof (state)\nthis:\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst c = a # list \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "proof (cases f)"], ["proof (state)\ngoal (6 subgoals):\n 1. f = Z \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 2. f = S \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 3. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 5. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 6. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Z"], ["proof (state)\nthis:\n  f = Z\n\ngoal (6 subgoals):\n 1. f = Z \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 2. f = S \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 3. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 5. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 6. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = Z", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Z\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_Z c"], ["proof (prove)\nusing this:\n  f = Z\n  ?c = ((Z, ?xs, ?ls) # ?fs, ?rv) \\<Longrightarrow>\n  estep (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 2. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 5. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 2. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 5. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case S"], ["proof (state)\nthis:\n  f = S\n\ngoal (5 subgoals):\n 1. f = S \\<Longrightarrow> estep (encode_config c) = encode_config (step c)\n 2. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 5. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = S", "show ?thesis"], ["proof (prove)\nusing this:\n  f = S\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_S c lenas"], ["proof (prove)\nusing this:\n  f = S\n  \\<lbrakk>?c = ((S, ?xs, ?ls) # ?fs, ?rv);\n   recfn (length ?xs) (fst (hd (fst ?c)))\\<rbrakk>\n  \\<Longrightarrow> estep (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Id"], ["proof (state)\nthis:\n  f = recf.Id x31_ x32_\n\ngoal (4 subgoals):\n 1. \\<And>x31 x32.\n       f = recf.Id x31 x32 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 4. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = recf.Id x31_ x32_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = recf.Id x31_ x32_\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_Id c lenas"], ["proof (prove)\nusing this:\n  f = recf.Id x31_ x32_\n  \\<lbrakk>?c = ((recf.Id ?m ?n, ?xs, ?ls) # ?fs, ?rv);\n   recfn (length ?xs) (fst (hd (fst ?c)))\\<rbrakk>\n  \\<Longrightarrow> estep (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by simp"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Cn"], ["proof (state)\nthis:\n  f = Cn x41_ x42_ x43_\n\ngoal (3 subgoals):\n 1. \\<And>x41 x42 x43.\n       f = Cn x41 x42 x43 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 3. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = Cn x41_ x42_ x43_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Cn x41_ x42_ x43_\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_Cn c"], ["proof (prove)\nusing this:\n  f = Cn x41_ x42_ x43_\n  ?c = ((Cn ?n ?f ?gs, ?xs, ?ls) # ?fs, ?rv) \\<Longrightarrow>\n  estep_Cn (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by (metis e2i_f e2stack_0_iff_Nil encode.simps(1) encode.simps(2) encode_kind_2\n        encode_kind_3 encode_kind_Cn estep_def list.distinct(1) recf.distinct(13)\n        recf.distinct(19) recf.distinct(5))"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Pr"], ["proof (state)\nthis:\n  f = Pr x51_ x52_ x53_\n\ngoal (2 subgoals):\n 1. \\<And>x51 x52 x53.\n       f = Pr x51 x52 x53 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)\n 2. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = Pr x51_ x52_ x53_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Pr x51_ x52_ x53_\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_Pr c lenas"], ["proof (prove)\nusing this:\n  f = Pr x51_ x52_ x53_\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv);\n   recfn (length ?xs) (Pr ?n ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by (metis e2i_f e2stack_0_iff_Nil encode.simps(1) encode.simps(2) encode_kind_2\n        encode_kind_4 encode_kind_Cn encode_kind_Pr estep_def list.distinct(1) recf.distinct(15)\n        recf.distinct(21) recf.distinct(25) recf.distinct(7))"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "case Mn"], ["proof (state)\nthis:\n  f = Mn x61_ x62_\n\ngoal (1 subgoal):\n 1. \\<And>x61 x62.\n       f = Mn x61 x62 \\<Longrightarrow>\n       estep (encode_config c) = encode_config (step c)", "then"], ["proof (chain)\npicking this:\n  f = Mn x61_ x62_", "show ?thesis"], ["proof (prove)\nusing this:\n  f = Mn x61_ x62_\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "using estep_Pr c lenas"], ["proof (prove)\nusing this:\n  f = Mn x61_ x62_\n  \\<lbrakk>?c = ((Pr ?n ?f ?g, ?xs, ?ls) # ?fs, ?rv);\n   recfn (length ?xs) (Pr ?n ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> estep_Pr (encode_config ?c) = encode_config (step ?c)\n  c = ((f, xs, ls) # fs, rv)\n  recfn (length xs) f\n\ngoal (1 subgoal):\n 1. estep (encode_config c) = encode_config (step c)", "by (metis (no_types, lifting) e2i_f e2stack_0_iff_Nil encode.simps(1)\n        encode.simps(2) encode_kind_2 encode_kind_5 encode_kind_Cn encode_kind_Mn encode_kind_Pr\n        estep_Mn estep_def list.distinct(1) recf.distinct(17) recf.distinct(23)\n        recf.distinct(27) recf.distinct(9))"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  estep (encode_config c) = encode_config (step c)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The step function as a partial recursive function\\label{s:step_recf}\\<close>"], ["", "text \\<open>In this section we construct a primitive recursive function\n@{term r_step} computing @{term estep}. This will entail defining @{typ\nrecf}s for many functions defined in the previous section.\\<close>"], ["", "definition \"r_e2stack \\<equiv> r_pdec1\""], ["", "lemma r_e2stack_prim: \"prim_recfn 1 r_e2stack\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2stack", "unfolding r_e2stack_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec1", "using r_pdec1_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec1\n\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec1", "by simp"], ["", "lemma r_e2stack [simp]: \"eval r_e2stack [e] \\<down>= e2stack e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2stack [e] \\<down>= e2stack e", "unfolding r_e2stack_def e2stack_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec1 [e] \\<down>= pdec1 e", "using r_pdec1_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec1\n\ngoal (1 subgoal):\n 1. eval r_pdec1 [e] \\<down>= pdec1 e", "by simp"], ["", "definition \"r_e2rv \\<equiv> r_pdec2\""], ["", "lemma r_e2rv_prim: \"prim_recfn 1 r_e2rv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2rv", "unfolding r_e2rv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec2", "using r_pdec2_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec2\n\ngoal (1 subgoal):\n 1. prim_recfn 1 r_pdec2", "by simp"], ["", "lemma r_e2rv [simp]: \"eval r_e2rv [e] \\<down>= e2rv e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2rv [e] \\<down>= e2rv e", "unfolding r_e2rv_def e2rv_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec2 [e] \\<down>= pdec2 e", "using r_pdec2_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec2\n\ngoal (1 subgoal):\n 1. eval r_pdec2 [e] \\<down>= pdec2 e", "by simp"], ["", "definition \"r_e2tail \\<equiv> Cn 1 r_tl [r_e2stack]\""], ["", "lemma r_e2tail_prim: \"prim_recfn 1 r_e2tail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2tail", "unfolding r_e2tail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_tl [r_e2stack])", "using r_e2stack_prim r_tl_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_tl\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_tl [r_e2stack])", "by simp"], ["", "lemma r_e2tail [simp]: \"eval r_e2tail [e] \\<down>= e2tail e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2tail [e] \\<down>= e2tail e", "unfolding r_e2tail_def e2tail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_tl [r_e2stack]) [e] \\<down>= e_tl (e2stack e)", "using r_e2stack_prim r_tl_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_tl\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_tl [r_e2stack]) [e] \\<down>= e_tl (e2stack e)", "by simp"], ["", "definition \"r_e2frame \\<equiv> Cn 1 r_hd [r_e2stack]\""], ["", "lemma r_e2frame_prim: \"prim_recfn 1 r_e2frame\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2frame", "unfolding r_e2frame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_hd [r_e2stack])", "using r_hd_prim r_e2stack_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_hd\n  prim_recfn 1 r_e2stack\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_hd [r_e2stack])", "by simp"], ["", "lemma r_e2frame [simp]: \"eval r_e2frame [e] \\<down>= e2frame e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2frame [e] \\<down>= e2frame e", "unfolding r_e2frame_def e2frame_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_hd [r_e2stack]) [e] \\<down>= e_hd (e2stack e)", "using r_hd_prim r_e2stack_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_hd\n  prim_recfn 1 r_e2stack\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_hd [r_e2stack]) [e] \\<down>= e_hd (e2stack e)", "by simp"], ["", "definition \"r_e2i \\<equiv> Cn 1 r_pdec1 [r_e2frame]\""], ["", "lemma r_e2i_prim: \"prim_recfn 1 r_e2i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2i", "unfolding r_e2i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec1 [r_e2frame])", "using r_pdec12_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec12\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec1 [r_e2frame])", "by simp"], ["", "lemma r_e2i [simp]: \"eval r_e2i [e] \\<down>= e2i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2i [e] \\<down>= e2i e", "unfolding r_e2i_def e2i_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec1 [r_e2frame]) [e] \\<down>= pdec1 (e2frame e)", "using r_pdec12_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec12\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec1 [r_e2frame]) [e] \\<down>= pdec1 (e2frame e)", "by simp"], ["", "definition \"r_e2xs \\<equiv> Cn 1 r_pdec12 [r_e2frame]\""], ["", "lemma r_e2xs_prim: \"prim_recfn 1 r_e2xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2xs", "unfolding r_e2xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec12 [r_e2frame])", "using r_pdec122_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec122\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec12 [r_e2frame])", "by simp"], ["", "lemma r_e2xs [simp]: \"eval r_e2xs [e] \\<down>= e2xs e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2xs [e] \\<down>= e2xs e", "unfolding r_e2xs_def e2xs_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec12 [r_e2frame]) [e] \\<down>= pdec12 (e2frame e)", "using r_pdec122_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec122\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec12 [r_e2frame]) [e] \\<down>= pdec12 (e2frame e)", "by simp"], ["", "definition \"r_e2ls \\<equiv> Cn 1 r_pdec22 [r_e2frame]\""], ["", "lemma r_e2ls_prim: \"prim_recfn 1 r_e2ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2ls", "unfolding r_e2ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec22 [r_e2frame])", "using r_pdec222_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec222\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_pdec22 [r_e2frame])", "by simp"], ["", "lemma r_e2ls [simp]: \"eval r_e2ls [e] \\<down>= e2ls e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2ls [e] \\<down>= e2ls e", "unfolding r_e2ls_def e2ls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec22 [r_e2frame]) [e] \\<down>= pdec22 (e2frame e)", "using r_pdec222_prim r_e2frame_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_pdec222\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_pdec22 [r_e2frame]) [e] \\<down>= pdec22 (e2frame e)", "by simp"], ["", "definition \"r_e2lenls \\<equiv> Cn 1 r_length [r_e2ls]\""], ["", "lemma r_e2lenls_prim: \"prim_recfn 1 r_e2lenls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_e2lenls", "unfolding r_e2lenls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_length [r_e2ls])", "using r_length_prim r_e2ls_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_length\n  prim_recfn 1 r_e2ls\n\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 r_length [r_e2ls])", "by simp"], ["", "lemma r_e2lenls [simp]: \"eval r_e2lenls [e] \\<down>= e2lenls e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_e2lenls [e] \\<down>= e2lenls e", "unfolding r_e2lenls_def e2lenls_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_length [r_e2ls]) [e] \\<down>= e_length (e2ls e)", "using r_length_prim r_e2ls_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_length\n  prim_recfn 1 r_e2ls\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_length [r_e2ls]) [e] \\<down>= e_length (e2ls e)", "by simp"], ["", "definition \"r_kind \\<equiv>\n  Cn 1 r_ifz [Id 1 0, Z, Cn 1 r_ifeq [Id 1 0, r_const 1, r_const 1, r_pdec1]]\""], ["", "lemma r_kind_prim: \"prim_recfn 1 r_kind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_kind", "unfolding r_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [recf.Id 1 0, Z,\n        Cn 1 r_ifeq [recf.Id 1 0, r_const 1, r_const 1, r_pdec1]])", "by simp"], ["", "lemma r_kind: \"eval r_kind [e] \\<down>= encode_kind e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_kind [e] \\<down>= encode_kind e", "unfolding r_kind_def encode_kind_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [recf.Id 1 0, Z,\n        Cn 1 r_ifeq [recf.Id 1 0, r_const 1, r_const 1, r_pdec1]])\n     [e] \\<down>=\n    (if e = 0 then 0 else if e = 1 then 1 else pdec1 e)", "by simp"], ["", "lemmas helpers_for_r_step_prim =\n  r_e2i_prim\n  r_e2lenls_prim\n  r_e2ls_prim\n  r_e2rv_prim\n  r_e2xs_prim\n  r_e2stack_prim\n  r_e2tail_prim\n  r_e2frame_prim"], ["", "text \\<open>We define primitive recursive functions @{term r_step_Id}, @{term\nr_step_Cn}, @{term r_step_Pr}, and @{term r_step_Mn}. The last three\ncorrespond to @{term estep_Cn}, @{term estep_Pr}, and @{term estep_Mn} from\nthe previous section.\\<close>"], ["", "definition \"r_step_Id \\<equiv>\n  Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]]\""], ["", "lemma r_step_Id:\n  \"eval r_step_Id [e] \\<down>= prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step_Id [e] \\<down>=\n    prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))", "unfolding r_step_Id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [r_e2tail, Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]])\n     [e] \\<down>=\n    prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_prod_encode\n       [r_e2tail, Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]])\n     [e] \\<down>=\n    prod_encode (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))", "by simp"], ["", "abbreviation r_triple_encode :: \"recf \\<Rightarrow> recf \\<Rightarrow> recf \\<Rightarrow> recf\" where\n  \"r_triple_encode x y z \\<equiv> Cn 1 r_prod_encode [x, Cn 1 r_prod_encode [y, z]]\""], ["", "definition \"r_step_Cn \\<equiv>\n  Cn 1 r_ifeq\n   [r_e2lenls,\n    Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n    Cn 1 r_ifz\n     [r_e2rv,\n      Cn 1 r_prod_encode\n       [Cn 1 r_cons [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) r_e2ls Z, r_e2stack],\n        Z],\n      Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n    Cn 1 r_ifz\n     [r_e2rv,\n      Cn 1 r_ifless\n       [r_e2lenls,\n        Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n        Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode (Cn 1 r_nth [Cn 1 r_pdec222 [r_e2i], r_e2lenls]) r_e2xs Z,\n            r_e2stack],\n          Z],\n        Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n      Cn 1 r_prod_encode\n       [Cn 1 r_cons\n         [r_triple_encode r_e2i r_e2xs (Cn 1 r_snoc [r_e2ls, Cn 1 r_dec [r_e2rv]]),\n          r_e2tail],\n        Z]]]\""], ["", "lemma r_step_Cn_prim: \"prim_recfn 1 r_step_Cn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_step_Cn", "unfolding r_step_Cn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifeq\n       [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) r_e2ls Z, r_e2stack],\n            Z],\n          Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_ifless\n           [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode\n                 (Cn 1 r_nth [Cn 1 r_pdec222 [r_e2i], r_e2lenls]) r_e2xs Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_snoc [r_e2ls, Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]]])", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifeq\n       [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) r_e2ls Z, r_e2stack],\n            Z],\n          Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_ifless\n           [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode\n                 (Cn 1 r_nth [Cn 1 r_pdec222 [r_e2i], r_e2lenls]) r_e2xs Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_snoc [r_e2ls, Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]]])", "by simp"], ["", "lemma r_step_Cn: \"eval r_step_Cn [e] \\<down>= estep_Cn e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step_Cn [e] \\<down>= estep_Cn e", "unfolding r_step_Cn_def estep_Cn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) r_e2ls Z, r_e2stack],\n            Z],\n          Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_ifless\n           [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode\n                 (Cn 1 r_nth [Cn 1 r_pdec222 [r_e2i], r_e2lenls]) r_e2xs Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_snoc [r_e2ls, Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]]])\n     [e] \\<down>=\n    (if e2lenls e = e_length (pdec222 (e2i e))\n     then if e2rv e = 0\n          then prod_encode\n                (e_cons (triple_encode (pdec122 (e2i e)) (e2ls e) 0)\n                  (e2stack e),\n                 0)\n          else prod_encode (e2tail e, e2rv e)\n     else if e2rv e = 0\n          then if e2lenls e < e_length (pdec222 (e2i e))\n               then prod_encode\n                     (e_cons\n                       (triple_encode (e_nth (pdec222 (e2i e)) (e2lenls e))\n                         (e2xs e) 0)\n                       (e2stack e),\n                      0)\n               else prod_encode (e2tail e, e2rv e)\n          else prod_encode\n                (e_cons\n                  (triple_encode (e2i e) (e2xs e)\n                    (e_snoc (e2ls e) (e2rv e - 1)))\n                  (e2tail e),\n                 0))", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifeq\n       [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) r_e2ls Z, r_e2stack],\n            Z],\n          Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_ifless\n           [r_e2lenls, Cn 1 r_length [Cn 1 r_pdec222 [r_e2i]],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode\n                 (Cn 1 r_nth [Cn 1 r_pdec222 [r_e2i], r_e2lenls]) r_e2xs Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode [r_e2tail, r_e2rv]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_snoc [r_e2ls, Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]]])\n     [e] \\<down>=\n    (if e2lenls e = e_length (pdec222 (e2i e))\n     then if e2rv e = 0\n          then prod_encode\n                (e_cons (triple_encode (pdec122 (e2i e)) (e2ls e) 0)\n                  (e2stack e),\n                 0)\n          else prod_encode (e2tail e, e2rv e)\n     else if e2rv e = 0\n          then if e2lenls e < e_length (pdec222 (e2i e))\n               then prod_encode\n                     (e_cons\n                       (triple_encode (e_nth (pdec222 (e2i e)) (e2lenls e))\n                         (e2xs e) 0)\n                       (e2stack e),\n                      0)\n               else prod_encode (e2tail e, e2rv e)\n          else prod_encode\n                (e_cons\n                  (triple_encode (e2i e) (e2xs e)\n                    (e_snoc (e2ls e) (e2rv e - 1)))\n                  (e2tail e),\n                 0))", "by simp"], ["", "definition \"r_step_Pr \\<equiv>\n  Cn 1 r_ifz\n   [r_e2ls,\n    Cn 1 r_ifz\n     [r_e2rv,\n      Cn 1 r_prod_encode\n       [Cn 1 r_cons\n         [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) (Cn 1 r_tl [r_e2xs]) Z,\n          r_e2stack],\n        Z],\n      Cn 1 r_prod_encode\n       [Cn 1 r_cons\n         [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Cn 1 r_dec [r_e2rv]]),\n          r_e2tail],\n        Z]],\n    Cn 1 r_ifeq\n     [r_e2lenls,\n      Cn 1 S [Cn 1 r_hd [r_e2xs]],\n      Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n      Cn 1 r_ifz\n        [r_e2rv,\n         Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode\n               (Cn 1 r_pdec222 [r_e2i])\n               (Cn 1 r_cons\n                 [Cn 1 r_dec [r_e2lenls],\n                  Cn 1 r_cons [Cn 1 r_hd [r_e2ls],\n                  Cn 1 r_tl [r_e2xs]]])\n               Z,\n              r_e2stack],\n            Z],\n         Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs (Cn 1 r_cons [Cn 1 r_dec [r_e2rv], r_e2ls]),\n              r_e2tail],\n            Z]]]]\""], ["", "lemma r_step_Pr_prim: \"prim_recfn 1 r_step_Pr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_step_Pr", "unfolding r_step_Pr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) (Cn 1 r_tl [r_e2xs])\n               Z,\n              r_e2stack],\n            Z],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_singleton_encode [Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]],\n        Cn 1 r_ifeq\n         [r_e2lenls, Cn 1 S [Cn 1 r_hd [r_e2xs]],\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_ifz\n           [r_e2rv,\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode (Cn 1 r_pdec222 [r_e2i])\n                 (Cn 1 r_cons\n                   [Cn 1 r_dec [r_e2lenls],\n                    Cn 1 r_cons [Cn 1 r_hd [r_e2ls], Cn 1 r_tl [r_e2xs]]])\n                 Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_cons [Cn 1 r_dec [r_e2rv], r_e2ls]),\n                r_e2tail],\n              Z]]]])", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) (Cn 1 r_tl [r_e2xs])\n               Z,\n              r_e2stack],\n            Z],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_singleton_encode [Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]],\n        Cn 1 r_ifeq\n         [r_e2lenls, Cn 1 S [Cn 1 r_hd [r_e2xs]],\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_ifz\n           [r_e2rv,\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode (Cn 1 r_pdec222 [r_e2i])\n                 (Cn 1 r_cons\n                   [Cn 1 r_dec [r_e2lenls],\n                    Cn 1 r_cons [Cn 1 r_hd [r_e2ls], Cn 1 r_tl [r_e2xs]]])\n                 Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_cons [Cn 1 r_dec [r_e2rv], r_e2ls]),\n                r_e2tail],\n              Z]]]])", "by simp"], ["", "lemma r_step_Pr: \"eval r_step_Pr [e] \\<down>= estep_Pr e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step_Pr [e] \\<down>= estep_Pr e", "unfolding r_step_Pr_def estep_Pr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) (Cn 1 r_tl [r_e2xs])\n               Z,\n              r_e2stack],\n            Z],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_singleton_encode [Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]],\n        Cn 1 r_ifeq\n         [r_e2lenls, Cn 1 S [Cn 1 r_hd [r_e2xs]],\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_ifz\n           [r_e2rv,\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode (Cn 1 r_pdec222 [r_e2i])\n                 (Cn 1 r_cons\n                   [Cn 1 r_dec [r_e2lenls],\n                    Cn 1 r_cons [Cn 1 r_hd [r_e2ls], Cn 1 r_tl [r_e2xs]]])\n                 Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_cons [Cn 1 r_dec [r_e2rv], r_e2ls]),\n                r_e2tail],\n              Z]]]])\n     [e] \\<down>=\n    (if e2ls e = 0\n     then if e2rv e = 0\n          then prod_encode\n                (e_cons (triple_encode (pdec122 (e2i e)) (e_tl (e2xs e)) 0)\n                  (e2stack e),\n                 0)\n          else prod_encode\n                (e_cons\n                  (triple_encode (e2i e) (e2xs e)\n                    (singleton_encode (e2rv e - 1)))\n                  (e2tail e),\n                 0)\n     else if e2lenls e = Suc (e_hd (e2xs e))\n          then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n          else if e2rv e = 0\n               then prod_encode\n                     (e_cons\n                       (triple_encode (pdec222 (e2i e))\n                         (e_cons (e2lenls e - 1)\n                           (e_cons (e_hd (e2ls e)) (e_tl (e2xs e))))\n                         0)\n                       (e2stack e),\n                      0)\n               else prod_encode\n                     (e_cons\n                       (triple_encode (e2i e) (e2xs e)\n                         (e_cons (e2rv e - 1) (e2ls e)))\n                       (e2tail e),\n                      0))", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_ifz\n         [r_e2rv,\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec122 [r_e2i]) (Cn 1 r_tl [r_e2xs])\n               Z,\n              r_e2stack],\n            Z],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs\n               (Cn 1 r_singleton_encode [Cn 1 r_dec [r_e2rv]]),\n              r_e2tail],\n            Z]],\n        Cn 1 r_ifeq\n         [r_e2lenls, Cn 1 S [Cn 1 r_hd [r_e2xs]],\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_ifz\n           [r_e2rv,\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode (Cn 1 r_pdec222 [r_e2i])\n                 (Cn 1 r_cons\n                   [Cn 1 r_dec [r_e2lenls],\n                    Cn 1 r_cons [Cn 1 r_hd [r_e2ls], Cn 1 r_tl [r_e2xs]]])\n                 Z,\n                r_e2stack],\n              Z],\n            Cn 1 r_prod_encode\n             [Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_cons [Cn 1 r_dec [r_e2rv], r_e2ls]),\n                r_e2tail],\n              Z]]]])\n     [e] \\<down>=\n    (if e2ls e = 0\n     then if e2rv e = 0\n          then prod_encode\n                (e_cons (triple_encode (pdec122 (e2i e)) (e_tl (e2xs e)) 0)\n                  (e2stack e),\n                 0)\n          else prod_encode\n                (e_cons\n                  (triple_encode (e2i e) (e2xs e)\n                    (singleton_encode (e2rv e - 1)))\n                  (e2tail e),\n                 0)\n     else if e2lenls e = Suc (e_hd (e2xs e))\n          then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n          else if e2rv e = 0\n               then prod_encode\n                     (e_cons\n                       (triple_encode (pdec222 (e2i e))\n                         (e_cons (e2lenls e - 1)\n                           (e_cons (e_hd (e2ls e)) (e_tl (e2xs e))))\n                         0)\n                       (e2stack e),\n                      0)\n               else prod_encode\n                     (e_cons\n                       (triple_encode (e2i e) (e2xs e)\n                         (e_cons (e2rv e - 1) (e2ls e)))\n                       (e2tail e),\n                      0))", "by simp"], ["", "definition \"r_step_Mn \\<equiv>\n  Cn 1 r_ifz\n   [r_e2ls,\n    Cn 1 r_prod_encode\n      [Cn 1 r_cons\n        [r_triple_encode (Cn 1 r_pdec22 [r_e2i]) (Cn 1 r_cons [Z, r_e2xs]) Z,\n         Cn 1 r_cons\n           [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Z]),\n            r_e2tail]],\n       Z],\n    Cn 1 r_ifeq\n      [r_e2rv,\n       r_const 1,\n       Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n       Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode\n             (Cn 1 r_pdec22 [r_e2i])\n             (Cn 1 r_cons [Cn 1 S [Cn 1 r_hd [r_e2ls]], r_e2xs])\n             Z,\n            Cn 1 r_cons\n              [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Cn 1 S [Cn 1 r_hd [r_e2ls]]]),\n               r_e2tail]],\n          Z]]]\""], ["", "lemma r_step_Mn_prim: \"prim_recfn 1 r_step_Mn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_step_Mn", "unfolding r_step_Mn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n             (Cn 1 r_cons [Z, r_e2xs]) Z,\n            Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Z]),\n              r_e2tail]],\n          Z],\n        Cn 1 r_ifeq\n         [r_e2rv, r_const 1,\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n               (Cn 1 r_cons [Cn 1 S [Cn 1 r_hd [r_e2ls]], r_e2xs]) Z,\n              Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_singleton_encode [Cn 1 S [Cn 1 r_hd [r_e2ls]]]),\n                r_e2tail]],\n            Z]]])", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n             (Cn 1 r_cons [Z, r_e2xs]) Z,\n            Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Z]),\n              r_e2tail]],\n          Z],\n        Cn 1 r_ifeq\n         [r_e2rv, r_const 1,\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n               (Cn 1 r_cons [Cn 1 S [Cn 1 r_hd [r_e2ls]], r_e2xs]) Z,\n              Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_singleton_encode [Cn 1 S [Cn 1 r_hd [r_e2ls]]]),\n                r_e2tail]],\n            Z]]])", "by simp"], ["", "lemma r_step_Mn: \"eval r_step_Mn [e] \\<down>= estep_Mn e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step_Mn [e] \\<down>= estep_Mn e", "unfolding r_step_Mn_def estep_Mn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n             (Cn 1 r_cons [Z, r_e2xs]) Z,\n            Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Z]),\n              r_e2tail]],\n          Z],\n        Cn 1 r_ifeq\n         [r_e2rv, r_const 1,\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n               (Cn 1 r_cons [Cn 1 S [Cn 1 r_hd [r_e2ls]], r_e2xs]) Z,\n              Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_singleton_encode [Cn 1 S [Cn 1 r_hd [r_e2ls]]]),\n                r_e2tail]],\n            Z]]])\n     [e] \\<down>=\n    (if e2ls e = 0\n     then prod_encode\n           (e_cons (triple_encode (pdec22 (e2i e)) (e_cons 0 (e2xs e)) 0)\n             (e_cons (triple_encode (e2i e) (e2xs e) (singleton_encode 0))\n               (e2tail e)),\n            0)\n     else if e2rv e = 1 then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n          else prod_encode\n                (e_cons\n                  (triple_encode (pdec22 (e2i e))\n                    (e_cons (Suc (e_hd (e2ls e))) (e2xs e)) 0)\n                  (e_cons\n                    (triple_encode (e2i e) (e2xs e)\n                      (singleton_encode (Suc (e_hd (e2ls e)))))\n                    (e2tail e)),\n                 0))", "using helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2ls,\n        Cn 1 r_prod_encode\n         [Cn 1 r_cons\n           [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n             (Cn 1 r_cons [Z, r_e2xs]) Z,\n            Cn 1 r_cons\n             [r_triple_encode r_e2i r_e2xs (Cn 1 r_singleton_encode [Z]),\n              r_e2tail]],\n          Z],\n        Cn 1 r_ifeq\n         [r_e2rv, r_const 1,\n          Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_hd [r_e2ls]]],\n          Cn 1 r_prod_encode\n           [Cn 1 r_cons\n             [r_triple_encode (Cn 1 r_pdec22 [r_e2i])\n               (Cn 1 r_cons [Cn 1 S [Cn 1 r_hd [r_e2ls]], r_e2xs]) Z,\n              Cn 1 r_cons\n               [r_triple_encode r_e2i r_e2xs\n                 (Cn 1 r_singleton_encode [Cn 1 S [Cn 1 r_hd [r_e2ls]]]),\n                r_e2tail]],\n            Z]]])\n     [e] \\<down>=\n    (if e2ls e = 0\n     then prod_encode\n           (e_cons (triple_encode (pdec22 (e2i e)) (e_cons 0 (e2xs e)) 0)\n             (e_cons (triple_encode (e2i e) (e2xs e) (singleton_encode 0))\n               (e2tail e)),\n            0)\n     else if e2rv e = 1 then prod_encode (e2tail e, Suc (e_hd (e2ls e)))\n          else prod_encode\n                (e_cons\n                  (triple_encode (pdec22 (e2i e))\n                    (e_cons (Suc (e_hd (e2ls e))) (e2xs e)) 0)\n                  (e_cons\n                    (triple_encode (e2i e) (e2xs e)\n                      (singleton_encode (Suc (e_hd (e2ls e)))))\n                    (e2tail e)),\n                 0))", "by simp"], ["", "definition \"r_step \\<equiv>\n  Cn 1 r_ifz\n    [r_e2stack,\n     Cn 1 r_prod_encode [Z, r_e2rv],\n     Cn 1 r_ifz\n       [r_e2i,\n        Cn 1 r_prod_encode [r_e2tail, r_const 1],\n        Cn 1 r_ifeq\n          [r_e2i,\n           r_const 1,\n           Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 S [Cn 1 r_hd [r_e2xs]]]],\n           Cn 1 r_ifeq\n             [Cn 1 r_kind [r_e2i],\n              r_const 2,\n              Cn 1 r_prod_encode [r_e2tail, Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]],\n              Cn 1 r_ifeq\n                [Cn 1 r_kind [r_e2i],\n                 r_const 3,\n                 r_step_Cn,\n                 Cn 1 r_ifeq\n                   [Cn 1 r_kind [r_e2i],\n                    r_const 4,\n                    r_step_Pr,\n                    Cn 1 r_ifeq\n                      [Cn 1 r_kind [r_e2i], r_const 5, r_step_Mn, Z]]]]]]]\""], ["", "lemma r_step_prim: \"prim_recfn 1 r_step\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_step", "unfolding r_step_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2stack, Cn 1 r_prod_encode [Z, r_e2rv],\n        Cn 1 r_ifz\n         [r_e2i, Cn 1 r_prod_encode [r_e2tail, r_const 1],\n          Cn 1 r_ifeq\n           [r_e2i, r_const 1,\n            Cn 1 r_prod_encode\n             [r_e2tail, Cn 1 S [Cn 1 S [Cn 1 r_hd [r_e2xs]]]],\n            Cn 1 r_ifeq\n             [Cn 1 r_kind [r_e2i], r_const 2,\n              Cn 1 r_prod_encode\n               [r_e2tail,\n                Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]],\n              Cn 1 r_ifeq\n               [Cn 1 r_kind [r_e2i], r_const 3, r_step_Cn,\n                Cn 1 r_ifeq\n                 [Cn 1 r_kind [r_e2i], r_const 4, r_step_Pr,\n                  Cn 1 r_ifeq\n                   [Cn 1 r_kind [r_e2i], r_const 5, r_step_Mn, Z]]]]]]])", "using r_kind_prim r_step_Mn_prim r_step_Pr_prim r_step_Cn_prim helpers_for_r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_kind\n  prim_recfn 1 r_step_Mn\n  prim_recfn 1 r_step_Pr\n  prim_recfn 1 r_step_Cn\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n\ngoal (1 subgoal):\n 1. prim_recfn 1\n     (Cn 1 r_ifz\n       [r_e2stack, Cn 1 r_prod_encode [Z, r_e2rv],\n        Cn 1 r_ifz\n         [r_e2i, Cn 1 r_prod_encode [r_e2tail, r_const 1],\n          Cn 1 r_ifeq\n           [r_e2i, r_const 1,\n            Cn 1 r_prod_encode\n             [r_e2tail, Cn 1 S [Cn 1 S [Cn 1 r_hd [r_e2xs]]]],\n            Cn 1 r_ifeq\n             [Cn 1 r_kind [r_e2i], r_const 2,\n              Cn 1 r_prod_encode\n               [r_e2tail,\n                Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]],\n              Cn 1 r_ifeq\n               [Cn 1 r_kind [r_e2i], r_const 3, r_step_Cn,\n                Cn 1 r_ifeq\n                 [Cn 1 r_kind [r_e2i], r_const 4, r_step_Pr,\n                  Cn 1 r_ifeq\n                   [Cn 1 r_kind [r_e2i], r_const 5, r_step_Mn, Z]]]]]]])", "by simp"], ["", "lemma r_step: \"eval r_step [e] \\<down>= estep e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step [e] \\<down>= estep e", "unfolding r_step_def estep_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2stack, Cn 1 r_prod_encode [Z, r_e2rv],\n        Cn 1 r_ifz\n         [r_e2i, Cn 1 r_prod_encode [r_e2tail, r_const 1],\n          Cn 1 r_ifeq\n           [r_e2i, r_const 1,\n            Cn 1 r_prod_encode\n             [r_e2tail, Cn 1 S [Cn 1 S [Cn 1 r_hd [r_e2xs]]]],\n            Cn 1 r_ifeq\n             [Cn 1 r_kind [r_e2i], r_const 2,\n              Cn 1 r_prod_encode\n               [r_e2tail,\n                Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]],\n              Cn 1 r_ifeq\n               [Cn 1 r_kind [r_e2i], r_const 3, r_step_Cn,\n                Cn 1 r_ifeq\n                 [Cn 1 r_kind [r_e2i], r_const 4, r_step_Pr,\n                  Cn 1 r_ifeq\n                   [Cn 1 r_kind [r_e2i], r_const 5, r_step_Mn, Z]]]]]]])\n     [e] \\<down>=\n    (if e2stack e = 0 then prod_encode (0, e2rv e)\n     else if e2i e = 0 then prod_encode (e2tail e, 1)\n          else if e2i e = 1\n               then prod_encode (e2tail e, Suc (Suc (e_hd (e2xs e))))\n               else if encode_kind (e2i e) = 2\n                    then prod_encode\n                          (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))\n                    else if encode_kind (e2i e) = 3 then estep_Cn e\n                         else if encode_kind (e2i e) = 4 then estep_Pr e\n                              else if encode_kind (e2i e) = 5\n                                   then estep_Mn e else 0)", "using r_kind_prim r_step_Mn_prim r_step_Pr_prim r_step_Cn_prim helpers_for_r_step_prim\n    r_kind r_step_Cn r_step_Pr r_step_Mn"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_kind\n  prim_recfn 1 r_step_Mn\n  prim_recfn 1 r_step_Pr\n  prim_recfn 1 r_step_Cn\n  prim_recfn 1 r_e2i\n  prim_recfn 1 r_e2lenls\n  prim_recfn 1 r_e2ls\n  prim_recfn 1 r_e2rv\n  prim_recfn 1 r_e2xs\n  prim_recfn 1 r_e2stack\n  prim_recfn 1 r_e2tail\n  prim_recfn 1 r_e2frame\n  eval r_kind [?e] \\<down>= encode_kind ?e\n  eval r_step_Cn [?e] \\<down>= estep_Cn ?e\n  eval r_step_Pr [?e] \\<down>= estep_Pr ?e\n  eval r_step_Mn [?e] \\<down>= estep_Mn ?e\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 1 r_ifz\n       [r_e2stack, Cn 1 r_prod_encode [Z, r_e2rv],\n        Cn 1 r_ifz\n         [r_e2i, Cn 1 r_prod_encode [r_e2tail, r_const 1],\n          Cn 1 r_ifeq\n           [r_e2i, r_const 1,\n            Cn 1 r_prod_encode\n             [r_e2tail, Cn 1 S [Cn 1 S [Cn 1 r_hd [r_e2xs]]]],\n            Cn 1 r_ifeq\n             [Cn 1 r_kind [r_e2i], r_const 2,\n              Cn 1 r_prod_encode\n               [r_e2tail,\n                Cn 1 S [Cn 1 r_nth [r_e2xs, Cn 1 r_pdec22 [r_e2i]]]],\n              Cn 1 r_ifeq\n               [Cn 1 r_kind [r_e2i], r_const 3, r_step_Cn,\n                Cn 1 r_ifeq\n                 [Cn 1 r_kind [r_e2i], r_const 4, r_step_Pr,\n                  Cn 1 r_ifeq\n                   [Cn 1 r_kind [r_e2i], r_const 5, r_step_Mn, Z]]]]]]])\n     [e] \\<down>=\n    (if e2stack e = 0 then prod_encode (0, e2rv e)\n     else if e2i e = 0 then prod_encode (e2tail e, 1)\n          else if e2i e = 1\n               then prod_encode (e2tail e, Suc (Suc (e_hd (e2xs e))))\n               else if encode_kind (e2i e) = 2\n                    then prod_encode\n                          (e2tail e, Suc (e_nth (e2xs e) (pdec22 (e2i e))))\n                    else if encode_kind (e2i e) = 3 then estep_Cn e\n                         else if encode_kind (e2i e) = 4 then estep_Pr e\n                              else if encode_kind (e2i e) = 5\n                                   then estep_Mn e else 0)", "by simp"], ["", "theorem r_step_equiv_step:\n  assumes \"valid (fst c)\"\n  shows \"eval r_step [encode_config c] \\<down>= encode_config (step c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step [encode_config c] \\<down>= encode_config (step c)", "using r_step estep assms"], ["proof (prove)\nusing this:\n  eval r_step [?e] \\<down>= estep ?e\n  valid (fst ?c) \\<Longrightarrow>\n  estep (encode_config ?c) = encode_config (step ?c)\n  valid (fst c)\n\ngoal (1 subgoal):\n 1. eval r_step [encode_config c] \\<down>= encode_config (step c)", "by simp"], ["", "subsection \\<open>The universal function\\label{s:the_universal}\\<close>"], ["", "text \\<open>The next function computes the configuration after arbitrarily\nmany steps.\\<close>"], ["", "definition \"r_leap \\<equiv>\n  Pr 2\n   (Cn 2 r_prod_encode\n     [Cn 2 r_singleton_encode\n       [Cn 2 r_prod_encode [Id 2 0, Cn 2 r_prod_encode [Id 2 1, r_constn 1 0]]],\n      r_constn 1 0])\n   (Cn 4 r_step [Id 4 1])\""], ["", "lemma r_leap_prim [simp]: \"prim_recfn 3 r_leap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_leap", "unfolding r_leap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Pr 2\n       (Cn 2 r_prod_encode\n         [Cn 2 r_singleton_encode\n           [Cn 2 r_prod_encode\n             [recf.Id 2 0, Cn 2 r_prod_encode [recf.Id 2 1, r_constn 1 0]]],\n          r_constn 1 0])\n       (Cn 4 r_step [recf.Id 4 1]))", "using r_step_prim"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_step\n\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Pr 2\n       (Cn 2 r_prod_encode\n         [Cn 2 r_singleton_encode\n           [Cn 2 r_prod_encode\n             [recf.Id 2 0, Cn 2 r_prod_encode [recf.Id 2 1, r_constn 1 0]]],\n          r_constn 1 0])\n       (Cn 4 r_step [recf.Id 4 1]))", "by simp"], ["", "lemma r_leap_total: \"eval r_leap [t, i, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [t, i, x] \\<down>", "using prim_recfn_total[OF r_leap_prim]"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_leap\n\ngoal (1 subgoal):\n 1. eval r_leap [t, i, x] \\<down>", "by simp"], ["", "lemma r_leap:\n  assumes \"i = encode f\" and \"recfn (e_length x) f\"\n  shows \"eval r_leap [t, i, x] \\<down>= encode_config (iterate t step ([(f, list_decode x, [])], None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [t, i, x] \\<down>=\n    encode_config\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))", "proof (induction t)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval r_leap [0, i, x] \\<down>=\n    encode_config\n     (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))\n 2. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval r_leap [0, i, x] \\<down>=\n    encode_config\n     (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))\n 2. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [0, i, x] \\<down>=\n    encode_config\n     (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))", "unfolding r_leap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Pr 2\n       (Cn 2 r_prod_encode\n         [Cn 2 r_singleton_encode\n           [Cn 2 r_prod_encode\n             [recf.Id 2 0, Cn 2 r_prod_encode [recf.Id 2 1, r_constn 1 0]]],\n          r_constn 1 0])\n       (Cn 4 r_step [recf.Id 4 1]))\n     [0, i, x] \\<down>=\n    encode_config\n     (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))", "using r_step_prim assms encode_config encode_frame"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_step\n  i = encode f\n  recfn (e_length x) f\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n  encode_frame (?f, ?xs, ?ls) =\n  triple_encode (encode ?f) (Partial_Recursive.list_encode ?xs)\n   (Partial_Recursive.list_encode ?ls)\n\ngoal (1 subgoal):\n 1. eval\n     (Pr 2\n       (Cn 2 r_prod_encode\n         [Cn 2 r_singleton_encode\n           [Cn 2 r_prod_encode\n             [recf.Id 2 0, Cn 2 r_prod_encode [recf.Id 2 1, r_constn 1 0]]],\n          r_constn 1 0])\n       (Cn 4 r_step [recf.Id 4 1]))\n     [0, i, x] \\<down>=\n    encode_config\n     (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))", "by simp"], ["proof (state)\nthis:\n  eval r_leap [0, i, x] \\<down>=\n  encode_config\n   (iterate 0 step ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "case (Suc t)"], ["proof (state)\nthis:\n  eval r_leap [t, i, x] \\<down>=\n  encode_config\n   (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "let ?c = \"([(f, list_decode x, [])], None)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "let ?tc = \"iterate t step ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "have \"valid (fst ?c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))", "using valid_def assms"], ["proof (prove)\nusing this:\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n  i = encode f\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))", "by simp"], ["proof (state)\nthis:\n  valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:\n  valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))", "have valid: \"valid (fst ?tc)\""], ["proof (prove)\nusing this:\n  valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal (1 subgoal):\n 1. valid\n     (fst (iterate t step\n            ([(f, Partial_Recursive.list_decode x, [])], None)))", "using iterate_step_valid"], ["proof (prove)\nusing this:\n  valid (fst ([(f, Partial_Recursive.list_decode x, [])], None))\n  valid ?stack \\<Longrightarrow> valid (fst (iterate ?t step (?stack, ?rv)))\n\ngoal (1 subgoal):\n 1. valid\n     (fst (iterate t step\n            ([(f, Partial_Recursive.list_decode x, [])], None)))", "by simp"], ["proof (state)\nthis:\n  valid\n   (fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "have \"eval r_leap [Suc t, i, x] =\n      eval (Cn 4 r_step [Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]", "by (smt One_nat_def Suc_eq_plus1 eq_numeral_Suc eval_Pr_converg_Suc list.size(3) list.size(4) nat_1_add_1 pred_numeral_simps(3) r_leap_def r_leap_prim r_leap_total)"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]", "have \"eval r_leap [Suc t, i, x] = eval (Cn 4 r_step [Id 4 1]) [t, encode_config ?tc, i, x]\""], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval (Cn 4 r_step [recf.Id 4 1])\n     [t, encode_config\n          (iterate t step\n            ([(f, Partial_Recursive.list_decode x, [])], None)),\n      i, x]", "using Suc"], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n  eval r_leap [t, i, x] \\<down>=\n  encode_config\n   (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval (Cn 4 r_step [recf.Id 4 1])\n     [t, encode_config\n          (iterate t step\n            ([(f, Partial_Recursive.list_decode x, [])], None)),\n      i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1])\n   [t, encode_config\n        (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)),\n    i, x]\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1])\n   [t, encode_config\n        (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)),\n    i, x]", "have \"eval r_leap [Suc t, i, x] = eval r_step [encode_config ?tc]\""], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1])\n   [t, encode_config\n        (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)),\n    i, x]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval r_step\n     [encode_config\n       (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))]", "using r_step_prim"], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1])\n   [t, encode_config\n        (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)),\n    i, x]\n  prim_recfn 1 r_step\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval r_step\n     [encode_config\n       (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))]", "by simp"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] =\n  eval r_step\n   [encode_config\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))]\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] =\n  eval r_step\n   [encode_config\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))]", "have \"eval r_leap [Suc t, i, x] \\<down>= encode_config (step ?tc)\""], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval r_step\n   [encode_config\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None))]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] \\<down>=\n    encode_config\n     (step\n       (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)))", "by (simp add: r_step_equiv_step valid)"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] \\<down>=\n  encode_config\n   (step\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       eval r_leap [t, i, x] \\<down>=\n       encode_config\n        (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])],\n           None)) \\<Longrightarrow>\n       eval r_leap [Suc t, i, x] \\<down>=\n       encode_config\n        (iterate (Suc t) step\n          ([(f, Partial_Recursive.list_decode x, [])], None))", "then"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] \\<down>=\n  encode_config\n   (step\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)))", "show ?case"], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] \\<down>=\n  encode_config\n   (step\n     (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)))\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] \\<down>=\n    encode_config\n     (iterate (Suc t) step\n       ([(f, Partial_Recursive.list_decode x, [])], None))", "by simp"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] \\<down>=\n  encode_config\n   (iterate (Suc t) step ([(f, Partial_Recursive.list_decode x, [])], None))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_leaves_empty_stack_empty:\n  assumes \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"iterate (t + t') step ([(f, list_decode x, [])], None) = ([], Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate (t + t') step\n     ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "using assms"], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n\ngoal (1 subgoal):\n 1. iterate (t + t') step\n     ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "by (induction t') simp_all"], ["", "text \\<open>The next function is essentially a convenience wrapper around\n@{term r_leap}. It returns zero if the configuration returned by @{term\nr_leap} is non-final, and @{term \"Suc v\"} if the configuration is final with\nreturn value $v$.\\<close>"], ["", "definition \"r_result \\<equiv>\n  Cn 3 r_ifz [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0]\""], ["", "lemma r_result_prim [simp]: \"prim_recfn 3 r_result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_result", "unfolding r_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])", "using r_leap_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_leap\n\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])", "by simp"], ["", "lemma r_result_total: \"total r_result\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_result", "using r_result_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_result\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_result", "by blast"], ["", "lemma r_result_empty_stack_None:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], None)\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "unfolding r_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    0", "using assms r_leap e2stack_0_iff_Nil e2stack_def e2stack_stack r_leap_total r_leap_prim\n    e2rv_def e2rv_rv"], ["proof (prove)\nusing this:\n  i = encode f\n  recfn (e_length x) f\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], None)\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_leap [?t, ?i, ?x] \\<down>=\n                    encode_config\n                     (iterate ?t step\n                       ([(?f, Partial_Recursive.list_decode ?x, [])], None))\n  ?e = encode_config (?ss, ?rv) \\<Longrightarrow>\n  (e2stack ?e = 0) = (?ss = [])\n  e2stack ?e \\<equiv> pdec1 ?e\n  e2stack (encode_config (?ss, ?rv)) =\n  Partial_Recursive.list_encode (map encode_frame ?ss)\n  eval r_leap [?t, ?i, ?x] \\<down>\n  prim_recfn 3 r_leap\n  e2rv ?e \\<equiv> pdec2 ?e\n  e2rv (encode_config (?ss, ?rv)) = encode_option ?rv\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    0", "by simp"], ["", "lemma r_result_empty_stack_Some:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"eval r_result [t, i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v", "unfolding r_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    Suc v", "using assms r_leap e2stack_0_iff_Nil e2stack_def e2stack_stack r_leap_total r_leap_prim\n    e2rv_def e2rv_rv"], ["proof (prove)\nusing this:\n  i = encode f\n  recfn (e_length x) f\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_leap [?t, ?i, ?x] \\<down>=\n                    encode_config\n                     (iterate ?t step\n                       ([(?f, Partial_Recursive.list_decode ?x, [])], None))\n  ?e = encode_config (?ss, ?rv) \\<Longrightarrow>\n  (e2stack ?e = 0) = (?ss = [])\n  e2stack ?e \\<equiv> pdec1 ?e\n  e2stack (encode_config (?ss, ?rv)) =\n  Partial_Recursive.list_encode (map encode_frame ?ss)\n  eval r_leap [?t, ?i, ?x] \\<down>\n  prim_recfn 3 r_leap\n  e2rv ?e \\<equiv> pdec2 ?e\n  e2rv (encode_config (?ss, ?rv)) = encode_option ?rv\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    Suc v", "by simp"], ["", "lemma r_result_empty_stack_stays:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n  shows \"eval r_result [t + t', i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t + t', i, x] \\<down>= Suc v", "using assms step_leaves_empty_stack_empty r_result_empty_stack_Some"], ["proof (prove)\nusing this:\n  i = encode f\n  recfn (e_length x) f\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n  ([], Some ?v) \\<Longrightarrow>\n  iterate (?t + ?t') step\n   ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n  ([], Some ?v)\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n   ([], Some ?v)\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= Suc ?v\n\ngoal (1 subgoal):\n 1. eval r_result [t + t', i, x] \\<down>= Suc v", "by simp"], ["", "lemma r_result_nonempty_stack:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"fst (iterate t step ([(f, list_decode x, [])], None)) \\<noteq> []\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "obtain ss rv where \"iterate t step ([(f, list_decode x, [])], None) = (ss, rv)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ss rv.\n        iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n        (ss, rv) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "moreover"], ["proof (state)\nthis:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "from this assms(3)"], ["proof (chain)\npicking this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n  fst (iterate t step\n        ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n  []", "have \"ss \\<noteq> []\""], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n  fst (iterate t step\n        ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n  []\n\ngoal (1 subgoal):\n 1. ss \\<noteq> []", "by simp"], ["proof (state)\nthis:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "ultimately"], ["proof (chain)\npicking this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n  ss \\<noteq> []", "have \"eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)\""], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)", "using assms r_leap"], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  (ss, rv)\n  ss \\<noteq> []\n  i = encode f\n  recfn (e_length x) f\n  fst (iterate t step\n        ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n  []\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_leap [?t, ?i, ?x] \\<down>=\n                    encode_config\n                     (iterate ?t step\n                       ([(?f, Partial_Recursive.list_decode ?x, [])], None))\n\ngoal (1 subgoal):\n 1. eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)", "by simp"], ["proof (state)\nthis:\n  eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)", "have \"eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0", "using \\<open>ss \\<noteq> []\\<close> r_leap_prim encode_config r_leap_total list_encode_0"], ["proof (prove)\nusing this:\n  eval r_leap [t, i, x] \\<down>= encode_config (ss, rv)\n  ss \\<noteq> []\n  prim_recfn 3 r_leap\n  encode_config (?ss, ?rv) =\n  prod_encode\n   (Partial_Recursive.list_encode (map encode_frame ?ss), encode_option ?rv)\n  eval r_leap [?t, ?i, ?x] \\<down>\n  Partial_Recursive.list_encode ?xs = 0 \\<Longrightarrow> ?xs = []\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0", "by (auto, blast)"], ["proof (state)\nthis:\n  eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "unfolding r_result_def"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    0", "using r_leap_prim"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_pdec1 [r_leap]) [t, i, x] \\<down>\\<noteq> 0\n  prim_recfn 3 r_leap\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] \\<down>=\n    0", "by auto"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_Suc:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"iterate t step ([(f, list_decode x, [])], None) = ([], Some v)\"\n    (is \"?cfg = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "proof (cases \"fst ?cfg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. fst (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])], None)) =\n    [] \\<Longrightarrow>\n    iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)\n 2. \\<And>a list.\n       fst (iterate t step\n             ([(f, Partial_Recursive.list_decode x, [])], None)) =\n       a # list \\<Longrightarrow>\n       iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n       ([], Some v)", "case Nil"], ["proof (state)\nthis:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  []\n\ngoal (2 subgoals):\n 1. fst (iterate t step\n          ([(f, Partial_Recursive.list_decode x, [])], None)) =\n    [] \\<Longrightarrow>\n    iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)\n 2. \\<And>a list.\n       fst (iterate t step\n             ([(f, Partial_Recursive.list_decode x, [])], None)) =\n       a # list \\<Longrightarrow>\n       iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n       ([], Some v)", "then"], ["proof (chain)\npicking this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  []", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  []\n\ngoal (1 subgoal):\n 1. iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "using assms r_result_empty_stack_None r_result_empty_stack_Some"], ["proof (prove)\nusing this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  []\n  i = encode f\n  recfn (e_length x) f\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n   ([], None)\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= 0\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n   ([], Some ?v)\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= Suc ?v\n\ngoal (1 subgoal):\n 1. iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "by (metis Zero_not_Suc nat.inject option.collapse option.inject prod.exhaust_sel)"], ["proof (state)\nthis:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst (iterate t step\n             ([(f, Partial_Recursive.list_decode x, [])], None)) =\n       a # list \\<Longrightarrow>\n       iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n       ([], Some v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst (iterate t step\n             ([(f, Partial_Recursive.list_decode x, [])], None)) =\n       a # list \\<Longrightarrow>\n       iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n       ([], Some v)", "case Cons"], ["proof (state)\nthis:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       fst (iterate t step\n             ([(f, Partial_Recursive.list_decode x, [])], None)) =\n       a # list \\<Longrightarrow>\n       iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n       ([], Some v)", "then"], ["proof (chain)\npicking this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  a_ # list_", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  a_ # list_\n\ngoal (1 subgoal):\n 1. iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "using assms r_result_nonempty_stack"], ["proof (prove)\nusing this:\n  fst (iterate t step ([(f, Partial_Recursive.list_decode x, [])], None)) =\n  a_ # list_\n  i = encode f\n  recfn (e_length x) f\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   fst (iterate ?t step\n         ([(?f, Partial_Recursive.list_decode ?x, [])], None)) \\<noteq>\n   []\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n    ([], Some v)", "by simp"], ["proof (state)\nthis:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_converg:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval f (list_decode x) \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n    (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "let ?xs = \"list_decode x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "let ?stack = \"[(f, ?xs, [])]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have \"wellf f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wellf f", "using assms(2)"], ["proof (prove)\nusing this:\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. wellf f", "by simp"], ["proof (state)\nthis:\n  wellf f\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "moreover"], ["proof (state)\nthis:\n  wellf f\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have \"length ?xs = arity f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length x = arity f", "using assms(2)"], ["proof (prove)\nusing this:\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. e_length x = arity f", "by simp"], ["proof (state)\nthis:\n  e_length x = arity f\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "ultimately"], ["proof (chain)\npicking this:\n  wellf f\n  e_length x = arity f", "have \"correct (?stack, None)\""], ["proof (prove)\nusing this:\n  wellf f\n  e_length x = arity f\n\ngoal (1 subgoal):\n 1. correct ([(f, Partial_Recursive.list_decode x, [])], None)", "using step_correct valid_def"], ["proof (prove)\nusing this:\n  wellf f\n  e_length x = arity f\n  valid ((?f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((?f, ?xs, []) # ?rest, None)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. correct ([(f, Partial_Recursive.list_decode x, [])], None)", "by simp"], ["proof (state)\nthis:\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "with assms(3)"], ["proof (chain)\npicking this:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)", "have \"reachable (?stack, None) ([], Some v)\""], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. reachable ([(f, Partial_Recursive.list_decode x, [])], None)\n     ([], Some v)", "by simp"], ["proof (state)\nthis:\n  reachable ([(f, Partial_Recursive.list_decode x, [])], None) ([], Some v)\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  reachable ([(f, Partial_Recursive.list_decode x, [])], None) ([], Some v)", "obtain t where\n    \"iterate t step (?stack, None) = ([], Some v)\"\n    \"\\<forall>t'<t. fst (iterate t' step (?stack, None)) \\<noteq> []\""], ["proof (prove)\nusing this:\n  reachable ([(f, Partial_Recursive.list_decode x, [])], None) ([], Some v)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>iterate t step\n                  ([(f, Partial_Recursive.list_decode x, [])], None) =\n                 ([], Some v);\n         \\<forall>t'<t.\n            fst (iterate t' step\n                  ([(f, Partial_Recursive.list_decode x, [])],\n                   None)) \\<noteq>\n            []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using reachable_iterate_step_empty_stack"], ["proof (prove)\nusing this:\n  reachable ([(f, Partial_Recursive.list_decode x, [])], None) ([], Some v)\n  reachable ?cfg ([], ?rv) \\<Longrightarrow>\n  \\<exists>t.\n     iterate t step ?cfg = ([], ?rv) \\<and>\n     (\\<forall>t'<t. fst (iterate t' step ?cfg) \\<noteq> [])\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>iterate t step\n                  ([(f, Partial_Recursive.list_decode x, [])], None) =\n                 ([], Some v);\n         \\<forall>t'<t.\n            fst (iterate t' step\n                  ([(f, Partial_Recursive.list_decode x, [])],\n                   None)) \\<noteq>\n            []\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  \\<forall>t'<t.\n     fst (iterate t' step\n           ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n     []\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  \\<forall>t'<t.\n     fst (iterate t' step\n           ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n     []", "have t:\n    \"eval r_result [t, i, x] \\<down>= Suc v\"\n    \"\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  \\<forall>t'<t.\n     fst (iterate t' step\n           ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n     []\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v &&&\n    \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0", "using r_result_empty_stack_Some r_result_nonempty_stack assms(1,2)"], ["proof (prove)\nusing this:\n  iterate t step ([(f, Partial_Recursive.list_decode x, [])], None) =\n  ([], Some v)\n  \\<forall>t'<t.\n     fst (iterate t' step\n           ([(f, Partial_Recursive.list_decode x, [])], None)) \\<noteq>\n     []\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n   ([], Some ?v)\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= Suc ?v\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   fst (iterate ?t step\n         ([(?f, Partial_Recursive.list_decode ?x, [])], None)) \\<noteq>\n   []\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= 0\n  i = encode f\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v &&&\n    \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0", "by simp_all"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0", "have \"eval r_result [t + t', i, x] \\<down>= Suc v\" for t'"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result [t + t', i, x] \\<down>= Suc v", "using r_result_empty_stack_stays assms r_result_Suc"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   iterate ?t step ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n   ([], Some ?v)\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t + ?t', ?i, ?x] \\<down>= Suc ?v\n  i = encode f\n  recfn (e_length x) f\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   eval r_result [?t, ?i, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> iterate ?t step\n                     ([(?f, Partial_Recursive.list_decode ?x, [])], None) =\n                    ([], Some ?v)\n\ngoal (1 subgoal):\n 1. eval r_result [t + t', i, x] \\<down>= Suc v", "by simp"], ["proof (state)\nthis:\n  eval r_result [t + ?t'1, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  eval r_result [t + ?t'1, i, x] \\<down>= Suc v", "have \"\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  eval r_result [t + ?t'1, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v", "using le_Suc_ex"], ["proof (prove)\nusing this:\n  eval r_result [t + ?t'1, i, x] \\<down>= Suc v\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v", "by blast"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "with t(2)"], ["proof (chain)\npicking this:\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n     (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_diverg:\n  assumes \"i = encode f\"\n    and \"recfn (e_length x) f\"\n    and \"eval f (list_decode x) \\<up>\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "let ?xs = \"list_decode x\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "let ?stack = \"[(f, ?xs, [])]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "have \"recfn (length ?xs) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (e_length x) f", "using assms(2)"], ["proof (prove)\nusing this:\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. recfn (e_length x) f", "by auto"], ["proof (state)\nthis:\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  recfn (e_length x) f", "have \"correct (?stack, None)\""], ["proof (prove)\nusing this:\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. correct ([(f, Partial_Recursive.list_decode x, [])], None)", "using step_correct valid_def"], ["proof (prove)\nusing this:\n  recfn (e_length x) f\n  valid ((?f, ?xs, []) # ?rest) \\<Longrightarrow>\n  correct ((?f, ?xs, []) # ?rest, None)\n  valid ?stack \\<equiv>\n  \\<forall>s\\<in>set ?stack. recfn (length (fst (snd s))) (fst s)\n\ngoal (1 subgoal):\n 1. correct ([(f, Partial_Recursive.list_decode x, [])], None)", "by simp"], ["proof (state)\nthis:\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "with assms(3)"], ["proof (chain)\npicking this:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)", "have \"nonterminating (?stack, None)\""], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n  correct ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. nonterminating ([(f, Partial_Recursive.list_decode x, [])], None)", "by simp"], ["proof (state)\nthis:\n  nonterminating ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  nonterminating ([(f, Partial_Recursive.list_decode x, [])], None)", "show ?thesis"], ["proof (prove)\nusing this:\n  nonterminating ([(f, Partial_Recursive.list_decode x, [])], None)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "using r_result_nonempty_stack assms(1,2)"], ["proof (prove)\nusing this:\n  nonterminating ([(f, Partial_Recursive.list_decode x, [])], None)\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f;\n   fst (iterate ?t step\n         ([(?f, Partial_Recursive.list_decode ?x, [])], None)) \\<noteq>\n   []\\<rbrakk>\n  \\<Longrightarrow> eval r_result [?t, ?i, ?x] \\<down>= 0\n  i = encode f\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we can define the universal partial recursive function. This\nfunction executes @{term r_result} for increasing time bounds, waits for it\nto reach a final configuration, and then extracts its result value. If no\nfinal configuration is reached, the universal function diverges.\\<close>"], ["", "definition \"r_univ \\<equiv>\n  Cn 2 r_dec [Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), Id 2 0, Id 2 1]]\""], ["", "lemma r_univ_recfn [simp]: \"recfn 2 r_univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_univ", "unfolding r_univ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])", "by simp"], ["", "theorem r_univ:\n  assumes \"i = encode f\" and \"recfn (e_length x) f\"\n  shows \"eval r_univ [i, x] = eval f (list_decode x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "let ?cond = \"Cn 3 r_not [r_result]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "let ?while = \"Mn 2 ?cond\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "let ?res = \"Cn 2 r_result [?while, Id 2 0, Id 2 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "let ?xs = \"list_decode x\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "have *: \"eval ?cond [t, i, x] \\<down>= (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "have \"eval ?cond [t, i, x] = eval r_not [the (eval r_result [t, i, x])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] =\n    eval r_not [the (eval r_result [t, i, x])]", "using r_result_total"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] =\n    eval r_not [the (eval r_result [t, i, x])]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] =\n  eval r_not [the (eval r_result [t, i, x])]\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "moreover"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] =\n  eval r_not [the (eval r_result [t, i, x])]\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "have \"eval r_result [t, i, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>", "by (simp add: r_result_total)"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_not [r_result]) [t, i, x] =\n  eval r_not [the (eval r_result [t, i, x])]\n  eval r_result [t, i, x] \\<down>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_not [r_result]) [t, i, x] =\n  eval r_not [the (eval r_result [t, i, x])]\n  eval r_result [t, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n    (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)", "by auto"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>=\n  (if eval r_result [t, i, x] \\<down>= 0 then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [?t, i, x] \\<down>=\n  (if eval r_result [?t, i, x] \\<down>= 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "proof (cases \"eval f ?xs \\<up>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval f (Partial_Recursive.list_decode x) \\<up> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)\n 2. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "case True"], ["proof (state)\nthis:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n\ngoal (2 subgoals):\n 1. eval f (Partial_Recursive.list_decode x) \\<up> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)\n 2. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval f (Partial_Recursive.list_decode x) \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval f (Partial_Recursive.list_decode x)", "using * r_result_diverg[OF assms] eval_Mn_diverg"], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<up>\n  eval (Cn 3 r_not [r_result]) [?t, i, x] \\<down>=\n  (if eval r_result [?t, i, x] \\<down>= 0 then 1 else 0)\n  eval f (Partial_Recursive.list_decode x) \\<up> \\<Longrightarrow>\n  eval r_result [?t, i, x] \\<down>= 0\n  recfn (length ?xs) (Mn ?n ?f) \\<Longrightarrow>\n  (\\<nexists>z.\n      eval ?f (z # ?xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval ?f (y # ?xs) \\<down>)) =\n  (eval (Mn ?n ?f) ?xs \\<up>)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval f (Partial_Recursive.list_decode x)", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "case False"], ["proof (state)\nthis:\n  eval f (Partial_Recursive.list_decode x) \\<down>\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval f (Partial_Recursive.list_decode x) \\<down>", "obtain v where v: \"eval f ?xs \\<down>= v\""], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval f (Partial_Recursive.list_decode x) \\<down>=\n        v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v", "obtain t where t:\n      \"\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\"\n      \"\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v;\n         \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result_converg[OF assms]"], ["proof (prove)\nusing this:\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n  eval f (Partial_Recursive.list_decode x) \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v;\n         \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0", "have\n      \"\\<forall>t'\\<ge>t. eval ?cond [t', i, x] \\<down>= 0\"\n      \"\\<forall>t'<t. eval ?cond [t', i, x] \\<down>= 1\""], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0 &&&\n    \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1", "using *"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  \\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0\n  eval (Cn 3 r_not [r_result]) [?t, i, x] \\<down>=\n  (if eval r_result [?t, i, x] \\<down>= 0 then 1 else 0)\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t.\n       eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0 &&&\n    \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0\n  \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<ge>t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0\n  \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1", "have \"eval ?while [i, x] \\<down>= t\""], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0\n  \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t", "using eval_Mn_convergI[of 2 ?cond \"[i, x]\" t]"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 0\n  \\<forall>t'<t. eval (Cn 3 r_not [r_result]) [t', i, x] \\<down>= 1\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 (Cn 3 r_not [r_result]));\n   eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0;\n   \\<And>y.\n      y < t \\<Longrightarrow>\n      eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>\\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t", "by simp"], ["proof (state)\nthis:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t", "have \"eval ?res [i, x] = eval r_result [t, i, x]\""], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] =\n    eval r_result [t, i, x]", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [t, i, x]\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [t, i, x]", "have \"eval ?res [i, x] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [t, i, x]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>=\n    Suc v", "using t(1)"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [t, i, x]\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>=\n    Suc v", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. eval f (Partial_Recursive.list_decode x) \\<down> \\<Longrightarrow>\n    eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  Suc v", "show ?thesis"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval f (Partial_Recursive.list_decode x)", "using v"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  Suc v\n  eval f (Partial_Recursive.list_decode x) \\<down>= v\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval f (Partial_Recursive.list_decode x)", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval f (Partial_Recursive.list_decode x)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem r_univ':\n  assumes \"recfn (e_length x) f\"\n  shows \"eval r_univ [encode f, x] = eval f (list_decode x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [encode f, x] = eval f (Partial_Recursive.list_decode x)", "using r_univ assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_univ [?i, ?x] =\n                    eval ?f (Partial_Recursive.list_decode ?x)\n  recfn (e_length x) f\n\ngoal (1 subgoal):\n 1. eval r_univ [encode f, x] = eval f (Partial_Recursive.list_decode x)", "by simp"], ["", "text \\<open>Universal functions for every arity can be built from @{term \"r_univ\"}.\\<close>"], ["", "definition r_universal :: \"nat \\<Rightarrow> recf\" where\n  \"r_universal n \\<equiv> Cn (Suc n) r_univ [Id (Suc n) 0, r_shift (r_list_encode (n - 1))]\""], ["", "lemma r_universal_recfn [simp]: \"n > 0 \\<Longrightarrow> recfn (Suc n) (r_universal n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> recfn (Suc n) (r_universal n)", "unfolding r_universal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    recfn (Suc n)\n     (Cn (Suc n) r_univ\n       [recf.Id (Suc n) 0, r_shift (r_list_encode (n - 1))])", "by simp"], ["", "lemma r_universal:\n  assumes \"recfn n f\" and \"length xs = n\"\n  shows \"eval (r_universal n) (encode f # xs) = eval f xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal n) (encode f # xs) = eval f xs", "unfolding r_universal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) r_univ\n       [recf.Id (Suc n) 0, r_shift (r_list_encode (n - 1))])\n     (encode f # xs) =\n    eval f xs", "using wellf_arity_nonzero assms r_list_encode r_univ'"], ["proof (prove)\nusing this:\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n  recfn n f\n  length xs = n\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_list_encode ?n) ?xs \\<down>= Partial_Recursive.list_encode ?xs\n  recfn (e_length ?x) ?f \\<Longrightarrow>\n  eval r_univ [encode ?f, ?x] = eval ?f (Partial_Recursive.list_decode ?x)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc n) r_univ\n       [recf.Id (Suc n) 0, r_shift (r_list_encode (n - 1))])\n     (encode f # xs) =\n    eval f xs", "by fastforce"], ["", "text \\<open>We will mostly be concerned with computing unary functions. Hence\nwe introduce separate functions for this case.\\<close>"], ["", "definition \"r_result1 \\<equiv>\n  Cn 3 r_result [Id 3 0, Id 3 1, Cn 3 r_singleton_encode [Id 3 2]]\""], ["", "lemma r_result1_prim [simp]: \"prim_recfn 3 r_result1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_result1", "unfolding r_result1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_result\n       [recf.Id 3 0, recf.Id 3 1, Cn 3 r_singleton_encode [recf.Id 3 2]])", "by simp"], ["", "lemma r_result1_total: \"total r_result1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_result1", "using Mn_free_imp_total"], ["proof (prove)\nusing this:\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_result1", "by simp"], ["", "lemma r_result1 [simp]:\n  \"eval r_result1 [t, i, x] = eval r_result [t, i, singleton_encode x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] = eval r_result [t, i, singleton_encode x]", "unfolding r_result1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_result\n       [recf.Id 3 0, recf.Id 3 1, Cn 3 r_singleton_encode [recf.Id 3 2]])\n     [t, i, x] =\n    eval r_result [t, i, singleton_encode x]", "by simp"], ["", "text \\<open>The following function will be our standard G?del numbering\nof all unary partial recursive functions.\\<close>"], ["", "definition \"r_phi \\<equiv> r_universal 1\""], ["", "lemma r_phi_recfn [simp]: \"recfn 2 r_phi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_phi", "unfolding r_phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_universal 1)", "by simp"], ["", "theorem r_phi:\n  assumes \"i = encode f\" and \"recfn 1 f\"\n  shows \"eval r_phi [i, x] = eval f [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [i, x] = eval f [x]", "unfolding r_phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 1) [i, x] = eval f [x]", "using r_universal assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n  i = encode f\n  recfn 1 f\n\ngoal (1 subgoal):\n 1. eval (r_universal 1) [i, x] = eval f [x]", "by force"], ["", "corollary r_phi':\n  assumes \"recfn 1 f\"\n  shows \"eval r_phi [encode f, x] = eval f [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [encode f, x] = eval f [x]", "using assms r_phi"], ["proof (prove)\nusing this:\n  recfn 1 f\n  \\<lbrakk>?i = encode ?f; recfn 1 ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_phi [?i, ?x] = eval ?f [?x]\n\ngoal (1 subgoal):\n 1. eval r_phi [encode f, x] = eval f [x]", "by simp"], ["", "lemma r_phi'': \"eval r_phi [i, x] = eval r_univ [i, singleton_encode x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [i, x] = eval r_univ [i, singleton_encode x]", "unfolding r_universal_def r_phi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc 1) r_univ\n       [recf.Id (Suc 1) 0, r_shift (r_list_encode (1 - 1))])\n     [i, x] =\n    eval r_univ [i, singleton_encode x]", "using r_list_encode"], ["proof (prove)\nusing this:\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_list_encode ?n) ?xs \\<down>= Partial_Recursive.list_encode ?xs\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc 1) r_univ\n       [recf.Id (Suc 1) 0, r_shift (r_list_encode (1 - 1))])\n     [i, x] =\n    eval r_univ [i, singleton_encode x]", "by simp"], ["", "section \\<open>Applications of the universal function\\<close>"], ["", "text \\<open>In this section we shall see some ways @{term r_univ} and @{term r_result} can\nbe used.\\<close>"], ["", "subsection \\<open>Lazy conditional evaluation\\<close>"], ["", "text \\<open>With the help of @{term r_univ} we can now define a\n\\hypertarget{p:r_lifz}{lazy variant} of @{term r_ifz}, in which only one\nbranch is evaluated.\\<close>"], ["", "definition r_lazyifzero :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> recf\" where\n  \"r_lazyifzero n j\\<^sub>1 j\\<^sub>2 \\<equiv>\n     Cn (Suc (Suc n)) r_univ\n      [Cn (Suc (Suc n)) r_ifz [Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1, r_constn (Suc n) j\\<^sub>2],\n       r_shift (r_list_encode n)]\""], ["", "lemma r_lazyifzero_recfn: \"recfn (Suc (Suc n)) (r_lazyifzero n j\\<^sub>1 j\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (Suc (Suc n)) (r_lazyifzero n j\\<^sub>1 j\\<^sub>2)", "using r_lazyifzero_def"], ["proof (prove)\nusing this:\n  r_lazyifzero ?n ?j\\<^sub>1 ?j\\<^sub>2 \\<equiv>\n  Cn (Suc (Suc ?n)) r_univ\n   [Cn (Suc (Suc ?n)) r_ifz\n     [recf.Id (Suc (Suc ?n)) 0, r_constn (Suc ?n) ?j\\<^sub>1,\n      r_constn (Suc ?n) ?j\\<^sub>2],\n    r_shift (r_list_encode ?n)]\n\ngoal (1 subgoal):\n 1. recfn (Suc (Suc n)) (r_lazyifzero n j\\<^sub>1 j\\<^sub>2)", "by simp"], ["", "lemma r_lazyifzero:\n  assumes \"length xs = Suc n\"\n    and \"j\\<^sub>1 = encode f\\<^sub>1\"\n    and \"j\\<^sub>2 = encode f\\<^sub>2\"\n    and \"recfn (Suc n) f\\<^sub>1\"\n    and \"recfn (Suc n) f\\<^sub>2\"\n  shows \"eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) = (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "let ?a = \"r_constn (Suc n) n\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "let ?b = \"Cn (Suc (Suc n)) r_ifz\n    [Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1, r_constn (Suc n) j\\<^sub>2]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "let ?c = \"r_shift (r_list_encode n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "have \"eval ?a (c # xs) \\<down>= n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_constn (Suc n) n) (c # xs) \\<down>= n", "using assms(1)"], ["proof (prove)\nusing this:\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. eval (r_constn (Suc n) n) (c # xs) \\<down>= n", "by simp"], ["proof (state)\nthis:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "moreover"], ["proof (state)\nthis:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "have \"eval ?b (c # xs) \\<down>= (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc (Suc n)) r_ifz\n       [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n        r_constn (Suc n) j\\<^sub>2])\n     (c # xs) \\<down>=\n    (if c = 0 then j\\<^sub>1 else j\\<^sub>2)", "using assms(1)"], ["proof (prove)\nusing this:\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc (Suc n)) r_ifz\n       [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n        r_constn (Suc n) j\\<^sub>2])\n     (c # xs) \\<down>=\n    (if c = 0 then j\\<^sub>1 else j\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "moreover"], ["proof (state)\nthis:\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "have \"eval ?c (c # xs) \\<down>= list_encode xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n    Partial_Recursive.list_encode xs", "using assms(1) r_list_encode r_shift"], ["proof (prove)\nusing this:\n  length xs = Suc n\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_list_encode ?n) ?xs \\<down>= Partial_Recursive.list_encode ?xs\n  recfn (length ?xs) ?f \\<Longrightarrow>\n  eval (r_shift ?f) (?x # ?xs) = eval ?f ?xs\n\ngoal (1 subgoal):\n 1. eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n    Partial_Recursive.list_encode xs", "by simp"], ["proof (state)\nthis:\n  eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n  eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n  Partial_Recursive.list_encode xs", "have \"eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n      eval r_univ [if c = 0 then j\\<^sub>1 else j\\<^sub>2, list_encode xs]\""], ["proof (prove)\nusing this:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n  eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    eval r_univ\n     [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n      Partial_Recursive.list_encode xs]", "unfolding r_lazyifzero_def"], ["proof (prove)\nusing this:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n  eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n  Partial_Recursive.list_encode xs\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc (Suc n)) r_univ\n       [Cn (Suc (Suc n)) r_ifz\n         [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n          r_constn (Suc n) j\\<^sub>2],\n        r_shift (r_list_encode n)])\n     (c # xs) =\n    eval r_univ\n     [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n      Partial_Recursive.list_encode xs]", "using r_lazyifzero_recfn assms(1)"], ["proof (prove)\nusing this:\n  eval (r_constn (Suc n) n) (c # xs) \\<down>= n\n  eval\n   (Cn (Suc (Suc n)) r_ifz\n     [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n      r_constn (Suc n) j\\<^sub>2])\n   (c # xs) \\<down>=\n  (if c = 0 then j\\<^sub>1 else j\\<^sub>2)\n  eval (r_shift (r_list_encode n)) (c # xs) \\<down>=\n  Partial_Recursive.list_encode xs\n  recfn (Suc (Suc ?n)) (r_lazyifzero ?n ?j\\<^sub>1 ?j\\<^sub>2)\n  length xs = Suc n\n\ngoal (1 subgoal):\n 1. eval\n     (Cn (Suc (Suc n)) r_univ\n       [Cn (Suc (Suc n)) r_ifz\n         [recf.Id (Suc (Suc n)) 0, r_constn (Suc n) j\\<^sub>1,\n          r_constn (Suc n) j\\<^sub>2],\n        r_shift (r_list_encode n)])\n     (c # xs) =\n    eval r_univ\n     [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n      Partial_Recursive.list_encode xs]", "by simp"], ["proof (state)\nthis:\n  eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n  eval r_univ\n   [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n    Partial_Recursive.list_encode xs]\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "then"], ["proof (chain)\npicking this:\n  eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n  eval r_univ\n   [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n    Partial_Recursive.list_encode xs]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n  eval r_univ\n   [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n    Partial_Recursive.list_encode xs]\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "using assms r_univ"], ["proof (prove)\nusing this:\n  eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n  eval r_univ\n   [if c = 0 then j\\<^sub>1 else j\\<^sub>2,\n    Partial_Recursive.list_encode xs]\n  length xs = Suc n\n  j\\<^sub>1 = encode f\\<^sub>1\n  j\\<^sub>2 = encode f\\<^sub>2\n  recfn (Suc n) f\\<^sub>1\n  recfn (Suc n) f\\<^sub>2\n  \\<lbrakk>?i = encode ?f; recfn (e_length ?x) ?f\\<rbrakk>\n  \\<Longrightarrow> eval r_univ [?i, ?x] =\n                    eval ?f (Partial_Recursive.list_decode ?x)\n\ngoal (1 subgoal):\n 1. eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n    (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)", "by simp"], ["proof (state)\nthis:\n  eval (r_lazyifzero n j\\<^sub>1 j\\<^sub>2) (c # xs) =\n  (if c = 0 then eval f\\<^sub>1 xs else eval f\\<^sub>2 xs)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition r_lifz :: \"recf \\<Rightarrow> recf \\<Rightarrow> recf\" where\n  \"r_lifz f g \\<equiv> r_lazyifzero (arity f - 1) (encode f) (encode g)\""], ["", "lemma r_lifz_recfn [simp]:\n  assumes \"recfn n f\" and \"recfn n g\"\n  shows \"recfn (Suc n) (r_lifz f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (Suc n) (r_lifz f g)", "using assms r_lazyifzero_recfn r_lifz_def wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  recfn n f\n  recfn n g\n  recfn (Suc (Suc ?n)) (r_lazyifzero ?n ?j\\<^sub>1 ?j\\<^sub>2)\n  r_lifz ?f ?g \\<equiv> r_lazyifzero (arity ?f - 1) (encode ?f) (encode ?g)\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. recfn (Suc n) (r_lifz f g)", "by auto"], ["", "lemma r_lifz [simp]:\n  assumes \"length xs = n\" and \"recfn n f\" and \"recfn n g\"\n  shows \"eval (r_lifz f g) (c # xs) = (if c = 0 then eval f xs else eval g xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_lifz f g) (c # xs) = (if c = 0 then eval f xs else eval g xs)", "using assms r_lazyifzero r_lifz_def wellf_arity_nonzero"], ["proof (prove)\nusing this:\n  length xs = n\n  recfn n f\n  recfn n g\n  \\<lbrakk>length ?xs = Suc ?n; ?j\\<^sub>1 = encode ?f\\<^sub>1;\n   ?j\\<^sub>2 = encode ?f\\<^sub>2; recfn (Suc ?n) ?f\\<^sub>1;\n   recfn (Suc ?n) ?f\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> eval (r_lazyifzero ?n ?j\\<^sub>1 ?j\\<^sub>2)\n                     (?c # ?xs) =\n                    (if ?c = 0 then eval ?f\\<^sub>1 ?xs\n                     else eval ?f\\<^sub>2 ?xs)\n  r_lifz ?f ?g \\<equiv> r_lazyifzero (arity ?f - 1) (encode ?f) (encode ?g)\n  wellf ?f \\<Longrightarrow> 0 < arity ?f\n\ngoal (1 subgoal):\n 1. eval (r_lifz f g) (c # xs) = (if c = 0 then eval f xs else eval g xs)", "by (metis One_nat_def Suc_pred)"], ["", "subsection \\<open>Enumerating the domains of partial recursive functions\\<close>"], ["", "text \\<open>In this section we define a binary function $\\mathit{enumdom}$\nsuch that for all $i$, the domain of $\\varphi_i$ equals\n$\\{\\mathit{enumdom}(i, x) \\mid \\mathit{enumdom}(i, x)\\!\\downarrow\\}$. In\nother words, the image of $\\mathit{enumdom}_i$ is the domain of $\\varphi_i$.\n\nFirst we need some more properties of @{term r_leap} and @{term r_result}.\\<close>"], ["", "lemma r_leap_Suc: \"eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]", "have \"eval r_leap [Suc t, i, x] =\n      eval (Cn 4 r_step [Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]", "using r_leap_total eval_Pr_converg_Suc r_leap_def"], ["proof (prove)\nusing this:\n  eval r_leap [?t, ?i, ?x] \\<down>\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (Suc ?x # ?xs) =\n                    eval ?g (?x # the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs)\n  r_leap \\<equiv>\n  Pr 2\n   (Cn 2 r_prod_encode\n     [Cn 2 r_singleton_encode\n       [Cn 2 r_prod_encode\n         [recf.Id 2 0, Cn 2 r_prod_encode [recf.Id 2 1, r_constn 1 0]]],\n      r_constn 1 0])\n   (Cn 4 r_step [recf.Id 4 1])\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] =\n    eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]", "by (metis length_Cons list.size(3) numeral_2_eq_2 numeral_3_eq_3 r_leap_prim)"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]", "then"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]", "using r_step_prim"], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] =\n  eval (Cn 4 r_step [recf.Id 4 1]) [t, the (eval r_leap [t, i, x]), i, x]\n  prim_recfn 1 r_step\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]", "by auto"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] = eval r_step [the (eval r_leap [t, i, x])]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_leap_Suc_saturating:\n  assumes \"pdec1 (the (eval r_leap [t, i, x])) = 0\"\n  shows \"eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "let ?e = \"eval r_leap [t, i, x]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "have \"eval r_step [the ?e] \\<down>= estep (the ?e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    estep (the (eval r_leap [t, i, x]))", "using r_step"], ["proof (prove)\nusing this:\n  eval r_step [?e] \\<down>= estep ?e\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    estep (the (eval r_leap [t, i, x]))", "by simp"], ["proof (state)\nthis:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  estep (the (eval r_leap [t, i, x]))\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  estep (the (eval r_leap [t, i, x]))", "have \"eval r_step [the ?e] \\<down>= prod_encode (0, e2rv (the ?e))\""], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  estep (the (eval r_leap [t, i, x]))\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    prod_encode (0, e2rv (the (eval r_leap [t, i, x])))", "using estep_def assms"], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  estep (the (eval r_leap [t, i, x]))\n  estep ?e \\<equiv>\n  if e2stack ?e = 0 then prod_encode (0, e2rv ?e)\n  else if e2i ?e = 0 then prod_encode (e2tail ?e, 1)\n       else if e2i ?e = 1\n            then prod_encode (e2tail ?e, Suc (Suc (e_hd (e2xs ?e))))\n            else if encode_kind (e2i ?e) = 2\n                 then prod_encode\n                       (e2tail ?e, Suc (e_nth (e2xs ?e) (pdec22 (e2i ?e))))\n                 else if encode_kind (e2i ?e) = 3 then estep_Cn ?e\n                      else if encode_kind (e2i ?e) = 4 then estep_Pr ?e\n                           else if encode_kind (e2i ?e) = 5 then estep_Mn ?e\n                                else 0\n  pdec1 (the (eval r_leap [t, i, x])) = 0\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    prod_encode (0, e2rv (the (eval r_leap [t, i, x])))", "by (simp add: e2stack_def)"], ["proof (state)\nthis:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode (0, e2rv (the (eval r_leap [t, i, x])))\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode (0, e2rv (the (eval r_leap [t, i, x])))", "have \"eval r_step [the ?e] \\<down>= prod_encode (pdec1 (the ?e), pdec2 (the ?e))\""], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode (0, e2rv (the (eval r_leap [t, i, x])))\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    prod_encode\n     (pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])))", "using assms"], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode (0, e2rv (the (eval r_leap [t, i, x])))\n  pdec1 (the (eval r_leap [t, i, x])) = 0\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    prod_encode\n     (pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])))", "by (simp add: e2rv_def)"], ["proof (state)\nthis:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode\n   (pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])))\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode\n   (pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])))", "have \"eval r_step [the ?e] \\<down>= the ?e\""], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  prod_encode\n   (pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])))\n\ngoal (1 subgoal):\n 1. eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n    the (eval r_leap [t, i, x])", "by simp"], ["proof (state)\nthis:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  the (eval r_leap [t, i, x])\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "then"], ["proof (chain)\npicking this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  the (eval r_leap [t, i, x])", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  the (eval r_leap [t, i, x])\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "using r_leap_total r_leap_Suc"], ["proof (prove)\nusing this:\n  eval r_step [the (eval r_leap [t, i, x])] \\<down>=\n  the (eval r_leap [t, i, x])\n  eval r_leap [?t, ?i, ?x] \\<down>\n  eval r_leap [Suc ?t, ?i, ?x] =\n  eval r_step [the (eval r_leap [?t, ?i, ?x])]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_Suc_saturating:\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result [Suc t, i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "let ?r = \"\\<lambda>t. eval r_ifz [pdec1 (the (eval r_leap [t, i, x])), pdec2 (the (eval r_leap [t, i, x])), 0]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "have \"?r t \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n    Suc v", "using assms"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n    Suc v", "unfolding r_result_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 r_ifz [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n   [t, i, x] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n    Suc v", "using r_leap_total r_leap_prim"], ["proof (prove)\nusing this:\n  eval\n   (Cn 3 r_ifz [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n   [t, i, x] \\<down>=\n  Suc v\n  eval r_leap [?t, ?i, ?x] \\<down>\n  prim_recfn 3 r_leap\n\ngoal (1 subgoal):\n 1. eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n    Suc v", "by simp"], ["proof (state)\nthis:\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "then"], ["proof (chain)\npicking this:\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n  Suc v", "have \"pdec1 (the (eval r_leap [t, i, x])) = 0\""], ["proof (prove)\nusing this:\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n  Suc v\n\ngoal (1 subgoal):\n 1. pdec1 (the (eval r_leap [t, i, x])) = 0", "using option.sel"], ["proof (prove)\nusing this:\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0] \\<down>=\n  Suc v\n  the (Some ?x2.0) = ?x2.0\n\ngoal (1 subgoal):\n 1. pdec1 (the (eval r_leap [t, i, x])) = 0", "by fastforce"], ["proof (state)\nthis:\n  pdec1 (the (eval r_leap [t, i, x])) = 0\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "then"], ["proof (chain)\npicking this:\n  pdec1 (the (eval r_leap [t, i, x])) = 0", "have \"eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\""], ["proof (prove)\nusing this:\n  pdec1 (the (eval r_leap [t, i, x])) = 0\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "using r_leap_Suc_saturating"], ["proof (prove)\nusing this:\n  pdec1 (the (eval r_leap [t, i, x])) = 0\n  pdec1 (the (eval r_leap [?t, ?i, ?x])) = 0 \\<Longrightarrow>\n  eval r_leap [Suc ?t, ?i, ?x] = eval r_leap [?t, ?i, ?x]\n\ngoal (1 subgoal):\n 1. eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "moreover"], ["proof (state)\nthis:\n  eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "have \"eval r_result [t, i, x] = ?r t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0]", "unfolding r_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0]", "using r_leap_total r_leap_prim"], ["proof (prove)\nusing this:\n  eval r_leap [?t, ?i, ?x] \\<down>\n  prim_recfn 3 r_leap\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [t, i, x])),\n      pdec2 (the (eval r_leap [t, i, x])), 0]", "by simp"], ["proof (state)\nthis:\n  eval r_result [t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "moreover"], ["proof (state)\nthis:\n  eval r_result [t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "have \"eval r_result [Suc t, i, x] = ?r (Suc t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [Suc t, i, x])),\n      pdec2 (the (eval r_leap [Suc t, i, x])), 0]", "unfolding r_result_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [Suc t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [Suc t, i, x])),\n      pdec2 (the (eval r_leap [Suc t, i, x])), 0]", "using r_leap_total r_leap_prim"], ["proof (prove)\nusing this:\n  eval r_leap [?t, ?i, ?x] \\<down>\n  prim_recfn 3 r_leap\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 3 r_ifz\n       [Cn 3 r_pdec1 [r_leap], Cn 3 r_pdec2 [r_leap], r_constn 2 0])\n     [Suc t, i, x] =\n    eval r_ifz\n     [pdec1 (the (eval r_leap [Suc t, i, x])),\n      pdec2 (the (eval r_leap [Suc t, i, x])), 0]", "by simp"], ["proof (state)\nthis:\n  eval r_result [Suc t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [Suc t, i, x])),\n    pdec2 (the (eval r_leap [Suc t, i, x])), 0]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "ultimately"], ["proof (chain)\npicking this:\n  eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\n  eval r_result [t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0]\n  eval r_result [Suc t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [Suc t, i, x])),\n    pdec2 (the (eval r_leap [Suc t, i, x])), 0]", "have \"eval r_result [Suc t, i, x] = eval r_result [t, i, x]\""], ["proof (prove)\nusing this:\n  eval r_leap [Suc t, i, x] = eval r_leap [t, i, x]\n  eval r_result [t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [t, i, x])),\n    pdec2 (the (eval r_leap [t, i, x])), 0]\n  eval r_result [Suc t, i, x] =\n  eval r_ifz\n   [pdec1 (the (eval r_leap [Suc t, i, x])),\n    pdec2 (the (eval r_leap [Suc t, i, x])), 0]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] = eval r_result [t, i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_result [Suc t, i, x] = eval r_result [t, i, x]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "with assms"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  eval r_result [Suc t, i, x] = eval r_result [t, i, x]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  eval r_result [Suc t, i, x] = eval r_result [t, i, x]\n\ngoal (1 subgoal):\n 1. eval r_result [Suc t, i, x] \\<down>= Suc v", "by simp"], ["proof (state)\nthis:\n  eval r_result [Suc t, i, x] \\<down>= Suc v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_saturating:\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result [t + d, i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t + d, i, x] \\<down>= Suc v", "using r_result_Suc_saturating assms"], ["proof (prove)\nusing this:\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_result [Suc ?t, ?i, ?x] \\<down>= Suc ?v\n  eval r_result [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_result [t + d, i, x] \\<down>= Suc v", "by (induction d) simp_all"], ["", "lemma r_result_converg':\n  assumes \"eval r_univ [i, x] \\<down>= v\"\n  shows \"\\<exists>t. (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and> (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "let ?f = \"Cn 3 r_not [r_result]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "let ?m = \"Mn 2 ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have \"recfn 2 ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Mn 2 (Cn 3 r_not [r_result]))", "by simp"], ["proof (state)\nthis:\n  recfn 2 (Mn 2 (Cn 3 r_not [r_result]))\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have eval_m: \"eval ?m [i, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up> \\<Longrightarrow> False", "assume \"eval ?m [i, x] \\<up>\""], ["proof (state)\nthis:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up>", "have \"eval r_univ [i, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<up>", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<up> \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<down>= v\n  eval r_univ [i, x] \\<up>", "show False"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>= v\n  eval r_univ [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>", "obtain t where t: \"eval ?m [i, x] \\<down>= t\""], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>=\n        t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t", "have f_t: \"eval ?f [t, i, x] \\<down>= 0\" and f_less_t: \"\\<And>y. y < t \\<Longrightarrow> eval ?f [y, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0 &&&\n    (\\<And>y.\n        y < t \\<Longrightarrow>\n        eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>\\<noteq> 0)", "using eval_Mn_convergE[of 2 ?f \"[i, x]\" t] \\<open>recfn 2 ?m\\<close>"], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 (Cn 3 r_not [r_result]));\n   eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\\<rbrakk>\n  \\<Longrightarrow> t =\n                    (LEAST z.\n                        eval (Cn 3 r_not [r_result]) [z, i, x] \\<down>=\n                        0 \\<and>\n                        (\\<forall>y<z.\n                            eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>))\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 (Cn 3 r_not [r_result]));\n   eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\\<rbrakk>\n  \\<Longrightarrow> eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n  \\<lbrakk>recfn (length [i, x]) (Mn 2 (Cn 3 r_not [r_result]));\n   eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t; ?y < t\\<rbrakk>\n  \\<Longrightarrow> eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\\<noteq>\n                    0\n  recfn 2 (Mn 2 (Cn 3 r_not [r_result]))\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0 &&&\n    (\\<And>y.\n        y < t \\<Longrightarrow>\n        eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>\\<noteq> 0)", "by (metis (no_types, lifting) One_nat_def Suc_1 length_Cons list.size(3))+"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n  ?y < t \\<Longrightarrow>\n  eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have eval_Cn2: \"eval (Cn 2 r_result [?m, Id 2 0, Id 2 1]) [i, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<up> \\<Longrightarrow>\n    False", "assume \"eval (Cn 2 r_result [?m, Id 2 0, Id 2 1]) [i, x] \\<up>\""], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<up> \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<up>", "have \"eval r_univ [i, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<up>", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<up> \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<down>= v\n  eval r_univ [i, x] \\<up>", "show False"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>= v\n  eval r_univ [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have \"eval r_result [t, i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some (Suc v) \\<Longrightarrow> False", "assume neq_Suc: \"\\<not> eval r_result [t, i, x] \\<down>= Suc v\""], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<noteq> Some (Suc v)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some (Suc v) \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"eval r_result [t, i, x] = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval r_result [t, i, x] \\<up> \\<Longrightarrow> False\n 2. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<up>\n\ngoal (2 subgoals):\n 1. eval r_result [t, i, x] \\<up> \\<Longrightarrow> False\n 2. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<up>\n\ngoal (1 subgoal):\n 1. False", "using f_t"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<up>\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>", "obtain w where w: \"eval r_result [t, i, x] \\<down>= w\" \"w \\<noteq> Suc v\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>eval r_result [t, i, x] \\<down>= w;\n         w \\<noteq> Suc v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using neq_Suc"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>\n  eval r_result [t, i, x] \\<noteq> Some (Suc v)\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>eval r_result [t, i, x] \\<down>= w;\n         w \\<noteq> Suc v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "have \"eval r_result [t, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>\\<noteq> 0", "by (rule ccontr; use f_t in auto)"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval r_result [t, i, x] \\<down>\\<noteq> 0", "have \"w \\<noteq> 0\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. w \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  w \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "have \"eval (Cn 2 r_result [?m, Id 2 0, Id 2 1]) [i, x] =\n          eval r_result [the (eval ?m [i, x]), i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] =\n    eval r_result [the (eval (Mn 2 (Cn 3 r_not [r_result])) [i, x]), i, x]", "using eval_m"], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] =\n    eval r_result [the (eval (Mn 2 (Cn 3 r_not [r_result])) [i, x]), i, x]", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [the (eval (Mn 2 (Cn 3 r_not [r_result])) [i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "with w t"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [the (eval (Mn 2 (Cn 3 r_not [r_result])) [i, x]), i, x]", "have \"eval (Cn 2 r_result [?m, Id 2 0, Id 2 1]) [i, x] \\<down>= w\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>= t\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] =\n  eval r_result [the (eval (Mn 2 (Cn 3 r_not [r_result])) [i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_result\n       [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>=\n    w", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  w\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  w\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "have \"eval r_univ [i, x] =\n          eval r_dec [the (eval (Cn 2 r_result [?m, Id 2 0, Id 2 1]) [i, x])]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] =\n    eval r_dec\n     [the (eval\n            (Cn 2 r_result\n              [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n            [i, x])]", "unfolding r_univ_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval r_dec\n     [the (eval\n            (Cn 2 r_result\n              [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n            [i, x])]", "using eval_Cn2"], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] =\n    eval r_dec\n     [the (eval\n            (Cn 2 r_result\n              [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n            [i, x])]", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] =\n  eval r_dec\n   [the (eval\n          (Cn 2 r_result\n            [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n          [i, x])]\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  w\n  eval r_univ [i, x] =\n  eval r_dec\n   [the (eval\n          (Cn 2 r_result\n            [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n          [i, x])]", "have \"eval r_univ [i, x] = eval r_dec [w]\""], ["proof (prove)\nusing this:\n  eval\n   (Cn 2 r_result [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n   [i, x] \\<down>=\n  w\n  eval r_univ [i, x] =\n  eval r_dec\n   [the (eval\n          (Cn 2 r_result\n            [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1])\n          [i, x])]\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] = eval r_dec [w]", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] = eval r_dec [w]\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] = eval r_dec [w]", "have \"eval r_univ [i, x] \\<down>= w - 1\""], ["proof (prove)\nusing this:\n  eval r_univ [i, x] = eval r_dec [w]\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down>= w - 1", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<down>= w - 1\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down> \\<Longrightarrow> False", "with assms \\<open>w \\<noteq> 0\\<close> w"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<down>= v\n  w \\<noteq> 0\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval r_univ [i, x] \\<down>= w - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>= v\n  w \\<noteq> 0\n  eval r_result [t, i, x] \\<down>= w\n  w \\<noteq> Suc v\n  eval r_univ [i, x] \\<down>= w - 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= Suc v", "have \"\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v", "using r_result_saturating le_Suc_ex"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc v\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_result [?t + ?d, ?i, ?x] \\<down>= Suc ?v\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v", "by blast"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "moreover"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "have \"eval r_result [y, i, x] \\<down>= 0\" if \"y < t\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [y, i, x] \\<down>= 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [y, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "assume neq0: \"eval r_result [y, i, x] \\<noteq> Some 0\""], ["proof (state)\nthis:\n  eval r_result [y, i, x] \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. eval r_result [y, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [y, i, x] \\<noteq> Some 0", "show False"], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. False", "proof (cases \"eval r_result [y, i, x] = None\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<up>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  eval r_result [y, i, x] \\<up>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<up>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [y, i, x] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<up>\n\ngoal (1 subgoal):\n 1. False", "using f_less_t \\<open>y < t\\<close>"], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<up>\n  ?y < t \\<Longrightarrow>\n  eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\\<noteq> 0\n  y < t\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  eval r_result [y, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [y, i, x] \\<down>", "obtain v where \"eval r_result [y, i, x] \\<down>= v\" \"v \\<noteq> 0\""], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>eval r_result [y, i, x] \\<down>= v; v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using neq0"], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<down>\n  eval r_result [y, i, x] \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>eval r_result [y, i, x] \\<down>= v; v \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_result [y, i, x] \\<down>= v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [y, i, x] \\<down>= v\n  v \\<noteq> 0", "have \"eval ?f [y, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval r_result [y, i, x] \\<down>= v\n  v \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result [y, i, x] \\<noteq> Some 0;\n     eval r_result [y, i, x] \\<down>\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. False", "using f_less_t \\<open>y < t\\<close>"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>= 0\n  ?y < t \\<Longrightarrow>\n  eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\\<noteq> 0\n  y < t\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y < t \\<Longrightarrow> eval r_result [?y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  ?y < t \\<Longrightarrow> eval r_result [?y, i, x] \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v\n  ?y < t \\<Longrightarrow> eval r_result [?y, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)", "by auto"], ["proof (state)\nthis:\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n     (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_diverg':\n  assumes \"eval r_univ [i, x] \\<up>\"\n  shows \"eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "let ?f = \"Cn 3 r_not [r_result]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "let ?m = \"Mn 2 ?f\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "assume \"eval r_result [t, i, x] \\<noteq> Some 0\""], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "with r_result_total"], ["proof (chain)\npicking this:\n  Partial_Recursive.total r_result\n  eval r_result [t, i, x] \\<noteq> Some 0", "have \"eval r_result [t, i, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_result\n  eval r_result [t, i, x] \\<noteq> Some 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>\\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0", "have \"eval ?f [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>\\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0", "by auto"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "have \"eval ?f [y, i, x] \\<down>\" if \"y < t\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>", "using  r_result_total"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>", "by simp"], ["proof (state)\nthis:\n  ?y < t \\<Longrightarrow> eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n  ?y < t \\<Longrightarrow> eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>", "have \"\\<exists>z. eval ?f (z # [i, x]) \\<down>= 0 \\<and> (\\<forall>y<z. eval ?f (y # [i, x]) \\<down>)\""], ["proof (prove)\nusing this:\n  eval (Cn 3 r_not [r_result]) [t, i, x] \\<down>= 0\n  ?y < t \\<Longrightarrow> eval (Cn 3 r_not [r_result]) [?y, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>z.\n       eval (Cn 3 r_not [r_result]) [z, i, x] \\<down>= 0 \\<and>\n       (\\<forall>y<z. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>z.\n     eval (Cn 3 r_not [r_result]) [z, i, x] \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>z.\n     eval (Cn 3 r_not [r_result]) [z, i, x] \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>)", "have \"eval ?m [i, x] \\<down>\""], ["proof (prove)\nusing this:\n  \\<exists>z.\n     eval (Cn 3 r_not [r_result]) [z, i, x] \\<down>= 0 \\<and>\n     (\\<forall>y<z. eval (Cn 3 r_not [r_result]) [y, i, x] \\<down>)\n\ngoal (1 subgoal):\n 1. eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>", "have \"eval r_univ [i, x] \\<down>\""], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down>", "unfolding r_univ_def"], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] \\<down>", "using r_result_total"], ["proof (prove)\nusing this:\n  eval (Mn 2 (Cn 3 r_not [r_result])) [i, x] \\<down>\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_dec\n       [Cn 2 r_result\n         [Mn 2 (Cn 3 r_not [r_result]), recf.Id 2 0, recf.Id 2 1]])\n     [i, x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<noteq> Some 0 \\<Longrightarrow> False", "with assms"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<up>\n  eval r_univ [i, x] \\<down>", "show False"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<up>\n  eval r_univ [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result_bivalent':\n  assumes \"eval r_univ [i, x] \\<down>= v\"\n  shows \"eval r_result [t, i, x] \\<down>= Suc v \\<or> eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result [t, i, x] \\<down>= 0", "using r_result_converg'[OF assms] not_less"], ["proof (prove)\nusing this:\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result [t', i, x] \\<down>= Suc v) \\<and>\n     (\\<forall>t'<t. eval r_result [t', i, x] \\<down>= 0)\n  (\\<not> ?x < ?y) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result [t, i, x] \\<down>= 0", "by blast"], ["", "lemma r_result_Some':\n  assumes \"eval r_result [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_univ [i, x] \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down>= v", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<noteq> Some v \\<Longrightarrow> False", "assume not_v: \"\\<not> eval r_univ [i, x] \\<down>= v\""], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<noteq> Some v \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"eval r_univ [i, x] \\<up>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval r_univ [i, x] \\<up> \\<Longrightarrow> False\n 2. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<up>\n\ngoal (2 subgoals):\n 1. eval r_univ [i, x] \\<up> \\<Longrightarrow> False\n 2. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<up>\n\ngoal (1 subgoal):\n 1. False", "using assms r_result_diverg'"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<up>\n  eval r_result [t, i, x] \\<down>= Suc v\n  eval r_univ [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<down>", "obtain w where w: \"eval r_univ [i, x] \\<down>= w\" \"w \\<noteq> v\""], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>eval r_univ [i, x] \\<down>= w; w \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using not_v"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>\n  eval r_univ [i, x] \\<noteq> Some v\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        \\<lbrakk>eval r_univ [i, x] \\<down>= w; w \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_univ [i, x] \\<down>= w\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_univ [i, x] \\<down>= w\n  w \\<noteq> v", "have \"eval r_result [t, i, x] \\<down>= Suc w \\<or> eval r_result [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>= w\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc w \\<or>\n    eval r_result [t, i, x] \\<down>= 0", "using r_result_bivalent'"], ["proof (prove)\nusing this:\n  eval r_univ [i, x] \\<down>= w\n  w \\<noteq> v\n  eval r_univ [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<or>\n  eval r_result [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result [t, i, x] \\<down>= Suc w \\<or>\n    eval r_result [t, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval r_result [t, i, x] \\<down>= Suc w \\<or>\n  eval r_result [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_univ [i, x] \\<down> \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  eval r_result [t, i, x] \\<down>= Suc w \\<or>\n  eval r_result [t, i, x] \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc w \\<or>\n  eval r_result [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. False", "using assms not_v w"], ["proof (prove)\nusing this:\n  eval r_result [t, i, x] \\<down>= Suc w \\<or>\n  eval r_result [t, i, x] \\<down>= 0\n  eval r_result [t, i, x] \\<down>= Suc v\n  eval r_univ [i, x] \\<noteq> Some v\n  eval r_univ [i, x] \\<down>= w\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_result1_converg':\n  assumes \"eval r_phi [i, x] \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n    (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)", "using assms r_result1 r_result_converg' r_phi''"], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<down>= v\n  eval r_result1 [?t, ?i, ?x] = eval r_result [?t, ?i, singleton_encode ?x]\n  eval r_univ [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [?i, ?x] = eval r_univ [?i, singleton_encode ?x]\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)", "by simp"], ["", "lemma r_result1_diverg':\n  assumes \"eval r_phi [i, x] \\<up>\"\n  shows \"eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0", "using assms r_result1 r_result_diverg' r_phi''"], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<up>\n  eval r_result1 [?t, ?i, ?x] = eval r_result [?t, ?i, singleton_encode ?x]\n  eval r_univ [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result [?t, ?i, ?x] \\<down>= 0\n  eval r_phi [?i, ?x] = eval r_univ [?i, singleton_encode ?x]\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0", "by simp"], ["", "lemma r_result1_Some':\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_phi [i, x] \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>= v", "using assms r_result1 r_result_Some' r_phi''"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [?t, ?i, ?x] = eval r_result [?t, ?i, singleton_encode ?x]\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_univ [?i, ?x] \\<down>= ?v\n  eval r_phi [?i, ?x] = eval r_univ [?i, singleton_encode ?x]\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>= v", "by simp"], ["", "text \\<open>The next function performs dovetailing in order to evaluate\n$\\varphi_i$ for every argument for arbitrarily many steps. Given $i$ and $z$,\nthe function decodes $z$ into a pair $(x, t$) and outputs zero (meaning\n``true'') iff.\\ the computation of $\\varphi_i$ on input $x$ halts after at most\n$t$ steps. Fixing $i$ and varying $z$ will eventually compute $\\varphi_i$\nfor every argument in the domain of $\\varphi_i$ sufficiently long for it to\nconverge.\\<close>"], ["", "definition \"r_dovetail \\<equiv>\n  Cn 2 r_not [Cn 2 r_result1 [Cn 2 r_pdec2 [Id 2 1], Id 2 0, Cn 2 r_pdec1 [Id 2 1]]]\""], ["", "lemma r_dovetail_prim: \"prim_recfn 2 r_dovetail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 2 r_dovetail", "by (simp add: r_dovetail_def)"], ["", "lemma r_dovetail:\n  \"eval r_dovetail [i, z] \\<down>=\n    (if the (eval r_result1 [pdec2 z, i, pdec1 z]) > 0 then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dovetail [i, z] \\<down>=\n    (if 0 < the (eval r_result1 [pdec2 z, i, pdec1 z]) then 0 else 1)", "unfolding r_dovetail_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_not\n       [Cn 2 r_result1\n         [Cn 2 r_pdec2 [recf.Id 2 1], recf.Id 2 0,\n          Cn 2 r_pdec1 [recf.Id 2 1]]])\n     [i, z] \\<down>=\n    (if 0 < the (eval r_result1 [pdec2 z, i, pdec1 z]) then 0 else 1)", "using r_result_total"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_not\n       [Cn 2 r_result1\n         [Cn 2 r_pdec2 [recf.Id 2 1], recf.Id 2 0,\n          Cn 2 r_pdec1 [recf.Id 2 1]]])\n     [i, z] \\<down>=\n    (if 0 < the (eval r_result1 [pdec2 z, i, pdec1 z]) then 0 else 1)", "by simp"], ["", "text \\<open>The function $\\mathit{enumdom}$ works as follows in order to\nenumerate exactly the domain of $\\varphi_i$. Given $i$ and $y$ it searches\nfor the minimum $z \\geq y$ for which the dovetail function returns true. This\n$z$ is decoded into $(x, t)$ and the $x$ is output. In this way every value\noutput by $\\mathit{enumdom}$ is in the domain of $\\varphi_i$ by construction\nof @{term r_dovetail}. Conversely an $x$ in the domain will be output for $y\n= (x, t)$ where $t$ is such that $\\varphi_i$ halts on $x$ within $t$\nsteps.\\<close>"], ["", "definition \"r_dovedelay \\<equiv>\n  Cn 3 r_and\n    [Cn 3 r_dovetail [Id 3 1, Id 3 0],\n     Cn 3 r_ifle [Id 3 2, Id 3 0, r_constn 2 0, r_constn 2 1]]\""], ["", "lemma r_dovedelay_prim: \"prim_recfn 3 r_dovedelay\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_dovedelay", "unfolding r_dovedelay_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_and\n       [Cn 3 r_dovetail [recf.Id 3 1, recf.Id 3 0],\n        Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_constn 2 0, r_constn 2 1]])", "using r_dovetail_prim"], ["proof (prove)\nusing this:\n  prim_recfn 2 r_dovetail\n\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Cn 3 r_and\n       [Cn 3 r_dovetail [recf.Id 3 1, recf.Id 3 0],\n        Cn 3 r_ifle [recf.Id 3 2, recf.Id 3 0, r_constn 2 0, r_constn 2 1]])", "by simp"], ["", "lemma r_dovedelay:\n  \"eval r_dovedelay [z, i, y] \\<down>=\n    (if the (eval r_result1 [pdec2 z, i, pdec1 z]) > 0 \\<and> y \\<le> z then 0 else 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dovedelay [z, i, y] \\<down>=\n    (if 0 < the (eval r_result1 [pdec2 z, i, pdec1 z]) \\<and> y \\<le> z\n     then 0 else 1)", "by (simp add: r_dovedelay_def r_dovetail r_dovetail_prim)"], ["", "definition \"r_enumdom \\<equiv> Cn 2 r_pdec1 [Mn 2 r_dovedelay]\""], ["", "lemma r_enumdom_recfn [simp]: \"recfn 2 r_enumdom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_enumdom", "by (simp add: r_enumdom_def r_dovedelay_prim)"], ["", "lemma r_enumdom [simp]:\n  \"eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "let ?h = \"Mn 2 r_dovedelay\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "have \"total r_dovedelay\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_dovedelay", "using r_dovedelay_prim"], ["proof (prove)\nusing this:\n  prim_recfn 3 r_dovedelay\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_dovedelay", "by blast"], ["proof (state)\nthis:\n  Partial_Recursive.total r_dovedelay\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "then"], ["proof (chain)\npicking this:\n  Partial_Recursive.total r_dovedelay", "have \"eval ?h [i, y] =\n    (if (\\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0)\n     then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)\n     else None)\""], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_dovedelay\n\ngoal (1 subgoal):\n 1. eval (Mn 2 r_dovedelay) [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)", "using r_dovedelay_prim r_enumdom_recfn eval_Mn_convergI"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_dovedelay\n  prim_recfn 3 r_dovedelay\n  recfn 2 r_enumdom\n  \\<lbrakk>recfn (length ?xs) (Mn ?n ?f); eval ?f (?z # ?xs) \\<down>= 0;\n   \\<And>y.\n      y < ?z \\<Longrightarrow> eval ?f (y # ?xs) \\<down>\\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> eval (Mn ?n ?f) ?xs \\<down>= ?z\n\ngoal (1 subgoal):\n 1. eval (Mn 2 r_dovedelay) [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)", "by simp"], ["proof (state)\nthis:\n  eval (Mn 2 r_dovedelay) [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "then"], ["proof (chain)\npicking this:\n  eval (Mn 2 r_dovedelay) [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (Mn 2 r_dovedelay) [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "unfolding r_enumdom_def"], ["proof (prove)\nusing this:\n  eval (Mn 2 r_dovedelay) [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_pdec1 [Mn 2 r_dovedelay]) [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "using r_dovedelay_prim"], ["proof (prove)\nusing this:\n  eval (Mn 2 r_dovedelay) [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0) else None)\n  prim_recfn 3 r_dovedelay\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_pdec1 [Mn 2 r_dovedelay]) [i, y] =\n    (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n     then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n     else None)", "by simp"], ["proof (state)\nthis:\n  eval r_enumdom [i, y] =\n  (if \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n   then Some (pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0))\n   else None)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>If @{term i} is the code of the empty function, @{term r_enumdom}\nhas an empty domain, too.\\<close>"], ["", "lemma r_enumdom_empty_domain:\n  assumes \"\\<And>x. eval r_phi [i, x] \\<up>\"\n  shows \"\\<And>y. eval r_enumdom [i, y] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. eval r_enumdom [i, y] \\<up>", "using assms r_result1_diverg' r_dovedelay"], ["proof (prove)\nusing this:\n  eval r_phi [i, ?x] \\<up>\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n\ngoal (1 subgoal):\n 1. \\<And>y. eval r_enumdom [i, y] \\<up>", "by simp"], ["", "text \\<open>If @{term i} is the code of a function with non-empty domain,\n@{term r_enumdom} enumerates its domain.\\<close>"], ["", "lemma r_enumdom_nonempty_domain:\n  assumes \"eval r_phi [i, x\\<^sub>0] \\<down>\"\n  shows \"\\<And>y. eval r_enumdom [i, y] \\<down>\"\n    and \"\\<And>x. eval r_phi [i, x] \\<down> \\<longleftrightarrow> (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>y. eval r_enumdom [i, y] \\<down>) &&&\n    (\\<And>x.\n        (eval r_phi [i, x] \\<down>) =\n        (\\<exists>y. eval r_enumdom [i, y] \\<down>= x))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>y. eval r_enumdom [i, y] \\<down>\n 2. \\<And>x.\n       (eval r_phi [i, x] \\<down>) =\n       (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)", "show \"eval r_enumdom [i, y] \\<down>\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "obtain t where t: \"\\<forall>t'\\<ge>t. the (eval r_result1 [t', i, x\\<^sub>0]) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<forall>t'\\<ge>t.\n           0 < the (eval r_result1 [t', i, x\\<^sub>0]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms r_result1_converg'"], ["proof (prove)\nusing this:\n  eval r_phi [i, x\\<^sub>0] \\<down>\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<forall>t'\\<ge>t.\n           0 < the (eval r_result1 [t', i, x\\<^sub>0]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>t'\\<ge>t. 0 < the (eval r_result1 [t', i, x\\<^sub>0])\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "let ?z = \"prod_encode (x\\<^sub>0, max t y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "have \"y \\<le> ?z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> prod_encode (x\\<^sub>0, max t y)", "using le_prod_encode_2 max.bounded_iff"], ["proof (prove)\nusing this:\n  ?b \\<le> prod_encode (?a, ?b)\n  (max ?b ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n\ngoal (1 subgoal):\n 1. y \\<le> prod_encode (x\\<^sub>0, max t y)", "by blast"], ["proof (state)\nthis:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "moreover"], ["proof (state)\nthis:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "have \"pdec2 ?z \\<ge> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> pdec2 (prod_encode (x\\<^sub>0, max t y))", "by simp"], ["proof (state)\nthis:\n  t \\<le> pdec2 (prod_encode (x\\<^sub>0, max t y))\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "ultimately"], ["proof (chain)\npicking this:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n  t \\<le> pdec2 (prod_encode (x\\<^sub>0, max t y))", "have \"the (eval r_result1 [pdec2 ?z, i, pdec1 ?z]) > 0\""], ["proof (prove)\nusing this:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n  t \\<le> pdec2 (prod_encode (x\\<^sub>0, max t y))\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [pdec2 (prod_encode (x\\<^sub>0, max t y)), i,\n               pdec1 (prod_encode (x\\<^sub>0, max t y))])", "using t"], ["proof (prove)\nusing this:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n  t \\<le> pdec2 (prod_encode (x\\<^sub>0, max t y))\n  \\<forall>t'\\<ge>t. 0 < the (eval r_result1 [t', i, x\\<^sub>0])\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [pdec2 (prod_encode (x\\<^sub>0, max t y)), i,\n               pdec1 (prod_encode (x\\<^sub>0, max t y))])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [pdec2 (prod_encode (x\\<^sub>0, max t y)), i,\n             pdec1 (prod_encode (x\\<^sub>0, max t y))])\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "with \\<open>y \\<le> ?z\\<close> r_dovedelay"], ["proof (chain)\npicking this:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n  0 < the (eval r_result1\n            [pdec2 (prod_encode (x\\<^sub>0, max t y)), i,\n             pdec1 (prod_encode (x\\<^sub>0, max t y))])", "have \"eval r_dovedelay [?z, i, y] \\<down>= 0\""], ["proof (prove)\nusing this:\n  y \\<le> prod_encode (x\\<^sub>0, max t y)\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n  0 < the (eval r_result1\n            [pdec2 (prod_encode (x\\<^sub>0, max t y)), i,\n             pdec1 (prod_encode (x\\<^sub>0, max t y))])\n\ngoal (1 subgoal):\n 1. eval r_dovedelay [prod_encode (x\\<^sub>0, max t y), i, y] \\<down>= 0", "by presburger"], ["proof (state)\nthis:\n  eval r_dovedelay [prod_encode (x\\<^sub>0, max t y), i, y] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval r_dovedelay [prod_encode (x\\<^sub>0, max t y), i, y] \\<down>= 0", "show \"eval r_enumdom [i, y] \\<down>\""], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x\\<^sub>0, max t y), i, y] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "using r_enumdom"], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x\\<^sub>0, max t y), i, y] \\<down>= 0\n  eval r_enumdom [?i, ?y] =\n  (if \\<exists>z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0\n   then Some (pdec1 (LEAST z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0))\n   else None)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "by auto"], ["proof (state)\nthis:\n  eval r_enumdom [i, y] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_enumdom [i, ?y] \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (eval r_phi [i, x] \\<down>) =\n       (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)", "show \"eval r_phi [i, x] \\<down> = (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval r_phi [i, x] \\<down>) =\n    (\\<exists>y. eval r_enumdom [i, y] \\<down>= x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. eval r_phi [i, x] \\<down> \\<Longrightarrow>\n    \\<exists>y. eval r_enumdom [i, y] \\<down>= x\n 2. \\<exists>y. eval r_enumdom [i, y] \\<down>= x \\<Longrightarrow>\n    eval r_phi [i, x] \\<down>", "show \"\\<exists>y. eval r_enumdom [i, y] \\<down>= x\" if \"eval r_phi [i, x] \\<down>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "from that"], ["proof (chain)\npicking this:\n  eval r_phi [i, x] \\<down>", "obtain v where \"eval r_phi [i, x] \\<down>= v\""], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval r_phi [i, x] \\<down>= v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_phi [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "then"], ["proof (chain)\npicking this:\n  eval r_phi [i, x] \\<down>= v", "obtain t where t: \"the (eval r_result1 [t, i, x]) > 0\""], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<down>= v\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        0 < the (eval r_result1 [t, i, x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_result1_converg' assms"], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<down>= v\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [i, x\\<^sub>0] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        0 < the (eval r_result1 [t, i, x]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Zero_not_Suc dual_order.refl option.sel zero_less_iff_neq_zero)"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [t, i, x])\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "let ?y = \"prod_encode (x, t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "have \"eval r_dovedelay [?y, i, ?y] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0", "using r_dovedelay t"], ["proof (prove)\nusing this:\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n  0 < the (eval r_result1 [t, i, x])\n\ngoal (1 subgoal):\n 1. eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "moreover"], ["proof (state)\nthis:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "from this"], ["proof (chain)\npicking this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0", "have \"(LEAST z. eval r_dovedelay [z, i, ?y] \\<down>= 0) = ?y\""], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n\ngoal (1 subgoal):\n 1. (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n    prod_encode (x, t)", "using gr_implies_not_zero r_dovedelay"], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> (0::?'a)\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n\ngoal (1 subgoal):\n 1. (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n    prod_encode (x, t)", "by (intro Least_equality; fastforce)"], ["proof (state)\nthis:\n  (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n  prod_encode (x, t)\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "ultimately"], ["proof (chain)\npicking this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n  (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n  prod_encode (x, t)", "have \"eval r_enumdom [i, ?y] \\<down>= x\""], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n  (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n  prod_encode (x, t)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, prod_encode (x, t)] \\<down>= x", "using r_enumdom"], ["proof (prove)\nusing this:\n  eval r_dovedelay [prod_encode (x, t), i, prod_encode (x, t)] \\<down>= 0\n  (LEAST z. eval r_dovedelay [z, i, prod_encode (x, t)] \\<down>= 0) =\n  prod_encode (x, t)\n  eval r_enumdom [?i, ?y] =\n  (if \\<exists>z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0\n   then Some (pdec1 (LEAST z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0))\n   else None)\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, prod_encode (x, t)] \\<down>= x", "by auto"], ["proof (state)\nthis:\n  eval r_enumdom [i, prod_encode (x, t)] \\<down>= x\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "then"], ["proof (chain)\npicking this:\n  eval r_enumdom [i, prod_encode (x, t)] \\<down>= x", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_enumdom [i, prod_encode (x, t)] \\<down>= x\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "by blast"], ["proof (state)\nthis:\n  \\<exists>y. eval r_enumdom [i, y] \\<down>= x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_phi [i, ?x] \\<down> \\<Longrightarrow>\n  \\<exists>y. eval r_enumdom [i, y] \\<down>= ?x\n\ngoal (1 subgoal):\n 1. \\<exists>y. eval r_enumdom [i, y] \\<down>= x \\<Longrightarrow>\n    eval r_phi [i, x] \\<down>", "show \"eval r_phi [i, x] \\<down>\" if \"\\<exists>y. eval r_enumdom [i, y] \\<down>= x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "from that"], ["proof (chain)\npicking this:\n  \\<exists>y. eval r_enumdom [i, y] \\<down>= x", "obtain y where y: \"eval r_enumdom [i, y] \\<down>= x\""], ["proof (prove)\nusing this:\n  \\<exists>y. eval r_enumdom [i, y] \\<down>= x\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        eval r_enumdom [i, y] \\<down>= x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval r_enumdom [i, y] \\<down>= x\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval r_enumdom [i, y] \\<down>= x", "have \"eval r_enumdom [i, y] \\<down>\""], ["proof (prove)\nusing this:\n  eval r_enumdom [i, y] \\<down>= x\n\ngoal (1 subgoal):\n 1. eval r_enumdom [i, y] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_enumdom [i, y] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval r_enumdom [i, y] \\<down>", "have\n        \"\\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\" and\n        *: \"eval r_enumdom [i, y] \\<down>= pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)\"\n          (is \"_ \\<down>= pdec1 ?z\")"], ["proof (prove)\nusing this:\n  eval r_enumdom [i, y] \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0 &&&\n    eval r_enumdom [i, y] \\<down>=\n    pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)", "using r_enumdom"], ["proof (prove)\nusing this:\n  eval r_enumdom [i, y] \\<down>\n  eval r_enumdom [?i, ?y] =\n  (if \\<exists>z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0\n   then Some (pdec1 (LEAST z. eval r_dovedelay [z, ?i, ?y] \\<down>= 0))\n   else None)\n\ngoal (1 subgoal):\n 1. \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0 &&&\n    eval r_enumdom [i, y] \\<down>=\n    pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)", "by metis+"], ["proof (state)\nthis:\n  \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n  eval r_enumdom [i, y] \\<down>=\n  pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n  eval r_enumdom [i, y] \\<down>=\n  pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)", "have z: \"eval r_dovedelay [?z, i, y] \\<down>= 0\""], ["proof (prove)\nusing this:\n  \\<exists>z. eval r_dovedelay [z, i, y] \\<down>= 0\n  eval r_enumdom [i, y] \\<down>=\n  pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. eval r_dovedelay\n     [LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0, i, y] \\<down>=\n    0", "by (meson wellorder_Least_lemma(1))"], ["proof (state)\nthis:\n  eval r_dovedelay\n   [LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0, i, y] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "have \"the (eval r_result1 [pdec2 ?z, i, pdec1 ?z]) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0), i,\n               pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < the (eval r_result1\n                     [pdec2\n                       (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                      i, pdec1\n                          (LEAST z.\n                              eval r_dovedelay [z, i, y] \\<down>=\n                              0)]) \\<Longrightarrow>\n    False", "assume \"\\<not> (the (eval r_result1 [pdec2 ?z, i, pdec1 ?z]) > 0)\""], ["proof (state)\nthis:\n  \\<not> 0 < the (eval r_result1\n                   [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                    i, pdec1\n                        (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n\ngoal (1 subgoal):\n 1. \\<not> 0 < the (eval r_result1\n                     [pdec2\n                       (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                      i, pdec1\n                          (LEAST z.\n                              eval r_dovedelay [z, i, y] \\<down>=\n                              0)]) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < the (eval r_result1\n                   [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                    i, pdec1\n                        (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])", "show False"], ["proof (prove)\nusing this:\n  \\<not> 0 < the (eval r_result1\n                   [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                    i, pdec1\n                        (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n\ngoal (1 subgoal):\n 1. False", "using r_dovedelay z"], ["proof (prove)\nusing this:\n  \\<not> 0 < the (eval r_result1\n                   [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0),\n                    i, pdec1\n                        (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n  eval r_dovedelay [?z, ?i, ?y] \\<down>=\n  (if 0 < the (eval r_result1 [pdec2 ?z, ?i, pdec1 ?z]) \\<and> ?y \\<le> ?z\n   then 0 else 1)\n  eval r_dovedelay\n   [LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0, i, y] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0), i,\n             pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "then"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1\n            [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0), i,\n             pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])", "have \"eval r_phi [i, pdec1 ?z] \\<down>\""], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0), i,\n             pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>", "using r_result1_diverg' assms"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [pdec2 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0), i,\n             pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)])\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  eval r_phi [i, x\\<^sub>0] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi\n     [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>", "by fastforce"], ["proof (state)\nthis:\n  eval r_phi\n   [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "then"], ["proof (chain)\npicking this:\n  eval r_phi\n   [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_phi\n   [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "using y *"], ["proof (prove)\nusing this:\n  eval r_phi\n   [i, pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)] \\<down>\n  eval r_enumdom [i, y] \\<down>= x\n  eval r_enumdom [i, y] \\<down>=\n  pdec1 (LEAST z. eval r_dovedelay [z, i, y] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. eval r_phi [i, x] \\<down>", "by auto"], ["proof (state)\nthis:\n  eval r_phi [i, x] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>y. eval r_enumdom [i, y] \\<down>= ?x \\<Longrightarrow>\n  eval r_phi [i, ?x] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (eval r_phi [i, ?x] \\<down>) =\n  (\\<exists>y. eval r_enumdom [i, y] \\<down>= ?x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For every $\\varphi_i$ with non-empty domain there is a total\nrecursive function that enumerates the domain of $\\varphi_i$.\\<close>"], ["", "lemma nonempty_domain_enumerable:\n  assumes \"eval r_phi [i, x\\<^sub>0] \\<down>\"\n  shows \"\\<exists>g. recfn 1 g \\<and> total g \\<and> (\\<forall>x. eval r_phi [i, x] \\<down> \\<longleftrightarrow> (\\<exists>y. eval g [y] \\<down>= x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "define g where \"g \\<equiv> Cn 1 r_enumdom [r_const i, Id 1 0]\""], ["proof (state)\nthis:\n  g \\<equiv> Cn 1 r_enumdom [r_const i, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "then"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 1 r_enumdom [r_const i, recf.Id 1 0]", "have \"recfn 1 g\""], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 1 r_enumdom [r_const i, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 g", "by simp"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "moreover"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "from this"], ["proof (chain)\npicking this:\n  recfn 1 g", "have \"total g\""], ["proof (prove)\nusing this:\n  recfn 1 g\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total g", "using totalI1[of g] g_def assms r_enumdom_nonempty_domain(1)"], ["proof (prove)\nusing this:\n  recfn 1 g\n  \\<lbrakk>recfn 1 g; \\<And>x. eval g [x] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total g\n  g \\<equiv> Cn 1 r_enumdom [r_const i, recf.Id 1 0]\n  eval r_phi [i, x\\<^sub>0] \\<down>\n  eval r_phi [?i, ?x\\<^sub>0] \\<down> \\<Longrightarrow>\n  eval r_enumdom [?i, ?y] \\<down>\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total g", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total g\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "moreover"], ["proof (state)\nthis:\n  Partial_Recursive.total g\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "have \"eval r_phi [i, x] \\<down> \\<longleftrightarrow> (\\<exists>y. eval g [y] \\<down>= x)\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval r_phi [i, x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= x)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval r_phi [i, x] \\<down>) =\n    (\\<exists>y.\n        eval (Cn 1 r_enumdom [r_const i, recf.Id 1 0]) [y] \\<down>= x)", "using r_enumdom_nonempty_domain(2)[OF assms]"], ["proof (prove)\nusing this:\n  (eval r_phi [i, ?x] \\<down>) =\n  (\\<exists>y. eval r_enumdom [i, y] \\<down>= ?x)\n\ngoal (1 subgoal):\n 1. (eval r_phi [i, x] \\<down>) =\n    (\\<exists>y.\n        eval (Cn 1 r_enumdom [r_const i, recf.Id 1 0]) [y] \\<down>= x)", "by simp"], ["proof (state)\nthis:\n  (eval r_phi [i, ?x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "ultimately"], ["proof (chain)\npicking this:\n  recfn 1 g\n  Partial_Recursive.total g\n  (eval r_phi [i, ?x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= ?x)", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 g\n  Partial_Recursive.total g\n  (eval r_phi [i, ?x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       recfn 1 g \\<and>\n       Partial_Recursive.total g \\<and>\n       (\\<forall>x.\n           (eval r_phi [i, x] \\<down>) =\n           (\\<exists>y. eval g [y] \\<down>= x))", "by auto"], ["proof (state)\nthis:\n  \\<exists>g.\n     recfn 1 g \\<and>\n     Partial_Recursive.total g \\<and>\n     (\\<forall>x.\n         (eval r_phi [i, x] \\<down>) = (\\<exists>y. eval g [y] \\<down>= x))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Concurrent evaluation of functions\\<close>"], ["", "text \\<open>We define a function that simulates two @{typ recf}s\n``concurrently'' for the same argument and returns the result of the one\nconverging first. If both diverge, so does the simulation function.\\<close>"], ["", "definition \"r_both \\<equiv>\n  Cn 4 r_ifz\n   [Cn 4 r_result1 [Id 4 0, Id 4 1, Id 4 3],\n    Cn 4 r_ifz\n     [Cn 4 r_result1 [Id 4 0, Id 4 2, Id 4 3],\n      Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n      Cn 4 r_prod_encode\n       [r_constn 3 1, Cn 4 r_dec [Cn 4 r_result1 [Id 4 0, Id 4 2, Id 4 3]]]],\n    Cn 4 r_prod_encode\n     [r_constn 3 0, Cn 4 r_dec [Cn 4 r_result1 [Id 4 0, Id 4 1, Id 4 3]]]]\""], ["", "lemma r_both_prim [simp]: \"prim_recfn 4 r_both\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4 r_both", "unfolding r_both_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 4\n     (Cn 4 r_ifz\n       [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3],\n        Cn 4 r_ifz\n         [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3],\n          Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n          Cn 4 r_prod_encode\n           [r_constn 3 1,\n            Cn 4 r_dec\n             [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3]]]],\n        Cn 4 r_prod_encode\n         [r_constn 3 0,\n          Cn 4 r_dec\n           [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3]]]])", "by simp"], ["", "lemma r_both:\n  assumes \"\\<And>x. eval r_phi [i, x] = eval f [x]\"\n    and \"\\<And>x. eval r_phi [j, x] = eval g [x]\"\n  shows \"eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\"\n    and \"\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0; eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk> \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\"\n    and \"eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\"\n    and \"\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0; eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk> \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n      eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)) &&&\n     (\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n       eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n      \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                        prod_encode (2, 0))) &&&\n    (eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n     eval r_both [t, i, j, x] \\<down>=\n     prod_encode (0, the (eval f [x]))) &&&\n    (\\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n      eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n     \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                       prod_encode (1, the (eval g [x])))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 3. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 4. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "have r_result_total [simp]: \"eval r_result [t, k, x] \\<down>\" for t k x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result [t, k, x] \\<down>", "using r_result_total"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_result\n\ngoal (1 subgoal):\n 1. eval r_result [t, k, x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_result [?t, ?k, ?x] \\<down>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 3. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 4. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "{"], ["proof (state)\nthis:\n  eval r_result [?t, ?k, ?x] \\<down>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 3. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 4. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "assume \"eval f [x] \\<up> \\<and> eval g [x] \\<up>\""], ["proof (state)\nthis:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 3. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 4. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>", "have \"eval r_result1 [t, i, x] \\<down>= 0\" and \"eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0 &&&\n    eval r_result1 [t, j, x] \\<down>= 0", "using assms r_result1_diverg'"], ["proof (prove)\nusing this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0 &&&\n    eval r_result1 [t, j, x] \\<down>= 0", "by auto"], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 3. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 4. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0", "show \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "unfolding r_both_def"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifz\n       [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3],\n        Cn 4 r_ifz\n         [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3],\n          Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n          Cn 4 r_prod_encode\n           [r_constn 3 1,\n            Cn 4 r_dec\n             [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3]]]],\n        Cn 4 r_prod_encode\n         [r_constn 3 0,\n          Cn 4 r_dec\n           [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3]]]])\n     [t, i, j, x] \\<down>=\n    prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "assume \"eval r_result1 [t, i, x] \\<down>= 0\" and \"eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n 2. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0", "show \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "unfolding r_both_def"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifz\n       [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3],\n        Cn 4 r_ifz\n         [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3],\n          Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n          Cn 4 r_prod_encode\n           [r_constn 3 1,\n            Cn 4 r_dec\n             [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3]]]],\n        Cn 4 r_prod_encode\n         [r_constn 3 0,\n          Cn 4 r_dec\n           [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3]]]])\n     [t, i, j, x] \\<down>=\n    prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (2 subgoals):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "assume \"eval r_result1 [t, i, x] \\<down>= Suc v\""], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n\ngoal (2 subgoals):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "moreover"], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n\ngoal (2 subgoals):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "from this"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= Suc v", "have \"eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))", "using assms r_result1_Some'"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_phi [?i, ?x] \\<down>= ?v\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))", "by fastforce"], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))\n\ngoal (2 subgoals):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n    eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))", "show \"eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "unfolding r_both_def"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [t, i, x] \\<down>= Suc (the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifz\n       [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3],\n        Cn 4 r_ifz\n         [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3],\n          Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n          Cn 4 r_prod_encode\n           [r_constn 3 1,\n            Cn 4 r_dec\n             [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3]]]],\n        Cn 4 r_prod_encode\n         [r_constn 3 0,\n          Cn 4 r_dec\n           [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3]]]])\n     [t, i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x]))", "by auto"], ["proof (state)\nthis:\n  eval r_both [t, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "assume \"eval r_result1 [t, i, x] \\<down>= 0\" and \"eval r_result1 [t, j, x] \\<down>= Suc v\""], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "moreover"], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "from this"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v", "have \"eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))", "using assms r_result1_Some'"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_phi [?i, ?x] \\<down>= ?v\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))", "by fastforce"], ["proof (state)\nthis:\n  eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n     eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n    \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                      prod_encode (1, the (eval g [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n  eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))", "show \"eval r_both [t, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n  eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "unfolding r_both_def"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= 0\n  eval r_result1 [t, j, x] \\<down>= Suc v\n  eval r_result1 [t, j, x] \\<down>= Suc (the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifz\n       [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3],\n        Cn 4 r_ifz\n         [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3],\n          Cn 4 r_prod_encode [r_constn 3 2, r_constn 3 0],\n          Cn 4 r_prod_encode\n           [r_constn 3 1,\n            Cn 4 r_dec\n             [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 2, recf.Id 4 3]]]],\n        Cn 4 r_prod_encode\n         [r_constn 3 0,\n          Cn 4 r_dec\n           [Cn 4 r_result1 [recf.Id 4 0, recf.Id 4 1, recf.Id 4 3]]]])\n     [t, i, j, x] \\<down>=\n    prod_encode (1, the (eval g [x]))", "by auto"], ["proof (state)\nthis:\n  eval r_both [t, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>eval r_result1 [t, i, x] \\<down>= 0;\n   eval r_result1 [t, j, x] \\<down>= Suc v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [t, i, j, x] \\<down>=\n                    prod_encode (1, the (eval g [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_parallel \\<equiv>\n  Cn 3 r_both [Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]), Id 3 0, Id 3 1, Id 3 2]\""], ["", "lemma r_parallel_recfn [simp]: \"recfn 3 r_parallel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_parallel", "unfolding r_parallel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3\n     (Cn 3 r_both\n       [Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]), recf.Id 3 0,\n        recf.Id 3 1, recf.Id 3 2])", "by simp"], ["", "lemma r_parallel:\n  assumes \"\\<And>x. eval r_phi [i, x] = eval f [x]\"\n    and \"\\<And>x. eval r_phi [j, x] = eval g [x]\"\n  shows \"eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow> eval r_parallel [i, j, x] \\<up>\"\n    and \"eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\"\n    and \"eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\"\n    and \"eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<up>) &&&\n     (eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>=\n      prod_encode (0, the (eval f [x])))) &&&\n    (eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval g [x]))) &&&\n    (eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (0, the (eval f [x])) \\<or>\n     eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x])))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "let ?cond = \"Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]\""], ["proof (state)\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "define m where \"m = Mn 3 ?cond\""], ["proof (state)\nthis:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])", "have m: \"r_parallel = Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]\""], ["proof (prove)\nusing this:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n\ngoal (1 subgoal):\n 1. r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]", "unfolding r_parallel_def"], ["proof (prove)\nusing this:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n\ngoal (1 subgoal):\n 1. Cn 3 r_both\n     [Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]), recf.Id 3 0,\n      recf.Id 3 1, recf.Id 3 2] =\n    Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]", "by simp"], ["proof (state)\nthis:\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "from m_def"], ["proof (chain)\npicking this:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])", "have \"recfn 3 m\""], ["proof (prove)\nusing this:\n  m = Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n\ngoal (1 subgoal):\n 1. recfn 3 m", "by simp"], ["proof (state)\nthis:\n  recfn 3 m\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "{"], ["proof (state)\nthis:\n  recfn 3 m\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "assume \"eval f [x] \\<up> \\<and> eval g [x] \\<up>\""], ["proof (state)\nthis:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>", "have \"\\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\""], ["proof (prove)\nusing this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "using assms r_both"], ["proof (prove)\nusing this:\n  eval f [x] \\<up> \\<and> eval g [x] \\<up>\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?f [?x] \\<up> \\<and> eval ?g [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= 0\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x]))\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  \\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "have \"eval ?cond [t, i, j, x] \\<down>= 1\" for t"], ["proof (prove)\nusing this:\n  \\<forall>t. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1", "have \"eval m [i, j, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. eval m [i, j, x] \\<up>", "unfolding m_def"], ["proof (prove)\nusing this:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<up>", "using eval_Mn_diverg"], ["proof (prove)\nusing this:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n  recfn (length ?xs) (Mn ?n ?f) \\<Longrightarrow>\n  (\\<nexists>z.\n      eval ?f (z # ?xs) \\<down>= 0 \\<and>\n      (\\<forall>y<z. eval ?f (y # ?xs) \\<down>)) =\n  (eval (Mn ?n ?f) ?xs \\<up>)\n\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<up>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval m [i, j, x] \\<up>", "have \"eval (Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]) [i, j, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n     [i, j, x] \\<up>", "using \\<open>recfn 3 m\\<close>"], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<up>\n  recfn 3 m\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n     [i, j, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n   [i, j, x] \\<up>\n\ngoal (4 subgoals):\n 1. eval f [x] \\<up> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 3. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 4. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n   [i, j, x] \\<up>", "show \"eval r_parallel [i, j, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n   [i, j, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<up>", "using m"], ["proof (prove)\nusing this:\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2])\n   [i, j, x] \\<up>\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<up>\n\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "assume \"eval f [x] \\<down> \\<and> eval g [x] \\<down>\""], ["proof (state)\nthis:\n  eval f [x] \\<down> \\<and> eval g [x] \\<down>\n\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<down>", "obtain vf vg where v: \"eval f [x] \\<down>= vf\" \"eval g [x] \\<down>= vg\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>vf vg.\n        \\<lbrakk>eval f [x] \\<down>= vf; eval g [x] \\<down>= vg\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg\n\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg", "obtain tf where tf:\n      \"\\<forall>t\\<ge>tf. eval r_result1 [t, i, x] \\<down>= Suc vf\"\n      \"\\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg\n\ngoal (1 subgoal):\n 1. (\\<And>tf.\n        \\<lbrakk>\\<forall>t\\<ge>tf.\n                    eval r_result1 [t, i, x] \\<down>= Suc vf;\n         \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result1_converg' assms"], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>tf.\n        \\<lbrakk>\\<forall>t\\<ge>tf.\n                    eval r_result1 [t, i, x] \\<down>= Suc vf;\n         \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>t\\<ge>tf. eval r_result1 [t, i, x] \\<down>= Suc vf\n  \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "from v"], ["proof (chain)\npicking this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg", "obtain tg where tg:\n      \"\\<forall>t\\<ge>tg. eval r_result1 [t, j, x] \\<down>= Suc vg\"\n      \"\\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg\n\ngoal (1 subgoal):\n 1. (\\<And>tg.\n        \\<lbrakk>\\<forall>t\\<ge>tg.\n                    eval r_result1 [t, j, x] \\<down>= Suc vg;\n         \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result1_converg' assms"], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= vf\n  eval g [x] \\<down>= vg\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>tg.\n        \\<lbrakk>\\<forall>t\\<ge>tg.\n                    eval r_result1 [t, j, x] \\<down>= Suc vg;\n         \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>t\\<ge>tg. eval r_result1 [t, j, x] \\<down>= Suc vg\n  \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (3 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 3. eval f [x] \\<down> \\<and> eval g [x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "show \"eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "proof (cases \"tf \\<le> tg\")"], ["proof (state)\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "case True"], ["proof (state)\nthis:\n  tf \\<le> tg\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "with tg(2)"], ["proof (chain)\npicking this:\n  \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\n  tf \\<le> tg", "have j0: \"\\<forall>t<tf. eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\n  tf \\<le> tg\n\ngoal (1 subgoal):\n 1. \\<forall>t<tf. eval r_result1 [t, j, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>t<tf. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have *: \"eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "using r_both(3) assms tf(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x]))\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  \\<forall>t\\<ge>tf. eval r_result1 [t, i, x] \\<down>= Suc vf\n\ngoal (1 subgoal):\n 1. eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval m [i, j, x] \\<down>= tf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval m [i, j, x] \\<down>= tf", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<down>=\n    tf", "proof (rule eval_Mn_convergI)"], ["proof (state)\ngoal (3 subgoals):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n 2. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tf, i, j, x] \\<down>=\n    0\n 3. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "show \"recfn (length [i, j, x]) (Mn 3 ?cond)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))", "by simp"], ["proof (state)\nthis:\n  recfn (length [i, j, x])\n   (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tf, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0", "using *"], ["proof (prove)\nusing this:\n  eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tf, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0", "show \"eval ?cond [tf, i, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval (Cn 4 r_pdec1 [r_both]) [tf, i, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tf, i, j, x] \\<down>=\n    0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [tf, i, j, x] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\" if \"t < tf\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "using tf(2) r_both(2) assms that j0"], ["proof (prove)\nusing this:\n  \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= 0\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  t < tf\n  \\<forall>t<tf. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  ?t < tf \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < tf \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)", "have \"eval ?cond [t, i, j, x] \\<down>= 1\" if \"t < tf\" for t"], ["proof (prove)\nusing this:\n  ?t < tf \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "using that"], ["proof (prove)\nusing this:\n  ?t < tf \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n  t < tf\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "by simp"], ["proof (state)\nthis:\n  ?t < tf \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < tf \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1", "show \"\\<And>y. y < tf \\<Longrightarrow> eval ?cond [y, i, j, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?t < tf \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tf \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "by simp"], ["proof (state)\nthis:\n  ?y < tf \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?y, i, j, x] \\<down>\\<noteq>\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= tf\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "moreover"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= tf\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval r_parallel [i, j, x] =\n          eval (Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]) [i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "using m"], ["proof (prove)\nusing this:\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval m [i, j, x] \\<down>= tf\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "have \"eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]\""], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= tf\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]", "using \\<open>recfn 3 m\\<close>"], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= tf\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n  recfn 3 m\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "with *"], ["proof (chain)\npicking this:\n  eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n  eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]", "have \"eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\""], ["proof (prove)\nusing this:\n  eval r_both [tf, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n  eval r_parallel [i, j, x] = eval r_both [tf, i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal (2 subgoals):\n 1. tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n 2. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "case False"], ["proof (state)\nthis:\n  \\<not> tf \\<le> tg\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "with tf(2)"], ["proof (chain)\npicking this:\n  \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\n  \\<not> tf \\<le> tg", "have i0: \"\\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  \\<forall>t<tf. eval r_result1 [t, i, x] \\<down>= 0\n  \\<not> tf \\<le> tg\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0", "have *: \"eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "using assms r_both(4) tg(1)"], ["proof (prove)\nusing this:\n  \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n  \\<forall>t\\<ge>tg. eval r_result1 [t, j, x] \\<down>= Suc vg\n\ngoal (1 subgoal):\n 1. eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "by auto"], ["proof (state)\nthis:\n  eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval m [i, j, x] \\<down>= tg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval m [i, j, x] \\<down>= tg", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<down>=\n    tg", "proof (rule eval_Mn_convergI)"], ["proof (state)\ngoal (3 subgoals):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n 2. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tg, i, j, x] \\<down>=\n    0\n 3. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "show \"recfn (length [i, j, x]) (Mn 3 ?cond)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))", "by simp"], ["proof (state)\nthis:\n  recfn (length [i, j, x])\n   (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tg, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1", "using *"], ["proof (prove)\nusing this:\n  eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tg, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1", "show \"eval ?cond [tg, i, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval (Cn 4 r_pdec1 [r_both]) [tg, i, j, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [tg, i, j, x] \\<down>=\n    0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [tg, i, j, x] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\" if \"t < tg\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "using tg(2) r_both(2) assms that i0"], ["proof (prove)\nusing this:\n  \\<forall>t<tg. eval r_result1 [t, j, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= 0\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  t < tg\n  \\<forall>t\\<le>tg. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  ?t < tg \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < tg \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)", "have \"eval ?cond [t, i, j, x] \\<down>= 1\" if \"t < tg\" for t"], ["proof (prove)\nusing this:\n  ?t < tg \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "using that"], ["proof (prove)\nusing this:\n  ?t < tg \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n  t < tg\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "by simp"], ["proof (state)\nthis:\n  ?t < tg \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < tg \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1", "show \"\\<And>y. y < tg \\<Longrightarrow> eval ?cond [y, i, j, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?t < tg \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < tg \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "by simp"], ["proof (state)\nthis:\n  ?y < tg \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?y, i, j, x] \\<down>\\<noteq>\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= tg\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "moreover"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= tg\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval r_parallel [i, j, x] =\n          eval (Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]) [i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "using m"], ["proof (prove)\nusing this:\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval m [i, j, x] \\<down>= tg\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "have \"eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]\""], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= tg\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]", "using \\<open>recfn 3 m\\<close>"], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= tg\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n  recfn 3 m\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "with *"], ["proof (chain)\npicking this:\n  eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n  eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]", "have \"eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  eval r_both [tg, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n  eval r_parallel [i, j, x] = eval r_both [tg, i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. \\<not> tf \\<le> tg \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x])) \\<or>\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "assume eval_fg: \"eval g [x] \\<down> \\<and> eval f [x] \\<up>\""], ["proof (state)\nthis:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>", "have i0: \"\\<forall>t. eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_result1 [t, i, x] \\<down>= 0", "using r_result1_diverg' assms"], ["proof (prove)\nusing this:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_result1 [t, i, x] \\<down>= 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>t. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "from eval_fg"], ["proof (chain)\npicking this:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>", "obtain v where \"eval g [x] \\<down>= v\""], ["proof (prove)\nusing this:\n  eval g [x] \\<down> \\<and> eval f [x] \\<up>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval g [x] \\<down>= v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval g [x] \\<down>= v\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  eval g [x] \\<down>= v", "obtain t\\<^sub>0 where t0:\n      \"\\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= Suc v\"\n      \"\\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval g [x] \\<down>= v\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0.\n        \\<lbrakk>\\<forall>t\\<ge>t\\<^sub>0.\n                    eval r_result1 [t, j, x] \\<down>= Suc v;\n         \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result1_converg' assms"], ["proof (prove)\nusing this:\n  eval g [x] \\<down>= v\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0.\n        \\<lbrakk>\\<forall>t\\<ge>t\\<^sub>0.\n                    eval r_result1 [t, j, x] \\<down>= Suc v;\n         \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0", "have *: \"eval r_both [t\\<^sub>0, i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n    prod_encode (1, the (eval g [x]))", "using r_both(4) assms i0"], ["proof (prove)\nusing this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  \\<forall>t. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n    prod_encode (1, the (eval g [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (1, the (eval g [x]))\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval m [i, j, x] \\<down>= t\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval m [i, j, x] \\<down>= t\\<^sub>0", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<down>=\n    t\\<^sub>0", "proof (rule eval_Mn_convergI)"], ["proof (state)\ngoal (3 subgoals):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n 2. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 3. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "show \"recfn (length [i, j, x]) (Mn 3 ?cond)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))", "by simp"], ["proof (state)\nthis:\n  recfn (length [i, j, x])\n   (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1", "using *"], ["proof (prove)\nusing this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1", "show \"eval ?cond [t\\<^sub>0, i, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 1\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [t\\<^sub>0, i, j, x] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\" if \"t < t\\<^sub>0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "using t0(2) r_both(2) assms that i0"], ["proof (prove)\nusing this:\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, j, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= 0\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  t < t\\<^sub>0\n  \\<forall>t. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)", "have \"eval ?cond [t, i, j, x] \\<down>= 1\" if \"t < t\\<^sub>0\" for t"], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "using that"], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n  t < t\\<^sub>0\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "by simp"], ["proof (state)\nthis:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1", "show \"\\<And>y. y < t\\<^sub>0 \\<Longrightarrow> eval ?cond [y, i, j, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "by simp"], ["proof (state)\nthis:\n  ?y < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?y, i, j, x] \\<down>\\<noteq>\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "moreover"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "have \"eval r_parallel [i, j, x] =\n        eval (Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]) [i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "using m"], ["proof (prove)\nusing this:\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "have \"eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\""], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "using \\<open>recfn 3 m\\<close>"], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n  recfn 3 m\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\n\ngoal (2 subgoals):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n 2. eval g [x] \\<down> \\<and> eval f [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "with *"], ["proof (chain)\npicking this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (1, the (eval g [x]))\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "show \"eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\""], ["proof (prove)\nusing this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (1, the (eval g [x]))\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval g [x]))\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "assume eval_fg: \"eval f [x] \\<down> \\<and> eval g [x] \\<up>\""], ["proof (state)\nthis:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>", "have j0: \"\\<forall>t. eval r_result1 [t, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_result1 [t, j, x] \\<down>= 0", "using r_result1_diverg' assms"], ["proof (prove)\nusing this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. \\<forall>t. eval r_result1 [t, j, x] \\<down>= 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>t. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "from eval_fg"], ["proof (chain)\npicking this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>", "obtain v where \"eval f [x] \\<down>= v\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up>\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval f [x] \\<down>= v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  eval f [x] \\<down>= v\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "then"], ["proof (chain)\npicking this:\n  eval f [x] \\<down>= v", "obtain t\\<^sub>0 where t0:\n      \"\\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= Suc v\"\n      \"\\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= v\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0.\n        \\<lbrakk>\\<forall>t\\<ge>t\\<^sub>0.\n                    eval r_result1 [t, i, x] \\<down>= Suc v;\n         \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using r_result1_converg' assms"], ["proof (prove)\nusing this:\n  eval f [x] \\<down>= v\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. (\\<And>t\\<^sub>0.\n        \\<lbrakk>\\<forall>t\\<ge>t\\<^sub>0.\n                    eval r_result1 [t, i, x] \\<down>= Suc v;\n         \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "then"], ["proof (chain)\npicking this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0", "have *: \"eval r_both [t\\<^sub>0, i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x]))", "using r_both(3) assms"], ["proof (prove)\nusing this:\n  \\<forall>t\\<ge>t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= Suc v\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x]))\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n\ngoal (1 subgoal):\n 1. eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n    prod_encode (0, the (eval f [x]))", "by blast"], ["proof (state)\nthis:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (0, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "have \"eval m [i, j, x] \\<down>= t\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval m [i, j, x] \\<down>= t\\<^sub>0", "unfolding m_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n     [i, j, x] \\<down>=\n    t\\<^sub>0", "proof (rule eval_Mn_convergI)"], ["proof (state)\ngoal (3 subgoals):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n 2. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 3. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "show \"recfn (length [i, j, x]) (Mn 3 ?cond)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn (length [i, j, x])\n     (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))", "by simp"], ["proof (state)\nthis:\n  recfn (length [i, j, x])\n   (Mn 3 (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1]))\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0", "using *"], ["proof (prove)\nusing this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (0, the (eval f [x]))\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0\n 2. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0", "show \"eval ?cond [t\\<^sub>0, i, j, x] \\<down>= 0\""], ["proof (prove)\nusing this:\n  eval (Cn 4 r_pdec1 [r_both]) [t\\<^sub>0, i, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t\\<^sub>0, i, j, x] \\<down>=\n    0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [t\\<^sub>0, i, j, x] \\<down>=\n  0\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "have \"eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)\" if \"t < t\\<^sub>0\" for t"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "using t0(2) r_both(2) assms that j0"], ["proof (prove)\nusing this:\n  \\<forall>t<t\\<^sub>0. eval r_result1 [t, i, x] \\<down>= 0\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval r_result1 [?t, ?i, ?x] \\<down>= 0;\n   eval r_result1 [?t, ?j, ?x] \\<down>= 0\\<rbrakk>\n  \\<Longrightarrow> eval r_both [?t, ?i, ?j, ?x] \\<down>= prod_encode (2, 0)\n  eval r_phi [i, ?x] = eval f [?x]\n  eval r_phi [j, ?x] = eval g [?x]\n  t < t\\<^sub>0\n  \\<forall>t. eval r_result1 [t, j, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_both [t, i, j, x] \\<down>= prod_encode (2, 0)", "by simp"], ["proof (state)\nthis:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)", "have \"eval ?cond [t, i, j, x] \\<down>= 1\" if \"t < t\\<^sub>0\" for t"], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "using that"], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval r_both [?t, i, j, x] \\<down>= prod_encode (2, 0)\n  t < t\\<^sub>0\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n     [t, i, j, x] \\<down>=\n    1", "by simp"], ["proof (state)\nthis:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "then"], ["proof (chain)\npicking this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1", "show \"\\<And>y. y < t\\<^sub>0 \\<Longrightarrow> eval ?cond [y, i, j, x] \\<down>\\<noteq> 0\""], ["proof (prove)\nusing this:\n  ?t < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?t, i, j, x] \\<down>=\n  1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < t\\<^sub>0 \\<Longrightarrow>\n       eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n        [y, i, j, x] \\<down>\\<noteq>\n       0", "by simp"], ["proof (state)\nthis:\n  ?y < t\\<^sub>0 \\<Longrightarrow>\n  eval (Cn 4 r_le [Cn 4 r_pdec1 [r_both], r_constn 3 1])\n   [?y, i, j, x] \\<down>\\<noteq>\n  0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "moreover"], ["proof (state)\nthis:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "have \"eval r_parallel [i, j, x] =\n        eval (Cn 3 r_both [m, Id 3 0, Id 3 1, Id 3 2]) [i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "using m"], ["proof (prove)\nusing this:\n  r_parallel = Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] =\n    eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "ultimately"], ["proof (chain)\npicking this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]", "have \"eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\""], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "using \\<open>recfn 3 m\\<close>"], ["proof (prove)\nusing this:\n  eval m [i, j, x] \\<down>= t\\<^sub>0\n  eval r_parallel [i, j, x] =\n  eval (Cn 3 r_both [m, recf.Id 3 0, recf.Id 3 1, recf.Id 3 2]) [i, j, x]\n  recfn 3 m\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\n\ngoal (1 subgoal):\n 1. eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "with *"], ["proof (chain)\npicking this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (0, the (eval f [x]))\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]", "show \"eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\""], ["proof (prove)\nusing this:\n  eval r_both [t\\<^sub>0, i, j, x] \\<down>=\n  prod_encode (0, the (eval f [x]))\n  eval r_parallel [i, j, x] = eval r_both [t\\<^sub>0, i, j, x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))", "by simp"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  eval f [x] \\<down> \\<and> eval g [x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval f [x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}