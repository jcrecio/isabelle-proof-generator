{"file_name": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference/Lemma_R.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Inductive_Inference", "problem_names": ["lemma r_result1_converg_phi:\n  assumes \"\\<phi> i x \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and> \n    (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)\"", "lemma r_result1_bivalent':\n  assumes \"eval r_phi [i, x] \\<down>= v\"\n  shows \"eval r_result1 [t, i, x] \\<down>= Suc v \\<or> eval r_result1 [t, i, x] \\<down>= 0\"", "lemma r_result1_bivalent_phi:\n  assumes \"\\<phi> i x \\<down>= v\"\n  shows \"eval r_result1 [t, i, x] \\<down>= Suc v \\<or> eval r_result1 [t, i, x] \\<down>= 0\"", "lemma r_result1_diverg_phi:\n  assumes \"\\<phi> i x \\<up>\"\n  shows \"eval r_result1 [t, i, x] \\<down>= 0\"", "lemma r_result1_some_phi:\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"\\<phi> i x \\<down>= v\"", "lemma r_result1_saturating':\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result1 [t + d, i, x] \\<down>= Suc v\"", "lemma r_result1_saturating_the:\n  assumes \"the (eval r_result1 [t, i, x]) > 0\" and \"t' \\<ge> t\"\n  shows \"the (eval r_result1 [t', i, x]) > 0\"", "lemma Greatest_bounded_Suc:\n  fixes P :: \"nat \\<Rightarrow> nat\"\n  shows \"(if P n > 0 then Suc n\n          else if \\<exists>j<n. P j > 0 then Suc (GREATEST j. j < n \\<and> P j > 0) else 0) =\n    (if \\<exists>j<Suc n. P j > 0 then Suc (GREATEST j. j < Suc n \\<and> P j > 0) else 0)\"\n      (is \"?lhs = ?rhs\")", "lemma r_delay_aux_prim: \"prim_recfn 3 r_delay_aux\"", "lemma r_delay_aux_total: \"total r_delay_aux\"", "lemma r_delay_aux:\n  assumes \"n \\<le> e_length x\"\n  shows \"eval r_delay_aux [n, i, x] \\<down>=\n   (if \\<exists>j<n. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\n    then Suc (GREATEST j.\n                 j < n \\<and>\n                 the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0)\n    else 0)\"", "lemma r_delay_recfn [simp]: \"recfn 2 r_delay\"", "lemma r_delay:\n  \"eval r_delay [i, x] \\<down>=\n    (if \\<exists>j<e_length x. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\n     then Suc (GREATEST j.\n        j < e_length x \\<and> the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0)\n     else 0)\"", "lemma delay_in_R2: \"delay \\<in> \\<R>\\<^sup>2\"", "lemma delay_le_length: \"the (delay i x) \\<le> e_length x\"", "lemma e_take_delay_init:\n  assumes \"f \\<in> \\<R>\" and \"the (delay i (f \\<triangleright> n)) > 0\"\n  shows \"e_take (the (delay i (f \\<triangleright> n))) (f \\<triangleright> n) = f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)\"", "lemma delay_gr0_converg:\n  assumes \"the (delay i x) > 0\"\n  shows \"\\<phi> i (e_take (the (delay i x)) x) \\<down>\"", "lemma delay_unbounded:\n  fixes n :: nat\n  assumes \"f \\<in> \\<R>\" and \"\\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\"\n  shows \"\\<exists>m. the (delay i (f \\<triangleright> m)) > n\"", "lemma delay_monotone:\n  assumes \"f \\<in> \\<R>\" and \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"the (delay i (f \\<triangleright> n\\<^sub>1)) \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\"\n    (is \"the (delay i ?x1) \\<le> the (delay i ?x2)\")", "lemma delay_unbounded_monotone:\n  fixes n :: nat\n  assumes \"f \\<in> \\<R>\" and \"\\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\"\n  shows \"\\<exists>m\\<^sub>0. \\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\"", "lemma r_totalizer_recfn: \"recfn 2 (r_totalizer d)\"", "lemma r_totalizer:\n  \"eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d else \\<phi> i (e_take (the (delay i x)) x))\"", "lemma r_totalizer_total: \"total (r_totalizer d)\"", "lemma totalizer_init:\n  assumes \"f \\<in> \\<R>\"\n  shows \"totalizer d i (f \\<triangleright> n) =\n    (if the (delay i (f \\<triangleright> n)) = 0 then Some d\n     else \\<phi> i (f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)))\"", "lemma totalizer_in_R2: \"totalizer d \\<in> \\<R>\\<^sup>2\"", "lemma lemma_R_for_Lim:\n  assumes \"learn_lim \\<psi> U (\\<phi> i)\"\n  shows \"learn_lim \\<psi> U (totalizer d i)\"", "lemma lemma_R_for_Lim_effective:\n  \"\\<exists>g\\<in>\\<R>. \\<forall>i.\n     \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n     (\\<forall>U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (g i))))\"", "lemma r_limr_recfn: \"recfn 1 r_limr\"\n  and r_limr_total: \"total r_limr\"\n  and r_limr:\n    \"\\<phi> (the (eval r_limr [i])) \\<in> \\<R>\"\n    \"learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow> learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))\"", "lemma lemma_R_for_BC:\n  assumes \"learn_bc \\<psi> U (\\<phi> i)\"\n  shows \"learn_bc \\<psi> U (totalizer d i)\"", "lemma lemma_R_for_FIN:\n  assumes \"learn_fin \\<psi> U (\\<phi> i)\"\n  shows \"learn_fin \\<psi> U (totalizer 0 i)\"", "lemma lemma_R_for_TOTAL:\n  fixes \\<psi> :: partial2\n  shows \"\\<exists>d. \\<forall>U. \\<forall>i. learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>  learn_total \\<psi> U (totalizer d i)\"", "lemma lemma_R_for_CP:\n  fixes \\<psi> :: partial2 and U :: \"partial1 set\"\n  assumes \"learn_cp \\<psi> U (\\<phi> i)\"\n  shows \"\\<exists>d. learn_cp \\<psi> U (totalizer d i)\"", "lemma prefixes_length: \"length (prefixes z i j x) = Suc x\"", "lemma init_adverse_eq_prefixes: \"(adverse z i j) \\<triangleright> n = list_encode (prefixes z i j n)\"", "lemma adverse_at_01:\n  \"adverse z i j 0 \\<down>= i\"\n  \"adverse z i j 1 \\<down>= j\"", "lemma adverse_in_R3: \"\\<exists>r. recfn 3 r \\<and> total r \\<and> (\\<lambda>i j x. eval r [i, j, x]) = adverse z\"", "lemma adverse_in_R1: \"adverse z i j \\<in> \\<R>\"", "lemma phi_translate_adverse: \"\\<exists>f\\<in>\\<R>\\<^sup>2.\\<forall>i j. \\<phi> (the (f i j)) = adverse z i j\"", "lemma adverse_in_V01: \"\\<exists>m n. adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and> adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\"", "lemma adverse_Suc:\n  assumes \"x > 0\"\n  shows \"adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc ((adverse z i j) \\<triangleright> x) 0) \\<noteq> s ((adverse z i j) \\<triangleright> x)\n     then 0\n     else if s (e_snoc ((adverse z i j) \\<triangleright> x) 1) \\<noteq> s ((adverse z i j) \\<triangleright> x)\n          then 1 else z)\"", "lemma adverse_Suc_not_hyp_change:\n  assumes \"x > 0\" and \"\\<not> hyp_change z i j x\"\n  shows \"adverse z i j (Suc x) \\<down>= z\"", "lemma while_hyp_change:\n  assumes \"\\<forall>x\\<le>n. x > 0 \\<longrightarrow> hyp_change z i j x\"\n  shows \"\\<forall>x\\<le>Suc n. adverse z i j x = adverse z' i j x\"", "lemma always_hyp_change_no_lim:\n  assumes \"\\<forall>x>0. hyp_change z i j x\"\n  shows \"\\<not> learn_lim \\<phi> {adverse z i j} s\"", "lemma no_hyp_change_no_cons:\n  assumes \"x > 0\" and \"\\<not> hyp_change z i j x\"\n  shows \"\\<not> learn_cons \\<phi> {adverse 0 i j, adverse 1 i j} s\"", "lemma V01_not_in_R_cons: \"\\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\"", "lemma r_parallel': \"eval r_parallel [i, j, x] = parallel i j x\"", "lemma r_parallel'':\n  shows \"eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow> eval r_parallel [i, j, x] \\<up>\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x]))\"\n    and \"eval r_phi [j, x] \\<down> \\<and> eval r_phi [i, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<down> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\"", "lemma parallel:\n  \"\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up> \\<Longrightarrow> parallel i j x \\<up>\"\n  \"\\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow> parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x))\"\n  \"\\<phi> j x \\<down> \\<and> \\<phi> i x \\<up> \\<Longrightarrow> parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\"\n  \"\\<phi> i x \\<down> \\<and> \\<phi> j x \\<down> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)) \\<or>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\"", "lemma parallel_converg_pdec1_0_or_1:\n  assumes \"parallel i j x \\<down>\"\n  shows \"pdec1 (the (parallel i j x)) = 0 \\<or> pdec1 (the (parallel i j x)) = 1\"", "lemma parallel_converg_either: \"(\\<phi> i x \\<down> \\<or> \\<phi> j x \\<down>) = (parallel i j x \\<down>)\"", "lemma parallel_0:\n  assumes \"parallel i j x \\<down>= prod_encode (0, v)\"\n  shows \"\\<phi> i x \\<down>= v\"", "lemma parallel_1:\n  assumes \"parallel i j x \\<down>= prod_encode (1, v)\"\n  shows \"\\<phi> j x \\<down>= v\"", "lemma parallel_converg_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"parallel (the (f 0)) (the (f 1)) x \\<down>\"", "lemma amalgamation_diverg: \"amalgamation i j x \\<up> \\<longleftrightarrow> \\<phi> i x \\<up> \\<and> \\<phi> j x \\<up>\"", "lemma amalgamation_total:\n  assumes \"total1 (\\<phi> i) \\<or> total1 (\\<phi> j)\"\n  shows \"total1 (amalgamation i j)\"", "lemma amalgamation_V01_total:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"total1 (amalgamation (the (f 0)) (the (f 1)))\"", "lemma r_amalgamation_recfn: \"recfn 3 r_amalgamation\"", "lemma r_amalgamation: \"eval r_amalgamation [i, j, x] = amalgamation i j x\"", "lemma amalgamate: \"\\<phi> (amalgamate i j) = amalgamation i j\"", "lemma amalgamation_in_P1: \"amalgamation i j \\<in> \\<P>\"", "lemma amalgamation_V01_R1:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"amalgamation (the (f 0)) (the (f 1)) \\<in> \\<R>\"", "lemma r_amalgamate_recfn: \"recfn 2 r_amalgamate\"", "lemma r_amalgamate: \"eval r_amalgamate [i, j] \\<down>= amalgamate i j\"", "lemma inconsist_converg:\n  assumes \"inconsist i e \\<down>\"\n  shows \"inconsist i e =\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then Some (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n     else Some (e_length e))\"\n    and \"\\<forall>x<e_length e. \\<phi> i x \\<down>\"", "lemma inconsist_bounded:\n  assumes \"inconsist i e \\<down>\"\n  shows \"the (inconsist i e) \\<le> e_length e\"", "lemma inconsist_consistent:\n  assumes \"inconsist i e \\<down>\"\n  shows \"inconsist i e \\<down>= e_length e \\<longleftrightarrow> (\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x)\"", "lemma inconsist_converg_eq:\n  assumes \"inconsist i e \\<down>= e_length e\"\n  shows \"\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\"", "lemma inconsist_converg_less:\n  assumes \"inconsist i e \\<down>\" and \"the (inconsist i e) < e_length e\"\n  shows \"\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\"\n    and \"inconsist i e \\<down>= (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\"", "lemma least_bounded_Suc:\n  assumes \"\\<exists>x. x < upper \\<and> P x\"\n  shows \"(LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)\"", "lemma least_bounded_gr:\n  fixes P :: \"nat \\<Rightarrow> bool\" and m :: nat\n  assumes \"\\<exists>x. x < upper \\<and> P x\"\n  shows \"(LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\"", "lemma inconsist_init_converg_less:\n  assumes \"f \\<in> \\<R>\"\n    and \"\\<phi> i \\<in> \\<R>\"\n    and \"inconsist i (f \\<triangleright> n) \\<down>\"\n    and \"the (inconsist i (f \\<triangleright> n)) < Suc n\"\n  shows \"inconsist i (f \\<triangleright> (n + m)) = inconsist i (f \\<triangleright> n)\"", "lemma r_inconsist_recfn: \"recfn 2 r_inconsist\"", "lemma r_inconsist: \"eval r_inconsist [i, e] = inconsist i e\"", "lemma inconsist_for_total:\n  assumes \"total1 (\\<phi> i)\"\n  shows \"inconsist i e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\"", "lemma inconsist_for_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\" and \"k = amalgamate (the (f 0)) (the (f 1))\"\n  shows \"inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)\"", "lemma r_auxhyp_prim: \"prim_recfn 1 r_auxhyp\"", "lemma r_auxhyp: \"\\<phi> (the (eval r_auxhyp [e])) = prenum e\"", "lemma auxhyp_prenum: \"\\<phi> (the (auxhyp e)) = prenum e\"", "lemma auxhyp_in_R1: \"auxhyp \\<in> \\<R>\"", "lemma r_sv01_recfn: \"recfn 1 r_sv01\"", "lemma sv01_in_P1: \"s\\<^bsub>01\\<^esub> \\<in> \\<P>\"", "lemma sv01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) = auxhyp (f \\<triangleright> 0)\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n \\<Longrightarrow>\n      pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist (amalg01 f) (f \\<triangleright> n))))) = 0 \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n \\<Longrightarrow>\n      pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq> 0 \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\"", "lemma sv01_converg_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\"", "lemma sv01_consistent_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"\\<forall>x\\<le>n. \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\"", "lemma sv01_limit_V01:\n assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n shows \"\\<exists>i. \\<forall>\\<^sup>\\<infinity>n. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\"", "lemma V01_learn_cons: \"learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\"", "lemma no_lemma_R_for_CONS: \"\\<exists>U. U \\<in> CONS \\<and> (\\<not> (\\<exists>s. s \\<in> \\<R> \\<and> learn_cons \\<phi> U s))\""], "translations": [["", "lemma r_result1_converg_phi:\n  assumes \"\\<phi> i x \\<down>= v\"\n  shows \"\\<exists>t.\n    (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and> \n    (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)", "using assms r_result1_converg' phi_def"], ["proof (prove)\nusing this:\n  \\<phi> i x \\<down>= v\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n\ngoal (1 subgoal):\n 1. \\<exists>t.\n       (\\<forall>t'\\<ge>t. eval r_result1 [t', i, x] \\<down>= Suc v) \\<and>\n       (\\<forall>t'<t. eval r_result1 [t', i, x] \\<down>= 0)", "by simp_all"], ["", "lemma r_result1_bivalent':\n  assumes \"eval r_phi [i, x] \\<down>= v\"\n  shows \"eval r_result1 [t, i, x] \\<down>= Suc v \\<or> eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result1 [t, i, x] \\<down>= 0", "using assms r_result1 r_result_bivalent' r_phi''"], ["proof (prove)\nusing this:\n  eval r_phi [i, x] \\<down>= v\n  eval r_result1 [?t, ?i, ?x] = eval r_result [?t, ?i, singleton_encode ?x]\n  eval r_univ [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<or>\n  eval r_result [?t, ?i, ?x] \\<down>= 0\n  eval r_phi [?i, ?x] = eval r_univ [?i, singleton_encode ?x]\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result1 [t, i, x] \\<down>= 0", "by simp"], ["", "lemma r_result1_bivalent_phi:\n  assumes \"\\<phi> i x \\<down>= v\"\n  shows \"eval r_result1 [t, i, x] \\<down>= Suc v \\<or> eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result1 [t, i, x] \\<down>= 0", "using assms r_result1_bivalent' phi_def"], ["proof (prove)\nusing this:\n  \\<phi> i x \\<down>= v\n  eval r_phi [?i, ?x] \\<down>= ?v \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<or>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= Suc v \\<or>\n    eval r_result1 [t, i, x] \\<down>= 0", "by simp_all"], ["", "lemma r_result1_diverg_phi:\n  assumes \"\\<phi> i x \\<up>\"\n  shows \"eval r_result1 [t, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0", "using assms phi_def r_result1_diverg'"], ["proof (prove)\nusing this:\n  \\<phi> i x \\<up>\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_result1 [t, i, x] \\<down>= 0", "by simp"], ["", "lemma r_result1_some_phi:\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"\\<phi> i x \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>= v", "using assms phi_def r_result1_Some'"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_phi [?i, ?x] \\<down>= ?v\n\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>= v", "by simp"], ["", "lemma r_result1_saturating':\n  assumes \"eval r_result1 [t, i, x] \\<down>= Suc v\"\n  shows \"eval r_result1 [t + d, i, x] \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [t + d, i, x] \\<down>= Suc v", "using assms r_result1 r_result_saturating r_phi''"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [?t, ?i, ?x] = eval r_result [?t, ?i, singleton_encode ?x]\n  eval r_result [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_result [?t + ?d, ?i, ?x] \\<down>= Suc ?v\n  eval r_phi [?i, ?x] = eval r_univ [?i, singleton_encode ?x]\n\ngoal (1 subgoal):\n 1. eval r_result1 [t + d, i, x] \\<down>= Suc v", "by simp"], ["", "lemma r_result1_saturating_the:\n  assumes \"the (eval r_result1 [t, i, x]) > 0\" and \"t' \\<ge> t\"\n  shows \"the (eval r_result1 [t', i, x]) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [t', i, x])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [t', i, x])", "from assms(1)"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1 [t, i, x])", "obtain v where \"eval r_result1 [t, i, x] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [t, i, x])\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using r_result1_bivalent_phi r_result1_diverg_phi"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [t, i, x])\n  \\<phi> ?i ?x \\<down>= ?v \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<or>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n  \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval r_result1 [t, i, x] \\<down>= Suc v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis inc_induct le_0_eq not_less_zero option.discI option.expand option.sel)"], ["proof (state)\nthis:\n  eval r_result1 [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [t', i, x])", "with assms"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1 [t, i, x])\n  t \\<le> t'\n  eval r_result1 [t, i, x] \\<down>= Suc v", "have \"eval r_result1 [t', i, x] \\<down>= Suc v\""], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [t, i, x])\n  t \\<le> t'\n  eval r_result1 [t, i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. eval r_result1 [t', i, x] \\<down>= Suc v", "using r_result1_saturating' le_Suc_ex"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [t, i, x])\n  t \\<le> t'\n  eval r_result1 [t, i, x] \\<down>= Suc v\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_result1 [?t + ?d, ?i, ?x] \\<down>= Suc ?v\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. eval r_result1 [t', i, x] \\<down>= Suc v", "by blast"], ["proof (state)\nthis:\n  eval r_result1 [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [t', i, x])", "then"], ["proof (chain)\npicking this:\n  eval r_result1 [t', i, x] \\<down>= Suc v", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result1 [t', i, x] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [t', i, x])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [t', i, x])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Greatest_bounded_Suc:\n  fixes P :: \"nat \\<Rightarrow> nat\"\n  shows \"(if P n > 0 then Suc n\n          else if \\<exists>j<n. P j > 0 then Suc (GREATEST j. j < n \\<and> P j > 0) else 0) =\n    (if \\<exists>j<Suc n. P j > 0 then Suc (GREATEST j. j < Suc n \\<and> P j > 0) else 0)\"\n      (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "proof (cases \"\\<exists>j<Suc n. P j > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j<Suc n. 0 < P j \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> (\\<exists>j<Suc n. 0 < P j) \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "case 1: True"], ["proof (state)\nthis:\n  \\<exists>j<Suc n. 0 < P j\n\ngoal (2 subgoals):\n 1. \\<exists>j<Suc n. 0 < P j \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> (\\<exists>j<Suc n. 0 < P j) \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "proof (cases \"P n > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "case True"], ["proof (state)\nthis:\n  0 < P n\n\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "then"], ["proof (chain)\npicking this:\n  0 < P n", "have \"(GREATEST j. j < Suc n \\<and> P j > 0) = n\""], ["proof (prove)\nusing this:\n  0 < P n\n\ngoal (1 subgoal):\n 1. (GREATEST j. j < Suc n \\<and> 0 < P j) = n", "using Greatest_equality[of \"\\<lambda>j. j < Suc n \\<and> P j > 0\"]"], ["proof (prove)\nusing this:\n  0 < P n\n  \\<lbrakk>?x < Suc n \\<and> 0 < P ?x;\n   \\<And>y. y < Suc n \\<and> 0 < P y \\<Longrightarrow> y \\<le> ?x\\<rbrakk>\n  \\<Longrightarrow> (GREATEST j. j < Suc n \\<and> 0 < P j) = ?x\n\ngoal (1 subgoal):\n 1. (GREATEST j. j < Suc n \\<and> 0 < P j) = n", "by simp"], ["proof (state)\nthis:\n  (GREATEST j. j < Suc n \\<and> 0 < P j) = n\n\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "moreover"], ["proof (state)\nthis:\n  (GREATEST j. j < Suc n \\<and> 0 < P j) = n\n\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "have \"?rhs = Suc (GREATEST j. j < Suc n \\<and> P j > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < Suc n \\<and> 0 < P j)", "using 1"], ["proof (prove)\nusing this:\n  \\<exists>j<Suc n. 0 < P j\n\ngoal (1 subgoal):\n 1. (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < Suc n \\<and> 0 < P j)", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  (GREATEST j. j < Suc n \\<and> 0 < P j) = n\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)", "have \"?rhs = Suc n\""], ["proof (prove)\nusing this:\n  (GREATEST j. j < Suc n \\<and> 0 < P j) = n\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n    Suc n", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc n\n\ngoal (2 subgoals):\n 1. 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n 2. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "then"], ["proof (chain)\npicking this:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc n\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "using True"], ["proof (prove)\nusing this:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc n\n  0 < P n\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "by simp"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> 0 < P n\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> 0 < P n", "have \"?lhs = Suc (GREATEST j. j < n \\<and> P j > 0)\""], ["proof (prove)\nusing this:\n  \\<not> 0 < P n\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < n \\<and> 0 < P j)", "using 1"], ["proof (prove)\nusing this:\n  \\<not> 0 < P n\n  \\<exists>j<Suc n. 0 < P j\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < n \\<and> 0 < P j)", "by (metis less_SucE)"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  Suc (GREATEST j. j < n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "moreover"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  Suc (GREATEST j. j < n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "have \"?rhs = Suc (GREATEST j. j < Suc n \\<and> P j > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < Suc n \\<and> 0 < P j)", "using 1"], ["proof (prove)\nusing this:\n  \\<exists>j<Suc n. 0 < P j\n\ngoal (1 subgoal):\n 1. (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n    Suc (GREATEST j. j < Suc n \\<and> 0 < P j)", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "moreover"], ["proof (state)\nthis:\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "have \"(GREATEST j. j < n \\<and> P j > 0) =\n        (GREATEST j. j < Suc n \\<and> P j > 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (GREATEST j. j < n \\<and> 0 < P j) =\n    (GREATEST j. j < Suc n \\<and> 0 < P j)", "using 1 False"], ["proof (prove)\nusing this:\n  \\<exists>j<Suc n. 0 < P j\n  \\<not> 0 < P n\n\ngoal (1 subgoal):\n 1. (GREATEST j. j < n \\<and> 0 < P j) =\n    (GREATEST j. j < Suc n \\<and> 0 < P j)", "by (metis less_SucI less_Suc_eq)"], ["proof (state)\nthis:\n  (GREATEST j. j < n \\<and> 0 < P j) =\n  (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> 0 < P n \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "ultimately"], ["proof (chain)\npicking this:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  Suc (GREATEST j. j < n \\<and> 0 < P j)\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n  (GREATEST j. j < n \\<and> 0 < P j) =\n  (GREATEST j. j < Suc n \\<and> 0 < P j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  Suc (GREATEST j. j < n \\<and> 0 < P j)\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0) =\n  Suc (GREATEST j. j < Suc n \\<and> 0 < P j)\n  (GREATEST j. j < n \\<and> 0 < P j) =\n  (GREATEST j. j < Suc n \\<and> 0 < P j)\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "by simp"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<Suc n. 0 < P j) \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<Suc n. 0 < P j) \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j<Suc n. 0 < P j)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<Suc n. 0 < P j) \\<Longrightarrow>\n    (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j<Suc n. 0 < P j)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j<Suc n. 0 < P j)\n\ngoal (1 subgoal):\n 1. (if 0 < P n then Suc n\n     else if \\<exists>j<n. 0 < P j\n          then Suc (GREATEST j. j < n \\<and> 0 < P j) else 0) =\n    (if \\<exists>j<Suc n. 0 < P j\n     then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)", "by auto"], ["proof (state)\nthis:\n  (if 0 < P n then Suc n\n   else if \\<exists>j<n. 0 < P j then Suc (GREATEST j. j < n \\<and> 0 < P j)\n        else 0) =\n  (if \\<exists>j<Suc n. 0 < P j\n   then Suc (GREATEST j. j < Suc n \\<and> 0 < P j) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For $n$, $i$, $x$, the next function simulates $\\varphi_i$ on all\nnon-empty prefixes of at most length $n$ of the list $x$ for at most $n$\nsteps. It returns the length of the longest such prefix for which $\\varphi_i$\nhalts, or zero if $\\varphi_i$ does not halt for any prefix.\\<close>"], ["", "definition \"r_delay_aux \\<equiv>\n  Pr 2 (r_constn 1 0)\n    (Cn 4 r_ifz\n      [Cn 4 r_result1\n        [Cn 4 r_length [Id 4 3], Id 4 2,\n         Cn 4 r_take [Cn 4 S [Id 4 0], Id 4 3]],\n       Id 4 1, Cn 4 S [Id 4 0]])\""], ["", "lemma r_delay_aux_prim: \"prim_recfn 3 r_delay_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3 r_delay_aux", "unfolding r_delay_aux_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 3\n     (Pr 2 (r_constn 1 0)\n       (Cn 4 r_ifz\n         [Cn 4 r_result1\n           [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n            Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]],\n          recf.Id 4 1, Cn 4 S [recf.Id 4 0]]))", "by simp_all"], ["", "lemma r_delay_aux_total: \"total r_delay_aux\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_delay_aux", "using  prim_recfn_total[OF r_delay_aux_prim]"], ["proof (prove)\nusing this:\n  Partial_Recursive.total r_delay_aux\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r_delay_aux", "."], ["", "lemma r_delay_aux:\n  assumes \"n \\<le> e_length x\"\n  shows \"eval r_delay_aux [n, i, x] \\<down>=\n   (if \\<exists>j<n. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\n    then Suc (GREATEST j.\n                 j < n \\<and>\n                 the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0)\n    else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "define z where \"z \\<equiv>\n    Cn 4 r_result1\n      [Cn 4 r_length [Id 4 3], Id 4 2, Cn 4 r_take [Cn 4 S [Id 4 0], Id 4 3]]\""], ["proof (state)\nthis:\n  z \\<equiv>\n  Cn 4 r_result1\n   [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n    Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]]\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "then"], ["proof (chain)\npicking this:\n  z \\<equiv>\n  Cn 4 r_result1\n   [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n    Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]]", "have z_recfn: \"recfn 4 z\""], ["proof (prove)\nusing this:\n  z \\<equiv>\n  Cn 4 r_result1\n   [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n    Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]]\n\ngoal (1 subgoal):\n 1. recfn 4 z", "by simp"], ["proof (state)\nthis:\n  recfn 4 z\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "have z: \"eval z [j, r, i, x] = eval r_result1 [e_length x, i, e_take (Suc j) x]\"\n      if \"j < e_length x\" for j r i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval z [j, r, i, x] = eval r_result1 [e_length x, i, e_take (Suc j) x]", "unfolding z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_result1\n       [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n        Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]])\n     [j, r, i, x] =\n    eval r_result1 [e_length x, i, e_take (Suc j) x]", "using that"], ["proof (prove)\nusing this:\n  j < e_length x\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_result1\n       [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n        Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]])\n     [j, r, i, x] =\n    eval r_result1 [e_length x, i, e_take (Suc j) x]", "by simp"], ["proof (state)\nthis:\n  ?j < e_length ?x \\<Longrightarrow>\n  eval z [?j, ?r, ?i, ?x] =\n  eval r_result1 [e_length ?x, ?i, e_take (Suc ?j) ?x]\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "define g where \"g \\<equiv> Cn 4 r_ifz [z, Id 4 1, Cn 4 S [Id 4 0]]\""], ["proof (state)\nthis:\n  g \\<equiv> Cn 4 r_ifz [z, recf.Id 4 1, Cn 4 S [recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "then"], ["proof (chain)\npicking this:\n  g \\<equiv> Cn 4 r_ifz [z, recf.Id 4 1, Cn 4 S [recf.Id 4 0]]", "have g: \"eval g [j, r, i, x] \\<down>=\n      (if the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0 then Suc j else r)\"\n      if \"j < e_length x\" for j r i x"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 4 r_ifz [z, recf.Id 4 1, Cn 4 S [recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval g [j, r, i, x] \\<down>=\n    (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc j else r)", "using that z prim_recfn_total z_recfn"], ["proof (prove)\nusing this:\n  g \\<equiv> Cn 4 r_ifz [z, recf.Id 4 1, Cn 4 S [recf.Id 4 0]]\n  j < e_length x\n  ?j < e_length ?x \\<Longrightarrow>\n  eval z [?j, ?r, ?i, ?x] =\n  eval r_result1 [e_length ?x, ?i, e_take (Suc ?j) ?x]\n  prim_recfn ?n ?f \\<Longrightarrow> Partial_Recursive.total ?f\n  recfn 4 z\n\ngoal (1 subgoal):\n 1. eval g [j, r, i, x] \\<down>=\n    (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc j else r)", "by simp"], ["proof (state)\nthis:\n  ?j < e_length ?x \\<Longrightarrow>\n  eval g [?j, ?r, ?i, ?x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc ?j) ?x])\n   then Suc ?j else ?r)\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "using assms"], ["proof (prove)\nusing this:\n  n \\<le> e_length x\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>=\n    (if \\<exists>j<n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> e_length x \\<Longrightarrow>\n    eval r_delay_aux [0, i, x] \\<down>=\n    (if \\<exists>j<0.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < 0 \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "case 0"], ["proof (state)\nthis:\n  0 \\<le> e_length x\n\ngoal (2 subgoals):\n 1. 0 \\<le> e_length x \\<Longrightarrow>\n    eval r_delay_aux [0, i, x] \\<down>=\n    (if \\<exists>j<0.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < 0 \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  0 \\<le> e_length x\n\ngoal (2 subgoals):\n 1. 0 \\<le> e_length x \\<Longrightarrow>\n    eval r_delay_aux [0, i, x] \\<down>=\n    (if \\<exists>j<0.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < 0 \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "have \"eval r_delay_aux [0, i, x] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay_aux [0, i, x] \\<down>= 0", "using eval_Pr_0 r_delay_aux_def r_delay_aux_prim r_constn"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (0 # ?xs) = eval ?f ?xs\n  r_delay_aux \\<equiv>\n  Pr 2 (r_constn 1 0)\n   (Cn 4 r_ifz\n     [Cn 4 r_result1\n       [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n        Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]],\n      recf.Id 4 1, Cn 4 S [recf.Id 4 0]])\n  prim_recfn 3 r_delay_aux\n  length ?xs = Suc ?n \\<Longrightarrow>\n  eval (r_constn ?n ?c) ?xs \\<down>= ?c\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [0, i, x] \\<down>= 0", "by (simp add: r_delay_aux_def)"], ["proof (state)\nthis:\n  eval r_delay_aux [0, i, x] \\<down>= 0\n\ngoal (2 subgoals):\n 1. 0 \\<le> e_length x \\<Longrightarrow>\n    eval r_delay_aux [0, i, x] \\<down>=\n    (if \\<exists>j<0.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < 0 \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)\n 2. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<le> e_length x\n  eval r_delay_aux [0, i, x] \\<down>= 0", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> e_length x\n  eval r_delay_aux [0, i, x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [0, i, x] \\<down>=\n    (if \\<exists>j<0.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < 0 \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [0, i, x] \\<down>=\n  (if \\<exists>j<0.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < 0 \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "case (Suc n)"], ["proof (state)\nthis:\n  n \\<le> e_length x \\<Longrightarrow>\n  eval r_delay_aux [n, i, x] \\<down>=\n  (if \\<exists>j<n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n  Suc n \\<le> e_length x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "let ?P = \"\\<lambda>j. the (eval r_result1 [e_length x, i, e_take (Suc j) x])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "have \"eval r_delay_aux [n, i, x] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>", "using Suc"], ["proof (prove)\nusing this:\n  n \\<le> e_length x \\<Longrightarrow>\n  eval r_delay_aux [n, i, x] \\<down>=\n  (if \\<exists>j<n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n  Suc n \\<le> e_length x\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [n, i, x] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [n, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "moreover"], ["proof (state)\nthis:\n  eval r_delay_aux [n, i, x] \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "have \"eval r_delay_aux [Suc n, i, x] =\n        eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] =\n    eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]", "unfolding r_delay_aux_def g_def z_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Pr 2 (r_constn 1 0)\n       (Cn 4 r_ifz\n         [Cn 4 r_result1\n           [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n            Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]],\n          recf.Id 4 1, Cn 4 S [recf.Id 4 0]]))\n     [Suc n, i, x] =\n    eval\n     (Pr 2 (r_constn 1 0)\n       (Cn 4 r_ifz\n         [Cn 4 r_result1\n           [Cn 4 r_length [recf.Id 4 3], recf.Id 4 2,\n            Cn 4 r_take [Cn 4 S [recf.Id 4 0], recf.Id 4 3]],\n          recf.Id 4 1, Cn 4 S [recf.Id 4 0]]))\n     [Suc n, i, x]", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [Suc n, i, x] =\n  eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "ultimately"], ["proof (chain)\npicking this:\n  eval r_delay_aux [n, i, x] \\<down>\n  eval r_delay_aux [Suc n, i, x] =\n  eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]", "have \"eval r_delay_aux [Suc n, i, x] =\n        eval g [n, the (eval r_delay_aux [n, i, x]), i, x]\""], ["proof (prove)\nusing this:\n  eval r_delay_aux [n, i, x] \\<down>\n  eval r_delay_aux [Suc n, i, x] =\n  eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] =\n    eval g [n, the (eval r_delay_aux [n, i, x]), i, x]", "using r_delay_aux_prim Suc eval_Pr_converg_Suc"], ["proof (prove)\nusing this:\n  eval r_delay_aux [n, i, x] \\<down>\n  eval r_delay_aux [Suc n, i, x] =\n  eval (Pr 2 (r_constn 1 0) g) [Suc n, i, x]\n  prim_recfn 3 r_delay_aux\n  n \\<le> e_length x \\<Longrightarrow>\n  eval r_delay_aux [n, i, x] \\<down>=\n  (if \\<exists>j<n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n  Suc n \\<le> e_length x\n  \\<lbrakk>recfn (Suc ?n) (Pr ?n ?f ?g); ?n = length ?xs;\n   eval (Pr ?n ?f ?g) (?x # ?xs) \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval (Pr ?n ?f ?g) (Suc ?x # ?xs) =\n                    eval ?g (?x # the (eval (Pr ?n ?f ?g) (?x # ?xs)) # ?xs)\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] =\n    eval g [n, the (eval r_delay_aux [n, i, x]), i, x]", "by (simp add: r_delay_aux_def g_def z_def numeral_3_eq_3)"], ["proof (state)\nthis:\n  eval r_delay_aux [Suc n, i, x] =\n  eval g [n, the (eval r_delay_aux [n, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "then"], ["proof (chain)\npicking this:\n  eval r_delay_aux [Suc n, i, x] =\n  eval g [n, the (eval r_delay_aux [n, i, x]), i, x]", "have \"eval r_delay_aux [Suc n, i, x] \\<down>=\n        (if ?P n > 0 then Suc n\n         else if \\<exists>j<n. ?P j > 0 then Suc (GREATEST j. j < n \\<and> ?P j > 0) else 0)\""], ["proof (prove)\nusing this:\n  eval r_delay_aux [Suc n, i, x] =\n  eval g [n, the (eval r_delay_aux [n, i, x]), i, x]\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] \\<down>=\n    (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x])\n     then Suc n\n     else if \\<exists>j<n.\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n          then Suc (GREATEST j.\n                       j < n \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x]))\n          else 0)", "using g Suc"], ["proof (prove)\nusing this:\n  eval r_delay_aux [Suc n, i, x] =\n  eval g [n, the (eval r_delay_aux [n, i, x]), i, x]\n  ?j < e_length ?x \\<Longrightarrow>\n  eval g [?j, ?r, ?i, ?x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc ?j) ?x])\n   then Suc ?j else ?r)\n  n \\<le> e_length x \\<Longrightarrow>\n  eval r_delay_aux [n, i, x] \\<down>=\n  (if \\<exists>j<n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n  Suc n \\<le> e_length x\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] \\<down>=\n    (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x])\n     then Suc n\n     else if \\<exists>j<n.\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n          then Suc (GREATEST j.\n                       j < n \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x]))\n          else 0)", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x]) then Suc n\n   else if \\<exists>j<n.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n        then Suc (GREATEST j.\n                     j < n \\<and>\n                     0 < the (eval r_result1\n                               [e_length x, i, e_take (Suc j) x]))\n        else 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "then"], ["proof (chain)\npicking this:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x]) then Suc n\n   else if \\<exists>j<n.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n        then Suc (GREATEST j.\n                     j < n \\<and>\n                     0 < the (eval r_result1\n                               [e_length x, i, e_take (Suc j) x]))\n        else 0)", "have \"eval r_delay_aux [Suc n, i, x] \\<down>=\n        (if \\<exists>j<Suc n. ?P j > 0 then Suc (GREATEST j. j < Suc n \\<and> ?P j > 0) else 0)\""], ["proof (prove)\nusing this:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x]) then Suc n\n   else if \\<exists>j<n.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n        then Suc (GREATEST j.\n                     j < n \\<and>\n                     0 < the (eval r_result1\n                               [e_length x, i, e_take (Suc j) x]))\n        else 0)\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] \\<down>=\n    (if \\<exists>j<Suc n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < Suc n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "using Greatest_bounded_Suc[where ?P=\"?P\"]"], ["proof (prove)\nusing this:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc n) x]) then Suc n\n   else if \\<exists>j<n.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n        then Suc (GREATEST j.\n                     j < n \\<and>\n                     0 < the (eval r_result1\n                               [e_length x, i, e_take (Suc j) x]))\n        else 0)\n  (if 0 < the (eval r_result1 [e_length x, i, e_take (Suc ?n) x])\n   then Suc ?n\n   else if \\<exists>j<?n.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n        then Suc (GREATEST j.\n                     j < ?n \\<and>\n                     0 < the (eval r_result1\n                               [e_length x, i, e_take (Suc j) x]))\n        else 0) =\n  (if \\<exists>j<Suc ?n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < Suc ?n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] \\<down>=\n    (if \\<exists>j<Suc n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < Suc n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if \\<exists>j<Suc n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < Suc n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>n \\<le> e_length x \\<Longrightarrow>\n                eval r_delay_aux [n, i, x] \\<down>=\n                (if \\<exists>j<n.\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])\n                 then Suc (GREATEST j.\n                              j < n \\<and>\n                              0 < the (eval r_result1\n  [e_length x, i, e_take (Suc j) x]))\n                 else 0);\n        Suc n \\<le> e_length x\\<rbrakk>\n       \\<Longrightarrow> eval r_delay_aux [Suc n, i, x] \\<down>=\n                         (if \\<exists>j<Suc n.\n                                0 < the (eval r_result1\n    [e_length x, i, e_take (Suc j) x])\n                          then Suc (GREATEST j.\n j < Suc n \\<and>\n 0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n                          else 0)", "then"], ["proof (chain)\npicking this:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if \\<exists>j<Suc n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < Suc n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)", "show ?case"], ["proof (prove)\nusing this:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if \\<exists>j<Suc n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < Suc n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal (1 subgoal):\n 1. eval r_delay_aux [Suc n, i, x] \\<down>=\n    (if \\<exists>j<Suc n.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < Suc n \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "by simp"], ["proof (state)\nthis:\n  eval r_delay_aux [Suc n, i, x] \\<down>=\n  (if \\<exists>j<Suc n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < Suc n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval r_delay_aux [n, i, x] \\<down>=\n  (if \\<exists>j<n.\n         0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n   then Suc (GREATEST j.\n                j < n \\<and>\n                0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n   else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next function simulates $\\varphi_i$ on all non-empty prefixes\nof a list $x$ of length $n$ for at most $n$ steps and outputs the length of\nthe longest prefix for which $\\varphi_i$ halts, or zero if $\\varphi_i$ does\nnot halt for any such prefix.\\<close>"], ["", "definition \"r_delay \\<equiv> Cn 2 r_delay_aux [Cn 2 r_length [Id 2 1], Id 2 0, Id 2 1]\""], ["", "lemma r_delay_recfn [simp]: \"recfn 2 r_delay\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_delay", "unfolding r_delay_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2 r_delay_aux\n       [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])", "by (simp add: r_delay_aux_prim)"], ["", "lemma r_delay:\n  \"eval r_delay [i, x] \\<down>=\n    (if \\<exists>j<e_length x. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\n     then Suc (GREATEST j.\n        j < e_length x \\<and> the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0)\n     else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_delay [i, x] \\<down>=\n    (if \\<exists>j<e_length x.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < e_length x \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "unfolding r_delay_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_delay_aux\n       [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>=\n    (if \\<exists>j<e_length x.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < e_length x \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "using r_delay_aux r_delay_aux_prim"], ["proof (prove)\nusing this:\n  ?n \\<le> e_length ?x \\<Longrightarrow>\n  eval r_delay_aux [?n, ?i, ?x] \\<down>=\n  (if \\<exists>j<?n.\n         0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n   then Suc (GREATEST j.\n                j < ?n \\<and>\n                0 < the (eval r_result1\n                          [e_length ?x, ?i, e_take (Suc j) ?x]))\n   else 0)\n  prim_recfn 3 r_delay_aux\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_delay_aux\n       [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, x] \\<down>=\n    (if \\<exists>j<e_length x.\n           0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n     then Suc (GREATEST j.\n                  j < e_length x \\<and>\n                  0 < the (eval r_result1\n                            [e_length x, i, e_take (Suc j) x]))\n     else 0)", "by simp"], ["", "definition \"delay i x \\<equiv> Some\n (if \\<exists>j<e_length x. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\n  then Suc (GREATEST j.\n    j < e_length x \\<and> the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0)\n  else 0)\""], ["", "lemma delay_in_R2: \"delay \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay \\<in> \\<R>\\<^sup>2", "using r_delay totalI2 R2I delay_def r_delay_recfn"], ["proof (prove)\nusing this:\n  eval r_delay [?i, ?x] \\<down>=\n  (if \\<exists>j<e_length ?x.\n         0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n   then Suc (GREATEST j.\n                j < e_length ?x \\<and>\n                0 < the (eval r_result1\n                          [e_length ?x, ?i, e_take (Suc j) ?x]))\n   else 0)\n  \\<lbrakk>recfn 2 ?f; \\<And>x y. eval ?f [x, y] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  \\<lbrakk>recfn 2 ?r; Partial_Recursive.total ?r;\n   \\<And>x y. eval ?r [x, y] = ?f x y\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> \\<R>\\<^sup>2\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n  recfn 2 r_delay\n\ngoal (1 subgoal):\n 1. delay \\<in> \\<R>\\<^sup>2", "by (metis (no_types, lifting) numeral_2_eq_2 option.simps(3))"], ["", "lemma delay_le_length: \"the (delay i x) \\<le> e_length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (delay i x) \\<le> e_length x", "proof (cases \"\\<exists>j<e_length x. the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "case True"], ["proof (state)\nthis:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "let ?P = \"\\<lambda>j. j < e_length x \\<and> the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "from True"], ["proof (chain)\npicking this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])", "have \"\\<exists>j. ?P j\""], ["proof (prove)\nusing this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (1 subgoal):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])", "by simp"], ["proof (state)\nthis:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "moreover"], ["proof (state)\nthis:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "have \"\\<And>y. ?P y \\<Longrightarrow> y \\<le> e_length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < e_length x \\<and>\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc y) x]) \\<Longrightarrow>\n       y \\<le> e_length x", "by simp"], ["proof (state)\nthis:\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x", "have \"?P (Greatest ?P)\""], ["proof (prove)\nusing this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length x \\<and>\n        0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n    < e_length x \\<and>\n    0 < the (eval r_result1\n              [e_length x, i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length x \\<and>\n                         0 < the (eval r_result1\n                                   [e_length x, i, e_take (Suc j) x])))\n                x])", "using GreatestI_ex_nat[where ?P=\"?P\"]"], ["proof (prove)\nusing this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n  \\<lbrakk>\\<exists>k<e_length x.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc k) x]);\n   \\<And>y.\n      y < e_length x \\<and>\n      0 < the (eval r_result1\n                [e_length x, i, e_take (Suc y) x]) \\<Longrightarrow>\n      y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (GREATEST j.\n                        j < e_length x \\<and>\n                        0 < the (eval r_result1\n                                  [e_length x, i, e_take (Suc j) x]))\n                    < e_length x \\<and>\n                    0 < the (eval r_result1\n                              [e_length x, i,\n                               e_take\n                                (Suc (GREATEST j.\n   j < e_length x \\<and>\n   0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])))\n                                x])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length x \\<and>\n        0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n    < e_length x \\<and>\n    0 < the (eval r_result1\n              [e_length x, i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length x \\<and>\n                         0 < the (eval r_result1\n                                   [e_length x, i, e_take (Suc j) x])))\n                x])", "by blast"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "then"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])", "have \"Greatest ?P < e_length x\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length x \\<and>\n        0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n    < e_length x", "by simp"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "moreover"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "have \"delay i x \\<down>= Suc (Greatest ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delay i x \\<down>=\n    Suc (GREATEST j.\n            j < e_length x \\<and>\n            0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "using delay_def True"], ["proof (prove)\nusing this:\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (1 subgoal):\n 1. delay i x \\<down>=\n    Suc (GREATEST j.\n            j < e_length x \\<and>\n            0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "by simp"], ["proof (state)\nthis:\n  delay i x \\<down>=\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (2 subgoals):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc j) x]) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x\n 2. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "ultimately"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x\n  delay i x \\<down>=\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x\n  delay i x \\<down>=\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. the (delay i x) \\<le> e_length x", "by auto"], ["proof (state)\nthis:\n  the (delay i x) \\<le> e_length x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    the (delay i x) \\<le> e_length x", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. the (delay i x) \\<le> e_length x", "using delay_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. the (delay i x) \\<le> e_length x", "by auto"], ["proof (state)\nthis:\n  the (delay i x) \\<le> e_length x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma e_take_delay_init:\n  assumes \"f \\<in> \\<R>\" and \"the (delay i (f \\<triangleright> n)) > 0\"\n  shows \"e_take (the (delay i (f \\<triangleright> n))) (f \\<triangleright> n) = f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_take (the (delay i (f \\<triangleright> n))) (f \\<triangleright> n) =\n    f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)", "using assms e_take_init[of f _ n] length_init[of f n] delay_le_length[of i \"f \\<triangleright> n\"]"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  0 < the (delay i (f \\<triangleright> n))\n  \\<lbrakk>f \\<in> \\<R>; ?k < Suc n\\<rbrakk>\n  \\<Longrightarrow> e_take (Suc ?k) (f \\<triangleright> n) =\n                    f \\<triangleright> ?k\n  e_length (f \\<triangleright> n) = Suc n\n  the (delay i (f \\<triangleright> n)) \\<le> e_length (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. e_take (the (delay i (f \\<triangleright> n))) (f \\<triangleright> n) =\n    f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)", "by (metis One_nat_def Suc_le_lessD Suc_pred)"], ["", "lemma delay_gr0_converg:\n  assumes \"the (delay i x) > 0\"\n  shows \"\\<phi> i (e_take (the (delay i x)) x) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "let ?P = \"\\<lambda>j. j < e_length x \\<and> the (eval r_result1 [e_length x, i, e_take (Suc j) x]) > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "have \"\\<exists>j. ?P j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j<e_length x.\n       0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    False", "assume \"\\<not> (\\<exists>j. ?P j)\""], ["proof (state)\nthis:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "have \"delay i x \\<down>= 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. delay i x \\<down>= 0", "using delay_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>j<e_length x.\n             0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. delay i x \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  delay i x \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>j<e_length x.\n               0 < the (eval r_result1\n                         [e_length x, i,\n                          e_take (Suc j) x])) \\<Longrightarrow>\n    False", "with assms"], ["proof (chain)\npicking this:\n  0 < the (delay i x)\n  delay i x \\<down>= 0", "show False"], ["proof (prove)\nusing this:\n  0 < the (delay i x)\n  delay i x \\<down>= 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])", "have d: \"the (delay i x) = Suc (Greatest ?P)\""], ["proof (prove)\nusing this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n\ngoal (1 subgoal):\n 1. the (delay i x) =\n    Suc (GREATEST j.\n            j < e_length x \\<and>\n            0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "using delay_def"], ["proof (prove)\nusing this:\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. the (delay i x) =\n    Suc (GREATEST j.\n            j < e_length x \\<and>\n            0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))", "by simp"], ["proof (state)\nthis:\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "moreover"], ["proof (state)\nthis:\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "have \"\\<And>y. ?P y \\<Longrightarrow> y \\<le> e_length x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < e_length x \\<and>\n       0 < the (eval r_result1\n                 [e_length x, i, e_take (Suc y) x]) \\<Longrightarrow>\n       y \\<le> e_length x", "by simp"], ["proof (state)\nthis:\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "ultimately"], ["proof (chain)\npicking this:\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x", "have \"?P (Greatest ?P)\""], ["proof (prove)\nusing this:\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length x \\<and>\n        0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n    < e_length x \\<and>\n    0 < the (eval r_result1\n              [e_length x, i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length x \\<and>\n                         0 < the (eval r_result1\n                                   [e_length x, i, e_take (Suc j) x])))\n                x])", "using \\<open>\\<exists>j. ?P j\\<close> GreatestI_ex_nat[where ?P=\"?P\"]"], ["proof (prove)\nusing this:\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  ?y < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i, e_take (Suc ?y) x]) \\<Longrightarrow>\n  ?y \\<le> e_length x\n  \\<exists>j<e_length x.\n     0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])\n  \\<lbrakk>\\<exists>k<e_length x.\n              0 < the (eval r_result1 [e_length x, i, e_take (Suc k) x]);\n   \\<And>y.\n      y < e_length x \\<and>\n      0 < the (eval r_result1\n                [e_length x, i, e_take (Suc y) x]) \\<Longrightarrow>\n      y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (GREATEST j.\n                        j < e_length x \\<and>\n                        0 < the (eval r_result1\n                                  [e_length x, i, e_take (Suc j) x]))\n                    < e_length x \\<and>\n                    0 < the (eval r_result1\n                              [e_length x, i,\n                               e_take\n                                (Suc (GREATEST j.\n   j < e_length x \\<and>\n   0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x])))\n                                x])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length x \\<and>\n        0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n    < e_length x \\<and>\n    0 < the (eval r_result1\n              [e_length x, i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length x \\<and>\n                         0 < the (eval r_result1\n                                   [e_length x, i, e_take (Suc j) x])))\n                x])", "by blast"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "then"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])", "have \"the (eval r_result1 [e_length x, i, e_take (Suc (Greatest ?P)) x]) > 0\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length x \\<and>\n      0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n  < e_length x \\<and>\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [e_length x, i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length x \\<and>\n                         0 < the (eval r_result1\n                                   [e_length x, i, e_take (Suc j) x])))\n                x])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "then"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])", "have \"the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x]) > 0\""], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])", "using d"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [e_length x, i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length x \\<and>\n                       0 < the (eval r_result1\n                                 [e_length x, i, e_take (Suc j) x])))\n              x])\n  the (delay i x) =\n  Suc (GREATEST j.\n          j < e_length x \\<and>\n          0 < the (eval r_result1 [e_length x, i, e_take (Suc j) x]))\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "then"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "using r_result1_diverg_phi"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [e_length x, i, e_take (the (delay i x)) x])\n  \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<phi> i (e_take (the (delay i x)) x) \\<down>", "by fastforce"], ["proof (state)\nthis:\n  \\<phi> i (e_take (the (delay i x)) x) \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delay_unbounded:\n  fixes n :: nat\n  assumes \"f \\<in> \\<R>\" and \"\\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\"\n  shows \"\\<exists>m. the (delay i (f \\<triangleright> m)) > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "from assms"], ["proof (chain)\npicking this:\n  f \\<in> \\<R>\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>", "have \"\\<exists>t. the (eval r_result1 [t, i, f \\<triangleright> n]) > 0\""], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>t. 0 < the (eval r_result1 [t, i, f \\<triangleright> n])", "using r_result1_converg_phi"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\n  \\<phi> ?i ?x \\<down>= ?v \\<Longrightarrow>\n  \\<exists>t.\n     (\\<forall>t'\\<ge>t. eval r_result1 [t', ?i, ?x] \\<down>= Suc ?v) \\<and>\n     (\\<forall>t'<t. eval r_result1 [t', ?i, ?x] \\<down>= 0)\n\ngoal (1 subgoal):\n 1. \\<exists>t. 0 < the (eval r_result1 [t, i, f \\<triangleright> n])", "by (metis le_refl option.exhaust_sel option.sel zero_less_Suc)"], ["proof (state)\nthis:\n  \\<exists>t. 0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "then"], ["proof (chain)\npicking this:\n  \\<exists>t. 0 < the (eval r_result1 [t, i, f \\<triangleright> n])", "obtain t where t: \"the (eval r_result1 [t, i, f \\<triangleright> n]) > 0\""], ["proof (prove)\nusing this:\n  \\<exists>t. 0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        0 < the (eval r_result1\n                  [t, i, f \\<triangleright> n]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "let ?m = \"max n t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "have \"Suc ?m \\<ge> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> Suc (max n t)", "by simp"], ["proof (state)\nthis:\n  t \\<le> Suc (max n t)\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "have m: \"the (eval r_result1 [Suc ?m, i, f \\<triangleright> n]) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "let ?w = \"eval r_result1 [t, i, f \\<triangleright> n]\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "obtain v where v: \"?w \\<down>= Suc v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval r_result1 [t, i, f \\<triangleright> n] \\<down>=\n        Suc v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using t assms(2) r_result1_bivalent_phi"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\n  \\<phi> ?i ?x \\<down>= ?v \\<Longrightarrow>\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<or>\n  eval r_result1 [?t, ?i, ?x] \\<down>= 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        eval r_result1 [t, i, f \\<triangleright> n] \\<down>=\n        Suc v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  eval r_result1 [t, i, f \\<triangleright> n] \\<down>= Suc v\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "have \"eval r_result1 [Suc ?m, i, f \\<triangleright> n] = ?w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n    eval r_result1 [t, i, f \\<triangleright> n]", "using v t r_result1_saturating' \\<open>Suc ?m \\<ge> t\\<close> le_Suc_ex"], ["proof (prove)\nusing this:\n  eval r_result1 [t, i, f \\<triangleright> n] \\<down>= Suc v\n  0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n  eval r_result1 [?t, ?i, ?x] \\<down>= Suc ?v \\<Longrightarrow>\n  eval r_result1 [?t + ?d, ?i, ?x] \\<down>= Suc ?v\n  t \\<le> Suc (max n t)\n  ?k \\<le> ?l \\<Longrightarrow> \\<exists>n. ?l = ?k + n\n\ngoal (1 subgoal):\n 1. eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n    eval r_result1 [t, i, f \\<triangleright> n]", "by fastforce"], ["proof (state)\nthis:\n  eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n  eval r_result1 [t, i, f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "then"], ["proof (chain)\npicking this:\n  eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n  eval r_result1 [t, i, f \\<triangleright> n]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n  eval r_result1 [t, i, f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "using t"], ["proof (prove)\nusing this:\n  eval r_result1 [Suc (max n t), i, f \\<triangleright> n] =\n  eval r_result1 [t, i, f \\<triangleright> n]\n  0 < the (eval r_result1 [t, i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "let ?x = \"f \\<triangleright> ?m\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "have \"the (delay i ?x) > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "let ?P = \"\\<lambda>j. j < e_length ?x \\<and> the (eval r_result1 [e_length ?x, i, e_take (Suc j) ?x]) > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "have \"e_length ?x = Suc ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (f \\<triangleright> max n t) = Suc (max n t)", "by simp"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> max n t) = Suc (max n t)\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "moreover"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> max n t) = Suc (max n t)\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "have \"e_take (Suc n) ?x = f \\<triangleright> n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n", "using assms(1) e_take_init"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<lbrakk>?f \\<in> \\<R>; ?k < Suc ?n\\<rbrakk>\n  \\<Longrightarrow> e_take (Suc ?k) (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright> ?k\n\ngoal (1 subgoal):\n 1. e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n", "by auto"], ["proof (state)\nthis:\n  e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "ultimately"], ["proof (chain)\npicking this:\n  e_length (f \\<triangleright> max n t) = Suc (max n t)\n  e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n", "have \"?P n\""], ["proof (prove)\nusing this:\n  e_length (f \\<triangleright> max n t) = Suc (max n t)\n  e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n\n\ngoal (1 subgoal):\n 1. n < e_length (f \\<triangleright> max n t) \\<and>\n    0 < the (eval r_result1\n              [e_length (f \\<triangleright> max n t), i,\n               e_take (Suc n) (f \\<triangleright> max n t)])", "using m"], ["proof (prove)\nusing this:\n  e_length (f \\<triangleright> max n t) = Suc (max n t)\n  e_take (Suc n) (f \\<triangleright> max n t) = f \\<triangleright> n\n  0 < the (eval r_result1 [Suc (max n t), i, f \\<triangleright> n])\n\ngoal (1 subgoal):\n 1. n < e_length (f \\<triangleright> max n t) \\<and>\n    0 < the (eval r_result1\n              [e_length (f \\<triangleright> max n t), i,\n               e_take (Suc n) (f \\<triangleright> max n t)])", "by simp"], ["proof (state)\nthis:\n  n < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc n) (f \\<triangleright> max n t)])\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "have \"\\<And>y. ?P y \\<Longrightarrow> y \\<le> e_length ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < e_length (f \\<triangleright> max n t) \\<and>\n       0 < the (eval r_result1\n                 [e_length (f \\<triangleright> max n t), i,\n                  e_take (Suc y)\n                   (f \\<triangleright> max n t)]) \\<Longrightarrow>\n       y \\<le> e_length (f \\<triangleright> max n t)", "by simp"], ["proof (state)\nthis:\n  ?y < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> max n t)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> max n t)\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "with \\<open>?P n\\<close>"], ["proof (chain)\npicking this:\n  n < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc n) (f \\<triangleright> max n t)])\n  ?y < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> max n t)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> max n t)", "have \"n \\<le> (Greatest ?P)\""], ["proof (prove)\nusing this:\n  n < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc n) (f \\<triangleright> max n t)])\n  ?y < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> max n t)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> max n t)\n\ngoal (1 subgoal):\n 1. n \\<le> (GREATEST j.\n                j < e_length (f \\<triangleright> max n t) \\<and>\n                0 < the (eval r_result1\n                          [e_length (f \\<triangleright> max n t), i,\n                           e_take (Suc j) (f \\<triangleright> max n t)]))", "using Greatest_le_nat[of ?P n \"e_length ?x\"]"], ["proof (prove)\nusing this:\n  n < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc n) (f \\<triangleright> max n t)])\n  ?y < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> max n t)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> max n t)\n  \\<lbrakk>n < e_length (f \\<triangleright> max n t) \\<and>\n           0 < the (eval r_result1\n                     [e_length (f \\<triangleright> max n t), i,\n                      e_take (Suc n) (f \\<triangleright> max n t)]);\n   \\<And>y.\n      y < e_length (f \\<triangleright> max n t) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> max n t), i,\n                 e_take (Suc y)\n                  (f \\<triangleright> max n t)]) \\<Longrightarrow>\n      y \\<le> e_length (f \\<triangleright> max n t)\\<rbrakk>\n  \\<Longrightarrow> n \\<le> (GREATEST j.\n                                j < e_length\n                                     (f \\<triangleright> max n t) \\<and>\n                                0 < the (eval r_result1\n    [e_length (f \\<triangleright> max n t), i,\n     e_take (Suc j) (f \\<triangleright> max n t)]))\n\ngoal (1 subgoal):\n 1. n \\<le> (GREATEST j.\n                j < e_length (f \\<triangleright> max n t) \\<and>\n                0 < the (eval r_result1\n                          [e_length (f \\<triangleright> max n t), i,\n                           e_take (Suc j) (f \\<triangleright> max n t)]))", "by simp"], ["proof (state)\nthis:\n  n \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> max n t) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> max n t), i,\n                         e_take (Suc j) (f \\<triangleright> max n t)]))\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "moreover"], ["proof (state)\nthis:\n  n \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> max n t) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> max n t), i,\n                         e_take (Suc j) (f \\<triangleright> max n t)]))\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "have \"the (delay i ?x) = Suc (Greatest ?P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> max n t)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> max n t) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> max n t), i,\n                       e_take (Suc j) (f \\<triangleright> max n t)]))", "using delay_def \\<open>?P n\\<close>"], ["proof (prove)\nusing this:\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n  n < e_length (f \\<triangleright> max n t) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> max n t), i,\n             e_take (Suc n) (f \\<triangleright> max n t)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> max n t)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> max n t) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> max n t), i,\n                       e_take (Suc j) (f \\<triangleright> max n t)]))", "by auto"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> max n t)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> max n t) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> max n t), i,\n                     e_take (Suc j) (f \\<triangleright> max n t)]))\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "ultimately"], ["proof (chain)\npicking this:\n  n \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> max n t) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> max n t), i,\n                         e_take (Suc j) (f \\<triangleright> max n t)]))\n  the (delay i (f \\<triangleright> max n t)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> max n t) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> max n t), i,\n                     e_take (Suc j) (f \\<triangleright> max n t)]))", "show ?thesis"], ["proof (prove)\nusing this:\n  n \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> max n t) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> max n t), i,\n                         e_take (Suc j) (f \\<triangleright> max n t)]))\n  the (delay i (f \\<triangleright> max n t)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> max n t) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> max n t), i,\n                     e_take (Suc j) (f \\<triangleright> max n t)]))\n\ngoal (1 subgoal):\n 1. n < the (delay i (f \\<triangleright> max n t))", "by simp"], ["proof (state)\nthis:\n  n < the (delay i (f \\<triangleright> max n t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n < the (delay i (f \\<triangleright> max n t))\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "then"], ["proof (chain)\npicking this:\n  n < the (delay i (f \\<triangleright> max n t))", "show ?thesis"], ["proof (prove)\nusing this:\n  n < the (delay i (f \\<triangleright> max n t))\n\ngoal (1 subgoal):\n 1. \\<exists>m. n < the (delay i (f \\<triangleright> m))", "by auto"], ["proof (state)\nthis:\n  \\<exists>m. n < the (delay i (f \\<triangleright> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delay_monotone:\n  assumes \"f \\<in> \\<R>\" and \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"the (delay i (f \\<triangleright> n\\<^sub>1)) \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\"\n    (is \"the (delay i ?x1) \\<le> the (delay i ?x2)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "proof (cases \"the (delay i (f \\<triangleright> n\\<^sub>1)) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) = 0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\n 2. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "case True"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) = 0\n\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) = 0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\n 2. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) = 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "by simp"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1))\n  \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "case False"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "let ?P1 = \"\\<lambda>j. j < e_length ?x1 \\<and> the (eval r_result1 [e_length ?x1, i, e_take (Suc j) ?x1]) > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "let ?P2 = \"\\<lambda>j. j < e_length ?x2 \\<and> the (eval r_result1 [e_length ?x2, i, e_take (Suc j) ?x2]) > 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "from False"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq> 0", "have d1: \"the (delay i ?x1) = Suc (Greatest ?P1)\" \"\\<exists>j. ?P1 j\""], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])) &&&\n    \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n       0 < the (eval r_result1\n                 [e_length (f \\<triangleright> n\\<^sub>1), i,\n                  e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])", "using delay_def option.collapse"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq> 0\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n  ?option \\<noteq> None \\<Longrightarrow> Some (the ?option) = ?option\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])) &&&\n    \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n       0 < the (eval r_result1\n                 [e_length (f \\<triangleright> n\\<^sub>1), i,\n                  e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])", "by fastforce+"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "moreover"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "have \"\\<And>y. ?P1 y \\<Longrightarrow> y \\<le> e_length ?x1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n       0 < the (eval r_result1\n                 [e_length (f \\<triangleright> n\\<^sub>1), i,\n                  e_take (Suc y)\n                   (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n       y \\<le> e_length (f \\<triangleright> n\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  ?y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>1)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "ultimately"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>1)", "have *: \"?P1 (Greatest ?P1)\""], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n    0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>1), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>1)])", "using GreatestI_ex_nat[of ?P1]"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>1)\n  \\<lbrakk>\\<exists>k<e_length (f \\<triangleright> n\\<^sub>1).\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>1), i,\n                         e_take (Suc k) (f \\<triangleright> n\\<^sub>1)]);\n   \\<And>y.\n      y < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc y)\n                  (f \\<triangleright> n\\<^sub>1)]) \\<Longrightarrow>\n      y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> (GREATEST j.\n                        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                        0 < the (eval r_result1\n                                  [e_length (f \\<triangleright> n\\<^sub>1),\n                                   i, e_take (Suc j)\n (f \\<triangleright> n\\<^sub>1)]))\n                    < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                    0 < the (eval r_result1\n                              [e_length (f \\<triangleright> n\\<^sub>1), i,\n                               e_take\n                                (Suc (GREATEST j.\n   j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n   0 < the (eval r_result1\n             [e_length (f \\<triangleright> n\\<^sub>1), i,\n              e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n                                (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n    0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>1), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>1)])", "by blast"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "let ?j = \"Greatest ?P1\""], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "from *"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])", "have \"?j < e_length ?x1\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "then"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1)", "have 1: \"e_take (Suc ?j) ?x1 = e_take (Suc ?j) ?x2\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1)\n\ngoal (1 subgoal):\n 1. e_take\n     (Suc (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>1), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n     (f \\<triangleright> n\\<^sub>1) =\n    e_take\n     (Suc (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>1), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n     (f \\<triangleright> n\\<^sub>2)", "using assms e_take_init"], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1)\n  f \\<in> \\<R>\n  n\\<^sub>1 \\<le> n\\<^sub>2\n  \\<lbrakk>?f \\<in> \\<R>; ?k < Suc ?n\\<rbrakk>\n  \\<Longrightarrow> e_take (Suc ?k) (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright> ?k\n\ngoal (1 subgoal):\n 1. e_take\n     (Suc (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>1), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n     (f \\<triangleright> n\\<^sub>1) =\n    e_take\n     (Suc (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>1), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n     (f \\<triangleright> n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>1) =\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "from *"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])", "have 2: \"?j < e_length ?x2\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>2)", "using assms(2)"], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "with 1 *"], ["proof (chain)\npicking this:\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>1) =\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>2)\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2)", "have \"the (eval r_result1 [e_length ?x1, i, e_take (Suc ?j) ?x2]) > 0\""], ["proof (prove)\nusing this:\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>1) =\n  e_take\n   (Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>1), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])))\n   (f \\<triangleright> n\\<^sub>2)\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>1)])\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>1), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>2)])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "moreover"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "have \"e_length ?x1 \\<le> e_length ?x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (f \\<triangleright> n\\<^sub>1)\n    \\<le> e_length (f \\<triangleright> n\\<^sub>2)", "using assms(2)"], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. e_length (f \\<triangleright> n\\<^sub>1)\n    \\<le> e_length (f \\<triangleright> n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> n\\<^sub>1)\n  \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "ultimately"], ["proof (chain)\npicking this:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  e_length (f \\<triangleright> n\\<^sub>1)\n  \\<le> e_length (f \\<triangleright> n\\<^sub>2)", "have \"the (eval r_result1 [e_length ?x2, i, e_take (Suc ?j) ?x2]) > 0\""], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  e_length (f \\<triangleright> n\\<^sub>1)\n  \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>2), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>2)])", "using r_result1_saturating_the"], ["proof (prove)\nusing this:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>1), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  e_length (f \\<triangleright> n\\<^sub>1)\n  \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n  \\<lbrakk>0 < the (eval r_result1 [?t, ?i, ?x]); ?t \\<le> ?t'\\<rbrakk>\n  \\<Longrightarrow> 0 < the (eval r_result1 [?t', ?i, ?x])\n\ngoal (1 subgoal):\n 1. 0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>2), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>2)])", "by simp"], ["proof (state)\nthis:\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "with 2"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2)\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])", "have \"?P2 ?j\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2)\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n    0 < the (eval r_result1\n              [e_length (f \\<triangleright> n\\<^sub>2), i,\n               e_take\n                (Suc (GREATEST j.\n                         j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                         0 < the (eval r_result1\n                                   [e_length (f \\<triangleright> n\\<^sub>1),\n                                    i, e_take (Suc j)\n  (f \\<triangleright> n\\<^sub>1)])))\n                (f \\<triangleright> n\\<^sub>2)])", "by simp"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "then"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])", "have d2: \"the (delay i ?x2) = Suc (Greatest ?P2)\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>2)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>2), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))", "using delay_def"], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>2)) =\n    Suc (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>2), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))", "by auto"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>2)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>2), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "have \"\\<And>y. ?P2 y \\<Longrightarrow> y \\<le> e_length ?x2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n       0 < the (eval r_result1\n                 [e_length (f \\<triangleright> n\\<^sub>2), i,\n                  e_take (Suc y)\n                   (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n       y \\<le> e_length (f \\<triangleright> n\\<^sub>2)", "by simp"], ["proof (state)\nthis:\n  ?y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "with \\<open>?P2 ?j\\<close>"], ["proof (chain)\npicking this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>2)", "have \"?j \\<le> (Greatest ?P2)\""], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>2), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))", "using Greatest_le_nat[of ?P2]"], ["proof (prove)\nusing this:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take\n              (Suc (GREATEST j.\n                       j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n                       0 < the (eval r_result1\n                                 [e_length (f \\<triangleright> n\\<^sub>1),\n                                  i, e_take (Suc j)\n(f \\<triangleright> n\\<^sub>1)])))\n              (f \\<triangleright> n\\<^sub>2)])\n  ?y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n  0 < the (eval r_result1\n            [e_length (f \\<triangleright> n\\<^sub>2), i,\n             e_take (Suc ?y)\n              (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n  ?y \\<le> e_length (f \\<triangleright> n\\<^sub>2)\n  \\<lbrakk>?k < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n           0 < the (eval r_result1\n                     [e_length (f \\<triangleright> n\\<^sub>2), i,\n                      e_take (Suc ?k) (f \\<triangleright> n\\<^sub>2)]);\n   \\<And>y.\n      y < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>2), i,\n                 e_take (Suc y)\n                  (f \\<triangleright> n\\<^sub>2)]) \\<Longrightarrow>\n      y \\<le> ?b\\<rbrakk>\n  \\<Longrightarrow> ?k \\<le> (GREATEST j.\n                                 j < e_length\n(f \\<triangleright> n\\<^sub>2) \\<and>\n                                 0 < the\n(eval r_result1\n  [e_length (f \\<triangleright> n\\<^sub>2), i,\n   e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n\ngoal (1 subgoal):\n 1. (GREATEST j.\n        j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n        0 < the (eval r_result1\n                  [e_length (f \\<triangleright> n\\<^sub>1), i,\n                   e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n    \\<le> (GREATEST j.\n              j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n              0 < the (eval r_result1\n                        [e_length (f \\<triangleright> n\\<^sub>2), i,\n                         e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))", "by blast"], ["proof (state)\nthis:\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<le> (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>2), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1)) \\<noteq>\n    0 \\<Longrightarrow>\n    the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "with d1 d2"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n  the (delay i (f \\<triangleright> n\\<^sub>2)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>2), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<le> (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>2), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n\\<^sub>1)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>1), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<exists>j<e_length (f \\<triangleright> n\\<^sub>1).\n     0 < the (eval r_result1\n               [e_length (f \\<triangleright> n\\<^sub>1), i,\n                e_take (Suc j) (f \\<triangleright> n\\<^sub>1)])\n  the (delay i (f \\<triangleright> n\\<^sub>2)) =\n  Suc (GREATEST j.\n          j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n          0 < the (eval r_result1\n                    [e_length (f \\<triangleright> n\\<^sub>2), i,\n                     e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n  (GREATEST j.\n      j < e_length (f \\<triangleright> n\\<^sub>1) \\<and>\n      0 < the (eval r_result1\n                [e_length (f \\<triangleright> n\\<^sub>1), i,\n                 e_take (Suc j) (f \\<triangleright> n\\<^sub>1)]))\n  \\<le> (GREATEST j.\n            j < e_length (f \\<triangleright> n\\<^sub>2) \\<and>\n            0 < the (eval r_result1\n                      [e_length (f \\<triangleright> n\\<^sub>2), i,\n                       e_take (Suc j) (f \\<triangleright> n\\<^sub>2)]))\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n\\<^sub>1))\n    \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))", "by simp"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n\\<^sub>1))\n  \\<le> the (delay i (f \\<triangleright> n\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma delay_unbounded_monotone:\n  fixes n :: nat\n  assumes \"f \\<in> \\<R>\" and \"\\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\"\n  shows \"\\<exists>m\\<^sub>0. \\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "from assms delay_unbounded"], ["proof (chain)\npicking this:\n  f \\<in> \\<R>\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<forall>n. \\<phi> ?i (?f \\<triangleright> n) \\<down>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m. ?n < the (delay ?i (?f \\<triangleright> m))", "obtain m\\<^sub>0 where \"the (delay i (f \\<triangleright> m\\<^sub>0)) > n\""], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<forall>n. \\<phi> i (f \\<triangleright> n) \\<down>\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<forall>n. \\<phi> ?i (?f \\<triangleright> n) \\<down>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m. ?n < the (delay ?i (?f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>0.\n        n < the (delay i (f \\<triangleright> m\\<^sub>0)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n < the (delay i (f \\<triangleright> m\\<^sub>0))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "then"], ["proof (chain)\npicking this:\n  n < the (delay i (f \\<triangleright> m\\<^sub>0))", "have \"\\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\""], ["proof (prove)\nusing this:\n  n < the (delay i (f \\<triangleright> m\\<^sub>0))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "using assms(1) delay_monotone order.strict_trans2"], ["proof (prove)\nusing this:\n  n < the (delay i (f \\<triangleright> m\\<^sub>0))\n  f \\<in> \\<R>\n  \\<lbrakk>?f \\<in> \\<R>; ?n\\<^sub>1 \\<le> ?n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> the (delay ?i (?f \\<triangleright> ?n\\<^sub>1))\n                    \\<le> the (delay ?i (?f \\<triangleright> ?n\\<^sub>2))\n  \\<lbrakk>?a < ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a < ?c\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))", "by auto"], ["proof (state)\nthis:\n  \\<exists>m\\<^sub>0.\n     \\<forall>m\\<ge>m\\<^sub>0. n < the (delay i (f \\<triangleright> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we can define a function that simulates an arbitrary strategy\n$\\varphi_i$ in a delayed way. The parameter $d$ is the default hypothesis for\nwhen $\\varphi_i$ does not halt within the time bound for any prefix.\\<close>"], ["", "definition r_totalizer :: \"nat \\<Rightarrow> recf\" where\n  \"r_totalizer d \\<equiv>\n     Cn 2\n      (r_lifz\n        (r_constn 1 d)\n        (Cn 2 r_phi\n          [Id 2 0, Cn 2 r_take [Cn 2 r_delay [Id 2 0, Id 2 1], Id 2 1]]))\n      [Cn 2 r_delay [Id 2 0, Id 2 1], Id 2 0, Id 2 1]\""], ["", "lemma r_totalizer_recfn: \"recfn 2 (r_totalizer d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_totalizer d)", "unfolding r_totalizer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2\n       (r_lifz (r_constn 1 d)\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n       [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])", "by simp"], ["", "lemma r_totalizer:\n  \"eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d else \\<phi> i (e_take (the (delay i x)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "let ?i = \"Cn 2 r_delay [Id 2 0, Id 2 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "have \"eval ?i [i, x] = eval r_delay [i, x]\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [i, x] =\n    eval r_delay [i, x]", "using r_delay_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_delay\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [i, x] =\n    eval r_delay [i, x]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] =\n  eval r_delay [?i, ?x]\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] =\n  eval r_delay [?i, ?x]", "have i: \"eval ?i [i, x] = delay i x\" for i x"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] =\n  eval r_delay [?i, ?x]\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [i, x] = delay i x", "using r_delay"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] =\n  eval r_delay [?i, ?x]\n  eval r_delay [?i, ?x] \\<down>=\n  (if \\<exists>j<e_length ?x.\n         0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n   then Suc (GREATEST j.\n                j < e_length ?x \\<and>\n                0 < the (eval r_result1\n                          [e_length ?x, ?i, e_take (Suc j) ?x]))\n   else 0)\n\ngoal (1 subgoal):\n 1. eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [i, x] = delay i x", "by (simp add: delay_def)"], ["proof (state)\nthis:\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] = delay ?i ?x\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "let ?t = \"r_constn 1 d\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "have t: \"eval ?t [i, x] \\<down>= d\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_constn 1 d) [i, x] \\<down>= d", "by simp"], ["proof (state)\nthis:\n  eval (r_constn 1 d) [?i, ?x] \\<down>= d\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "let ?e1 = \"Cn 2 r_take [?i, Id 2 1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "let ?e = \"Cn 2 r_phi [Id 2 0, ?e1]\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "have \"eval ?e1 [i, x] = eval r_take [the (delay i x), x]\" for i x"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n     [i, x] =\n    eval r_take [the (delay i x), x]", "using r_delay i delay_def"], ["proof (prove)\nusing this:\n  eval r_delay [?i, ?x] \\<down>=\n  (if \\<exists>j<e_length ?x.\n         0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n   then Suc (GREATEST j.\n                j < e_length ?x \\<and>\n                0 < the (eval r_result1\n                          [e_length ?x, ?i, e_take (Suc j) ?x]))\n   else 0)\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] = delay ?i ?x\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n     [i, x] =\n    eval r_take [the (delay i x), x]", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] =\n  eval r_take [the (delay ?i ?x), ?x]\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] =\n  eval r_take [the (delay ?i ?x), ?x]", "have \"eval ?e1 [i, x] \\<down>= e_take (the (delay i x)) x\" for i x"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] =\n  eval r_take [the (delay ?i ?x), ?x]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n     [i, x] \\<down>=\n    e_take (the (delay i x)) x", "using delay_le_length"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] =\n  eval r_take [the (delay ?i ?x), ?x]\n  the (delay ?i ?x) \\<le> e_length ?x\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n     [i, x] \\<down>=\n    e_take (the (delay i x)) x", "by simp"], ["proof (state)\nthis:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] \\<down>=\n  e_take (the (delay ?i ?x)) ?x\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] \\<down>=\n  e_take (the (delay ?i ?x)) ?x", "have e: \"eval ?e [i, x] = \\<phi> i (e_take (the (delay i x)) x)\""], ["proof (prove)\nusing this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] \\<down>=\n  e_take (the (delay ?i ?x)) ?x\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n     [i, x] =\n    \\<phi> i (e_take (the (delay i x)) x)", "using phi_def"], ["proof (prove)\nusing this:\n  eval (Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1])\n   [?i, ?x] \\<down>=\n  e_take (the (delay ?i ?x)) ?x\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n     [i, x] =\n    \\<phi> i (e_take (the (delay i x)) x)", "by simp"], ["proof (state)\nthis:\n  eval\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n   [i, x] =\n  \\<phi> i (e_take (the (delay i x)) x)\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "let ?z = \"r_lifz ?t ?e\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "have recfn_te: \"recfn 2 ?t\" \"recfn 2 ?e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_constn 1 d) &&&\n    recfn 2\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])", "by simp_all"], ["proof (state)\nthis:\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])", "have \"eval (r_totalizer d) [i, x] = eval (r_lifz ?t ?e) [the (delay i x), i, x]\"\n      for i x"], ["proof (prove)\nusing this:\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    eval\n     (r_lifz (r_constn 1 d)\n       (Cn 2 r_phi\n         [recf.Id 2 0,\n          Cn 2 r_take\n           [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n     [the (delay i x), i, x]", "unfolding r_totalizer_def"], ["proof (prove)\nusing this:\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2\n       (r_lifz (r_constn 1 d)\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n       [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, x] =\n    eval\n     (r_lifz (r_constn 1 d)\n       (Cn 2 r_phi\n         [recf.Id 2 0,\n          Cn 2 r_take\n           [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n     [the (delay i x), i, x]", "using i r_totalizer_recfn delay_def"], ["proof (prove)\nusing this:\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n  eval (Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1]) [?i, ?x] = delay ?i ?x\n  recfn 2 (r_totalizer ?d)\n  delay ?i ?x \\<equiv>\n  Some\n   (if \\<exists>j<e_length ?x.\n          0 < the (eval r_result1 [e_length ?x, ?i, e_take (Suc j) ?x])\n    then Suc (GREATEST j.\n                 j < e_length ?x \\<and>\n                 0 < the (eval r_result1\n                           [e_length ?x, ?i, e_take (Suc j) ?x]))\n    else 0)\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2\n       (r_lifz (r_constn 1 d)\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n       [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, x] =\n    eval\n     (r_lifz (r_constn 1 d)\n       (Cn 2 r_phi\n         [recf.Id 2 0,\n          Cn 2 r_take\n           [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n     [the (delay i x), i, x]", "by simp"], ["proof (state)\nthis:\n  eval (r_totalizer d) [?i, ?x] =\n  eval\n   (r_lifz (r_constn 1 d)\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take\n         [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n   [the (delay ?i ?x), ?i, ?x]\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  eval (r_totalizer d) [?i, ?x] =\n  eval\n   (r_lifz (r_constn 1 d)\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take\n         [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n   [the (delay ?i ?x), ?i, ?x]", "have \"eval (r_totalizer d) [i, x] =\n      (if the (delay i x) = 0 then eval ?t [i, x] else eval ?e [i, x])\"\n      for i x"], ["proof (prove)\nusing this:\n  eval (r_totalizer d) [?i, ?x] =\n  eval\n   (r_lifz (r_constn 1 d)\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take\n         [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n   [the (delay ?i ?x), ?i, ?x]\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then eval (r_constn 1 d) [i, x]\n     else eval\n           (Cn 2 r_phi\n             [recf.Id 2 0,\n              Cn 2 r_take\n               [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n           [i, x])", "using recfn_te"], ["proof (prove)\nusing this:\n  eval (r_totalizer d) [?i, ?x] =\n  eval\n   (r_lifz (r_constn 1 d)\n     (Cn 2 r_phi\n       [recf.Id 2 0,\n        Cn 2 r_take\n         [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]]))\n   [the (delay ?i ?x), ?i, ?x]\n  recfn 2 (r_constn 1 d)\n  recfn 2\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then eval (r_constn 1 d) [i, x]\n     else eval\n           (Cn 2 r_phi\n             [recf.Id 2 0,\n              Cn 2 r_take\n               [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n           [i, x])", "by simp"], ["proof (state)\nthis:\n  eval (r_totalizer d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then eval (r_constn 1 d) [?i, ?x]\n   else eval\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n         [?i, ?x])\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "then"], ["proof (chain)\npicking this:\n  eval (r_totalizer d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then eval (r_constn 1 d) [?i, ?x]\n   else eval\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n         [?i, ?x])", "show ?thesis"], ["proof (prove)\nusing this:\n  eval (r_totalizer d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then eval (r_constn 1 d) [?i, ?x]\n   else eval\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n         [?i, ?x])\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "using t e"], ["proof (prove)\nusing this:\n  eval (r_totalizer d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then eval (r_constn 1 d) [?i, ?x]\n   else eval\n         (Cn 2 r_phi\n           [recf.Id 2 0,\n            Cn 2 r_take\n             [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n         [?i, ?x])\n  eval (r_constn 1 d) [?i, ?x] \\<down>= d\n  eval\n   (Cn 2 r_phi\n     [recf.Id 2 0,\n      Cn 2 r_take [Cn 2 r_delay [recf.Id 2 0, recf.Id 2 1], recf.Id 2 1]])\n   [i, x] =\n  \\<phi> i (e_take (the (delay i x)) x)\n\ngoal (1 subgoal):\n 1. eval (r_totalizer d) [i, x] =\n    (if the (delay i x) = 0 then Some d\n     else \\<phi> i (e_take (the (delay i x)) x))", "by simp"], ["proof (state)\nthis:\n  eval (r_totalizer d) [i, x] =\n  (if the (delay i x) = 0 then Some d\n   else \\<phi> i (e_take (the (delay i x)) x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma r_totalizer_total: \"total (r_totalizer d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_Recursive.total (r_totalizer d)", "proof (rule totalI2)"], ["proof (state)\ngoal (2 subgoals):\n 1. recfn 2 (r_totalizer d)\n 2. \\<And>x y. eval (r_totalizer d) [x, y] \\<down>", "show \"recfn 2 (r_totalizer d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_totalizer d)", "using r_totalizer_recfn"], ["proof (prove)\nusing this:\n  recfn 2 (r_totalizer ?d)\n\ngoal (1 subgoal):\n 1. recfn 2 (r_totalizer d)", "by simp"], ["proof (state)\nthis:\n  recfn 2 (r_totalizer d)\n\ngoal (1 subgoal):\n 1. \\<And>x y. eval (r_totalizer d) [x, y] \\<down>", "show \"\\<And>x y. eval (r_totalizer d) [x, y] \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. eval (r_totalizer d) [x, y] \\<down>", "using r_totalizer delay_gr0_converg"], ["proof (prove)\nusing this:\n  eval (r_totalizer ?d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then Some ?d\n   else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x))\n  0 < the (delay ?i ?x) \\<Longrightarrow>\n  \\<phi> ?i (e_take (the (delay ?i ?x)) ?x) \\<down>\n\ngoal (1 subgoal):\n 1. \\<And>x y. eval (r_totalizer d) [x, y] \\<down>", "by simp"], ["proof (state)\nthis:\n  eval (r_totalizer d) [?x, ?y] \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "definition totalizer :: \"nat \\<Rightarrow> partial2\" where\n  \"totalizer d i x \\<equiv>\n     if the (delay i x) = 0 then Some d else \\<phi> i (e_take (the (delay i x)) x)\""], ["", "lemma totalizer_init:\n  assumes \"f \\<in> \\<R>\"\n  shows \"totalizer d i (f \\<triangleright> n) =\n    (if the (delay i (f \\<triangleright> n)) = 0 then Some d\n     else \\<phi> i (f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totalizer d i (f \\<triangleright> n) =\n    (if the (delay i (f \\<triangleright> n)) = 0 then Some d\n     else \\<phi> i\n           (f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)))", "using assms e_take_delay_init"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<lbrakk>?f \\<in> \\<R>;\n   0 < the (delay ?i (?f \\<triangleright> ?n))\\<rbrakk>\n  \\<Longrightarrow> e_take (the (delay ?i (?f \\<triangleright> ?n)))\n                     (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright>\n                    (the (delay ?i (?f \\<triangleright> ?n)) - 1)\n\ngoal (1 subgoal):\n 1. totalizer d i (f \\<triangleright> n) =\n    (if the (delay i (f \\<triangleright> n)) = 0 then Some d\n     else \\<phi> i\n           (f \\<triangleright> (the (delay i (f \\<triangleright> n)) - 1)))", "by (simp add: totalizer_def)"], ["", "lemma totalizer_in_R2: \"totalizer d \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totalizer d \\<in> \\<R>\\<^sup>2", "using totalizer_def r_totalizer r_totalizer_total R2I r_totalizer_recfn"], ["proof (prove)\nusing this:\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n  eval (r_totalizer ?d) [?i, ?x] =\n  (if the (delay ?i ?x) = 0 then Some ?d\n   else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x))\n  Partial_Recursive.total (r_totalizer ?d)\n  \\<lbrakk>recfn 2 ?r; Partial_Recursive.total ?r;\n   \\<And>x y. eval ?r [x, y] = ?f x y\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> \\<R>\\<^sup>2\n  recfn 2 (r_totalizer ?d)\n\ngoal (1 subgoal):\n 1. totalizer d \\<in> \\<R>\\<^sup>2", "by metis"], ["", "text \\<open>For LIM, @{term totalizer} works with every default hypothesis\n$d$.\\<close>"], ["", "lemma lemma_R_for_Lim:\n  assumes \"learn_lim \\<psi> U (\\<phi> i)\"\n  shows \"learn_lim \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_lim \\<psi> U (totalizer d i)", "proof (rule learn_limI)"], ["proof (state)\ngoal (2 subgoals):\n 1. environment \\<psi> U (totalizer d i)\n 2. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)", "show env: \"environment \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "using assms learn_limE(1) totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_lim \\<psi> U (\\<phi> i)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  environment \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)", "show \"\\<exists>j. \\<psi> j = f \\<and> (\\<forall>\\<^sup>\\<infinity>n. totalizer d i (f \\<triangleright> n) \\<down>= j)\" if \"f \\<in> U\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "have \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using assms env that"], ["proof (prove)\nusing this:\n  learn_lim \\<psi> U (\\<phi> i)\n  environment \\<psi> U (totalizer d i)\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "from assms learn_limE"], ["proof (chain)\npicking this:\n  learn_lim \\<psi> U (\\<phi> i)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)", "obtain j n\\<^sub>0 where\n      j: \"\\<psi> j = f\" and\n      n0: \"\\<forall>n\\<ge>n\\<^sub>0. (\\<phi> i) (f \\<triangleright> n) \\<down>= j\""], ["proof (prove)\nusing this:\n  learn_lim \\<psi> U (\\<phi> i)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n\ngoal (1 subgoal):\n 1. (\\<And>j n\\<^sub>0.\n        \\<lbrakk>\\<psi> j = f;\n         \\<forall>n\\<ge>n\\<^sub>0.\n            \\<phi> i (f \\<triangleright> n) \\<down>= j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>f \\<in> U\\<close>"], ["proof (prove)\nusing this:\n  learn_lim \\<psi> U (\\<phi> i)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>j n\\<^sub>0.\n        \\<lbrakk>\\<psi> j = f;\n         \\<forall>n\\<ge>n\\<^sub>0.\n            \\<phi> i (f \\<triangleright> n) \\<down>= j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<psi> j = f\n  \\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "obtain m\\<^sub>0 where m0: \"\\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>0.\n        \\<forall>m\\<ge>m\\<^sub>0.\n           n\\<^sub>0\n           < the (delay i (f \\<triangleright> m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using delay_unbounded_monotone \\<open>f \\<in> \\<R>\\<close> \\<open>f \\<in> U\\<close> assms learn_limE(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<forall>n. \\<phi> ?i (?f \\<triangleright> n) \\<down>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<^sub>0.\n                       \\<forall>m\\<ge>m\\<^sub>0.\n                          ?n < the (delay ?i (?f \\<triangleright> m))\n  f \\<in> \\<R>\n  f \\<in> U\n  learn_lim \\<psi> U (\\<phi> i)\n  learn_lim ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>0.\n        \\<forall>m\\<ge>m\\<^sub>0.\n           n\\<^sub>0\n           < the (delay i (f \\<triangleright> m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) = \\<phi> i (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "using totalizer_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) = \\<phi> i (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "using e_take_delay_init m0 \\<open>f \\<in> \\<R>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n  \\<lbrakk>?f \\<in> \\<R>;\n   0 < the (delay ?i (?f \\<triangleright> ?n))\\<rbrakk>\n  \\<Longrightarrow> e_take (the (delay ?i (?f \\<triangleright> ?n)))\n                     (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright>\n                    (the (delay ?i (?f \\<triangleright> ?n)) - 1)\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "with m0 n0"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= j\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) \\<down>= j\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= j\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) \\<down>= j", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "with j"], ["proof (chain)\npicking this:\n  \\<psi> j = f\n  \\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) \\<down>= j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> j = f\n  \\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) \\<down>= j\n\ngoal (1 subgoal):\n 1. \\<exists>j.\n       \\<psi> j = f \\<and>\n       (\\<exists>n\\<^sub>0.\n           \\<forall>n\\<ge>n\\<^sub>0.\n              totalizer d i (f \\<triangleright> n) \\<down>= j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j.\n     \\<psi> j = f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0.\n            totalizer d i (f \\<triangleright> n) \\<down>= j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>j.\n     \\<psi> j = ?f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0.\n            totalizer d i (?f \\<triangleright> n) \\<down>= j)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The effective version of Lemma~R for LIM states that there is a\ntotal recursive function computing G?del numbers of total strategies\nfrom those of arbitrary strategies.\\<close>"], ["", "lemma lemma_R_for_Lim_effective:\n  \"\\<exists>g\\<in>\\<R>. \\<forall>i.\n     \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n     (\\<forall>U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (g i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "have \"totalizer 0 \\<in> \\<P>\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. totalizer 0 \\<in> \\<P>\\<^sup>2", "using totalizer_in_R2"], ["proof (prove)\nusing this:\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. totalizer 0 \\<in> \\<P>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  totalizer 0 \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "then"], ["proof (chain)\npicking this:\n  totalizer 0 \\<in> \\<P>\\<^sup>2", "obtain g where g: \"g \\<in> \\<R>\" \"\\<forall>i. (totalizer 0) i = \\<phi> (the (g i))\""], ["proof (prove)\nusing this:\n  totalizer 0 \\<in> \\<P>\\<^sup>2\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<R>;\n         \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using numbering_translation_for_phi"], ["proof (prove)\nusing this:\n  totalizer 0 \\<in> \\<P>\\<^sup>2\n  ?\\<psi> \\<in> \\<P>\\<^sup>2 \\<Longrightarrow>\n  \\<exists>c\\<in>\\<R>. \\<forall>i. ?\\<psi> i = \\<phi> (the (c i))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> \\<R>;\n         \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  g \\<in> \\<R>\n  \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "with totalizer_in_R2"], ["proof (chain)\npicking this:\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n  g \\<in> \\<R>\n  \\<forall>i. totalizer 0 i = \\<phi> (the (g i))", "have \"\\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n  g \\<in> \\<R>\n  \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\n\ngoal (1 subgoal):\n 1. \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>", "by (metis R2_proj_R1)"], ["proof (state)\nthis:\n  \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "moreover"], ["proof (state)\nthis:\n  \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "from g(2) lemma_R_for_Lim[where ?d=0]"], ["proof (chain)\npicking this:\n  \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer 0 ?i)", "have\n    \"\\<forall>i U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (g i)))\""], ["proof (prove)\nusing this:\n  \\<forall>i. totalizer 0 i = \\<phi> (the (g i))\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer 0 ?i)\n\ngoal (1 subgoal):\n 1. \\<forall>i U \\<psi>.\n       learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n       learn_lim \\<psi> U (\\<phi> (the (g i)))", "by simp"], ["proof (state)\nthis:\n  \\<forall>i U \\<psi>.\n     learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (g i)))\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\n  \\<forall>i U \\<psi>.\n     learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (g i)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\n  \\<forall>i U \\<psi>.\n     learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (g i)))\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "using g(1)"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<phi> (the (g i)) \\<in> \\<R>\n  \\<forall>i U \\<psi>.\n     learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (g i)))\n  g \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>g\\<in>\\<R>.\n       \\<forall>i.\n          \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n          (\\<forall>U \\<psi>.\n              learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n              learn_lim \\<psi> U (\\<phi> (the (g i))))", "by blast"], ["proof (state)\nthis:\n  \\<exists>g\\<in>\\<R>.\n     \\<forall>i.\n        \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n        (\\<forall>U \\<psi>.\n            learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n            learn_lim \\<psi> U (\\<phi> (the (g i))))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In order for us to use the previous lemma, we need a function\nthat performs the actual computation:\\<close>"], ["", "definition \"r_limr \\<equiv>\n SOME g.\n   recfn 1 g \\<and>\n   total g \\<and>\n   (\\<forall>i. \\<phi> (the (eval g [i])) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (eval g [i])))))\""], ["", "lemma r_limr_recfn: \"recfn 1 r_limr\"\n  and r_limr_total: \"total r_limr\"\n  and r_limr:\n    \"\\<phi> (the (eval r_limr [i])) \\<in> \\<R>\"\n    \"learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow> learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r_limr &&&\n    Partial_Recursive.total r_limr &&&\n    \\<phi> (the (eval r_limr [i])) \\<in> \\<R> &&&\n    (learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i]))))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "let ?P = \"\\<lambda>g.\n    g \\<in> \\<R> \\<and>\n    (\\<forall>i. \\<phi> (the (g i)) \\<in> \\<R> \\<and> (\\<forall>U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (g i)))))\""], ["proof (state)\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "let ?Q = \"\\<lambda>g.\n    recfn 1 g \\<and>\n    total g \\<and>\n    (\\<forall>i. \\<phi> (the (eval g [i])) \\<in> \\<R> \\<and> \n       (\\<forall>U \\<psi>. learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow> learn_lim \\<psi> U (\\<phi> (the (eval g [i])))))\""], ["proof (state)\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "have \"\\<exists>g. ?P g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>g.\n       g \\<in> \\<R> \\<and>\n       (\\<forall>i.\n           \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (g i)))))", "using lemma_R_for_Lim_effective"], ["proof (prove)\nusing this:\n  \\<exists>g\\<in>\\<R>.\n     \\<forall>i.\n        \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n        (\\<forall>U \\<psi>.\n            learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n            learn_lim \\<psi> U (\\<phi> (the (g i))))\n\ngoal (1 subgoal):\n 1. \\<exists>g.\n       g \\<in> \\<R> \\<and>\n       (\\<forall>i.\n           \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (g i)))))", "by auto"], ["proof (state)\nthis:\n  \\<exists>g.\n     g \\<in> \\<R> \\<and>\n     (\\<forall>i.\n         \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U (\\<phi> (the (g i)))))\n\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "then"], ["proof (chain)\npicking this:\n  \\<exists>g.\n     g \\<in> \\<R> \\<and>\n     (\\<forall>i.\n         \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U (\\<phi> (the (g i)))))", "obtain g where \"?P g\""], ["proof (prove)\nusing this:\n  \\<exists>g.\n     g \\<in> \\<R> \\<and>\n     (\\<forall>i.\n         \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U (\\<phi> (the (g i)))))\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        g \\<in> \\<R> \\<and>\n        (\\<forall>i.\n            \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n            (\\<forall>U \\<psi>.\n                learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n                learn_lim \\<psi> U (\\<phi> (the (g i))))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> \\<R> \\<and>\n  (\\<forall>i.\n      \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (g i)))))\n\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "then"], ["proof (chain)\npicking this:\n  g \\<in> \\<R> \\<and>\n  (\\<forall>i.\n      \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (g i)))))", "obtain g' where g': \"recfn 1 g'\" \"total g'\" \"\\<forall>i. eval g' [i] = g i\""], ["proof (prove)\nusing this:\n  g \\<in> \\<R> \\<and>\n  (\\<forall>i.\n      \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (g i)))))\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        \\<lbrakk>recfn 1 g'; Partial_Recursive.total g';\n         \\<forall>i. eval g' [i] = g i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 1 g'\n  Partial_Recursive.total g'\n  \\<forall>i. eval g' [i] = g i\n\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "with \\<open>?P g\\<close>"], ["proof (chain)\npicking this:\n  g \\<in> \\<R> \\<and>\n  (\\<forall>i.\n      \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (g i)))))\n  recfn 1 g'\n  Partial_Recursive.total g'\n  \\<forall>i. eval g' [i] = g i", "have \"?Q g'\""], ["proof (prove)\nusing this:\n  g \\<in> \\<R> \\<and>\n  (\\<forall>i.\n      \\<phi> (the (g i)) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (g i)))))\n  recfn 1 g'\n  Partial_Recursive.total g'\n  \\<forall>i. eval g' [i] = g i\n\ngoal (1 subgoal):\n 1. recfn 1 g' \\<and>\n    Partial_Recursive.total g' \\<and>\n    (\\<forall>i.\n        \\<phi> (the (eval g' [i])) \\<in> \\<R> \\<and>\n        (\\<forall>U \\<psi>.\n            learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n            learn_lim \\<psi> U (\\<phi> (the (eval g' [i])))))", "by simp"], ["proof (state)\nthis:\n  recfn 1 g' \\<and>\n  Partial_Recursive.total g' \\<and>\n  (\\<forall>i.\n      \\<phi> (the (eval g' [i])) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (eval g' [i])))))\n\ngoal (4 subgoals):\n 1. recfn 1 r_limr\n 2. Partial_Recursive.total r_limr\n 3. \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n 4. learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n    learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))", "with r_limr_def someI_ex[of ?Q]"], ["proof (chain)\npicking this:\n  r_limr \\<equiv>\n  SOME g.\n     recfn 1 g \\<and>\n     Partial_Recursive.total g \\<and>\n     (\\<forall>i.\n         \\<phi> (the (eval g [i])) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U (\\<phi> (the (eval g [i])))))\n  \\<exists>x.\n     recfn 1 x \\<and>\n     Partial_Recursive.total x \\<and>\n     (\\<forall>i.\n         \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U\n              (\\<phi> (the (eval x [i]))))) \\<Longrightarrow>\n  recfn 1\n   (SOME x.\n       recfn 1 x \\<and>\n       Partial_Recursive.total x \\<and>\n       (\\<forall>i.\n           \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (eval x [i])))))) \\<and>\n  Partial_Recursive.total\n   (SOME x.\n       recfn 1 x \\<and>\n       Partial_Recursive.total x \\<and>\n       (\\<forall>i.\n           \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (eval x [i])))))) \\<and>\n  (\\<forall>i.\n      \\<phi>\n       (the (eval\n              (SOME x.\n                  recfn 1 x \\<and>\n                  Partial_Recursive.total x \\<and>\n                  (\\<forall>i.\n                      \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n                      (\\<forall>U \\<psi>.\n                          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n                          learn_lim \\<psi> U (\\<phi> (the (eval x [i]))))))\n              [i]))\n      \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U\n           (\\<phi>\n             (the (eval\n                    (SOME x.\n                        recfn 1 x \\<and>\n                        Partial_Recursive.total x \\<and>\n                        (\\<forall>i.\n                            \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n                            (\\<forall>U \\<psi>.\n                                learn_lim \\<psi> U\n                                 (\\<phi> i) \\<longrightarrow>\n                                learn_lim \\<psi> U\n                                 (\\<phi> (the (eval x [i]))))))\n                    [i])))))\n  recfn 1 g' \\<and>\n  Partial_Recursive.total g' \\<and>\n  (\\<forall>i.\n      \\<phi> (the (eval g' [i])) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (eval g' [i])))))", "show\n    \"recfn 1 r_limr\"\n    \"total r_limr\"\n    \"\\<phi> (the (eval r_limr [i])) \\<in> \\<R>\"\n    \"learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow> learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))\""], ["proof (prove)\nusing this:\n  r_limr \\<equiv>\n  SOME g.\n     recfn 1 g \\<and>\n     Partial_Recursive.total g \\<and>\n     (\\<forall>i.\n         \\<phi> (the (eval g [i])) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U (\\<phi> (the (eval g [i])))))\n  \\<exists>x.\n     recfn 1 x \\<and>\n     Partial_Recursive.total x \\<and>\n     (\\<forall>i.\n         \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n         (\\<forall>U \\<psi>.\n             learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n             learn_lim \\<psi> U\n              (\\<phi> (the (eval x [i]))))) \\<Longrightarrow>\n  recfn 1\n   (SOME x.\n       recfn 1 x \\<and>\n       Partial_Recursive.total x \\<and>\n       (\\<forall>i.\n           \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (eval x [i])))))) \\<and>\n  Partial_Recursive.total\n   (SOME x.\n       recfn 1 x \\<and>\n       Partial_Recursive.total x \\<and>\n       (\\<forall>i.\n           \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n           (\\<forall>U \\<psi>.\n               learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n               learn_lim \\<psi> U (\\<phi> (the (eval x [i])))))) \\<and>\n  (\\<forall>i.\n      \\<phi>\n       (the (eval\n              (SOME x.\n                  recfn 1 x \\<and>\n                  Partial_Recursive.total x \\<and>\n                  (\\<forall>i.\n                      \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n                      (\\<forall>U \\<psi>.\n                          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n                          learn_lim \\<psi> U (\\<phi> (the (eval x [i]))))))\n              [i]))\n      \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U\n           (\\<phi>\n             (the (eval\n                    (SOME x.\n                        recfn 1 x \\<and>\n                        Partial_Recursive.total x \\<and>\n                        (\\<forall>i.\n                            \\<phi> (the (eval x [i])) \\<in> \\<R> \\<and>\n                            (\\<forall>U \\<psi>.\n                                learn_lim \\<psi> U\n                                 (\\<phi> i) \\<longrightarrow>\n                                learn_lim \\<psi> U\n                                 (\\<phi> (the (eval x [i]))))))\n                    [i])))))\n  recfn 1 g' \\<and>\n  Partial_Recursive.total g' \\<and>\n  (\\<forall>i.\n      \\<phi> (the (eval g' [i])) \\<in> \\<R> \\<and>\n      (\\<forall>U \\<psi>.\n          learn_lim \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_lim \\<psi> U (\\<phi> (the (eval g' [i])))))\n\ngoal (1 subgoal):\n 1. (recfn 1 r_limr &&& Partial_Recursive.total r_limr) &&&\n    \\<phi> (the (eval r_limr [i])) \\<in> \\<R> &&&\n    (learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n     learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i]))))", "by auto"], ["proof (state)\nthis:\n  recfn 1 r_limr\n  Partial_Recursive.total r_limr\n  \\<phi> (the (eval r_limr [i])) \\<in> \\<R>\n  learn_lim \\<psi> U (\\<phi> i) \\<Longrightarrow>\n  learn_lim \\<psi> U (\\<phi> (the (eval r_limr [i])))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For BC, too, @{term totalizer} works with every default\nhypothesis $d$.\\<close>"], ["", "lemma lemma_R_for_BC:\n  assumes \"learn_bc \\<psi> U (\\<phi> i)\"\n  shows \"learn_bc \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_bc \\<psi> U (totalizer d i)", "proof (rule learn_bcI)"], ["proof (state)\ngoal (2 subgoals):\n 1. environment \\<psi> U (totalizer d i)\n 2. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "show env: \"environment \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "using assms learn_bcE(1) totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_bc \\<psi> U (\\<phi> i)\n  learn_bc ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  environment \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "show \"\\<exists>n\\<^sub>0. \\<forall>n\\<ge>n\\<^sub>0. \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f\" if \"f \\<in> U\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "have \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using assms env that"], ["proof (prove)\nusing this:\n  learn_bc \\<psi> U (\\<phi> i)\n  environment \\<psi> U (totalizer d i)\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "obtain n\\<^sub>0 where n0: \"\\<forall>n\\<ge>n\\<^sub>0. \\<psi> (the ((\\<phi> i) (f \\<triangleright> n))) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>0.\n        \\<forall>n\\<ge>n\\<^sub>0.\n           \\<psi> (the (\\<phi> i (f \\<triangleright> n))) =\n           f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms learn_bcE \\<open>f \\<in> U\\<close>"], ["proof (prove)\nusing this:\n  learn_bc \\<psi> U (\\<phi> i)\n  learn_bc ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_bc ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n\\<^sub>0.\n                       \\<forall>n\\<ge>n\\<^sub>0.\n                          ?\\<psi> (the (?s (?f \\<triangleright> n))) = ?f\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>0.\n        \\<forall>n\\<ge>n\\<^sub>0.\n           \\<psi> (the (\\<phi> i (f \\<triangleright> n))) =\n           f \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>n\\<^sub>0.\n     \\<psi> (the (\\<phi> i (f \\<triangleright> n))) = f\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "obtain m\\<^sub>0 where m0: \"\\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>0.\n        \\<forall>m\\<ge>m\\<^sub>0.\n           n\\<^sub>0\n           < the (delay i (f \\<triangleright> m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using delay_unbounded_monotone \\<open>f \\<in> \\<R>\\<close> \\<open>f \\<in> U\\<close> assms learn_bcE(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<forall>n. \\<phi> ?i (?f \\<triangleright> n) \\<down>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<^sub>0.\n                       \\<forall>m\\<ge>m\\<^sub>0.\n                          ?n < the (delay ?i (?f \\<triangleright> m))\n  f \\<in> \\<R>\n  f \\<in> U\n  learn_bc \\<psi> U (\\<phi> i)\n  learn_bc ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>0.\n        \\<forall>m\\<ge>m\\<^sub>0.\n           n\\<^sub>0\n           < the (delay i (f \\<triangleright> m)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) = \\<phi> i (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "using totalizer_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer d i (f \\<triangleright> m) = \\<phi> i (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "using e_take_delay_init m0 \\<open>f \\<in> \\<R>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n  \\<lbrakk>?f \\<in> \\<R>;\n   0 < the (delay ?i (?f \\<triangleright> ?n))\\<rbrakk>\n  \\<Longrightarrow> e_take (the (delay ?i (?f \\<triangleright> ?n)))\n                     (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright>\n                    (the (delay ?i (?f \\<triangleright> ?n)) - 1)\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer d i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "with m0 n0"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>n\\<ge>n\\<^sub>0.\n     \\<psi> (the (\\<phi> i (f \\<triangleright> n))) = f\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "have \"\\<forall>m\\<ge>m\\<^sub>0. \\<psi> (the (totalizer d i (f \\<triangleright> m))) = f\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>n\\<ge>n\\<^sub>0.\n     \\<psi> (the (\\<phi> i (f \\<triangleright> n))) = f\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer d i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       \\<psi> (the (totalizer d i (f \\<triangleright> m))) = f", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     \\<psi> (the (totalizer d i (f \\<triangleright> m))) = f\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     \\<psi> (the (totalizer d i (f \\<triangleright> m))) = f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     \\<psi> (the (totalizer d i (f \\<triangleright> m))) = f\n\ngoal (1 subgoal):\n 1. \\<exists>n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f", "by auto"], ["proof (state)\nthis:\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi> (the (totalizer d i (f \\<triangleright> n))) = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        \\<psi> (the (totalizer d i (?f \\<triangleright> n))) = ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lemma_R_for_BC_simple:\n  assumes \"learn_bc \\<psi> U s\"\n  shows \"\\<exists>s'\\<in>\\<R>. learn_bc \\<psi> U s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>\\<R>. learn_bc \\<psi> U s'", "using assms lemma_R_for_BC totalizer_in_R2 learn_bcE"], ["proof (prove)\nusing this:\n  learn_bc \\<psi> U s\n  learn_bc ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_bc ?\\<psi> ?U (totalizer ?d ?i)\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n  learn_bc ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  \\<lbrakk>learn_bc ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n\\<^sub>0.\n                       \\<forall>n\\<ge>n\\<^sub>0.\n                          ?\\<psi> (the (?s (?f \\<triangleright> n))) = ?f\n\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>\\<R>. learn_bc \\<psi> U s'", "by (metis R2_proj_R1 learn_bcE(1) phi_universal)"], ["", "text \\<open>For FIN the default hypothesis of @{term totalizer} must be\nzero, signalling ``don't know yet''.\\<close>"], ["", "lemma lemma_R_for_FIN:\n  assumes \"learn_fin \\<psi> U (\\<phi> i)\"\n  shows \"learn_fin \\<psi> U (totalizer 0 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_fin \\<psi> U (totalizer 0 i)", "proof (rule learn_finI)"], ["proof (state)\ngoal (2 subgoals):\n 1. environment \\<psi> U (totalizer 0 i)\n 2. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia n\\<^sub>0.\n          \\<psi> ia = f \\<and>\n          (\\<forall>n<n\\<^sub>0.\n              totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n          (\\<forall>n\\<ge>n\\<^sub>0.\n              totalizer 0 i (f \\<triangleright> n) \\<down>= Suc ia)", "show env: \"environment \\<psi> U (totalizer 0 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer 0 i)", "using assms learn_finE(1) totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_fin \\<psi> U (\\<phi> i)\n  learn_fin ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer 0 i)", "by auto"], ["proof (state)\nthis:\n  environment \\<psi> U (totalizer 0 i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia n\\<^sub>0.\n          \\<psi> ia = f \\<and>\n          (\\<forall>n<n\\<^sub>0.\n              totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n          (\\<forall>n\\<ge>n\\<^sub>0.\n              totalizer 0 i (f \\<triangleright> n) \\<down>= Suc ia)", "show \"\\<exists>j n\\<^sub>0. \\<psi> j = f \\<and>\n           (\\<forall>n<n\\<^sub>0. totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n           (\\<forall>n\\<ge>n\\<^sub>0. totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)\"\n      if \"f \\<in> U\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "have \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using assms env that"], ["proof (prove)\nusing this:\n  learn_fin \\<psi> U (\\<phi> i)\n  environment \\<psi> U (totalizer 0 i)\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "from assms learn_finE[of \\<psi> U \"\\<phi> i\"]"], ["proof (chain)\npicking this:\n  learn_fin \\<psi> U (\\<phi> i)\n  learn_fin \\<psi> U (\\<phi> i) \\<Longrightarrow>\n  environment \\<psi> U (\\<phi> i)\n  \\<lbrakk>learn_fin \\<psi> U (\\<phi> i); ?f \\<in> U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ia n\\<^sub>0.\n                       \\<psi> ia = ?f \\<and>\n                       (\\<forall>n<n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>=\n                           0) \\<and>\n                       (\\<forall>n\\<ge>n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>= Suc ia)", "obtain j where\n      j: \"\\<psi> j = f\" and\n      ex_n0: \"\\<exists>n\\<^sub>0. (\\<forall>n<n\\<^sub>0. (\\<phi> i) (f \\<triangleright> n) \\<down>= 0) \\<and> (\\<forall>n\\<ge>n\\<^sub>0. (\\<phi> i) (f \\<triangleright> n) \\<down>= Suc j)\""], ["proof (prove)\nusing this:\n  learn_fin \\<psi> U (\\<phi> i)\n  learn_fin \\<psi> U (\\<phi> i) \\<Longrightarrow>\n  environment \\<psi> U (\\<phi> i)\n  \\<lbrakk>learn_fin \\<psi> U (\\<phi> i); ?f \\<in> U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ia n\\<^sub>0.\n                       \\<psi> ia = ?f \\<and>\n                       (\\<forall>n<n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>=\n                           0) \\<and>\n                       (\\<forall>n\\<ge>n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>= Suc ia)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<psi> j = f;\n         \\<exists>n\\<^sub>0.\n            (\\<forall>n<n\\<^sub>0.\n                \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n            (\\<forall>n\\<ge>n\\<^sub>0.\n                \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>f \\<in> U\\<close>"], ["proof (prove)\nusing this:\n  learn_fin \\<psi> U (\\<phi> i)\n  learn_fin \\<psi> U (\\<phi> i) \\<Longrightarrow>\n  environment \\<psi> U (\\<phi> i)\n  \\<lbrakk>learn_fin \\<psi> U (\\<phi> i); ?f \\<in> U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>ia n\\<^sub>0.\n                       \\<psi> ia = ?f \\<and>\n                       (\\<forall>n<n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>=\n                           0) \\<and>\n                       (\\<forall>n\\<ge>n\\<^sub>0.\n                           \\<phi> i (?f \\<triangleright> n) \\<down>= Suc ia)\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>\\<psi> j = f;\n         \\<exists>n\\<^sub>0.\n            (\\<forall>n<n\\<^sub>0.\n                \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n            (\\<forall>n\\<ge>n\\<^sub>0.\n                \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<psi> j = f\n  \\<exists>n\\<^sub>0.\n     (\\<forall>n<n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "let ?Q = \"\\<lambda>n\\<^sub>0. (\\<forall>n<n\\<^sub>0. (\\<phi> i) (f \\<triangleright> n) \\<down>= 0) \\<and> (\\<forall>n\\<ge>n\\<^sub>0. (\\<phi> i) (f \\<triangleright> n) \\<down>= Suc j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "define n\\<^sub>0 where \"n\\<^sub>0 = Least ?Q\""], ["proof (state)\nthis:\n  n\\<^sub>0 =\n  (LEAST n\\<^sub>0.\n      (\\<forall>n<n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n      (\\<forall>n\\<ge>n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= Suc j))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "with ex_n0"], ["proof (chain)\npicking this:\n  \\<exists>n\\<^sub>0.\n     (\\<forall>n<n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  n\\<^sub>0 =\n  (LEAST n\\<^sub>0.\n      (\\<forall>n<n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n      (\\<forall>n\\<ge>n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= Suc j))", "have n0: \"?Q n\\<^sub>0\" \"\\<forall>n<n\\<^sub>0. \\<not> ?Q n\""], ["proof (prove)\nusing this:\n  \\<exists>n\\<^sub>0.\n     (\\<forall>n<n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  n\\<^sub>0 =\n  (LEAST n\\<^sub>0.\n      (\\<forall>n<n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n      (\\<forall>n\\<ge>n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= Suc j))\n\ngoal (1 subgoal):\n 1. (\\<forall>n<n\\<^sub>0.\n        \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n    (\\<forall>n\\<ge>n\\<^sub>0.\n        \\<phi> i (f \\<triangleright> n) \\<down>= Suc j) &&&\n    \\<forall>n<n\\<^sub>0.\n       \\<not> ((\\<forall>na<n.\n                   \\<phi> i (f \\<triangleright> na) \\<down>= 0) \\<and>\n               (\\<forall>na\\<ge>n.\n                   \\<phi> i (f \\<triangleright> na) \\<down>= Suc j))", "using LeastI_ex[of ?Q] not_less_Least[of _ ?Q]"], ["proof (prove)\nusing this:\n  \\<exists>n\\<^sub>0.\n     (\\<forall>n<n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  n\\<^sub>0 =\n  (LEAST n\\<^sub>0.\n      (\\<forall>n<n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n      (\\<forall>n\\<ge>n\\<^sub>0.\n          \\<phi> i (f \\<triangleright> n) \\<down>= Suc j))\n  \\<exists>x.\n     (\\<forall>n<x. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>x.\n         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j) \\<Longrightarrow>\n  (\\<forall>n<LEAST n\\<^sub>0.\n                 (\\<forall>n<n\\<^sub>0.\n                     \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n                 (\\<forall>n\\<ge>n\\<^sub>0.\n                     \\<phi> i (f \\<triangleright> n) \\<down>= Suc j).\n      \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n  (\\<forall>n\\<ge>LEAST n\\<^sub>0.\n                     (\\<forall>n<n\\<^sub>0.\n                         \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n                     (\\<forall>n\\<ge>n\\<^sub>0.\n                         \\<phi> i (f \\<triangleright> n) \\<down>= Suc j).\n      \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  ?k < (LEAST x.\n           (\\<forall>n<x. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n           (\\<forall>n\\<ge>x.\n               \\<phi> i (f \\<triangleright> n) \\<down>=\n               Suc j)) \\<Longrightarrow>\n  \\<not> ((\\<forall>n<?k. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n          (\\<forall>n\\<ge>?k.\n              \\<phi> i (f \\<triangleright> n) \\<down>= Suc j))\n\ngoal (1 subgoal):\n 1. (\\<forall>n<n\\<^sub>0.\n        \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n    (\\<forall>n\\<ge>n\\<^sub>0.\n        \\<phi> i (f \\<triangleright> n) \\<down>= Suc j) &&&\n    \\<forall>n<n\\<^sub>0.\n       \\<not> ((\\<forall>na<n.\n                   \\<phi> i (f \\<triangleright> na) \\<down>= 0) \\<and>\n               (\\<forall>na\\<ge>n.\n                   \\<phi> i (f \\<triangleright> na) \\<down>= Suc j))", "by blast+"], ["proof (state)\nthis:\n  (\\<forall>n<n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n  (\\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  \\<forall>n<n\\<^sub>0.\n     \\<not> ((\\<forall>na<n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= 0) \\<and>\n             (\\<forall>na\\<ge>n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= Suc j))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "define m\\<^sub>0 where \"m\\<^sub>0 = (LEAST m\\<^sub>0. \\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\\<^sub>0)\"\n      (is \"m\\<^sub>0 = Least ?P\")"], ["proof (state)\nthis:\n  m\\<^sub>0 =\n  (LEAST m\\<^sub>0.\n      \\<forall>m\\<ge>m\\<^sub>0.\n         n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "moreover"], ["proof (state)\nthis:\n  m\\<^sub>0 =\n  (LEAST m\\<^sub>0.\n      \\<forall>m\\<ge>m\\<^sub>0.\n         n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "have \"\\<exists>m\\<^sub>0. \\<forall>m\\<ge>m\\<^sub>0. the (delay i (f \\<triangleright> m)) > n\\<^sub>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0.\n          n\\<^sub>0 < the (delay i (f \\<triangleright> m))", "using delay_unbounded_monotone \\<open>f\\<in>\\<R>\\<close> \\<open>f \\<in> U\\<close> assms learn_finE(1)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<forall>n. \\<phi> ?i (?f \\<triangleright> n) \\<down>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<^sub>0.\n                       \\<forall>m\\<ge>m\\<^sub>0.\n                          ?n < the (delay ?i (?f \\<triangleright> m))\n  f \\<in> \\<R>\n  f \\<in> U\n  learn_fin \\<psi> U (\\<phi> i)\n  learn_fin ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>0.\n       \\<forall>m\\<ge>m\\<^sub>0.\n          n\\<^sub>0 < the (delay i (f \\<triangleright> m))", "by simp"], ["proof (state)\nthis:\n  \\<exists>m\\<^sub>0.\n     \\<forall>m\\<ge>m\\<^sub>0.\n        n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "ultimately"], ["proof (chain)\npicking this:\n  m\\<^sub>0 =\n  (LEAST m\\<^sub>0.\n      \\<forall>m\\<ge>m\\<^sub>0.\n         n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n  \\<exists>m\\<^sub>0.\n     \\<forall>m\\<ge>m\\<^sub>0.\n        n\\<^sub>0 < the (delay i (f \\<triangleright> m))", "have m0: \"?P m\\<^sub>0\" \"\\<forall>m<m\\<^sub>0. \\<not> ?P m\""], ["proof (prove)\nusing this:\n  m\\<^sub>0 =\n  (LEAST m\\<^sub>0.\n      \\<forall>m\\<ge>m\\<^sub>0.\n         n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n  \\<exists>m\\<^sub>0.\n     \\<forall>m\\<ge>m\\<^sub>0.\n        n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       n\\<^sub>0 < the (delay i (f \\<triangleright> m)) &&&\n    \\<forall>m<m\\<^sub>0.\n       \\<not> (\\<forall>ma\\<ge>m.\n                  n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))", "using LeastI_ex[of ?P] not_less_Least[of _ ?P]"], ["proof (prove)\nusing this:\n  m\\<^sub>0 =\n  (LEAST m\\<^sub>0.\n      \\<forall>m\\<ge>m\\<^sub>0.\n         n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n  \\<exists>m\\<^sub>0.\n     \\<forall>m\\<ge>m\\<^sub>0.\n        n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<exists>x.\n     \\<forall>m\\<ge>x.\n        n\\<^sub>0 < the (delay i (f \\<triangleright> m)) \\<Longrightarrow>\n  \\<forall>m\\<ge>LEAST m\\<^sub>0.\n                    \\<forall>m\\<ge>m\\<^sub>0.\n                       n\\<^sub>0 < the (delay i (f \\<triangleright> m)).\n     n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  ?k < (LEAST x.\n           \\<forall>m\\<ge>x.\n              n\\<^sub>0\n              < the (delay i (f \\<triangleright> m))) \\<Longrightarrow>\n  \\<not> (\\<forall>m\\<ge>?k.\n             n\\<^sub>0 < the (delay i (f \\<triangleright> m)))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       n\\<^sub>0 < the (delay i (f \\<triangleright> m)) &&&\n    \\<forall>m<m\\<^sub>0.\n       \\<not> (\\<forall>ma\\<ge>m.\n                  n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))", "by blast+"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer 0 i (f \\<triangleright> m) = \\<phi> i (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer 0 i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "using totalizer_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer 0 i (f \\<triangleright> m) =\n       \\<phi> i\n        (e_take (the (delay i (f \\<triangleright> m)))\n          (f \\<triangleright> m))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "then"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer 0 i (f \\<triangleright> m) = \\<phi> i (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer 0 i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "using e_take_delay_init m0 \\<open>f\\<in>\\<R>\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (e_take (the (delay i (f \\<triangleright> m))) (f \\<triangleright> m))\n  \\<lbrakk>?f \\<in> \\<R>;\n   0 < the (delay ?i (?f \\<triangleright> ?n))\\<rbrakk>\n  \\<Longrightarrow> e_take (the (delay ?i (?f \\<triangleright> ?n)))\n                     (?f \\<triangleright> ?n) =\n                    ?f \\<triangleright>\n                    (the (delay ?i (?f \\<triangleright> ?n)) - 1)\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer 0 i (f \\<triangleright> m) =\n       \\<phi> i\n        (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "with m0 n0"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n  (\\<forall>n<n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n  (\\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  \\<forall>n<n\\<^sub>0.\n     \\<not> ((\\<forall>na<n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= 0) \\<and>\n             (\\<forall>na\\<ge>n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= Suc j))\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))", "have \"\\<forall>m\\<ge>m\\<^sub>0. totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\""], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n  (\\<forall>n<n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n  (\\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  \\<forall>n<n\\<^sub>0.\n     \\<not> ((\\<forall>na<n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= 0) \\<and>\n             (\\<forall>na\\<ge>n.\n                 \\<phi> i (f \\<triangleright> na) \\<down>= Suc j))\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) =\n     \\<phi> i\n      (f \\<triangleright> (the (delay i (f \\<triangleright> m)) - 1))\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>m\\<^sub>0.\n       totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j", "by auto"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "moreover"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "have \"totalizer 0 i (f \\<triangleright> m) \\<down>= 0\" if \"m < m\\<^sub>0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "proof (cases \"the (delay i (f \\<triangleright> m)) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> m)) = 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0\n 2. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "case True"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> m)) = 0\n\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> m)) = 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0\n 2. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> m)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> m)) = 0\n\ngoal (1 subgoal):\n 1. totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "by (simp add: totalizer_def)"], ["proof (state)\nthis:\n  totalizer 0 i (f \\<triangleright> m) \\<down>= 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "case False"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> m)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> m)) \\<noteq> 0", "have \"the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0\""], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> m)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0", "using m0 that \\<open>f \\<in> \\<R>\\<close> delay_monotone"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> m)) \\<noteq> 0\n  \\<forall>m\\<ge>m\\<^sub>0. n\\<^sub>0 < the (delay i (f \\<triangleright> m))\n  \\<forall>m<m\\<^sub>0.\n     \\<not> (\\<forall>ma\\<ge>m.\n                n\\<^sub>0 < the (delay i (f \\<triangleright> ma)))\n  m < m\\<^sub>0\n  f \\<in> \\<R>\n  \\<lbrakk>?f \\<in> \\<R>; ?n\\<^sub>1 \\<le> ?n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> the (delay ?i (?f \\<triangleright> ?n\\<^sub>1))\n                    \\<le> the (delay ?i (?f \\<triangleright> ?n\\<^sub>2))\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0", "by (meson leI order.strict_trans2)"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> m)) \\<noteq> 0 \\<Longrightarrow>\n    totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0\n\ngoal (1 subgoal):\n 1. totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "using \\<open>f \\<in> \\<R>\\<close> n0(1) totalizer_init"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> m)) \\<le> n\\<^sub>0\n  f \\<in> \\<R>\n  (\\<forall>n<n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= 0) \\<and>\n  (\\<forall>n\\<ge>n\\<^sub>0. \\<phi> i (f \\<triangleright> n) \\<down>= Suc j)\n  ?f \\<in> \\<R> \\<Longrightarrow>\n  totalizer ?d ?i (?f \\<triangleright> ?n) =\n  (if the (delay ?i (?f \\<triangleright> ?n)) = 0 then Some ?d\n   else \\<phi> ?i\n         (?f \\<triangleright>\n          (the (delay ?i (?f \\<triangleright> ?n)) - 1)))\n\ngoal (1 subgoal):\n 1. totalizer 0 i (f \\<triangleright> m) \\<down>= 0", "by (simp add: Suc_le_lessD)"], ["proof (state)\nthis:\n  totalizer 0 i (f \\<triangleright> m) \\<down>= 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?m < m\\<^sub>0 \\<Longrightarrow>\n  totalizer 0 i (f \\<triangleright> ?m) \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\n  ?m < m\\<^sub>0 \\<Longrightarrow>\n  totalizer 0 i (f \\<triangleright> ?m) \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\n  ?m < m\\<^sub>0 \\<Longrightarrow>\n  totalizer 0 i (f \\<triangleright> ?m) \\<down>= 0\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "using j"], ["proof (prove)\nusing this:\n  \\<forall>m\\<ge>m\\<^sub>0.\n     totalizer 0 i (f \\<triangleright> m) \\<down>= Suc j\n  ?m < m\\<^sub>0 \\<Longrightarrow>\n  totalizer 0 i (f \\<triangleright> ?m) \\<down>= 0\n  \\<psi> j = f\n\ngoal (1 subgoal):\n 1. \\<exists>j n\\<^sub>0.\n       \\<psi> j = f \\<and>\n       (\\<forall>n<n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n       (\\<forall>n\\<ge>n\\<^sub>0.\n           totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)", "by auto"], ["proof (state)\nthis:\n  \\<exists>j n\\<^sub>0.\n     \\<psi> j = f \\<and>\n     (\\<forall>n<n\\<^sub>0.\n         totalizer 0 i (f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         totalizer 0 i (f \\<triangleright> n) \\<down>= Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>j n\\<^sub>0.\n     \\<psi> j = ?f \\<and>\n     (\\<forall>n<n\\<^sub>0.\n         totalizer 0 i (?f \\<triangleright> n) \\<down>= 0) \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         totalizer 0 i (?f \\<triangleright> n) \\<down>= Suc j)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Weaker Lemma R for CP and TOTAL\\<close>"], ["", "text \\<open>For TOTAL the default hypothesis used by @{term totalizer}\ndepends on the hypothesis space, because it must refer to a total function in\nthat space. Consequently the total strategy depends on the hypothesis space,\nwhich makes this form of Lemma~R weaker than the ones in the previous\nsection.\\<close>"], ["", "lemma lemma_R_for_TOTAL:\n  fixes \\<psi> :: partial2\n  shows \"\\<exists>d. \\<forall>U. \\<forall>i. learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>  learn_total \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "proof (cases \"\\<exists>d. \\<psi> d \\<in> \\<R>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)\n 2. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "case True"], ["proof (state)\nthis:\n  \\<exists>d. \\<psi> d \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. \\<exists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)\n 2. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  \\<exists>d. \\<psi> d \\<in> \\<R>", "obtain d where \"\\<psi> d \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<exists>d. \\<psi> d \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<psi> d \\<in> \\<R> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<psi> d \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. \\<exists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)\n 2. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "have \"learn_total \\<psi> U (totalizer d i)\" if \"learn_total \\<psi> U (\\<phi> i)\" for U i"], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_total \\<psi> U (totalizer d i)", "proof (rule learn_totalI)"], ["proof (state)\ngoal (3 subgoals):\n 1. environment \\<psi> U (totalizer d i)\n 2. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)\n 3. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "show env: \"environment \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "using that learn_totalE(1) totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_total \\<psi> U (\\<phi> i)\n  learn_total ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  environment \\<psi> U (totalizer d i)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)\n 2. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "show \"\\<And>f. f \\<in> U \\<Longrightarrow> \\<exists>j. \\<psi> j = f \\<and> (\\<forall>\\<^sup>\\<infinity>n. totalizer d i (f \\<triangleright> n) \\<down>= j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>j.\n          \\<psi> j = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= j)", "using that learn_total_def lemma_R_for_Lim[where ?d=d] learn_limE(2)"], ["proof (prove)\nusing this:\n  learn_total \\<psi> U (\\<phi> i)\n  learn_total ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n. ?\\<psi> (the (?s (f \\<triangleright> n))) \\<in> \\<R>)\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer d ?i)\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>j.\n          \\<psi> j = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= j)", "by metis"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>j.\n     \\<psi> j = ?f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0.\n            totalizer d i (?f \\<triangleright> n) \\<down>= j)\n\ngoal (1 subgoal):\n 1. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "show \"\\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>\" if \"f \\<in> U\" for f n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "proof (cases \"the (delay i (f \\<triangleright> n)) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n)) = 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>\n 2. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "case True"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n)) = 0\n\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n)) = 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>\n 2. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) = 0\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "using totalizer_def \\<open>\\<psi> d \\<in> \\<R>\\<close>"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) = 0\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n  \\<psi> d \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "by simp"], ["proof (state)\nthis:\n  \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "case False"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "have \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using that env"], ["proof (prove)\nusing this:\n  f \\<in> U\n  environment \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  f \\<in> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "using False that \\<open>learn_total \\<psi> U (\\<phi> i)\\<close> totalizer_init learn_totalE(3)"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0\n  f \\<in> U\n  learn_total \\<psi> U (\\<phi> i)\n  ?f \\<in> \\<R> \\<Longrightarrow>\n  totalizer ?d ?i (?f \\<triangleright> ?n) =\n  (if the (delay ?i (?f \\<triangleright> ?n)) = 0 then Some ?d\n   else \\<phi> ?i\n         (?f \\<triangleright>\n          (the (delay ?i (?f \\<triangleright> ?n)) - 1)))\n  \\<lbrakk>learn_total ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi> (the (?s (?f \\<triangleright> ?n))) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>", "by simp"], ["proof (state)\nthis:\n  \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<psi> (the (totalizer d i (?f \\<triangleright> ?n))) \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  learn_total \\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_total \\<psi> ?U (totalizer d ?i)\n\ngoal (2 subgoals):\n 1. \\<exists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)\n 2. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  learn_total \\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_total \\<psi> ?U (totalizer d ?i)", "show ?thesis"], ["proof (prove)\nusing this:\n  learn_total \\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_total \\<psi> ?U (totalizer d ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     \\<forall>U i.\n        learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n        learn_total \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "case False"], ["proof (state)\nthis:\n  \\<nexists>d. \\<psi> d \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<nexists>d. \\<psi> d \\<in> \\<R> \\<Longrightarrow>\n    \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  \\<nexists>d. \\<psi> d \\<in> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>d. \\<psi> d \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "using learn_total_def lemma_R_for_Lim"], ["proof (prove)\nusing this:\n  \\<nexists>d. \\<psi> d \\<in> \\<R>\n  learn_total ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n. ?\\<psi> (the (?s (f \\<triangleright> n))) \\<in> \\<R>)\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer ?d ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>d.\n       \\<forall>U i.\n          learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n          learn_total \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d.\n     \\<forall>U i.\n        learn_total \\<psi> U (\\<phi> i) \\<longrightarrow>\n        learn_total \\<psi> U (totalizer d i)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary lemma_R_for_TOTAL_simple:\n  assumes \"learn_total \\<psi> U s\"\n  shows \"\\<exists>s'\\<in>\\<R>. learn_total \\<psi> U s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>\\<R>. learn_total \\<psi> U s'", "using assms lemma_R_for_TOTAL totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_total \\<psi> U s\n  \\<exists>d.\n     \\<forall>U i.\n        learn_total ?\\<psi> U (\\<phi> i) \\<longrightarrow>\n        learn_total ?\\<psi> U (totalizer d i)\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>s'\\<in>\\<R>. learn_total \\<psi> U s'", "by (metis R2_proj_R1 learn_totalE(1) phi_universal)"], ["", "text \\<open>For CP the default hypothesis used by @{term totalizer} depends\non both the hypothesis space and the class. Therefore the total strategy\ndepends on both the the hypothesis space and the class, which makes Lemma~R\nfor CP even weaker than the one for TOTAL.\\<close>"], ["", "lemma lemma_R_for_CP:\n  fixes \\<psi> :: partial2 and U :: \"partial1 set\"\n  assumes \"learn_cp \\<psi> U (\\<phi> i)\"\n  shows \"\\<exists>d. learn_cp \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "proof (cases \"U = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. U = {} \\<Longrightarrow> \\<exists>d. learn_cp \\<psi> U (totalizer d i)\n 2. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "case True"], ["proof (state)\nthis:\n  U = {}\n\ngoal (2 subgoals):\n 1. U = {} \\<Longrightarrow> \\<exists>d. learn_cp \\<psi> U (totalizer d i)\n 2. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  U = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  U = {}\n\ngoal (1 subgoal):\n 1. \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "using assms learn_cp_def lemma_R_for_Lim"], ["proof (prove)\nusing this:\n  U = {}\n  learn_cp \\<psi> U (\\<phi> i)\n  learn_cp ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n. ?\\<psi> (the (?s (f \\<triangleright> n))) \\<in> ?U)\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer ?d ?i)\n\ngoal (1 subgoal):\n 1. \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d. learn_cp \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "case False"], ["proof (state)\nthis:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  U \\<noteq> {}", "obtain f where \"f \\<in> U\""], ["proof (prove)\nusing this:\n  U \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>f. f \\<in> U \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "from \\<open>f \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> U", "obtain d where \"\\<psi> d = f\""], ["proof (prove)\nusing this:\n  f \\<in> U\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<psi> d = f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using learn_cpE(2)[OF assms]"], ["proof (prove)\nusing this:\n  f \\<in> U\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>ia n\\<^sub>0.\n     \\<psi> ia = ?f \\<and>\n     (\\<forall>n\\<ge>n\\<^sub>0.\n         \\<phi> i (?f \\<triangleright> n) \\<down>= ia)\n\ngoal (1 subgoal):\n 1. (\\<And>d. \\<psi> d = f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<psi> d = f\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "with \\<open>f \\<in> U\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> U\n  \\<psi> d = f", "have \"\\<psi> d \\<in> U\""], ["proof (prove)\nusing this:\n  f \\<in> U\n  \\<psi> d = f\n\ngoal (1 subgoal):\n 1. \\<psi> d \\<in> U", "by simp"], ["proof (state)\nthis:\n  \\<psi> d \\<in> U\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "have \"learn_cp \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_cp \\<psi> U (totalizer d i)", "proof (rule learn_cpI)"], ["proof (state)\ngoal (3 subgoals):\n 1. environment \\<psi> U (totalizer d i)\n 2. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)\n 3. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "show env: \"environment \\<psi> U (totalizer d i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "using assms learn_cpE(1) totalizer_in_R2"], ["proof (prove)\nusing this:\n  learn_cp \\<psi> U (\\<phi> i)\n  learn_cp ?\\<psi> ?U ?s \\<Longrightarrow> environment ?\\<psi> ?U ?s\n  totalizer ?d \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. environment \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  environment \\<psi> U (totalizer d i)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>ia.\n          \\<psi> ia = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= ia)\n 2. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "show \"\\<And>f. f \\<in> U \\<Longrightarrow> \\<exists>j. \\<psi> j = f \\<and> (\\<forall>\\<^sup>\\<infinity>n. totalizer d i (f \\<triangleright> n) \\<down>= j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>j.\n          \\<psi> j = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= j)", "using assms learn_cp_def lemma_R_for_Lim[where ?d=d] learn_limE(2)"], ["proof (prove)\nusing this:\n  learn_cp \\<psi> U (\\<phi> i)\n  learn_cp ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n. ?\\<psi> (the (?s (f \\<triangleright> n))) \\<in> ?U)\n  learn_lim ?\\<psi> ?U (\\<phi> ?i) \\<Longrightarrow>\n  learn_lim ?\\<psi> ?U (totalizer d ?i)\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> \\<exists>i.\n                       ?\\<psi> i = ?f \\<and>\n                       (\\<exists>n\\<^sub>0.\n                           \\<forall>n\\<ge>n\\<^sub>0.\n                              ?s (?f \\<triangleright> n) \\<down>= i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> U \\<Longrightarrow>\n       \\<exists>j.\n          \\<psi> j = f \\<and>\n          (\\<exists>n\\<^sub>0.\n              \\<forall>n\\<ge>n\\<^sub>0.\n                 totalizer d i (f \\<triangleright> n) \\<down>= j)", "by metis"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<exists>j.\n     \\<psi> j = ?f \\<and>\n     (\\<exists>n\\<^sub>0.\n         \\<forall>n\\<ge>n\\<^sub>0.\n            totalizer d i (?f \\<triangleright> n) \\<down>= j)\n\ngoal (1 subgoal):\n 1. \\<And>f n.\n       f \\<in> U \\<Longrightarrow>\n       \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "show \"\\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U\" if \"f \\<in> U\" for f n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "proof (cases \"the (delay i (f \\<triangleright> n)) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n)) = 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U\n 2. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "case True"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n)) = 0\n\ngoal (2 subgoals):\n 1. the (delay i (f \\<triangleright> n)) = 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U\n 2. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n)) = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) = 0\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "using totalizer_def \\<open>\\<psi> d \\<in> U\\<close>"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) = 0\n  totalizer ?d ?i ?x \\<equiv>\n  if the (delay ?i ?x) = 0 then Some ?d\n  else \\<phi> ?i (e_take (the (delay ?i ?x)) ?x)\n  \\<psi> d \\<in> U\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "by simp"], ["proof (state)\nthis:\n  \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "case False"], ["proof (state)\nthis:\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. the (delay i (f \\<triangleright> n)) \\<noteq> 0 \\<Longrightarrow>\n    \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "then"], ["proof (chain)\npicking this:\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "using that env assms totalizer_init learn_cpE(3)"], ["proof (prove)\nusing this:\n  the (delay i (f \\<triangleright> n)) \\<noteq> 0\n  f \\<in> U\n  environment \\<psi> U (totalizer d i)\n  learn_cp \\<psi> U (\\<phi> i)\n  ?f \\<in> \\<R> \\<Longrightarrow>\n  totalizer ?d ?i (?f \\<triangleright> ?n) =\n  (if the (delay ?i (?f \\<triangleright> ?n)) = 0 then Some ?d\n   else \\<phi> ?i\n         (?f \\<triangleright>\n          (the (delay ?i (?f \\<triangleright> ?n)) - 1)))\n  \\<lbrakk>learn_cp ?\\<psi> ?U ?s; ?f \\<in> ?U\\<rbrakk>\n  \\<Longrightarrow> ?\\<psi> (the (?s (?f \\<triangleright> ?n))) \\<in> ?U\n\ngoal (1 subgoal):\n 1. \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U", "by auto"], ["proof (state)\nthis:\n  \\<psi> (the (totalizer d i (f \\<triangleright> n))) \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> U \\<Longrightarrow>\n  \\<psi> (the (totalizer d i (?f \\<triangleright> ?n))) \\<in> U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  learn_cp \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. U \\<noteq> {} \\<Longrightarrow>\n    \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "then"], ["proof (chain)\npicking this:\n  learn_cp \\<psi> U (totalizer d i)", "show ?thesis"], ["proof (prove)\nusing this:\n  learn_cp \\<psi> U (totalizer d i)\n\ngoal (1 subgoal):\n 1. \\<exists>d. learn_cp \\<psi> U (totalizer d i)", "by auto"], ["proof (state)\nthis:\n  \\<exists>d. learn_cp \\<psi> U (totalizer d i)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>No Lemma R for CONS\\<close>"], ["", "text \\<open>This section demonstrates that the class $V_{01}$ of all total\nrecursive functions $f$ where $f(0)$ or $f(1)$ is a G?del number of $f$ can\nbe consistently learned in the limit, but not by a total strategy. This implies\nthat Lemma~R does not hold for CONS.\\<close>"], ["", "definition V01 :: \"partial1 set\" (\"V\\<^sub>0\\<^sub>1\") where\n  \"V\\<^sub>0\\<^sub>1 = {f. f \\<in> \\<R> \\<and> (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)}\""], ["", "subsubsection \\<open>No total CONS strategy for @{term \"V\\<^sub>0\\<^sub>1\"}\\label{s:v01_not_total}\\<close>"], ["", "text \\<open>In order to show that no total strategy can learn @{term\n\"V\\<^sub>0\\<^sub>1\"} we construct, for each total strategy $S$, one or two\nfunctions in @{term \"V\\<^sub>0\\<^sub>1\"} such that $S$ fails for at least one\nof them. At the core of this construction is a process that given a total\nrecursive strategy $S$ and numbers $z, i, j \\in \\mathbb{N}$ builds a function\n$f$ as follows: Set $f(0) = i$ and $f(1) = j$. For $x\\geq1$:\n\\begin{enumerate}\n\\item[(a)] Check whether $S$ changes its hypothesis when $f^x$ is\n  extended by 0, that is, if $S(f^x) \\neq S(f^x0)$. If so, set $f(x+1) = 0$.\n\\item[(b)] Otherwise check if $S$ changes its hypothesis when $f^x$ is extended\n  by $1$, that is, if $S(f^x) \\neq S(f^x1)$. If so, set $f(x+1) = 1$.\n\\item[(c)] If neither happens, set $f(x+1) = z$.\n\\end{enumerate}\nIn other words, as long as we can force $S$ to change its hypothesis by\nextending the function by 0 or 1, we do just that. Now there are two\ncases:\n\\begin{enumerate}\n\\item[Case 1.] For all $x\\geq1$ either (a) or (b) occurs; then $S$\n  changes its hypothesis on $f$ all the time and thus does not learn $f$ in\n  the limit (not to mention consistently). The value of $z$ makes no\n  difference in this case.\n\\item[Case 2.] For some minimal $x$, (c) occurs, that is,\n  there is an $f^x$ such that $h := S(f^x) = S(f^x0) = S(f^x1)$. But the\n  hypothesis $h$ cannot be consistent with both prefixes $f^x0$ and $f^x1$.\n  Running the process once with $z = 0$ and once with $z = 1$ yields two\n  functions starting with $f^x0$ and $f^x1$, respectively, such that $S$\n  outputs the same hypothesis, $h$, on both prefixes and thus cannot be\n  consistent for both functions.\n\\end{enumerate}\nThis process is computable because $S$ is total. The construction does not\nwork if we only assume $S$ to be a CONS strategy for $V_{01}$, because we\nneed to be able to apply $S$ to prefixes not in $V_{01}$.\n\nThe parameters $i$ and $j$ provide flexibility to find functions built by the\nabove process that are actually in $V_{01}$. To this end we will use\nSmullyan's double fixed-point theorem.\\<close>"], ["", "context\n  fixes s :: partial1\n  assumes s_in_R1 [simp, intro]: \"s \\<in> \\<R>\"\nbegin"], ["", "text \\<open>The function @{term prefixes} constructs prefixes according to the\naforementioned process.\\<close>"], ["", "fun prefixes :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat list\" where\n  \"prefixes z i j 0 = [i]\"\n| \"prefixes z i j (Suc x) = prefixes z i j x @\n    [if x = 0 then j\n     else if s (list_encode (prefixes z i j x @ [0])) \\<noteq> s (list_encode (prefixes z i j x))\n          then 0\n          else if s (list_encode (prefixes z i j x @ [1])) \\<noteq> s (list_encode (prefixes z i j x))\n               then 1\n               else z]\""], ["", "lemma prefixes_length: \"length (prefixes z i j x) = Suc x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (local.prefixes z i j x) = Suc x", "by (induction x) simp_all"], ["", "text \\<open>The functions @{term[names_short] \"adverse z i j\"} are the\nfunctions constructed by @{term[names_short] \"prefixes\"}.\\<close>"], ["", "definition adverse :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat option\" where\n  \"adverse z i j x \\<equiv> Some (last (prefixes z i j x))\""], ["", "lemma init_adverse_eq_prefixes: \"(adverse z i j) \\<triangleright> n = list_encode (prefixes z i j n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> n =\n    Partial_Recursive.list_encode (local.prefixes z i j n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> n =\n    Partial_Recursive.list_encode (local.prefixes z i j n)", "have \"prefix (adverse z i j) n = prefixes z i j n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (local.adverse z i j) n = local.prefixes z i j n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. prefix (local.adverse z i j) 0 = local.prefixes z i j 0\n 2. \\<And>n.\n       prefix (local.adverse z i j) n =\n       local.prefixes z i j n \\<Longrightarrow>\n       prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. prefix (local.adverse z i j) 0 = local.prefixes z i j 0\n 2. \\<And>n.\n       prefix (local.adverse z i j) n =\n       local.prefixes z i j n \\<Longrightarrow>\n       prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix (local.adverse z i j) 0 = local.prefixes z i j 0", "using adverse_def prefixes_length prefixI'"], ["proof (prove)\nusing this:\n  local.adverse ?z ?i ?j ?x \\<equiv>\n  Some (last (local.prefixes ?z ?i ?j ?x))\n  length (local.prefixes ?z ?i ?j ?x) = Suc ?x\n  \\<lbrakk>length ?vs = Suc ?n;\n   \\<And>x. x < Suc ?n \\<Longrightarrow> ?f x \\<down>= ?vs ! x\\<rbrakk>\n  \\<Longrightarrow> prefix ?f ?n = ?vs\n\ngoal (1 subgoal):\n 1. prefix (local.adverse z i j) 0 = local.prefixes z i j 0", "by fastforce"], ["proof (state)\nthis:\n  prefix (local.adverse z i j) 0 = local.prefixes z i j 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       prefix (local.adverse z i j) n =\n       local.prefixes z i j n \\<Longrightarrow>\n       prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       prefix (local.adverse z i j) n =\n       local.prefixes z i j n \\<Longrightarrow>\n       prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "case (Suc n)"], ["proof (state)\nthis:\n  prefix (local.adverse z i j) n = local.prefixes z i j n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       prefix (local.adverse z i j) n =\n       local.prefixes z i j n \\<Longrightarrow>\n       prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "then"], ["proof (chain)\npicking this:\n  prefix (local.adverse z i j) n = local.prefixes z i j n", "show ?case"], ["proof (prove)\nusing this:\n  prefix (local.adverse z i j) n = local.prefixes z i j n\n\ngoal (1 subgoal):\n 1. prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "using adverse_def"], ["proof (prove)\nusing this:\n  prefix (local.adverse z i j) n = local.prefixes z i j n\n  local.adverse ?z ?i ?j ?x \\<equiv>\n  Some (last (local.prefixes ?z ?i ?j ?x))\n\ngoal (1 subgoal):\n 1. prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)", "by (simp add: prefix_Suc)"], ["proof (state)\nthis:\n  prefix (local.adverse z i j) (Suc n) = local.prefixes z i j (Suc n)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefix (local.adverse z i j) n = local.prefixes z i j n\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> n =\n    Partial_Recursive.list_encode (local.prefixes z i j n)", "then"], ["proof (chain)\npicking this:\n  prefix (local.adverse z i j) n = local.prefixes z i j n", "show ?thesis"], ["proof (prove)\nusing this:\n  prefix (local.adverse z i j) n = local.prefixes z i j n\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> n =\n    Partial_Recursive.list_encode (local.prefixes z i j n)", "by (simp add: init_def)"], ["proof (state)\nthis:\n  local.adverse z i j \\<triangleright> n =\n  Partial_Recursive.list_encode (local.prefixes z i j n)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adverse_at_01:\n  \"adverse z i j 0 \\<down>= i\"\n  \"adverse z i j 1 \\<down>= j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j 0 \\<down>= i &&& local.adverse z i j 1 \\<down>= j", "by (auto simp add: adverse_def)"], ["", "text \\<open>Had we introduced ternary partial recursive functions, the\n@{term[names_short] \"adverse z\"} functions would be among them.\\<close>"], ["", "lemma adverse_in_R3: \"\\<exists>r. recfn 3 r \\<and> total r \\<and> (\\<lambda>i j x. eval r [i, j, x]) = adverse z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "obtain rs where rs: \"recfn 1 rs\" \"total rs\" \"(\\<lambda>x. eval rs [x]) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>recfn 1 rs; Partial_Recursive.total rs;\n         (\\<lambda>x. eval rs [x]) = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R1E"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> \\<R>;\n   \\<And>r.\n      \\<lbrakk>recfn 1 r; Partial_Recursive.total r;\n       ?f = (\\<lambda>x. eval r [x])\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>rs.\n        \\<lbrakk>recfn 1 rs; Partial_Recursive.total rs;\n         (\\<lambda>x. eval rs [x]) = s\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  recfn 1 rs\n  Partial_Recursive.total rs\n  (\\<lambda>x. eval rs [x]) = s\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have s_total: \"\\<And>x. s x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. s x \\<down>", "by simp"], ["proof (state)\nthis:\n  s ?x \\<down>\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define f where \"f = Cn 2 r_singleton_encode [Id 2 0]\""], ["proof (state)\nthis:\n  f = Cn 2 r_singleton_encode [recf.Id 2 0]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  f = Cn 2 r_singleton_encode [recf.Id 2 0]", "have \"recfn 2 f\""], ["proof (prove)\nusing this:\n  f = Cn 2 r_singleton_encode [recf.Id 2 0]\n\ngoal (1 subgoal):\n 1. recfn 2 f", "by simp"], ["proof (state)\nthis:\n  recfn 2 f\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have f: \"\\<And>i j. eval f [i, j] \\<down>= list_encode [i]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j. eval f [i, j] \\<down>= singleton_encode i", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       eval (Cn 2 r_singleton_encode [recf.Id 2 0]) [i, j] \\<down>=\n       singleton_encode i", "by simp"], ["proof (state)\nthis:\n  eval f [?i, ?j] \\<down>= singleton_encode ?i\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define ch1 where \"ch1 = Cn 4 r_ifeq\n    [Cn 4 rs [Cn 4 r_snoc [Id 4 1, r_constn 3 1]],\n     Cn 4 rs [Id 4 1],\n     r_dummy 3 (r_const z),\n     r_constn 3 1]\""], ["proof (state)\nthis:\n  ch1 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n    Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  ch1 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n    Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1]", "have ch1: \"recfn 4 ch1\" \"total ch1\""], ["proof (prove)\nusing this:\n  ch1 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n    Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1]\n\ngoal (1 subgoal):\n 1. recfn 4 ch1 &&& Partial_Recursive.total ch1", "using Cn_total prim_recfn_total rs"], ["proof (prove)\nusing this:\n  ch1 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n    Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1]\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  prim_recfn ?n ?f \\<Longrightarrow> Partial_Recursive.total ?f\n  recfn 1 rs\n  Partial_Recursive.total rs\n  (\\<lambda>x. eval rs [x]) = s\n\ngoal (1 subgoal):\n 1. recfn 4 ch1 &&& Partial_Recursive.total ch1", "by auto"], ["proof (state)\nthis:\n  recfn 4 ch1\n  Partial_Recursive.total ch1\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define ch0 where \"ch0 = Cn 4 r_ifeq\n    [Cn 4 rs [Cn 4 r_snoc [Id 4 1, r_constn 3 0]],\n     Cn 4 rs [Id 4 1],\n     ch1,\n     r_constn 3 0]\""], ["proof (state)\nthis:\n  ch0 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n    Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  ch0 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n    Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0]", "have ch0_total: \"total ch0\" \"recfn 4 ch0\""], ["proof (prove)\nusing this:\n  ch0 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n    Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0]\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total ch0 &&& recfn 4 ch0", "using Cn_total prim_recfn_total rs ch1"], ["proof (prove)\nusing this:\n  ch0 =\n  Cn 4 r_ifeq\n   [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n    Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0]\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  prim_recfn ?n ?f \\<Longrightarrow> Partial_Recursive.total ?f\n  recfn 1 rs\n  Partial_Recursive.total rs\n  (\\<lambda>x. eval rs [x]) = s\n  recfn 4 ch1\n  Partial_Recursive.total ch1\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total ch0 &&& recfn 4 ch0", "by auto"], ["proof (state)\nthis:\n  Partial_Recursive.total ch0\n  recfn 4 ch0\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have \"eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)\" for l v i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)", "have \"eval ch1 [l, v, i, j] = eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ch1 [l, v, i, j] =\n    eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]", "unfolding ch1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifeq\n       [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n        Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1])\n     [l, v, i, j] =\n    eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]", "using rs"], ["proof (prove)\nusing this:\n  recfn 1 rs\n  Partial_Recursive.total rs\n  (\\<lambda>x. eval rs [x]) = s\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifeq\n       [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 1]],\n        Cn 4 rs [recf.Id 4 1], r_dummy 3 (r_const z), r_constn 3 1])\n     [l, v, i, j] =\n    eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]", "by auto"], ["proof (state)\nthis:\n  eval ch1 [l, v, i, j] =\n  eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]\n\ngoal (1 subgoal):\n 1. eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)", "then"], ["proof (chain)\npicking this:\n  eval ch1 [l, v, i, j] =\n  eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ch1 [l, v, i, j] =\n  eval r_ifeq [the (s (e_snoc v 1)), the (s v), z, 1]\n\ngoal (1 subgoal):\n 1. eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)", "by (simp add: s_total option.expand)"], ["proof (state)\nthis:\n  eval ch1 [l, v, i, j] \\<down>= (if s (e_snoc v 1) = s v then z else 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval ch1 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 1) = s ?v then z else 1)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "moreover"], ["proof (state)\nthis:\n  eval ch1 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 1) = s ?v then z else 1)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have \"eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)\" for l v i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)", "have \"eval ch0 [l, v, i, j] =\n        eval r_ifeq [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ch0 [l, v, i, j] =\n    eval r_ifeq\n     [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]", "unfolding ch0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifeq\n       [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n        Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0])\n     [l, v, i, j] =\n    eval r_ifeq\n     [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]", "using rs ch1"], ["proof (prove)\nusing this:\n  recfn 1 rs\n  Partial_Recursive.total rs\n  (\\<lambda>x. eval rs [x]) = s\n  recfn 4 ch1\n  Partial_Recursive.total ch1\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifeq\n       [Cn 4 rs [Cn 4 r_snoc [recf.Id 4 1, r_constn 3 0]],\n        Cn 4 rs [recf.Id 4 1], ch1, r_constn 3 0])\n     [l, v, i, j] =\n    eval r_ifeq\n     [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]", "by auto"], ["proof (state)\nthis:\n  eval ch0 [l, v, i, j] =\n  eval r_ifeq\n   [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]\n\ngoal (1 subgoal):\n 1. eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)", "then"], ["proof (chain)\npicking this:\n  eval ch0 [l, v, i, j] =\n  eval r_ifeq\n   [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ch0 [l, v, i, j] =\n  eval r_ifeq\n   [the (s (e_snoc v 0)), the (s v), the (eval ch1 [l, v, i, j]), 0]\n\ngoal (1 subgoal):\n 1. eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)", "by (simp add: s_total option.expand)"], ["proof (state)\nthis:\n  eval ch0 [l, v, i, j] \\<down>=\n  (if s (e_snoc v 0) = s v then the (eval ch1 [l, v, i, j]) else 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) = s ?v then the (eval ch1 [?l, ?v, ?i, ?j]) else 0)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "ultimately"], ["proof (chain)\npicking this:\n  eval ch1 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 1) = s ?v then z else 1)\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) = s ?v then the (eval ch1 [?l, ?v, ?i, ?j]) else 0)", "have ch0: \"\\<And>l v i j. eval ch0 [l, v, i, j] \\<down>=\n    (if s (e_snoc v 0) \\<noteq> s v then 0\n     else if s (e_snoc v 1) \\<noteq> s v then 1 else z)\""], ["proof (prove)\nusing this:\n  eval ch1 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 1) = s ?v then z else 1)\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) = s ?v then the (eval ch1 [?l, ?v, ?i, ?j]) else 0)\n\ngoal (1 subgoal):\n 1. \\<And>l v i j.\n       eval ch0 [l, v, i, j] \\<down>=\n       (if s (e_snoc v 0) \\<noteq> s v then 0\n        else if s (e_snoc v 1) \\<noteq> s v then 1 else z)", "by simp"], ["proof (state)\nthis:\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n   else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define app where \"app = Cn 4 r_ifz [Id 4 0, Id 4 3, ch0]\""], ["proof (state)\nthis:\n  app = Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  app = Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]", "have \"recfn 4 app\" \"total app\""], ["proof (prove)\nusing this:\n  app = Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]\n\ngoal (1 subgoal):\n 1. recfn 4 app &&& Partial_Recursive.total app", "using ch0_total totalI4"], ["proof (prove)\nusing this:\n  app = Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]\n  Partial_Recursive.total ch0\n  recfn 4 ch0\n  \\<lbrakk>recfn 4 ?f; \\<And>w x y z. eval ?f [w, x, y, z] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. recfn 4 app &&& Partial_Recursive.total app", "by auto"], ["proof (state)\nthis:\n  recfn 4 app\n  Partial_Recursive.total app\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have \"eval app [l, v, i, j] \\<down>= (if l = 0 then j else the (eval ch0 [l, v, i, j]))\" for l v i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval app [l, v, i, j] \\<down>=\n    (if l = 0 then j else the (eval ch0 [l, v, i, j]))", "unfolding app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]) [l, v, i, j] \\<down>=\n    (if l = 0 then j else the (eval ch0 [l, v, i, j]))", "using ch0_total"], ["proof (prove)\nusing this:\n  Partial_Recursive.total ch0\n  recfn 4 ch0\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_ifz [recf.Id 4 0, recf.Id 4 3, ch0]) [l, v, i, j] \\<down>=\n    (if l = 0 then j else the (eval ch0 [l, v, i, j]))", "by simp"], ["proof (state)\nthis:\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j else the (eval ch0 [?l, ?v, ?i, ?j]))\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "with ch0"], ["proof (chain)\npicking this:\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n   else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j else the (eval ch0 [?l, ?v, ?i, ?j]))", "have app: \"\\<And>l v i j. eval app [l, v, i, j] \\<down>=\n    (if l = 0 then j\n     else if s (e_snoc v 0) \\<noteq> s v then 0\n     else if s (e_snoc v 1) \\<noteq> s v then 1 else z)\""], ["proof (prove)\nusing this:\n  eval ch0 [?l, ?v, ?i, ?j] \\<down>=\n  (if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n   else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j else the (eval ch0 [?l, ?v, ?i, ?j]))\n\ngoal (1 subgoal):\n 1. \\<And>l v i j.\n       eval app [l, v, i, j] \\<down>=\n       (if l = 0 then j\n        else if s (e_snoc v 0) \\<noteq> s v then 0\n             else if s (e_snoc v 1) \\<noteq> s v then 1 else z)", "by simp"], ["proof (state)\nthis:\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j\n   else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n        else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define g where \"g = Cn 4 r_snoc [Id 4 1, app]\""], ["proof (state)\nthis:\n  g = Cn 4 r_snoc [recf.Id 4 1, app]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "with app"], ["proof (chain)\npicking this:\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j\n   else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n        else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  g = Cn 4 r_snoc [recf.Id 4 1, app]", "have g: \"\\<And>l v i j. eval g [l, v, i, j] \\<down>= e_snoc v\n    (if l = 0 then j\n     else if s (e_snoc v 0) \\<noteq> s v then 0\n     else if s (e_snoc v 1) \\<noteq> s v then 1 else z)\""], ["proof (prove)\nusing this:\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j\n   else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n        else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  g = Cn 4 r_snoc [recf.Id 4 1, app]\n\ngoal (1 subgoal):\n 1. \\<And>l v i j.\n       eval g [l, v, i, j] \\<down>=\n       e_snoc v\n        (if l = 0 then j\n         else if s (e_snoc v 0) \\<noteq> s v then 0\n              else if s (e_snoc v 1) \\<noteq> s v then 1 else z)", "using \\<open>recfn 4 app\\<close>"], ["proof (prove)\nusing this:\n  eval app [?l, ?v, ?i, ?j] \\<down>=\n  (if ?l = 0 then ?j\n   else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n        else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  g = Cn 4 r_snoc [recf.Id 4 1, app]\n  recfn 4 app\n\ngoal (1 subgoal):\n 1. \\<And>l v i j.\n       eval g [l, v, i, j] \\<down>=\n       e_snoc v\n        (if l = 0 then j\n         else if s (e_snoc v 0) \\<noteq> s v then 0\n              else if s (e_snoc v 1) \\<noteq> s v then 1 else z)", "by auto"], ["proof (state)\nthis:\n  eval g [?l, ?v, ?i, ?j] \\<down>=\n  e_snoc ?v\n   (if ?l = 0 then ?j\n    else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n         else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "from g_def"], ["proof (chain)\npicking this:\n  g = Cn 4 r_snoc [recf.Id 4 1, app]", "have \"recfn 4 g\" \"total g\""], ["proof (prove)\nusing this:\n  g = Cn 4 r_snoc [recf.Id 4 1, app]\n\ngoal (1 subgoal):\n 1. recfn 4 g &&& Partial_Recursive.total g", "using \\<open>recfn 4 app\\<close> \\<open>total app\\<close> Cn_total Mn_free_imp_total"], ["proof (prove)\nusing this:\n  g = Cn 4 r_snoc [recf.Id 4 1, app]\n  recfn 4 app\n  Partial_Recursive.total app\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. recfn 4 g &&& Partial_Recursive.total g", "by auto"], ["proof (state)\nthis:\n  recfn 4 g\n  Partial_Recursive.total g\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define b where \"b = Pr 2 f g\""], ["proof (state)\nthis:\n  b = Pr 2 f g\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  b = Pr 2 f g", "have \"recfn 3 b\""], ["proof (prove)\nusing this:\n  b = Pr 2 f g\n\ngoal (1 subgoal):\n 1. recfn 3 b", "using \\<open>recfn 2 f\\<close> \\<open>recfn 4 g\\<close>"], ["proof (prove)\nusing this:\n  b = Pr 2 f g\n  recfn 2 f\n  recfn 4 g\n\ngoal (1 subgoal):\n 1. recfn 3 b", "by simp"], ["proof (state)\nthis:\n  recfn 3 b\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "have b: \"eval b [x, i, j] \\<down>= list_encode (prefixes z i j x)\" for x i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval b [x, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j x)", "proof (induction x)"], ["proof (state)\ngoal (2 subgoals):\n 1. eval b [0, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j 0)\n 2. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. eval b [0, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j 0)\n 2. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval b [0, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j 0)", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Pr 2 f g) [0, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j 0)", "using f \\<open>recfn 2 f\\<close> \\<open>recfn 4 g\\<close>"], ["proof (prove)\nusing this:\n  eval f [?i, ?j] \\<down>= singleton_encode ?i\n  recfn 2 f\n  recfn 4 g\n\ngoal (1 subgoal):\n 1. eval (Pr 2 f g) [0, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j 0)", "by simp"], ["proof (state)\nthis:\n  eval b [0, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "case (Suc x)"], ["proof (state)\nthis:\n  eval b [x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "then"], ["proof (chain)\npicking this:\n  eval b [x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j x)", "have \"eval b [Suc x, i, j] = eval g [x, the (eval b [x, i, j]), i, j]\""], ["proof (prove)\nusing this:\n  eval b [x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j x)\n\ngoal (1 subgoal):\n 1. eval b [Suc x, i, j] = eval g [x, the (eval b [x, i, j]), i, j]", "using b_def \\<open>recfn 3 b\\<close>"], ["proof (prove)\nusing this:\n  eval b [x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j x)\n  b = Pr 2 f g\n  recfn 3 b\n\ngoal (1 subgoal):\n 1. eval b [Suc x, i, j] = eval g [x, the (eval b [x, i, j]), i, j]", "by simp"], ["proof (state)\nthis:\n  eval b [Suc x, i, j] = eval g [x, the (eval b [x, i, j]), i, j]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "also"], ["proof (state)\nthis:\n  eval b [Suc x, i, j] = eval g [x, the (eval b [x, i, j]), i, j]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "have \"... \\<down>=\n     (let v = list_encode (prefixes z i j x)\n      in e_snoc v\n        (if x = 0 then j\n         else if s (e_snoc v 0) \\<noteq> s v then 0\n              else if s (e_snoc v 1) \\<noteq> s v then 1 else z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [x, the (eval b [x, i, j]), i, j] \\<down>=\n    (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n     in e_snoc v\n         (if x = 0 then j\n          else if s (e_snoc v 0) \\<noteq> s v then 0\n               else if s (e_snoc v 1) \\<noteq> s v then 1 else z))", "using g Suc"], ["proof (prove)\nusing this:\n  eval g [?l, ?v, ?i, ?j] \\<down>=\n  e_snoc ?v\n   (if ?l = 0 then ?j\n    else if s (e_snoc ?v 0) \\<noteq> s ?v then 0\n         else if s (e_snoc ?v 1) \\<noteq> s ?v then 1 else z)\n  eval b [x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j x)\n\ngoal (1 subgoal):\n 1. eval g [x, the (eval b [x, i, j]), i, j] \\<down>=\n    (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n     in e_snoc v\n         (if x = 0 then j\n          else if s (e_snoc v 0) \\<noteq> s v then 0\n               else if s (e_snoc v 1) \\<noteq> s v then 1 else z))", "by simp"], ["proof (state)\nthis:\n  eval g [x, the (eval b [x, i, j]), i, j] \\<down>=\n  (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n   in e_snoc v\n       (if x = 0 then j\n        else if s (e_snoc v 0) \\<noteq> s v then 0\n             else if s (e_snoc v 1) \\<noteq> s v then 1 else z))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "also"], ["proof (state)\nthis:\n  eval g [x, the (eval b [x, i, j]), i, j] \\<down>=\n  (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n   in e_snoc v\n       (if x = 0 then j\n        else if s (e_snoc v 0) \\<noteq> s v then 0\n             else if s (e_snoc v 1) \\<noteq> s v then 1 else z))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "have \"... \\<down>=\n     (let v = list_encode (prefixes z i j x)\n      in e_snoc v\n        (if x = 0 then j\n         else if s (list_encode (prefixes z i j x @ [0])) \\<noteq> s v then 0\n              else if s (list_encode (prefixes z i j x @ [1])) \\<noteq> s v then 1 else z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n      in e_snoc v\n          (if x = 0 then j\n           else if s (e_snoc v 0) \\<noteq> s v then 0\n                else if s (e_snoc v 1) \\<noteq> s v then 1 else z)) \\<down>=\n    (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n     in e_snoc v\n         (if x = 0 then j\n          else if s (Partial_Recursive.list_encode\n                      (local.prefixes z i j x @ [0])) \\<noteq>\n                  s v\n               then 0\n               else if s (Partial_Recursive.list_encode\n                           (local.prefixes z i j x @ [1])) \\<noteq>\n                       s v\n                    then 1 else z))", "using list_decode_encode"], ["proof (prove)\nusing this:\n  Partial_Recursive.list_decode (Partial_Recursive.list_encode ?xs) = ?xs\n\ngoal (1 subgoal):\n 1. Some\n     (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n      in e_snoc v\n          (if x = 0 then j\n           else if s (e_snoc v 0) \\<noteq> s v then 0\n                else if s (e_snoc v 1) \\<noteq> s v then 1 else z)) \\<down>=\n    (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n     in e_snoc v\n         (if x = 0 then j\n          else if s (Partial_Recursive.list_encode\n                      (local.prefixes z i j x @ [0])) \\<noteq>\n                  s v\n               then 0\n               else if s (Partial_Recursive.list_encode\n                           (local.prefixes z i j x @ [1])) \\<noteq>\n                       s v\n                    then 1 else z))", "by presburger"], ["proof (state)\nthis:\n  Some\n   (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n    in e_snoc v\n        (if x = 0 then j\n         else if s (e_snoc v 0) \\<noteq> s v then 0\n              else if s (e_snoc v 1) \\<noteq> s v then 1 else z)) \\<down>=\n  (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n   in e_snoc v\n       (if x = 0 then j\n        else if s (Partial_Recursive.list_encode\n                    (local.prefixes z i j x @ [0])) \\<noteq>\n                s v\n             then 0\n             else if s (Partial_Recursive.list_encode\n                         (local.prefixes z i j x @ [1])) \\<noteq>\n                     s v\n                  then 1 else z))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       eval b [x, i, j] \\<down>=\n       Partial_Recursive.list_encode\n        (local.prefixes z i j x) \\<Longrightarrow>\n       eval b [Suc x, i, j] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "finally"], ["proof (chain)\npicking this:\n  eval b [Suc x, i, j] \\<down>=\n  (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n   in e_snoc v\n       (if x = 0 then j\n        else if s (Partial_Recursive.list_encode\n                    (local.prefixes z i j x @ [0])) \\<noteq>\n                s v\n             then 0\n             else if s (Partial_Recursive.list_encode\n                         (local.prefixes z i j x @ [1])) \\<noteq>\n                     s v\n                  then 1 else z))", "show ?case"], ["proof (prove)\nusing this:\n  eval b [Suc x, i, j] \\<down>=\n  (let v = Partial_Recursive.list_encode (local.prefixes z i j x)\n   in e_snoc v\n       (if x = 0 then j\n        else if s (Partial_Recursive.list_encode\n                    (local.prefixes z i j x @ [0])) \\<noteq>\n                s v\n             then 0\n             else if s (Partial_Recursive.list_encode\n                         (local.prefixes z i j x @ [1])) \\<noteq>\n                     s v\n                  then 1 else z))\n\ngoal (1 subgoal):\n 1. eval b [Suc x, i, j] \\<down>=\n    Partial_Recursive.list_encode (local.prefixes z i j (Suc x))", "by simp"], ["proof (state)\nthis:\n  eval b [Suc x, i, j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z i j (Suc x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval b [?x, ?i, ?j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define b' where \"b' = Cn 3 b [Id 3 2, Id 3 0, Id 3 1]\""], ["proof (state)\nthis:\n  b' = Cn 3 b [recf.Id 3 2, recf.Id 3 0, recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  b' = Cn 3 b [recf.Id 3 2, recf.Id 3 0, recf.Id 3 1]", "have \"recfn 3 b'\""], ["proof (prove)\nusing this:\n  b' = Cn 3 b [recf.Id 3 2, recf.Id 3 0, recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. recfn 3 b'", "using \\<open>recfn 3 b\\<close>"], ["proof (prove)\nusing this:\n  b' = Cn 3 b [recf.Id 3 2, recf.Id 3 0, recf.Id 3 1]\n  recfn 3 b\n\ngoal (1 subgoal):\n 1. recfn 3 b'", "by simp"], ["proof (state)\nthis:\n  recfn 3 b'\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "with b"], ["proof (chain)\npicking this:\n  eval b [?x, ?i, ?j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 b'", "have b': \"\\<And>i j x. eval b' [i, j, x] \\<down>= list_encode (prefixes z i j x)\""], ["proof (prove)\nusing this:\n  eval b [?x, ?i, ?j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 b'\n\ngoal (1 subgoal):\n 1. \\<And>i j x.\n       eval b' [i, j, x] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j x)", "using b'_def"], ["proof (prove)\nusing this:\n  eval b [?x, ?i, ?j] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 b'\n  b' = Cn 3 b [recf.Id 3 2, recf.Id 3 0, recf.Id 3 1]\n\ngoal (1 subgoal):\n 1. \\<And>i j x.\n       eval b' [i, j, x] \\<down>=\n       Partial_Recursive.list_encode (local.prefixes z i j x)", "by simp"], ["proof (state)\nthis:\n  eval b' [?i, ?j, ?x] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "define r where \"r = Cn 3 r_last [b']\""], ["proof (state)\nthis:\n  r = Cn 3 r_last [b']\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "then"], ["proof (chain)\npicking this:\n  r = Cn 3 r_last [b']", "have \"recfn 3 r\""], ["proof (prove)\nusing this:\n  r = Cn 3 r_last [b']\n\ngoal (1 subgoal):\n 1. recfn 3 r", "using \\<open>recfn 3 b'\\<close>"], ["proof (prove)\nusing this:\n  r = Cn 3 r_last [b']\n  recfn 3 b'\n\ngoal (1 subgoal):\n 1. recfn 3 r", "by simp"], ["proof (state)\nthis:\n  recfn 3 r\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "with b'"], ["proof (chain)\npicking this:\n  eval b' [?i, ?j, ?x] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 r", "have \"\\<And>i j x. eval r [i, j, x] \\<down>= last (prefixes z i j x)\""], ["proof (prove)\nusing this:\n  eval b' [?i, ?j, ?x] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 r\n\ngoal (1 subgoal):\n 1. \\<And>i j x. eval r [i, j, x] \\<down>= last (local.prefixes z i j x)", "using r_def prefixes_length"], ["proof (prove)\nusing this:\n  eval b' [?i, ?j, ?x] \\<down>=\n  Partial_Recursive.list_encode (local.prefixes z ?i ?j ?x)\n  recfn 3 r\n  r = Cn 3 r_last [b']\n  length (local.prefixes ?z ?i ?j ?x) = Suc ?x\n\ngoal (1 subgoal):\n 1. \\<And>i j x. eval r [i, j, x] \\<down>= last (local.prefixes z i j x)", "by auto"], ["proof (state)\nthis:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "moreover"], ["proof (state)\nthis:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "from this"], ["proof (chain)\npicking this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)", "have \"total r\""], ["proof (prove)\nusing this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r", "using totalI3 \\<open>recfn 3 r\\<close>"], ["proof (prove)\nusing this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n  \\<lbrakk>recfn 3 ?f; \\<And>x y z. eval ?f [x, y, z] \\<down>\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  recfn 3 r\n\ngoal (1 subgoal):\n 1. Partial_Recursive.total r", "by simp"], ["proof (state)\nthis:\n  Partial_Recursive.total r\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "ultimately"], ["proof (chain)\npicking this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n  Partial_Recursive.total r", "have \"(\\<lambda>i j x. eval r [i, j, x]) = adverse z\""], ["proof (prove)\nusing this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n  Partial_Recursive.total r\n\ngoal (1 subgoal):\n 1. (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "unfolding adverse_def"], ["proof (prove)\nusing this:\n  eval r [?i, ?j, ?x] \\<down>= last (local.prefixes z ?i ?j ?x)\n  Partial_Recursive.total r\n\ngoal (1 subgoal):\n 1. (\\<lambda>i j x. eval r [i, j, x]) =\n    (\\<lambda>i j x. Some (last (local.prefixes z i j x)))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "with \\<open>recfn 3 r\\<close> \\<open>total r\\<close>"], ["proof (chain)\npicking this:\n  recfn 3 r\n  Partial_Recursive.total r\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 3 r\n  Partial_Recursive.total r\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       recfn 3 r \\<and>\n       Partial_Recursive.total r \\<and>\n       (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z", "by auto"], ["proof (state)\nthis:\n  \\<exists>r.\n     recfn 3 r \\<and>\n     Partial_Recursive.total r \\<and>\n     (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma adverse_in_R1: \"adverse z i j \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "from adverse_in_R3"], ["proof (chain)\npicking this:\n  \\<exists>r.\n     recfn 3 r \\<and>\n     Partial_Recursive.total r \\<and>\n     (\\<lambda>i j x. eval r [i, j, x]) = local.adverse ?z", "obtain r where\n    r: \"recfn 3 r\" \"total r\" \"(\\<lambda>i j x. eval r [i, j, x]) = adverse z\""], ["proof (prove)\nusing this:\n  \\<exists>r.\n     recfn 3 r \\<and>\n     Partial_Recursive.total r \\<and>\n     (\\<lambda>i j x. eval r [i, j, x]) = local.adverse ?z\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 3 r; Partial_Recursive.total r;\n         (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 3 r\n  Partial_Recursive.total r\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "define rij where \"rij = Cn 1 r [r_const i, r_const j, Id 1 0]\""], ["proof (state)\nthis:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "then"], ["proof (chain)\npicking this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]", "have \"recfn 1 rij\" \"total rij\""], ["proof (prove)\nusing this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. recfn 1 rij &&& Partial_Recursive.total rij", "using r(1,2) Cn_total Mn_free_imp_total"], ["proof (prove)\nusing this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]\n  recfn 3 r\n  Partial_Recursive.total r\n  \\<lbrakk>\\<forall>g\\<in>set ?gs. Partial_Recursive.total g;\n   Partial_Recursive.total ?f; recfn ?n (Cn ?n ?f ?gs)\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total (Cn ?n ?f ?gs)\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. recfn 1 rij &&& Partial_Recursive.total rij", "by auto"], ["proof (state)\nthis:\n  recfn 1 rij\n  Partial_Recursive.total rij\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "from rij_def"], ["proof (chain)\npicking this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]", "have \"\\<And>x. eval rij [x] = eval r [i, j, x]\""], ["proof (prove)\nusing this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. \\<And>x. eval rij [x] = eval r [i, j, x]", "using r(1)"], ["proof (prove)\nusing this:\n  rij = Cn 1 r [r_const i, r_const j, recf.Id 1 0]\n  recfn 3 r\n\ngoal (1 subgoal):\n 1. \\<And>x. eval rij [x] = eval r [i, j, x]", "by auto"], ["proof (state)\nthis:\n  eval rij [?x] = eval r [i, j, ?x]\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "with r(3)"], ["proof (chain)\npicking this:\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n  eval rij [?x] = eval r [i, j, ?x]", "have \"\\<And>x. eval rij [x] = adverse z i j x\""], ["proof (prove)\nusing this:\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n  eval rij [?x] = eval r [i, j, ?x]\n\ngoal (1 subgoal):\n 1. \\<And>x. eval rij [x] = local.adverse z i j x", "by metis"], ["proof (state)\nthis:\n  eval rij [?x] = local.adverse z i j ?x\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "with \\<open>recfn 1 rij\\<close> \\<open>total rij\\<close>"], ["proof (chain)\npicking this:\n  recfn 1 rij\n  Partial_Recursive.total rij\n  eval rij [?x] = local.adverse z i j ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  recfn 1 rij\n  Partial_Recursive.total rij\n  eval rij [?x] = local.adverse z i j ?x\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  local.adverse z i j \\<in> \\<R>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next we show that for every $z$ there are $i$, $j$ such that\n@{term[names_short] \"adverse z i j \\<in> V\\<^sub>0\\<^sub>1\"}. The first step is to show that for every\n$z$, G?del numbers for @{term[names_short] \"adverse z i j\"} can be computed\nuniformly from $i$ and $j$.\\<close>"], ["", "lemma phi_translate_adverse: \"\\<exists>f\\<in>\\<R>\\<^sup>2.\\<forall>i j. \\<phi> (the (f i j)) = adverse z i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "obtain r where r: \"recfn 3 r\" \"total r\" \"(\\<lambda>i j x. eval r [i, j, x]) = adverse z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 3 r; Partial_Recursive.total r;\n         (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adverse_in_R3"], ["proof (prove)\nusing this:\n  \\<exists>r.\n     recfn 3 r \\<and>\n     Partial_Recursive.total r \\<and>\n     (\\<lambda>i j x. eval r [i, j, x]) = local.adverse ?z\n\ngoal (1 subgoal):\n 1. (\\<And>r.\n        \\<lbrakk>recfn 3 r; Partial_Recursive.total r;\n         (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  recfn 3 r\n  Partial_Recursive.total r\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "let ?p = \"encode r\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "define rf where \"rf = Cn 2 (r_smn 1 2) [r_dummy 1 (r_const ?p), Id 2 0, Id 2 1]\""], ["proof (state)\nthis:\n  rf =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r)), recf.Id 2 0, recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "then"], ["proof (chain)\npicking this:\n  rf =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r)), recf.Id 2 0, recf.Id 2 1]", "have \"recfn 2 rf\" and \"total rf\""], ["proof (prove)\nusing this:\n  rf =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r)), recf.Id 2 0, recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. recfn 2 rf &&& Partial_Recursive.total rf", "using Mn_free_imp_total"], ["proof (prove)\nusing this:\n  rf =\n  Cn 2 (r_smn 1 2)\n   [r_dummy 1 (r_const (encode r)), recf.Id 2 0, recf.Id 2 1]\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n\ngoal (1 subgoal):\n 1. recfn 2 rf &&& Partial_Recursive.total rf", "by simp_all"], ["proof (state)\nthis:\n  recfn 2 rf\n  Partial_Recursive.total rf\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "define f where \"f \\<equiv> \\<lambda>i j. eval rf [i, j]\""], ["proof (state)\nthis:\n  f \\<equiv> \\<lambda>i j. eval rf [i, j]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "with \\<open>recfn 2 rf\\<close> \\<open>total rf\\<close>"], ["proof (chain)\npicking this:\n  recfn 2 rf\n  Partial_Recursive.total rf\n  f \\<equiv> \\<lambda>i j. eval rf [i, j]", "have \"f \\<in> \\<R>\\<^sup>2\""], ["proof (prove)\nusing this:\n  recfn 2 rf\n  Partial_Recursive.total rf\n  f \\<equiv> \\<lambda>i j. eval rf [i, j]\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>\\<^sup>2", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\\<^sup>2\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have rf: \"eval rf [i, j] = eval (r_smn 1 2) [?p, i, j]\" for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval rf [i, j] = eval (r_smn 1 2) [encode r, i, j]", "unfolding rf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 (r_smn 1 2)\n       [r_dummy 1 (r_const (encode r)), recf.Id 2 0, recf.Id 2 1])\n     [i, j] =\n    eval (r_smn 1 2) [encode r, i, j]", "by simp"], ["proof (state)\nthis:\n  eval rf [?i, ?j] = eval (r_smn 1 2) [encode r, ?i, ?j]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "{"], ["proof (state)\nthis:\n  eval rf [?i, ?j] = eval (r_smn 1 2) [encode r, ?i, ?j]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "fix i j x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"\\<phi> (the (f i j)) x = eval r_phi [the (f i j), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (f i j)) x = eval r_phi [the (f i j), x]", "using phi_def"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f i j)) x = eval r_phi [the (f i j), x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (f i j)) x = eval r_phi [the (f i j), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  \\<phi> (the (f i j)) x = eval r_phi [the (f i j), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = eval r_phi [the (eval rf [i, j]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (f i j), x] = eval r_phi [the (eval rf [i, j]), x]", "using f_def"], ["proof (prove)\nusing this:\n  f \\<equiv> \\<lambda>i j. eval rf [i, j]\n\ngoal (1 subgoal):\n 1. eval r_phi [the (f i j), x] = eval r_phi [the (eval rf [i, j]), x]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (f i j), x] = eval r_phi [the (eval rf [i, j]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  eval r_phi [the (f i j), x] = eval r_phi [the (eval rf [i, j]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = eval (r_universal 1) [the (eval (r_smn 1 2) [?p, i, j]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [the (eval rf [i, j]), x] =\n    eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x]", "using rf r_phi_def"], ["proof (prove)\nusing this:\n  eval rf [?i, ?j] = eval (r_smn 1 2) [encode r, ?i, ?j]\n  r_phi \\<equiv> r_universal 1\n\ngoal (1 subgoal):\n 1. eval r_phi [the (eval rf [i, j]), x] =\n    eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [the (eval rf [i, j]), x] =\n  eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  eval r_phi [the (eval rf [i, j]), x] =\n  eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = eval (r_universal (2 + 1)) (?p # [i, j] @ [x])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x] =\n    eval (r_universal (2 + 1)) (encode r # [i, j] @ [x])", "using smn_lemma[of 1 \"[i, j]\" 2 \"[x]\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < 1; length [i, j] = 2; length [x] = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal (2 + 1)) (?p # [i, j] @ [x]) =\n                    eval (r_universal 1)\n                     [the (eval (r_smn 1 2) [?p, i, j]), x]\n\ngoal (1 subgoal):\n 1. eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x] =\n    eval (r_universal (2 + 1)) (encode r # [i, j] @ [x])", "by simp"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x] =\n  eval (r_universal (2 + 1)) (encode r # [i, j] @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  eval (r_universal 1) [the (eval (r_smn 1 2) [encode r, i, j]), x] =\n  eval (r_universal (2 + 1)) (encode r # [i, j] @ [x])\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = eval (r_universal 3) [?p, i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal (2 + 1)) (encode r # [i, j] @ [x]) =\n    eval (r_universal 3) [encode r, i, j, x]", "by simp"], ["proof (state)\nthis:\n  eval (r_universal (2 + 1)) (encode r # [i, j] @ [x]) =\n  eval (r_universal 3) [encode r, i, j, x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  eval (r_universal (2 + 1)) (encode r # [i, j] @ [x]) =\n  eval (r_universal 3) [encode r, i, j, x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = eval r [i, j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_universal 3) [encode r, i, j, x] = eval r [i, j, x]", "using r_universal r"], ["proof (prove)\nusing this:\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n  recfn 3 r\n  Partial_Recursive.total r\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. eval (r_universal 3) [encode r, i, j, x] = eval r [i, j, x]", "by force"], ["proof (state)\nthis:\n  eval (r_universal 3) [encode r, i, j, x] = eval r [i, j, x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "also"], ["proof (state)\nthis:\n  eval (r_universal 3) [encode r, i, j, x] = eval r [i, j, x]\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "have \"... = adverse z i j x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r [i, j, x] = local.adverse z i j x", "using r(3)"], ["proof (prove)\nusing this:\n  (\\<lambda>i j x. eval r [i, j, x]) = local.adverse z\n\ngoal (1 subgoal):\n 1. eval r [i, j, x] = local.adverse z i j x", "by metis"], ["proof (state)\nthis:\n  eval r [i, j, x] = local.adverse z i j x\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (the (f i j)) x = local.adverse z i j x", "have \"\\<phi> (the (f i j)) x = adverse z i j x\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f i j)) x = local.adverse z i j x\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f i j)) x = local.adverse z i j x", "."], ["proof (state)\nthis:\n  \\<phi> (the (f i j)) x = local.adverse z i j x\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "}"], ["proof (state)\nthis:\n  \\<phi> (the (f ?i2 ?j2)) ?x2 = local.adverse z ?i2 ?j2 ?x2\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "with \\<open>f \\<in> \\<R>\\<^sup>2\\<close>"], ["proof (chain)\npicking this:\n  f \\<in> \\<R>\\<^sup>2\n  \\<phi> (the (f ?i2 ?j2)) ?x2 = local.adverse z ?i2 ?j2 ?x2", "show ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\\<^sup>2\n  \\<phi> (the (f ?i2 ?j2)) ?x2 = local.adverse z ?i2 ?j2 ?x2\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>\\<R>\\<^sup>2.\n       \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j", "by blast"], ["proof (state)\nthis:\n  \\<exists>f\\<in>\\<R>\\<^sup>2.\n     \\<forall>i j. \\<phi> (the (f i j)) = local.adverse z i j\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The second, and final, step is to apply Smullyan's double\nfixed-point theorem to show the existence of @{term[names_short] adverse}\nfunctions in @{term \"V\\<^sub>0\\<^sub>1\"}.\\<close>"], ["", "lemma adverse_in_V01: \"\\<exists>m n. adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and> adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "obtain f\\<^sub>0 where f0: \"f\\<^sub>0 \\<in> \\<R>\\<^sup>2\" \"\\<forall>i j. \\<phi> (the (f\\<^sub>0 i j)) = adverse 0 i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>0.\n        \\<lbrakk>f\\<^sub>0 \\<in> \\<R>\\<^sup>2;\n         \\<forall>i j.\n            \\<phi> (the (f\\<^sub>0 i j)) = local.adverse 0 i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using phi_translate_adverse[of 0]"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>\\<R>\\<^sup>2.\n     \\<forall>i j. \\<phi> (the (f i j)) = local.adverse 0 i j\n\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>0.\n        \\<lbrakk>f\\<^sub>0 \\<in> \\<R>\\<^sup>2;\n         \\<forall>i j.\n            \\<phi> (the (f\\<^sub>0 i j)) = local.adverse 0 i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>0 \\<in> \\<R>\\<^sup>2\n  \\<forall>i j. \\<phi> (the (f\\<^sub>0 i j)) = local.adverse 0 i j\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "obtain f\\<^sub>1 where f1: \"f\\<^sub>1 \\<in> \\<R>\\<^sup>2\" \"\\<forall>i j. \\<phi> (the (f\\<^sub>1 i j)) = adverse 1 i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>1.\n        \\<lbrakk>f\\<^sub>1 \\<in> \\<R>\\<^sup>2;\n         \\<forall>i j.\n            \\<phi> (the (f\\<^sub>1 i j)) = local.adverse 1 i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using phi_translate_adverse[of 1]"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>\\<R>\\<^sup>2.\n     \\<forall>i j. \\<phi> (the (f i j)) = local.adverse 1 i j\n\ngoal (1 subgoal):\n 1. (\\<And>f\\<^sub>1.\n        \\<lbrakk>f\\<^sub>1 \\<in> \\<R>\\<^sup>2;\n         \\<forall>i j.\n            \\<phi> (the (f\\<^sub>1 i j)) = local.adverse 1 i j\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f\\<^sub>1 \\<in> \\<R>\\<^sup>2\n  \\<forall>i j. \\<phi> (the (f\\<^sub>1 i j)) = local.adverse 1 i j\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "obtain m n where \"\\<phi> m = \\<phi> (the (f\\<^sub>0 m n))\" and \"\\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (f\\<^sub>0 m n));\n         \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using smullyan_double_fixed_point[OF f0(1) f1(1)]"], ["proof (prove)\nusing this:\n  (\\<And>m n.\n      \\<lbrakk>\\<phi> m = \\<phi> (the (f\\<^sub>0 m n));\n       \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>\\<phi> m = \\<phi> (the (f\\<^sub>0 m n));\n         \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<phi> m = \\<phi> (the (f\\<^sub>0 m n))\n  \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "with f0(2) f1(2)"], ["proof (chain)\npicking this:\n  \\<forall>i j. \\<phi> (the (f\\<^sub>0 i j)) = local.adverse 0 i j\n  \\<forall>i j. \\<phi> (the (f\\<^sub>1 i j)) = local.adverse 1 i j\n  \\<phi> m = \\<phi> (the (f\\<^sub>0 m n))\n  \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))", "have \"\\<phi> m = adverse 0 m n\" and \"\\<phi> n = adverse 1 m n\""], ["proof (prove)\nusing this:\n  \\<forall>i j. \\<phi> (the (f\\<^sub>0 i j)) = local.adverse 0 i j\n  \\<forall>i j. \\<phi> (the (f\\<^sub>1 i j)) = local.adverse 1 i j\n  \\<phi> m = \\<phi> (the (f\\<^sub>0 m n))\n  \\<phi> n = \\<phi> (the (f\\<^sub>1 m n))\n\ngoal (1 subgoal):\n 1. \\<phi> m = local.adverse 0 m n &&& \\<phi> n = local.adverse 1 m n", "by simp_all"], ["proof (state)\nthis:\n  \\<phi> m = local.adverse 0 m n\n  \\<phi> n = local.adverse 1 m n\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  \\<phi> m = local.adverse 0 m n\n  \\<phi> n = local.adverse 1 m n\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "have \"the (adverse 0 m n 0) = m\" and \"the (adverse 1 m n 1) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (local.adverse 0 m n 0) = m &&& the (local.adverse 1 m n 1) = n", "using adverse_at_01"], ["proof (prove)\nusing this:\n  local.adverse ?z ?i ?j 0 \\<down>= ?i\n  local.adverse ?z ?i ?j 1 \\<down>= ?j\n\ngoal (1 subgoal):\n 1. the (local.adverse 0 m n 0) = m &&& the (local.adverse 1 m n 1) = n", "by simp_all"], ["proof (state)\nthis:\n  the (local.adverse 0 m n 0) = m\n  the (local.adverse 1 m n 1) = n\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> m = local.adverse 0 m n\n  \\<phi> n = local.adverse 1 m n\n  the (local.adverse 0 m n 0) = m\n  the (local.adverse 1 m n 1) = n", "have\n    \"\\<phi> (the (adverse 0 m n 0)) = adverse 0 m n\"\n    \"\\<phi> (the (adverse 1 m n 1)) = adverse 1 m n\""], ["proof (prove)\nusing this:\n  \\<phi> m = local.adverse 0 m n\n  \\<phi> n = local.adverse 1 m n\n  the (local.adverse 0 m n 0) = m\n  the (local.adverse 1 m n 1) = n\n\ngoal (1 subgoal):\n 1. \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n &&&\n    \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n", "by simp_all"], ["proof (state)\nthis:\n  \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n\n  \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "moreover"], ["proof (state)\nthis:\n  \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n\n  \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "have \"adverse 0 m n \\<in> \\<R>\" and \"adverse 1 m n \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse 0 m n \\<in> \\<R> &&& local.adverse 1 m n \\<in> \\<R>", "using adverse_in_R1"], ["proof (prove)\nusing this:\n  local.adverse ?z ?i ?j \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. local.adverse 0 m n \\<in> \\<R> &&& local.adverse 1 m n \\<in> \\<R>", "by simp_all"], ["proof (state)\nthis:\n  local.adverse 0 m n \\<in> \\<R>\n  local.adverse 1 m n \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n\n  \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n\n  local.adverse 0 m n \\<in> \\<R>\n  local.adverse 1 m n \\<in> \\<R>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n\n  \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n\n  local.adverse 0 m n \\<in> \\<R>\n  local.adverse 1 m n \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "using V01_def"], ["proof (prove)\nusing this:\n  \\<phi> (the (local.adverse 0 m n 0)) = local.adverse 0 m n\n  \\<phi> (the (local.adverse 1 m n 1)) = local.adverse 1 m n\n  local.adverse 0 m n \\<in> \\<R>\n  local.adverse 1 m n \\<in> \\<R>\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. \\<exists>m n.\n       local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n       local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1", "by auto"], ["proof (state)\nthis:\n  \\<exists>m n.\n     local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n     local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Before we prove the main result of this section we need some\nlemmas regarding the shape of the @{term[names_short] adverse} functions and\nhypothesis changes of the strategy.\\<close>"], ["", "lemma adverse_Suc:\n  assumes \"x > 0\"\n  shows \"adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc ((adverse z i j) \\<triangleright> x) 0) \\<noteq> s ((adverse z i j) \\<triangleright> x)\n     then 0\n     else if s (e_snoc ((adverse z i j) \\<triangleright> x) 1) \\<noteq> s ((adverse z i j) \\<triangleright> x)\n          then 1 else z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n        s (local.adverse z i j \\<triangleright> x)\n     then 0\n     else if s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> x)\n          then 1 else z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n        s (local.adverse z i j \\<triangleright> x)\n     then 0\n     else if s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> x)\n          then 1 else z)", "have \"adverse z i j (Suc x) \\<down>=\n    (if s (list_encode (prefixes z i j x @ [0])) \\<noteq> s (list_encode (prefixes z i j x))\n     then 0\n     else if s (list_encode (prefixes z i j x @ [1])) \\<noteq> s (list_encode (prefixes z i j x))\n          then 1 else z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (Partial_Recursive.list_encode\n            (local.prefixes z i j x @ [0])) \\<noteq>\n        s (Partial_Recursive.list_encode (local.prefixes z i j x))\n     then 0\n     else if s (Partial_Recursive.list_encode\n                 (local.prefixes z i j x @ [1])) \\<noteq>\n             s (Partial_Recursive.list_encode (local.prefixes z i j x))\n          then 1 else z)", "using assms adverse_def"], ["proof (prove)\nusing this:\n  0 < x\n  local.adverse ?z ?i ?j ?x \\<equiv>\n  Some (last (local.prefixes ?z ?i ?j ?x))\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (Partial_Recursive.list_encode\n            (local.prefixes z i j x @ [0])) \\<noteq>\n        s (Partial_Recursive.list_encode (local.prefixes z i j x))\n     then 0\n     else if s (Partial_Recursive.list_encode\n                 (local.prefixes z i j x @ [1])) \\<noteq>\n             s (Partial_Recursive.list_encode (local.prefixes z i j x))\n          then 1 else z)", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j (Suc x) \\<down>=\n  (if s (Partial_Recursive.list_encode\n          (local.prefixes z i j x @ [0])) \\<noteq>\n      s (Partial_Recursive.list_encode (local.prefixes z i j x))\n   then 0\n   else if s (Partial_Recursive.list_encode\n               (local.prefixes z i j x @ [1])) \\<noteq>\n           s (Partial_Recursive.list_encode (local.prefixes z i j x))\n        then 1 else z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n        s (local.adverse z i j \\<triangleright> x)\n     then 0\n     else if s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> x)\n          then 1 else z)", "then"], ["proof (chain)\npicking this:\n  local.adverse z i j (Suc x) \\<down>=\n  (if s (Partial_Recursive.list_encode\n          (local.prefixes z i j x @ [0])) \\<noteq>\n      s (Partial_Recursive.list_encode (local.prefixes z i j x))\n   then 0\n   else if s (Partial_Recursive.list_encode\n               (local.prefixes z i j x @ [1])) \\<noteq>\n           s (Partial_Recursive.list_encode (local.prefixes z i j x))\n        then 1 else z)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.adverse z i j (Suc x) \\<down>=\n  (if s (Partial_Recursive.list_encode\n          (local.prefixes z i j x @ [0])) \\<noteq>\n      s (Partial_Recursive.list_encode (local.prefixes z i j x))\n   then 0\n   else if s (Partial_Recursive.list_encode\n               (local.prefixes z i j x @ [1])) \\<noteq>\n           s (Partial_Recursive.list_encode (local.prefixes z i j x))\n        then 1 else z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>=\n    (if s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n        s (local.adverse z i j \\<triangleright> x)\n     then 0\n     else if s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> x)\n          then 1 else z)", "by (simp add: init_adverse_eq_prefixes)"], ["proof (state)\nthis:\n  local.adverse z i j (Suc x) \\<down>=\n  (if s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n      s (local.adverse z i j \\<triangleright> x)\n   then 0\n   else if s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\n        then 1 else z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The process in the proof sketch (page~\\pageref{s:v01_not_total})\nconsists of steps (a), (b), and (c). The next abbreviation is true iff.\\ step\n(a) or (b) applies.\\<close>"], ["", "abbreviation \"hyp_change z i j x \\<equiv>\n  s (e_snoc ((adverse z i j) \\<triangleright> x) 0) \\<noteq> s ((adverse z i j) \\<triangleright> x) \\<or>\n  s (e_snoc ((adverse z i j) \\<triangleright> x) 1) \\<noteq> s ((adverse z i j) \\<triangleright> x)\""], ["", "text \\<open>If step (c) applies, the process appends $z$.\\<close>"], ["", "lemma adverse_Suc_not_hyp_change:\n  assumes \"x > 0\" and \"\\<not> hyp_change z i j x\"\n  shows \"adverse z i j (Suc x) \\<down>= z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>= z", "using assms adverse_Suc"], ["proof (prove)\nusing this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x))\n  0 < ?x \\<Longrightarrow>\n  local.adverse ?z ?i ?j (Suc ?x) \\<down>=\n  (if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x) 0) \\<noteq>\n      s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n   then 0\n   else if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n        then 1 else ?z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc x) \\<down>= z", "by simp"], ["", "text \\<open>While (a) or (b) applies, the process appends a value that\nforces $S$ to change its hypothesis.\\<close>"], ["", "lemma while_hyp_change:\n  assumes \"\\<forall>x\\<le>n. x > 0 \\<longrightarrow> hyp_change z i j x\"\n  shows \"\\<forall>x\\<le>Suc n. adverse z i j x = adverse z' i j x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>0.\n       0 < x \\<longrightarrow>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n    \\<forall>x\\<le>Suc 0. local.adverse z i j x = local.adverse z' i j x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "case 0"], ["proof (state)\nthis:\n  \\<forall>x\\<le>0.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (2 subgoals):\n 1. \\<forall>x\\<le>0.\n       0 < x \\<longrightarrow>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n    \\<forall>x\\<le>Suc 0. local.adverse z i j x = local.adverse z' i j x\n 2. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>0.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>0.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc 0. local.adverse z i j x = local.adverse z' i j x", "by (simp add: adverse_def le_Suc_eq)"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc 0. local.adverse z i j x = local.adverse z' i j x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "case (Suc n)"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)", "have \"\\<forall>x\\<le>n. x > 0 \\<longrightarrow> hyp_change z i j x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       0 < x \\<longrightarrow>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x)", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "with Suc"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)", "have \"\\<forall>x\\<le>Suc n. x > 0 \\<longrightarrow> adverse z i j x = adverse z' i j x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  \\<forall>x\\<le>n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc n.\n       0 < x \\<longrightarrow>\n       local.adverse z i j x = local.adverse z' i j x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow> local.adverse z i j x = local.adverse z' i j x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow> local.adverse z i j x = local.adverse z' i j x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "have \"adverse z i j 0 = adverse z' i j 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j 0 = local.adverse z' i j 0", "using adverse_at_01"], ["proof (prove)\nusing this:\n  local.adverse ?z ?i ?j 0 \\<down>= ?i\n  local.adverse ?z ?i ?j 1 \\<down>= ?j\n\ngoal (1 subgoal):\n 1. local.adverse z i j 0 = local.adverse z' i j 0", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j 0 = local.adverse z' i j 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow> local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j 0 = local.adverse z' i j 0", "have zz': \"\\<forall>x\\<le>Suc n. adverse z i j x = adverse z' i j x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow> local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j 0 = local.adverse z' i j 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "moreover"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "have \"adverse z i j \\<in> \\<R>\" \"adverse z' i j \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R> &&& local.adverse z' i j \\<in> \\<R>", "using adverse_in_R1"], ["proof (prove)\nusing this:\n  local.adverse ?z ?i ?j \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> \\<R> &&& local.adverse z' i j \\<in> \\<R>", "by simp_all"], ["proof (state)\nthis:\n  local.adverse z i j \\<in> \\<R>\n  local.adverse z' i j \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j \\<in> \\<R>\n  local.adverse z' i j \\<in> \\<R>", "have init_zz': \"(adverse z i j) \\<triangleright> (Suc n) = (adverse z' i j) \\<triangleright> (Suc n)\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j \\<in> \\<R>\n  local.adverse z' i j \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> Suc n =\n    local.adverse z' i j \\<triangleright> Suc n", "using init_eqI"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j \\<in> \\<R>\n  local.adverse z' i j \\<in> \\<R>\n  (\\<And>x. x \\<le> ?n \\<Longrightarrow> ?f x = ?g x) \\<Longrightarrow>\n  ?f \\<triangleright> ?n = ?g \\<triangleright> ?n\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> Suc n =\n    local.adverse z' i j \\<triangleright> Suc n", "by blast"], ["proof (state)\nthis:\n  local.adverse z i j \\<triangleright> Suc n =\n  local.adverse z' i j \\<triangleright> Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "have \"adverse z i j (Suc (Suc n)) = adverse z' i j (Suc (Suc n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "proof (cases \"s (e_snoc ((adverse z i j) \\<triangleright> (Suc n)) 0) \\<noteq> s ((adverse z i j) \\<triangleright> (Suc n))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "case True"], ["proof (state)\nthis:\n  s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc n)\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "then"], ["proof (chain)\npicking this:\n  s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc n)", "have \"s (e_snoc ((adverse z' i j) \\<triangleright> (Suc n)) 0) \\<noteq> s ((adverse z' i j) \\<triangleright> (Suc n))\""], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z' i j \\<triangleright> Suc n)", "using init_zz'"], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc n)\n  local.adverse z i j \\<triangleright> Suc n =\n  local.adverse z' i j \\<triangleright> Suc n\n\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z' i j \\<triangleright> Suc n)", "by simp"], ["proof (state)\nthis:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z' i j \\<triangleright> Suc n)\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "then"], ["proof (chain)\npicking this:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z' i j \\<triangleright> Suc n)", "have \"adverse z' i j (Suc (Suc n)) \\<down>= 0\""], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z' i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. local.adverse z' i j (Suc (Suc n)) \\<down>= 0", "by (simp add: adverse_Suc)"], ["proof (state)\nthis:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 0\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "moreover"], ["proof (state)\nthis:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 0\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "have \"adverse z i j (Suc (Suc n)) \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) \\<down>= 0", "using True"], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) \\<down>= 0", "by (simp add: adverse_Suc)"], ["proof (state)\nthis:\n  local.adverse z i j (Suc (Suc n)) \\<down>= 0\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 0\n  local.adverse z i j (Suc (Suc n)) \\<down>= 0", "show ?thesis"], ["proof (prove)\nusing this:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 0\n  local.adverse z i j (Suc (Suc n)) \\<down>= 0\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "case False"], ["proof (state)\nthis:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "then"], ["proof (chain)\npicking this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> Suc n)", "have \"s (e_snoc ((adverse z' i j) \\<triangleright> (Suc n)) 0) = s ((adverse z' i j) \\<triangleright> (Suc n))\""], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n    s (local.adverse z' i j \\<triangleright> Suc n)", "using init_zz'"], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> Suc n)\n  local.adverse z i j \\<triangleright> Suc n =\n  local.adverse z' i j \\<triangleright> Suc n\n\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n    s (local.adverse z' i j \\<triangleright> Suc n)", "by simp"], ["proof (state)\nthis:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n  s (local.adverse z' i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "then"], ["proof (chain)\npicking this:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n  s (local.adverse z' i j \\<triangleright> Suc n)", "have \"adverse z' i j (Suc (Suc n)) \\<down>= 1\""], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n  s (local.adverse z' i j \\<triangleright> Suc n)\n\ngoal (1 subgoal):\n 1. local.adverse z' i j (Suc (Suc n)) \\<down>= 1", "using init_zz' Suc.prems adverse_Suc"], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z' i j \\<triangleright> Suc n) 0) =\n  s (local.adverse z' i j \\<triangleright> Suc n)\n  local.adverse z i j \\<triangleright> Suc n =\n  local.adverse z' i j \\<triangleright> Suc n\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  0 < ?x \\<Longrightarrow>\n  local.adverse ?z ?i ?j (Suc ?x) \\<down>=\n  (if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x) 0) \\<noteq>\n      s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n   then 0\n   else if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n        then 1 else ?z)\n\ngoal (1 subgoal):\n 1. local.adverse z' i j (Suc (Suc n)) \\<down>= 1", "by (smt le_refl zero_less_Suc)"], ["proof (state)\nthis:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "moreover"], ["proof (state)\nthis:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "have \"adverse z i j (Suc (Suc n)) \\<down>= 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) \\<down>= 1", "using False Suc.prems adverse_Suc"], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n) 0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> Suc n)\n  \\<forall>x\\<le>Suc n.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  0 < ?x \\<Longrightarrow>\n  local.adverse ?z ?i ?j (Suc ?x) \\<down>=\n  (if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x) 0) \\<noteq>\n      s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n   then 0\n   else if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n        then 1 else ?z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) \\<down>= 1", "by auto"], ["proof (state)\nthis:\n  local.adverse z i j (Suc (Suc n)) \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> Suc n)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> Suc n) \\<Longrightarrow>\n    local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "ultimately"], ["proof (chain)\npicking this:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 1\n  local.adverse z i j (Suc (Suc n)) \\<down>= 1", "show ?thesis"], ["proof (prove)\nusing this:\n  local.adverse z' i j (Suc (Suc n)) \\<down>= 1\n  local.adverse z i j (Suc (Suc n)) \\<down>= 1\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>\\<forall>x\\<le>n.\n                   0 < x \\<longrightarrow>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x) \\<Longrightarrow>\n                \\<forall>x\\<le>Suc n.\n                   local.adverse z i j x = local.adverse z' i j x;\n        \\<forall>x\\<le>Suc n.\n           0 < x \\<longrightarrow>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x) \\<or>\n           s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> x)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<le>Suc (Suc n).\n                            local.adverse z i j x = local.adverse z' i j x", "with zz'"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc (Suc n).\n       local.adverse z i j x = local.adverse z' i j x", "using le_SucE"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>Suc n. local.adverse z i j x = local.adverse z' i j x\n  local.adverse z i j (Suc (Suc n)) = local.adverse z' i j (Suc (Suc n))\n  \\<lbrakk>?m \\<le> Suc ?n; ?m \\<le> ?n \\<Longrightarrow> ?R;\n   ?m = Suc ?n \\<Longrightarrow> ?R\\<rbrakk>\n  \\<Longrightarrow> ?R\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>Suc (Suc n).\n       local.adverse z i j x = local.adverse z' i j x", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<le>Suc (Suc n). local.adverse z i j x = local.adverse z' i j x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next result corresponds to Case~1 from the proof sketch.\\<close>"], ["", "lemma always_hyp_change_no_lim:\n  assumes \"\\<forall>x>0. hyp_change z i j x\"\n  shows \"\\<not> learn_lim \\<phi> {adverse z i j} s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> {local.adverse z i j} s", "proof (rule infinite_hyp_changes_not_Lim[of \"adverse z i j\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. local.adverse z i j \\<in> {local.adverse z i j}\n 2. \\<forall>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "show \"adverse z i j \\<in> {adverse z i j}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse z i j \\<in> {local.adverse z i j}", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j \\<in> {local.adverse z i j}\n\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "show \"\\<forall>n. \\<exists>m\\<^sub>1>n. \\<exists>m\\<^sub>2>n. s (adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq> s (adverse z i j \\<triangleright> m\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "from assms"], ["proof (chain)\npicking this:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)", "obtain m\\<^sub>1 where m1: \"m\\<^sub>1 > n\" \"hyp_change z i j m\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. (\\<And>m\\<^sub>1.\n        \\<lbrakk>n < m\\<^sub>1;\n         s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n         s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             1) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  n < m\\<^sub>1\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "have \"s (adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq> s (adverse z i j \\<triangleright> (Suc m\\<^sub>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "proof (cases \"s (e_snoc ((adverse z i j) \\<triangleright> m\\<^sub>1) 0) \\<noteq> s ((adverse z i j) \\<triangleright> m\\<^sub>1)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "case True"], ["proof (state)\nthis:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)", "have \"adverse z i j (Suc m\\<^sub>1) \\<down>= 0\""], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc m\\<^sub>1) \\<down>= 0", "using m1 adverse_Suc"], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  n < m\\<^sub>1\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  0 < ?x \\<Longrightarrow>\n  local.adverse ?z ?i ?j (Suc ?x) \\<down>=\n  (if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x) 0) \\<noteq>\n      s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n   then 0\n   else if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n        then 1 else ?z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc m\\<^sub>1) \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 0\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 0", "have \"(adverse z i j) \\<triangleright> (Suc m\\<^sub>1) = e_snoc ((adverse z i j) \\<triangleright> m\\<^sub>1) 0\""], ["proof (prove)\nusing this:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 0\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n    e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0", "by (simp add: init_Suc_snoc)"], ["proof (state)\nthis:\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0\n\ngoal (2 subgoals):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n 2. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "with True"], ["proof (chain)\npicking this:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0", "show ?thesis"], ["proof (prove)\nusing this:\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0\n\ngoal (1 subgoal):\n 1. s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "case False"], ["proof (state)\nthis:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)", "have \"adverse z i j (Suc m\\<^sub>1) \\<down>= 1\""], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc m\\<^sub>1) \\<down>= 1", "using m1 adverse_Suc"], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  n < m\\<^sub>1\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  0 < ?x \\<Longrightarrow>\n  local.adverse ?z ?i ?j (Suc ?x) \\<down>=\n  (if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x) 0) \\<noteq>\n      s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n   then 0\n   else if s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x)\n        then 1 else ?z)\n\ngoal (1 subgoal):\n 1. local.adverse z i j (Suc m\\<^sub>1) \\<down>= 1", "by simp"], ["proof (state)\nthis:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "then"], ["proof (chain)\npicking this:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 1", "have \"(adverse z i j) \\<triangleright> (Suc m\\<^sub>1) = e_snoc ((adverse z i j) \\<triangleright> m\\<^sub>1) 1\""], ["proof (prove)\nusing this:\n  local.adverse z i j (Suc m\\<^sub>1) \\<down>= 1\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n    e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1", "by (simp add: init_Suc_snoc)"], ["proof (state)\nthis:\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1\n\ngoal (1 subgoal):\n 1. \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n               0) \\<noteq>\n           s (local.adverse z i j \\<triangleright>\n              m\\<^sub>1) \\<Longrightarrow>\n    s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "with False m1(2)"], ["proof (chain)\npicking this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1)\n             0) \\<noteq>\n         s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 0) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<or>\n  s (e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1)\n  local.adverse z i j \\<triangleright> Suc m\\<^sub>1 =\n  e_snoc (local.adverse z i j \\<triangleright> m\\<^sub>1) 1\n\ngoal (1 subgoal):\n 1. s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n    s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "by simp"], ["proof (state)\nthis:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<exists>m\\<^sub>1>n.\n          \\<exists>m\\<^sub>2>n.\n             s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n             s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)", "show \"\\<exists>m\\<^sub>1>n. \\<exists>m\\<^sub>2>n. s (adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq> s (adverse z i j \\<triangleright> m\\<^sub>2)\""], ["proof (prove)\nusing this:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "using less_SucI m1(1)"], ["proof (prove)\nusing this:\n  s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n  s (local.adverse z i j \\<triangleright> Suc m\\<^sub>1)\n  ?m < ?n \\<Longrightarrow> ?m < Suc ?n\n  n < m\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<^sub>1>n.\n       \\<exists>m\\<^sub>2>n.\n          s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> m\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>m\\<^sub>1>n.\n     \\<exists>m\\<^sub>2>n.\n        s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n        s (local.adverse z i j \\<triangleright> m\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n.\n     \\<exists>m\\<^sub>1>n.\n        \\<exists>m\\<^sub>2>n.\n           s (local.adverse z i j \\<triangleright> m\\<^sub>1) \\<noteq>\n           s (local.adverse z i j \\<triangleright> m\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next result corresponds to Case~2 from the proof sketch.\\<close>"], ["", "lemma no_hyp_change_no_cons:\n  assumes \"x > 0\" and \"\\<not> hyp_change z i j x\"\n  shows \"\\<not> learn_cons \\<phi> {adverse 0 i j, adverse 1 i j} s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "let ?P = \"\\<lambda>x. x > 0 \\<and> \\<not> hyp_change z i j x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "define xmin where \"xmin = Least ?P\""], ["proof (state)\nthis:\n  xmin =\n  (LEAST x.\n      0 < x \\<and>\n      \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x) \\<or>\n              s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x)))\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "with assms"], ["proof (chain)\npicking this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x))\n  xmin =\n  (LEAST x.\n      0 < x \\<and>\n      \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x) \\<or>\n              s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x)))", "have xmin:\n    \"?P xmin\"\n    \"\\<And>x. x < xmin \\<Longrightarrow> \\<not> ?P x\""], ["proof (prove)\nusing this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x))\n  xmin =\n  (LEAST x.\n      0 < x \\<and>\n      \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x) \\<or>\n              s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x)))\n\ngoal (1 subgoal):\n 1. 0 < xmin \\<and>\n    \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin)\n                0) \\<noteq>\n            s (local.adverse z i j \\<triangleright> xmin) \\<or>\n            s (e_snoc (local.adverse z i j \\<triangleright> xmin)\n                1) \\<noteq>\n            s (local.adverse z i j \\<triangleright> xmin)) &&&\n    (\\<And>x.\n        x < xmin \\<Longrightarrow>\n        \\<not> (0 < x \\<and>\n                \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                            0) \\<noteq>\n                        s (local.adverse z i j \\<triangleright> x) \\<or>\n                        s (e_snoc (local.adverse z i j \\<triangleright> x)\n                            1) \\<noteq>\n                        s (local.adverse z i j \\<triangleright> x))))", "using LeastI[of ?P] not_less_Least[of _ ?P]"], ["proof (prove)\nusing this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> x))\n  xmin =\n  (LEAST x.\n      0 < x \\<and>\n      \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x) \\<or>\n              s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n              s (local.adverse z i j \\<triangleright> x)))\n  0 < ?k \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?k) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> ?k) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> ?k) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> ?k)) \\<Longrightarrow>\n  0 < (LEAST x.\n          0 < x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> x))) \\<and>\n  \\<not> (s (e_snoc\n              (local.adverse z i j \\<triangleright>\n               (LEAST x.\n                   0 < x \\<and>\n                   \\<not> (s (e_snoc\n                               (local.adverse z i j \\<triangleright> x)\n                               0) \\<noteq>\n                           s (local.adverse z i j \\<triangleright> x) \\<or>\n                           s (e_snoc\n                               (local.adverse z i j \\<triangleright> x)\n                               1) \\<noteq>\n                           s (local.adverse z i j \\<triangleright> x))))\n              0) \\<noteq>\n          s (local.adverse z i j \\<triangleright>\n             (LEAST x.\n                 0 < x \\<and>\n                 \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                             0) \\<noteq>\n                         s (local.adverse z i j \\<triangleright> x) \\<or>\n                         s (e_snoc (local.adverse z i j \\<triangleright> x)\n                             1) \\<noteq>\n                         s (local.adverse z i j \\<triangleright> x)))) \\<or>\n          s (e_snoc\n              (local.adverse z i j \\<triangleright>\n               (LEAST x.\n                   0 < x \\<and>\n                   \\<not> (s (e_snoc\n                               (local.adverse z i j \\<triangleright> x)\n                               0) \\<noteq>\n                           s (local.adverse z i j \\<triangleright> x) \\<or>\n                           s (e_snoc\n                               (local.adverse z i j \\<triangleright> x)\n                               1) \\<noteq>\n                           s (local.adverse z i j \\<triangleright> x))))\n              1) \\<noteq>\n          s (local.adverse z i j \\<triangleright>\n             (LEAST x.\n                 0 < x \\<and>\n                 \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                             0) \\<noteq>\n                         s (local.adverse z i j \\<triangleright> x) \\<or>\n                         s (e_snoc (local.adverse z i j \\<triangleright> x)\n                             1) \\<noteq>\n                         s (local.adverse z i j \\<triangleright> x)))))\n  ?k < (LEAST x.\n           0 < x \\<and>\n           \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       0) \\<noteq>\n                   s (local.adverse z i j \\<triangleright> x) \\<or>\n                   s (e_snoc (local.adverse z i j \\<triangleright> x)\n                       1) \\<noteq>\n                   s (local.adverse z i j \\<triangleright>\n                      x))) \\<Longrightarrow>\n  \\<not> (0 < ?k \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?k)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?k) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?k)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?k)))\n\ngoal (1 subgoal):\n 1. 0 < xmin \\<and>\n    \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin)\n                0) \\<noteq>\n            s (local.adverse z i j \\<triangleright> xmin) \\<or>\n            s (e_snoc (local.adverse z i j \\<triangleright> xmin)\n                1) \\<noteq>\n            s (local.adverse z i j \\<triangleright> xmin)) &&&\n    (\\<And>x.\n        x < xmin \\<Longrightarrow>\n        \\<not> (0 < x \\<and>\n                \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> x)\n                            0) \\<noteq>\n                        s (local.adverse z i j \\<triangleright> x) \\<or>\n                        s (e_snoc (local.adverse z i j \\<triangleright> x)\n                            1) \\<noteq>\n                        s (local.adverse z i j \\<triangleright> x))))", "by simp_all"], ["proof (state)\nthis:\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  ?x < xmin \\<Longrightarrow>\n  \\<not> (0 < ?x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x)))\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  ?x < xmin \\<Longrightarrow>\n  \\<not> (0 < ?x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x)))", "have \"xmin > 0\""], ["proof (prove)\nusing this:\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  ?x < xmin \\<Longrightarrow>\n  \\<not> (0 < ?x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x)))\n\ngoal (1 subgoal):\n 1. 0 < xmin", "by simp"], ["proof (state)\nthis:\n  0 < xmin\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "have \"\\<forall>x\\<le>xmin - 1. x > 0 \\<longrightarrow> hyp_change z i j x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>xmin - 1.\n       0 < x \\<longrightarrow>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x)", "using xmin"], ["proof (prove)\nusing this:\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  ?x < xmin \\<Longrightarrow>\n  \\<not> (0 < ?x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x)))\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>xmin - 1.\n       0 < x \\<longrightarrow>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse z i j \\<triangleright> x)", "by (metis One_nat_def Suc_pred le_imp_less_Suc)"], ["proof (state)\nthis:\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)", "have\n    \"\\<forall>x\\<le>xmin. adverse z i j x = adverse 0 i j x\"\n    \"\\<forall>x\\<le>xmin. adverse z i j x = adverse 1 i j x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x &&&\n    \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x", "using while_hyp_change[of \"xmin - 1\" z i j 0]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc (xmin - 1).\n     local.adverse z i j x = local.adverse 0 i j x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x &&&\n    \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x", "using while_hyp_change[of \"xmin - 1\" z i j 1]"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x)\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc (xmin - 1).\n     local.adverse z i j x = local.adverse 0 i j x\n  \\<forall>x\\<le>xmin - 1.\n     0 < x \\<longrightarrow>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse z i j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse z i j \\<triangleright> x) \\<Longrightarrow>\n  \\<forall>x\\<le>Suc (xmin - 1).\n     local.adverse z i j x = local.adverse 1 i j x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x &&&\n    \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x", "by simp_all"], ["proof (state)\nthis:\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x", "have\n    init_z0: \"(adverse z i j) \\<triangleright> xmin = (adverse 0 i j) \\<triangleright> xmin\" and\n    init_z1: \"(adverse z i j) \\<triangleright> xmin = (adverse 1 i j) \\<triangleright> xmin\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> xmin =\n    local.adverse 0 i j \\<triangleright> xmin &&&\n    local.adverse z i j \\<triangleright> xmin =\n    local.adverse 1 i j \\<triangleright> xmin", "using adverse_in_R1 init_eqI"], ["proof (prove)\nusing this:\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 0 i j x\n  \\<forall>x\\<le>xmin. local.adverse z i j x = local.adverse 1 i j x\n  local.adverse ?z ?i ?j \\<in> \\<R>\n  (\\<And>x. x \\<le> ?n \\<Longrightarrow> ?f x = ?g x) \\<Longrightarrow>\n  ?f \\<triangleright> ?n = ?g \\<triangleright> ?n\n\ngoal (1 subgoal):\n 1. local.adverse z i j \\<triangleright> xmin =\n    local.adverse 0 i j \\<triangleright> xmin &&&\n    local.adverse z i j \\<triangleright> xmin =\n    local.adverse 1 i j \\<triangleright> xmin", "by blast+"], ["proof (state)\nthis:\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 0 i j \\<triangleright> xmin\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 0 i j \\<triangleright> xmin\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin", "have\n    a0: \"adverse 0 i j (Suc xmin) \\<down>= 0\" and\n    a1: \"adverse 1 i j (Suc xmin) \\<down>= 1\""], ["proof (prove)\nusing this:\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 0 i j \\<triangleright> xmin\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin\n\ngoal (1 subgoal):\n 1. local.adverse 0 i j (Suc xmin) \\<down>= 0 &&&\n    local.adverse 1 i j (Suc xmin) \\<down>= 1", "using adverse_Suc_not_hyp_change xmin(1) init_z1"], ["proof (prove)\nusing this:\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 0 i j \\<triangleright> xmin\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin\n  \\<lbrakk>0 < ?x;\n   \\<not> (s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               0) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x) \\<or>\n           s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> ?x)\n               1) \\<noteq>\n           s (local.adverse ?z ?i ?j \\<triangleright> ?x))\\<rbrakk>\n  \\<Longrightarrow> local.adverse ?z ?i ?j (Suc ?x) \\<down>= ?z\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin\n\ngoal (1 subgoal):\n 1. local.adverse 0 i j (Suc xmin) \\<down>= 0 &&&\n    local.adverse 1 i j (Suc xmin) \\<down>= 1", "by metis+"], ["proof (state)\nthis:\n  local.adverse 0 i j (Suc xmin) \\<down>= 0\n  local.adverse 1 i j (Suc xmin) \\<down>= 1\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  local.adverse 0 i j (Suc xmin) \\<down>= 0\n  local.adverse 1 i j (Suc xmin) \\<down>= 1", "have\n    i0: \"(adverse 0 i j) \\<triangleright> (Suc xmin) = e_snoc ((adverse z i j) \\<triangleright> xmin) 0\" and\n    i1: \"(adverse 1 i j) \\<triangleright> (Suc xmin) = e_snoc ((adverse z i j) \\<triangleright> xmin) 1\""], ["proof (prove)\nusing this:\n  local.adverse 0 i j (Suc xmin) \\<down>= 0\n  local.adverse 1 i j (Suc xmin) \\<down>= 1\n\ngoal (1 subgoal):\n 1. local.adverse 0 i j \\<triangleright> Suc xmin =\n    e_snoc (local.adverse z i j \\<triangleright> xmin) 0 &&&\n    local.adverse 1 i j \\<triangleright> Suc xmin =\n    e_snoc (local.adverse z i j \\<triangleright> xmin) 1", "using init_z0 init_z1"], ["proof (prove)\nusing this:\n  local.adverse 0 i j (Suc xmin) \\<down>= 0\n  local.adverse 1 i j (Suc xmin) \\<down>= 1\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 0 i j \\<triangleright> xmin\n  local.adverse z i j \\<triangleright> xmin =\n  local.adverse 1 i j \\<triangleright> xmin\n\ngoal (1 subgoal):\n 1. local.adverse 0 i j \\<triangleright> Suc xmin =\n    e_snoc (local.adverse z i j \\<triangleright> xmin) 0 &&&\n    local.adverse 1 i j \\<triangleright> Suc xmin =\n    e_snoc (local.adverse z i j \\<triangleright> xmin) 1", "by (simp_all add: init_Suc_snoc)"], ["proof (state)\nthis:\n  local.adverse 0 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 0\n  local.adverse 1 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 1\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "moreover"], ["proof (state)\nthis:\n  local.adverse 0 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 0\n  local.adverse 1 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 1\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "have\n    \"s (e_snoc ((adverse z i j) \\<triangleright> xmin) 0) = s ((adverse z i j) \\<triangleright> xmin)\"\n    \"s (e_snoc ((adverse z i j) \\<triangleright> xmin) 1) = s ((adverse z i j) \\<triangleright> xmin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) =\n    s (local.adverse z i j \\<triangleright> xmin) &&&\n    s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) =\n    s (local.adverse z i j \\<triangleright> xmin)", "using xmin"], ["proof (prove)\nusing this:\n  0 < xmin \\<and>\n  \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin) \\<or>\n          s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) \\<noteq>\n          s (local.adverse z i j \\<triangleright> xmin))\n  ?x < xmin \\<Longrightarrow>\n  \\<not> (0 < ?x \\<and>\n          \\<not> (s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      0) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x) \\<or>\n                  s (e_snoc (local.adverse z i j \\<triangleright> ?x)\n                      1) \\<noteq>\n                  s (local.adverse z i j \\<triangleright> ?x)))\n\ngoal (1 subgoal):\n 1. s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) =\n    s (local.adverse z i j \\<triangleright> xmin) &&&\n    s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) =\n    s (local.adverse z i j \\<triangleright> xmin)", "by simp_all"], ["proof (state)\nthis:\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) =\n  s (local.adverse z i j \\<triangleright> xmin)\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "ultimately"], ["proof (chain)\npicking this:\n  local.adverse 0 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 0\n  local.adverse 1 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 1\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) =\n  s (local.adverse z i j \\<triangleright> xmin)", "have\n    \"s ((adverse 0 i j) \\<triangleright> (Suc xmin)) = s ((adverse z i j) \\<triangleright> xmin)\"\n    \"s ((adverse 1 i j) \\<triangleright> (Suc xmin)) = s ((adverse z i j) \\<triangleright> xmin)\""], ["proof (prove)\nusing this:\n  local.adverse 0 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 0\n  local.adverse 1 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 1\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 0) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (e_snoc (local.adverse z i j \\<triangleright> xmin) 1) =\n  s (local.adverse z i j \\<triangleright> xmin)\n\ngoal (1 subgoal):\n 1. s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n    s (local.adverse z i j \\<triangleright> xmin) &&&\n    s (local.adverse 1 i j \\<triangleright> Suc xmin) =\n    s (local.adverse z i j \\<triangleright> xmin)", "by simp_all"], ["proof (state)\nthis:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (local.adverse 1 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "then"], ["proof (chain)\npicking this:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (local.adverse 1 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)", "have\n    \"s ((adverse 0 i j) \\<triangleright> (Suc xmin)) = s ((adverse 1 i j) \\<triangleright> (Suc xmin))\""], ["proof (prove)\nusing this:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)\n  s (local.adverse 1 i j \\<triangleright> Suc xmin) =\n  s (local.adverse z i j \\<triangleright> xmin)\n\ngoal (1 subgoal):\n 1. s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n    s (local.adverse 1 i j \\<triangleright> Suc xmin)", "by simp"], ["proof (state)\nthis:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse 1 i j \\<triangleright> Suc xmin)\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "moreover"], ["proof (state)\nthis:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse 1 i j \\<triangleright> Suc xmin)\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "have \"(adverse 0 i j) \\<triangleright> (Suc xmin) \\<noteq> (adverse 1 i j) \\<triangleright> (Suc xmin)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n    local.adverse 1 i j \\<triangleright> Suc xmin", "using a0 a1 i0 i1"], ["proof (prove)\nusing this:\n  local.adverse 0 i j (Suc xmin) \\<down>= 0\n  local.adverse 1 i j (Suc xmin) \\<down>= 1\n  local.adverse 0 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 0\n  local.adverse 1 i j \\<triangleright> Suc xmin =\n  e_snoc (local.adverse z i j \\<triangleright> xmin) 1\n\ngoal (1 subgoal):\n 1. local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n    local.adverse 1 i j \\<triangleright> Suc xmin", "by (metis append1_eq_conv list_decode_encode zero_neq_one)"], ["proof (state)\nthis:\n  local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n  local.adverse 1 i j \\<triangleright> Suc xmin\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "ultimately"], ["proof (chain)\npicking this:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse 1 i j \\<triangleright> Suc xmin)\n  local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n  local.adverse 1 i j \\<triangleright> Suc xmin", "show \"\\<not> learn_cons \\<phi> {adverse 0 i j, adverse 1 i j} s\""], ["proof (prove)\nusing this:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse 1 i j \\<triangleright> Suc xmin)\n  local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n  local.adverse 1 i j \\<triangleright> Suc xmin\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "using same_hyp_different_init_not_cons"], ["proof (prove)\nusing this:\n  s (local.adverse 0 i j \\<triangleright> Suc xmin) =\n  s (local.adverse 1 i j \\<triangleright> Suc xmin)\n  local.adverse 0 i j \\<triangleright> Suc xmin \\<noteq>\n  local.adverse 1 i j \\<triangleright> Suc xmin\n  \\<lbrakk>?f \\<in> ?U; ?g \\<in> ?U;\n   ?f \\<triangleright> ?n \\<noteq> ?g \\<triangleright> ?n;\n   ?s (?f \\<triangleright> ?n) = ?s (?g \\<triangleright> ?n)\\<rbrakk>\n  \\<Longrightarrow> \\<not> learn_cons \\<phi> ?U ?s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s", "by blast"], ["proof (state)\nthis:\n  \\<not> learn_cons \\<phi> {local.adverse 0 i j, local.adverse 1 i j} s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Combining the previous two lemmas shows that @{term\n\"V\\<^sub>0\\<^sub>1\"} cannot be learned consistently in the limit by the total\nstrategy $S$.\\<close>"], ["", "lemma V01_not_in_R_cons: \"\\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "obtain m n where\n    mn0: \"adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\" and\n    mn1: \"adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1;\n         local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using adverse_in_V01"], ["proof (prove)\nusing this:\n  \\<exists>m n.\n     local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1 \\<and>\n     local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>m n.\n        \\<lbrakk>local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1;\n         local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "show \"\\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "proof (cases \"\\<forall>x>0. hyp_change 0 m n x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x>0.\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n 2. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "case True"], ["proof (state)\nthis:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x)\n\ngoal (2 subgoals):\n 1. \\<forall>x>0.\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n 2. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "then"], ["proof (chain)\npicking this:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x)", "have \"\\<not> learn_lim \\<phi> {adverse 0 m n} s\""], ["proof (prove)\nusing this:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x)\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> {local.adverse 0 m n} s", "using always_hyp_change_no_lim"], ["proof (prove)\nusing this:\n  \\<forall>x>0.\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse 0 m n \\<triangleright> x)\n  \\<forall>x>0.\n     s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> x) 0) \\<noteq>\n     s (local.adverse ?z ?i ?j \\<triangleright> x) \\<or>\n     s (e_snoc (local.adverse ?z ?i ?j \\<triangleright> x) 1) \\<noteq>\n     s (local.adverse ?z ?i ?j \\<triangleright> x) \\<Longrightarrow>\n  \\<not> learn_lim \\<phi> {local.adverse ?z ?i ?j} s\n\ngoal (1 subgoal):\n 1. \\<not> learn_lim \\<phi> {local.adverse 0 m n} s", "by simp"], ["proof (state)\nthis:\n  \\<not> learn_lim \\<phi> {local.adverse 0 m n} s\n\ngoal (2 subgoals):\n 1. \\<forall>x>0.\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<or>\n       s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n       s (local.adverse 0 m n \\<triangleright> x) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n 2. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "with mn0"], ["proof (chain)\npicking this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_lim \\<phi> {local.adverse 0 m n} s", "show ?thesis"], ["proof (prove)\nusing this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_lim \\<phi> {local.adverse 0 m n} s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "using learn_cons_def learn_lim_closed_subseteq"], ["proof (prove)\nusing this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_lim \\<phi> {local.adverse 0 m n} s\n  learn_cons ?\\<psi> ?U ?s \\<equiv>\n  learn_lim ?\\<psi> ?U ?s \\<and>\n  (\\<forall>f\\<in>?U.\n      \\<forall>n k.\n         k \\<le> n \\<longrightarrow>\n         ?\\<psi> (the (?s (f \\<triangleright> n))) k = f k)\n  \\<lbrakk>learn_lim ?\\<psi> ?U ?s; ?V \\<subseteq> ?U\\<rbrakk>\n  \\<Longrightarrow> learn_lim ?\\<psi> ?V ?s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "by auto"], ["proof (state)\nthis:\n  \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>x>0.\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x) \\<or>\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>x>0.\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x) \\<or>\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x))", "obtain x where x: \"x > 0\" \"\\<not> hyp_change 0 m n x\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>x>0.\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x) \\<or>\n             s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n             s (local.adverse 0 m n \\<triangleright> x))\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>0 < x;\n         \\<not> (s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                     0) \\<noteq>\n                 s (local.adverse 0 m n \\<triangleright> x) \\<or>\n                 s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                     1) \\<noteq>\n                 s (local.adverse 0 m n \\<triangleright> x))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "then"], ["proof (chain)\npicking this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x))", "have \"\\<not> learn_cons \\<phi> {adverse 0 m n, adverse 1 m n} s\""], ["proof (prove)\nusing this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x))\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s", "using no_hyp_change_no_cons[OF x]"], ["proof (prove)\nusing this:\n  0 < x\n  \\<not> (s (e_snoc (local.adverse 0 m n \\<triangleright> x) 0) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x) \\<or>\n          s (e_snoc (local.adverse 0 m n \\<triangleright> x) 1) \\<noteq>\n          s (local.adverse 0 m n \\<triangleright> x))\n  \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s", "by simp"], ["proof (state)\nthis:\n  \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>x>0.\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   0) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x) \\<or>\n               s (e_snoc (local.adverse 0 m n \\<triangleright> x)\n                   1) \\<noteq>\n               s (local.adverse 0 m n \\<triangleright> x)) \\<Longrightarrow>\n    \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "with mn0 mn1"], ["proof (chain)\npicking this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s", "show ?thesis"], ["proof (prove)\nusing this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "using learn_cons_closed_subseteq"], ["proof (prove)\nusing this:\n  local.adverse 0 m n \\<in> V\\<^sub>0\\<^sub>1\n  local.adverse 1 m n \\<in> V\\<^sub>0\\<^sub>1\n  \\<not> learn_cons \\<phi> {local.adverse 0 m n, local.adverse 1 m n} s\n  \\<lbrakk>learn_cons ?\\<psi> ?U ?s; ?V \\<subseteq> ?U\\<rbrakk>\n  \\<Longrightarrow> learn_cons ?\\<psi> ?V ?s\n\ngoal (1 subgoal):\n 1. \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s", "by auto"], ["proof (state)\nthis:\n  \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>@{term \"V\\<^sub>0\\<^sub>1\"} is in CONS\\<close>"], ["", "text \\<open>At first glance, consistently learning @{term \"V\\<^sub>0\\<^sub>1\"} looks fairly\neasy. After all every @{term \"f \\<in> V\\<^sub>0\\<^sub>1\"} provides a G?del number of itself\neither at argument 0 or 1. A strategy only has to figure out which one is\nright. However, the strategy $S$ we are going to devise does not always\nconverge to $f(0)$ or $f(1)$. Instead it uses a technique called\n``amalgamation''. The amalgamation of two G?del numbers $i$ and $j$ is a\nfunction whose value at $x$ is determined by simulating $\\varphi_i(x)$ and\n$\\varphi_j(x)$ in parallel and outputting the value of the first one to halt.\nIf neither halts the value is undefined. There is a function\n$a\\in\\mathcal{R}^2$ such that $\\varphi_{a(i,j)}$ is the amalgamation of $i$\nand $j$.\n\nIf @{term \"f \\<in> V\\<^sub>0\\<^sub>1\"} then $\\varphi_{a(f(0), f(1))}$ is\ntotal because by definition of @{term \"V\\<^sub>0\\<^sub>1\"} we have\n$\\varphi_{f(0)} = f$ or $\\varphi_{f(1)} = f$ and $f$ is total.\n\nGiven a prefix $f^n$ of an @{term \"f \\<in> V\\<^sub>0\\<^sub>1\"} the strategy\n$S$ first computes $\\varphi_{a(f(0), f(1))}(x)$ for $x = 0, \\ldots, n$. For\nthe resulting prefix $\\varphi^n_{a(f(0), f(1))}$ there are two cases:\n\\begin{enumerate}\n\\item[Case 1.] It differs from $f^n$, say at minimum index $x$. Then for\n  either $z = 0$ or $z = 1$ we have $\\varphi_{f(z)}(x) \\neq f(x)$ by\n  definition of amalgamation. This\n  implies $\\varphi_{f(z)} \\neq f$, and thus $\\varphi_{f(1-z)} = f$ by\n  definition of @{term \"V\\<^sub>0\\<^sub>1\"}. We set $S(f^n) = f(1 - z)$. This\n  hypothesis is correct and hence consistent.\n\\item[Case 2.] It equals $f^n$. Then we set $S(f^n) = a(f(0), f(1))$. This\n  hypothesis is consistent by definition of this case.\n\\end{enumerate}\n\nIn both cases the hypothesis is consistent. If Case~1 holds for some $n$, the\nsame $x$ and $z$ will be found also for all larger values of $n$. Therefore\n$S$ converges to the correct hypothesis $f(1 - z)$. If Case~2 holds for all\n$n$, then $S$ always outputs the same hypothesis $a(f(0), f(1))$ and thus\nalso converges.\n\nThe above discussion tacitly assumes $n \\geq 1$, such that both $f(0)$ and\n$f(1)$ are available to $S$. For $n = 0$ the strategy outputs an arbitrary\nconsistent hypothesis.\\<close>"], ["", "text \\<open>Amalgamation uses the concurrent simulation of functions.\\<close>"], ["", "definition parallel :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> nat option\" where\n  \"parallel i j x \\<equiv> eval r_parallel [i, j, x]\""], ["", "lemma r_parallel': \"eval r_parallel [i, j, x] = parallel i j x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = parallel i j x", "using parallel_def"], ["proof (prove)\nusing this:\n  parallel ?i ?j ?x \\<equiv> eval r_parallel [?i, ?j, ?x]\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] = parallel i j x", "by simp"], ["", "lemma r_parallel'':\n  shows \"eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow> eval r_parallel [i, j, x] \\<up>\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x]))\"\n    and \"eval r_phi [j, x] \\<down> \\<and> eval r_phi [i, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<down> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eval r_phi [i, x] \\<up> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<up>) &&&\n     (eval r_phi [i, x] \\<down> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>=\n      prod_encode (0, the (eval r_phi [i, x])))) &&&\n    (eval r_phi [j, x] \\<down> \\<and>\n     eval r_phi [i, x] \\<up> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x]))) &&&\n    (eval r_phi [i, x] \\<down> \\<and>\n     eval r_phi [j, x] \\<down> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (0, the (eval r_phi [i, x])) \\<or>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x])))", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x]))\n 3. eval r_phi [j, x] \\<down> \\<and>\n    eval r_phi [i, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))\n 4. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))", "let ?f = \"Cn 1 r_phi [r_const i, Id 1 0]\""], ["proof (state)\ngoal (4 subgoals):\n 1. eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x]))\n 3. eval r_phi [j, x] \\<down> \\<and>\n    eval r_phi [i, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))\n 4. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))", "let ?g = \"Cn 1 r_phi [r_const j, Id 1 0]\""], ["proof (state)\ngoal (4 subgoals):\n 1. eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x]))\n 3. eval r_phi [j, x] \\<down> \\<and>\n    eval r_phi [i, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))\n 4. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))", "have *: \"\\<And>x. eval r_phi [i, x] = eval ?f [x]\" \"\\<And>x. eval r_phi [j, x] = eval ?g [x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        eval r_phi [i, x] =\n        eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [x]) &&&\n    (\\<And>x.\n        eval r_phi [j, x] = eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [x])", "by simp_all"], ["proof (state)\nthis:\n  eval r_phi [i, ?x] = eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x]\n  eval r_phi [j, ?x] = eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x]\n\ngoal (4 subgoals):\n 1. eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<up>\n 2. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x]))\n 3. eval r_phi [j, x] \\<down> \\<and>\n    eval r_phi [i, x] \\<up> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))\n 4. eval r_phi [i, x] \\<down> \\<and>\n    eval r_phi [j, x] \\<down> \\<Longrightarrow>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (0, the (eval r_phi [i, x])) \\<or>\n    eval r_parallel [i, j, x] \\<down>=\n    prod_encode (1, the (eval r_phi [j, x]))", "show \"eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow> eval r_parallel [i, j, x] \\<up>\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x]))\"\n    and \"eval r_phi [j, x] \\<down> \\<and> eval r_phi [i, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\"\n    and \"eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<down> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (0, the (eval r_phi [i, x])) \\<or>\n      eval r_parallel [i, j, x] \\<down>= prod_encode (1, the (eval r_phi [j, x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eval r_phi [i, x] \\<up> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<up>) &&&\n     (eval r_phi [i, x] \\<down> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>=\n      prod_encode (0, the (eval r_phi [i, x])))) &&&\n    (eval r_phi [j, x] \\<down> \\<and>\n     eval r_phi [i, x] \\<up> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x]))) &&&\n    (eval r_phi [i, x] \\<down> \\<and>\n     eval r_phi [j, x] \\<down> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (0, the (eval r_phi [i, x])) \\<or>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x])))", "using r_parallel[OF *]"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x] \\<up> \\<and>\n  eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, ?x] \\<up>\n  eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x] \\<down> \\<and>\n  eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, ?x] \\<down>=\n  prod_encode (0, the (eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x]))\n  eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x] \\<down> \\<and>\n  eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, ?x] \\<down>=\n  prod_encode (1, the (eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x]))\n  eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x] \\<down> \\<and>\n  eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x] \\<down> \\<Longrightarrow>\n  eval r_parallel [i, j, ?x] \\<down>=\n  prod_encode\n   (0, the (eval (Cn 1 r_phi [r_const i, recf.Id 1 0]) [?x])) \\<or>\n  eval r_parallel [i, j, ?x] \\<down>=\n  prod_encode (1, the (eval (Cn 1 r_phi [r_const j, recf.Id 1 0]) [?x]))\n\ngoal (1 subgoal):\n 1. ((eval r_phi [i, x] \\<up> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<up>) &&&\n     (eval r_phi [i, x] \\<down> \\<and>\n      eval r_phi [j, x] \\<up> \\<Longrightarrow>\n      eval r_parallel [i, j, x] \\<down>=\n      prod_encode (0, the (eval r_phi [i, x])))) &&&\n    (eval r_phi [j, x] \\<down> \\<and>\n     eval r_phi [i, x] \\<up> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x]))) &&&\n    (eval r_phi [i, x] \\<down> \\<and>\n     eval r_phi [j, x] \\<down> \\<Longrightarrow>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (0, the (eval r_phi [i, x])) \\<or>\n     eval r_parallel [i, j, x] \\<down>=\n     prod_encode (1, the (eval r_phi [j, x])))", "by simp_all"], ["proof (state)\nthis:\n  eval r_phi [i, x] \\<up> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, x] \\<up>\n  eval r_phi [i, x] \\<down> \\<and> eval r_phi [j, x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, x] \\<down>=\n  prod_encode (0, the (eval r_phi [i, x]))\n  eval r_phi [j, x] \\<down> \\<and> eval r_phi [i, x] \\<up> \\<Longrightarrow>\n  eval r_parallel [i, j, x] \\<down>=\n  prod_encode (1, the (eval r_phi [j, x]))\n  eval r_phi [i, x] \\<down> \\<and>\n  eval r_phi [j, x] \\<down> \\<Longrightarrow>\n  eval r_parallel [i, j, x] \\<down>=\n  prod_encode (0, the (eval r_phi [i, x])) \\<or>\n  eval r_parallel [i, j, x] \\<down>=\n  prod_encode (1, the (eval r_phi [j, x]))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma parallel:\n  \"\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up> \\<Longrightarrow> parallel i j x \\<up>\"\n  \"\\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow> parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x))\"\n  \"\\<phi> j x \\<down> \\<and> \\<phi> i x \\<up> \\<Longrightarrow> parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\"\n  \"\\<phi> i x \\<down> \\<and> \\<phi> j x \\<down> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)) \\<or>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n      parallel i j x \\<up>) &&&\n     (\\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n      parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)))) &&&\n    (\\<phi> j x \\<down> \\<and> \\<phi> i x \\<up> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))) &&&\n    (\\<phi> i x \\<down> \\<and> \\<phi> j x \\<down> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)) \\<or>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x)))", "using phi_def r_parallel'' r_parallel parallel_def"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n  eval r_phi [?i, ?x] \\<up> \\<and>\n  eval r_phi [?j, ?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [?i, ?j, ?x] \\<up>\n  eval r_phi [?i, ?x] \\<down> \\<and>\n  eval r_phi [?j, ?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [?i, ?j, ?x] \\<down>=\n  prod_encode (0, the (eval r_phi [?i, ?x]))\n  eval r_phi [?j, ?x] \\<down> \\<and>\n  eval r_phi [?i, ?x] \\<up> \\<Longrightarrow>\n  eval r_parallel [?i, ?j, ?x] \\<down>=\n  prod_encode (1, the (eval r_phi [?j, ?x]))\n  eval r_phi [?i, ?x] \\<down> \\<and>\n  eval r_phi [?j, ?x] \\<down> \\<Longrightarrow>\n  eval r_parallel [?i, ?j, ?x] \\<down>=\n  prod_encode (0, the (eval r_phi [?i, ?x])) \\<or>\n  eval r_parallel [?i, ?j, ?x] \\<down>=\n  prod_encode (1, the (eval r_phi [?j, ?x]))\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?f [?x] \\<up> \\<and> eval ?g [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<up>\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?f [?x] \\<down> \\<and> eval ?g [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x]))\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?g [?x] \\<down> \\<and> eval ?f [?x] \\<up>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n  \\<lbrakk>\\<And>x. eval r_phi [?i, x] = eval ?f [x];\n   \\<And>x. eval r_phi [?j, x] = eval ?g [x];\n   eval ?f [?x] \\<down> \\<and> eval ?g [?x] \\<down>\\<rbrakk>\n  \\<Longrightarrow> eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (0, the (eval ?f [?x])) \\<or>\n                    eval r_parallel [?i, ?j, ?x] \\<down>=\n                    prod_encode (1, the (eval ?g [?x]))\n  parallel ?i ?j ?x \\<equiv> eval r_parallel [?i, ?j, ?x]\n\ngoal (1 subgoal):\n 1. ((\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n      parallel i j x \\<up>) &&&\n     (\\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n      parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)))) &&&\n    (\\<phi> j x \\<down> \\<and> \\<phi> i x \\<up> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))) &&&\n    (\\<phi> i x \\<down> \\<and> \\<phi> j x \\<down> \\<Longrightarrow>\n     parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)) \\<or>\n     parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x)))", "by simp_all"], ["", "lemma parallel_converg_pdec1_0_or_1:\n  assumes \"parallel i j x \\<down>\"\n  shows \"pdec1 (the (parallel i j x)) = 0 \\<or> pdec1 (the (parallel i j x)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1 (the (parallel i j x)) = 0 \\<or> pdec1 (the (parallel i j x)) = 1", "using assms parallel[of i x j] parallel(3)[of j x i]"], ["proof (prove)\nusing this:\n  parallel i j x \\<down>\n  \\<phi> i x \\<up> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n  parallel i j x \\<up>\n  \\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n  parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x))\n  \\<phi> i x \\<down> \\<and> \\<phi> j x \\<up> \\<Longrightarrow>\n  parallel j i x \\<down>= prod_encode (1, the (\\<phi> i x))\n  \\<phi> i x \\<down> \\<and> \\<phi> j x \\<down> \\<Longrightarrow>\n  parallel i j x \\<down>= prod_encode (0, the (\\<phi> i x)) \\<or>\n  parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\n  \\<phi> j x \\<down> \\<and> \\<phi> i x \\<up> \\<Longrightarrow>\n  parallel i j x \\<down>= prod_encode (1, the (\\<phi> j x))\n\ngoal (1 subgoal):\n 1. pdec1 (the (parallel i j x)) = 0 \\<or> pdec1 (the (parallel i j x)) = 1", "by (metis fst_eqD option.sel prod_encode_inverse)"], ["", "lemma parallel_converg_either: \"(\\<phi> i x \\<down> \\<or> \\<phi> j x \\<down>) = (parallel i j x \\<down>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> i x \\<down> \\<or> \\<phi> j x \\<down>) = (parallel i j x \\<down>)", "using parallel"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<up> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<up>\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x))\n  \\<phi> ?j ?x \\<down> \\<and> \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<down> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x)) \\<or>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n\ngoal (1 subgoal):\n 1. (\\<phi> i x \\<down> \\<or> \\<phi> j x \\<down>) = (parallel i j x \\<down>)", "by (metis option.simps(3))"], ["", "lemma parallel_0:\n  assumes \"parallel i j x \\<down>= prod_encode (0, v)\"\n  shows \"\\<phi> i x \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>= v", "using parallel assms"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<up> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<up>\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x))\n  \\<phi> ?j ?x \\<down> \\<and> \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<down> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x)) \\<or>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  parallel i j x \\<down>= prod_encode (0, v)\n\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>= v", "by (smt option.collapse option.sel option.simps(3) prod.inject prod_encode_eq zero_neq_one)"], ["", "lemma parallel_1:\n  assumes \"parallel i j x \\<down>= prod_encode (1, v)\"\n  shows \"\\<phi> j x \\<down>= v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> j x \\<down>= v", "using parallel assms"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<up> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<up>\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x))\n  \\<phi> ?j ?x \\<down> \\<and> \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<down> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x)) \\<or>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  parallel i j x \\<down>= prod_encode (1, v)\n\ngoal (1 subgoal):\n 1. \\<phi> j x \\<down>= v", "by (smt option.collapse option.sel option.simps(3) prod.inject prod_encode_eq zero_neq_one)"], ["", "lemma parallel_converg_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"parallel (the (f 0)) (the (f 1)) x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "have \"f \\<in> \\<R> \\<and> (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<and>\n    (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)", "using assms V01_def"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R> \\<and>\n    (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R> \\<and> (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)\n\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "then"], ["proof (chain)\npicking this:\n  f \\<in> \\<R> \\<and> (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)", "have \"\\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  f \\<in> \\<R> \\<and> (\\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f)\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>", "have \"\\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>", "using R1_imp_total1"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) \\<in> \\<R> \\<or> \\<phi> (the (f 1)) \\<in> \\<R>\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>\n\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>\n\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "using parallel_converg_either"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) x \\<down> \\<or> \\<phi> (the (f 1)) x \\<down>\n  (\\<phi> ?i ?x \\<down> \\<or> \\<phi> ?j ?x \\<down>) =\n  (parallel ?i ?j ?x \\<down>)\n\ngoal (1 subgoal):\n 1. parallel (the (f 0)) (the (f 1)) x \\<down>", "by simp"], ["proof (state)\nthis:\n  parallel (the (f 0)) (the (f 1)) x \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The amalgamation of two G?del numbers can then be described\nin terms of @{term \"parallel\"}.\\<close>"], ["", "definition amalgamation :: \"nat \\<Rightarrow> nat \\<Rightarrow> partial1\" where\n  \"amalgamation i j x \\<equiv>\n     if parallel i j x \\<up> then None else Some (pdec2 (the (parallel i j x)))\""], ["", "lemma amalgamation_diverg: \"amalgamation i j x \\<up> \\<longleftrightarrow> \\<phi> i x \\<up> \\<and> \\<phi> j x \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (amalgamation i j x \\<up>) = (\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up>)", "using amalgamation_def parallel"], ["proof (prove)\nusing this:\n  amalgamation ?i ?j ?x \\<equiv>\n  if parallel ?i ?j ?x \\<up> then None\n  else Some (pdec2 (the (parallel ?i ?j ?x)))\n  \\<phi> ?i ?x \\<up> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<up>\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x))\n  \\<phi> ?j ?x \\<down> \\<and> \\<phi> ?i ?x \\<up> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n  \\<phi> ?i ?x \\<down> \\<and> \\<phi> ?j ?x \\<down> \\<Longrightarrow>\n  parallel ?i ?j ?x \\<down>= prod_encode (0, the (\\<phi> ?i ?x)) \\<or>\n  parallel ?i ?j ?x \\<down>= prod_encode (1, the (\\<phi> ?j ?x))\n\ngoal (1 subgoal):\n 1. (amalgamation i j x \\<up>) = (\\<phi> i x \\<up> \\<and> \\<phi> j x \\<up>)", "by (metis option.simps(3))"], ["", "lemma amalgamation_total:\n  assumes \"total1 (\\<phi> i) \\<or> total1 (\\<phi> j)\"\n  shows \"total1 (amalgamation i j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total1 (amalgamation i j)", "using assms amalgamation_diverg[of i j] total_def"], ["proof (prove)\nusing this:\n  total1 (\\<phi> i) \\<or> total1 (\\<phi> j)\n  (amalgamation i j ?x \\<up>) = (\\<phi> i ?x \\<up> \\<and> \\<phi> j ?x \\<up>)\n  Partial_Recursive.total ?f \\<equiv>\n  \\<forall>xs. length xs = arity ?f \\<longrightarrow> eval ?f xs \\<down>\n\ngoal (1 subgoal):\n 1. total1 (amalgamation i j)", "by auto"], ["", "lemma amalgamation_V01_total:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"total1 (amalgamation (the (f 0)) (the (f 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total1 (amalgamation (the (f 0)) (the (f 1)))", "using assms V01_def amalgamation_total R1_imp_total1 total1_def"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n  total1 (\\<phi> ?i) \\<or> total1 (\\<phi> ?j) \\<Longrightarrow>\n  total1 (amalgamation ?i ?j)\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. total1 (amalgamation (the (f 0)) (the (f 1)))", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["", "definition \"r_amalgamation \\<equiv> Cn 3 r_pdec2 [r_parallel]\""], ["", "lemma r_amalgamation_recfn: \"recfn 3 r_amalgamation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 r_amalgamation", "unfolding r_amalgamation_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 3 (Cn 3 r_pdec2 [r_parallel])", "by simp"], ["", "lemma r_amalgamation: \"eval r_amalgamation [i, j, x] = amalgamation i j x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_amalgamation [i, j, x] = amalgamation i j x", "proof (cases \"parallel i j x \\<up>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "case True"], ["proof (state)\nthis:\n  parallel i j x \\<up>\n\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  parallel i j x \\<up>", "have \"eval r_parallel [i, j, x] \\<up>\""], ["proof (prove)\nusing this:\n  parallel i j x \\<up>\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<up>", "by (simp add: r_parallel')"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<up>\n\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  eval r_parallel [i, j, x] \\<up>", "have \"eval r_amalgamation [i, j, x] \\<up>\""], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_amalgamation [i, j, x] \\<up>", "unfolding r_amalgamation_def"], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<up>\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [r_parallel]) [i, j, x] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] \\<up>\n\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "moreover"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] \\<up>\n\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "from True"], ["proof (chain)\npicking this:\n  parallel i j x \\<up>", "have \"amalgamation i j x \\<up>\""], ["proof (prove)\nusing this:\n  parallel i j x \\<up>\n\ngoal (1 subgoal):\n 1. amalgamation i j x \\<up>", "using amalgamation_def"], ["proof (prove)\nusing this:\n  parallel i j x \\<up>\n  amalgamation ?i ?j ?x \\<equiv>\n  if parallel ?i ?j ?x \\<up> then None\n  else Some (pdec2 (the (parallel ?i ?j ?x)))\n\ngoal (1 subgoal):\n 1. amalgamation i j x \\<up>", "by simp"], ["proof (state)\nthis:\n  amalgamation i j x \\<up>\n\ngoal (2 subgoals):\n 1. parallel i j x \\<up> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x\n 2. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "ultimately"], ["proof (chain)\npicking this:\n  eval r_amalgamation [i, j, x] \\<up>\n  amalgamation i j x \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_amalgamation [i, j, x] \\<up>\n  amalgamation i j x \\<up>\n\ngoal (1 subgoal):\n 1. eval r_amalgamation [i, j, x] = amalgamation i j x", "by simp"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] = amalgamation i j x\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "case False"], ["proof (state)\nthis:\n  parallel i j x \\<down>\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  parallel i j x \\<down>", "have \"eval r_parallel [i, j, x] \\<down>\""], ["proof (prove)\nusing this:\n  parallel i j x \\<down>\n\ngoal (1 subgoal):\n 1. eval r_parallel [i, j, x] \\<down>", "by (simp add: r_parallel')"], ["proof (state)\nthis:\n  eval r_parallel [i, j, x] \\<down>\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  eval r_parallel [i, j, x] \\<down>", "have \"eval r_amalgamation [i, j, x] = eval r_pdec2 [the (eval r_parallel [i, j, x])]\""], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval r_amalgamation [i, j, x] =\n    eval r_pdec2 [the (eval r_parallel [i, j, x])]", "unfolding r_amalgamation_def"], ["proof (prove)\nusing this:\n  eval r_parallel [i, j, x] \\<down>\n\ngoal (1 subgoal):\n 1. eval (Cn 3 r_pdec2 [r_parallel]) [i, j, x] =\n    eval r_pdec2 [the (eval r_parallel [i, j, x])]", "by simp"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] =\n  eval r_pdec2 [the (eval r_parallel [i, j, x])]\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "also"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] =\n  eval r_pdec2 [the (eval r_parallel [i, j, x])]\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "have \"... \\<down>= pdec2 (the (eval r_parallel [i, j, x]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_pdec2 [the (eval r_parallel [i, j, x])] \\<down>=\n    pdec2 (the (eval r_parallel [i, j, x]))", "by simp"], ["proof (state)\nthis:\n  eval r_pdec2 [the (eval r_parallel [i, j, x])] \\<down>=\n  pdec2 (the (eval r_parallel [i, j, x]))\n\ngoal (1 subgoal):\n 1. parallel i j x \\<down> \\<Longrightarrow>\n    eval r_amalgamation [i, j, x] = amalgamation i j x", "finally"], ["proof (chain)\npicking this:\n  eval r_amalgamation [i, j, x] \\<down>=\n  pdec2 (the (eval r_parallel [i, j, x]))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_amalgamation [i, j, x] \\<down>=\n  pdec2 (the (eval r_parallel [i, j, x]))\n\ngoal (1 subgoal):\n 1. eval r_amalgamation [i, j, x] = amalgamation i j x", "by (simp add: False amalgamation_def r_parallel')"], ["proof (state)\nthis:\n  eval r_amalgamation [i, j, x] = amalgamation i j x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The function @{term \"amalgamate\"} computes G?del numbers of\namalgamations. It corresponds to the function $a$ from the proof sketch.\\<close>"], ["", "definition amalgamate :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\" where\n  \"amalgamate i j \\<equiv> smn 1 (encode r_amalgamation) [i, j]\""], ["", "lemma amalgamate: \"\\<phi> (amalgamate i j) = amalgamation i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) = amalgamation i j", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "have \"\\<phi> (amalgamate i j) x = eval r_phi [amalgamate i j, x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x = eval r_phi [amalgamate i j, x]", "by (simp add: phi_def)"], ["proof (state)\nthis:\n  \\<phi> (amalgamate i j) x = eval r_phi [amalgamate i j, x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "also"], ["proof (state)\nthis:\n  \\<phi> (amalgamate i j) x = eval r_phi [amalgamate i j, x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "have \"... = eval r_phi [smn 1 (encode r_amalgamation) [i, j], x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [amalgamate i j, x] =\n    eval r_phi [smn 1 (encode r_amalgamation) [i, j], x]", "using amalgamate_def"], ["proof (prove)\nusing this:\n  amalgamate ?i ?j \\<equiv> smn 1 (encode r_amalgamation) [?i, ?j]\n\ngoal (1 subgoal):\n 1. eval r_phi [amalgamate i j, x] =\n    eval r_phi [smn 1 (encode r_amalgamation) [i, j], x]", "by simp"], ["proof (state)\nthis:\n  eval r_phi [amalgamate i j, x] =\n  eval r_phi [smn 1 (encode r_amalgamation) [i, j], x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "also"], ["proof (state)\nthis:\n  eval r_phi [amalgamate i j, x] =\n  eval r_phi [smn 1 (encode r_amalgamation) [i, j], x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "have \"... = eval r_phi\n     [encode (Cn 1 (r_universal 3)\n      (r_constn 0 (encode r_amalgamation) # map (r_constn 0) [i, j] @ map (Id 1) [0])), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi [smn 1 (encode r_amalgamation) [i, j], x] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         (r_constn 0 (encode r_amalgamation) #\n          map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n      x]", "using smn[of 1 \"encode r_amalgamation\" \"[i, j]\"]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  smn 1 (encode r_amalgamation) [i, j] =\n  encode\n   (Cn 1 (r_universal (1 + length [i, j]))\n     (r_constn (1 - 1) (encode r_amalgamation) #\n      map (r_constn (1 - 1)) [i, j] @ map (recf.Id 1) [0..<1]))\n\ngoal (1 subgoal):\n 1. eval r_phi [smn 1 (encode r_amalgamation) [i, j], x] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         (r_constn 0 (encode r_amalgamation) #\n          map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n      x]", "by (simp add: numeral_3_eq_3)"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_amalgamation) [i, j], x] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       (r_constn 0 (encode r_amalgamation) #\n        map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "also"], ["proof (state)\nthis:\n  eval r_phi [smn 1 (encode r_amalgamation) [i, j], x] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       (r_constn 0 (encode r_amalgamation) #\n        map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "have \"... = eval r_phi\n     [encode (Cn 1 (r_universal 3)\n      (r_const (encode r_amalgamation) # [r_const i, r_const j, Id 1 0])), x]\"\n     (is \"... = eval r_phi [encode ?f, x]\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         (r_constn 0 (encode r_amalgamation) #\n          map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n      x] =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_const (encode r_amalgamation), r_const i, r_const j,\n          recf.Id 1 0]),\n      x]", "by (simp add: r_constn_def)"], ["proof (state)\nthis:\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       (r_constn 0 (encode r_amalgamation) #\n        map (r_constn 0) [i, j] @ map (recf.Id 1) [0])),\n    x] =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (amalgamate i j) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]", "have \"\\<phi> (amalgamate i j) x = eval r_phi\n     [encode (Cn 1 (r_universal 3)\n      (r_const (encode r_amalgamation) # [r_const i, r_const j, Id 1 0])), x]\""], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 3)\n         [r_const (encode r_amalgamation), r_const i, r_const j,\n          recf.Id 1 0]),\n      x]", "."], ["proof (state)\nthis:\n  \\<phi> (amalgamate i j) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (amalgamate i j) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]", "have \"\\<phi> (amalgamate i j) x = eval (r_universal 3) [encode r_amalgamation, i, j, x]\""], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x =\n    eval (r_universal 3) [encode r_amalgamation, i, j, x]", "unfolding r_phi_def"], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 1)\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x =\n    eval (r_universal 3) [encode r_amalgamation, i, j, x]", "using r_universal[of ?f 1] r_amalgamation_recfn"], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 1)\n   [encode\n     (Cn 1 (r_universal 3)\n       [r_const (encode r_amalgamation), r_const i, r_const j,\n        recf.Id 1 0]),\n    x]\n  \\<lbrakk>recfn 1\n            (Cn 1 (r_universal 3)\n              [r_const (encode r_amalgamation), r_const i, r_const j,\n               recf.Id 1 0]);\n   length ?xs = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal 1)\n                     (encode\n                       (Cn 1 (r_universal 3)\n                         [r_const (encode r_amalgamation), r_const i,\n                          r_const j, recf.Id 1 0]) #\n                      ?xs) =\n                    eval\n                     (Cn 1 (r_universal 3)\n                       [r_const (encode r_amalgamation), r_const i,\n                        r_const j, recf.Id 1 0])\n                     ?xs\n  recfn 3 r_amalgamation\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x =\n    eval (r_universal 3) [encode r_amalgamation, i, j, x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 3) [encode r_amalgamation, i, j, x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (amalgamate i j) x = amalgamation i j x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 3) [encode r_amalgamation, i, j, x]", "show \"\\<phi> (amalgamate i j) x = amalgamation i j x\""], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 3) [encode r_amalgamation, i, j, x]\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x = amalgamation i j x", "using r_amalgamation"], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate i j) x =\n  eval (r_universal 3) [encode r_amalgamation, i, j, x]\n  eval r_amalgamation [?i, ?j, ?x] = amalgamation ?i ?j ?x\n\ngoal (1 subgoal):\n 1. \\<phi> (amalgamate i j) x = amalgamation i j x", "by (simp add: r_amalgamation_recfn r_universal)"], ["proof (state)\nthis:\n  \\<phi> (amalgamate i j) x = amalgamation i j x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma amalgamation_in_P1: \"amalgamation i j \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amalgamation i j \\<in> \\<P>", "using amalgamate"], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate ?i ?j) = amalgamation ?i ?j\n\ngoal (1 subgoal):\n 1. amalgamation i j \\<in> \\<P>", "by (metis P2_proj_P1 phi_in_P2)"], ["", "lemma amalgamation_V01_R1:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"amalgamation (the (f 0)) (the (f 1)) \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. amalgamation (the (f 0)) (the (f 1)) \\<in> \\<R>", "using assms amalgamation_V01_total amalgamation_in_P1"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  total1 (amalgamation (the (?f 0)) (the (?f 1)))\n  amalgamation ?i ?j \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. amalgamation (the (f 0)) (the (f 1)) \\<in> \\<R>", "by (simp add: P1_total_imp_R1)"], ["", "definition \"r_amalgamate \\<equiv>\n  Cn 2 (r_smn 1 2) [r_dummy 1 (r_const (encode r_amalgamation)), Id 2 0, Id 2 1]\""], ["", "lemma r_amalgamate_recfn: \"recfn 2 r_amalgamate\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_amalgamate", "unfolding r_amalgamate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (Cn 2 (r_smn 1 2)\n       [r_dummy 1 (r_const (encode r_amalgamation)), recf.Id 2 0,\n        recf.Id 2 1])", "by simp"], ["", "lemma r_amalgamate: \"eval r_amalgamate [i, j] \\<down>= amalgamate i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "let ?p = \"encode r_amalgamation\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "have rs21: \"eval (r_smn 1 2) [?p, i, j] \\<down>= smn 1 ?p [i, j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n    smn 1 (encode r_amalgamation) [i, j]", "using r_smn"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n; length ?cs = ?m\\<rbrakk>\n  \\<Longrightarrow> eval (r_smn ?n ?m) (?p # ?cs) \\<down>= smn ?n ?p ?cs\n\ngoal (1 subgoal):\n 1. eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n    smn 1 (encode r_amalgamation) [i, j]", "by simp"], ["proof (state)\nthis:\n  eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n  smn 1 (encode r_amalgamation) [i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "moreover"], ["proof (state)\nthis:\n  eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n  smn 1 (encode r_amalgamation) [i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "have \"eval r_amalgamate [i, j] = eval (r_smn 1 2) [?p, i, j]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] =\n    eval (r_smn 1 2) [encode r_amalgamation, i, j]", "unfolding r_amalgamate_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 (r_smn 1 2)\n       [r_dummy 1 (r_const (encode r_amalgamation)), recf.Id 2 0,\n        recf.Id 2 1])\n     [i, j] =\n    eval (r_smn 1 2) [encode r_amalgamation, i, j]", "by auto"], ["proof (state)\nthis:\n  eval r_amalgamate [i, j] = eval (r_smn 1 2) [encode r_amalgamation, i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "ultimately"], ["proof (chain)\npicking this:\n  eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n  smn 1 (encode r_amalgamation) [i, j]\n  eval r_amalgamate [i, j] = eval (r_smn 1 2) [encode r_amalgamation, i, j]", "have \"eval r_amalgamate [i, j] \\<down>= smn 1 ?p [i, j]\""], ["proof (prove)\nusing this:\n  eval (r_smn 1 2) [encode r_amalgamation, i, j] \\<down>=\n  smn 1 (encode r_amalgamation) [i, j]\n  eval r_amalgamate [i, j] = eval (r_smn 1 2) [encode r_amalgamation, i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= smn 1 (encode r_amalgamation) [i, j]", "by simp"], ["proof (state)\nthis:\n  eval r_amalgamate [i, j] \\<down>= smn 1 (encode r_amalgamation) [i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "then"], ["proof (chain)\npicking this:\n  eval r_amalgamate [i, j] \\<down>= smn 1 (encode r_amalgamation) [i, j]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_amalgamate [i, j] \\<down>= smn 1 (encode r_amalgamation) [i, j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "using amalgamate_def"], ["proof (prove)\nusing this:\n  eval r_amalgamate [i, j] \\<down>= smn 1 (encode r_amalgamation) [i, j]\n  amalgamate ?i ?j \\<equiv> smn 1 (encode r_amalgamation) [?i, ?j]\n\ngoal (1 subgoal):\n 1. eval r_amalgamate [i, j] \\<down>= amalgamate i j", "by simp"], ["proof (state)\nthis:\n  eval r_amalgamate [i, j] \\<down>= amalgamate i j\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The strategy $S$ distinguishes the two cases from the proof\nsketch with the help of the next function, which checks if a hypothesis\n$\\varphi_i$ is inconsistent with a prefix $e$. If so, it returns the least $x\n< |e|$ witnessing the inconsistency; otherwise it returns the length $|e|$.\nIf $\\varphi_i$ diverges for some $x < |e|$, so does the function.\\<close>"], ["", "definition inconsist :: partial2 where\n  \"inconsist i e \\<equiv>\n    (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\""], ["", "lemma inconsist_converg:\n  assumes \"inconsist i e \\<down>\"\n  shows \"inconsist i e =\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then Some (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n     else Some (e_length e))\"\n    and \"\\<forall>x<e_length e. \\<phi> i x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist i e =\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then Some\n           (LEAST x.\n               x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n     else Some (e_length e)) &&&\n    \\<forall>x<e_length e. \\<phi> i x \\<down>", "using inconsist_def assms"], ["proof (prove)\nusing this:\n  inconsist ?i ?e \\<equiv>\n  if \\<exists>x<e_length ?e. \\<phi> ?i x \\<up> then None\n  else if \\<exists>x<e_length ?e. \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x\n       then Some\n             (LEAST x.\n                 x < e_length ?e \\<and>\n                 \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x)\n       else Some (e_length ?e)\n  inconsist i e \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i e =\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then Some\n           (LEAST x.\n               x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n     else Some (e_length e)) &&&\n    \\<forall>x<e_length e. \\<phi> i x \\<down>", "by (presburger, meson)"], ["", "lemma inconsist_bounded:\n  assumes \"inconsist i e \\<down>\"\n  shows \"the (inconsist i e) \\<le> e_length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. the (inconsist i e) \\<le> e_length e", "proof (cases \"\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x<e_length e.\n       \\<phi> i x \\<down>\\<noteq> e_nth e x \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e\n 2. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e", "case True"], ["proof (state)\nthis:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (2 subgoals):\n 1. \\<exists>x<e_length e.\n       \\<phi> i x \\<down>\\<noteq> e_nth e x \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e\n 2. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. the (inconsist i e) \\<le> e_length e", "using inconsist_converg[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  inconsist i e =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some\n         (LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n  \\<forall>x<e_length e. \\<phi> i x \\<down>\n\ngoal (1 subgoal):\n 1. the (inconsist i e) \\<le> e_length e", "by (smt Least_le dual_order.strict_implies_order dual_order.strict_trans2 option.sel)"], ["proof (state)\nthis:\n  the (inconsist i e) \\<le> e_length e\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    the (inconsist i e) \\<le> e_length e", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. the (inconsist i e) \\<le> e_length e", "using inconsist_converg[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  inconsist i e =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some\n         (LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n  \\<forall>x<e_length e. \\<phi> i x \\<down>\n\ngoal (1 subgoal):\n 1. the (inconsist i e) \\<le> e_length e", "by auto"], ["proof (state)\nthis:\n  the (inconsist i e) \\<le> e_length e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsist_consistent:\n  assumes \"inconsist i e \\<down>\"\n  shows \"inconsist i e \\<down>= e_length e \\<longleftrightarrow> (\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inconsist i e \\<down>= e_length e) =\n    (\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inconsist i e \\<down>= e_length e \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n 2. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n    inconsist i e \\<down>= e_length e", "show \"\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\" if \"inconsist i e \\<down>= e_length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "proof (cases \"\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x<e_length e.\n       \\<phi> i x \\<down>\\<noteq> e_nth e x \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n 2. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "case True"], ["proof (state)\nthis:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (2 subgoals):\n 1. \\<exists>x<e_length e.\n       \\<phi> i x \\<down>\\<noteq> e_nth e x \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n 2. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "using that inconsist_converg[OF assms]"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  inconsist i e \\<down>= e_length e\n  inconsist i e =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some\n         (LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n  \\<forall>x<e_length e. \\<phi> i x \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "by (metis (mono_tags, lifting) not_less_Least option.inject)"], ["proof (state)\nthis:\n  \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<e_length e.\n               \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<Longrightarrow>\n    \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "using that inconsist_converg[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  inconsist i e \\<down>= e_length e\n  inconsist i e =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some\n         (LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n  \\<forall>x<e_length e. \\<phi> i x \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inconsist i e \\<down>= e_length e \\<Longrightarrow>\n  \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n    inconsist i e \\<down>= e_length e", "show \"\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow> inconsist i e \\<down>= e_length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n    inconsist i e \\<down>= e_length e", "unfolding inconsist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n    (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < e_length e \\<and>\n                    \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    e_length e", "using assms"], ["proof (prove)\nusing this:\n  inconsist i e \\<down>\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n    (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < e_length e \\<and>\n                    \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    e_length e", "by auto"], ["proof (state)\nthis:\n  \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x \\<Longrightarrow>\n  inconsist i e \\<down>= e_length e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsist_converg_eq:\n  assumes \"inconsist i e \\<down>= e_length e\"\n  shows \"\\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "using assms inconsist_consistent"], ["proof (prove)\nusing this:\n  inconsist i e \\<down>= e_length e\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  (inconsist ?i ?e \\<down>= e_length ?e) =\n  (\\<forall>x<e_length ?e. \\<phi> ?i x \\<down>= e_nth ?e x)\n\ngoal (1 subgoal):\n 1. \\<forall>x<e_length e. \\<phi> i x \\<down>= e_nth e x", "by auto"], ["", "lemma inconsist_converg_less:\n  assumes \"inconsist i e \\<down>\" and \"the (inconsist i e) < e_length e\"\n  shows \"\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\"\n    and \"inconsist i e \\<down>= (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x &&&\n    inconsist i e \\<down>=\n    (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n 2. inconsist i e \\<down>=\n    (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "show \"\\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x", "using assms"], ["proof (prove)\nusing this:\n  inconsist i e \\<down>\n  the (inconsist i e) < e_length e\n\ngoal (1 subgoal):\n 1. \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x", "by (metis (no_types, lifting) inconsist_converg(1) nat_neq_iff option.sel)"], ["proof (state)\nthis:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. inconsist i e \\<down>=\n    (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x", "show \"inconsist i e \\<down>= (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. inconsist i e \\<down>=\n    (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "using assms inconsist_converg"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  inconsist i e \\<down>\n  the (inconsist i e) < e_length e\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  inconsist ?i ?e =\n  (if \\<exists>x<e_length ?e. \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x\n   then Some\n         (LEAST x.\n             x < e_length ?e \\<and> \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x)\n   else Some (e_length ?e))\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  \\<forall>x<e_length ?e. \\<phi> ?i x \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i e \\<down>=\n    (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "by presburger"], ["proof (state)\nthis:\n  inconsist i e \\<down>=\n  (LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_bounded_Suc:\n  assumes \"\\<exists>x. x < upper \\<and> P x\"\n  shows \"(LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "let ?Q = \"\\<lambda>x. x < upper \\<and> P x\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "let ?x = \"Least ?Q\""], ["proof (state)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>x<upper. P x", "have \"?x < upper \\<and> P ?x\""], ["proof (prove)\nusing this:\n  \\<exists>x<upper. P x\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) < upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)", "using LeastI_ex[of ?Q]"], ["proof (prove)\nusing this:\n  \\<exists>x<upper. P x\n  \\<exists>x<upper. P x \\<Longrightarrow>\n  (LEAST x. x < upper \\<and> P x) < upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) < upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)", "by simp"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) < upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "then"], ["proof (chain)\npicking this:\n  (LEAST x. x < upper \\<and> P x) < upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)", "have 1: \"?x < Suc upper \\<and> P ?x\""], ["proof (prove)\nusing this:\n  (LEAST x. x < upper \\<and> P x) < upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)", "by simp"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>x<upper. P x", "have 2: \"\\<forall>y<?x. \\<not> P y\""], ["proof (prove)\nusing this:\n  \\<exists>x<upper. P x\n\ngoal (1 subgoal):\n 1. \\<forall>y<LEAST x. x < upper \\<and> P x. \\<not> P y", "using Least_le[of ?Q] not_less_Least"], ["proof (prove)\nusing this:\n  \\<exists>x<upper. P x\n  ?k < upper \\<and> P ?k \\<Longrightarrow>\n  (LEAST x. x < upper \\<and> P x) \\<le> ?k\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n\ngoal (1 subgoal):\n 1. \\<forall>y<LEAST x. x < upper \\<and> P x. \\<not> P y", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y<LEAST x. x < upper \\<and> P x. \\<not> P y\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "have \"(LEAST x. x < Suc upper \\<and> P x) = ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x < Suc upper \\<and> P x) = (LEAST x. x < upper \\<and> P x)", "proof (rule Least_equality)"], ["proof (state)\ngoal (2 subgoals):\n 1. (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)\n 2. \\<And>y.\n       y < Suc upper \\<and> P y \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) \\<le> y", "show \"?x < Suc upper \\<and> P ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)", "using 1 2"], ["proof (prove)\nusing this:\n  (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n  \\<forall>y<LEAST x. x < upper \\<and> P x. \\<not> P y\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n    P (LEAST x. x < upper \\<and> P x)", "by blast"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc upper \\<and> P y \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) \\<le> y", "show \"\\<And>y. y < Suc upper \\<and> P y \\<Longrightarrow> ?x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc upper \\<and> P y \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) \\<le> y", "using 1 2 leI"], ["proof (prove)\nusing this:\n  (LEAST x. x < upper \\<and> P x) < Suc upper \\<and>\n  P (LEAST x. x < upper \\<and> P x)\n  \\<forall>y<LEAST x. x < upper \\<and> P x. \\<not> P y\n  \\<not> ?x < ?y \\<Longrightarrow> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y < Suc upper \\<and> P y \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) \\<le> y", "by blast"], ["proof (state)\nthis:\n  ?y < Suc upper \\<and> P ?y \\<Longrightarrow>\n  (LEAST x. x < upper \\<and> P x) \\<le> ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (LEAST x. x < Suc upper \\<and> P x) = (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", "then"], ["proof (chain)\npicking this:\n  (LEAST x. x < Suc upper \\<and> P x) = (LEAST x. x < upper \\<and> P x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST x. x < Suc upper \\<and> P x) = (LEAST x. x < upper \\<and> P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)", ".."], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < Suc upper \\<and> P x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma least_bounded_gr:\n  fixes P :: \"nat \\<Rightarrow> bool\" and m :: nat\n  assumes \"\\<exists>x. x < upper \\<and> P x\"\n  shows \"(LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)", "proof (induction m)"], ["proof (state)\ngoal (2 subgoals):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + 0 \\<and> P x)\n 2. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + 0 \\<and> P x)\n 2. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + 0 \\<and> P x)", "by simp"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + 0 \\<and> P x)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "case (Suc m)"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "moreover"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "have \"\\<exists>x. x < upper + m \\<and> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x<upper + m. P x", "using assms trans_less_add1"], ["proof (prove)\nusing this:\n  \\<exists>x<upper. P x\n  ?i < ?j \\<Longrightarrow> ?i < ?j + ?m\n\ngoal (1 subgoal):\n 1. \\<exists>x<upper + m. P x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x<upper + m. P x\n\ngoal (1 subgoal):\n 1. \\<And>m.\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + m \\<and> P x) \\<Longrightarrow>\n       (LEAST x. x < upper \\<and> P x) =\n       (LEAST x. x < upper + Suc m \\<and> P x)", "ultimately"], ["proof (chain)\npicking this:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\n  \\<exists>x<upper + m. P x", "show ?case"], ["proof (prove)\nusing this:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\n  \\<exists>x<upper + m. P x\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) =\n    (LEAST x. x < upper + Suc m \\<and> P x)", "using least_bounded_Suc"], ["proof (prove)\nusing this:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + m \\<and> P x)\n  \\<exists>x<upper + m. P x\n  \\<exists>x<?upper. ?P x \\<Longrightarrow>\n  (LEAST x. x < ?upper \\<and> ?P x) = (LEAST x. x < Suc ?upper \\<and> ?P x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < upper \\<and> P x) =\n    (LEAST x. x < upper + Suc m \\<and> P x)", "by simp"], ["proof (state)\nthis:\n  (LEAST x. x < upper \\<and> P x) = (LEAST x. x < upper + Suc m \\<and> P x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsist_init_converg_less:\n  assumes \"f \\<in> \\<R>\"\n    and \"\\<phi> i \\<in> \\<R>\"\n    and \"inconsist i (f \\<triangleright> n) \\<down>\"\n    and \"the (inconsist i (f \\<triangleright> n)) < Suc n\"\n  shows \"inconsist i (f \\<triangleright> (n + m)) = inconsist i (f \\<triangleright> n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "have phi_i_total: \"\\<phi> i x \\<down>\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> \\<R>\n  \\<phi> i \\<in> \\<R>\n  inconsist i (f \\<triangleright> n) \\<down>\n  the (inconsist i (f \\<triangleright> n)) < Suc n\n\ngoal (1 subgoal):\n 1. \\<phi> i x \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<phi> i ?x \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "moreover"], ["proof (state)\nthis:\n  \\<phi> i ?x \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "have f_nth: \"f x \\<down>= e_nth (f \\<triangleright> n) x\" if \"x < Suc n\" for x n"], ["proof (prove)\ngoal (1 subgoal):\n 1. f x \\<down>= e_nth (f \\<triangleright> n) x", "using that assms(1)"], ["proof (prove)\nusing this:\n  x < Suc n\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. f x \\<down>= e_nth (f \\<triangleright> n) x", "by simp"], ["proof (state)\nthis:\n  ?x < Suc ?n \\<Longrightarrow>\n  f ?x \\<down>= e_nth (f \\<triangleright> ?n) ?x\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> i ?x \\<down>\n  ?x < Suc ?n \\<Longrightarrow>\n  f ?x \\<down>= e_nth (f \\<triangleright> ?n) ?x", "have \"(\\<phi> i x \\<noteq> f x) = (\\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\" if \"x < Suc n\" for x n"], ["proof (prove)\nusing this:\n  \\<phi> i ?x \\<down>\n  ?x < Suc ?n \\<Longrightarrow>\n  f ?x \\<down>= e_nth (f \\<triangleright> ?n) ?x\n\ngoal (1 subgoal):\n 1. (\\<phi> i x \\<noteq> f x) =\n    (\\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "using that"], ["proof (prove)\nusing this:\n  \\<phi> i ?x \\<down>\n  ?x < Suc ?n \\<Longrightarrow>\n  f ?x \\<down>= e_nth (f \\<triangleright> ?n) ?x\n  x < Suc n\n\ngoal (1 subgoal):\n 1. (\\<phi> i x \\<noteq> f x) =\n    (\\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "by simp"], ["proof (state)\nthis:\n  ?x < Suc ?n \\<Longrightarrow>\n  (\\<phi> i ?x \\<noteq> f ?x) =\n  (\\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  ?x < Suc ?n \\<Longrightarrow>\n  (\\<phi> i ?x \\<noteq> f ?x) =\n  (\\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)", "have cond: \"(x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n      (x < e_length (f \\<triangleright> n) \\<and> \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\" for x n"], ["proof (prove)\nusing this:\n  ?x < Suc ?n \\<Longrightarrow>\n  (\\<phi> i ?x \\<noteq> f ?x) =\n  (\\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n\ngoal (1 subgoal):\n 1. (x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n    (x < e_length (f \\<triangleright> n) \\<and>\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "using length_init"], ["proof (prove)\nusing this:\n  ?x < Suc ?n \\<Longrightarrow>\n  (\\<phi> i ?x \\<noteq> f ?x) =\n  (\\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n  e_length (?f \\<triangleright> ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. (x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n    (x < e_length (f \\<triangleright> n) \\<and>\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "by metis"], ["proof (state)\nthis:\n  (?x < Suc ?n \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> ?n) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  (?x < Suc ?n \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> ?n) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)", "have\n    1: \"\\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\" and\n    2: \"inconsist i (f \\<triangleright> n) \\<down>= (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)\""], ["proof (prove)\nusing this:\n  (?x < Suc ?n \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> ?n) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x &&&\n    inconsist i (f \\<triangleright> n) \\<down>=\n    (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)", "using assms(3,4) inconsist_converg_less[of i \"f \\<triangleright> n\"]"], ["proof (prove)\nusing this:\n  (?x < Suc ?n \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> ?n) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n  inconsist i (f \\<triangleright> n) \\<down>\n  the (inconsist i (f \\<triangleright> n)) < Suc n\n  \\<lbrakk>inconsist i (f \\<triangleright> n) \\<down>;\n   the (inconsist i (f \\<triangleright> n))\n   < e_length (f \\<triangleright> n)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x<e_length (f \\<triangleright> n).\n                       \\<phi> i x \\<down>\\<noteq>\n                       e_nth (f \\<triangleright> n) x\n  \\<lbrakk>inconsist i (f \\<triangleright> n) \\<down>;\n   the (inconsist i (f \\<triangleright> n))\n   < e_length (f \\<triangleright> n)\\<rbrakk>\n  \\<Longrightarrow> inconsist i (f \\<triangleright> n) \\<down>=\n                    (LEAST x.\n                        x < e_length (f \\<triangleright> n) \\<and>\n                        \\<phi> i x \\<down>\\<noteq>\n                        e_nth (f \\<triangleright> n) x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x &&&\n    inconsist i (f \\<triangleright> n) \\<down>=\n    (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\n  inconsist i (f \\<triangleright> n) \\<down>=\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\n  inconsist i (f \\<triangleright> n) \\<down>=\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)", "have 3: \"\\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x\""], ["proof (prove)\nusing this:\n  \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\n  inconsist i (f \\<triangleright> n) \\<down>=\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x", "using not_add_less1"], ["proof (prove)\nusing this:\n  \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\n  inconsist i (f \\<triangleright> n) \\<down>=\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)\n  \\<not> ?i + ?j < ?i\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x", "by fastforce"], ["proof (state)\nthis:\n  \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x", "have \"\\<exists>x<Suc (n + m). \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\""], ["proof (prove)\nusing this:\n  \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc (n + m).\n       \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x", "using cond"], ["proof (prove)\nusing this:\n  \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x\n  (?x < Suc ?n \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> ?n) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> ?n) ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc (n + m).\n       \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x<Suc (n + m).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<Suc (n + m).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x", "have \"\\<exists>x<e_length (f \\<triangleright> (n + m)). \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\""], ["proof (prove)\nusing this:\n  \\<exists>x<Suc (n + m).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n\ngoal (1 subgoal):\n 1. \\<exists>x<e_length (f \\<triangleright> (n + m)).\n       \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x", "by simp"], ["proof (state)\nthis:\n  \\<exists>x<e_length (f \\<triangleright> (n + m)).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "moreover"], ["proof (state)\nthis:\n  \\<exists>x<e_length (f \\<triangleright> (n + m)).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "have 4: \"inconsist i (f \\<triangleright> (n + m)) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>", "using assms(2) R1_imp_total1 inconsist_def"], ["proof (prove)\nusing this:\n  \\<phi> i \\<in> \\<R>\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  inconsist ?i ?e \\<equiv>\n  if \\<exists>x<e_length ?e. \\<phi> ?i x \\<up> then None\n  else if \\<exists>x<e_length ?e. \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x\n       then Some\n             (LEAST x.\n                 x < e_length ?e \\<and>\n                 \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x)\n       else Some (e_length ?e)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>", "by simp"], ["proof (state)\nthis:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>x<e_length (f \\<triangleright> (n + m)).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n  inconsist i (f \\<triangleright> (n + m)) \\<down>", "have \"inconsist i (f \\<triangleright> (n + m)) \\<down>=\n      (LEAST x. x < e_length (f \\<triangleright> (n + m)) \\<and> \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)\""], ["proof (prove)\nusing this:\n  \\<exists>x<e_length (f \\<triangleright> (n + m)).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n  inconsist i (f \\<triangleright> (n + m)) \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>=\n    (LEAST x.\n        x < e_length (f \\<triangleright> (n + m)) \\<and>\n        \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)", "using inconsist_converg[OF 4]"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length (f \\<triangleright> (n + m)).\n     \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n  inconsist i (f \\<triangleright> (n + m)) \\<down>\n  inconsist i (f \\<triangleright> (n + m)) =\n  (if \\<exists>x<e_length (f \\<triangleright> (n + m)).\n         \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x\n   then Some\n         (LEAST x.\n             x < e_length (f \\<triangleright> (n + m)) \\<and>\n             \\<phi> i x \\<down>\\<noteq>\n             e_nth (f \\<triangleright> (n + m)) x)\n   else Some (e_length (f \\<triangleright> (n + m))))\n  \\<forall>x<e_length (f \\<triangleright> (n + m)). \\<phi> i x \\<down>\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>=\n    (LEAST x.\n        x < e_length (f \\<triangleright> (n + m)) \\<and>\n        \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)", "by simp"], ["proof (state)\nthis:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> (n + m)) \\<and>\n      \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> (n + m)) \\<and>\n      \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)", "have 5: \"inconsist i (f \\<triangleright> (n + m)) \\<down>= (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)\""], ["proof (prove)\nusing this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> (n + m)) \\<and>\n      \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>=\n    (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)", "using cond[of _ \"n + m\"]"], ["proof (prove)\nusing this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> (n + m)) \\<and>\n      \\<phi> i x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) x)\n  (?x < Suc (n + m) \\<and> \\<phi> i ?x \\<noteq> f ?x) =\n  (?x < e_length (f \\<triangleright> (n + m)) \\<and>\n   \\<phi> i ?x \\<down>\\<noteq> e_nth (f \\<triangleright> (n + m)) ?x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) \\<down>=\n    (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)", "by simp"], ["proof (state)\nthis:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)", "have \"(LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n      (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)\""], ["proof (prove)\nusing this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n    (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)", "using least_bounded_gr[where ?upper=\"Suc n\"] 1 3"], ["proof (prove)\nusing this:\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)\n  \\<exists>x<Suc n. ?P x \\<Longrightarrow>\n  (LEAST x. x < Suc n \\<and> ?P x) = (LEAST x. x < Suc n + ?m \\<and> ?P x)\n  \\<exists>x<Suc n. \\<phi> i x \\<noteq> f x\n  \\<exists>x<Suc (n + m). \\<phi> i x \\<noteq> f x\n\ngoal (1 subgoal):\n 1. (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n    (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)", "by simp"], ["proof (state)\nthis:\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n  (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "then"], ["proof (chain)\npicking this:\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n  (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n  (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "using 2 5"], ["proof (prove)\nusing this:\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x) =\n  (LEAST x. x < Suc n + m \\<and> \\<phi> i x \\<noteq> f x)\n  inconsist i (f \\<triangleright> n) \\<down>=\n  (LEAST x. x < Suc n \\<and> \\<phi> i x \\<noteq> f x)\n  inconsist i (f \\<triangleright> (n + m)) \\<down>=\n  (LEAST x. x < Suc (n + m) \\<and> \\<phi> i x \\<noteq> f x)\n\ngoal (1 subgoal):\n 1. inconsist i (f \\<triangleright> (n + m)) =\n    inconsist i (f \\<triangleright> n)", "by simp"], ["proof (state)\nthis:\n  inconsist i (f \\<triangleright> (n + m)) =\n  inconsist i (f \\<triangleright> n)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"r_inconsist \\<equiv>\n  let\n    f = Cn 2 r_length [Id 2 1];\n    g = Cn 4 r_ifless\n      [Id 4 1,\n       Cn 4 r_length [Id 4 3],\n       Id 4 1,\n       Cn 4 r_ifeq\n        [Cn 4 r_phi [Id 4 2, Id 4 0],\n         Cn 4 r_nth [Id 4 3, Id 4 0],\n         Id 4 1,\n         Id 4 0]]\n   in Cn 2 (Pr 2 f g) [Cn 2 r_length [Id 2 1], Id 2 0, Id 2 1]\""], ["", "lemma r_inconsist_recfn: \"recfn 2 r_inconsist\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 r_inconsist", "unfolding r_inconsist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2\n     (let f = Cn 2 r_length [recf.Id 2 1];\n          g = Cn 4 r_ifless\n               [recf.Id 4 1, Cn 4 r_length [recf.Id 4 3], recf.Id 4 1,\n                Cn 4 r_ifeq\n                 [Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0],\n                  Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0], recf.Id 4 1,\n                  recf.Id 4 0]]\n      in Cn 2 (Pr 2 f g)\n          [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])", "by simp"], ["", "lemma r_inconsist: \"eval r_inconsist [i, e] = inconsist i e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define f where \"f = Cn 2 r_length [Id 2 1]\""], ["proof (state)\nthis:\n  f = Cn 2 r_length [recf.Id 2 1]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define len where \"len = Cn 4 r_length [Id 4 3]\""], ["proof (state)\nthis:\n  len = Cn 4 r_length [recf.Id 4 3]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define nth where \"nth = Cn 4 r_nth [Id 4 3, Id 4 0]\""], ["proof (state)\nthis:\n  nth = Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define ph where \"ph = Cn 4 r_phi [Id 4 2, Id 4 0]\""], ["proof (state)\nthis:\n  ph = Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define g where\n    \"g = Cn 4 r_ifless [Id 4 1, len, Id 4 1, Cn 4 r_ifeq [ph, nth, Id 4 1, Id 4 0]]\""], ["proof (state)\nthis:\n  g =\n  Cn 4 r_ifless\n   [recf.Id 4 1, len, recf.Id 4 1,\n    Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"recfn 2 f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 f", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (Cn 2 r_length [recf.Id 2 1])", "by simp"], ["proof (state)\nthis:\n  recfn 2 f\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have f: \"eval f [i, e] \\<down>= e_length e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval f [i, e] \\<down>= e_length e", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 2 r_length [recf.Id 2 1]) [i, e] \\<down>= e_length e", "by simp"], ["proof (state)\nthis:\n  eval f [i, e] \\<down>= e_length e\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"recfn 4 len\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 len", "unfolding len_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 (Cn 4 r_length [recf.Id 4 3])", "by simp"], ["proof (state)\nthis:\n  recfn 4 len\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have len: \"eval len [j, v, i, e] \\<down>= e_length e\" for j v"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval len [j, v, i, e] \\<down>= e_length e", "unfolding len_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_length [recf.Id 4 3]) [j, v, i, e] \\<down>= e_length e", "by simp"], ["proof (state)\nthis:\n  eval len [?j, ?v, i, e] \\<down>= e_length e\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"recfn 4 nth\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 nth", "unfolding nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 (Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0])", "by simp"], ["proof (state)\nthis:\n  recfn 4 nth\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have nth: \"eval nth [j, v, i, e] \\<down>= e_nth e j\" for j v"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval nth [j, v, i, e] \\<down>= e_nth e j", "unfolding nth_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0]) [j, v, i, e] \\<down>=\n    e_nth e j", "by simp"], ["proof (state)\nthis:\n  eval nth [?j, ?v, i, e] \\<down>= e_nth e ?j\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"recfn 4 ph\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 ph", "unfolding ph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 (Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0])", "by simp"], ["proof (state)\nthis:\n  recfn 4 ph\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have ph: \"eval ph [j, v, i, e] = \\<phi> i j\" for j v"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval ph [j, v, i, e] = \\<phi> i j", "unfolding ph_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0]) [j, v, i, e] = \\<phi> i j", "using phi_def"], ["proof (prove)\nusing this:\n  \\<phi> ?i ?x \\<equiv> eval r_phi [?i, ?x]\n\ngoal (1 subgoal):\n 1. eval (Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0]) [j, v, i, e] = \\<phi> i j", "by simp"], ["proof (state)\nthis:\n  eval ph [?j, ?v, i, e] = \\<phi> i ?j\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"recfn 4 g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4 g", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 4\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])", "using \\<open>recfn 4 nth\\<close> \\<open>recfn 4 ph\\<close> \\<open>recfn 4 len\\<close>"], ["proof (prove)\nusing this:\n  recfn 4 nth\n  recfn 4 ph\n  recfn 4 len\n\ngoal (1 subgoal):\n 1. recfn 4\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])", "by simp"], ["proof (state)\nthis:\n  recfn 4 g\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have g_diverg: \"eval g [j, v, i, e] \\<up>\" if \"eval ph [j, v, i, e] \\<up>\" for j v"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [j, v, i, e] \\<up>", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])\n     [j, v, i, e] \\<up>", "using that \\<open>recfn 4 nth\\<close> \\<open>recfn 4 ph\\<close> \\<open>recfn 4 len\\<close>"], ["proof (prove)\nusing this:\n  eval ph [j, v, i, e] \\<up>\n  recfn 4 nth\n  recfn 4 ph\n  recfn 4 len\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])\n     [j, v, i, e] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval ph [?j, ?v, i, e] \\<up> \\<Longrightarrow> eval g [?j, ?v, i, e] \\<up>\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have g_converg: \"eval g [j, v, i, e] \\<down>=\n      (if v < e_length e then v else if \\<phi> i j \\<down>= e_nth e j then v else j)\"\n      if \"eval ph [j, v, i, e] \\<down>\" for j v"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval g [j, v, i, e] \\<down>=\n    (if v < e_length e then v\n     else if \\<phi> i j \\<down>= e_nth e j then v else j)", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])\n     [j, v, i, e] \\<down>=\n    (if v < e_length e then v\n     else if \\<phi> i j \\<down>= e_nth e j then v else j)", "using that \\<open>recfn 4 nth\\<close> \\<open>recfn 4 ph\\<close> \\<open>recfn 4 len\\<close> len nth ph"], ["proof (prove)\nusing this:\n  eval ph [j, v, i, e] \\<down>\n  recfn 4 nth\n  recfn 4 ph\n  recfn 4 len\n  eval len [?j, ?v, i, e] \\<down>= e_length e\n  eval nth [?j, ?v, i, e] \\<down>= e_nth e ?j\n  eval ph [?j, ?v, i, e] = \\<phi> i ?j\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 4 r_ifless\n       [recf.Id 4 1, len, recf.Id 4 1,\n        Cn 4 r_ifeq [ph, nth, recf.Id 4 1, recf.Id 4 0]])\n     [j, v, i, e] \\<down>=\n    (if v < e_length e then v\n     else if \\<phi> i j \\<down>= e_nth e j then v else j)", "by auto"], ["proof (state)\nthis:\n  eval ph [?j, ?v, i, e] \\<down> \\<Longrightarrow>\n  eval g [?j, ?v, i, e] \\<down>=\n  (if ?v < e_length e then ?v\n   else if \\<phi> i ?j \\<down>= e_nth e ?j then ?v else ?j)\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "define h where \"h \\<equiv> Pr 2 f g\""], ["proof (state)\nthis:\n  h \\<equiv> Pr 2 f g\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "then"], ["proof (chain)\npicking this:\n  h \\<equiv> Pr 2 f g", "have \"recfn 3 h\""], ["proof (prove)\nusing this:\n  h \\<equiv> Pr 2 f g\n\ngoal (1 subgoal):\n 1. recfn 3 h", "by (simp add: \\<open>recfn 2 f\\<close> \\<open>recfn 4 g\\<close>)"], ["proof (state)\nthis:\n  recfn 3 h\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "let ?invariant = \"\\<lambda>j i e.\n    (if \\<exists>x<j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\""], ["proof (state)\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"eval h [j, i, e] = ?invariant j i e\" if \"j \\<le> e_length e\" for j"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [j, i, e] =\n    (if \\<exists>x<j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "using that"], ["proof (prove)\nusing this:\n  j \\<le> e_length e\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] =\n    (if \\<exists>x<j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "proof (induction j)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> e_length e \\<Longrightarrow>\n    eval h [0, i, e] =\n    (if \\<exists>x<0. \\<phi> i x \\<up> then None\n     else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "case 0"], ["proof (state)\nthis:\n  0 \\<le> e_length e\n\ngoal (2 subgoals):\n 1. 0 \\<le> e_length e \\<Longrightarrow>\n    eval h [0, i, e] =\n    (if \\<exists>x<0. \\<phi> i x \\<up> then None\n     else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> e_length e", "show ?case"], ["proof (prove)\nusing this:\n  0 \\<le> e_length e\n\ngoal (1 subgoal):\n 1. eval h [0, i, e] =\n    (if \\<exists>x<0. \\<phi> i x \\<up> then None\n     else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "unfolding h_def"], ["proof (prove)\nusing this:\n  0 \\<le> e_length e\n\ngoal (1 subgoal):\n 1. eval (Pr 2 f g) [0, i, e] =\n    (if \\<exists>x<0. \\<phi> i x \\<up> then None\n     else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "using \\<open>recfn 2 f\\<close> f \\<open>recfn 4 g\\<close>"], ["proof (prove)\nusing this:\n  0 \\<le> e_length e\n  recfn 2 f\n  eval f [i, e] \\<down>= e_length e\n  recfn 4 g\n\ngoal (1 subgoal):\n 1. eval (Pr 2 f g) [0, i, e] =\n    (if \\<exists>x<0. \\<phi> i x \\<up> then None\n     else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "by simp"], ["proof (state)\nthis:\n  eval h [0, i, e] =\n  (if \\<exists>x<0. \\<phi> i x \\<up> then None\n   else if \\<exists>x<0. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < 0 \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "case (Suc j)"], ["proof (state)\nthis:\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  Suc j \\<le> e_length e\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  Suc j \\<le> e_length e", "have j_less: \"j < e_length e\""], ["proof (prove)\nusing this:\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  Suc j \\<le> e_length e\n\ngoal (1 subgoal):\n 1. j < e_length e", "by simp"], ["proof (state)\nthis:\n  j < e_length e\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  j < e_length e", "have j_le: \"j \\<le> e_length e\""], ["proof (prove)\nusing this:\n  j < e_length e\n\ngoal (1 subgoal):\n 1. j \\<le> e_length e", "by simp"], ["proof (state)\nthis:\n  j \\<le> e_length e\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       \\<lbrakk>j \\<le> e_length e \\<Longrightarrow>\n                eval h [j, i, e] =\n                (if \\<exists>x<j. \\<phi> i x \\<up> then None\n                 else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n                      then Some\n                            (LEAST x.\n                                x < j \\<and>\n                                \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                      else Some (e_length e));\n        Suc j \\<le> e_length e\\<rbrakk>\n       \\<Longrightarrow> eval h [Suc j, i, e] =\n                         (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n                          else if \\<exists>x<Suc j.\n                                     \\<phi> i x \\<down>\\<noteq> e_nth e x\n                               then Some\n                                     (LEAST x.\n   x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n                               else Some (e_length e))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "proof (cases \"eval h [j, i, e] \\<up>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "case True"], ["proof (state)\nthis:\n  eval h [j, i, e] \\<up>\n\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  eval h [j, i, e] \\<up>", "have \"\\<exists>x<j. \\<phi> i x \\<up>\""], ["proof (prove)\nusing this:\n  eval h [j, i, e] \\<up>\n\ngoal (1 subgoal):\n 1. \\<exists>x<j. \\<phi> i x \\<up>", "using j_le Suc.IH"], ["proof (prove)\nusing this:\n  eval h [j, i, e] \\<up>\n  j \\<le> e_length e\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. \\<exists>x<j. \\<phi> i x \\<up>", "by (metis option.simps(3))"], ["proof (state)\nthis:\n  \\<exists>x<j. \\<phi> i x \\<up>\n\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<j. \\<phi> i x \\<up>", "have \"\\<exists>x<Suc j. \\<phi> i x \\<up>\""], ["proof (prove)\nusing this:\n  \\<exists>x<j. \\<phi> i x \\<up>\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc j. \\<phi> i x \\<up>", "using less_SucI"], ["proof (prove)\nusing this:\n  \\<exists>x<j. \\<phi> i x \\<up>\n  ?m < ?n \\<Longrightarrow> ?m < Suc ?n\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc j. \\<phi> i x \\<up>", "by blast"], ["proof (state)\nthis:\n  \\<exists>x<Suc j. \\<phi> i x \\<up>\n\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "moreover"], ["proof (state)\nthis:\n  \\<exists>x<Suc j. \\<phi> i x \\<up>\n\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "have h: \"eval h [Suc j, i, e] \\<up>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] \\<up>", "using True h_def \\<open>recfn 3 h\\<close>"], ["proof (prove)\nusing this:\n  eval h [j, i, e] \\<up>\n  h \\<equiv> Pr 2 f g\n  recfn 3 h\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] \\<up>", "by simp"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] \\<up>\n\ngoal (2 subgoals):\n 1. eval h [j, i, e] \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>x<Suc j. \\<phi> i x \\<up>\n  eval h [Suc j, i, e] \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x<Suc j. \\<phi> i x \\<up>\n  eval h [Suc j, i, e] \\<up>\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "by simp"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "case False"], ["proof (state)\nthis:\n  eval h [j, i, e] \\<down>\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "with Suc.IH j_le"], ["proof (chain)\npicking this:\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  j \\<le> e_length e\n  eval h [j, i, e] \\<down>", "have h_j: \"eval h [j, i, e] =\n        (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n         else Some (e_length e))\""], ["proof (prove)\nusing this:\n  j \\<le> e_length e \\<Longrightarrow>\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  j \\<le> e_length e\n  eval h [j, i, e] \\<down>\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] =\n    (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n     else Some (e_length e))", "by presburger"], ["proof (state)\nthis:\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "then"], ["proof (chain)\npicking this:\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))", "have the_h_j: \"the (eval h [j, i, e]) =\n        (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\"\n         (is \"_ = ?v\")"], ["proof (prove)\nusing this:\n  eval h [j, i, e] =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then Some (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n   else Some (e_length e))\n\ngoal (1 subgoal):\n 1. the (eval h [j, i, e]) =\n    (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by auto"], ["proof (state)\nthis:\n  the (eval h [j, i, e]) =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "have h_Suc: \"eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]", "using False h_def \\<open>recfn 4 g\\<close> \\<open>recfn 2 f\\<close>"], ["proof (prove)\nusing this:\n  eval h [j, i, e] \\<down>\n  h \\<equiv> Pr 2 f g\n  recfn 4 g\n  recfn 2 f\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]", "by auto"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n\ngoal (1 subgoal):\n 1. eval h [j, i, e] \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "proof (cases \"\\<phi> i j \\<up>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> i j \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "case True"], ["proof (state)\nthis:\n  \\<phi> i j \\<up>\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<up> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))\n 2. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "with ph g_diverg h_Suc"], ["proof (chain)\npicking this:\n  eval ph [?j, ?v, i, e] = \\<phi> i ?j\n  eval ph [?j, ?v, i, e] \\<up> \\<Longrightarrow> eval g [?j, ?v, i, e] \\<up>\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n  \\<phi> i j \\<up>", "show ?thesis"], ["proof (prove)\nusing this:\n  eval ph [?j, ?v, i, e] = \\<phi> i ?j\n  eval ph [?j, ?v, i, e] \\<up> \\<Longrightarrow> eval g [?j, ?v, i, e] \\<up>\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n  \\<phi> i j \\<up>\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "by auto"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "case False"], ["proof (state)\nthis:\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "with h_Suc"], ["proof (chain)\npicking this:\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n  \\<phi> i j \\<down>", "have \"eval h [Suc j, i, e] \\<down>=\n          (if ?v < e_length e then ?v\n           else if \\<phi> i j \\<down>= e_nth e j then ?v else j)\"\n          (is \"_ \\<down>= ?lhs\")"], ["proof (prove)\nusing this:\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] \\<down>=\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j)", "using g_converg ph the_h_j"], ["proof (prove)\nusing this:\n  eval h [Suc j, i, e] = eval g [j, the (eval h [j, i, e]), i, e]\n  \\<phi> i j \\<down>\n  eval ph [?j, ?v, i, e] \\<down> \\<Longrightarrow>\n  eval g [?j, ?v, i, e] \\<down>=\n  (if ?v < e_length e then ?v\n   else if \\<phi> i ?j \\<down>= e_nth e ?j then ?v else ?j)\n  eval ph [?j, ?v, i, e] = \\<phi> i ?j\n  the (eval h [j, i, e]) =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] \\<down>=\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j)", "by simp"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] \\<down>=\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "moreover"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] \\<down>=\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "have \"?invariant (Suc j) i e \\<down>=\n          (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n           then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n           else e_length e)\"\n          (is \"_ \\<down>= ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "from False"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<down>", "have \"\\<phi> i j \\<down>\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down>", "by simp"], ["proof (state)\nthis:\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "moreover"], ["proof (state)\nthis:\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "have \"\\<not> (\\<exists>x<j. \\<phi> i x \\<up>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<j. \\<phi> i x \\<up>)", "by (metis (no_types, lifting) Suc.IH h_j j_le option.simps(3))"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<up>)\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<down>\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<up>)", "have \"\\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<up>)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)", "using less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<up>)\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)", "by auto"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<up>)\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by auto"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e)) \\<down>=\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e)) \\<down>=\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "moreover"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e)) \\<down>=\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "have \"?lhs = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "proof (cases \"?v < e_length e\")"], ["proof (state)\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "case True"], ["proof (state)\nthis:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e", "have\n            ex_j: \"\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\" and\n            v_eq: \"?v = (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\nusing this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n\ngoal (1 subgoal):\n 1. \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x &&&\n    (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "by presburger+"], ["proof (state)\nthis:\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "with True"], ["proof (chain)\npicking this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "have \"?lhs = ?v\""], ["proof (prove)\nusing this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "from ex_j"], ["proof (chain)\npicking this:\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x", "have \"\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\""], ["proof (prove)\nusing this:\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x", "using less_SucI"], ["proof (prove)\nusing this:\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  ?m < ?n \\<Longrightarrow> ?m < Suc ?n\n\ngoal (1 subgoal):\n 1. \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x", "by blast"], ["proof (state)\nthis:\n  \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x", "have \"?rhs = (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\nusing this:\n  \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (2 subgoals):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n    < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "with True v_eq ex_j"], ["proof (chain)\npicking this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "using least_bounded_Suc[of j \"\\<lambda>x. \\<phi> i x \\<down>\\<noteq> e_nth e x\"]"], ["proof (prove)\nusing this:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  < e_length e\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x \\<Longrightarrow>\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) =\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "case False"], ["proof (state)\nthis:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e", "have not_ex: \"\\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\nusing this:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "using Least_le[of \"\\<lambda>x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\"] j_le"], ["proof (prove)\nusing this:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e\n  ?k < j \\<and> \\<phi> i ?k \\<down>\\<noteq> e_nth e ?k \\<Longrightarrow>\n  (LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<le> ?k\n  j \\<le> e_length e\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "by (smt leD le_less_linear le_trans)"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "have \"?v = e_length e\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    e_length e", "by argo"], ["proof (state)\nthis:\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "with False"], ["proof (chain)\npicking this:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e", "have lhs: \"?lhs = (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)\""], ["proof (prove)\nusing this:\n  \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e)\n         < e_length e\n  (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)\n\ngoal (1 subgoal):\n 1. \\<not> (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n            then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n            else e_length e)\n           < e_length e \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "proof (cases \"\\<phi> i j \\<down>= e_nth e j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "case True"], ["proof (state)\nthis:\n  \\<phi> i j \\<down>= e_nth e j\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<down>= e_nth e j", "have \"\\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>= e_nth e j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "using less_SucE not_ex"], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>= e_nth e j\n  \\<lbrakk>?m < Suc ?n; ?m < ?n \\<Longrightarrow> ?P;\n   ?m = ?n \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)", "have \"?rhs = e_length e\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    e_length e", "by argo"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "moreover"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "from True"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<down>= e_nth e j", "have \"?lhs = e_length e\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>= e_nth e j\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    e_length e", "using lhs"], ["proof (prove)\nusing this:\n  \\<phi> i j \\<down>= e_nth e j\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    e_length e", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  e_length e\n\ngoal (2 subgoals):\n 1. \\<phi> i j \\<down>= e_nth e j \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\n 2. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "ultimately"], ["proof (chain)\npicking this:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  e_length e", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  e_length e\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  e_length e\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "case False"], ["proof (state)\nthis:\n  \\<phi> i j \\<noteq> Some (e_nth e j)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<noteq> Some (e_nth e j)", "have \"\\<phi> i j \\<down>\\<noteq> e_nth e j\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<noteq> Some (e_nth e j)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down>\\<noteq> e_nth e j", "using \\<open>\\<phi> i j \\<down>\\<close>"], ["proof (prove)\nusing this:\n  \\<phi> i j \\<noteq> Some (e_nth e j)\n  \\<phi> i j \\<down>\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down>\\<noteq> e_nth e j", "by simp"], ["proof (state)\nthis:\n  \\<phi> i j \\<down>\\<noteq> e_nth e j\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "with not_ex"], ["proof (chain)\npicking this:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<phi> i j \\<down>\\<noteq> e_nth e j", "have \"(LEAST x. x<Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j\""], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<phi> i j \\<down>\\<noteq> e_nth e j\n\ngoal (1 subgoal):\n 1. (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j", "using LeastI[of \"\\<lambda>x. x<Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\" j] less_Suc_eq"], ["proof (prove)\nusing this:\n  \\<not> (\\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  \\<phi> i j \\<down>\\<noteq> e_nth e j\n  j < Suc j \\<and> \\<phi> i j \\<down>\\<noteq> e_nth e j \\<Longrightarrow>\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  < Suc j \\<and>\n  \\<phi> i\n   (LEAST x.\n       x < Suc j \\<and>\n       \\<phi> i x \\<down>\\<noteq> e_nth e x) \\<down>\\<noteq>\n  e_nth e (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n  (?m < Suc ?n) = (?m < ?n \\<or> ?m = ?n)\n\ngoal (1 subgoal):\n 1. (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j", "by blast"], ["proof (state)\nthis:\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j", "have \"?rhs = j\""], ["proof (prove)\nusing this:\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    j", "using \\<open>\\<phi> i j \\<down>\\<noteq> e_nth e j\\<close>"], ["proof (prove)\nusing this:\n  (LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x) = j\n  \\<phi> i j \\<down>\\<noteq> e_nth e j\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e) =\n    j", "by (meson lessI)"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  j\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "moreover"], ["proof (state)\nthis:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  j\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "from False lhs"], ["proof (chain)\npicking this:\n  \\<phi> i j \\<noteq> Some (e_nth e j)\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)", "have \"?lhs = j\""], ["proof (prove)\nusing this:\n  \\<phi> i j \\<noteq> Some (e_nth e j)\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<phi> i j \\<down>= e_nth e j then e_length e else j)\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    j", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  j\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<noteq> Some (e_nth e j) \\<Longrightarrow>\n    (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "ultimately"], ["proof (chain)\npicking this:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  j\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  j", "show ?thesis"], ["proof (prove)\nusing this:\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e) =\n  j\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  j\n\ngoal (1 subgoal):\n 1. (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n         then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n         else e_length e)\n        < e_length e\n     then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n          else e_length e\n     else if \\<phi> i j \\<down>= e_nth e j\n          then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n               then LEAST x.\n                       x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n               else e_length e\n          else j) =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by simp"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. \\<phi> i j \\<down> \\<Longrightarrow>\n    eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "ultimately"], ["proof (chain)\npicking this:\n  eval h [Suc j, i, e] \\<down>=\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j)\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e)) \\<down>=\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)", "show ?thesis"], ["proof (prove)\nusing this:\n  eval h [Suc j, i, e] \\<down>=\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j)\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e)) \\<down>=\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n  (if (if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n       then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n       else e_length e)\n      < e_length e\n   then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n        else e_length e\n   else if \\<phi> i j \\<down>= e_nth e j\n        then if \\<exists>x<j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n             then LEAST x. x < j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n             else e_length e\n        else j) =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal (1 subgoal):\n 1. eval h [Suc j, i, e] =\n    (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n     else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "by simp"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval h [Suc j, i, e] =\n  (if \\<exists>x<Suc j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<Suc j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < Suc j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?j \\<le> e_length e \\<Longrightarrow>\n  eval h [?j, i, e] =\n  (if \\<exists>x<?j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<?j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < ?j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "then"], ["proof (chain)\npicking this:\n  ?j \\<le> e_length e \\<Longrightarrow>\n  eval h [?j, i, e] =\n  (if \\<exists>x<?j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<?j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < ?j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))", "have \"eval h [e_length e, i, e] = ?invariant (e_length e) i e\""], ["proof (prove)\nusing this:\n  ?j \\<le> e_length e \\<Longrightarrow>\n  eval h [?j, i, e] =\n  (if \\<exists>x<?j. \\<phi> i x \\<up> then None\n   else if \\<exists>x<?j. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x. x < ?j \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval h [e_length e, i, e] =\n    (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < e_length e \\<and>\n                    \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e))", "by auto"], ["proof (state)\nthis:\n  eval h [e_length e, i, e] =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n   else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < e_length e \\<and>\n                  \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "then"], ["proof (chain)\npicking this:\n  eval h [e_length e, i, e] =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n   else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < e_length e \\<and>\n                  \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))", "have \"eval h [e_length e, i, e] = inconsist i e\""], ["proof (prove)\nusing this:\n  eval h [e_length e, i, e] =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n   else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < e_length e \\<and>\n                  \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n\ngoal (1 subgoal):\n 1. eval h [e_length e, i, e] = inconsist i e", "using inconsist_def"], ["proof (prove)\nusing this:\n  eval h [e_length e, i, e] =\n  (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n   else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n        then Some\n              (LEAST x.\n                  x < e_length e \\<and>\n                  \\<phi> i x \\<down>\\<noteq> e_nth e x)\n        else Some (e_length e))\n  inconsist ?i ?e \\<equiv>\n  if \\<exists>x<e_length ?e. \\<phi> ?i x \\<up> then None\n  else if \\<exists>x<e_length ?e. \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x\n       then Some\n             (LEAST x.\n                 x < e_length ?e \\<and>\n                 \\<phi> ?i x \\<down>\\<noteq> e_nth ?e x)\n       else Some (e_length ?e)\n\ngoal (1 subgoal):\n 1. eval h [e_length e, i, e] = inconsist i e", "by simp"], ["proof (state)\nthis:\n  eval h [e_length e, i, e] = inconsist i e\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "moreover"], ["proof (state)\nthis:\n  eval h [e_length e, i, e] = inconsist i e\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "have \"eval (Cn 2 (Pr 2 f g) [Cn 2 r_length [Id 2 1], Id 2 0, Id 2 1]) [i, e] =\n      eval h [e_length e, i, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 (Pr 2 f g)\n       [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, e] =\n    eval h [e_length e, i, e]", "using \\<open>recfn 4 g\\<close> \\<open>recfn 2 f\\<close> h_def"], ["proof (prove)\nusing this:\n  recfn 4 g\n  recfn 2 f\n  h \\<equiv> Pr 2 f g\n\ngoal (1 subgoal):\n 1. eval\n     (Cn 2 (Pr 2 f g)\n       [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, e] =\n    eval h [e_length e, i, e]", "by auto"], ["proof (state)\nthis:\n  eval\n   (Cn 2 (Pr 2 f g) [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n   [i, e] =\n  eval h [e_length e, i, e]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "ultimately"], ["proof (chain)\npicking this:\n  eval h [e_length e, i, e] = inconsist i e\n  eval\n   (Cn 2 (Pr 2 f g) [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n   [i, e] =\n  eval h [e_length e, i, e]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval h [e_length e, i, e] = inconsist i e\n  eval\n   (Cn 2 (Pr 2 f g) [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n   [i, e] =\n  eval h [e_length e, i, e]\n\ngoal (1 subgoal):\n 1. eval r_inconsist [i, e] = inconsist i e", "unfolding r_inconsist_def"], ["proof (prove)\nusing this:\n  eval h [e_length e, i, e] = inconsist i e\n  eval\n   (Cn 2 (Pr 2 f g) [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n   [i, e] =\n  eval h [e_length e, i, e]\n\ngoal (1 subgoal):\n 1. eval\n     (let f = Cn 2 r_length [recf.Id 2 1];\n          g = Cn 4 r_ifless\n               [recf.Id 4 1, Cn 4 r_length [recf.Id 4 3], recf.Id 4 1,\n                Cn 4 r_ifeq\n                 [Cn 4 r_phi [recf.Id 4 2, recf.Id 4 0],\n                  Cn 4 r_nth [recf.Id 4 3, recf.Id 4 0], recf.Id 4 1,\n                  recf.Id 4 0]]\n      in Cn 2 (Pr 2 f g)\n          [Cn 2 r_length [recf.Id 2 1], recf.Id 2 0, recf.Id 2 1])\n     [i, e] =\n    inconsist i e", "by (simp add: f_def g_def len_def nth_def ph_def)"], ["proof (state)\nthis:\n  eval r_inconsist [i, e] = inconsist i e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inconsist_for_total:\n  assumes \"total1 (\\<phi> i)\"\n  shows \"inconsist i e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist i e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "unfolding inconsist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < e_length e \\<and>\n                    \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "using assms total1_def"], ["proof (prove)\nusing this:\n  total1 (\\<phi> i)\n  total1 ?f \\<equiv> \\<forall>x. ?f x \\<down>\n\ngoal (1 subgoal):\n 1. (if \\<exists>x<e_length e. \\<phi> i x \\<up> then None\n     else if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n          then Some\n                (LEAST x.\n                    x < e_length e \\<and>\n                    \\<phi> i x \\<down>\\<noteq> e_nth e x)\n          else Some (e_length e)) \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> i x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> i x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by (auto; blast)"], ["", "lemma inconsist_for_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\" and \"k = amalgamate (the (f 0)) (the (f 1))\"\n  shows \"inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x. x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "have \"\\<phi> k \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> k \\<in> \\<R>", "using amalgamation_V01_R1[OF assms(1)] assms(2) amalgamate"], ["proof (prove)\nusing this:\n  amalgamation (the (f 0)) (the (f 1)) \\<in> \\<R>\n  k = amalgamate (the (f 0)) (the (f 1))\n  \\<phi> (amalgamate ?i ?j) = amalgamation ?i ?j\n\ngoal (1 subgoal):\n 1. \\<phi> k \\<in> \\<R>", "by simp"], ["proof (state)\nthis:\n  \\<phi> k \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "then"], ["proof (chain)\npicking this:\n  \\<phi> k \\<in> \\<R>", "have \"total1 (\\<phi> k)\""], ["proof (prove)\nusing this:\n  \\<phi> k \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. total1 (\\<phi> k)", "by simp"], ["proof (state)\nthis:\n  total1 (\\<phi> k)\n\ngoal (1 subgoal):\n 1. inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "with inconsist_for_total[of k]"], ["proof (chain)\npicking this:\n  total1 (\\<phi> k) \\<Longrightarrow>\n  inconsist k ?e \\<down>=\n  (if \\<exists>x<e_length ?e. \\<phi> k x \\<down>\\<noteq> e_nth ?e x\n   then LEAST x.\n           x < e_length ?e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth ?e x\n   else e_length ?e)\n  total1 (\\<phi> k)", "show ?thesis"], ["proof (prove)\nusing this:\n  total1 (\\<phi> k) \\<Longrightarrow>\n  inconsist k ?e \\<down>=\n  (if \\<exists>x<e_length ?e. \\<phi> k x \\<down>\\<noteq> e_nth ?e x\n   then LEAST x.\n           x < e_length ?e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth ?e x\n   else e_length ?e)\n  total1 (\\<phi> k)\n\ngoal (1 subgoal):\n 1. inconsist k e \\<down>=\n    (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n     then LEAST x.\n             x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n     else e_length e)", "by simp"], ["proof (state)\nthis:\n  inconsist k e \\<down>=\n  (if \\<exists>x<e_length e. \\<phi> k x \\<down>\\<noteq> e_nth e x\n   then LEAST x. x < e_length e \\<and> \\<phi> k x \\<down>\\<noteq> e_nth e x\n   else e_length e)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The next function computes G?del numbers of functions consistent\nwith a given prefix. The strategy will use these as consistent auxiliary\nhypotheses when receiving a prefix of length one.\\<close>"], ["", "definition \"r_auxhyp \\<equiv> Cn 1 (r_smn 1 1) [r_const (encode r_prenum), Id 1 0]\""], ["", "lemma r_auxhyp_prim: \"prim_recfn 1 r_auxhyp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 r_auxhyp", "unfolding r_auxhyp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prim_recfn 1 (Cn 1 (r_smn 1 1) [r_const (encode r_prenum), recf.Id 1 0])", "by simp"], ["", "lemma r_auxhyp: \"\\<phi> (the (eval r_auxhyp [e])) = prenum e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) = prenum e", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "let ?p = \"encode r_prenum\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "let ?p = \"encode r_prenum\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"eval r_auxhyp [e] = eval (r_smn 1 1) [?p, e]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_auxhyp [e] = eval (r_smn 1 1) [encode r_prenum, e]", "unfolding r_auxhyp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 (r_smn 1 1) [r_const (encode r_prenum), recf.Id 1 0]) [e] =\n    eval (r_smn 1 1) [encode r_prenum, e]", "by simp"], ["proof (state)\nthis:\n  eval r_auxhyp [e] = eval (r_smn 1 1) [encode r_prenum, e]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "then"], ["proof (chain)\npicking this:\n  eval r_auxhyp [e] = eval (r_smn 1 1) [encode r_prenum, e]", "have \"eval r_auxhyp [e] \\<down>= smn 1 ?p [e]\""], ["proof (prove)\nusing this:\n  eval r_auxhyp [e] = eval (r_smn 1 1) [encode r_prenum, e]\n\ngoal (1 subgoal):\n 1. eval r_auxhyp [e] \\<down>= smn 1 (encode r_prenum) [e]", "by (simp add: r_smn)"], ["proof (state)\nthis:\n  eval r_auxhyp [e] \\<down>= smn 1 (encode r_prenum) [e]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "also"], ["proof (state)\nthis:\n  eval r_auxhyp [e] \\<down>= smn 1 (encode r_prenum) [e]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"... \\<down>= encode (Cn 1 (r_universal (1 + length [e]))\n      (r_constn (1 - 1) ?p #\n       map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (smn 1 (encode r_prenum) [e]) \\<down>=\n    encode\n     (Cn 1 (r_universal (1 + length [e]))\n       (r_constn (1 - 1) (encode r_prenum) #\n        map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))", "using smn[of 1 ?p \"[e]\"]"], ["proof (prove)\nusing this:\n  0 < 1 \\<Longrightarrow>\n  smn 1 (encode r_prenum) [e] =\n  encode\n   (Cn 1 (r_universal (1 + length [e]))\n     (r_constn (1 - 1) (encode r_prenum) #\n      map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))\n\ngoal (1 subgoal):\n 1. Some (smn 1 (encode r_prenum) [e]) \\<down>=\n    encode\n     (Cn 1 (r_universal (1 + length [e]))\n       (r_constn (1 - 1) (encode r_prenum) #\n        map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))", "by simp"], ["proof (state)\nthis:\n  Some (smn 1 (encode r_prenum) [e]) \\<down>=\n  encode\n   (Cn 1 (r_universal (1 + length [e]))\n     (r_constn (1 - 1) (encode r_prenum) #\n      map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "also"], ["proof (state)\nthis:\n  Some (smn 1 (encode r_prenum) [e]) \\<down>=\n  encode\n   (Cn 1 (r_universal (1 + length [e]))\n     (r_constn (1 - 1) (encode r_prenum) #\n      map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"... \\<down>= encode (Cn 1 (r_universal (1 + 1))\n      (r_constn 0 ?p # map (r_constn 0) [e] @ [Id 1 0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (encode\n       (Cn 1 (r_universal (1 + length [e]))\n         (r_constn (1 - 1) (encode r_prenum) #\n          map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))) \\<down>=\n    encode\n     (Cn 1 (r_universal (1 + 1))\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))", "by simp"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal (1 + length [e]))\n       (r_constn (1 - 1) (encode r_prenum) #\n        map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))) \\<down>=\n  encode\n   (Cn 1 (r_universal (1 + 1))\n     (r_constn 0 (encode r_prenum) # map (r_constn 0) [e] @ [recf.Id 1 0]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "also"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal (1 + length [e]))\n       (r_constn (1 - 1) (encode r_prenum) #\n        map (r_constn (1 - 1)) [e] @ map (recf.Id 1) [0..<1]))) \\<down>=\n  encode\n   (Cn 1 (r_universal (1 + 1))\n     (r_constn 0 (encode r_prenum) # map (r_constn 0) [e] @ [recf.Id 1 0]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"... \\<down>= encode (Cn 1 (r_universal 2)\n      (r_constn 0 ?p # map (r_constn 0) [e] @ [Id 1 0]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (encode\n       (Cn 1 (r_universal (1 + 1))\n         (r_constn 0 (encode r_prenum) #\n          map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n    encode\n     (Cn 1 (r_universal 2)\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))", "by (metis one_add_one)"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal (1 + 1))\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     (r_constn 0 (encode r_prenum) # map (r_constn 0) [e] @ [recf.Id 1 0]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "also"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal (1 + 1))\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     (r_constn 0 (encode r_prenum) # map (r_constn 0) [e] @ [recf.Id 1 0]))\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"... \\<down>= encode (Cn 1 (r_universal 2) [r_constn 0 ?p, r_constn 0 e, Id 1 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (encode\n       (Cn 1 (r_universal 2)\n         (r_constn 0 (encode r_prenum) #\n          map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n    encode\n     (Cn 1 (r_universal 2)\n       [r_constn 0 (encode r_prenum), r_constn 0 e, recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal 2)\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_constn 0 (encode r_prenum), r_constn 0 e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "also"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal 2)\n       (r_constn 0 (encode r_prenum) #\n        map (r_constn 0) [e] @ [recf.Id 1 0]))) \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_constn 0 (encode r_prenum), r_constn 0 e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"... \\<down>= encode (Cn 1 (r_universal 2) [r_const ?p, r_const e, Id 1 0])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some\n     (encode\n       (Cn 1 (r_universal 2)\n         [r_constn 0 (encode r_prenum), r_constn 0 e,\n          recf.Id 1 0])) \\<down>=\n    encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0])", "using r_constn_def"], ["proof (prove)\nusing this:\n  r_constn ?n ?c \\<equiv>\n  if ?n = 0 then r_const ?c else r_dummy ?n (r_const ?c)\n\ngoal (1 subgoal):\n 1. Some\n     (encode\n       (Cn 1 (r_universal 2)\n         [r_constn 0 (encode r_prenum), r_constn 0 e,\n          recf.Id 1 0])) \\<down>=\n    encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  Some\n   (encode\n     (Cn 1 (r_universal 2)\n       [r_constn 0 (encode r_prenum), r_constn 0 e, recf.Id 1 0])) \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "finally"], ["proof (chain)\npicking this:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])", "have \"eval r_auxhyp [e] \\<down>=\n    encode (Cn 1 (r_universal 2) [r_const ?p, r_const e, Id 1 0])\""], ["proof (prove)\nusing this:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. eval r_auxhyp [e] \\<down>=\n    encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0])", "."], ["proof (state)\nthis:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "moreover"], ["proof (state)\nthis:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "have \"\\<phi> (the (eval r_auxhyp [e])) x = eval r_phi [the (eval r_auxhyp [e]), x]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x =\n    eval r_phi [the (eval r_auxhyp [e]), x]", "by (simp add: phi_def)"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi [the (eval r_auxhyp [e]), x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "ultimately"], ["proof (chain)\npicking this:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi [the (eval r_auxhyp [e]), x]", "have \"\\<phi> (the (eval r_auxhyp [e])) x =\n      eval r_phi [encode (Cn 1 (r_universal 2) [r_const ?p, r_const e, Id 1 0]), x]\"\n      (is \"_ = eval r_phi [encode ?f, x]\")"], ["proof (prove)\nusing this:\n  eval r_auxhyp [e] \\<down>=\n  encode\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi [the (eval r_auxhyp [e]), x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x =\n    eval r_phi\n     [encode\n       (Cn 1 (r_universal 2)\n         [r_const (encode r_prenum), r_const e, recf.Id 1 0]),\n      x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0]),\n    x]", "have \"\\<phi> (the (eval r_auxhyp [e])) x =\n      eval (Cn 1 (r_universal 2) [r_const ?p, r_const e, Id 1 0]) [x]\""], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0]),\n    x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x =\n    eval\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n     [x]", "using r_phi_def r_universal[of ?f 1 \"[x]\"]"], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval r_phi\n   [encode\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0]),\n    x]\n  r_phi \\<equiv> r_universal 1\n  \\<lbrakk>recfn 1\n            (Cn 1 (r_universal 2)\n              [r_const (encode r_prenum), r_const e, recf.Id 1 0]);\n   length [x] = 1\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal 1)\n                     [encode\n                       (Cn 1 (r_universal 2)\n                         [r_const (encode r_prenum), r_const e,\n                          recf.Id 1 0]),\n                      x] =\n                    eval\n                     (Cn 1 (r_universal 2)\n                       [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n                     [x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x =\n    eval\n     (Cn 1 (r_universal 2)\n       [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n     [x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n   [x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n   [x]", "have \"\\<phi> (the (eval r_auxhyp [e])) x = eval (r_universal 2) [?p, e, x]\""], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval\n   (Cn 1 (r_universal 2)\n     [r_const (encode r_prenum), r_const e, recf.Id 1 0])\n   [x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x =\n    eval (r_universal 2) [encode r_prenum, e, x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval (r_universal 2) [encode r_prenum, e, x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval (r_universal 2) [encode r_prenum, e, x]", "have \"\\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]\""], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval (r_universal 2) [encode r_prenum, e, x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]", "using r_universal"], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x =\n  eval (r_universal 2) [encode r_prenum, e, x]\n  \\<lbrakk>recfn ?n ?f; length ?xs = ?n\\<rbrakk>\n  \\<Longrightarrow> eval (r_universal ?n) (encode ?f # ?xs) = eval ?f ?xs\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]", "show \"\\<phi> (the (eval r_auxhyp [e])) x = prenum e x\""], ["proof (prove)\nusing this:\n  \\<phi> (the (eval r_auxhyp [e])) x = eval r_prenum [e, x]\n\ngoal (1 subgoal):\n 1. \\<phi> (the (eval r_auxhyp [e])) x = prenum e x", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (eval r_auxhyp [e])) x = prenum e x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition auxhyp :: partial1 where\n  \"auxhyp e \\<equiv> eval r_auxhyp [e]\""], ["", "lemma auxhyp_prenum: \"\\<phi> (the (auxhyp e)) = prenum e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (the (auxhyp e)) = prenum e", "using auxhyp_def r_auxhyp"], ["proof (prove)\nusing this:\n  auxhyp ?e \\<equiv> eval r_auxhyp [?e]\n  \\<phi> (the (eval r_auxhyp [?e])) = prenum ?e\n\ngoal (1 subgoal):\n 1. \\<phi> (the (auxhyp e)) = prenum e", "by metis"], ["", "lemma auxhyp_in_R1: \"auxhyp \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. auxhyp \\<in> \\<R>", "using auxhyp_def Mn_free_imp_total R1I r_auxhyp_prim"], ["proof (prove)\nusing this:\n  auxhyp ?e \\<equiv> eval r_auxhyp [?e]\n  \\<lbrakk>wellf ?f; Mn_free ?f\\<rbrakk>\n  \\<Longrightarrow> Partial_Recursive.total ?f\n  \\<lbrakk>recfn 1 ?r; Partial_Recursive.total ?r;\n   \\<And>x. eval ?r [x] = ?f x\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> \\<R>\n  prim_recfn 1 r_auxhyp\n\ngoal (1 subgoal):\n 1. auxhyp \\<in> \\<R>", "by metis"], ["", "text \\<open>Now we can define our consistent learning strategy for @{term \"V\\<^sub>0\\<^sub>1\"}.\\<close>"], ["", "definition \"r_sv01 \\<equiv>\n  let\n    at0 = Cn 1 r_nth [Id 1 0, Z];\n    at1 = Cn 1 r_nth [Id 1 0, r_const 1];\n    m = Cn 1 r_amalgamate [at0, at1];\n    c = Cn 1 r_inconsist [m, Id 1 0];\n    p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n    g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n  in Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], Id 1 0]\""], ["", "lemma r_sv01_recfn: \"recfn 1 r_sv01\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 r_sv01", "unfolding r_sv01_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1\n     (let at0 = Cn 1 r_nth [recf.Id 1 0, Z];\n          at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1];\n          m = Cn 1 r_amalgamate [at0, at1];\n          c = Cn 1 r_inconsist [m, recf.Id 1 0];\n          p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n          g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n      in Cn 1 (r_lifz r_auxhyp g)\n          [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])", "using r_auxhyp_prim r_inconsist_recfn r_amalgamate_recfn"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_auxhyp\n  recfn 2 r_inconsist\n  recfn 2 r_amalgamate\n\ngoal (1 subgoal):\n 1. recfn 1\n     (let at0 = Cn 1 r_nth [recf.Id 1 0, Z];\n          at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1];\n          m = Cn 1 r_amalgamate [at0, at1];\n          c = Cn 1 r_inconsist [m, recf.Id 1 0];\n          p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n          g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n      in Cn 1 (r_lifz r_auxhyp g)\n          [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])", "by (simp add: Let_def)"], ["", "definition sv01 :: partial1 (\"s\\<^bsub>01\\<^esub>\")where\n  \"sv01 e \\<equiv> eval r_sv01 [e]\""], ["", "lemma sv01_in_P1: \"s\\<^bsub>01\\<^esub> \\<in> \\<P>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> \\<in> \\<P>", "using sv01_def r_sv01_recfn P1I"], ["proof (prove)\nusing this:\n  s\\<^bsub>01\\<^esub> ?e \\<equiv> eval r_sv01 [?e]\n  recfn 1 r_sv01\n  \\<lbrakk>recfn 1 ?r; (\\<lambda>x. eval ?r [x]) = ?f\\<rbrakk>\n  \\<Longrightarrow> ?f \\<in> \\<P>\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> \\<in> \\<P>", "by presburger"], ["", "text \\<open>We are interested in the behavior of @{term \"s\\<^bsub>01\\<^esub>\"} only on\nprefixes of functions in @{term \"V\\<^sub>0\\<^sub>1\"}. This behavior is linked\nto the amalgamation of $f(0)$ and $f(1)$, where $f$ is the function\nto be learned.\\<close>"], ["", "abbreviation amalg01 :: \"partial1 \\<Rightarrow> nat\" where\n  \"amalg01 f \\<equiv> amalgamate (the (f 0)) (the (f 1))\""], ["", "lemma sv01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) = auxhyp (f \\<triangleright> 0)\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n \\<Longrightarrow>\n      pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist (amalg01 f) (f \\<triangleright> n))))) = 0 \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\"\n    and \"n \\<noteq> 0 \\<Longrightarrow>\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n \\<Longrightarrow>\n      pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq> 0 \\<Longrightarrow>\n      s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n     auxhyp (f \\<triangleright> 0) &&&\n     (\\<lbrakk>n \\<noteq> 0;\n       inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n      \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                        amalg01 f)) &&&\n    (\\<lbrakk>n \\<noteq> 0;\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n      pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\\<rbrakk>\n     \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1) &&&\n    (\\<lbrakk>n \\<noteq> 0;\n      the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n      pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f)\n                     (f \\<triangleright> n))))) \\<noteq>\n      0\\<rbrakk>\n     \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have f_total: \"\\<And>x. f x \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. f x \\<down>", "using assms V01_def R1_imp_total1"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n\ngoal (1 subgoal):\n 1. \\<And>x. f x \\<down>", "by blast"], ["proof (state)\nthis:\n  f ?x \\<down>\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define at0 where \"at0 = Cn 1 r_nth [Id 1 0, Z]\""], ["proof (state)\nthis:\n  at0 = Cn 1 r_nth [recf.Id 1 0, Z]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define at1 where \"at1 = Cn 1 r_nth [Id 1 0, r_const 1]\""], ["proof (state)\nthis:\n  at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define m where  \"m = Cn 1 r_amalgamate [at0, at1]\""], ["proof (state)\nthis:\n  m = Cn 1 r_amalgamate [at0, at1]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define c where \"c = Cn 1 r_inconsist [m, Id 1 0]\""], ["proof (state)\nthis:\n  c = Cn 1 r_inconsist [m, recf.Id 1 0]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define p where \"p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]]\""], ["proof (state)\nthis:\n  p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "define g where \"g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\""], ["proof (state)\nthis:\n  g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 g", "unfolding g_def p_def c_def m_def at1_def at0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_ifeq\n       [Cn 1 r_inconsist\n         [Cn 1 r_amalgamate\n           [Cn 1 r_nth [recf.Id 1 0, Z],\n            Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n          recf.Id 1 0],\n        r_length,\n        Cn 1 r_amalgamate\n         [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n        Cn 1 r_ifz\n         [Cn 1 r_pdec1\n           [Cn 1 r_parallel\n             [Cn 1 r_nth [recf.Id 1 0, Z],\n              Cn 1 r_nth [recf.Id 1 0, r_const 1],\n              Cn 1 r_inconsist\n               [Cn 1 r_amalgamate\n                 [Cn 1 r_nth [recf.Id 1 0, Z],\n                  Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n                recf.Id 1 0]]],\n          Cn 1 r_nth [recf.Id 1 0, r_const 1],\n          Cn 1 r_nth [recf.Id 1 0, Z]]])", "using r_auxhyp_prim r_inconsist_recfn r_amalgamate_recfn"], ["proof (prove)\nusing this:\n  prim_recfn 1 r_auxhyp\n  recfn 2 r_inconsist\n  recfn 2 r_amalgamate\n\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_ifeq\n       [Cn 1 r_inconsist\n         [Cn 1 r_amalgamate\n           [Cn 1 r_nth [recf.Id 1 0, Z],\n            Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n          recf.Id 1 0],\n        r_length,\n        Cn 1 r_amalgamate\n         [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n        Cn 1 r_ifz\n         [Cn 1 r_pdec1\n           [Cn 1 r_parallel\n             [Cn 1 r_nth [recf.Id 1 0, Z],\n              Cn 1 r_nth [recf.Id 1 0, r_const 1],\n              Cn 1 r_inconsist\n               [Cn 1 r_amalgamate\n                 [Cn 1 r_nth [recf.Id 1 0, Z],\n                  Cn 1 r_nth [recf.Id 1 0, r_const 1]],\n                recf.Id 1 0]]],\n          Cn 1 r_nth [recf.Id 1 0, r_const 1],\n          Cn 1 r_nth [recf.Id 1 0, Z]]])", "by simp"], ["proof (state)\nthis:\n  recfn 1 g\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0", "have \"eval r_sv01 [f \\<triangleright> 0] = eval r_auxhyp [f \\<triangleright> 0]\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> 0] =\n    eval r_auxhyp [f \\<triangleright> 0]", "unfolding r_sv01_def"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0\n\ngoal (1 subgoal):\n 1. eval\n     (let at0 = Cn 1 r_nth [recf.Id 1 0, Z];\n          at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1];\n          m = Cn 1 r_amalgamate [at0, at1];\n          c = Cn 1 r_inconsist [m, recf.Id 1 0];\n          p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n          g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n      in Cn 1 (r_lifz r_auxhyp g)\n          [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n     [f \\<triangleright> 0] =\n    eval r_auxhyp [f \\<triangleright> 0]", "using \\<open>recfn 1 g\\<close> c_def g_def m_def p_def r_auxhyp_prim"], ["proof (prove)\nusing this:\n  eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> 0] \\<down>= 0\n  recfn 1 g\n  c = Cn 1 r_inconsist [m, recf.Id 1 0]\n  g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n  m = Cn 1 r_amalgamate [at0, at1]\n  p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]]\n  prim_recfn 1 r_auxhyp\n\ngoal (1 subgoal):\n 1. eval\n     (let at0 = Cn 1 r_nth [recf.Id 1 0, Z];\n          at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1];\n          m = Cn 1 r_amalgamate [at0, at1];\n          c = Cn 1 r_inconsist [m, recf.Id 1 0];\n          p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n          g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n      in Cn 1 (r_lifz r_auxhyp g)\n          [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n     [f \\<triangleright> 0] =\n    eval r_auxhyp [f \\<triangleright> 0]", "by (auto simp add: Let_def)"], ["proof (state)\nthis:\n  eval r_sv01 [f \\<triangleright> 0] = eval r_auxhyp [f \\<triangleright> 0]\n\ngoal (4 subgoals):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)\n 2. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 4. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  eval r_sv01 [f \\<triangleright> 0] = eval r_auxhyp [f \\<triangleright> 0]", "show \"s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) = auxhyp (f \\<triangleright> 0)\""], ["proof (prove)\nusing this:\n  eval r_sv01 [f \\<triangleright> 0] = eval r_auxhyp [f \\<triangleright> 0]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) =\n    auxhyp (f \\<triangleright> 0)", "by (simp add: auxhyp_def sv01_def)"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) = auxhyp (f \\<triangleright> 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have sv01: \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\" if \"n \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "have *: \"eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n] \\<down>\\<noteq> 0\"\n      (is \"?r_eq \\<down>\\<noteq> 0\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_eq [r_length, r_const 1])\n     [f \\<triangleright> n] \\<down>\\<noteq>\n    0", "using that"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. eval (Cn 1 r_eq [r_length, r_const 1])\n     [f \\<triangleright> n] \\<down>\\<noteq>\n    0", "by simp"], ["proof (state)\nthis:\n  eval (Cn 1 r_eq [r_length, r_const 1])\n   [f \\<triangleright> n] \\<down>\\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "moreover"], ["proof (state)\nthis:\n  eval (Cn 1 r_eq [r_length, r_const 1])\n   [f \\<triangleright> n] \\<down>\\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "have \"recfn 2 (r_lifz r_auxhyp g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 2 (r_lifz r_auxhyp g)", "using \\<open>recfn 1 g\\<close> r_auxhyp_prim"], ["proof (prove)\nusing this:\n  recfn 1 g\n  prim_recfn 1 r_auxhyp\n\ngoal (1 subgoal):\n 1. recfn 2 (r_lifz r_auxhyp g)", "by simp"], ["proof (state)\nthis:\n  recfn 2 (r_lifz r_auxhyp g)\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "moreover"], ["proof (state)\nthis:\n  recfn 2 (r_lifz r_auxhyp g)\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "have \"eval r_sv01 [f \\<triangleright> n] =\n        eval (Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], Id 1 0]) [f \\<triangleright> n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> n] =\n    eval\n     (Cn 1 (r_lifz r_auxhyp g)\n       [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n     [f \\<triangleright> n]", "using r_sv01_def"], ["proof (prove)\nusing this:\n  r_sv01 \\<equiv>\n  let at0 = Cn 1 r_nth [recf.Id 1 0, Z];\n      at1 = Cn 1 r_nth [recf.Id 1 0, r_const 1];\n      m = Cn 1 r_amalgamate [at0, at1];\n      c = Cn 1 r_inconsist [m, recf.Id 1 0];\n      p = Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]];\n      g = Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]]\n  in Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0]\n\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> n] =\n    eval\n     (Cn 1 (r_lifz r_auxhyp g)\n       [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n     [f \\<triangleright> n]", "by (metis at0_def at1_def c_def g_def m_def p_def)"], ["proof (state)\nthis:\n  eval r_sv01 [f \\<triangleright> n] =\n  eval\n   (Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n   [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "ultimately"], ["proof (chain)\npicking this:\n  eval (Cn 1 r_eq [r_length, r_const 1])\n   [f \\<triangleright> n] \\<down>\\<noteq>\n  0\n  recfn 2 (r_lifz r_auxhyp g)\n  eval r_sv01 [f \\<triangleright> n] =\n  eval\n   (Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n   [f \\<triangleright> n]", "have \"eval r_sv01 [f \\<triangleright> n] = eval (r_lifz r_auxhyp g) [the ?r_eq, f \\<triangleright> n]\""], ["proof (prove)\nusing this:\n  eval (Cn 1 r_eq [r_length, r_const 1])\n   [f \\<triangleright> n] \\<down>\\<noteq>\n  0\n  recfn 2 (r_lifz r_auxhyp g)\n  eval r_sv01 [f \\<triangleright> n] =\n  eval\n   (Cn 1 (r_lifz r_auxhyp g) [Cn 1 r_eq [r_length, r_const 1], recf.Id 1 0])\n   [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> n] =\n    eval (r_lifz r_auxhyp g)\n     [the (eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n]),\n      f \\<triangleright> n]", "by simp"], ["proof (state)\nthis:\n  eval r_sv01 [f \\<triangleright> n] =\n  eval (r_lifz r_auxhyp g)\n   [the (eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n]),\n    f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "then"], ["proof (chain)\npicking this:\n  eval r_sv01 [f \\<triangleright> n] =\n  eval (r_lifz r_auxhyp g)\n   [the (eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n]),\n    f \\<triangleright> n]", "have \"eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]\""], ["proof (prove)\nusing this:\n  eval r_sv01 [f \\<triangleright> n] =\n  eval (r_lifz r_auxhyp g)\n   [the (eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n]),\n    f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]", "using \"*\" \\<open>recfn 1 g\\<close> r_auxhyp_prim"], ["proof (prove)\nusing this:\n  eval r_sv01 [f \\<triangleright> n] =\n  eval (r_lifz r_auxhyp g)\n   [the (eval (Cn 1 r_eq [r_length, r_const 1]) [f \\<triangleright> n]),\n    f \\<triangleright> n]\n  eval (Cn 1 r_eq [r_length, r_const 1])\n   [f \\<triangleright> n] \\<down>\\<noteq>\n  0\n  recfn 1 g\n  prim_recfn 1 r_auxhyp\n\ngoal (1 subgoal):\n 1. eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]", "by auto"], ["proof (state)\nthis:\n  eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "then"], ["proof (chain)\npicking this:\n  eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]", "show ?thesis"], ["proof (prove)\nusing this:\n  eval r_sv01 [f \\<triangleright> n] = eval g [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    eval g [f \\<triangleright> n]", "by (simp add: sv01_def that)"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 at0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 at0", "unfolding at0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_nth [recf.Id 1 0, Z])", "by simp"], ["proof (state)\nthis:\n  recfn 1 at0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have at0: \"eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval at0 [f \\<triangleright> n] \\<down>= the (f 0)", "unfolding at0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval (Cn 1 r_nth [recf.Id 1 0, Z]) [f \\<triangleright> n] \\<down>=\n    the (f 0)", "by simp"], ["proof (state)\nthis:\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 at1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 at1", "unfolding at1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_nth [recf.Id 1 0, r_const 1])", "by simp"], ["proof (state)\nthis:\n  recfn 1 at1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have at1: \"n \\<noteq> 0 \\<Longrightarrow> eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval at1 [f \\<triangleright> n] \\<down>= the (f 1)", "unfolding at1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_nth [recf.Id 1 0, r_const 1])\n     [f \\<triangleright> n] \\<down>=\n    the (f 1)", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 m", "unfolding m_def at0_def at1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_amalgamate\n       [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]])", "using r_amalgamate_recfn"], ["proof (prove)\nusing this:\n  recfn 2 r_amalgamate\n\ngoal (1 subgoal):\n 1. recfn 1\n     (Cn 1 r_amalgamate\n       [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]])", "by simp"], ["proof (state)\nthis:\n  recfn 1 m\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have m: \"n \\<noteq> 0 \\<Longrightarrow> eval m [f \\<triangleright> n] \\<down>= amalg01 f\"\n      (is \"_ \\<Longrightarrow> _ \\<down>= ?m\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval m [f \\<triangleright> n] \\<down>= amalg01 f", "unfolding m_def at0_def at1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (Cn 1 r_amalgamate\n       [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]])\n     [f \\<triangleright> n] \\<down>=\n    amalg01 f", "using at0 at1 amalgamate r_amalgamate r_amalgamate_recfn"], ["proof (prove)\nusing this:\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  \\<phi> (amalgamate ?i ?j) = amalgamation ?i ?j\n  eval r_amalgamate [?i, ?j] \\<down>= amalgamate ?i ?j\n  recfn 2 r_amalgamate\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval\n     (Cn 1 r_amalgamate\n       [Cn 1 r_nth [recf.Id 1 0, Z], Cn 1 r_nth [recf.Id 1 0, r_const 1]])\n     [f \\<triangleright> n] \\<down>=\n    amalg01 f", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f", "have c: \"n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] = inconsist (amalg01 f) (f \\<triangleright> n)\"\n      (is \"_ \\<Longrightarrow> _ = ?c\")"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval c [f \\<triangleright> n] =\n    inconsist (amalg01 f) (f \\<triangleright> n)", "unfolding c_def"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_inconsist [m, recf.Id 1 0]) [f \\<triangleright> n] =\n    inconsist (amalg01 f) (f \\<triangleright> n)", "using r_inconsist_recfn \\<open>recfn 1 m\\<close> r_inconsist"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n  recfn 2 r_inconsist\n  recfn 1 m\n  eval r_inconsist [?i, ?e] = inconsist ?i ?e\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_inconsist [m, recf.Id 1 0]) [f \\<triangleright> n] =\n    inconsist (amalg01 f) (f \\<triangleright> n)", "by auto"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)", "have c_converg: \"n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>", "using inconsist_for_V01[OF assms]"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)\n  ?k = amalg01 f \\<Longrightarrow>\n  inconsist ?k ?e \\<down>=\n  (if \\<exists>x<e_length ?e. \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n   then LEAST x.\n           x < e_length ?e \\<and> \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n   else e_length ?e)\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 c", "unfolding c_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_inconsist [m, recf.Id 1 0])", "using \\<open>recfn 1 m\\<close> r_inconsist_recfn"], ["proof (prove)\nusing this:\n  recfn 1 m\n  recfn 2 r_inconsist\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_inconsist [m, recf.Id 1 0])", "by simp"], ["proof (state)\nthis:\n  recfn 1 c\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have par: \"n \\<noteq> 0 \\<Longrightarrow>\n      eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] = parallel (the (f 0)) (the (f 1)) (the ?c)\"\n      (is \"_ \\<Longrightarrow> _ = ?par\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n    parallel (the (f 0)) (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "using at0 at1 c c_converg m r_parallel' \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 c\\<close>"], ["proof (prove)\nusing this:\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n  eval r_parallel [?i, ?j, ?x] = parallel ?i ?j ?x\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 c\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n    parallel (the (f 0)) (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n  parallel (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "with parallel_converg_V01[OF assms]"], ["proof (chain)\npicking this:\n  parallel (the (f 0)) (the (f 1)) ?x \\<down>\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n  parallel (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "have\n      par_converg: \"n \\<noteq> 0 \\<Longrightarrow> eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\""], ["proof (prove)\nusing this:\n  parallel (the (f 0)) (the (f 1)) ?x \\<down>\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n  parallel (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>", "have p_converg: \"n \\<noteq> 0 \\<Longrightarrow> eval p [f \\<triangleright> n] \\<down>\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow> eval p [f \\<triangleright> n] \\<down>", "unfolding p_def"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])\n     [f \\<triangleright> n] \\<down>", "using at0 at1 c_converg \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 c\\<close>"], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 c\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])\n     [f \\<triangleright> n] \\<down>", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow> eval p [f \\<triangleright> n] \\<down>\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have p: \"n \\<noteq> 0 \\<Longrightarrow> eval p [f \\<triangleright> n] \\<down>= pdec1 (the ?par)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval p [f \\<triangleright> n] \\<down>=\n    pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])\n     [f \\<triangleright> n] \\<down>=\n    pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "using at0 at1 c_converg \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 c\\<close> par par_converg"], ["proof (prove)\nusing this:\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 c\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] =\n  parallel (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_parallel [at0, at1, c]) [f \\<triangleright> n] \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])\n     [f \\<triangleright> n] \\<down>=\n    pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval p [f \\<triangleright> n] \\<down>=\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"recfn 1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 p", "unfolding p_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])", "using \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 m\\<close> \\<open>recfn 1 c\\<close>"], ["proof (prove)\nusing this:\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 m\n  recfn 1 c\n\ngoal (1 subgoal):\n 1. recfn 1 (Cn 1 r_pdec1 [Cn 1 r_parallel [at0, at1, c]])", "by simp"], ["proof (state)\nthis:\n  recfn 1 p\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "let ?r = \"Cn 1 r_ifz [p, at1, at0]\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have r: \"n \\<noteq> 0 \\<Longrightarrow> eval ?r [f \\<triangleright> n] = (if pdec1 (the ?par) = 0 then f 1 else f 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n    (if pdec1\n         (the (parallel (the (f 0)) (the (f 1))\n                (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n        0\n     then f 1 else f 0)", "using at0 at1 c_converg \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 c\\<close>\n      \\<open>recfn 1 m\\<close> \\<open>recfn 1 p\\<close> p f_total"], ["proof (prove)\nusing this:\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 c\n  recfn 1 m\n  recfn 1 p\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval p [f \\<triangleright> n] \\<down>=\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n  f ?x \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n    (if pdec1\n         (the (parallel (the (f 0)) (the (f 1))\n                (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n        0\n     then f 1 else f 0)", "by fastforce"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n  (if pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\n   then f 1 else f 0)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have g: \"n \\<noteq> 0 \\<Longrightarrow>\n      eval g [f \\<triangleright> n] \\<down>=\n        (if the ?c = e_length (f \\<triangleright> n)\n         then ?m else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval g [f \\<triangleright> n] \\<down>=\n    (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n        e_length (f \\<triangleright> n)\n     then amalg01 f\n     else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))", "unfolding g_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]])\n     [f \\<triangleright> n] \\<down>=\n    (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n        e_length (f \\<triangleright> n)\n     then amalg01 f\n     else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))", "using \\<open>recfn 1 p\\<close> \\<open>recfn 1 at0\\<close> \\<open>recfn 1 at1\\<close> \\<open>recfn 1 c\\<close> \\<open>recfn 1 m\\<close>\n      p_converg at1 at0 c c_converg m"], ["proof (prove)\nusing this:\n  recfn 1 p\n  recfn 1 at0\n  recfn 1 at1\n  recfn 1 c\n  recfn 1 m\n  n \\<noteq> 0 \\<Longrightarrow> eval p [f \\<triangleright> n] \\<down>\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval at1 [f \\<triangleright> n] \\<down>= the (f 1)\n  eval at0 [f \\<triangleright> n] \\<down>= the (f 0)\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval c [f \\<triangleright> n] =\n  inconsist (amalg01 f) (f \\<triangleright> n)\n  n \\<noteq> 0 \\<Longrightarrow> eval c [f \\<triangleright> n] \\<down>\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval m [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    eval (Cn 1 r_ifeq [c, r_length, m, Cn 1 r_ifz [p, at1, at0]])\n     [f \\<triangleright> n] \\<down>=\n    (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n        e_length (f \\<triangleright> n)\n     then amalg01 f\n     else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))", "by simp"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "{"], ["proof (state)\nthis:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "assume \"n \\<noteq> 0\" and \"?c \\<down>= Suc n\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "moreover"], ["proof (state)\nthis:\n  n \\<noteq> 0\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "have \"e_length (f \\<triangleright> n) = Suc n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e_length (f \\<triangleright> n) = Suc n", "by simp"], ["proof (state)\nthis:\n  e_length (f \\<triangleright> n) = Suc n\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "ultimately"], ["proof (chain)\npicking this:\n  n \\<noteq> 0\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n  e_length (f \\<triangleright> n) = Suc n", "have \"eval g [f \\<triangleright> n] \\<down>= ?m\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n  e_length (f \\<triangleright> n) = Suc n\n\ngoal (1 subgoal):\n 1. eval g [f \\<triangleright> n] \\<down>= amalg01 f", "using g"], ["proof (prove)\nusing this:\n  n \\<noteq> 0\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n  e_length (f \\<triangleright> n) = Suc n\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n\ngoal (1 subgoal):\n 1. eval g [f \\<triangleright> n] \\<down>= amalg01 f", "by simp"], ["proof (state)\nthis:\n  eval g [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n                      amalg01 f\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 3. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  eval g [f \\<triangleright> n] \\<down>= amalg01 f", "show \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\""], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] \\<down>= amalg01 f\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f", "using sv01[OF \\<open>n \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] \\<down>= amalg01 f\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "assume \"n \\<noteq> 0\" and \"the ?c < Suc n\" and \"pdec1 (the ?par) = 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "with g r f_total"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n  (if pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\n   then f 1 else f 0)\n  f ?x \\<down>\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0", "have \"eval g [f \\<triangleright> n] = f 1\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n  (if pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\n   then f 1 else f 0)\n  f ?x \\<down>\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n\ngoal (1 subgoal):\n 1. eval g [f \\<triangleright> n] = f 1", "by simp"], ["proof (state)\nthis:\n  eval g [f \\<triangleright> n] = f 1\n\ngoal (2 subgoals):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n 2. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  eval g [f \\<triangleright> n] = f 1", "show \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\""], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] = f 1\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1", "using sv01[OF \\<open>n \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] = f 1\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "assume \"n \\<noteq> 0\" and \"the ?c < Suc n\" and \"pdec1 (the ?par) \\<noteq> 0\""], ["proof (state)\nthis:\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "with g r f_total"], ["proof (chain)\npicking this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n  (if pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\n   then f 1 else f 0)\n  f ?x \\<down>\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0", "have \"eval g [f \\<triangleright> n] = f 0\""], ["proof (prove)\nusing this:\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval g [f \\<triangleright> n] \\<down>=\n  (if the (inconsist (amalg01 f) (f \\<triangleright> n)) =\n      e_length (f \\<triangleright> n)\n   then amalg01 f\n   else the (eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n]))\n  n \\<noteq> 0 \\<Longrightarrow>\n  eval (Cn 1 r_ifz [p, at1, at0]) [f \\<triangleright> n] =\n  (if pdec1\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n      0\n   then f 1 else f 0)\n  f ?x \\<down>\n  n \\<noteq> 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. eval g [f \\<triangleright> n] = f 0", "by simp"], ["proof (state)\nthis:\n  eval g [f \\<triangleright> n] = f 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>n \\<noteq> 0;\n     the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n     pdec1\n      (the (parallel (the (f 0)) (the (f 1))\n             (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n     0\\<rbrakk>\n    \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "then"], ["proof (chain)\npicking this:\n  eval g [f \\<triangleright> n] = f 0", "show \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\""], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] = f 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "using sv01[OF \\<open>n \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  eval g [f \\<triangleright> n] = f 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = eval g [f \\<triangleright> n]\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>n \\<noteq> 0;\n   the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n;\n   pdec1\n    (the (parallel (the (f 0)) (the (f 1))\n           (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Part of the correctness of @{term sv01} is convergence on\nprefixes of functions in @{term \"V\\<^sub>0\\<^sub>1\"}.\\<close>"], ["", "lemma sv01_converg_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "then"], ["proof (chain)\npicking this:\n  n = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "using assms sv01 R1_imp_total1 auxhyp_in_R1"], ["proof (prove)\nusing this:\n  n = 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  auxhyp \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "case n_gr_0: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "proof (cases \"inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    Suc n \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n 2. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "case True"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (2 subgoals):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    Suc n \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n 2. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "then"], ["proof (chain)\npicking this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "using n_gr_0 assms sv01"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n  n \\<noteq> 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "case False"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "then"], ["proof (chain)\npicking this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)", "have \"the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\""], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "using assms inconsist_bounded inconsist_for_V01 length_init"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n  f \\<in> V\\<^sub>0\\<^sub>1\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  the (inconsist ?i ?e) \\<le> e_length ?e\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?k = amalg01 ?f\\<rbrakk>\n  \\<Longrightarrow> inconsist ?k ?e \\<down>=\n                    (if \\<exists>x<e_length ?e.\n                           \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     then LEAST x.\n                             x < e_length ?e \\<and>\n                             \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     else e_length ?e)\n  e_length (?f \\<triangleright> ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "by (metis (no_types, lifting) le_neq_implies_less option.collapse option.simps(3))"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "then"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "using n_gr_0 assms sv01 R1_imp_total1 total1E V01_def"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  n \\<noteq> 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<Longrightarrow> ?f ?x \\<down>\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>", "by (metis (no_types, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Another part of the correctness of @{term sv01} is its hypotheses\nbeing consistent on prefixes of functions in @{term \"V\\<^sub>0\\<^sub>1\"}.\\<close>"], ["", "lemma sv01_consistent_V01:\n  assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n  shows \"\\<forall>x\\<le>n. \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "proof (cases \"n = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case True"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  n = 0", "have \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = auxhyp (f \\<triangleright> n)\""], ["proof (prove)\nusing this:\n  n = 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    auxhyp (f \\<triangleright> n)", "using sv01[OF assms]"], ["proof (prove)\nusing this:\n  n = 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> 0) = auxhyp (f \\<triangleright> 0)\n  \\<lbrakk>?n \\<noteq> 0;\n   inconsist (amalg01 f) (f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> ?n) \\<down>=\n                    amalg01 f\n  \\<lbrakk>?n \\<noteq> 0;\n   the (inconsist (amalg01 f) (f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (f 0)) (the (f 1))\n           (the (inconsist (amalg01 f) (f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> ?n) = f 1\n  \\<lbrakk>?n \\<noteq> 0;\n   the (inconsist (amalg01 f) (f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (f 0)) (the (f 1))\n           (the (inconsist (amalg01 f) (f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (f \\<triangleright> ?n) = f 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) =\n    auxhyp (f \\<triangleright> n)", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = auxhyp (f \\<triangleright> n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = auxhyp (f \\<triangleright> n)", "have \"\\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) = prenum (f \\<triangleright> n)\""], ["proof (prove)\nusing this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = auxhyp (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n    prenum (f \\<triangleright> n)", "using auxhyp_prenum"], ["proof (prove)\nusing this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = auxhyp (f \\<triangleright> n)\n  \\<phi> (the (auxhyp ?e)) = prenum ?e\n\ngoal (1 subgoal):\n 1. \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n    prenum (f \\<triangleright> n)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n  prenum (f \\<triangleright> n)\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n  prenum (f \\<triangleright> n)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n  prenum (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "using R1_imp_total1 total1E assms"], ["proof (prove)\nusing this:\n  \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) =\n  prenum (f \\<triangleright> n)\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<Longrightarrow> ?f ?x \\<down>\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "by (simp add: V01_def)"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case n_gr_0: False"], ["proof (state)\nthis:\n  n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "let ?m = \"amalg01 f\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "let ?e = \"f \\<triangleright> n\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "let ?c = \"the (inconsist ?m ?e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "have c: \"inconsist ?m ?e \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>", "using assms inconsist_for_V01"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?k = amalg01 ?f\\<rbrakk>\n  \\<Longrightarrow> inconsist ?k ?e \\<down>=\n                    (if \\<exists>x<e_length ?e.\n                           \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     then LEAST x.\n                             x < e_length ?e \\<and>\n                             \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     else e_length ?e)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>", "by blast"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>\n\ngoal (1 subgoal):\n 1. n \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "proof (cases \"inconsist ?m ?e \\<down>= Suc n\")"], ["proof (state)\ngoal (2 subgoals):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    Suc n \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case True"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (2 subgoals):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    Suc n \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n", "show ?thesis"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "using assms n_gr_0 sv01 R1_imp_total1 total1E V01_def is_init_of_def\n        inconsist_consistent not_initial_imp_not_eq length_init inconsist_converg_eq"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>= Suc n\n  f \\<in> V\\<^sub>0\\<^sub>1\n  n \\<noteq> 0\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  ?f \\<in> \\<R> \\<Longrightarrow> total1 ?f\n  total1 ?f \\<Longrightarrow> ?f ?x \\<down>\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n  is_init_of ?t ?f \\<equiv> \\<forall>i<e_length ?t. ?f i \\<down>= e_nth ?t i\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  (inconsist ?i ?e \\<down>= e_length ?e) =\n  (\\<forall>x<e_length ?e. \\<phi> ?i x \\<down>= e_nth ?e x)\n  \\<lbrakk>\\<And>x. x < Suc ?n \\<Longrightarrow> ?f x \\<down>;\n   \\<not> is_init_of (?f \\<triangleright> ?n) ?g\\<rbrakk>\n  \\<Longrightarrow> ?f \\<noteq> ?g\n  e_length (?f \\<triangleright> ?n) = Suc ?n\n  inconsist ?i ?e \\<down>= e_length ?e \\<Longrightarrow>\n  \\<forall>x<e_length ?e. \\<phi> ?i x \\<down>= e_nth ?e x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "by (metis (no_types, lifting) le_imp_less_Suc mem_Collect_eq option.sel)"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case False"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)", "have less: \"the (inconsist ?m ?e) < Suc n\""], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "using c assms inconsist_bounded inconsist_for_V01 length_init"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq> Some (Suc n)\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>\n  f \\<in> V\\<^sub>0\\<^sub>1\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  the (inconsist ?i ?e) \\<le> e_length ?e\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?k = amalg01 ?f\\<rbrakk>\n  \\<Longrightarrow> inconsist ?k ?e \\<down>=\n                    (if \\<exists>x<e_length ?e.\n                           \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     then LEAST x.\n                             x < e_length ?e \\<and>\n                             \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     else e_length ?e)\n  e_length (?f \\<triangleright> ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "by (metis le_neq_implies_less option.collapse)"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n", "have \"the (inconsist ?m ?e) < e_length ?e\""], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n))\n    < e_length (f \\<triangleright> n)", "by auto"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n)", "have\n      \"\\<exists>x<e_length ?e. \\<phi> ?m x \\<down>\\<noteq> e_nth ?e x\"\n      \"inconsist ?m ?e \\<down>= (LEAST x. x < e_length ?e \\<and> \\<phi> ?m x \\<down>\\<noteq> e_nth ?e x)\"\n      (is \"_ \\<down>= Least ?P\")"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n)\n\ngoal (1 subgoal):\n 1. \\<exists>x<e_length (f \\<triangleright> n).\n       \\<phi> (amalg01 f) x \\<down>\\<noteq>\n       e_nth (f \\<triangleright> n) x &&&\n    inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    (LEAST x.\n        x < e_length (f \\<triangleright> n) \\<and>\n        \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "using inconsist_converg_less[OF c]"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n)\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n) \\<Longrightarrow>\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n) \\<Longrightarrow>\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n\ngoal (1 subgoal):\n 1. \\<exists>x<e_length (f \\<triangleright> n).\n       \\<phi> (amalg01 f) x \\<down>\\<noteq>\n       e_nth (f \\<triangleright> n) x &&&\n    inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n    (LEAST x.\n        x < e_length (f \\<triangleright> n) \\<and>\n        \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "by simp_all"], ["proof (state)\nthis:\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)", "have \"?P ?c\" and \"\\<And>x. x < ?c \\<Longrightarrow> \\<not> ?P x\""], ["proof (prove)\nusing this:\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n))\n    < e_length (f \\<triangleright> n) \\<and>\n    \\<phi> (amalg01 f)\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>\\<noteq>\n    e_nth (f \\<triangleright> n)\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) &&&\n    (\\<And>x.\n        x < the (inconsist (amalg01 f)\n                  (f \\<triangleright> n)) \\<Longrightarrow>\n        \\<not> (x < e_length (f \\<triangleright> n) \\<and>\n                \\<phi> (amalg01 f) x \\<down>\\<noteq>\n                e_nth (f \\<triangleright> n) x))", "using LeastI_ex[of ?P] not_less_Least[of _ ?P]"], ["proof (prove)\nusing this:\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x\n  inconsist (amalg01 f) (f \\<triangleright> n) \\<down>=\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n  \\<exists>x<e_length (f \\<triangleright> n).\n     \\<phi> (amalg01 f) x \\<down>\\<noteq>\n     e_nth (f \\<triangleright> n) x \\<Longrightarrow>\n  (LEAST x.\n      x < e_length (f \\<triangleright> n) \\<and>\n      \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n  < e_length (f \\<triangleright> n) \\<and>\n  \\<phi> (amalg01 f)\n   (LEAST x.\n       x < e_length (f \\<triangleright> n) \\<and>\n       \\<phi> (amalg01 f) x \\<down>\\<noteq>\n       e_nth (f \\<triangleright> n) x) \\<down>\\<noteq>\n  e_nth (f \\<triangleright> n)\n   (LEAST x.\n       x < e_length (f \\<triangleright> n) \\<and>\n       \\<phi> (amalg01 f) x \\<down>\\<noteq> e_nth (f \\<triangleright> n) x)\n  ?k < (LEAST x.\n           x < e_length (f \\<triangleright> n) \\<and>\n           \\<phi> (amalg01 f) x \\<down>\\<noteq>\n           e_nth (f \\<triangleright> n) x) \\<Longrightarrow>\n  \\<not> (?k < e_length (f \\<triangleright> n) \\<and>\n          \\<phi> (amalg01 f) ?k \\<down>\\<noteq>\n          e_nth (f \\<triangleright> n) ?k)\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n))\n    < e_length (f \\<triangleright> n) \\<and>\n    \\<phi> (amalg01 f)\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>\\<noteq>\n    e_nth (f \\<triangleright> n)\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) &&&\n    (\\<And>x.\n        x < the (inconsist (amalg01 f)\n                  (f \\<triangleright> n)) \\<Longrightarrow>\n        \\<not> (x < e_length (f \\<triangleright> n) \\<and>\n                \\<phi> (amalg01 f) x \\<down>\\<noteq>\n                e_nth (f \\<triangleright> n) x))", "by (auto simp del: e_nth)"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n) \\<and>\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>\\<noteq>\n  e_nth (f \\<triangleright> n)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  ?x < the (inconsist (amalg01 f) (f \\<triangleright> n)) \\<Longrightarrow>\n  \\<not> (?x < e_length (f \\<triangleright> n) \\<and>\n          \\<phi> (amalg01 f) ?x \\<down>\\<noteq>\n          e_nth (f \\<triangleright> n) ?x)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n) \\<and>\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>\\<noteq>\n  e_nth (f \\<triangleright> n)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  ?x < the (inconsist (amalg01 f) (f \\<triangleright> n)) \\<Longrightarrow>\n  \\<not> (?x < e_length (f \\<triangleright> n) \\<and>\n          \\<phi> (amalg01 f) ?x \\<down>\\<noteq>\n          e_nth (f \\<triangleright> n) ?x)", "have \"\\<phi> ?m ?c \\<noteq> f ?c\""], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n))\n  < e_length (f \\<triangleright> n) \\<and>\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>\\<noteq>\n  e_nth (f \\<triangleright> n)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  ?x < the (inconsist (amalg01 f) (f \\<triangleright> n)) \\<Longrightarrow>\n  \\<not> (?x < e_length (f \\<triangleright> n) \\<and>\n          \\<phi> (amalg01 f) ?x \\<down>\\<noteq>\n          e_nth (f \\<triangleright> n) ?x)\n\ngoal (1 subgoal):\n 1. \\<phi> (amalg01 f)\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by auto"], ["proof (state)\nthis:\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "have \"amalgamation (the (f 0)) (the (f 1)) ?c \\<noteq> f ?c\""], ["proof (prove)\nusing this:\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. amalgamation (the (f 0)) (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "using amalgamate"], ["proof (prove)\nusing this:\n  \\<phi> (amalg01 f)\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  \\<phi> (amalgamate ?i ?j) = amalgamation ?i ?j\n\ngoal (1 subgoal):\n 1. amalgamation (the (f 0)) (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by simp"], ["proof (state)\nthis:\n  amalgamation (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  amalgamation (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "have *: \"Some (pdec2 (the (parallel (the (f 0)) (the (f 1)) ?c))) \\<noteq> f ?c\""], ["proof (prove)\nusing this:\n  amalgamation (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. Some\n     (pdec2\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f)\n                     (f \\<triangleright> n)))))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "using amalgamation_def"], ["proof (prove)\nusing this:\n  amalgamation (the (f 0)) (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n  amalgamation ?i ?j ?x \\<equiv>\n  if parallel ?i ?j ?x \\<up> then None\n  else Some (pdec2 (the (parallel ?i ?j ?x)))\n\ngoal (1 subgoal):\n 1. Some\n     (pdec2\n       (the (parallel (the (f 0)) (the (f 1))\n              (the (inconsist (amalg01 f)\n                     (f \\<triangleright> n)))))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by (metis assms parallel_converg_V01)"], ["proof (state)\nthis:\n  Some\n   (pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "let ?p = \"parallel (the (f 0)) (the (f 1)) ?c\""], ["proof (state)\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n) \\<noteq>\n    Some (Suc n) \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "proof (cases \"pdec1 (the ?p) = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case True"], ["proof (state)\nthis:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0", "have \"\\<phi> (the (f 0)) ?c \\<down>= pdec2 (the ?p)\""], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n    pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "using assms parallel_0 parallel_converg_V01"], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n  f \\<in> V\\<^sub>0\\<^sub>1\n  parallel ?i ?j ?x \\<down>= prod_encode (0, ?v) \\<Longrightarrow>\n  \\<phi> ?i ?x \\<down>= ?v\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  parallel (the (?f 0)) (the (?f 1)) ?x \\<down>\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n    pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "by (metis option.collapse prod.collapse prod_decode_inverse)"], ["proof (state)\nthis:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "have \"\\<phi> (the (f 0)) ?c \\<noteq> f ?c\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "using *"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n  Some\n   (pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "have \"\\<phi> (the (f 0)) \\<noteq> f\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) \\<noteq> f", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 0)) \\<noteq> f\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0)) \\<noteq> f", "have \"\\<phi> (the (f 1)) = f\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) \\<noteq> f\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1)) = f", "using assms V01_def"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) \\<noteq> f\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1)) = f", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 1)) = f\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "moreover"], ["proof (state)\nthis:\n  \\<phi> (the (f 1)) = f\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "have \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1", "using True less n_gr_0 sv01 assms"], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  n \\<noteq> 0\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n\ngoal (2 subgoals):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n 2. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 1)) = f\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1)) = f\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 1\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "case False"], ["proof (state)\nthis:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0", "have \"pdec1 (the ?p) = 1\""], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n    1", "by (meson assms parallel_converg_V01 parallel_converg_pdec1_0_or_1)"], ["proof (state)\nthis:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  1\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  1", "have \"\\<phi> (the (f 1)) ?c \\<down>= pdec2 (the ?p)\""], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  1\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n    pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "using assms parallel_1 parallel_converg_V01"], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) =\n  1\n  f \\<in> V\\<^sub>0\\<^sub>1\n  parallel ?i ?j ?x \\<down>= prod_encode (1, ?v) \\<Longrightarrow>\n  \\<phi> ?j ?x \\<down>= ?v\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  parallel (the (?f 0)) (the (?f 1)) ?x \\<down>\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n    pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "by (metis option.collapse prod.collapse prod_decode_inverse)"], ["proof (state)\nthis:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))", "have \"\\<phi> (the (f 1)) ?c \\<noteq> f ?c\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "using *"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<down>=\n  pdec2\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n)))))\n  Some\n   (pdec2\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n)))))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1))\n     (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n    f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "by simp"], ["proof (state)\nthis:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))", "have \"\\<phi> (the (f 1)) \\<noteq> f\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1))\n   (the (inconsist (amalg01 f) (f \\<triangleright> n))) \\<noteq>\n  f (the (inconsist (amalg01 f) (f \\<triangleright> n)))\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 1)) \\<noteq> f", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 1)) \\<noteq> f\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "then"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 1)) \\<noteq> f", "have \"\\<phi> (the (f 0)) = f\""], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1)) \\<noteq> f\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) = f", "using assms V01_def"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 1)) \\<noteq> f\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. \\<phi> (the (f 0)) = f", "by auto"], ["proof (state)\nthis:\n  \\<phi> (the (f 0)) = f\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "moreover"], ["proof (state)\nthis:\n  \\<phi> (the (f 0)) = f\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "from False less n_gr_0 sv01 assms"], ["proof (chain)\npicking this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  n \\<noteq> 0\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  f \\<in> V\\<^sub>0\\<^sub>1", "have \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\""], ["proof (prove)\nusing this:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n  0\n  the (inconsist (amalg01 f) (f \\<triangleright> n)) < Suc n\n  n \\<noteq> 0\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "by simp"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n))))) \\<noteq>\n    0 \\<Longrightarrow>\n    \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> (the (f 0)) = f\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (the (f 0)) = f\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = f 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<le>n.\n       \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<le>n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) x = f x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The final part of the correctness is @{term \"sv01\"} converging\nfor all functions in @{term \"V\\<^sub>0\\<^sub>1\"}.\\<close>"], ["", "lemma sv01_limit_V01:\n assumes \"f \\<in> V\\<^sub>0\\<^sub>1\"\n shows \"\\<exists>i. \\<forall>\\<^sup>\\<infinity>n. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "proof (cases \"\\<forall>n>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalgamate (the (f 0)) (the (f 1))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>n>0.\n       s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n       amalg01 f \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n 2. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "case True"], ["proof (state)\nthis:\n  \\<forall>n>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\n\ngoal (2 subgoals):\n 1. \\<forall>n>0.\n       s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n       amalg01 f \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n 2. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  \\<forall>n>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f\n\ngoal (1 subgoal):\n 1. \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "by (meson less_le_trans zero_less_one)"], ["proof (state)\nthis:\n  \\<exists>i n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>n>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>n>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f)", "obtain n\\<^sub>0 where n0:\n    \"n\\<^sub>0 \\<noteq> 0\"\n    \"s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq> amalg01 f\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f)\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>0.\n        \\<lbrakk>n\\<^sub>0 \\<noteq> 0;\n         s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n         amalg01 f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>f \\<in> V\\<^sub>0\\<^sub>1\\<close> sv01_converg_V01"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>n>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= amalg01 f)\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>\n\ngoal (1 subgoal):\n 1. (\\<And>n\\<^sub>0.\n        \\<lbrakk>n\\<^sub>0 \\<noteq> 0;\n         s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n         amalg01 f\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  n\\<^sub>0 \\<noteq> 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n  amalg01 f\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>0 \\<noteq> 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n  amalg01 f", "have *: \"the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\"\n      (is \"the (inconsist ?m (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\")"], ["proof (prove)\nusing this:\n  n\\<^sub>0 \\<noteq> 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n  amalg01 f\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0))\n    < Suc n\\<^sub>0", "using assms \\<open>n\\<^sub>0 \\<noteq> 0\\<close> sv01(2) inconsist_bounded inconsist_for_V01 length_init"], ["proof (prove)\nusing this:\n  n\\<^sub>0 \\<noteq> 0\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n  amalg01 f\n  f \\<in> V\\<^sub>0\\<^sub>1\n  n\\<^sub>0 \\<noteq> 0\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  inconsist ?i ?e \\<down> \\<Longrightarrow>\n  the (inconsist ?i ?e) \\<le> e_length ?e\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?k = amalg01 ?f\\<rbrakk>\n  \\<Longrightarrow> inconsist ?k ?e \\<down>=\n                    (if \\<exists>x<e_length ?e.\n                           \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     then LEAST x.\n                             x < e_length ?e \\<and>\n                             \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     else e_length ?e)\n  e_length (?f \\<triangleright> ?n) = Suc ?n\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0))\n    < Suc n\\<^sub>0", "by (metis (no_types, lifting) le_neq_implies_less option.collapse option.simps(3))"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "have \"f \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "using assms V01_def"], ["proof (prove)\nusing this:\n  f \\<in> V\\<^sub>0\\<^sub>1\n  V\\<^sub>0\\<^sub>1 =\n  {f \\<in> \\<R>. \\<phi> (the (f 0)) = f \\<or> \\<phi> (the (f 1)) = f}\n\ngoal (1 subgoal):\n 1. f \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  f \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "have \"\\<phi> ?m \\<in> \\<R>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (amalg01 f) \\<in> \\<R>", "using amalgamate amalgamation_V01_R1 assms"], ["proof (prove)\nusing this:\n  \\<phi> (amalgamate ?i ?j) = amalgamation ?i ?j\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  amalgamation (the (?f 0)) (the (?f 1)) \\<in> \\<R>\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<phi> (amalg01 f) \\<in> \\<R>", "by auto"], ["proof (state)\nthis:\n  \\<phi> (amalg01 f) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  \\<phi> (amalg01 f) \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "have \"inconsist ?m (f \\<triangleright> n\\<^sub>0) \\<down>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>", "using inconsist_for_V01 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?k = amalg01 ?f\\<rbrakk>\n  \\<Longrightarrow> inconsist ?k ?e \\<down>=\n                    (if \\<exists>x<e_length ?e.\n                           \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     then LEAST x.\n                             x < e_length ?e \\<and>\n                             \\<phi> ?k x \\<down>\\<noteq> e_nth ?e x\n                     else e_length ?e)\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>", "by blast"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "ultimately"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n  f \\<in> \\<R>\n  \\<phi> (amalg01 f) \\<in> \\<R>\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>", "have **: \"inconsist ?m (f \\<triangleright> (n\\<^sub>0 + m)) = inconsist ?m (f \\<triangleright> n\\<^sub>0)\" for m"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n  f \\<in> \\<R>\n  \\<phi> (amalg01 f) \\<in> \\<R>\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + m)) =\n    inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)", "using inconsist_init_converg_less[of f ?m]"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n  f \\<in> \\<R>\n  \\<phi> (amalg01 f) \\<in> \\<R>\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0) \\<down>\n  \\<lbrakk>f \\<in> \\<R>; \\<phi> (amalg01 f) \\<in> \\<R>;\n   inconsist (amalg01 f) (f \\<triangleright> ?n) \\<down>;\n   the (inconsist (amalg01 f) (f \\<triangleright> ?n)) < Suc ?n\\<rbrakk>\n  \\<Longrightarrow> inconsist (amalg01 f) (f \\<triangleright> (?n + ?m)) =\n                    inconsist (amalg01 f) (f \\<triangleright> ?n)\n\ngoal (1 subgoal):\n 1. inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + m)) =\n    inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)", "by simp"], ["proof (state)\nthis:\n  inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)", "have \"the (inconsist ?m (f \\<triangleright> (n\\<^sub>0 + m))) < Suc n\\<^sub>0 + m\" for m"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + m)))\n    < Suc n\\<^sub>0 + m", "using *"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n\ngoal (1 subgoal):\n 1. the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + m)))\n    < Suc n\\<^sub>0 + m", "by auto"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)))\n  < Suc n\\<^sub>0 + ?m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)))\n  < Suc n\\<^sub>0 + ?m\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "have\n    \"pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist ?m (f \\<triangleright> (n\\<^sub>0 + m)))))) =\n      pdec1 (the (parallel (the (f 0)) (the (f 1)) (the (inconsist ?m (f \\<triangleright> n\\<^sub>0)))))\"\n    for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f)\n                   (f \\<triangleright> (n\\<^sub>0 + m)))))) =\n    pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))", "using **"], ["proof (prove)\nusing this:\n  inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f)\n                   (f \\<triangleright> (n\\<^sub>0 + m)))))) =\n    pdec1\n     (the (parallel (the (f 0)) (the (f 1))\n            (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))", "by auto"], ["proof (state)\nthis:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f)\n                 (f \\<triangleright> (n\\<^sub>0 + ?m)))))) =\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f)\n                 (f \\<triangleright> (n\\<^sub>0 + ?m)))))) =\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "have \"n\\<^sub>0 + m \\<noteq> 0\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. n\\<^sub>0 + m \\<noteq> 0", "using \\<open>n\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  n\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n\\<^sub>0 + m \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  n\\<^sub>0 + ?m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "ultimately"], ["proof (chain)\npicking this:\n  the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)))\n  < Suc n\\<^sub>0 + ?m\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f)\n                 (f \\<triangleright> (n\\<^sub>0 + ?m)))))) =\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))\n  n\\<^sub>0 + ?m \\<noteq> 0", "have \"s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + m)) = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\" for m"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)))\n  < Suc n\\<^sub>0 + ?m\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f)\n                 (f \\<triangleright> (n\\<^sub>0 + ?m)))))) =\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))\n  n\\<^sub>0 + ?m \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + m)) =\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)", "using assms sv01 * \\<open>n\\<^sub>0 \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  the (inconsist (amalg01 f) (f \\<triangleright> (n\\<^sub>0 + ?m)))\n  < Suc n\\<^sub>0 + ?m\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f)\n                 (f \\<triangleright> (n\\<^sub>0 + ?m)))))) =\n  pdec1\n   (the (parallel (the (f 0)) (the (f 1))\n          (the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)))))\n  n\\<^sub>0 + ?m \\<noteq> 0\n  f \\<in> V\\<^sub>0\\<^sub>1\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  s\\<^bsub>01\\<^esub> (?f \\<triangleright> 0) =\n  auxhyp (?f \\<triangleright> 0)\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   inconsist (amalg01 ?f) (?f \\<triangleright> ?n) \\<down>= Suc ?n\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) \\<down>=\n                    amalg01 ?f\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n))))) =\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 1\n  \\<lbrakk>?f \\<in> V\\<^sub>0\\<^sub>1; ?n \\<noteq> 0;\n   the (inconsist (amalg01 ?f) (?f \\<triangleright> ?n)) < Suc ?n;\n   pdec1\n    (the (parallel (the (?f 0)) (the (?f 1))\n           (the (inconsist (amalg01 ?f)\n                  (?f \\<triangleright> ?n))))) \\<noteq>\n   0\\<rbrakk>\n  \\<Longrightarrow> s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n) = ?f 0\n  the (inconsist (amalg01 f) (f \\<triangleright> n\\<^sub>0)) < Suc n\\<^sub>0\n  n\\<^sub>0 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + m)) =\n    s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)", "by (metis add_Suc)"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "moreover"], ["proof (state)\nthis:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "define i where \"i = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\""], ["proof (state)\nthis:\n  i = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "ultimately"], ["proof (chain)\npicking this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n  i = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)", "have \"\\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i\""], ["proof (prove)\nusing this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n  i = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i", "using nat_le_iff_add"], ["proof (prove)\nusing this:\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> (n\\<^sub>0 + ?m)) =\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n  i = s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0)\n  (?m \\<le> ?n) = (\\<exists>k. ?n = ?m + k)\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i", "by auto"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i", "have \"\\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>n\\<^sub>0.\n       s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i", "using n0(2)"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) = i\n  s\\<^bsub>01\\<^esub> (f \\<triangleright> n\\<^sub>0) \\<down>\\<noteq>\n  amalg01 f\n\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>n\\<^sub>0.\n       s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i", "by simp"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>n\\<^sub>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>n>0.\n               s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>=\n               amalg01 f) \\<Longrightarrow>\n    \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "then"], ["proof (chain)\npicking this:\n  \\<forall>n\\<ge>n\\<^sub>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>n\\<^sub>0.\n     s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= the i\n\ngoal (1 subgoal):\n 1. \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma V01_learn_cons: \"learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>", "proof (rule learn_consI2)"], ["proof (state)\ngoal (3 subgoals):\n 1. environment \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\n 2. \\<And>f.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<exists>i n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n 3. \\<And>f n.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<forall>k\\<le>n.\n          \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) k = f k", "show \"environment \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. environment \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>", "by (simp add: Collect_mono V01_def phi_in_P2 sv01_in_P1 sv01_converg_V01)"], ["proof (state)\nthis:\n  environment \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<exists>i n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\n 2. \\<And>f n.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<forall>k\\<le>n.\n          \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) k = f k", "show \"\\<And>f n. f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow> \\<forall>k\\<le>n. \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) k = f k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f n.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<forall>k\\<le>n.\n          \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) k = f k", "using sv01_consistent_V01"], ["proof (prove)\nusing this:\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  \\<forall>x\\<le>?n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n))) x = ?f x\n\ngoal (1 subgoal):\n 1. \\<And>f n.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<forall>k\\<le>n.\n          \\<phi> (the (s\\<^bsub>01\\<^esub> (f \\<triangleright> n))) k = f k", "."], ["proof (state)\nthis:\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  \\<forall>k\\<le>?n.\n     \\<phi> (the (s\\<^bsub>01\\<^esub> (?f \\<triangleright> ?n))) k = ?f k\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n       \\<exists>i n\\<^sub>0.\n          \\<forall>n\\<ge>n\\<^sub>0.\n             s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "show \"\\<exists>i n\\<^sub>0. \\<forall>n\\<ge>n\\<^sub>0. s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i\" if \"f \\<in> V\\<^sub>0\\<^sub>1\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "using sv01_limit_V01 that"], ["proof (prove)\nusing this:\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  \\<exists>i n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        s\\<^bsub>01\\<^esub> (?f \\<triangleright> n) \\<down>= i\n  f \\<in> V\\<^sub>0\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>i n\\<^sub>0.\n       \\<forall>n\\<ge>n\\<^sub>0.\n          s\\<^bsub>01\\<^esub> (f \\<triangleright> n) \\<down>= i", "by simp"], ["proof (state)\nthis:\n  ?f \\<in> V\\<^sub>0\\<^sub>1 \\<Longrightarrow>\n  \\<exists>i n\\<^sub>0.\n     \\<forall>n\\<ge>n\\<^sub>0.\n        s\\<^bsub>01\\<^esub> (?f \\<triangleright> n) \\<down>= i\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary V01_in_CONS: \"V\\<^sub>0\\<^sub>1 \\<in> CONS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V\\<^sub>0\\<^sub>1 \\<in> CONS", "using V01_learn_cons CONS_def"], ["proof (prove)\nusing this:\n  learn_cons \\<phi> V\\<^sub>0\\<^sub>1 s\\<^bsub>01\\<^esub>\n  CONS \\<equiv> {U. \\<exists>\\<psi> s. learn_cons \\<psi> U s}\n\ngoal (1 subgoal):\n 1. V\\<^sub>0\\<^sub>1 \\<in> CONS", "by auto"], ["", "text \\<open>Now we can show the main result of this section, namely that\nthere is a consistently learnable class that cannot be learned consistently\nby a total strategy. In other words, there is no Lemma~R for CONS.\\<close>"], ["", "lemma no_lemma_R_for_CONS: \"\\<exists>U. U \\<in> CONS \\<and> (\\<not> (\\<exists>s. s \\<in> \\<R> \\<and> learn_cons \\<phi> U s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> CONS \\<and>\n       (\\<nexists>s. s \\<in> \\<R> \\<and> learn_cons \\<phi> U s)", "using V01_in_CONS V01_not_in_R_cons"], ["proof (prove)\nusing this:\n  V\\<^sub>0\\<^sub>1 \\<in> CONS\n  ?s \\<in> \\<R> \\<Longrightarrow>\n  \\<not> learn_cons \\<phi> V\\<^sub>0\\<^sub>1 ?s\n\ngoal (1 subgoal):\n 1. \\<exists>U.\n       U \\<in> CONS \\<and>\n       (\\<nexists>s. s \\<in> \\<R> \\<and> learn_cons \\<phi> U s)", "by auto"], ["", "end"]]}