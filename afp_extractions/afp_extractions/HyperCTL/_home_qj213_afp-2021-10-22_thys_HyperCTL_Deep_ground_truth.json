{"file_name": "/home/qj213/afp-2021-10-22/thys/HyperCTL/Deep.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HyperCTL", "problem_names": ["lemmas der_Op_defs =\nTr_def Con_def Imp_def Eq_def Ev_def Alw_def Wuntil_def Fall_def Fall2_def", "lemma finite_fresh_pvar:\nassumes \"finite (P :: pvar set)\"\nobtains p where \"p \\<notin> P\"", "lemma getFresh:\nassumes \"finite P\" shows \"getFresh P \\<notin> P\"", "lemma eqOn_Un[simp]:\n\"eqOn (P \\<union> Q) env env1 \\<longleftrightarrow> eqOn P env env1 \\<and> eqOn Q env env1\"", "lemma eqOn_update[simp]:\n\"eqOn P (env(p := \\<pi>)) (env1(p := \\<pi>)) \\<longleftrightarrow> eqOn (P - {p}) env env1\"", "lemma eqOn_singl[simp]:\n\"eqOn {p} env env1 \\<longleftrightarrow> env p = env1 p\"", "lemma sem_Exi_explicit:\n\"sem (Exi p \\<phi>) env \\<pi>l \\<longleftrightarrow>\n (\\<exists> \\<pi>. wfp AP' \\<pi> \\<and> stateOf \\<pi> = (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n       sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\"", "lemma sem_derived[simp]:\n \"sem Tr env = tr\"\n \"sem (Con \\<phi> \\<psi>) env = con (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Imp \\<phi> \\<psi>) env = imp (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Eq \\<phi> \\<psi>) env = eq (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Fall p \\<phi>) env = fall (\\<lambda> \\<pi> \\<pi>l. sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\"\n \"sem (Ev \\<phi>) env = ev (sem \\<phi> env)\"\n \"sem (Alw \\<phi>) env = alw (sem \\<phi> env)\"\n \"sem (Wuntil \\<phi> \\<psi>) env = wuntil (sem \\<phi> env) (sem \\<psi> env)\"", "lemma sem_Fall2[simp]:\n\"sem (Fall2 p p' \\<phi>) env =\n fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. sem \\<phi> (env (p := length \\<pi>l, p' := Suc(length \\<pi>l))) (\\<pi>l @ [\\<pi>,\\<pi>']))\"", "lemma cpt_Un[simp]:\n\"cpt (P \\<union> Q) env \\<pi>l \\<longleftrightarrow> cpt P env \\<pi>l \\<and> cpt Q env \\<pi>l\"", "lemma cpt_singl[simp]:\n\"cpt {p} env \\<pi>l \\<longleftrightarrow> env p < length \\<pi>l\"", "lemma cpt_map_stl[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map stl \\<pi>l)\"", "lemma eqOn_Un[simp]:\n\"eqOn (P \\<union> Q) env \\<pi>l env1 \\<pi>l1 \\<longleftrightarrow> eqOn P env \\<pi>l env1 \\<pi>l1 \\<and> eqOn Q env \\<pi>l env1 \\<pi>l1\"", "lemma eqOn_singl[simp]:\n\"eqOn {p} env \\<pi>l env1 \\<pi>l1 \\<longleftrightarrow> \\<pi>l!(env p) = \\<pi>l1!(env1 p)\"", "lemma eqOn_map_stl[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env1 \\<pi>l1 \\<Longrightarrow>\n eqOn P env \\<pi>l env1 \\<pi>l1 \\<Longrightarrow> eqOn P env (map stl \\<pi>l) env1 (map stl \\<pi>l1)\"", "lemma cpt_map_sdrop[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map (sdrop i) \\<pi>l)\"", "lemma cpt_update[simp]:\nassumes \"cpt (P - {p}) env \\<pi>l\"\nshows \"cpt P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\"", "lemma eqOn_map_sdrop[simp]:\n\"cpt V env \\<pi>l \\<Longrightarrow> cpt V env1 \\<pi>l1 \\<Longrightarrow>\n eqOn V env \\<pi>l env1 \\<pi>l1 \\<Longrightarrow> eqOn V env (map (sdrop i) \\<pi>l) env1 (map (sdrop i) \\<pi>l1)\"", "lemma eqOn_update[simp]:\nassumes \"cpt (P - {p}) env \\<pi>l\" and \"cpt (P - {p}) env1 \\<pi>l1\"\nshows\n\"eqOn P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n \\<longleftrightarrow>\n eqOn (P - {p}) env \\<pi>l env1 \\<pi>l1\"", "lemma eqOn_FV_sem_NE:\nassumes \"cpt (FV \\<phi>) env \\<pi>l\" and \"cpt (FV \\<phi>) env1 \\<pi>l1\" and \"eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\"\nand \"\\<pi>l \\<noteq> []\" and \"\\<pi>l1 \\<noteq> []\" and \"last \\<pi>l = last \\<pi>l1\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1\"", "theorem eqOn_FV_sem:\nassumes \"wff \\<phi>\" and \"pointerOf \\<pi>l = pointerOf \\<pi>l1\"\nand \"cpt (FV \\<phi>) env \\<pi>l\" and \"cpt (FV \\<phi>) env1 \\<pi>l1\" and \"eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1\"", "lemma semClosed:\nassumes \\<phi>: \"wff \\<phi>\" \"FV \\<phi> = {}\" and p: \"pointerOf \\<pi>l = s0\"\nshows \"semClosed \\<phi> = sem \\<phi> env \\<pi>l\"", "lemma semClosed_Nil:\nassumes \\<phi>: \"wff \\<phi>\" \"FV \\<phi> = {}\"\nshows \"semClosed \\<phi> = sem \\<phi> env []\"", "lemma sem_Scon[simp]:\nassumes \"finite \\<phi>s\"\nshows \"sem (Scon \\<phi>s) env = scon ((\\<lambda> \\<phi>. sem \\<phi> env) ` \\<phi>s)\"", "lemma FV_Scon[simp]:\nassumes \"finite \\<phi>s\"\nshows \"FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)\""], "translations": [["", "lemmas der_Op_defs =\nTr_def Con_def Imp_def Eq_def Ev_def Alw_def Wuntil_def Fall_def Fall2_def"], ["", "text\\<open>Well-formed formulas are those that do not have a temporal operator\noutside the scope of any quantifier -- indeed, in HyperCTL* such a situation does not make sense, \nsince the temporal operators refer to previously introduced/quantified paths.\\<close>"], ["", "primrec wff :: \"'aprop dfmla \\<Rightarrow> bool\" where\n \"wff (Atom a p) = True\"\n|\"wff Fls = True\"\n|\"wff (Neg \\<phi>) = wff \\<phi>\"\n|\"wff (Dis \\<phi> \\<psi>) = (wff \\<phi> \\<and> wff \\<psi>)\"\n|\"wff (Next \\<phi>) = False\"\n|\"wff (Until \\<phi> \\<psi>) = False\"\n|\"wff (Exi p \\<phi>) = True\""], ["", "text \\<open>The ability to pick a fresh variable\\<close>"], ["", "lemma finite_fresh_pvar:\nassumes \"finite (P :: pvar set)\"\nobtains p where \"p \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<notin> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<notin> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"finite (natOf ` P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (natOf ` P)", "by (metis assms finite_imageI)"], ["proof (state)\nthis:\n  finite (natOf ` P)\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<notin> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite (natOf ` P)", "obtain n where \"n \\<notin> natOf ` P\""], ["proof (prove)\nusing this:\n  finite (natOf ` P)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        n \\<notin> natOf ` P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis unbounded_k_infinite)"], ["proof (state)\nthis:\n  n \\<notin> natOf ` P\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<notin> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"Pvariable n \\<notin> P\""], ["proof (prove)\nusing this:\n  n \\<notin> natOf ` P\n\ngoal (1 subgoal):\n 1. Pvariable n \\<notin> P", "by (metis imageI pvar.sel)"], ["proof (state)\nthis:\n  Pvariable n \\<notin> P\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<notin> P \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  Pvariable n \\<notin> P\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  Pvariable n \\<notin> P\n  ?p \\<notin> P \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition getFresh :: \"pvar set \\<Rightarrow> pvar\" where\n\"getFresh P \\<equiv> SOME p. p \\<notin> P\""], ["", "lemma getFresh:\nassumes \"finite P\" shows \"getFresh P \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getFresh P \\<notin> P", "by (metis assms exE_some finite_fresh_pvar getFresh_def)"], ["", "text \\<open>The free-variables operator\\<close>"], ["", "primrec FV :: \"'aprop dfmla \\<Rightarrow> pvar set\" where\n \"FV (Atom a p) = {p}\"\n|\"FV Fls = {}\"\n|\"FV (Neg \\<phi>) = FV \\<phi>\"\n|\"FV (Dis \\<phi> \\<psi>) = FV \\<phi> \\<union> FV \\<psi>\"\n|\"FV (Next \\<phi>) = FV \\<phi>\"\n|\"FV (Until \\<phi> \\<psi>) = FV \\<phi> \\<union> FV \\<psi>\"\n|\"FV (Exi p \\<phi>) = FV \\<phi> - {p}\""], ["", "text\\<open>Environments\\<close>"], ["", "type_synonym env = \"pvar \\<Rightarrow> nat\""], ["", "definition \"eqOn P env env1 \\<equiv> \\<forall> p. p \\<in> P \\<longrightarrow> env p = env1 p\""], ["", "lemma eqOn_Un[simp]:\n\"eqOn (P \\<union> Q) env env1 \\<longleftrightarrow> eqOn P env env1 \\<and> eqOn Q env env1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqOn (P \\<union> Q) env env1 = (eqOn P env env1 \\<and> eqOn Q env env1)", "unfolding eqOn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. p \\<in> P \\<union> Q \\<longrightarrow> env p = env1 p) =\n    ((\\<forall>p. p \\<in> P \\<longrightarrow> env p = env1 p) \\<and>\n     (\\<forall>p. p \\<in> Q \\<longrightarrow> env p = env1 p))", "by auto"], ["", "lemma eqOn_update[simp]:\n\"eqOn P (env(p := \\<pi>)) (env1(p := \\<pi>)) \\<longleftrightarrow> eqOn (P - {p}) env env1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqOn P (env(p := \\<pi>)) (env1(p := \\<pi>)) = eqOn (P - {p}) env env1", "unfolding eqOn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pa.\n        pa \\<in> P \\<longrightarrow>\n        (env(p := \\<pi>)) pa = (env1(p := \\<pi>)) pa) =\n    (\\<forall>pa. pa \\<in> P - {p} \\<longrightarrow> env pa = env1 pa)", "by auto"], ["", "lemma eqOn_singl[simp]:\n\"eqOn {p} env env1 \\<longleftrightarrow> env p = env1 p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqOn {p} env env1 = (env p = env1 p)", "unfolding eqOn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pa. pa \\<in> {p} \\<longrightarrow> env pa = env1 pa) =\n    (env p = env1 p)", "by auto"], ["", "context Shallow\nbegin"], ["", "subsection \\<open>The semantic operator\\<close>"], ["", "text\\<open>The semantics will interpret deep (syntactic) formulas as shallow formulas.\nRecall that the latter are predicates on lists of paths -- the interpretation will\nbe parameterized by an environment mapping each path variable to a number indicating\nthe index (in the list) for the path denoted by the variable.\n\nThe semantics will only\nbe meaningful if the indexes of a formula's free variables are smaller than the length\nof the path list -- we call this property ``compatibility''.\\<close>"], ["", "primrec sem :: \"'aprop dfmla \\<Rightarrow> env \\<Rightarrow> ('state,'aprop) sfmla\" where\n \"sem (Atom a p) env = atom a (env p)\"\n|\"sem Fls env = fls\"\n|\"sem (Neg \\<phi>) env = neg (sem \\<phi> env)\"\n|\"sem (Dis \\<phi> \\<psi>) env = dis (sem \\<phi> env) (sem \\<psi> env)\"\n|\"sem (Next \\<phi>) env = next (sem \\<phi> env)\"\n|\"sem (Until \\<phi> \\<psi>) env = until (sem \\<phi> env) (sem \\<psi> env)\"\n|\"sem (Exi p \\<phi>) env = exi (\\<lambda> \\<pi> \\<pi>l. sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\""], ["", "lemma sem_Exi_explicit:\n\"sem (Exi p \\<phi>) env \\<pi>l \\<longleftrightarrow>\n (\\<exists> \\<pi>. wfp AP' \\<pi> \\<and> stateOf \\<pi> = (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n       sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem (Exi p \\<phi>) env \\<pi>l =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))", "unfolding sem.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. exi (\\<lambda>\\<pi> \\<pi>l.\n            sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\n     \\<pi>l =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))", "unfolding exi_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))", ".."], ["", "lemma sem_derived[simp]:\n \"sem Tr env = tr\"\n \"sem (Con \\<phi> \\<psi>) env = con (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Imp \\<phi> \\<psi>) env = imp (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Eq \\<phi> \\<psi>) env = eq (sem \\<phi> env) (sem \\<psi> env)\"\n \"sem (Fall p \\<phi>) env = fall (\\<lambda> \\<pi> \\<pi>l. sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]))\"\n \"sem (Ev \\<phi>) env = ev (sem \\<phi> env)\"\n \"sem (Alw \\<phi>) env = alw (sem \\<phi> env)\"\n \"sem (Wuntil \\<phi> \\<psi>) env = wuntil (sem \\<phi> env) (sem \\<psi> env)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sem Tr env = tr &&&\n      sem (Con \\<phi> \\<psi>) env =\n      con (sem \\<phi> env) (sem \\<psi> env)) &&&\n     sem (Imp \\<phi> \\<psi>) env = imp (sem \\<phi> env) (sem \\<psi> env) &&&\n     sem (Eq \\<phi> \\<psi>) env = eq (sem \\<phi> env) (sem \\<psi> env)) &&&\n    (sem (Fall p \\<phi>) env =\n     fall\n      (\\<lambda>\\<pi> \\<pi>l.\n          sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) &&&\n     sem (Ev \\<phi>) env = ev (sem \\<phi> env)) &&&\n    sem (Alw \\<phi>) env = alw (sem \\<phi> env) &&&\n    sem (Wuntil \\<phi> \\<psi>) env =\n    wuntil (sem \\<phi> env) (sem \\<psi> env)", "unfolding der_Op_defs der_op_defs"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((sem (Neg Fls) env = neg fls &&&\n      sem (Neg (Dis (Neg \\<phi>) (Neg \\<psi>))) env =\n      neg (dis (neg (sem \\<phi> env)) (neg (sem \\<psi> env)))) &&&\n     sem (Dis (Neg \\<phi>) \\<psi>) env =\n     dis (neg (sem \\<phi> env)) (sem \\<psi> env) &&&\n     sem (Neg (Dis (Neg (Dis (Neg \\<phi>) \\<psi>))\n                (Neg (Dis (Neg \\<psi>) \\<phi>))))\n      env =\n     neg (dis (neg (dis (neg (sem \\<phi> env)) (sem \\<psi> env)))\n           (neg (dis (neg (sem \\<psi> env)) (sem \\<phi> env))))) &&&\n    (sem (Neg (Exi p (Neg \\<phi>))) env =\n     neg (exi (\\<lambda>\\<pi>.\n                  neg (\\<lambda>\\<pi>l.\n                          sem \\<phi> (env(p := length \\<pi>l))\n                           (\\<pi>l @ [\\<pi>])))) &&&\n     sem (Until (Neg Fls) \\<phi>) env =\n     until (neg fls) (sem \\<phi> env)) &&&\n    sem (Neg (Until (Neg Fls) (Neg \\<phi>))) env =\n    neg (until (neg fls) (neg (sem \\<phi> env))) &&&\n    sem (Dis (Until \\<phi> \\<psi>) (Neg (Until (Neg Fls) (Neg \\<phi>))))\n     env =\n    dis (until (sem \\<phi> env) (sem \\<psi> env))\n     (neg (until (neg fls) (neg (sem \\<phi> env))))", "by (auto simp: neg_def[abs_def])"], ["", "lemma sem_Fall2[simp]:\n\"sem (Fall2 p p' \\<phi>) env =\n fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. sem \\<phi> (env (p := length \\<pi>l, p' := Suc(length \\<pi>l))) (\\<pi>l @ [\\<pi>,\\<pi>']))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem (Fall2 p p' \\<phi>) env =\n    fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         sem \\<phi> (env(p := length \\<pi>l, p' := Suc (length \\<pi>l)))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))", "unfolding Fall2_def fall2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sem (Fall p (Fall p' \\<phi>)) env =\n    fall\n     (\\<lambda>\\<pi>.\n         fall\n          (\\<lambda>\\<pi>' \\<pi>l.\n              sem \\<phi>\n               (env(p := length \\<pi>l, p' := Suc (length \\<pi>l)))\n               (\\<pi>l @ [\\<pi>', \\<pi>])))", "by (auto simp add: fall_def exi_def[abs_def] neg_def[abs_def])"], ["", "text\\<open>Compatibility of a pair (environment,path list) on a set of variables means\nno out-or-range references:\\<close>"], ["", "definition \"cpt P env \\<pi>l \\<equiv> \\<forall> p \\<in> P. env p < length \\<pi>l\""], ["", "lemma cpt_Un[simp]:\n\"cpt (P \\<union> Q) env \\<pi>l \\<longleftrightarrow> cpt P env \\<pi>l \\<and> cpt Q env \\<pi>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpt (P \\<union> Q) env \\<pi>l =\n    (cpt P env \\<pi>l \\<and> cpt Q env \\<pi>l)", "unfolding cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>P \\<union> Q. env p < length \\<pi>l) =\n    ((\\<forall>p\\<in>P. env p < length \\<pi>l) \\<and>\n     (\\<forall>p\\<in>Q. env p < length \\<pi>l))", "by auto"], ["", "lemma cpt_singl[simp]:\n\"cpt {p} env \\<pi>l \\<longleftrightarrow> env p < length \\<pi>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpt {p} env \\<pi>l = (env p < length \\<pi>l)", "unfolding cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p\\<in>{p}. env p < length \\<pi>l) = (env p < length \\<pi>l)", "by auto"], ["", "lemma cpt_map_stl[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map stl \\<pi>l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map stl \\<pi>l)", "unfolding cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>P. env p < length \\<pi>l \\<Longrightarrow>\n    \\<forall>p\\<in>P. env p < length (map stl \\<pi>l)", "by auto"], ["", "text \\<open>Next we prove that the semantics of well-formed formulas only depends on the interpretation\nof the free variables of a formula and on the current state of the last recorded path --\nwe call the latter the ``pointer'' of the path list.\\<close>"], ["", "fun pointerOf :: \"('state,'aprop) path list \\<Rightarrow> 'state\" where\n\"pointerOf \\<pi>l = (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0)\""], ["", "text\\<open>Equality of two pairs (environment,path list) on a set of variables:\\<close>"], ["", "definition eqOn ::\n\"pvar set \\<Rightarrow> env \\<Rightarrow> ('state,'aprop) path list \\<Rightarrow> env \\<Rightarrow> ('state,'aprop) path list \\<Rightarrow> bool\"\nwhere\n\"eqOn P env \\<pi>l env1 \\<pi>l1 \\<equiv> \\<forall> p. p \\<in> P \\<longrightarrow> \\<pi>l!(env p) = \\<pi>l1!(env1 p)\""], ["", "lemma eqOn_Un[simp]:\n\"eqOn (P \\<union> Q) env \\<pi>l env1 \\<pi>l1 \\<longleftrightarrow> eqOn P env \\<pi>l env1 \\<pi>l1 \\<and> eqOn Q env \\<pi>l env1 \\<pi>l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.eqOn (P \\<union> Q) env \\<pi>l env1 \\<pi>l1 =\n    (local.eqOn P env \\<pi>l env1 \\<pi>l1 \\<and>\n     local.eqOn Q env \\<pi>l env1 \\<pi>l1)", "unfolding eqOn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p.\n        p \\<in> P \\<union> Q \\<longrightarrow>\n        \\<pi>l ! env p = \\<pi>l1 ! env1 p) =\n    ((\\<forall>p.\n         p \\<in> P \\<longrightarrow>\n         \\<pi>l ! env p = \\<pi>l1 ! env1 p) \\<and>\n     (\\<forall>p.\n         p \\<in> Q \\<longrightarrow> \\<pi>l ! env p = \\<pi>l1 ! env1 p))", "by auto"], ["", "lemma eqOn_singl[simp]:\n\"eqOn {p} env \\<pi>l env1 \\<pi>l1 \\<longleftrightarrow> \\<pi>l!(env p) = \\<pi>l1!(env1 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.eqOn {p} env \\<pi>l env1 \\<pi>l1 =\n    (\\<pi>l ! env p = \\<pi>l1 ! env1 p)", "unfolding eqOn_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pa.\n        pa \\<in> {p} \\<longrightarrow>\n        \\<pi>l ! env pa = \\<pi>l1 ! env1 pa) =\n    (\\<pi>l ! env p = \\<pi>l1 ! env1 p)", "by auto"], ["", "lemma eqOn_map_stl[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env1 \\<pi>l1 \\<Longrightarrow>\n eqOn P env \\<pi>l env1 \\<pi>l1 \\<Longrightarrow> eqOn P env (map stl \\<pi>l) env1 (map stl \\<pi>l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cpt P env \\<pi>l; cpt P env1 \\<pi>l1;\n     local.eqOn P env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n    \\<Longrightarrow> local.eqOn P env (map stl \\<pi>l) env1\n                       (map stl \\<pi>l1)", "unfolding eqOn_def cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p\\<in>P. env p < length \\<pi>l;\n     \\<forall>p\\<in>P. env1 p < length \\<pi>l1;\n     \\<forall>p.\n        p \\<in> P \\<longrightarrow>\n        \\<pi>l ! env p = \\<pi>l1 ! env1 p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         p \\<in> P \\<longrightarrow>\n                         map stl \\<pi>l ! env p = map stl \\<pi>l1 ! env1 p", "by auto"], ["", "lemma cpt_map_sdrop[simp]:\n\"cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map (sdrop i) \\<pi>l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpt P env \\<pi>l \\<Longrightarrow> cpt P env (map (sdrop i) \\<pi>l)", "unfolding cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>P. env p < length \\<pi>l \\<Longrightarrow>\n    \\<forall>p\\<in>P. env p < length (map (sdrop i) \\<pi>l)", "by auto"], ["", "lemma cpt_update[simp]:\nassumes \"cpt (P - {p}) env \\<pi>l\"\nshows \"cpt P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cpt P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])", "using assms"], ["proof (prove)\nusing this:\n  cpt (P - {p}) env \\<pi>l\n\ngoal (1 subgoal):\n 1. cpt P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])", "unfolding cpt_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>P - {p}. env p < length \\<pi>l\n\ngoal (1 subgoal):\n 1. \\<forall>pa\\<in>P.\n       (env(p := length \\<pi>l)) pa < length (\\<pi>l @ [\\<pi>])", "by simp (metis Diff_iff less_SucI singleton_iff)"], ["", "lemma eqOn_map_sdrop[simp]:\n\"cpt V env \\<pi>l \\<Longrightarrow> cpt V env1 \\<pi>l1 \\<Longrightarrow>\n eqOn V env \\<pi>l env1 \\<pi>l1 \\<Longrightarrow> eqOn V env (map (sdrop i) \\<pi>l) env1 (map (sdrop i) \\<pi>l1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cpt V env \\<pi>l; cpt V env1 \\<pi>l1;\n     local.eqOn V env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n    \\<Longrightarrow> local.eqOn V env (map (sdrop i) \\<pi>l) env1\n                       (map (sdrop i) \\<pi>l1)", "unfolding eqOn_def cpt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p\\<in>V. env p < length \\<pi>l;\n     \\<forall>p\\<in>V. env1 p < length \\<pi>l1;\n     \\<forall>p.\n        p \\<in> V \\<longrightarrow>\n        \\<pi>l ! env p = \\<pi>l1 ! env1 p\\<rbrakk>\n    \\<Longrightarrow> \\<forall>p.\n                         p \\<in> V \\<longrightarrow>\n                         map (sdrop i) \\<pi>l ! env p =\n                         map (sdrop i) \\<pi>l1 ! env1 p", "by auto"], ["", "lemma eqOn_update[simp]:\nassumes \"cpt (P - {p}) env \\<pi>l\" and \"cpt (P - {p}) env1 \\<pi>l1\"\nshows\n\"eqOn P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n \\<longleftrightarrow>\n eqOn (P - {p}) env \\<pi>l env1 \\<pi>l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.eqOn P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n     (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]) =\n    local.eqOn (P - {p}) env \\<pi>l env1 \\<pi>l1", "using assms"], ["proof (prove)\nusing this:\n  cpt (P - {p}) env \\<pi>l\n  cpt (P - {p}) env1 \\<pi>l1\n\ngoal (1 subgoal):\n 1. local.eqOn P (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n     (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]) =\n    local.eqOn (P - {p}) env \\<pi>l env1 \\<pi>l1", "unfolding eqOn_def cpt_def"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>P - {p}. env p < length \\<pi>l\n  \\<forall>p\\<in>P - {p}. env1 p < length \\<pi>l1\n\ngoal (1 subgoal):\n 1. (\\<forall>pa.\n        pa \\<in> P \\<longrightarrow>\n        (\\<pi>l @ [\\<pi>]) ! (env(p := length \\<pi>l)) pa =\n        (\\<pi>l1 @ [\\<pi>]) ! (env1(p := length \\<pi>l1)) pa) =\n    (\\<forall>pa.\n        pa \\<in> P - {p} \\<longrightarrow>\n        \\<pi>l ! env pa = \\<pi>l1 ! env1 pa)", "by simp (metis DiffI nth_append singleton_iff)"], ["", "lemma eqOn_FV_sem_NE:\nassumes \"cpt (FV \\<phi>) env \\<pi>l\" and \"cpt (FV \\<phi>) env1 \\<pi>l1\" and \"eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\"\nand \"\\<pi>l \\<noteq> []\" and \"\\<pi>l1 \\<noteq> []\" and \"last \\<pi>l = last \\<pi>l1\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1", "using assms"], ["proof (prove)\nusing this:\n  cpt (FV \\<phi>) env \\<pi>l\n  cpt (FV \\<phi>) env1 \\<pi>l1\n  local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1", "proof (induction \\<phi> arbitrary: env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "case (Until \\<phi> \\<psi> env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\nthis:\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "hence \"\\<And> i. sem \\<phi> env (map (sdrop i) \\<pi>l) = sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n              sem \\<psi> env (map (sdrop i) \\<pi>l) = sem \\<psi> env1 (map (sdrop i) \\<pi>l1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       sem \\<phi> env (map (sdrop i) \\<pi>l) =\n       sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n       sem \\<psi> env (map (sdrop i) \\<pi>l) =\n       sem \\<psi> env1 (map (sdrop i) \\<pi>l1)", "using Until"], ["proof (prove)\nusing this:\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       sem \\<phi> env (map (sdrop i) \\<pi>l) =\n       sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n       sem \\<psi> env (map (sdrop i) \\<pi>l) =\n       sem \\<psi> env1 (map (sdrop i) \\<pi>l1)", "by (auto simp: last_map)"], ["proof (state)\nthis:\n  sem \\<phi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<phi> env1 (map (sdrop ?i) \\<pi>l1) \\<and>\n  sem \\<psi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<psi> env1 (map (sdrop ?i) \\<pi>l1)\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "thus ?case"], ["proof (prove)\nusing this:\n  sem \\<phi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<phi> env1 (map (sdrop ?i) \\<pi>l1) \\<and>\n  sem \\<psi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<psi> env1 (map (sdrop ?i) \\<pi>l1)\n\ngoal (1 subgoal):\n 1. sem (Until \\<phi> \\<psi>) env \\<pi>l =\n    sem (Until \\<phi> \\<psi>) env1 \\<pi>l1", "by (auto simp: op_defs)"], ["proof (state)\nthis:\n  sem (Until \\<phi> \\<psi>) env \\<pi>l =\n  sem (Until \\<phi> \\<psi>) env1 \\<pi>l1\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "case (Exi p \\<phi> env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\nthis:\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "hence 1:\n  \"\\<And> \\<pi>. cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) \\<and>\n         cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]) \\<and>\n         eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\""], ["proof (prove)\nusing this:\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) \\<and>\n       cpt (FV \\<phi>) (env1(p := length \\<pi>l1))\n        (\\<pi>l1 @ [\\<pi>]) \\<and>\n       local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n        (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])", "by simp_all"], ["proof (state)\nthis:\n  cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) \\<and>\n  cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>]) \\<and>\n  local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>])\n   (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "thus ?case"], ["proof (prove)\nusing this:\n  cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) \\<and>\n  cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>]) \\<and>\n  local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>])\n   (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (1 subgoal):\n 1. sem (Exi p \\<phi>) env \\<pi>l = sem (Exi p \\<phi>) env1 \\<pi>l1", "unfolding sem.simps exi_def"], ["proof (prove)\nusing this:\n  cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) \\<and>\n  cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>]) \\<and>\n  local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>])\n   (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l1 \\<noteq> [] then stateOf (last \\<pi>l1) else s0) \\<and>\n        sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]))", "using Exi"], ["proof (prove)\nusing this:\n  cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) \\<and>\n  cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>]) \\<and>\n  local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>])\n   (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n  \\<lbrakk>cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0;\n   ?\\<pi>l \\<noteq> []; ?\\<pi>l1.0 \\<noteq> [];\n   last ?\\<pi>l = last ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n  \\<pi>l \\<noteq> []\n  \\<pi>l1 \\<noteq> []\n  last \\<pi>l = last \\<pi>l1\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l1 \\<noteq> [] then stateOf (last \\<pi>l1) else s0) \\<and>\n        sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]))", "by (intro iff_exI) (metis append_is_Nil_conv last_snoc)"], ["proof (state)\nthis:\n  sem (Exi p \\<phi>) env \\<pi>l = sem (Exi p \\<phi>) env1 \\<pi>l1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1; \\<pi>l \\<noteq> [];\n        \\<pi>l1 \\<noteq> []; last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>cpt (FV \\<phi>2) env \\<pi>l;\n            cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1;\n            \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n            last \\<pi>l = last \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1;\n                    \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n                    last \\<pi>l = last \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1;\n        \\<pi>l \\<noteq> []; \\<pi>l1 \\<noteq> [];\n        last \\<pi>l = last \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1", "qed(auto simp: last_map op_defs)"], ["", "text\\<open>The next theorem states that the semantics of a formula on an environment\nand a list of paths only depends on the pointer of the list of paths.\n\\<close>"], ["", "theorem eqOn_FV_sem:\nassumes \"wff \\<phi>\" and \"pointerOf \\<pi>l = pointerOf \\<pi>l1\"\nand \"cpt (FV \\<phi>) env \\<pi>l\" and \"cpt (FV \\<phi>) env1 \\<pi>l1\" and \"eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1", "using assms"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV \\<phi>) env \\<pi>l\n  cpt (FV \\<phi>) env1 \\<pi>l1\n  local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\n\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1", "proof (induction \\<phi> arbitrary: env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Until \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "case (Until \\<phi> \\<psi> env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\nthis:\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>wff \\<psi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  wff (Until \\<phi> \\<psi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Until \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "hence \"\\<And> i. sem \\<phi> env (map (sdrop i) \\<pi>l) = sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n              sem \\<psi> env (map (sdrop i) \\<pi>l) = sem \\<psi> env1 (map (sdrop i) \\<pi>l1)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>wff \\<psi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  wff (Until \\<phi> \\<psi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       sem \\<phi> env (map (sdrop i) \\<pi>l) =\n       sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n       sem \\<psi> env (map (sdrop i) \\<pi>l) =\n       sem \\<psi> env1 (map (sdrop i) \\<pi>l1)", "using Until"], ["proof (prove)\nusing this:\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>wff \\<psi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  wff (Until \\<phi> \\<psi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  \\<lbrakk>wff \\<psi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<psi>) ?env ?\\<pi>l; cpt (FV \\<psi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<psi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<psi> ?env ?\\<pi>l = sem \\<psi> ?env1.0 ?\\<pi>l1.0\n  wff (Until \\<phi> \\<psi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Until \\<phi> \\<psi>)) env \\<pi>l\n  cpt (FV (Until \\<phi> \\<psi>)) env1 \\<pi>l1\n  local.eqOn (FV (Until \\<phi> \\<psi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       sem \\<phi> env (map (sdrop i) \\<pi>l) =\n       sem \\<phi> env1 (map (sdrop i) \\<pi>l1) \\<and>\n       sem \\<psi> env (map (sdrop i) \\<pi>l) =\n       sem \\<psi> env1 (map (sdrop i) \\<pi>l1)", "by (auto simp: last_map)"], ["proof (state)\nthis:\n  sem \\<phi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<phi> env1 (map (sdrop ?i) \\<pi>l1) \\<and>\n  sem \\<psi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<psi> env1 (map (sdrop ?i) \\<pi>l1)\n\ngoal (7 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Until \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Until \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Until \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Until \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Until \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 7. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "thus ?case"], ["proof (prove)\nusing this:\n  sem \\<phi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<phi> env1 (map (sdrop ?i) \\<pi>l1) \\<and>\n  sem \\<psi> env (map (sdrop ?i) \\<pi>l) =\n  sem \\<psi> env1 (map (sdrop ?i) \\<pi>l1)\n\ngoal (1 subgoal):\n 1. sem (Until \\<phi> \\<psi>) env \\<pi>l =\n    sem (Until \\<phi> \\<psi>) env1 \\<pi>l1", "by (auto simp: op_defs)"], ["proof (state)\nthis:\n  sem (Until \\<phi> \\<psi>) env \\<pi>l =\n  sem (Until \\<phi> \\<psi>) env1 \\<pi>l1\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "case (Exi p \\<phi> env \\<pi>l env1 \\<pi>l1)"], ["proof (state)\nthis:\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  wff (Exi p \\<phi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "have \"\\<And> \\<pi>. sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) =\n             sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>]) =\n       sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])", "apply(rule eqOn_FV_sem_NE)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>\\<pi>.\n       cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n 2. \\<And>\\<pi>.\n       cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n 3. \\<And>\\<pi>.\n       local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n        (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n 4. \\<And>\\<pi>. \\<pi>l @ [\\<pi>] \\<noteq> []\n 5. \\<And>\\<pi>. \\<pi>l1 @ [\\<pi>] \\<noteq> []\n 6. \\<And>\\<pi>. last (\\<pi>l @ [\\<pi>]) = last (\\<pi>l1 @ [\\<pi>])", "using Exi"], ["proof (prove)\nusing this:\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  wff (Exi p \\<phi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (6 subgoals):\n 1. \\<And>\\<pi>.\n       cpt (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n 2. \\<And>\\<pi>.\n       cpt (FV \\<phi>) (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n 3. \\<And>\\<pi>.\n       local.eqOn (FV \\<phi>) (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])\n        (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>])\n 4. \\<And>\\<pi>. \\<pi>l @ [\\<pi>] \\<noteq> []\n 5. \\<And>\\<pi>. \\<pi>l1 @ [\\<pi>] \\<noteq> []\n 6. \\<And>\\<pi>. last (\\<pi>l @ [\\<pi>]) = last (\\<pi>l1 @ [\\<pi>])", "by auto"], ["proof (state)\nthis:\n  sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) =\n  sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (6 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1\n 6. \\<And>x1 \\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Exi x1 \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Exi x1 \\<phi>)) env \\<pi>l;\n        cpt (FV (Exi x1 \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Exi x1 \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Exi x1 \\<phi>) env \\<pi>l =\n                         sem (Exi x1 \\<phi>) env1 \\<pi>l1", "thus ?case"], ["proof (prove)\nusing this:\n  sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) =\n  sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (1 subgoal):\n 1. sem (Exi p \\<phi>) env \\<pi>l = sem (Exi p \\<phi>) env1 \\<pi>l1", "unfolding sem.simps exi_def"], ["proof (prove)\nusing this:\n  sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) =\n  sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l1 \\<noteq> [] then stateOf (last \\<pi>l1) else s0) \\<and>\n        sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]))", "using Exi"], ["proof (prove)\nusing this:\n  sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [?\\<pi>]) =\n  sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [?\\<pi>])\n  \\<lbrakk>wff \\<phi>; pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0;\n   cpt (FV \\<phi>) ?env ?\\<pi>l; cpt (FV \\<phi>) ?env1.0 ?\\<pi>l1.0;\n   local.eqOn (FV \\<phi>) ?env ?\\<pi>l ?env1.0 ?\\<pi>l1.0\\<rbrakk>\n  \\<Longrightarrow> sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  wff (Exi p \\<phi>)\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n  cpt (FV (Exi p \\<phi>)) env \\<pi>l\n  cpt (FV (Exi p \\<phi>)) env1 \\<pi>l1\n  local.eqOn (FV (Exi p \\<phi>)) env \\<pi>l env1 \\<pi>l1\n\ngoal (1 subgoal):\n 1. (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l \\<noteq> [] then stateOf (last \\<pi>l) else s0) \\<and>\n        sem \\<phi> (env(p := length \\<pi>l)) (\\<pi>l @ [\\<pi>])) =\n    (\\<exists>\\<pi>.\n        wfp AP' \\<pi> \\<and>\n        stateOf \\<pi> =\n        (if \\<pi>l1 \\<noteq> [] then stateOf (last \\<pi>l1) else s0) \\<and>\n        sem \\<phi> (env1(p := length \\<pi>l1)) (\\<pi>l1 @ [\\<pi>]))", "by (intro iff_exI conj_cong) simp_all"], ["proof (state)\nthis:\n  sem (Exi p \\<phi>) env \\<pi>l = sem (Exi p \\<phi>) env1 \\<pi>l1\n\ngoal (5 subgoals):\n 1. \\<And>x1 x2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff (Atom x1 x2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Atom x1 x2)) env \\<pi>l;\n        cpt (FV (Atom x1 x2)) env1 \\<pi>l1;\n        local.eqOn (FV (Atom x1 x2)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Atom x1 x2) env \\<pi>l =\n                         sem (Atom x1 x2) env1 \\<pi>l1\n 2. \\<And>env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>wff Fls; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV Fls) env \\<pi>l; cpt (FV Fls) env1 \\<pi>l1;\n        local.eqOn (FV Fls) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem Fls env \\<pi>l = sem Fls env1 \\<pi>l1\n 3. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Neg \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Neg \\<phi>)) env \\<pi>l;\n        cpt (FV (Neg \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Neg \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Neg \\<phi>) env \\<pi>l =\n                         sem (Neg \\<phi>) env1 \\<pi>l1\n 4. \\<And>\\<phi>1 \\<phi>2 env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>1;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>1) env \\<pi>l;\n                    cpt (FV \\<phi>1) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>1) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi>1 env \\<pi>l =\n                                     sem \\<phi>1 env1 \\<pi>l1;\n        \\<And>env \\<pi>l env1 \\<pi>l1.\n           \\<lbrakk>wff \\<phi>2; pointerOf \\<pi>l = pointerOf \\<pi>l1;\n            cpt (FV \\<phi>2) env \\<pi>l; cpt (FV \\<phi>2) env1 \\<pi>l1;\n            local.eqOn (FV \\<phi>2) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n           \\<Longrightarrow> sem \\<phi>2 env \\<pi>l =\n                             sem \\<phi>2 env1 \\<pi>l1;\n        wff (Dis \\<phi>1 \\<phi>2); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l;\n        cpt (FV (Dis \\<phi>1 \\<phi>2)) env1 \\<pi>l1;\n        local.eqOn (FV (Dis \\<phi>1 \\<phi>2)) env \\<pi>l env1\n         \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Dis \\<phi>1 \\<phi>2) env \\<pi>l =\n                         sem (Dis \\<phi>1 \\<phi>2) env1 \\<pi>l1\n 5. \\<And>\\<phi> env \\<pi>l env1 \\<pi>l1.\n       \\<lbrakk>\\<And>env \\<pi>l env1 \\<pi>l1.\n                   \\<lbrakk>wff \\<phi>;\n                    pointerOf \\<pi>l = pointerOf \\<pi>l1;\n                    cpt (FV \\<phi>) env \\<pi>l;\n                    cpt (FV \\<phi>) env1 \\<pi>l1;\n                    local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n                   \\<Longrightarrow> sem \\<phi> env \\<pi>l =\n                                     sem \\<phi> env1 \\<pi>l1;\n        wff (Next \\<phi>); pointerOf \\<pi>l = pointerOf \\<pi>l1;\n        cpt (FV (Next \\<phi>)) env \\<pi>l;\n        cpt (FV (Next \\<phi>)) env1 \\<pi>l1;\n        local.eqOn (FV (Next \\<phi>)) env \\<pi>l env1 \\<pi>l1\\<rbrakk>\n       \\<Longrightarrow> sem (Next \\<phi>) env \\<pi>l =\n                         sem (Next \\<phi>) env1 \\<pi>l1", "qed(auto simp: last_map op_defs)"], ["", "corollary FV_sem:\nassumes \"wff \\<phi>\" and \"\\<forall> p \\<in> FV \\<phi>. env p = env1 p\"\nand \"cpt (FV \\<phi>) env \\<pi>l\" and \"cpt (FV \\<phi>) env1 \\<pi>l\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l", "apply(rule eqOn_FV_sem)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l\n 3. cpt (FV \\<phi>) env \\<pi>l\n 4. cpt (FV \\<phi>) env1 \\<pi>l\n 5. local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l", "using assms"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  \\<forall>p\\<in>FV \\<phi>. env p = env1 p\n  cpt (FV \\<phi>) env \\<pi>l\n  cpt (FV \\<phi>) env1 \\<pi>l\n\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l\n 3. cpt (FV \\<phi>) env \\<pi>l\n 4. cpt (FV \\<phi>) env1 \\<pi>l\n 5. local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l", "unfolding eqOn_def"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  \\<forall>p\\<in>FV \\<phi>. env p = env1 p\n  cpt (FV \\<phi>) env \\<pi>l\n  cpt (FV \\<phi>) env1 \\<pi>l\n\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l\n 3. cpt (FV \\<phi>) env \\<pi>l\n 4. cpt (FV \\<phi>) env1 \\<pi>l\n 5. \\<forall>p.\n       p \\<in> FV \\<phi> \\<longrightarrow> \\<pi>l ! env p = \\<pi>l ! env1 p", "by auto"], ["", "text\\<open>As a consequence, the interpretation of a closed formula (i.e., a formula\nwith no free variables) will not depend on the environment and, from the\nlist of paths, will only depend on its pointer:\\<close>"], ["", "corollary interp_closed:\nassumes \"wff \\<phi>\" and \"FV \\<phi> = {}\" and \"pointerOf \\<pi>l = pointerOf \\<pi>l1\"\nshows \"sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem \\<phi> env \\<pi>l = sem \\<phi> env1 \\<pi>l1", "apply(rule eqOn_FV_sem)"], ["proof (prove)\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l1\n 3. cpt (FV \\<phi>) env \\<pi>l\n 4. cpt (FV \\<phi>) env1 \\<pi>l1\n 5. local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1", "using assms"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  FV \\<phi> = {}\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l1\n 3. cpt (FV \\<phi>) env \\<pi>l\n 4. cpt (FV \\<phi>) env1 \\<pi>l1\n 5. local.eqOn (FV \\<phi>) env \\<pi>l env1 \\<pi>l1", "unfolding eqOn_def cpt_def"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  FV \\<phi> = {}\n  pointerOf \\<pi>l = pointerOf \\<pi>l1\n\ngoal (5 subgoals):\n 1. wff \\<phi>\n 2. pointerOf \\<pi>l = pointerOf \\<pi>l1\n 3. \\<forall>p\\<in>FV \\<phi>. env p < length \\<pi>l\n 4. \\<forall>p\\<in>FV \\<phi>. env1 p < length \\<pi>l1\n 5. \\<forall>p.\n       p \\<in> FV \\<phi> \\<longrightarrow> \\<pi>l ! env p = \\<pi>l1 ! env1 p", "by auto"], ["", "text\\<open>Therefore, it makes sense to define the interpretation of a closed formula\nby choosing any environment and any list of paths such that its pointer is the initial state\n(e.g., the empty list) -- knowing that the choices are irrelevant.\\<close>"], ["", "definition \"semClosed \\<phi> \\<equiv> sem \\<phi> (any::env) (SOME \\<pi>l. pointerOf \\<pi>l = s0)\""], ["", "lemma semClosed:\nassumes \\<phi>: \"wff \\<phi>\" \"FV \\<phi> = {}\" and p: \"pointerOf \\<pi>l = s0\"\nshows \"semClosed \\<phi> = sem \\<phi> env \\<pi>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env \\<pi>l", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env \\<pi>l", "have \"pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0", "by (rule someI[of _ \"[]\"]) simp"], ["proof (state)\nthis:\n  pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0\n\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env \\<pi>l", "thus ?thesis"], ["proof (prove)\nusing this:\n  pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0\n\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env \\<pi>l", "unfolding semClosed_def"], ["proof (prove)\nusing this:\n  pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0\n\ngoal (1 subgoal):\n 1. sem \\<phi> any (SOME \\<pi>l. pointerOf \\<pi>l = s0) =\n    sem \\<phi> env \\<pi>l", "using interp_closed[OF \\<phi>] p"], ["proof (prove)\nusing this:\n  pointerOf (SOME \\<pi>l. pointerOf \\<pi>l = s0) = s0\n  pointerOf ?\\<pi>l = pointerOf ?\\<pi>l1.0 \\<Longrightarrow>\n  sem \\<phi> ?env ?\\<pi>l = sem \\<phi> ?env1.0 ?\\<pi>l1.0\n  pointerOf \\<pi>l = s0\n\ngoal (1 subgoal):\n 1. sem \\<phi> any (SOME \\<pi>l. pointerOf \\<pi>l = s0) =\n    sem \\<phi> env \\<pi>l", "by auto"], ["proof (state)\nthis:\n  semClosed \\<phi> = sem \\<phi> env \\<pi>l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma semClosed_Nil:\nassumes \\<phi>: \"wff \\<phi>\" \"FV \\<phi> = {}\"\nshows \"semClosed \\<phi> = sem \\<phi> env []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env []", "using assms semClosed"], ["proof (prove)\nusing this:\n  wff \\<phi>\n  FV \\<phi> = {}\n  \\<lbrakk>wff ?\\<phi>; FV ?\\<phi> = {}; pointerOf ?\\<pi>l = s0\\<rbrakk>\n  \\<Longrightarrow> semClosed ?\\<phi> = sem ?\\<phi> ?env ?\\<pi>l\n\ngoal (1 subgoal):\n 1. semClosed \\<phi> = sem \\<phi> env []", "by auto"], ["", "subsection\\<open>The conjunction of a finite set of formulas\\<close>"], ["", "text\\<open>This is defined by making the set into a list (by choosing any ordering of the\nelements) and iterating binary conjunction.\\<close>"], ["", "definition Scon :: \"'aprop dfmla set \\<Rightarrow> 'aprop dfmla\" where\n\"Scon \\<phi>s \\<equiv> foldr Con (asList \\<phi>s) Tr\""], ["", "lemma sem_Scon[simp]:\nassumes \"finite \\<phi>s\"\nshows \"sem (Scon \\<phi>s) env = scon ((\\<lambda> \\<phi>. sem \\<phi> env) ` \\<phi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem (Scon \\<phi>s) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sem (Scon \\<phi>s) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "define \\<phi>l where \"\\<phi>l = asList \\<phi>s\""], ["proof (state)\nthis:\n  \\<phi>l = asList \\<phi>s\n\ngoal (1 subgoal):\n 1. sem (Scon \\<phi>s) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "have \"sem (foldr Con \\<phi>l Tr) env = scon ((\\<lambda> \\<phi>. sem \\<phi> env) ` (set \\<phi>l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sem (foldr Con \\<phi>l Tr) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` set \\<phi>l)", "by (induct \\<phi>l) (auto simp: scon_def)"], ["proof (state)\nthis:\n  sem (foldr Con \\<phi>l Tr) env =\n  scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` set \\<phi>l)\n\ngoal (1 subgoal):\n 1. sem (Scon \\<phi>s) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sem (foldr Con \\<phi>l Tr) env =\n  scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` set \\<phi>l)\n\ngoal (1 subgoal):\n 1. sem (Scon \\<phi>s) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "unfolding \\<phi>l_def Scon_def"], ["proof (prove)\nusing this:\n  sem (foldr Con (asList \\<phi>s) Tr) env =\n  scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` set (asList \\<phi>s))\n\ngoal (1 subgoal):\n 1. sem (foldr Con (asList \\<phi>s) Tr) env =\n    scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)", "by (metis assms set_asList)"], ["proof (state)\nthis:\n  sem (Scon \\<phi>s) env =\n  scon ((\\<lambda>\\<phi>. sem \\<phi> env) ` \\<phi>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma FV_Scon[simp]:\nassumes \"finite \\<phi>s\"\nshows \"FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)", "define \\<phi>l where \"\\<phi>l = asList \\<phi>s\""], ["proof (state)\nthis:\n  \\<phi>l = asList \\<phi>s\n\ngoal (1 subgoal):\n 1. FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)", "have \"FV (foldr Con \\<phi>l Tr) = \\<Union> (set (map FV \\<phi>l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FV (foldr Con \\<phi>l Tr) = \\<Union> (set (map FV \\<phi>l))", "by (induct \\<phi>l) (auto simp: der_Op_defs)"], ["proof (state)\nthis:\n  FV (foldr Con \\<phi>l Tr) = \\<Union> (set (map FV \\<phi>l))\n\ngoal (1 subgoal):\n 1. FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  FV (foldr Con \\<phi>l Tr) = \\<Union> (set (map FV \\<phi>l))\n\ngoal (1 subgoal):\n 1. FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)", "unfolding \\<phi>l_def Scon_def"], ["proof (prove)\nusing this:\n  FV (foldr Con (asList \\<phi>s) Tr) =\n  \\<Union> (set (map FV (asList \\<phi>s)))\n\ngoal (1 subgoal):\n 1. FV (foldr Con (asList \\<phi>s) Tr) = \\<Union> (FV ` \\<phi>s)", "by (metis assms set_map set_asList)"], ["proof (state)\nthis:\n  FV (Scon \\<phi>s) = \\<Union> (FV ` \\<phi>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(* context Shallow  *)\n(*>*)"], ["", "text\\<open>end-of-context Shallow\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}