{"file_name": "/home/qj213/afp-2021-10-22/thys/HyperCTL/Noninterference.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/HyperCTL", "problem_names": ["lemma purge_Nil[simp]: \"purge G [] = []\"\nand purge_Cons_in[simp]: \"u \\<notin> G \\<Longrightarrow> purge G ((u,c) # ucl) = (u,c) # purge G ucl\"\nand purge_Cons_notIn[simp]: \"u \\<in> G \\<Longrightarrow> purge G ((u,c) # ucl) = purge G ucl\"", "lemma purge_append:\n\"purge G (ucl1 @ ucl2) = purge G ucl1 @ purge G ucl2\"", "lemma toSink: \"s \\<in> S \\<Longrightarrow> toSink s \\<in> \\<delta> s \\<inter> Sink\"", "lemma fall2_imp_alw:\n\"fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l)) (\\<pi>l @ [\\<pi>,\\<pi>'])) []\n \\<longleftrightarrow>\n (\\<forall> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n           \\<longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>,\\<pi>']\n )\"", "lemma wfp_stateOf_shift_stake_sconst:\nfixes \\<pi> i\ndefines \"\\<pi>1 \\<equiv> shift (stake (Suc i) \\<pi>) (sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))\"\nassumes \\<pi>: \"wfp AP' \\<pi>\"\nshows \"wfp AP' \\<pi>1 \\<and> stateOf \\<pi>1 = stateOf \\<pi>\"", "lemma fall2_imp_alw_index:\nassumes 0: \"\\<And> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n                     \\<phi> [] [\\<pi>,\\<pi>'] = f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n                     \\<psi> [] [\\<pi>,\\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>')\"\nshows\n\"fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l)) (\\<pi>l @ [\\<pi>,\\<pi>'])) []\n \\<longleftrightarrow>\n (\\<forall> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n           \\<longrightarrow>\n           (\\<forall> i. (\\<forall> j \\<le> i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n )\"\n(is \"?L \\<longleftrightarrow> ?R\")", "lemma getGMUserCom[simp]: \"getGMUserCom (State st u c) = (u,c)\"", "lemma Last_in_L[simp]: \"Last u c \\<in> L s \\<longleftrightarrow> (\\<exists> st. s = State st u c)\"", "lemma Obs_in_L[simp]: \"Obs u ou \\<in> L s \\<longleftrightarrow> ou = out (getGMState s) u\"", "lemma f_id[simp,intro!]: \"f s s\"", "lemma apropsOf_L_stateOf[simp]:\n\"wfp AP' \\<pi> \\<Longrightarrow> apropsOf \\<pi> = L (stateOf \\<pi>)\"", "lemma eqOnUC_0_Suc0[simp]:\nassumes \"wfp AP' \\<pi>\" and \"wfp AP' \\<pi>'\"\nshows\n\"eqOnUC 0 (Suc 0) u c [\\<pi>, \\<pi>']\n \\<longleftrightarrow>\n ((\\<exists>st. stateOf \\<pi> = State st u c) =\n  (\\<exists>st'. stateOf \\<pi>' = State st' u c)\n )\"", "lemma eqOnUOut_0_Suc0[simp]:\nassumes \"wfp AP' \\<pi>\" and \"wfp AP' \\<pi>'\"\nshows\n\"eqOnUOut 0 (Suc 0) u ou [\\<pi>, \\<pi>']\n \\<longleftrightarrow>\n (ou = out (getGMState (stateOf \\<pi>)) u \\<longleftrightarrow>\n  ou = out (getGMState (stateOf \\<pi>')) u\n )\"", "lemma nonintSfmla_nonintSI: \"nonintSfmla [] \\<longleftrightarrow> nonintSI\"", "lemma wffp_induct2[consumes 1, case_names Singl Cons]:\nassumes \"wffp sl\"\nand \"\\<And> s. P [s]\"\nand \"\\<And> s sl. \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl; P sl\\<rbrakk> \\<Longrightarrow> P (s # sl)\"\nshows \"P sl\"", "lemma wffp_NE: assumes \"wffp sl\" shows \"sl \\<noteq> []\"", "lemma wffp:\n\"wffp sl \\<longleftrightarrow> sl \\<noteq> [] \\<and> (\\<forall> i. Suc i < length sl \\<longrightarrow> sl!(Suc i) \\<in> \\<delta>(sl!i))\"\n(is \"?L \\<longleftrightarrow> ?A \\<and> (\\<forall> i. ?R i)\")", "lemma wffp_hdI[intro]:\nassumes \"wffp sl\" and \"hd sl \\<in> \\<delta> s\"\nshows \"wffp (s # sl)\"", "lemma wffp_append:\nassumes sl: \"wffp sl\" and sl1: \"wffp sl1\" and h: \"hd sl1 \\<in> \\<delta> (last sl)\"\nshows \"wffp (sl @ sl1)\"", "lemma wffp_append_iff:\n\"wffp (sl @ sl1) \\<longleftrightarrow>\n (wffp sl \\<and> sl1 = []) \\<or>\n (sl = [] \\<and> wffp sl1) \\<or>\n (wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl))\"\n(is \"_ \\<longleftrightarrow> ?R\")", "lemma wffp_to_wfp:\nassumes \\<pi>_def: \"\\<pi> = map (\\<lambda> s. (s, L s)) sl @- sconst (toSink (last sl), L (toSink (last sl)))\"\nassumes sl: \"wffp sl\"\nshows\n\"wfp UNIV \\<pi> \\<and>\n (\\<forall> i < length sl. sl ! i = fst (\\<pi> !! i)) \\<and>\n (\\<forall> i \\<ge> length sl. fst (\\<pi> !! i) = toSink (last sl)) \\<and>\n stateOf \\<pi> = hd sl\"", "lemma wffp_imp_appendL: \"wffp (sl1 @ sl2) \\<Longrightarrow> sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1\"", "lemma wffp_imp_appendR: \"wffp (sl1 @ sl2) \\<Longrightarrow> sl2 \\<noteq> [] \\<Longrightarrow> wffp sl2\"", "lemma wffp_iff_map_Idle:\nassumes \"wffp sl\"\nshows\n\"\\<exists> n st.\n   (n > 0 \\<and> sl = map Idle (replicate n st)) \\<or>\n   (\\<exists> st1 u1 c1 sl1. sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\"", "lemma wffp_cases3[elim, consumes 1, case_names Idle State Idle_State]:\nassumes \"wffp sl\"\nobtains\nn st where\n\"n > 0\" and \"sl = map Idle (replicate n st)\"\n|\nst u c sl1 where\n\"sl = State st u c # sl1\" and \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\"\n|\nn st u c sl1 where\n\"n > 0\" and \"sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1\"\nand \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State (do st u c) u c)\"", "lemma wffp_cases2[elim, consumes 1, case_names Idle State]:\nassumes \"wffp sl\"\nobtains\nn st where\n\"n > 0\" and \"sl = map Idle (replicate n st)\"\n|\nn st st1 u c sl1 where\n\"sl = map Idle (replicate n st) @ [State st1 u c] @ sl1\"\nand \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\"", "lemma wffp_Idle_Idle:\nassumes \"wffp (sl1 @ [Idle st1] @ [Idle st2] @ sl2)\"\nshows \"st2 = st1\"", "lemma wffp_Idle_State:\nassumes \"wffp (sl1 @ [Idle st1] @ [State st2 u2 c2] @ sl2)\"\nshows \"st2 = st1 \\<or> st2 = do st1 u2 c2\"", "lemma wffp_State_Idle:\nassumes \"wffp (sl1 @ [State st1 u1 c1] @ [Idle st2] @ sl2)\"\nshows \"st2 = st1\"", "lemma wffp_State_State:\nassumes \"wffp (sl1 @ [State st1 u1 c1] @ [State st2 u2 c2] @ sl2)\"\nshows \"st2 = do st1 u2 c2\"", "lemma wfp_to_wffp:\nassumes sl_def: \"sl = map fst (stake i \\<pi>)\" and i: \"i > 0\" and \\<pi>: \"wfp UNIV \\<pi>\"\nshows\n\"wffp sl \\<and>\n (\\<forall> j < length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n stateOf \\<pi> = hd sl\"", "lemma nonintSI_nonintS: \"nonintSI \\<longleftrightarrow> nonintS\"", "lemma purgeIdle_simps[simp]:\n\"purgeIdle [] = []\"\n\"purgeIdle ((Idle st) # sl) = purgeIdle sl\"\n\"purgeIdle ((State st u c) # sl) = (State st u c) # purgeIdle sl\"", "lemma purgeIdle_append:\n\"purgeIdle (sl1 @ sl2) = purgeIdle sl1 @ purgeIdle sl2\"", "lemma purgeIdle_set_isState:\nassumes \"s \\<in> set (purgeIdle sl)\"\nshows \"isState s\"", "lemma purgeIdle_Nil_iff:\n\"purgeIdle sl = [] \\<longleftrightarrow> (\\<forall>s\\<in>set sl. \\<not> isState s)\"", "lemma purgeIdle_Cons_iff:\n\"purgeIdle sl = s # sll\n \\<longleftrightarrow>\n (\\<exists> sl1 sl2. sl = sl1 @ s # sl2 \\<and>\n            (\\<forall>s1\\<in>set sl1. \\<not> isState s1) \\<and> isState s \\<and> purgeIdle sl2 = sll)\"", "lemma purgeIdle_map_Idle[simp]:\n\"purgeIdle (map Idle s) = []\"", "lemma purgeIdle_replicate_Idle[simp]:\n\"purgeIdle (replicate n (Idle st)) = []\"", "lemma wffp_purgeIdle_Nil:\nassumes \"wffp sl\" and \"purgeIdle sl = []\"\nshows \"\\<exists> n st. n > 0 \\<and> sl = replicate n (Idle st)\"", "lemma wffp_hd_purgeIdle:\nassumes wsl: \"wffp sl\" and psl: \"purgeIdle sl \\<noteq> []\"\nand ist: \"isState s\" and hsl: \"hd sl \\<in> \\<delta> s\"\nshows \"hd (purgeIdle sl) \\<in> \\<delta> s\"", "lemma wffp_purgeIdle:\nassumes \"wffp sl\" and \"purgeIdle sl \\<noteq> []\"\nshows \"wffp (purgeIdle sl)\"", "lemma isState_purgeIdle:\n\"(\\<exists> sl. purgeIdle sl = sll) \\<longleftrightarrow> list_all isState sll\"", "lemma wffp_last_purgeIdle:\nassumes \"wffp sl\" and \"purgeIdle sl \\<noteq> []\"\nshows \"getGMState (last (purgeIdle sl)) = getGMState (last sl)\"", "lemma wffp_isState_doo:\nassumes \"wffp sl\" and \"list_all isState sl\"\nshows \"doo (getGMState (hd sl)) (map getGMUserCom (tl sl)) = getGMState (last sl)\"", "lemma isState_hd_purgeIdle:\nassumes wsl: \"wffp sl\" and ist: \"isState (hd sl)\"\nshows \"purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl\"", "lemma wffp_isState_doo_purgeIdle:\nfixes sl defines sll: \"sll \\<equiv> purgeIdle sl\"\nassumes wsl: \"wffp sl\" and ist: \"isState (hd sl)\"\nshows \"doo (getGMState (hd sl)) (map getGMUserCom (tl sll)) = getGMState (last sl)\"", "lemma map_getGMUserCom_surj:\nassumes \"isState s\"\nshows \"\\<exists> sl. wffp sl \\<and> list_all isState sl \\<and> hd sl = s \\<and> map getGMUserCom (tl sl) = ucl\"", "lemma purgeIdle_purge_ex:\nassumes \"wffp sl\" and \"list_all isState sl\" and \"map getGMUserCom (tl sl) = ucl\"\nshows \"\\<exists> sl'. hd sl' = ss' \\<and> wffp sl' \\<and>\n              list_all2 f (tl sl) (tl sl') \\<and>\n              map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\"", "lemma purgeIdle_getGMUserCom_purge:\nfixes sl sl'\ndefines \"ucl \\<equiv> map getGMUserCom (purgeIdle (tl sl))\"\n    and \"ucl' \\<equiv> map getGMUserCom (purgeIdle (tl sl'))\"\nassumes wsl: \"wffp sl\" and wsl': \"wffp sl'\" and f: \"list_all2 f sl sl'\"\nshows \"purge GH ucl = purge GH ucl'\"", "lemma nonintS_iff_nonint:\n\"nonintS \\<longleftrightarrow> nonint\"", "theorem nonintSfmla_iff_nonint:\n\"nonintSfmla [] \\<longleftrightarrow> nonint\""], "translations": [["", "lemma purge_Nil[simp]: \"purge G [] = []\"\nand purge_Cons_in[simp]: \"u \\<notin> G \\<Longrightarrow> purge G ((u,c) # ucl) = (u,c) # purge G ucl\"\nand purge_Cons_notIn[simp]: \"u \\<in> G \\<Longrightarrow> purge G ((u,c) # ucl) = purge G ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purge G [] = [] &&&\n    (u \\<notin> G \\<Longrightarrow>\n     purge G ((u, c) # ucl) = (u, c) # purge G ucl) &&&\n    (u \\<in> G \\<Longrightarrow> purge G ((u, c) # ucl) = purge G ucl)", "unfolding purge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(u, c). u \\<notin> G) [] = [] &&&\n    (u \\<notin> G \\<Longrightarrow>\n     filter (\\<lambda>(u, c). u \\<notin> G) ((u, c) # ucl) =\n     (u, c) # filter (\\<lambda>(u, c). u \\<notin> G) ucl) &&&\n    (u \\<in> G \\<Longrightarrow>\n     filter (\\<lambda>(u, c). u \\<notin> G) ((u, c) # ucl) =\n     filter (\\<lambda>(u, c). u \\<notin> G) ucl)", "by auto"], ["", "lemma purge_append:\n\"purge G (ucl1 @ ucl2) = purge G ucl1 @ purge G ucl2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purge G (ucl1 @ ucl2) = purge G ucl1 @ purge G ucl2", "unfolding purge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>(u, c). u \\<notin> G) (ucl1 @ ucl2) =\n    filter (\\<lambda>(u, c). u \\<notin> G) ucl1 @\n    filter (\\<lambda>(u, c). u \\<notin> G) ucl2", "by (metis filter_append)"], ["", "definition nonint :: bool where\n\"nonint \\<equiv> \\<forall> ucl. \\<forall> u \\<in> GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\""], ["", "(*<*)"], ["", "end"], ["", "(* context GM_sec_model *)\n(*>*)"], ["", "text\\<open>end-of-context GM-sec-model\\<close>"], ["", "subsection\\<open>Specialized Kripke structures\\<close>"], ["", "text\\<open>As a preparation for representing noninterference in HyperCTL*,\nwe define a specialized notion of Kripke structure.  It is enriched\nwith the following date: \ntwo binary state predicates f and g, intuitively capturing high-input\nand low-output equivalence, respectively; \na set Sink of\nstates immediately accessible from any state and such that, for the states in Sink,\nthere exist self-transitions and f holds.\n\nThis specialized structure, represented by the locale Shallow-Idle, is an auxiliary that streamlines our proofs, \neasing the connection\nbetween finite paths (specific to Goguen-Meseguer noninterference) and\ninfinite paths (specific to the HyperCTL* semantics).\nThe desired Kripke structure produced from a Goguen-Meseguer model \nwill actually be such a specialized structure.\n\\<close>"], ["", "locale Shallow_Idle = Shallow S \"s0\" \\<delta> AP\n  for S :: \"'state set\" and s0 :: 'state and \\<delta> :: \"'state \\<Rightarrow> 'state set\"\n  and AP :: \"'aprop set\"\n  and f :: \"'state \\<Rightarrow> 'state \\<Rightarrow> bool\" and g :: \"'state \\<Rightarrow> 'state \\<Rightarrow> bool\"\n  and Sink :: \"'state set\"\n  +\n  assumes Sink_S: \"Sink \\<subseteq> S\"\n  and Sink: \"\\<And> s. s \\<in> S \\<Longrightarrow> \\<exists> s'. s' \\<in> \\<delta> s \\<inter> Sink\"\n  and Sink_idle: \"\\<And> s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\"\n  and Sink_f: \"\\<And> s1 s2. {s1,s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2\"\nbegin"], ["", "definition \"toSink s \\<equiv> SOME s'. s' \\<in> \\<delta> s \\<inter> Sink\""], ["", "lemma toSink: \"s \\<in> S \\<Longrightarrow> toSink s \\<in> \\<delta> s \\<inter> Sink\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow> toSink s \\<in> \\<delta> s \\<inter> Sink", "unfolding toSink_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> S \\<Longrightarrow>\n    (SOME s'. s' \\<in> \\<delta> s \\<inter> Sink)\n    \\<in> \\<delta> s \\<inter> Sink", "by (metis Sink someI)"], ["", "lemma fall2_imp_alw:\n\"fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l)) (\\<pi>l @ [\\<pi>,\\<pi>'])) []\n \\<longleftrightarrow>\n (\\<forall> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n           \\<longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>,\\<pi>']\n )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'])", "by (auto intro!: fall2_intro imp_intro elim!: fall2_elim imp_elim) (metis imp_elim)+"], ["", "lemma wfp_stateOf_shift_stake_sconst:\nfixes \\<pi> i\ndefines \"\\<pi>1 \\<equiv> shift (stake (Suc i) \\<pi>) (sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))\"\nassumes \\<pi>: \"wfp AP' \\<pi>\"\nshows \"wfp AP' \\<pi>1 \\<and> stateOf \\<pi>1 = stateOf \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp AP' \\<pi>1 \\<and> stateOf \\<pi>1 = stateOf \\<pi>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "have \\<pi>1_less[simp]: \"\\<And> k. k < Suc i \\<Longrightarrow> \\<pi>1 !! k = \\<pi> !! k\"\n   and \\<pi>1_geq[simp]: \"\\<And> k. k > i \\<Longrightarrow> \\<pi>1 !! k = (toSink (fst (\\<pi> !! i)) , L (toSink (fst (\\<pi> !! i))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k. k < Suc i \\<Longrightarrow> \\<pi>1 !! k = \\<pi> !! k) &&&\n    (\\<And>k.\n        i < k \\<Longrightarrow>\n        \\<pi>1 !! k =\n        (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))", "unfolding \\<pi>1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k.\n        k < Suc i \\<Longrightarrow>\n        (stake (Suc i) \\<pi> @-\n         sconst\n          (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))) !!\n        k =\n        \\<pi> !! k) &&&\n    (\\<And>k.\n        i < k \\<Longrightarrow>\n        (stake (Suc i) \\<pi> @-\n         sconst\n          (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))) !!\n        k =\n        (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))", "by (auto simp del: stake.simps)"], ["proof (state)\nthis:\n  ?k < Suc i \\<Longrightarrow> \\<pi>1 !! ?k = \\<pi> !! ?k\n  i < ?k \\<Longrightarrow>\n  \\<pi>1 !! ?k = (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "{"], ["proof (state)\nthis:\n  ?k < Suc i \\<Longrightarrow> \\<pi>1 !! ?k = \\<pi> !! ?k\n  i < ?k \\<Longrightarrow>\n  \\<pi>1 !! ?k = (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "have \"fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "proof(cases \"k < Suc i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "case True"], ["proof (state)\nthis:\n  k < Suc i\n\ngoal (2 subgoals):\n 1. k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "hence 0: \"\\<pi>1 !! k = \\<pi> !! k\""], ["proof (prove)\nusing this:\n  k < Suc i\n\ngoal (1 subgoal):\n 1. \\<pi>1 !! k = \\<pi> !! k", "by simp"], ["proof (state)\nthis:\n  \\<pi>1 !! k = \\<pi> !! k\n\ngoal (2 subgoals):\n 1. k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "proof(cases \"k < i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "case True"], ["proof (state)\nthis:\n  k < i\n\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "hence 1: \"Suc k < Suc i\""], ["proof (prove)\nusing this:\n  k < i\n\ngoal (1 subgoal):\n 1. Suc k < Suc i", "by simp"], ["proof (state)\nthis:\n  Suc k < Suc i\n\ngoal (2 subgoals):\n 1. k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n 2. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "using \\<pi>"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "unfolding \\<pi>1_less[OF 1] 0 wfp"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     fst (\\<pi> !! i) \\<in> S \\<and>\n     snd (\\<pi> !! i) \\<subseteq> AP' \\<and>\n     snd (\\<pi> !! i) \\<inter> AP = L (fst (\\<pi> !! i)) \\<and>\n     fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc k) \\<in> \\<delta> (fst (\\<pi> !! k))", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "case False"], ["proof (state)\nthis:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "hence 1: \"Suc k > i\" and k: \"k = i\""], ["proof (prove)\nusing this:\n  \\<not> k < i\n\ngoal (1 subgoal):\n 1. i < Suc k &&& k = i", "using True"], ["proof (prove)\nusing this:\n  \\<not> k < i\n  k < Suc i\n\ngoal (1 subgoal):\n 1. i < Suc k &&& k = i", "by simp_all"], ["proof (state)\nthis:\n  i < Suc k\n  k = i\n\ngoal (1 subgoal):\n 1. \\<not> k < i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "using \\<pi>"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "unfolding \\<pi>1_geq[OF 1] 0 wfp"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     fst (\\<pi> !! i) \\<in> S \\<and>\n     snd (\\<pi> !! i) \\<subseteq> AP' \\<and>\n     snd (\\<pi> !! i) \\<inter> AP = L (fst (\\<pi> !! i)) \\<and>\n     fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n    \\<in> \\<delta> (fst (\\<pi> !! k))", "unfolding k"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     fst (\\<pi> !! i) \\<in> S \\<and>\n     snd (\\<pi> !! i) \\<subseteq> AP' \\<and>\n     snd (\\<pi> !! i) \\<inter> AP = L (fst (\\<pi> !! i)) \\<and>\n     fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n    \\<in> \\<delta> (fst (\\<pi> !! i))", "by (metis IntD1 fstI toSink)"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "case False"], ["proof (state)\nthis:\n  \\<not> k < Suc i\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "hence k: \"k > i\" and sk: \"Suc k > i\""], ["proof (prove)\nusing this:\n  \\<not> k < Suc i\n\ngoal (1 subgoal):\n 1. i < k &&& i < Suc k", "by auto"], ["proof (state)\nthis:\n  i < k\n  i < Suc k\n\ngoal (1 subgoal):\n 1. \\<not> k < Suc i \\<Longrightarrow>\n    fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))", "unfolding \\<pi>1_geq[OF k] \\<pi>1_geq[OF sk]"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n    \\<in> \\<delta>\n           (fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))", "using \\<pi> wfp Sink_idle toSink"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp ?AP' ?\\<pi> =\n  (\\<forall>i.\n      fst (?\\<pi> !! i) \\<in> S \\<and>\n      snd (?\\<pi> !! i) \\<subseteq> ?AP' \\<and>\n      snd (?\\<pi> !! i) \\<inter> AP = L (fst (?\\<pi> !! i)) \\<and>\n      fst (?\\<pi> !! Suc i) \\<in> \\<delta> (fst (?\\<pi> !! i)))\n  ?s \\<in> Sink \\<Longrightarrow> ?s \\<in> \\<delta> ?s\n  ?s \\<in> S \\<Longrightarrow> toSink ?s \\<in> \\<delta> ?s \\<inter> Sink\n\ngoal (1 subgoal):\n 1. fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n    \\<in> \\<delta>\n           (fst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc k) \\<in> \\<delta> (fst (\\<pi>1 !! k))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "}"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "moreover"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "{"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "fix k"], ["proof (state)\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "have \"fst (\\<pi>1 !! k) \\<in> S \\<and> snd (\\<pi>1 !! k) \\<subseteq> AP' \\<and> snd (\\<pi>1 !! k) \\<inter> AP = L (fst (\\<pi>1 !! k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi>1 !! k) \\<in> S \\<and>\n    snd (\\<pi>1 !! k) \\<subseteq> AP' \\<and>\n    snd (\\<pi>1 !! k) \\<inter> AP = L (fst (\\<pi>1 !! k))", "apply(cases \"k < Suc i\",simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. k < Suc i \\<Longrightarrow>\n    fst (\\<pi> !! k) \\<in> S \\<and>\n    snd (\\<pi> !! k) \\<subseteq> AP' \\<and>\n    snd (\\<pi> !! k) \\<inter> AP = L (fst (\\<pi> !! k))\n 2. \\<not> k < Suc i \\<Longrightarrow>\n    toSink (fst (\\<pi> !! i)) \\<in> S \\<and>\n    L (toSink (fst (\\<pi> !! i))) \\<subseteq> AP' \\<and>\n    L (toSink (fst (\\<pi> !! i))) \\<inter> AP =\n    L (toSink (fst (\\<pi> !! i)))", "by (metis (lifting, no_types) \\<pi> wfp AP_AP' IntD1 L \\<delta> inf.orderE order_trans rev_subsetD toSink)+"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! k) \\<in> S \\<and>\n  snd (\\<pi>1 !! k) \\<subseteq> AP' \\<and>\n  snd (\\<pi>1 !! k) \\<inter> AP = L (fst (\\<pi>1 !! k))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "}"], ["proof (state)\nthis:\n  fst (\\<pi>1 !! ?k2) \\<in> S \\<and>\n  snd (\\<pi>1 !! ?k2) \\<subseteq> AP' \\<and>\n  snd (\\<pi>1 !! ?k2) \\<inter> AP = L (fst (\\<pi>1 !! ?k2))\n\ngoal (2 subgoals):\n 1. wfp AP' \\<pi>1\n 2. stateOf \\<pi>1 = stateOf \\<pi>", "ultimately"], ["proof (chain)\npicking this:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n  fst (\\<pi>1 !! ?k2) \\<in> S \\<and>\n  snd (\\<pi>1 !! ?k2) \\<subseteq> AP' \\<and>\n  snd (\\<pi>1 !! ?k2) \\<inter> AP = L (fst (\\<pi>1 !! ?k2))", "show \"wfp AP' \\<pi>1\""], ["proof (prove)\nusing this:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n  fst (\\<pi>1 !! ?k2) \\<in> S \\<and>\n  snd (\\<pi>1 !! ?k2) \\<subseteq> AP' \\<and>\n  snd (\\<pi>1 !! ?k2) \\<inter> AP = L (fst (\\<pi>1 !! ?k2))\n\ngoal (1 subgoal):\n 1. wfp AP' \\<pi>1", "unfolding wfp"], ["proof (prove)\nusing this:\n  fst (\\<pi>1 !! Suc ?k2) \\<in> \\<delta> (fst (\\<pi>1 !! ?k2))\n  fst (\\<pi>1 !! ?k2) \\<in> S \\<and>\n  snd (\\<pi>1 !! ?k2) \\<subseteq> AP' \\<and>\n  snd (\\<pi>1 !! ?k2) \\<inter> AP = L (fst (\\<pi>1 !! ?k2))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       fst (\\<pi>1 !! i) \\<in> S \\<and>\n       snd (\\<pi>1 !! i) \\<subseteq> AP' \\<and>\n       snd (\\<pi>1 !! i) \\<inter> AP = L (fst (\\<pi>1 !! i)) \\<and>\n       fst (\\<pi>1 !! Suc i) \\<in> \\<delta> (fst (\\<pi>1 !! i))", "by auto"], ["proof (state)\nthis:\n  wfp AP' \\<pi>1\n\ngoal (1 subgoal):\n 1. stateOf \\<pi>1 = stateOf \\<pi>", "show \"stateOf \\<pi>1 = stateOf \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stateOf \\<pi>1 = stateOf \\<pi>", "by (metis \\<pi>1_def shift.simps(2) stake.simps(2) stream.sel(1))"], ["proof (state)\nthis:\n  stateOf \\<pi>1 = stateOf \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fall2_imp_alw_index:\nassumes 0: \"\\<And> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n                     \\<phi> [] [\\<pi>,\\<pi>'] = f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n                     \\<psi> [] [\\<pi>,\\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>')\"\nshows\n\"fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l. imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l)) (\\<pi>l @ [\\<pi>,\\<pi>'])) []\n \\<longleftrightarrow>\n (\\<forall> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n           \\<longrightarrow>\n           (\\<forall> i. (\\<forall> j \\<le> i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n )\"\n(is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "have 1: \"\\<And> i \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n                      f (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) = \\<phi> [] [sdrop i \\<pi>, sdrop i \\<pi>'] \\<and>\n                      g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) = \\<psi> [] [sdrop i \\<pi>, sdrop i \\<pi>']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i \\<pi> \\<pi>'.\n       wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n       f (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) =\n       \\<phi> [] [sdrop i \\<pi>, sdrop i \\<pi>'] \\<and>\n       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) =\n       \\<psi> [] [sdrop i \\<pi>, sdrop i \\<pi>']", "using 0"], ["proof (prove)\nusing this:\n  wfp AP' ?\\<pi> \\<and> wfp AP' ?\\<pi>' \\<longrightarrow>\n  \\<phi> [] [?\\<pi>, ?\\<pi>'] = f (stateOf ?\\<pi>) (stateOf ?\\<pi>') \\<and>\n  \\<psi> [] [?\\<pi>, ?\\<pi>'] = g (stateOf ?\\<pi>) (stateOf ?\\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>i \\<pi> \\<pi>'.\n       wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n       f (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) =\n       \\<phi> [] [sdrop i \\<pi>, sdrop i \\<pi>'] \\<and>\n       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)) =\n       \\<psi> [] [sdrop i \\<pi>, sdrop i \\<pi>']", "by auto"], ["proof (state)\nthis:\n  wfp AP' ?\\<pi> \\<and> wfp AP' ?\\<pi>' \\<longrightarrow>\n  f (fst (?\\<pi> !! ?i)) (fst (?\\<pi>' !! ?i)) =\n  \\<phi> [] [sdrop ?i ?\\<pi>, sdrop ?i ?\\<pi>'] \\<and>\n  g (fst (?\\<pi> !! ?i)) (fst (?\\<pi>' !! ?i)) =\n  \\<psi> [] [sdrop ?i ?\\<pi>, sdrop ?i ?\\<pi>']\n\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "unfolding fall2_imp_alw"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>']) =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "proof(intro iffI allI impI, elim conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "fix \\<pi> \\<pi>' i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "assume L: \"\\<forall> \\<pi> \\<pi>'. wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n                       \\<longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>,\\<pi>']\"\n    and \\<pi>\\<pi>'[simp]: \"wfp AP' \\<pi>\" \"wfp AP' \\<pi>'\" \"stateOf \\<pi> = s0\" \"stateOf \\<pi>' = s0\"\n    and \\<phi>: \"\\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\""], ["proof (state)\nthis:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp AP' \\<pi> \\<and>\n     wfp AP' \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>']\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "have \\<pi>\\<pi>'i[simp]: \"\\<And> i. wfp AP' (sdrop i \\<pi>) \\<and> wfp AP' (sdrop i \\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. wfp AP' (sdrop i \\<pi>) \\<and> wfp AP' (sdrop i \\<pi>')", "by (metis \\<pi>\\<pi>' wfp_sdrop)"], ["proof (state)\nthis:\n  wfp AP' (sdrop ?i \\<pi>) \\<and> wfp AP' (sdrop ?i \\<pi>')\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "define \\<pi>1 where \"\\<pi>1 = shift (stake (Suc i) \\<pi>) (sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))\""], ["proof (state)\nthis:\n  \\<pi>1 =\n  stake (Suc i) \\<pi> @-\n  sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "define \\<pi>1' where \"\\<pi>1' = shift (stake (Suc i) \\<pi>') (sconst (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i)))))\""], ["proof (state)\nthis:\n  \\<pi>1' =\n  stake (Suc i) \\<pi>' @-\n  sconst (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "have \\<pi>1\\<pi>1': \"wfp AP' \\<pi>1 \\<and> stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp AP' \\<pi>1 \\<and>\n    stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0", "using wfp_stateOf_shift_stake_sconst"], ["proof (prove)\nusing this:\n  wfp AP' ?\\<pi> \\<Longrightarrow>\n  wfp AP'\n   (stake (Suc ?i) ?\\<pi> @-\n    sconst\n     (toSink (fst (?\\<pi> !! ?i)), L (toSink (fst (?\\<pi> !! ?i))))) \\<and>\n  stateOf\n   (stake (Suc ?i) ?\\<pi> @-\n    sconst (toSink (fst (?\\<pi> !! ?i)), L (toSink (fst (?\\<pi> !! ?i))))) =\n  stateOf ?\\<pi>\n\ngoal (1 subgoal):\n 1. wfp AP' \\<pi>1 \\<and>\n    stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0", "unfolding \\<pi>1_def \\<pi>1'_def"], ["proof (prove)\nusing this:\n  wfp AP' ?\\<pi> \\<Longrightarrow>\n  wfp AP'\n   (stake (Suc ?i) ?\\<pi> @-\n    sconst\n     (toSink (fst (?\\<pi> !! ?i)), L (toSink (fst (?\\<pi> !! ?i))))) \\<and>\n  stateOf\n   (stake (Suc ?i) ?\\<pi> @-\n    sconst (toSink (fst (?\\<pi> !! ?i)), L (toSink (fst (?\\<pi> !! ?i))))) =\n  stateOf ?\\<pi>\n\ngoal (1 subgoal):\n 1. wfp AP'\n     (stake (Suc i) \\<pi> @-\n      sconst\n       (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))) \\<and>\n    stateOf\n     (stake (Suc i) \\<pi> @-\n      sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))) =\n    s0 \\<and>\n    wfp AP'\n     (stake (Suc i) \\<pi>' @-\n      sconst\n       (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))) \\<and>\n    stateOf\n     (stake (Suc i) \\<pi>' @-\n      sconst (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))) =\n    s0", "by auto"], ["proof (state)\nthis:\n  wfp AP' \\<pi>1 \\<and>\n  stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "hence \\<pi>1\\<pi>1'i: \"\\<And> i. wfp AP' (sdrop i \\<pi>1) \\<and> wfp AP' (sdrop i \\<pi>1')\""], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>1 \\<and>\n  stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0\n\ngoal (1 subgoal):\n 1. \\<And>i. wfp AP' (sdrop i \\<pi>1) \\<and> wfp AP' (sdrop i \\<pi>1')", "by (metis \\<pi>\\<pi>' wfp_sdrop)"], ["proof (state)\nthis:\n  wfp AP' (sdrop ?i \\<pi>1) \\<and> wfp AP' (sdrop ?i \\<pi>1')\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "have imp: \"imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1,\\<pi>1']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']", "using L  \\<pi>1\\<pi>1'"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp AP' \\<pi> \\<and>\n     wfp AP' \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>']\n  wfp AP' \\<pi>1 \\<and>\n  stateOf \\<pi>1 = s0 \\<and> wfp AP' \\<pi>1' \\<and> stateOf \\<pi>1' = s0\n\ngoal (1 subgoal):\n 1. imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']", "by auto"], ["proof (state)\nthis:\n  imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "moreover"], ["proof (state)\nthis:\n  imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "have \"alw (\\<phi> []) [\\<pi>1,\\<pi>1']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<phi> []) [\\<pi>1, \\<pi>1']", "unfolding alw"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. \\<phi> [] (map (sdrop i) [\\<pi>1, \\<pi>1'])", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<phi> [] (map (sdrop i) [\\<pi>1, \\<pi>1'])", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. \\<phi> [] (map (sdrop i) [\\<pi>1, \\<pi>1'])", "have a: \"fst (\\<pi> !! i) \\<in> S\" and b: \"fst (\\<pi>' !! i) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) \\<in> S &&& fst (\\<pi>' !! i) \\<in> S", "using \\<pi>\\<pi>'"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) \\<in> S &&& fst (\\<pi>' !! i) \\<in> S", "unfolding wfp"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     fst (\\<pi> !! i) \\<in> S \\<and>\n     snd (\\<pi> !! i) \\<subseteq> AP' \\<and>\n     snd (\\<pi> !! i) \\<inter> AP = L (fst (\\<pi> !! i)) \\<and>\n     fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n  \\<forall>i.\n     fst (\\<pi>' !! i) \\<in> S \\<and>\n     snd (\\<pi>' !! i) \\<subseteq> AP' \\<and>\n     snd (\\<pi>' !! i) \\<inter> AP = L (fst (\\<pi>' !! i)) \\<and>\n     fst (\\<pi>' !! Suc i) \\<in> \\<delta> (fst (\\<pi>' !! i))\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) \\<in> S &&& fst (\\<pi>' !! i) \\<in> S", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi> !! i) \\<in> S\n  fst (\\<pi>' !! i) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>i. \\<phi> [] (map (sdrop i) [\\<pi>1, \\<pi>1'])", "thus \"\\<phi> [] (map (sdrop k) [\\<pi>1, \\<pi>1'])\""], ["proof (prove)\nusing this:\n  fst (\\<pi> !! i) \\<in> S\n  fst (\\<pi>' !! i) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<phi> [] (map (sdrop k) [\\<pi>1, \\<pi>1'])", "using \\<phi> 0 \\<pi>1\\<pi>1'i"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! i) \\<in> S\n  fst (\\<pi>' !! i) \\<in> S\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n  wfp AP' ?\\<pi> \\<and> wfp AP' ?\\<pi>' \\<longrightarrow>\n  \\<phi> [] [?\\<pi>, ?\\<pi>'] = f (stateOf ?\\<pi>) (stateOf ?\\<pi>') \\<and>\n  \\<psi> [] [?\\<pi>, ?\\<pi>'] = g (stateOf ?\\<pi>) (stateOf ?\\<pi>')\n  wfp AP' (sdrop ?i \\<pi>1) \\<and> wfp AP' (sdrop ?i \\<pi>1')\n\ngoal (1 subgoal):\n 1. \\<phi> [] (map (sdrop k) [\\<pi>1, \\<pi>1'])", "unfolding \\<pi>1_def \\<pi>1'_def"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! i) \\<in> S\n  fst (\\<pi>' !! i) \\<in> S\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n  wfp AP' ?\\<pi> \\<and> wfp AP' ?\\<pi>' \\<longrightarrow>\n  \\<phi> [] [?\\<pi>, ?\\<pi>'] = f (stateOf ?\\<pi>) (stateOf ?\\<pi>') \\<and>\n  \\<psi> [] [?\\<pi>, ?\\<pi>'] = g (stateOf ?\\<pi>) (stateOf ?\\<pi>')\n  wfp AP'\n   (sdrop ?i\n     (stake (Suc i) \\<pi> @-\n      sconst\n       (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))))) \\<and>\n  wfp AP'\n   (sdrop ?i\n     (stake (Suc i) \\<pi>' @-\n      sconst (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))))\n\ngoal (1 subgoal):\n 1. \\<phi> []\n     (map (sdrop k)\n       [stake (Suc i) \\<pi> @-\n        sconst (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i)))),\n        stake (Suc i) \\<pi>' @-\n        sconst\n         (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))])", "apply(cases \"k < Suc i\", simp_all del: stake.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < Suc i; fst (\\<pi> !! i) \\<in> S;\n     fst (\\<pi>' !! i) \\<in> S;\n     \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n     \\<And>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n        \\<phi> [] [\\<pi>, \\<pi>'] =\n        f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n        \\<psi> [] [\\<pi>, \\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>');\n     \\<And>ia.\n        wfp AP'\n         (sdrop ia\n           (stake (Suc i) \\<pi> @-\n            sconst\n             (toSink (fst (\\<pi> !! i)),\n              L (toSink (fst (\\<pi> !! i)))))) \\<and>\n        wfp AP'\n         (sdrop ia\n           (stake (Suc i) \\<pi>' @-\n            sconst\n             (toSink (fst (\\<pi>' !! i)),\n              L (toSink (fst (\\<pi>' !! i))))))\\<rbrakk>\n    \\<Longrightarrow> f (toSink (fst (\\<pi> !! i)))\n                       (toSink (fst (\\<pi>' !! i)))", "using toSink[OF a] toSink[OF b] Sink_f"], ["proof (prove)\nusing this:\n  toSink (fst (\\<pi> !! i)) \\<in> \\<delta> (fst (\\<pi> !! i)) \\<inter> Sink\n  toSink (fst (\\<pi>' !! i))\n  \\<in> \\<delta> (fst (\\<pi>' !! i)) \\<inter> Sink\n  {?s1.0, ?s2.0} \\<subseteq> Sink \\<Longrightarrow> f ?s1.0 ?s2.0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> k < Suc i; fst (\\<pi> !! i) \\<in> S;\n     fst (\\<pi>' !! i) \\<in> S;\n     \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n     \\<And>\\<pi> \\<pi>'.\n        wfp AP' \\<pi> \\<and> wfp AP' \\<pi>' \\<longrightarrow>\n        \\<phi> [] [\\<pi>, \\<pi>'] =\n        f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n        \\<psi> [] [\\<pi>, \\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>');\n     \\<And>ia.\n        wfp AP'\n         (sdrop ia\n           (stake (Suc i) \\<pi> @-\n            sconst\n             (toSink (fst (\\<pi> !! i)),\n              L (toSink (fst (\\<pi> !! i)))))) \\<and>\n        wfp AP'\n         (sdrop ia\n           (stake (Suc i) \\<pi>' @-\n            sconst\n             (toSink (fst (\\<pi>' !! i)),\n              L (toSink (fst (\\<pi>' !! i))))))\\<rbrakk>\n    \\<Longrightarrow> f (toSink (fst (\\<pi> !! i)))\n                       (toSink (fst (\\<pi>' !! i)))", "by auto"], ["proof (state)\nthis:\n  \\<phi> [] (map (sdrop k) [\\<pi>1, \\<pi>1'])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alw (\\<phi> []) [\\<pi>1, \\<pi>1']\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "ultimately"], ["proof (chain)\npicking this:\n  imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']\n  alw (\\<phi> []) [\\<pi>1, \\<pi>1']", "have \"alw (\\<psi> []) [\\<pi>1,\\<pi>1']\""], ["proof (prove)\nusing this:\n  imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>1, \\<pi>1']\n  alw (\\<phi> []) [\\<pi>1, \\<pi>1']\n\ngoal (1 subgoal):\n 1. alw (\\<psi> []) [\\<pi>1, \\<pi>1']", "by auto"], ["proof (state)\nthis:\n  alw (\\<psi> []) [\\<pi>1, \\<pi>1']\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "hence \"\\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']\""], ["proof (prove)\nusing this:\n  alw (\\<psi> []) [\\<pi>1, \\<pi>1']\n\ngoal (1 subgoal):\n 1. \\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']", "unfolding alw"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<psi> [] (map (sdrop i) [\\<pi>1, \\<pi>1'])\n\ngoal (1 subgoal):\n 1. \\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']", "by simp"], ["proof (state)\nthis:\n  \\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "hence \"g (fst (\\<pi>1 !! i)) (fst (\\<pi>1' !! i))\""], ["proof (prove)\nusing this:\n  \\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi>1 !! i)) (fst (\\<pi>1' !! i))", "using 0 \\<pi>1\\<pi>1'i"], ["proof (prove)\nusing this:\n  \\<psi> [] [sdrop i \\<pi>1, sdrop i \\<pi>1']\n  wfp AP' ?\\<pi> \\<and> wfp AP' ?\\<pi>' \\<longrightarrow>\n  \\<phi> [] [?\\<pi>, ?\\<pi>'] = f (stateOf ?\\<pi>) (stateOf ?\\<pi>') \\<and>\n  \\<psi> [] [?\\<pi>, ?\\<pi>'] = g (stateOf ?\\<pi>) (stateOf ?\\<pi>')\n  wfp AP' (sdrop ?i \\<pi>1) \\<and> wfp AP' (sdrop ?i \\<pi>1')\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi>1 !! i)) (fst (\\<pi>1' !! i))", "by simp"], ["proof (state)\nthis:\n  g (fst (\\<pi>1 !! i)) (fst (\\<pi>1' !! i))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   imp (alw (\\<phi> [])) (alw (\\<psi> [])) [\\<pi>, \\<pi>'];\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j));\n        wfp AP' \\<pi>; wfp AP' \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n 2. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "thus \"g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\""], ["proof (prove)\nusing this:\n  g (fst (\\<pi>1 !! i)) (fst (\\<pi>1' !! i))\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "unfolding \\<pi>1_def \\<pi>1'_def"], ["proof (prove)\nusing this:\n  g (fst ((stake (Suc i) \\<pi> @-\n           sconst\n            (toSink (fst (\\<pi> !! i)), L (toSink (fst (\\<pi> !! i))))) !!\n          i))\n   (fst ((stake (Suc i) \\<pi>' @-\n          sconst\n           (toSink (fst (\\<pi>' !! i)), L (toSink (fst (\\<pi>' !! i))))) !!\n         i))\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "by (auto simp del: stake.simps)"], ["proof (state)\nthis:\n  g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp AP' \\<pi> \\<and>\n                   wfp AP' \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wfp AP' \\<pi> \\<and>\n        wfp AP' \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\\<rbrakk>\n       \\<Longrightarrow> imp (alw (\\<phi> [])) (alw (\\<psi> []))\n                          [\\<pi>, \\<pi>']", "qed(auto simp: sdrop_imp_alw 1)"], ["proof (state)\nthis:\n  fall2\n   (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n       imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n        (\\<pi>l @ [\\<pi>, \\<pi>']))\n   [] =\n  (\\<forall>\\<pi> \\<pi>'.\n      wfp AP' \\<pi> \\<and>\n      wfp AP' \\<pi>' \\<and>\n      stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n      (\\<forall>i.\n          (\\<forall>j\\<le>i.\n              f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n          g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*<*)"], ["", "end"], ["", "(* context Shallow-Idle *)\n(*>*)"], ["", "text\\<open>end-of-context Shallow-Idle\\<close>"], ["", "subsection\\<open>Faithful representation as a HyperCTL* property\\<close>"], ["", "text\\<open>Starting with a Goguen-Meseguer model, we will produce a specialized\nKripke structure and a shallow HyperCTL* formula.\nThen we we will prove that the structure satisfies the formula iff the\nGoguen-Meseguer model satisfies noninterference.\\<close>"], ["", "text\\<open>\nThe Kripke structure has two kinds of states: ``idle'' states storing Goguen-Meseguer states,\nand normal states storing Goguen-Meseguer states, users and commands: the former \nwill be used for synchronization and the latter for Goguen-Meseguer steps.\nThe Kripke labels store user-command actions and user-output observations.\n\n\\<close>"], ["", "datatype ('St,'U,'C) state =\n  isIdle: Idle (getGMState: 'St) | isState: State (getGMState: 'St) (getGMUser: 'U) (getGMCom: 'C)"], ["", "datatype ('U,'C,'Out) aprop = Last 'U 'C | Obs 'U 'Out"], ["", "definition getGMUserCom where \"getGMUserCom s = (getGMUser s, getGMCom s)\""], ["", "lemma getGMUserCom[simp]: \"getGMUserCom (State st u c) = (u,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. getGMUserCom (State st u c) = (u, c)", "unfolding getGMUserCom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (getGMUser (State st u c), getGMCom (State st u c)) = (u, c)", "by auto"], ["", "context GM_sec_model\nbegin"], ["", "primrec L :: \"('St,'U,'C) state \\<Rightarrow> ('U,'C,'Out) aprop set\" where\n \"L (Idle st) = {Obs u' (out st u') | u'. True}\"\n|\"L (State st u c) = {Last u c} \\<union> {Obs u' (out st u') | u'. True}\""], ["", "text\\<open>Get the Goguen-Meseguer state:\\<close>"], ["", "primrec getGMState where\n \"getGMState (Idle st) = st\"\n|\"getGMState (State st u c) = st\""], ["", "lemma Last_in_L[simp]: \"Last u c \\<in> L s \\<longleftrightarrow> (\\<exists> st. s = State st u c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Last u c \\<in> L s) = (\\<exists>st. s = State st u c)", "by (cases s) auto"], ["", "lemma Obs_in_L[simp]: \"Obs u ou \\<in> L s \\<longleftrightarrow> ou = out (getGMState s) u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Obs u ou \\<in> L s) = (ou = out (local.getGMState s) u)", "by (cases s) auto"], ["", "primrec \\<delta> :: \"('St,'U,'C) state \\<Rightarrow> ('St,'U,'C) state set\" where\n \"\\<delta> (Idle st) = {Idle st} \\<union> {State (do st u' c') u' c' | u' c'. True}\"\n|\"\\<delta> (State st u c) = {Idle st} \\<union> {State (do st u' c') u' c' | u' c'. True}\""], ["", "abbreviation s0 where \"s0 \\<equiv> State st0 any any\""], ["", "definition f :: \"('a, 'U, 'b) state \\<Rightarrow> ('c, 'U, 'b) state \\<Rightarrow> bool\"\nwhere\n\"f s s' \\<equiv>\n \\<forall> u c. u \\<notin> GH \\<longrightarrow> ((\\<exists> st. s = State st u c) \\<longleftrightarrow> (\\<exists> st'. s' = State st' u c))\""], ["", "definition g :: \"('St, 'a, 'b) state \\<Rightarrow> ('St, 'c, 'd) state \\<Rightarrow> bool\"\nwhere\n\"g s s' \\<equiv> \\<forall> u1. u1 \\<in> GL \\<longrightarrow> out (getGMState s) u1 = out (getGMState s') u1\""], ["", "lemma f_id[simp,intro!]: \"f s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s s", "unfolding f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u c.\n       u \\<notin> GH \\<longrightarrow>\n       (\\<exists>st. s = State st u c) = (\\<exists>st'. s = State st' u c)", "by auto"], ["", "definition Sink :: \"('St,'U,'C) state set\"\nwhere\n\"Sink = {Idle st | st . True}\""], ["", "end"], ["", "(* context GM_sec_model *)"], ["", "sublocale GM_sec_model < Shallow_Idle\nwhere S = \"UNIV::('St,'U,'C) state set\"\nand AP = \"UNIV :: ('U,'C,'Out) aprop set\" and AP' = \"UNIV :: ('U,'C,'Out) aprop set\"\nand s0 = s0 and L = L and \\<delta> = \\<delta> and f = f and g = g and Sink = Sink"], ["proof (prove)\ngoal (1 subgoal):\n 1. Shallow_Idle L UNIV UNIV s0 \\<delta> UNIV f Sink", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s.\n       s \\<in> UNIV \\<Longrightarrow>\n       \\<exists>s'. s' \\<in> \\<delta> s \\<inter> Sink\n 7. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 8. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "fix s"], ["proof (state)\ngoal (8 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s.\n       s \\<in> UNIV \\<Longrightarrow>\n       \\<exists>s'. s' \\<in> \\<delta> s \\<inter> Sink\n 7. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 8. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "show \"\\<exists>s'. s' \\<in> \\<delta> s \\<inter> Sink\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'. s' \\<in> \\<delta> s \\<inter> Sink", "by (rule exI[of _ \"Idle (getGMState s)\"]) (cases s, auto simp: Sink_def)"], ["proof (state)\nthis:\n  \\<exists>s'. s' \\<in> \\<delta> s \\<inter> Sink\n\ngoal (7 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 7. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 7. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "fix s"], ["proof (state)\ngoal (7 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 7. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "assume \"s \\<in> Sink\""], ["proof (state)\nthis:\n  s \\<in> Sink\n\ngoal (7 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s. s \\<in> Sink \\<Longrightarrow> s \\<in> \\<delta> s\n 7. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "thus \"s \\<in> \\<delta> s\""], ["proof (prove)\nusing this:\n  s \\<in> Sink\n\ngoal (1 subgoal):\n 1. s \\<in> \\<delta> s", "unfolding Sink_def"], ["proof (prove)\nusing this:\n  s \\<in> {Idle st |st. True}\n\ngoal (1 subgoal):\n 1. s \\<in> \\<delta> s", "by (cases s) auto"], ["proof (state)\nthis:\n  s \\<in> \\<delta> s\n\ngoal (6 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "fix s1 s2"], ["proof (state)\ngoal (6 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "assume \"{s1, s2} \\<subseteq> Sink\""], ["proof (state)\nthis:\n  {s1, s2} \\<subseteq> Sink\n\ngoal (6 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV\n 6. \\<And>s1 s2. {s1, s2} \\<subseteq> Sink \\<Longrightarrow> f s1 s2", "thus \"f s1 s2\""], ["proof (prove)\nusing this:\n  {s1, s2} \\<subseteq> Sink\n\ngoal (1 subgoal):\n 1. f s1 s2", "unfolding Sink_def f_def"], ["proof (prove)\nusing this:\n  {s1, s2} \\<subseteq> {Idle st |st. True}\n\ngoal (1 subgoal):\n 1. \\<forall>u c.\n       u \\<notin> GH \\<longrightarrow>\n       (\\<exists>st. s1 = State st u c) = (\\<exists>st'. s2 = State st' u c)", "by auto"], ["proof (state)\nthis:\n  f s1 s2\n\ngoal (5 subgoals):\n 1. s0 \\<in> UNIV\n 2. \\<And>s. s \\<in> UNIV \\<Longrightarrow> \\<delta> s \\<subseteq> UNIV\n 3. \\<And>s. s \\<in> UNIV \\<Longrightarrow> L s \\<subseteq> UNIV\n 4. UNIV \\<subseteq> UNIV\n 5. Sink \\<subseteq> UNIV", "qed auto"], ["", "context GM_sec_model\nbegin"], ["", "lemma apropsOf_L_stateOf[simp]:\n\"wfp AP' \\<pi> \\<Longrightarrow> apropsOf \\<pi> = L (stateOf \\<pi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp AP' \\<pi> \\<Longrightarrow> apropsOf \\<pi> = L (stateOf \\<pi>)", "unfolding wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       fst (\\<pi> !! i) \\<in> UNIV \\<and>\n       snd (\\<pi> !! i) \\<subseteq> AP' \\<and>\n       snd (\\<pi> !! i) \\<inter> UNIV = L (fst (\\<pi> !! i)) \\<and>\n       fst (\\<pi> !! Suc i)\n       \\<in> \\<delta> (fst (\\<pi> !! i)) \\<Longrightarrow>\n    apropsOf \\<pi> = L (stateOf \\<pi>)", "by (metis Int_UNIV_right snth.simps(1))"], ["", "text\\<open>The equality of two states w.r.t.\\ a given ``last'' user-command pair:\\<close>"], ["", "definition eqOnUC ::\n\"nat \\<Rightarrow> nat \\<Rightarrow> 'U \\<Rightarrow> 'C \\<Rightarrow> (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla\"\nwhere\n\"eqOnUC i i' u c \\<equiv> eq (atom (Last u c) i) (atom (Last u c) i')\""], ["", "text\\<open>The equality of two states w.r.t.\\ all their ``last'' user-command pairs with\nthe user not in GH:\\<close>"], ["", "definition eqButGH ::\n\"nat \\<Rightarrow> nat \\<Rightarrow> (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla\"\nwhere\n\"eqButGH i i' \\<equiv> scon {eqOnUC i i' u c | u c. (u,c) \\<in> (UNIV - GH) \\<times> UNIV}\""], ["", "text\\<open>The equality of two states w.r.t.\\ a given ``observed'' user-observation pair:\\<close>"], ["", "definition eqOnUOut ::\n\"nat \\<Rightarrow> nat \\<Rightarrow> 'U \\<Rightarrow> 'Out \\<Rightarrow> (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla\"\nwhere\n\"eqOnUOut i i' u ou \\<equiv> eq (atom (Obs u ou) i) (atom (Obs u ou) i')\""], ["", "text\\<open>The equality of two states w.r.t.\\ all their ``observed'' user-observation pairs with\nthe user in GL:\\<close>"], ["", "definition eqOnGL ::\n\"nat \\<Rightarrow> nat \\<Rightarrow> (('St,'U,'C) state,('U,'C,'Out) aprop) sfmla\"\nwhere\n\"eqOnGL i i' \\<equiv> scon {eqOnUOut i i' u ou | u ou. (u,ou) \\<in> GL \\<times> UNIV}\""], ["", "lemma eqOnUC_0_Suc0[simp]:\nassumes \"wfp AP' \\<pi>\" and \"wfp AP' \\<pi>'\"\nshows\n\"eqOnUC 0 (Suc 0) u c [\\<pi>, \\<pi>']\n \\<longleftrightarrow>\n ((\\<exists>st. stateOf \\<pi> = State st u c) =\n  (\\<exists>st'. stateOf \\<pi>' = State st' u c)\n )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqOnUC 0 (Suc 0) u c [\\<pi>, \\<pi>'] =\n    ((\\<exists>st. stateOf \\<pi> = State st u c) =\n     (\\<exists>st'. stateOf \\<pi>' = State st' u c))", "using assms"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n\ngoal (1 subgoal):\n 1. eqOnUC 0 (Suc 0) u c [\\<pi>, \\<pi>'] =\n    ((\\<exists>st. stateOf \\<pi> = State st u c) =\n     (\\<exists>st'. stateOf \\<pi>' = State st' u c))", "unfolding eqOnUC_def atom_def[abs_def] eq_equals"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n\ngoal (1 subgoal):\n 1. ((Last u c \\<in> apropsOf ([\\<pi>, \\<pi>'] ! 0)) =\n     (Last u c \\<in> apropsOf ([\\<pi>, \\<pi>'] ! Suc 0))) =\n    ((\\<exists>st. stateOf \\<pi> = State st u c) =\n     (\\<exists>st'. stateOf \\<pi>' = State st' u c))", "by simp"], ["", "lemma eqOnUOut_0_Suc0[simp]:\nassumes \"wfp AP' \\<pi>\" and \"wfp AP' \\<pi>'\"\nshows\n\"eqOnUOut 0 (Suc 0) u ou [\\<pi>, \\<pi>']\n \\<longleftrightarrow>\n (ou = out (getGMState (stateOf \\<pi>)) u \\<longleftrightarrow>\n  ou = out (getGMState (stateOf \\<pi>')) u\n )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eqOnUOut 0 (Suc 0) u ou [\\<pi>, \\<pi>'] =\n    ((ou = out (local.getGMState (stateOf \\<pi>)) u) =\n     (ou = out (local.getGMState (stateOf \\<pi>')) u))", "using assms"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n\ngoal (1 subgoal):\n 1. eqOnUOut 0 (Suc 0) u ou [\\<pi>, \\<pi>'] =\n    ((ou = out (local.getGMState (stateOf \\<pi>)) u) =\n     (ou = out (local.getGMState (stateOf \\<pi>')) u))", "unfolding eqOnUOut_def atom_def[abs_def] eq_equals"], ["proof (prove)\nusing this:\n  wfp AP' \\<pi>\n  wfp AP' \\<pi>'\n\ngoal (1 subgoal):\n 1. ((Obs u ou \\<in> apropsOf ([\\<pi>, \\<pi>'] ! 0)) =\n     (Obs u ou \\<in> apropsOf ([\\<pi>, \\<pi>'] ! Suc 0))) =\n    ((ou = out (local.getGMState (stateOf \\<pi>)) u) =\n     (ou = out (local.getGMState (stateOf \\<pi>')) u))", "by simp"], ["", "text\\<open>The (shallow) noninterference formula -- it will be proved equivalent to nonint,\nthe original statement of noninterference.\\<close>"], ["", "definition nonintSfmla :: \"(('St,'U,'C) state,('U,'C,'Out) aprop) sfmla\" where\n\"nonintSfmla \\<equiv>\n fall2 (\\<lambda> \\<pi>' \\<pi> \\<pi>l.\n        imp (alw (eqButGH (length \\<pi>l) (Suc (length \\<pi>l))))\n            (alw (eqOnGL (length \\<pi>l) (Suc (length \\<pi>l))))\n        (\\<pi>l @ [\\<pi>,\\<pi>'])\n       )\""], ["", "text\\<open>First, we show that nonintSfmla is equivalent to nonintSI, a variant of noninterference\nthat speaks about Synchronized Infinite paths.\\<close>"], ["", "definition nonintSI :: bool where\n\"nonintSI \\<equiv>\n \\<forall> \\<pi> \\<pi>'. wfp UNIV \\<pi> \\<and> wfp UNIV \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n           \\<longrightarrow>\n          (\\<forall> i. (\\<forall> j \\<le> i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\""], ["", "lemma nonintSfmla_nonintSI: \"nonintSfmla [] \\<longleftrightarrow> nonintSI\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "define \\<phi> where \"\\<phi> \\<pi>l = eqButGH (length \\<pi>l) (Suc (length \\<pi>l))\"\n    for \\<pi>l :: \"(('St,'U,'C) state,('U,'C,'Out) aprop) path list\""], ["proof (state)\nthis:\n  \\<phi> ?\\<pi>l = eqButGH (length ?\\<pi>l) (Suc (length ?\\<pi>l))\n\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "define \\<psi> where \"\\<psi> \\<pi>l = eqOnGL (length \\<pi>l) (Suc (length \\<pi>l))\"\n    for \\<pi>l :: \"(('St,'U,'C) state,('U,'C,'Out) aprop) path list\""], ["proof (state)\nthis:\n  \\<psi> ?\\<pi>l = eqOnGL (length ?\\<pi>l) (Suc (length ?\\<pi>l))\n\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "have \"\\<And> \\<pi> \\<pi>'. wfp UNIV \\<pi> \\<and> wfp UNIV \\<pi>' \\<longrightarrow>\n                 \\<phi> [] [\\<pi>,\\<pi>'] = f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n                 \\<psi> [] [\\<pi>,\\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       wfp UNIV \\<pi> \\<and> wfp UNIV \\<pi>' \\<longrightarrow>\n       \\<phi> [] [\\<pi>, \\<pi>'] = f (stateOf \\<pi>) (stateOf \\<pi>') \\<and>\n       \\<psi> [] [\\<pi>, \\<pi>'] = g (stateOf \\<pi>) (stateOf \\<pi>')", "unfolding \\<phi>_def \\<psi>_def f_def g_def eqButGH_def eqOnGL_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>'.\n       wfp UNIV \\<pi> \\<and> wfp UNIV \\<pi>' \\<longrightarrow>\n       scon\n        {eqOnUC (length []) (Suc (length [])) u c |u c.\n         (u, c) \\<in> (UNIV - GH) \\<times> UNIV}\n        [\\<pi>, \\<pi>'] =\n       (\\<forall>u c.\n           u \\<notin> GH \\<longrightarrow>\n           (\\<exists>st. stateOf \\<pi> = State st u c) =\n           (\\<exists>st'. stateOf \\<pi>' = State st' u c)) \\<and>\n       scon\n        {eqOnUOut (length []) (Suc (length [])) u ou |u ou.\n         (u, ou) \\<in> GL \\<times> UNIV}\n        [\\<pi>, \\<pi>'] =\n       (\\<forall>u1.\n           u1 \\<in> GL \\<longrightarrow>\n           out (local.getGMState (stateOf \\<pi>)) u1 =\n           out (local.getGMState (stateOf \\<pi>')) u1)", "by (fastforce simp add: scon_def eqOnUC_0_Suc0)"], ["proof (state)\nthis:\n  wfp UNIV ?\\<pi>3 \\<and> wfp UNIV ?\\<pi>'3 \\<longrightarrow>\n  \\<phi> [] [?\\<pi>3, ?\\<pi>'3] =\n  f (stateOf ?\\<pi>3) (stateOf ?\\<pi>'3) \\<and>\n  \\<psi> [] [?\\<pi>3, ?\\<pi>'3] = g (stateOf ?\\<pi>3) (stateOf ?\\<pi>'3)\n\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "from fall2_imp_alw_index[of \\<phi> \\<psi>, OF this]"], ["proof (chain)\npicking this:\n  fall2\n   (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n       imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n        (\\<pi>l @ [\\<pi>, \\<pi>']))\n   [] =\n  (\\<forall>\\<pi> \\<pi>'.\n      wfp UNIV \\<pi> \\<and>\n      wfp UNIV \\<pi>' \\<and>\n      stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n      (\\<forall>i.\n          (\\<forall>j\\<le>i.\n              f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n          g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "show ?thesis"], ["proof (prove)\nusing this:\n  fall2\n   (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n       imp (alw (\\<phi> \\<pi>l)) (alw (\\<psi> \\<pi>l))\n        (\\<pi>l @ [\\<pi>, \\<pi>']))\n   [] =\n  (\\<forall>\\<pi> \\<pi>'.\n      wfp UNIV \\<pi> \\<and>\n      wfp UNIV \\<pi>' \\<and>\n      stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n      (\\<forall>i.\n          (\\<forall>j\\<le>i.\n              f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n          g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))\n\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonintSI", "unfolding nonintSfmla_def nonintSI_def \\<phi>_def \\<psi>_def"], ["proof (prove)\nusing this:\n  fall2\n   (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n       imp (alw (eqButGH (length \\<pi>l) (Suc (length \\<pi>l))))\n        (alw (eqOnGL (length \\<pi>l) (Suc (length \\<pi>l))))\n        (\\<pi>l @ [\\<pi>, \\<pi>']))\n   [] =\n  (\\<forall>\\<pi> \\<pi>'.\n      wfp UNIV \\<pi> \\<and>\n      wfp UNIV \\<pi>' \\<and>\n      stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n      (\\<forall>i.\n          (\\<forall>j\\<le>i.\n              f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n          g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))\n\ngoal (1 subgoal):\n 1. fall2\n     (\\<lambda>\\<pi>' \\<pi> \\<pi>l.\n         imp (alw (eqButGH (length \\<pi>l) (Suc (length \\<pi>l))))\n          (alw (eqOnGL (length \\<pi>l) (Suc (length \\<pi>l))))\n          (\\<pi>l @ [\\<pi>, \\<pi>']))\n     [] =\n    (\\<forall>\\<pi> \\<pi>'.\n        wfp UNIV \\<pi> \\<and>\n        wfp UNIV \\<pi>' \\<and>\n        stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n        (\\<forall>i.\n            (\\<forall>j\\<le>i.\n                f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n            g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))))", "."], ["proof (state)\nthis:\n  nonintSfmla [] = nonintSI\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>In turn, nonintSI will be shown equivalent to nonintS, a variant speaking about\nSynchronized finite paths. To this end, we introduce a notion of well-formed finite path (wffp) -- besides\nfiniteness, another difference from the previously defined infinite paths is that, thanks to\nthe fact that here AP coincides with AP', paths are mere sequences of states as opposed\nto pairs (state,set of atomic predicates).\\<close>"], ["", "inductive wffp :: \"('St,'U,'C) state list \\<Rightarrow> bool\"\nwhere\nSingl[simp,intro!]: \"wffp [s]\"\n|\nCons[intro]:\n\"\\<lbrakk>s' \\<in> \\<delta> s; wffp (s' # sl)\\<rbrakk>\n \\<Longrightarrow>\n wffp (s # s' # sl)\""], ["", "lemma wffp_induct2[consumes 1, case_names Singl Cons]:\nassumes \"wffp sl\"\nand \"\\<And> s. P [s]\"\nand \"\\<And> s sl. \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl; P sl\\<rbrakk> \\<Longrightarrow> P (s # sl)\"\nshows \"P sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P sl", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  P [?s3]\n  \\<lbrakk>hd ?sl3 \\<in> \\<delta> ?s3; wffp ?sl3; P ?sl3\\<rbrakk>\n  \\<Longrightarrow> P (?s3 # ?sl3)\n\ngoal (1 subgoal):\n 1. P sl", "by induct auto"], ["", "definition nonintS :: bool where\n\"nonintS \\<equiv>\n \\<forall> sl sl'. wffp sl \\<and> wffp sl' \\<and> hd sl = s0 \\<and> hd sl' = s0 \\<and>\n            list_all2 f sl sl' \\<longrightarrow> g (last sl) (last sl')\""], ["", "lemma wffp_NE: assumes \"wffp sl\" shows \"sl \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> []", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. sl \\<noteq> []", "by induct auto"], ["", "lemma wffp:\n\"wffp sl \\<longleftrightarrow> sl \\<noteq> [] \\<and> (\\<forall> i. Suc i < length sl \\<longrightarrow> sl!(Suc i) \\<in> \\<delta>(sl!i))\"\n(is \"?L \\<longleftrightarrow> ?A \\<and> (\\<forall> i. ?R i)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp sl =\n    (sl \\<noteq> [] \\<and>\n     (\\<forall>i.\n         Suc i < length sl \\<longrightarrow>\n         sl ! Suc i \\<in> \\<delta> (sl ! i)))", "proof (intro iffI allI conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. \\<And>i.\n       wffp sl \\<Longrightarrow>\n       Suc i < length sl \\<longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. \\<And>i.\n       wffp sl \\<Longrightarrow>\n       Suc i < length sl \\<longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "assume ?L"], ["proof (state)\nthis:\n  wffp sl\n\ngoal (3 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. \\<And>i.\n       wffp sl \\<Longrightarrow>\n       Suc i < length sl \\<longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "thus \"?R i\""], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. Suc i < length sl \\<longrightarrow> sl ! Suc i \\<in> \\<delta> (sl ! i)", "proof (induct arbitrary: i)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s i.\n       Suc i < length [s] \\<longrightarrow>\n       [s] ! Suc i \\<in> \\<delta> ([s] ! i)\n 2. \\<And>s' s sl i.\n       \\<lbrakk>s' \\<in> \\<delta> s; wffp (s' # sl);\n        \\<And>i.\n           Suc i < length (s' # sl) \\<longrightarrow>\n           (s' # sl) ! Suc i \\<in> \\<delta> ((s' # sl) ! i)\\<rbrakk>\n       \\<Longrightarrow> Suc i < length (s # s' # sl) \\<longrightarrow>\n                         (s # s' # sl) ! Suc i\n                         \\<in> \\<delta> ((s # s' # sl) ! i)", "case (Cons s' s sl i)"], ["proof (state)\nthis:\n  s' \\<in> \\<delta> s\n  wffp (s' # sl)\n  Suc ?i3 < length (s' # sl) \\<longrightarrow>\n  (s' # sl) ! Suc ?i3 \\<in> \\<delta> ((s' # sl) ! ?i3)\n\ngoal (2 subgoals):\n 1. \\<And>s i.\n       Suc i < length [s] \\<longrightarrow>\n       [s] ! Suc i \\<in> \\<delta> ([s] ! i)\n 2. \\<And>s' s sl i.\n       \\<lbrakk>s' \\<in> \\<delta> s; wffp (s' # sl);\n        \\<And>i.\n           Suc i < length (s' # sl) \\<longrightarrow>\n           (s' # sl) ! Suc i \\<in> \\<delta> ((s' # sl) ! i)\\<rbrakk>\n       \\<Longrightarrow> Suc i < length (s # s' # sl) \\<longrightarrow>\n                         (s # s' # sl) ! Suc i\n                         \\<in> \\<delta> ((s # s' # sl) ! i)", "thus ?case"], ["proof (prove)\nusing this:\n  s' \\<in> \\<delta> s\n  wffp (s' # sl)\n  Suc ?i3 < length (s' # sl) \\<longrightarrow>\n  (s' # sl) ! Suc ?i3 \\<in> \\<delta> ((s' # sl) ! ?i3)\n\ngoal (1 subgoal):\n 1. Suc i < length (s # s' # sl) \\<longrightarrow>\n    (s # s' # sl) ! Suc i \\<in> \\<delta> ((s # s' # sl) ! i)", "by(cases i) auto"], ["proof (state)\nthis:\n  Suc i < length (s # s' # sl) \\<longrightarrow>\n  (s # s' # sl) ! Suc i \\<in> \\<delta> ((s # s' # sl) ! i)\n\ngoal (1 subgoal):\n 1. \\<And>s i.\n       Suc i < length [s] \\<longrightarrow>\n       [s] ! Suc i \\<in> \\<delta> ([s] ! i)", "qed auto"], ["proof (state)\nthis:\n  Suc i < length sl \\<longrightarrow> sl ! Suc i \\<in> \\<delta> (sl ! i)\n\ngoal (2 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "assume \"?A \\<and> (\\<forall> i. ?R i)\""], ["proof (state)\nthis:\n  sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length sl \\<longrightarrow>\n      sl ! Suc i \\<in> \\<delta> (sl ! i))\n\ngoal (2 subgoals):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []\n 2. sl \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length sl \\<longrightarrow>\n        sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n    wffp sl", "thus ?L"], ["proof (prove)\nusing this:\n  sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length sl \\<longrightarrow>\n      sl ! Suc i \\<in> \\<delta> (sl ! i))\n\ngoal (1 subgoal):\n 1. wffp sl", "proof(induct sl)"], ["proof (state)\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length [] \\<longrightarrow>\n        [] ! Suc i \\<in> \\<delta> ([] ! i)) \\<Longrightarrow>\n    wffp []\n 2. \\<And>a sl.\n       \\<lbrakk>sl \\<noteq> [] \\<and>\n                (\\<forall>i.\n                    Suc i < length sl \\<longrightarrow>\n                    sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n                wffp sl;\n        a # sl \\<noteq> [] \\<and>\n        (\\<forall>i.\n            Suc i < length (a # sl) \\<longrightarrow>\n            (a # sl) ! Suc i \\<in> \\<delta> ((a # sl) ! i))\\<rbrakk>\n       \\<Longrightarrow> wffp (a # sl)", "case (Cons s sl)"], ["proof (state)\nthis:\n  sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length sl \\<longrightarrow>\n      sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n  wffp sl\n  s # sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length (s # sl) \\<longrightarrow>\n      (s # sl) ! Suc i \\<in> \\<delta> ((s # sl) ! i))\n\ngoal (2 subgoals):\n 1. [] \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length [] \\<longrightarrow>\n        [] ! Suc i \\<in> \\<delta> ([] ! i)) \\<Longrightarrow>\n    wffp []\n 2. \\<And>a sl.\n       \\<lbrakk>sl \\<noteq> [] \\<and>\n                (\\<forall>i.\n                    Suc i < length sl \\<longrightarrow>\n                    sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n                wffp sl;\n        a # sl \\<noteq> [] \\<and>\n        (\\<forall>i.\n            Suc i < length (a # sl) \\<longrightarrow>\n            (a # sl) ! Suc i \\<in> \\<delta> ((a # sl) ! i))\\<rbrakk>\n       \\<Longrightarrow> wffp (a # sl)", "thus ?case"], ["proof (prove)\nusing this:\n  sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length sl \\<longrightarrow>\n      sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n  wffp sl\n  s # sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length (s # sl) \\<longrightarrow>\n      (s # sl) ! Suc i \\<in> \\<delta> ((s # sl) ! i))\n\ngoal (1 subgoal):\n 1. wffp (s # sl)", "apply safe"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sl \\<noteq> [] \\<and>\n             (\\<forall>i.\n                 Suc i < length sl \\<longrightarrow>\n                 sl ! Suc i \\<in> \\<delta> (sl ! i)) \\<Longrightarrow>\n             wffp sl;\n     s # sl \\<noteq> [];\n     \\<forall>i.\n        Suc i < length (s # sl) \\<longrightarrow>\n        (s # sl) ! Suc i \\<in> \\<delta> ((s # sl) ! i)\\<rbrakk>\n    \\<Longrightarrow> wffp (s # sl)", "by (cases sl) (force intro!: wffp.intros)+"], ["proof (state)\nthis:\n  wffp (s # sl)\n\ngoal (1 subgoal):\n 1. [] \\<noteq> [] \\<and>\n    (\\<forall>i.\n        Suc i < length [] \\<longrightarrow>\n        [] ! Suc i \\<in> \\<delta> ([] ! i)) \\<Longrightarrow>\n    wffp []", "qed(auto intro: wffp.intros)"], ["proof (state)\nthis:\n  wffp sl\n\ngoal (1 subgoal):\n 1. wffp sl \\<Longrightarrow> sl \\<noteq> []", "qed (auto simp: wffp_NE)"], ["", "lemma wffp_hdI[intro]:\nassumes \"wffp sl\" and \"hd sl \\<in> \\<delta> s\"\nshows \"wffp (s # sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (s # sl)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. wffp (s # sl)", "by (cases sl) auto"], ["", "lemma wffp_append:\nassumes sl: \"wffp sl\" and sl1: \"wffp sl1\" and h: \"hd sl1 \\<in> \\<delta> (last sl)\"\nshows \"wffp (sl @ sl1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (sl @ sl1)", "using sl h"], ["proof (prove)\nusing this:\n  wffp sl\n  hd sl1 \\<in> \\<delta> (last sl)\n\ngoal (1 subgoal):\n 1. wffp (sl @ sl1)", "by (induct sl) (auto simp: sl1)"], ["", "lemma wffp_append_iff:\n\"wffp (sl @ sl1) \\<longleftrightarrow>\n (wffp sl \\<and> sl1 = []) \\<or>\n (sl = [] \\<and> wffp sl1) \\<or>\n (wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl))\"\n(is \"_ \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (sl @ sl1) =\n    (wffp sl \\<and> sl1 = [] \\<or>\n     sl = [] \\<and> wffp sl1 \\<or>\n     wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wffp (sl @ sl1) \\<Longrightarrow>\n    wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n 2. wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and>\n    wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl) \\<Longrightarrow>\n    wffp (sl @ sl1)", "assume \"wffp (sl @ sl1)\""], ["proof (state)\nthis:\n  wffp (sl @ sl1)\n\ngoal (2 subgoals):\n 1. wffp (sl @ sl1) \\<Longrightarrow>\n    wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n 2. wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and>\n    wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl) \\<Longrightarrow>\n    wffp (sl @ sl1)", "thus ?R"], ["proof (prove)\nusing this:\n  wffp (sl @ sl1)\n\ngoal (1 subgoal):\n 1. wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)", "proof(induction \"sl @ sl1\" arbitrary: sl sl1 rule: list.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sl sl1.\n       \\<lbrakk>[] = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n 2. \\<And>x1 x2 sl sl1.\n       \\<lbrakk>\\<And>sl sl1.\n                   \\<lbrakk>x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n                   \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                                     sl = [] \\<and> wffp sl1 \\<or>\n                                     wffp sl \\<and>\n                                     wffp sl1 \\<and>\n                                     hd sl1 \\<in> \\<delta> (last sl);\n        x1 # x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)", "case (Cons s sl sl1 sl2)"], ["proof (state)\nthis:\n  \\<lbrakk>sl = ?sl3 @ ?sl1.3; wffp (?sl3 @ ?sl1.3)\\<rbrakk>\n  \\<Longrightarrow> wffp ?sl3 \\<and> ?sl1.3 = [] \\<or>\n                    ?sl3 = [] \\<and> wffp ?sl1.3 \\<or>\n                    wffp ?sl3 \\<and>\n                    wffp ?sl1.3 \\<and> hd ?sl1.3 \\<in> \\<delta> (last ?sl3)\n  s # sl = sl1 @ sl2\n  wffp (sl1 @ sl2)\n\ngoal (2 subgoals):\n 1. \\<And>sl sl1.\n       \\<lbrakk>[] = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n 2. \\<And>x1 x2 sl sl1.\n       \\<lbrakk>\\<And>sl sl1.\n                   \\<lbrakk>x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n                   \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                                     sl = [] \\<and> wffp sl1 \\<or>\n                                     wffp sl \\<and>\n                                     wffp sl1 \\<and>\n                                     hd sl1 \\<in> \\<delta> (last sl);\n        x1 # x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)", "note C = Cons"], ["proof (state)\nthis:\n  \\<lbrakk>sl = ?sl3 @ ?sl1.3; wffp (?sl3 @ ?sl1.3)\\<rbrakk>\n  \\<Longrightarrow> wffp ?sl3 \\<and> ?sl1.3 = [] \\<or>\n                    ?sl3 = [] \\<and> wffp ?sl1.3 \\<or>\n                    wffp ?sl3 \\<and>\n                    wffp ?sl1.3 \\<and> hd ?sl1.3 \\<in> \\<delta> (last ?sl3)\n  s # sl = sl1 @ sl2\n  wffp (sl1 @ sl2)\n\ngoal (2 subgoals):\n 1. \\<And>sl sl1.\n       \\<lbrakk>[] = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n 2. \\<And>x1 x2 sl sl1.\n       \\<lbrakk>\\<And>sl sl1.\n                   \\<lbrakk>x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n                   \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                                     sl = [] \\<and> wffp sl1 \\<or>\n                                     wffp sl \\<and>\n                                     wffp sl1 \\<and>\n                                     hd sl1 \\<in> \\<delta> (last sl);\n        x1 # x2 = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "proof(cases \"sl1 = [] \\<or> sl2 = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sl1 = [] \\<or> sl2 = [] \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n 2. \\<not> (sl1 = [] \\<or> sl2 = []) \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "case False"], ["proof (state)\nthis:\n  \\<not> (sl1 = [] \\<or> sl2 = [])\n\ngoal (2 subgoals):\n 1. sl1 = [] \\<or> sl2 = [] \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n 2. \\<not> (sl1 = [] \\<or> sl2 = []) \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "then"], ["proof (chain)\npicking this:\n  \\<not> (sl1 = [] \\<or> sl2 = [])", "obtain sll1 where sl1: \"sl1 = s # sll1\" and sl : \"sl = sll1 @  sl2\""], ["proof (prove)\nusing this:\n  \\<not> (sl1 = [] \\<or> sl2 = [])\n\ngoal (1 subgoal):\n 1. (\\<And>sll1.\n        \\<lbrakk>sl1 = s # sll1; sl = sll1 @ sl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using C(2)"], ["proof (prove)\nusing this:\n  \\<not> (sl1 = [] \\<or> sl2 = [])\n  s # sl = sl1 @ sl2\n\ngoal (1 subgoal):\n 1. (\\<And>sll1.\n        \\<lbrakk>sl1 = s # sll1; sl = sll1 @ sl2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases sl1) auto"], ["proof (state)\nthis:\n  sl1 = s # sll1\n  sl = sll1 @ sl2\n\ngoal (2 subgoals):\n 1. sl1 = [] \\<or> sl2 = [] \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n 2. \\<not> (sl1 = [] \\<or> sl2 = []) \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "have wsl: \"wffp sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp sl", "by (metis C False append_is_Nil_conv list.inject sl wffp.simps)"], ["proof (state)\nthis:\n  wffp sl\n\ngoal (2 subgoals):\n 1. sl1 = [] \\<or> sl2 = [] \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n 2. \\<not> (sl1 = [] \\<or> sl2 = []) \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "using C(1)[OF sl, unfolded sl[symmetric], OF wsl]"], ["proof (prove)\nusing this:\n  wffp sll1 \\<and> sl2 = [] \\<or>\n  sll1 = [] \\<and> wffp sl2 \\<or>\n  wffp sll1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sll1)\n\ngoal (1 subgoal):\n 1. wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "by (metis (no_types) C False wffp_hdI append_is_Nil_conv list.sel(1) hd_append\n                last.simps list.inject sl sl1 wffp.simps)"], ["proof (state)\nthis:\n  wffp sl1 \\<and> sl2 = [] \\<or>\n  sl1 = [] \\<and> wffp sl2 \\<or>\n  wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n\ngoal (1 subgoal):\n 1. sl1 = [] \\<or> sl2 = [] \\<Longrightarrow>\n    wffp sl1 \\<and> sl2 = [] \\<or>\n    sl1 = [] \\<and> wffp sl2 \\<or>\n    wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)", "qed(insert C, auto)"], ["proof (state)\nthis:\n  wffp sl1 \\<and> sl2 = [] \\<or>\n  sl1 = [] \\<and> wffp sl2 \\<or>\n  wffp sl1 \\<and> wffp sl2 \\<and> hd sl2 \\<in> \\<delta> (last sl1)\n\ngoal (1 subgoal):\n 1. \\<And>sl sl1.\n       \\<lbrakk>[] = sl @ sl1; wffp (sl @ sl1)\\<rbrakk>\n       \\<Longrightarrow> wffp sl \\<and> sl1 = [] \\<or>\n                         sl = [] \\<and> wffp sl1 \\<or>\n                         wffp sl \\<and>\n                         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)", "qed auto"], ["proof (state)\nthis:\n  wffp sl \\<and> sl1 = [] \\<or>\n  sl = [] \\<and> wffp sl1 \\<or>\n  wffp sl \\<and> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl)\n\ngoal (1 subgoal):\n 1. wffp sl \\<and> sl1 = [] \\<or>\n    sl = [] \\<and> wffp sl1 \\<or>\n    wffp sl \\<and>\n    wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (last sl) \\<Longrightarrow>\n    wffp (sl @ sl1)", "qed (auto simp: wffp_append)"], ["", "lemma wffp_to_wfp:\nassumes \\<pi>_def: \"\\<pi> = map (\\<lambda> s. (s, L s)) sl @- sconst (toSink (last sl), L (toSink (last sl)))\"\nassumes sl: \"wffp sl\"\nshows\n\"wfp UNIV \\<pi> \\<and>\n (\\<forall> i < length sl. sl ! i = fst (\\<pi> !! i)) \\<and>\n (\\<forall> i \\<ge> length sl. fst (\\<pi> !! i) = toSink (last sl)) \\<and>\n stateOf \\<pi> = hd sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfp UNIV \\<pi> \\<and>\n    (\\<forall>i<length sl. sl ! i = fst (\\<pi> !! i)) \\<and>\n    (\\<forall>i\\<ge>length sl. fst (\\<pi> !! i) = toSink (last sl)) \\<and>\n    stateOf \\<pi> = hd sl", "unfolding wfp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        fst (\\<pi> !! i) \\<in> UNIV \\<and>\n        snd (\\<pi> !! i) \\<subseteq> UNIV \\<and>\n        snd (\\<pi> !! i) \\<inter> UNIV = L (fst (\\<pi> !! i)) \\<and>\n        fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))) \\<and>\n    (\\<forall>i<length sl. sl ! i = fst (\\<pi> !! i)) \\<and>\n    (\\<forall>i\\<ge>length sl. fst (\\<pi> !! i) = toSink (last sl)) \\<and>\n    stateOf \\<pi> = hd sl", "proof safe"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       \\<lbrakk>x \\<in> snd (\\<pi> !! i); x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> L (fst (\\<pi> !! i))\n 4. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 5. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 6. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 7. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 8. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 9. stateOf \\<pi> = hd sl", "fix i s"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       \\<lbrakk>x \\<in> snd (\\<pi> !! i); x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> L (fst (\\<pi> !! i))\n 4. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 5. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 6. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 7. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 8. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 9. stateOf \\<pi> = hd sl", "{"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       \\<lbrakk>x \\<in> snd (\\<pi> !! i); x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> L (fst (\\<pi> !! i))\n 4. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 5. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 6. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 7. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 8. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 9. stateOf \\<pi> = hd sl", "assume \"s \\<in> snd (\\<pi> !! i)\""], ["proof (state)\nthis:\n  s \\<in> snd (\\<pi> !! i)\n\ngoal (9 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       \\<lbrakk>x \\<in> snd (\\<pi> !! i); x \\<in> UNIV\\<rbrakk>\n       \\<Longrightarrow> x \\<in> L (fst (\\<pi> !! i))\n 4. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 5. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 6. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 7. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 8. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 9. stateOf \\<pi> = hd sl", "thus \"s \\<in> L (fst (\\<pi> !! i))\""], ["proof (prove)\nusing this:\n  s \\<in> snd (\\<pi> !! i)\n\ngoal (1 subgoal):\n 1. s \\<in> L (fst (\\<pi> !! i))", "unfolding \\<pi>_def wffp"], ["proof (prove)\nusing this:\n  s \\<in> snd ((map (\\<lambda>s. (s, L s)) sl @-\n                sconst (toSink (last sl), L (toSink (last sl)))) !!\n               i)\n\ngoal (1 subgoal):\n 1. s \\<in> L (fst ((map (\\<lambda>s. (s, L s)) sl @-\n                     sconst (toSink (last sl), L (toSink (last sl)))) !!\n                    i))", "by (cases \"i < length sl\") auto"], ["proof (state)\nthis:\n  s \\<in> L (fst (\\<pi> !! i))\n\ngoal (8 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 4. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 5. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 6. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 7. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 8. stateOf \\<pi> = hd sl", "}"], ["proof (state)\nthis:\n  s \\<in> snd (\\<pi> !! i) \\<Longrightarrow> s \\<in> L (fst (\\<pi> !! i))\n\ngoal (8 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 4. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 5. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 6. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 7. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 8. stateOf \\<pi> = hd sl", "{"], ["proof (state)\nthis:\n  s \\<in> snd (\\<pi> !! i) \\<Longrightarrow> s \\<in> L (fst (\\<pi> !! i))\n\ngoal (8 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 4. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 5. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 6. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 7. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 8. stateOf \\<pi> = hd sl", "assume \"s \\<in> L (fst (\\<pi> !! i))\""], ["proof (state)\nthis:\n  s \\<in> L (fst (\\<pi> !! i))\n\ngoal (8 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x.\n       x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow>\n       x \\<in> snd (\\<pi> !! i)\n 4. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 5. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 6. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 7. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 8. stateOf \\<pi> = hd sl", "thus \"s \\<in> snd (\\<pi> !! i)\""], ["proof (prove)\nusing this:\n  s \\<in> L (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. s \\<in> snd (\\<pi> !! i)", "unfolding \\<pi>_def wffp"], ["proof (prove)\nusing this:\n  s \\<in> L (fst ((map (\\<lambda>s. (s, L s)) sl @-\n                   sconst (toSink (last sl), L (toSink (last sl)))) !!\n                  i))\n\ngoal (1 subgoal):\n 1. s \\<in> snd ((map (\\<lambda>s. (s, L s)) sl @-\n                  sconst (toSink (last sl), L (toSink (last sl)))) !!\n                 i)", "by (cases \"i < length sl\") auto"], ["proof (state)\nthis:\n  s \\<in> snd (\\<pi> !! i)\n\ngoal (7 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 6. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 7. stateOf \\<pi> = hd sl", "}"], ["proof (state)\nthis:\n  s \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> s \\<in> snd (\\<pi> !! i)\n\ngoal (7 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 6. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 7. stateOf \\<pi> = hd sl", "{"], ["proof (state)\nthis:\n  s \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> s \\<in> snd (\\<pi> !! i)\n\ngoal (7 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 6. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 7. stateOf \\<pi> = hd sl", "fix j"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 6. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 7. stateOf \\<pi> = hd sl", "assume \"j < length sl\""], ["proof (state)\nthis:\n  j < length sl\n\ngoal (7 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i. i < length sl \\<Longrightarrow> sl ! i = fst (\\<pi> !! i)\n 6. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 7. stateOf \\<pi> = hd sl", "thus \"sl!j = fst (\\<pi> !! j)\""], ["proof (prove)\nusing this:\n  j < length sl\n\ngoal (1 subgoal):\n 1. sl ! j = fst (\\<pi> !! j)", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  j < length sl\n\ngoal (1 subgoal):\n 1. sl ! j =\n    fst ((map (\\<lambda>s. (s, L s)) sl @-\n          sconst (toSink (last sl), L (toSink (last sl)))) !!\n         j)", "apply (cases sl, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>j < length sl; sl = a # list\\<rbrakk>\n       \\<Longrightarrow> sl ! j =\n                         fst ((map (\\<lambda>s. (s, L s)) sl @-\n                               sconst\n                                (toSink (last sl), L (toSink (last sl)))) !!\n                              j)", "by (cases j) auto"], ["proof (state)\nthis:\n  sl ! j = fst (\\<pi> !! j)\n\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "}"], ["proof (state)\nthis:\n  ?j5 < length sl \\<Longrightarrow> sl ! ?j5 = fst (\\<pi> !! ?j5)\n\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "note 1 = this"], ["proof (state)\nthis:\n  ?j5 < length sl \\<Longrightarrow> sl ! ?j5 = fst (\\<pi> !! ?j5)\n\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "{"], ["proof (state)\nthis:\n  ?j5 < length sl \\<Longrightarrow> sl ! ?j5 = fst (\\<pi> !! ?j5)\n\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "fix j"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "assume \"j \\<ge> length sl\""], ["proof (state)\nthis:\n  length sl \\<le> j\n\ngoal (6 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. \\<And>i.\n       length sl \\<le> i \\<Longrightarrow>\n       fst (\\<pi> !! i) = toSink (last sl)\n 6. stateOf \\<pi> = hd sl", "thus \"fst (\\<pi> !! j) = toSink (last sl)\""], ["proof (prove)\nusing this:\n  length sl \\<le> j\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! j) = toSink (last sl)", "using sl"], ["proof (prove)\nusing this:\n  length sl \\<le> j\n  wffp sl\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! j) = toSink (last sl)", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  length sl \\<le> j\n  wffp sl\n\ngoal (1 subgoal):\n 1. fst ((map (\\<lambda>s. (s, L s)) sl @-\n          sconst (toSink (last sl), L (toSink (last sl)))) !!\n         j) =\n    toSink (last sl)", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi> !! j) = toSink (last sl)\n\ngoal (5 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. stateOf \\<pi> = hd sl", "}"], ["proof (state)\nthis:\n  length sl \\<le> ?j5 \\<Longrightarrow>\n  fst (\\<pi> !! ?j5) = toSink (last sl)\n\ngoal (5 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. stateOf \\<pi> = hd sl", "note 2 = this"], ["proof (state)\nthis:\n  length sl \\<le> ?j5 \\<Longrightarrow>\n  fst (\\<pi> !! ?j5) = toSink (last sl)\n\ngoal (5 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. \\<And>i. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 5. stateOf \\<pi> = hd sl", "show \"fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "proof(cases \"length sl \\<le> Suc i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "case False"], ["proof (state)\nthis:\n  \\<not> length sl \\<le> Suc i\n\ngoal (2 subgoals):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "hence \"Suc i < length sl\""], ["proof (prove)\nusing this:\n  \\<not> length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. Suc i < length sl", "by simp"], ["proof (state)\nthis:\n  Suc i < length sl\n\ngoal (2 subgoals):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "hence \"fst (\\<pi> !! Suc i) = sl!(Suc i) \\<and> fst (\\<pi> !! i) = sl!i\""], ["proof (prove)\nusing this:\n  Suc i < length sl\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i", "using 1"], ["proof (prove)\nusing this:\n  Suc i < length sl\n  ?j5 < length sl \\<Longrightarrow> sl ! ?j5 = fst (\\<pi> !! ?j5)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i", "by fastforce"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i\n\ngoal (2 subgoals):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "using sl False"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i\n  wffp sl\n  \\<not> length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "unfolding wffp"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! Suc i) = sl ! Suc i \\<and> fst (\\<pi> !! i) = sl ! i\n  sl \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length sl \\<longrightarrow>\n      sl ! Suc i \\<in> \\<delta> (sl ! i))\n  \\<not> length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "case True"], ["proof (state)\nthis:\n  length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "note sl = True"], ["proof (state)\nthis:\n  length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "hence 22: \"fst (\\<pi> !! Suc i) = toSink (last sl)\""], ["proof (prove)\nusing this:\n  length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) = toSink (last sl)", "using 2"], ["proof (prove)\nusing this:\n  length sl \\<le> Suc i\n  length sl \\<le> ?j5 \\<Longrightarrow>\n  fst (\\<pi> !! ?j5) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) = toSink (last sl)", "by blast"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. length sl \\<le> Suc i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "proof(cases \"length sl \\<le> i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "case True"], ["proof (state)\nthis:\n  length sl \\<le> i\n\ngoal (2 subgoals):\n 1. length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "hence \"fst (\\<pi> !! i) = toSink (last sl)\""], ["proof (prove)\nusing this:\n  length sl \\<le> i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) = toSink (last sl)", "using 2"], ["proof (prove)\nusing this:\n  length sl \\<le> i\n  length sl \\<le> ?j5 \\<Longrightarrow>\n  fst (\\<pi> !! ?j5) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) = toSink (last sl)", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi> !! i) = toSink (last sl)\n\ngoal (2 subgoals):\n 1. length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n 2. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! i) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "using 22"], ["proof (prove)\nusing this:\n  fst (\\<pi> !! i) = toSink (last sl)\n  fst (\\<pi> !! Suc i) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "by (metis IntD2 Sink_idle UNIV_I toSink)"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "case False"], ["proof (state)\nthis:\n  \\<not> length sl \\<le> i\n\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "hence \"last sl = sl!i\""], ["proof (prove)\nusing this:\n  \\<not> length sl \\<le> i\n\ngoal (1 subgoal):\n 1. last sl = sl ! i", "using sl"], ["proof (prove)\nusing this:\n  \\<not> length sl \\<le> i\n  length sl \\<le> Suc i\n\ngoal (1 subgoal):\n 1. last sl = sl ! i", "by (metis Suc_eq_plus1 diff_add_inverse2 last_conv_nth le0 le_Suc_eq length_0_conv)"], ["proof (state)\nthis:\n  last sl = sl ! i\n\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "moreover"], ["proof (state)\nthis:\n  last sl = sl ! i\n\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "have \"fst (\\<pi> !! i) = sl!i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) = sl ! i", "using False 1"], ["proof (prove)\nusing this:\n  \\<not> length sl \\<le> i\n  ?j5 < length sl \\<Longrightarrow> sl ! ?j5 = fst (\\<pi> !! ?j5)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! i) = sl ! i", "by auto"], ["proof (state)\nthis:\n  fst (\\<pi> !! i) = sl ! i\n\ngoal (1 subgoal):\n 1. \\<not> length sl \\<le> i \\<Longrightarrow>\n    fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "ultimately"], ["proof (chain)\npicking this:\n  last sl = sl ! i\n  fst (\\<pi> !! i) = sl ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  last sl = sl ! i\n  fst (\\<pi> !! i) = sl ! i\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "using 22"], ["proof (prove)\nusing this:\n  last sl = sl ! i\n  fst (\\<pi> !! i) = sl ! i\n  fst (\\<pi> !! Suc i) = toSink (last sl)\n\ngoal (1 subgoal):\n 1. fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))", "by (metis IntD1 UNIV_I toSink)"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fst (\\<pi> !! Suc i) \\<in> \\<delta> (fst (\\<pi> !! i))\n\ngoal (4 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV\n 4. stateOf \\<pi> = hd sl", "show \"stateOf \\<pi> = hd sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stateOf \\<pi> = hd sl", "using wffp_NE[OF sl]"], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. stateOf \\<pi> = hd sl", "unfolding \\<pi>_def"], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. stateOf\n     (map (\\<lambda>s. (s, L s)) sl @-\n      sconst (toSink (last sl), L (toSink (last sl)))) =\n    hd sl", "by (cases sl) auto"], ["proof (state)\nthis:\n  stateOf \\<pi> = hd sl\n\ngoal (3 subgoals):\n 1. \\<And>i. fst (\\<pi> !! i) \\<in> UNIV\n 2. \\<And>i x. x \\<in> snd (\\<pi> !! i) \\<Longrightarrow> x \\<in> UNIV\n 3. \\<And>i x. x \\<in> L (fst (\\<pi> !! i)) \\<Longrightarrow> x \\<in> UNIV", "qed auto"], ["", "lemma wffp_imp_appendL: \"wffp (sl1 @ sl2) \\<Longrightarrow> sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wffp (sl1 @ sl2); sl1 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wffp sl1", "by (metis wffp_append_iff)"], ["", "lemma wffp_imp_appendR: \"wffp (sl1 @ sl2) \\<Longrightarrow> sl2 \\<noteq> [] \\<Longrightarrow> wffp sl2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wffp (sl1 @ sl2); sl2 \\<noteq> []\\<rbrakk>\n    \\<Longrightarrow> wffp sl2", "by (metis wffp_append_iff)"], ["", "lemma wffp_iff_map_Idle:\nassumes \"wffp sl\"\nshows\n\"\\<exists> n st.\n   (n > 0 \\<and> sl = map Idle (replicate n st)) \\<or>\n   (\\<exists> st1 u1 c1 sl1. sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "proof (induction rule: wffp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "case (Singl s)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "proof (cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (Idle st)"], ["proof (state)\nthis:\n  s = Idle st\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "unfolding Idle"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n sta.\n       0 < n \\<and> [Idle st] = map Idle (replicate n sta) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           [Idle st] = map Idle (replicate n sta) @ [State st1 u1 c1] @ sl1)", "by (intro exI[of _ \"Suc 0\"] exI[of _ st]) auto"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (State st1 u1 c1)"], ["proof (state)\nthis:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "unfolding State"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> [State st1 u1 c1] = map Idle (replicate n st) \\<or>\n       (\\<exists>st1a u1a c1a sl1.\n           [State st1 u1 c1] =\n           map Idle (replicate n st) @ [State st1a u1a c1a] @ sl1)", "by (intro exI[of _ 0] exI[of _ st]) auto"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> [s] = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         [s] = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "case (Cons s sl)"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  \\<exists>n st.\n     0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "{"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  \\<exists>n st.\n     0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "fix n st"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "assume n: \"n > 0\" and sl: \"sl = map Idle (replicate n st)\""], ["proof (state)\nthis:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "then"], ["proof (chain)\npicking this:\n  0 < n\n  sl = map Idle (replicate n st)", "obtain n' where n: \"n = Suc n'\""], ["proof (prove)\nusing this:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (1 subgoal):\n 1. (\\<And>n'. n = Suc n' \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (cases n) auto"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "hence sl': \"sl = (Idle st) # map Idle (replicate n' st)\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. sl = Idle st # map Idle (replicate n' st)", "using sl"], ["proof (prove)\nusing this:\n  n = Suc n'\n  sl = map Idle (replicate n st)\n\ngoal (1 subgoal):\n 1. sl = Idle st # map Idle (replicate n' st)", "by auto"], ["proof (state)\nthis:\n  sl = Idle st # map Idle (replicate n' st)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "proof(cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (Idle st1)"], ["proof (state)\nthis:\n  s = Idle st1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "have st1: \"st1 = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st1 = st", "using \\<open>hd sl \\<in> \\<delta> s\\<close>"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. st1 = st", "unfolding sl' Idle"], ["proof (prove)\nusing this:\n  hd (Idle st # map Idle (replicate n' st)) \\<in> \\<delta> (Idle st1)\n\ngoal (1 subgoal):\n 1. st1 = st", "by auto"], ["proof (state)\nthis:\n  st1 = st\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "apply (intro exI[of _ \"Suc n\"] exI[of _ st])"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Suc n \\<and> s # sl = map Idle (replicate (Suc n) st) \\<or>\n    (\\<exists>st1 u1 c1 sl1.\n        s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1)", "using n"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. 0 < Suc n \\<and> s # sl = map Idle (replicate (Suc n) st) \\<or>\n    (\\<exists>st1 u1 c1 sl1.\n        s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1)", "unfolding sl Idle st1"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. 0 < Suc n \\<and>\n    Idle st # map Idle (replicate n st) =\n    map Idle (replicate (Suc n) st) \\<or>\n    (\\<exists>st1 u1 c1 sl1.\n        Idle st # map Idle (replicate n st) =\n        map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (State st1 u1 c1)"], ["proof (state)\nthis:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "hence \"s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\""], ["proof (prove)\nusing this:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl", "by simp"], ["proof (state)\nthis:\n  s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "fix n st st1 u1 c1 sl1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "assume sl: \"sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\""], ["proof (state)\nthis:\n  sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "proof(cases s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (Idle st2)"], ["proof (state)\nthis:\n  s = Idle st2\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       s = Idle x1 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "have \"s # sl = map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s # sl = map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1", "unfolding sl Idle 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Idle st2 # map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl1 =\n    map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1", "by simp"], ["proof (state)\nthis:\n  s # sl = map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow>\n    \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n 2. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s # sl = map Idle (replicate (Suc 0) st2) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "hence sl': \"sl = (Idle st) # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. sl = Idle st # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1", "using sl"], ["proof (prove)\nusing this:\n  n = Suc n'\n  sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. sl = Idle st # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1", "by auto"], ["proof (state)\nthis:\n  sl = Idle st # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "have st2: \"st2 = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2 = st", "using \\<open>hd sl \\<in> \\<delta> s\\<close>"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. st2 = st", "unfolding sl' Idle"], ["proof (prove)\nusing this:\n  hd (Idle st # map Idle (replicate n' st) @ [State st1 u1 c1] @ sl1)\n  \\<in> \\<delta> (Idle st2)\n\ngoal (1 subgoal):\n 1. st2 = st", "by auto"], ["proof (state)\nthis:\n  st2 = st\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "have \"s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1", "unfolding sl Idle st2"], ["proof (prove)\ngoal (1 subgoal):\n 1. Idle st # map Idle (replicate n st) @ [State st1 u1 c1] @ sl1 =\n    map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1", "by auto"], ["proof (state)\nthis:\n  s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<And>nat.\n       n = Suc nat \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s # sl = map Idle (replicate (Suc n) st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "case (State st1 u1 c1)"], ["proof (state)\nthis:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "hence \"s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\""], ["proof (prove)\nusing this:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl", "by simp"], ["proof (state)\nthis:\n  s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       s = State x21 x22 x23 \\<Longrightarrow>\n       \\<exists>n st.\n          0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n          (\\<exists>st1 u1 c1 sl1.\n              s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  s # sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "by blast"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "}"], ["proof (state)\nthis:\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<exists>n st.\n           0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n           (\\<exists>st1 u1 c1 sl1.\n               sl =\n               map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and>\n                            s # sl = map Idle (replicate n st) \\<or>\n                            (\\<exists>st1 u1 c1 sl1.\n                                s # sl =\n                                map Idle (replicate n st) @\n                                [State st1 u1 c1] @ sl1)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "using Cons(3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>n st.\n                       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n                       (\\<exists>st1 u1 c1 sl1.\n                           s # sl =\n                           map Idle (replicate n st) @\n                           [State st1 u1 c1] @ sl1)\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n  \\<exists>n st.\n     0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. \\<exists>n st.\n       0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n       (\\<exists>st1 u1 c1 sl1.\n           s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)", "by auto"], ["proof (state)\nthis:\n  \\<exists>n st.\n     0 < n \\<and> s # sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         s # sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_cases3[elim, consumes 1, case_names Idle State Idle_State]:\nassumes \"wffp sl\"\nobtains\nn st where\n\"n > 0\" and \"sl = map Idle (replicate n st)\"\n|\nst u c sl1 where\n\"sl = State st u c # sl1\" and \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\"\n|\nn st u c sl1 where\n\"n > 0\" and \"sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1\"\nand \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State (do st u c) u c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "fix n st"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume n: \"n > 0\" and sl: \"sl = map Idle (replicate n st)\""], ["proof (state)\nthis:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence thesis"], ["proof (prove)\nusing this:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  0 < n\n  sl = map Idle (replicate n st)\n  \\<lbrakk>0 < ?n3; sl = map Idle (replicate ?n3 ?st3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>sl = State ?st3 ?u3 ?c3 # ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and> hd ?sl1.3 \\<in> \\<delta> (State ?st3 ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>0 < ?n3;\n   sl =\n   map Idle (replicate ?n3 ?st3) @\n   [State (do ?st3 ?u3 ?c3) ?u3 ?c3] @ ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and>\n   hd ?sl1.3 \\<in> \\<delta> (State (do ?st3 ?u3 ?c3) ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "{"], ["proof (state)\nthis:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "fix n st st1 u1 c1 sl1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume sl: \"sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\""], ["proof (state)\nthis:\n  sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have 1: \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u1 c1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl1 \\<noteq> [] \\<Longrightarrow>\n    wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u1 c1)", "by (metis append_is_Nil_conv assms last.simps not_Cons_self2 sl wffp_append_iff)"], ["proof (state)\nthis:\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u1 c1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "have thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof(cases n)"], ["proof (state)\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "case 0"], ["proof (state)\nthis:\n  n = 0\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "have \"sl = State st1 u1 c1 # sl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl = State st1 u1 c1 # sl1", "using sl"], ["proof (prove)\nusing this:\n  sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. sl = State st1 u1 c1 # sl1", "unfolding 0"], ["proof (prove)\nusing this:\n  sl = map Idle (replicate 0 st) @ [State st1 u1 c1] @ sl1\n\ngoal (1 subgoal):\n 1. sl = State st1 u1 c1 # sl1", "by auto"], ["proof (state)\nthis:\n  sl = State st1 u1 c1 # sl1\n\ngoal (2 subgoals):\n 1. n = 0 \\<Longrightarrow> thesis\n 2. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "thus thesis"], ["proof (prove)\nusing this:\n  sl = State st1 u1 c1 # sl1\n\ngoal (1 subgoal):\n 1. thesis", "using that 1"], ["proof (prove)\nusing this:\n  sl = State st1 u1 c1 # sl1\n  \\<lbrakk>0 < ?n3; sl = map Idle (replicate ?n3 ?st3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>sl = State ?st3 ?u3 ?c3 # ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and> hd ?sl1.3 \\<in> \\<delta> (State ?st3 ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>0 < ?n3;\n   sl =\n   map Idle (replicate ?n3 ?st3) @\n   [State (do ?st3 ?u3 ?c3) ?u3 ?c3] @ ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and>\n   hd ?sl1.3 \\<in> \\<delta> (State (do ?st3 ?u3 ?c3) ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u1 c1)\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "case (Suc n')"], ["proof (state)\nthis:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "hence 2: \"replicate n st = replicate n' st @ [st]\""], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. replicate n st = replicate n' st @ [st]", "by (metis replicate_Suc replicate_append_same)"], ["proof (state)\nthis:\n  replicate n st = replicate n' st @ [st]\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "have \"wffp (map Idle [st] @ [State st1 u1 c1])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (map Idle [st] @ [State st1 u1 c1])", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. wffp (map Idle [st] @ [State st1 u1 c1])", "unfolding sl 2"], ["proof (prove)\nusing this:\n  wffp (map Idle (replicate n' st @ [st]) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. wffp (map Idle [st] @ [State st1 u1 c1])", "unfolding map_append append_assoc"], ["proof (prove)\nusing this:\n  wffp\n   (map Idle (replicate n' st) @ map Idle [st] @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. wffp (map Idle [st] @ [State st1 u1 c1])", "by (metis (no_types) append_assoc append_is_Nil_conv append_self_conv\n                 append_singl_rev neq_Nil_conv wffp_imp_appendL wffp_imp_appendR)"], ["proof (state)\nthis:\n  wffp (map Idle [st] @ [State st1 u1 c1])\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "hence st1: \"st1 = do st u1 c1\""], ["proof (prove)\nusing this:\n  wffp (map Idle [st] @ [State st1 u1 c1])\n\ngoal (1 subgoal):\n 1. st1 = do st u1 c1", "by (auto elim!: wffp.cases)"], ["proof (state)\nthis:\n  st1 = do st u1 c1\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "have \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using Suc"], ["proof (prove)\nusing this:\n  n = Suc n'\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<And>nat. n = Suc nat \\<Longrightarrow> thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. thesis", "using that 1"], ["proof (prove)\nusing this:\n  0 < n\n  \\<lbrakk>0 < ?n3; sl = map Idle (replicate ?n3 ?st3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>sl = State ?st3 ?u3 ?c3 # ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and> hd ?sl1.3 \\<in> \\<delta> (State ?st3 ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>0 < ?n3;\n   sl =\n   map Idle (replicate ?n3 ?st3) @\n   [State (do ?st3 ?u3 ?c3) ?u3 ?c3] @ ?sl1.3;\n   ?sl1.3 \\<noteq> [] \\<Longrightarrow>\n   wffp ?sl1.3 \\<and>\n   hd ?sl1.3 \\<in> \\<delta> (State (do ?st3 ?u3 ?c3) ?u3 ?c3)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u1 c1)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis sl st1)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "}"], ["proof (state)\nthis:\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>st u c sl1.\n        \\<lbrakk>sl = State st u c # sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n        \\<Longrightarrow> thesis;\n     \\<And>n st u c sl1.\n        \\<lbrakk>0 < n;\n         sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and>\n         hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  thesis", "show thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "using wffp_iff_map_Idle[OF assms]"], ["proof (prove)\nusing this:\n  \\<lbrakk>0 < ?n5; sl = map Idle (replicate ?n5 ?st5)\\<rbrakk>\n  \\<Longrightarrow> thesis\n  sl =\n  map Idle (replicate ?n5 ?st5) @\n  [State ?st1.5 ?u1.5 ?c1.5] @ ?sl1.5 \\<Longrightarrow>\n  thesis\n  \\<exists>n st.\n     0 < n \\<and> sl = map Idle (replicate n st) \\<or>\n     (\\<exists>st1 u1 c1 sl1.\n         sl = map Idle (replicate n st) @ [State st1 u1 c1] @ sl1)\n\ngoal (1 subgoal):\n 1. thesis", "by auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_cases2[elim, consumes 1, case_names Idle State]:\nassumes \"wffp sl\"\nobtains\nn st where\n\"n > 0\" and \"sl = map Idle (replicate n st)\"\n|\nn st st1 u c sl1 where\n\"sl = map Idle (replicate n st) @ [State st1 u c] @ sl1\"\nand \"sl1 \\<noteq> [] \\<Longrightarrow> wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>n st st1 u c sl1.\n        \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>n st.\n                \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     \\<And>n st st1 u c sl1.\n        \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n         sl1 \\<noteq> [] \\<Longrightarrow>\n         wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply(cases sl rule: wffp_cases3)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>st u c sl1.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>n st u c sl1.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>st u c sl1.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>n st u c sl1.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis append_Cons append_Nil list.map(1) replicate_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n st u c sl1.\n       \\<lbrakk>\\<And>n st.\n                   \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        \\<And>n st st1 u c sl1.\n           \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n            sl1 \\<noteq> [] \\<Longrightarrow>\n            wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (metis append_Cons append_Nil)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wffp_Idle_Idle:\nassumes \"wffp (sl1 @ [Idle st1] @ [Idle st2] @ sl2)\"\nshows \"st2 = st1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2 = st1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. st2 = st1", "have \"wffp [Idle st1, Idle st2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp [Idle st1, Idle st2]", "using assms"], ["proof (prove)\nusing this:\n  wffp (sl1 @ [Idle st1] @ [Idle st2] @ sl2)\n\ngoal (1 subgoal):\n 1. wffp [Idle st1, Idle st2]", "by (metis wffp_imp_appendR append_assoc append_singl_rev list.distinct(1) wffp_imp_appendL)"], ["proof (state)\nthis:\n  wffp [Idle st1, Idle st2]\n\ngoal (1 subgoal):\n 1. st2 = st1", "thus ?thesis"], ["proof (prove)\nusing this:\n  wffp [Idle st1, Idle st2]\n\ngoal (1 subgoal):\n 1. st2 = st1", "unfolding wffp"], ["proof (prove)\nusing this:\n  [Idle st1, Idle st2] \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length [Idle st1, Idle st2] \\<longrightarrow>\n      [Idle st1, Idle st2] ! Suc i\n      \\<in> \\<delta> ([Idle st1, Idle st2] ! i))\n\ngoal (1 subgoal):\n 1. st2 = st1", "by auto"], ["proof (state)\nthis:\n  st2 = st1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_Idle_State:\nassumes \"wffp (sl1 @ [Idle st1] @ [State st2 u2 c2] @ sl2)\"\nshows \"st2 = st1 \\<or> st2 = do st1 u2 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2 = st1 \\<or> st2 = do st1 u2 c2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. st2 = st1 \\<or> st2 = do st1 u2 c2", "have \"wffp [Idle st1, State st2 u2 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp [Idle st1, State st2 u2 c2]", "using assms"], ["proof (prove)\nusing this:\n  wffp (sl1 @ [Idle st1] @ [State st2 u2 c2] @ sl2)\n\ngoal (1 subgoal):\n 1. wffp [Idle st1, State st2 u2 c2]", "by (metis wffp_imp_appendR append_assoc append_singl_rev list.distinct(1) wffp_imp_appendL)"], ["proof (state)\nthis:\n  wffp [Idle st1, State st2 u2 c2]\n\ngoal (1 subgoal):\n 1. st2 = st1 \\<or> st2 = do st1 u2 c2", "thus ?thesis"], ["proof (prove)\nusing this:\n  wffp [Idle st1, State st2 u2 c2]\n\ngoal (1 subgoal):\n 1. st2 = st1 \\<or> st2 = do st1 u2 c2", "unfolding wffp"], ["proof (prove)\nusing this:\n  [Idle st1, State st2 u2 c2] \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length [Idle st1, State st2 u2 c2] \\<longrightarrow>\n      [Idle st1, State st2 u2 c2] ! Suc i\n      \\<in> \\<delta> ([Idle st1, State st2 u2 c2] ! i))\n\ngoal (1 subgoal):\n 1. st2 = st1 \\<or> st2 = do st1 u2 c2", "by auto"], ["proof (state)\nthis:\n  st2 = st1 \\<or> st2 = do st1 u2 c2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_State_Idle:\nassumes \"wffp (sl1 @ [State st1 u1 c1] @ [Idle st2] @ sl2)\"\nshows \"st2 = st1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2 = st1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. st2 = st1", "have \"wffp [State st1 u1 c1, Idle st2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp [State st1 u1 c1, Idle st2]", "using assms"], ["proof (prove)\nusing this:\n  wffp (sl1 @ [State st1 u1 c1] @ [Idle st2] @ sl2)\n\ngoal (1 subgoal):\n 1. wffp [State st1 u1 c1, Idle st2]", "by (metis wffp_imp_appendR append_assoc append_singl_rev list.distinct(1) wffp_imp_appendL)"], ["proof (state)\nthis:\n  wffp [State st1 u1 c1, Idle st2]\n\ngoal (1 subgoal):\n 1. st2 = st1", "thus ?thesis"], ["proof (prove)\nusing this:\n  wffp [State st1 u1 c1, Idle st2]\n\ngoal (1 subgoal):\n 1. st2 = st1", "unfolding wffp"], ["proof (prove)\nusing this:\n  [State st1 u1 c1, Idle st2] \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length [State st1 u1 c1, Idle st2] \\<longrightarrow>\n      [State st1 u1 c1, Idle st2] ! Suc i\n      \\<in> \\<delta> ([State st1 u1 c1, Idle st2] ! i))\n\ngoal (1 subgoal):\n 1. st2 = st1", "by auto"], ["proof (state)\nthis:\n  st2 = st1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_State_State:\nassumes \"wffp (sl1 @ [State st1 u1 c1] @ [State st2 u2 c2] @ sl2)\"\nshows \"st2 = do st1 u2 c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. st2 = do st1 u2 c2", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. st2 = do st1 u2 c2", "have \"wffp [State st1 u1 c1, State st2 u2 c2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp [State st1 u1 c1, State st2 u2 c2]", "using assms"], ["proof (prove)\nusing this:\n  wffp (sl1 @ [State st1 u1 c1] @ [State st2 u2 c2] @ sl2)\n\ngoal (1 subgoal):\n 1. wffp [State st1 u1 c1, State st2 u2 c2]", "by (metis wffp_imp_appendR append_assoc append_singl_rev list.distinct(1) wffp_imp_appendL)"], ["proof (state)\nthis:\n  wffp [State st1 u1 c1, State st2 u2 c2]\n\ngoal (1 subgoal):\n 1. st2 = do st1 u2 c2", "thus ?thesis"], ["proof (prove)\nusing this:\n  wffp [State st1 u1 c1, State st2 u2 c2]\n\ngoal (1 subgoal):\n 1. st2 = do st1 u2 c2", "unfolding wffp"], ["proof (prove)\nusing this:\n  [State st1 u1 c1, State st2 u2 c2] \\<noteq> [] \\<and>\n  (\\<forall>i.\n      Suc i < length [State st1 u1 c1, State st2 u2 c2] \\<longrightarrow>\n      [State st1 u1 c1, State st2 u2 c2] ! Suc i\n      \\<in> \\<delta> ([State st1 u1 c1, State st2 u2 c2] ! i))\n\ngoal (1 subgoal):\n 1. st2 = do st1 u2 c2", "by auto"], ["proof (state)\nthis:\n  st2 = do st1 u2 c2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wfp_to_wffp:\nassumes sl_def: \"sl = map fst (stake i \\<pi>)\" and i: \"i > 0\" and \\<pi>: \"wfp UNIV \\<pi>\"\nshows\n\"wffp sl \\<and>\n (\\<forall> j < length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n stateOf \\<pi> = hd sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp sl \\<and>\n    (\\<forall>j<length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n    stateOf \\<pi> = hd sl", "unfolding wffp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sl \\<noteq> [] \\<and>\n     (\\<forall>i.\n         Suc i < length sl \\<longrightarrow>\n         sl ! Suc i \\<in> \\<delta> (sl ! i))) \\<and>\n    (\\<forall>j<length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n    stateOf \\<pi> = hd sl", "proof(intro conjI allI impI)"], ["proof (state)\ngoal (4 subgoals):\n 1. sl \\<noteq> []\n 2. \\<And>i.\n       Suc i < length sl \\<Longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. \\<And>j. j < length sl \\<Longrightarrow> fst (\\<pi> !! j) = sl ! j\n 4. stateOf \\<pi> = hd sl", "fix j"], ["proof (state)\ngoal (4 subgoals):\n 1. sl \\<noteq> []\n 2. \\<And>i.\n       Suc i < length sl \\<Longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. \\<And>j. j < length sl \\<Longrightarrow> fst (\\<pi> !! j) = sl ! j\n 4. stateOf \\<pi> = hd sl", "have 1: \"stake i \\<pi> \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake i \\<pi> \\<noteq> []", "using i"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. stake i \\<pi> \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  stake i \\<pi> \\<noteq> []\n\ngoal (4 subgoals):\n 1. sl \\<noteq> []\n 2. \\<And>i.\n       Suc i < length sl \\<Longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. \\<And>j. j < length sl \\<Longrightarrow> fst (\\<pi> !! j) = sl ! j\n 4. stateOf \\<pi> = hd sl", "show \"stateOf \\<pi> = hd sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stateOf \\<pi> = hd sl", "unfolding sl_def hd_map[OF 1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. stateOf \\<pi> = fst (hd (stake i \\<pi>))", "using i"], ["proof (prove)\nusing this:\n  0 < i\n\ngoal (1 subgoal):\n 1. stateOf \\<pi> = fst (hd (stake i \\<pi>))", "by simp"], ["proof (state)\nthis:\n  stateOf \\<pi> = hd sl\n\ngoal (3 subgoals):\n 1. sl \\<noteq> []\n 2. \\<And>i.\n       Suc i < length sl \\<Longrightarrow>\n       sl ! Suc i \\<in> \\<delta> (sl ! i)\n 3. \\<And>j. j < length sl \\<Longrightarrow> fst (\\<pi> !! j) = sl ! j", "qed(insert assms, unfold sl_def wfp, auto)"], ["", "lemma nonintSI_nonintS: \"nonintSI \\<longleftrightarrow> nonintS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonintSI = nonintS", "proof(unfold nonintS_def nonintSI_def, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "fix sl sl' i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "obtain \\<pi> \\<pi>' where\n  \\<pi>: \"\\<pi> = map (\\<lambda> s. (s, L s)) sl @- sconst (toSink (last sl), L (toSink (last sl)))\" and\n  \\<pi>': \"\\<pi>' = map (\\<lambda> s. (s, L s)) sl' @- sconst (toSink (last sl'), L (toSink (last sl')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi> \\<pi>'.\n        \\<lbrakk>\\<pi> =\n                 map (\\<lambda>s. (s, L s)) sl @-\n                 sconst (toSink (last sl), L (toSink (last sl)));\n         \\<pi>' =\n         map (\\<lambda>s. (s, L s)) sl' @-\n         sconst (toSink (last sl'), L (toSink (last sl')))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<pi> =\n  map (\\<lambda>s. (s, L s)) sl @-\n  sconst (toSink (last sl), L (toSink (last sl)))\n  \\<pi>' =\n  map (\\<lambda>s. (s, L s)) sl' @-\n  sconst (toSink (last sl'), L (toSink (last sl')))\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "assume 0: \"\\<forall> \\<pi> \\<pi>'.\n    wfp UNIV \\<pi> \\<and> wfp UNIV \\<pi>' \\<and> stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0\n    \\<longrightarrow>\n    (\\<forall> i. (\\<forall> j \\<le> i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\"\n  and slsl': \"wffp sl\" \"wffp sl'\" \"hd sl = s0\" \"hd sl' = s0\"\n  and \"list_all2 f sl sl'\""], ["proof (state)\nthis:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp UNIV \\<pi> \\<and>\n     wfp UNIV \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     (\\<forall>i.\n         (\\<forall>j\\<le>i.\n             f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n         g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  list_all2 f sl sl'\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "hence l: \"length sl = length sl'\" and i: \"\\<forall> i < length sl. f (sl ! i) (sl' ! i)\""], ["proof (prove)\nusing this:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp UNIV \\<pi> \\<and>\n     wfp UNIV \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     (\\<forall>i.\n         (\\<forall>j\\<le>i.\n             f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n         g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. length sl = length sl' &&& \\<forall>i<length sl. f (sl ! i) (sl' ! i)", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp UNIV \\<pi> \\<and>\n     wfp UNIV \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     (\\<forall>i.\n         (\\<forall>j\\<le>i.\n             f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n         g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  length sl = length sl' \\<and> (\\<forall>i<length sl. f (sl ! i) (sl' ! i))\n\ngoal (1 subgoal):\n 1. length sl = length sl' &&& \\<forall>i<length sl. f (sl ! i) (sl' ! i)", "by auto"], ["proof (state)\nthis:\n  length sl = length sl'\n  \\<forall>i<length sl. f (sl ! i) (sl' ! i)\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "define i0 where \"i0 = length sl - 1\""], ["proof (state)\nthis:\n  i0 = length sl - 1\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have slsl'_NE: \"sl \\<noteq> [] \\<and> sl' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<and> sl' \\<noteq> []", "using slsl' wffp_NE"], ["proof (prove)\nusing this:\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  wffp ?sl \\<Longrightarrow> ?sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<and> sl' \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  sl \\<noteq> [] \\<and> sl' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "hence last: \"last sl = sl!i0\" \"last sl' = sl'!i0\""], ["proof (prove)\nusing this:\n  sl \\<noteq> [] \\<and> sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. last sl = sl ! i0 &&& last sl' = sl' ! i0", "by (metis i0_def l slsl' last_conv_nth)+"], ["proof (state)\nthis:\n  last sl = sl ! i0\n  last sl' = sl' ! i0\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have i0: \"i0 < length sl\" \"i0 < length sl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i0 < length sl &&& i0 < length sl'", "unfolding i0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. length sl - 1 < length sl &&& length sl - 1 < length sl'", "using l slsl' slsl'_NE"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  sl \\<noteq> [] \\<and> sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. length sl - 1 < length sl &&& length sl - 1 < length sl'", "by auto"], ["proof (state)\nthis:\n  i0 < length sl\n  i0 < length sl'\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have j: \"\\<forall> j \\<le> i0. f (sl ! j) (sl' ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i0. f (sl ! j) (sl' ! j)", "using i slsl'_NE"], ["proof (prove)\nusing this:\n  \\<forall>i<length sl. f (sl ! i) (sl' ! i)\n  sl \\<noteq> [] \\<and> sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>i0. f (sl ! j) (sl' ! j)", "unfolding i0_def"], ["proof (prove)\nusing this:\n  \\<forall>i<length sl. f (sl ! i) (sl' ! i)\n  sl \\<noteq> [] \\<and> sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<forall>j\\<le>length sl - 1. f (sl ! j) (sl' ! j)", "by (metis Suc_diff_eq_diff_pred Suc_diff_le Zero_neq_Suc diff_is_0_eq'\n            le_less_linear length_greater_0_conv)"], ["proof (state)\nthis:\n  \\<forall>j\\<le>i0. f (sl ! j) (sl' ! j)\n\ngoal (2 subgoals):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>\\<pi> \\<pi>'.\n                   wfp UNIV \\<pi> \\<and>\n                   wfp UNIV \\<pi>' \\<and>\n                   stateOf \\<pi> = s0 \\<and>\n                   stateOf \\<pi>' = s0 \\<longrightarrow>\n                   (\\<forall>i.\n                       (\\<forall>j\\<le>i.\n                           f (fst (\\<pi> !! j))\n                            (fst (\\<pi>' !! j))) \\<longrightarrow>\n                       g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)));\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')\n 2. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "show \"g (last sl) (last sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (last sl) (last sl')", "unfolding last"], ["proof (prove)\ngoal (1 subgoal):\n 1. g (sl ! i0) (sl' ! i0)", "using 0 slsl' j i0"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp UNIV \\<pi> \\<and>\n     wfp UNIV \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     (\\<forall>i.\n         (\\<forall>j\\<le>i.\n             f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n         g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  \\<forall>j\\<le>i0. f (sl ! j) (sl' ! j)\n  i0 < length sl\n  i0 < length sl'\n\ngoal (1 subgoal):\n 1. g (sl ! i0) (sl' ! i0)", "using wffp_to_wfp[OF \\<pi>] wffp_to_wfp[OF \\<pi>']"], ["proof (prove)\nusing this:\n  \\<forall>\\<pi> \\<pi>'.\n     wfp UNIV \\<pi> \\<and>\n     wfp UNIV \\<pi>' \\<and>\n     stateOf \\<pi> = s0 \\<and> stateOf \\<pi>' = s0 \\<longrightarrow>\n     (\\<forall>i.\n         (\\<forall>j\\<le>i.\n             f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))) \\<longrightarrow>\n         g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i)))\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  \\<forall>j\\<le>i0. f (sl ! j) (sl' ! j)\n  i0 < length sl\n  i0 < length sl'\n  wffp sl \\<Longrightarrow>\n  wfp UNIV \\<pi> \\<and>\n  (\\<forall>i<length sl. sl ! i = fst (\\<pi> !! i)) \\<and>\n  (\\<forall>i\\<ge>length sl. fst (\\<pi> !! i) = toSink (last sl)) \\<and>\n  stateOf \\<pi> = hd sl\n  wffp sl' \\<Longrightarrow>\n  wfp UNIV \\<pi>' \\<and>\n  (\\<forall>i<length sl'. sl' ! i = fst (\\<pi>' !! i)) \\<and>\n  (\\<forall>i\\<ge>length sl'. fst (\\<pi>' !! i) = toSink (last sl')) \\<and>\n  stateOf \\<pi>' = hd sl'\n\ngoal (1 subgoal):\n 1. g (sl ! i0) (sl' ! i0)", "by auto"], ["proof (state)\nthis:\n  g (last sl) (last sl')\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "fix \\<pi> \\<pi>' i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "assume\n  \"\\<forall> sl sl'. wffp sl \\<and> wffp sl' \\<and> hd sl = s0 \\<and> hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow> g (last sl) (last sl')\"\n  and \\<pi>\\<pi>': \"wfp UNIV \\<pi>\" \"wfp UNIV \\<pi>'\" and state: \"stateOf \\<pi> = s0\" \"stateOf \\<pi>' = s0\"\n  and f: \"\\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\""], ["proof (state)\nthis:\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n     g (last sl) (last sl')\n  wfp UNIV \\<pi>\n  wfp UNIV \\<pi>'\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "hence R:\n  \"\\<forall> sl sl'. wffp sl \\<and> wffp sl' \\<and> hd sl = s0 \\<and> hd sl' = s0 \\<and> length sl = length sl'\n            \\<longrightarrow>\n            ((\\<forall> i < length sl. f (sl!i) (sl'!i)) \\<longrightarrow> g (last sl) (last sl'))\""], ["proof (prove)\nusing this:\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n     g (last sl) (last sl')\n  wfp UNIV \\<pi>\n  wfp UNIV \\<pi>'\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<forall>sl sl'.\n       wffp sl \\<and>\n       wffp sl' \\<and>\n       hd sl = s0 \\<and>\n       hd sl' = s0 \\<and> length sl = length sl' \\<longrightarrow>\n       (\\<forall>i<length sl. f (sl ! i) (sl' ! i)) \\<longrightarrow>\n       g (last sl) (last sl')", "unfolding list_all2_conv_all_nth"], ["proof (prove)\nusing this:\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and>\n     length sl = length sl' \\<and>\n     (\\<forall>i<length sl. f (sl ! i) (sl' ! i)) \\<longrightarrow>\n     g (last sl) (last sl')\n  wfp UNIV \\<pi>\n  wfp UNIV \\<pi>'\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<forall>sl sl'.\n       wffp sl \\<and>\n       wffp sl' \\<and>\n       hd sl = s0 \\<and>\n       hd sl' = s0 \\<and> length sl = length sl' \\<longrightarrow>\n       (\\<forall>i<length sl. f (sl ! i) (sl' ! i)) \\<longrightarrow>\n       g (last sl) (last sl')", "by auto"], ["proof (state)\nthis:\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> length sl = length sl' \\<longrightarrow>\n     (\\<forall>i<length sl. f (sl ! i) (sl' ! i)) \\<longrightarrow>\n     g (last sl) (last sl')\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "define i0 where \"i0 = Suc i\""], ["proof (state)\nthis:\n  i0 = Suc i\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have i0_ge: \"i0 > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < i0", "unfolding i0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Suc i", "by auto"], ["proof (state)\nthis:\n  0 < i0\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have ii0: \"i < i0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < i0", "unfolding i0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < Suc i", "by auto"], ["proof (state)\nthis:\n  i < i0\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have f: \"\\<forall>j<i0. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>j<i0. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))", "using f"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<forall>j<i0. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))", "unfolding i0_def"], ["proof (prove)\nusing this:\n  \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<forall>j<Suc i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))", "by auto"], ["proof (state)\nthis:\n  \\<forall>j<i0. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "obtain sl sl' where\n  sl_def: \"sl = map fst (stake i0 \\<pi>)\" and sl'_def: \"sl' = map fst (stake i0 \\<pi>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl sl'.\n        \\<lbrakk>sl = map fst (stake i0 \\<pi>);\n         sl' = map fst (stake i0 \\<pi>')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  sl = map fst (stake i0 \\<pi>)\n  sl' = map fst (stake i0 \\<pi>')\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have i0: \"i0 = length sl\" \"length sl' = length sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i0 = length sl &&& length sl' = length sl", "unfolding i0_def sl_def sl'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc i = length (map fst (stake (Suc i) \\<pi>)) &&&\n    length (map fst (stake (Suc i) \\<pi>')) =\n    length (map fst (stake (Suc i) \\<pi>))", "by auto"], ["proof (state)\nthis:\n  i0 = length sl\n  length sl' = length sl\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "have 1: \"sl!i = last sl\" \"sl'!i = last sl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl ! i = last sl &&& sl' ! i = last sl'", "using i0"], ["proof (prove)\nusing this:\n  i0 = length sl\n  length sl' = length sl\n\ngoal (1 subgoal):\n 1. sl ! i = last sl &&& sl' ! i = last sl'", "unfolding i0_def"], ["proof (prove)\nusing this:\n  Suc i = length sl\n  length sl' = length sl\n\ngoal (1 subgoal):\n 1. sl ! i = last sl &&& sl' ! i = last sl'", "using last_conv_nth length_greater_0_conv"], ["proof (prove)\nusing this:\n  Suc i = length sl\n  length sl' = length sl\n  ?xs \\<noteq> [] \\<Longrightarrow> last ?xs = ?xs ! (length ?xs - 1)\n  (0 < length ?xs) = (?xs \\<noteq> [])\n\ngoal (1 subgoal):\n 1. sl ! i = last sl &&& sl' ! i = last sl'", "by (metis diff_Suc_1 i0 i0_ge)+"], ["proof (state)\nthis:\n  sl ! i = last sl\n  sl' ! i = last sl'\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi> \\<pi>' i.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        wfp UNIV \\<pi>; wfp UNIV \\<pi>'; stateOf \\<pi> = s0;\n        stateOf \\<pi>' = s0;\n        \\<forall>j\\<le>i. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\\<rbrakk>\n       \\<Longrightarrow> g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "show \"g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "using wfp_to_wffp[OF sl_def i0_ge \\<pi>\\<pi>'(1)] wfp_to_wffp[OF sl'_def i0_ge \\<pi>\\<pi>'(2)]"], ["proof (prove)\nusing this:\n  wffp sl \\<and>\n  (\\<forall>j<length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n  stateOf \\<pi> = hd sl\n  wffp sl' \\<and>\n  (\\<forall>j<length sl'. fst (\\<pi>' !! j) = sl' ! j) \\<and>\n  stateOf \\<pi>' = hd sl'\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "using R state f ii0"], ["proof (prove)\nusing this:\n  wffp sl \\<and>\n  (\\<forall>j<length sl. fst (\\<pi> !! j) = sl ! j) \\<and>\n  stateOf \\<pi> = hd sl\n  wffp sl' \\<and>\n  (\\<forall>j<length sl'. fst (\\<pi>' !! j) = sl' ! j) \\<and>\n  stateOf \\<pi>' = hd sl'\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> length sl = length sl' \\<longrightarrow>\n     (\\<forall>i<length sl. f (sl ! i) (sl' ! i)) \\<longrightarrow>\n     g (last sl) (last sl')\n  stateOf \\<pi> = s0\n  stateOf \\<pi>' = s0\n  \\<forall>j<i0. f (fst (\\<pi> !! j)) (fst (\\<pi>' !! j))\n  i < i0\n\ngoal (1 subgoal):\n 1. g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))", "by (simp add: 1 i0)"], ["proof (state)\nthis:\n  g (fst (\\<pi> !! i)) (fst (\\<pi>' !! i))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Finally, we show that nonintS is equivalent to standard\nnoninterference (predicate nonint).\\<close>"], ["", "text\\<open>purgeIdle removes the idle steps from a finite path:\\<close>"], ["", "definition purgeIdle :: \"('St, 'U, 'C) state list \\<Rightarrow> ('St, 'U, 'C) state list\"\nwhere \"purgeIdle \\<equiv> filter isState\""], ["", "lemma purgeIdle_simps[simp]:\n\"purgeIdle [] = []\"\n\"purgeIdle ((Idle st) # sl) = purgeIdle sl\"\n\"purgeIdle ((State st u c) # sl) = (State st u c) # purgeIdle sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle [] = [] &&&\n    purgeIdle (Idle st # sl) = purgeIdle sl &&&\n    purgeIdle (State st u c # sl) = State st u c # purgeIdle sl", "unfolding purgeIdle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter isState [] = [] &&&\n    filter isState (Idle st # sl) = filter isState sl &&&\n    filter isState (State st u c # sl) = State st u c # filter isState sl", "by auto"], ["", "lemma purgeIdle_append:\n\"purgeIdle (sl1 @ sl2) = purgeIdle sl1 @ purgeIdle sl2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (sl1 @ sl2) = purgeIdle sl1 @ purgeIdle sl2", "unfolding purgeIdle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter isState (sl1 @ sl2) = filter isState sl1 @ filter isState sl2", "by (metis filter_append)"], ["", "lemma purgeIdle_set_isState:\nassumes \"s \\<in> set (purgeIdle sl)\"\nshows \"isState s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isState s", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> set (purgeIdle sl)\n\ngoal (1 subgoal):\n 1. isState s", "unfolding purgeIdle_def"], ["proof (prove)\nusing this:\n  s \\<in> set (filter isState sl)\n\ngoal (1 subgoal):\n 1. isState s", "by (metis filter_set member_filter)"], ["", "lemma purgeIdle_Nil_iff:\n\"purgeIdle sl = [] \\<longleftrightarrow> (\\<forall>s\\<in>set sl. \\<not> isState s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (purgeIdle sl = []) = (\\<forall>s\\<in>set sl. \\<not> isState s)", "unfolding purgeIdle_def filter_empty_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>set sl. \\<not> isState x) =\n    (\\<forall>s\\<in>set sl. \\<not> isState s)", "by auto"], ["", "lemma purgeIdle_Cons_iff:\n\"purgeIdle sl = s # sll\n \\<longleftrightarrow>\n (\\<exists> sl1 sl2. sl = sl1 @ s # sl2 \\<and>\n            (\\<forall>s1\\<in>set sl1. \\<not> isState s1) \\<and> isState s \\<and> purgeIdle sl2 = sll)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (purgeIdle sl = s # sll) =\n    (\\<exists>sl1 sl2.\n        sl = sl1 @ s # sl2 \\<and>\n        (\\<forall>s1\\<in>set sl1. \\<not> isState s1) \\<and>\n        isState s \\<and> purgeIdle sl2 = sll)", "unfolding purgeIdle_def filter_eq_Cons_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>us vs.\n        sl = us @ s # vs \\<and>\n        (\\<forall>u\\<in>set us. \\<not> isState u) \\<and>\n        isState s \\<and> sll = filter isState vs) =\n    (\\<exists>sl1 sl2.\n        sl = sl1 @ s # sl2 \\<and>\n        (\\<forall>s1\\<in>set sl1. \\<not> isState s1) \\<and>\n        isState s \\<and> filter isState sl2 = sll)", "by auto"], ["", "lemma purgeIdle_map_Idle[simp]:\n\"purgeIdle (map Idle s) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (map Idle s) = []", "unfolding purgeIdle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter isState (map Idle s) = []", "by auto"], ["", "lemma purgeIdle_replicate_Idle[simp]:\n\"purgeIdle (replicate n (Idle st)) = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (replicate n (Idle st)) = []", "unfolding purgeIdle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. filter isState (replicate n (Idle st)) = []", "by auto"], ["", "lemma wffp_purgeIdle_Nil:\nassumes \"wffp sl\" and \"purgeIdle sl = []\"\nshows \"\\<exists> n st. n > 0 \\<and> sl = replicate n (Idle st)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  purgeIdle sl = []\n\ngoal (1 subgoal):\n 1. \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)", "proof(induction sl rule: wffp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       purgeIdle [s] = [] \\<Longrightarrow>\n       \\<exists>n st. 0 < n \\<and> [s] = replicate n (Idle st)\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "case (Singl s)"], ["proof (state)\nthis:\n  purgeIdle [s] = []\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       purgeIdle [s] = [] \\<Longrightarrow>\n       \\<exists>n st. 0 < n \\<and> [s] = replicate n (Idle st)\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "thus ?case"], ["proof (prove)\nusing this:\n  purgeIdle [s] = []\n\ngoal (1 subgoal):\n 1. \\<exists>n st. 0 < n \\<and> [s] = replicate n (Idle st)", "by (cases s) (auto intro: exI[of _ \"Suc 0\"])"], ["proof (state)\nthis:\n  \\<exists>n st. 0 < n \\<and> [s] = replicate n (Idle st)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "case (Cons s sl)"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl = [] \\<Longrightarrow>\n  \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)\n  purgeIdle (s # sl) = []\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "then"], ["proof (chain)\npicking this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl = [] \\<Longrightarrow>\n  \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)\n  purgeIdle (s # sl) = []", "obtain n st where sl: \"sl = replicate n (Idle st)\""], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl = [] \\<Longrightarrow>\n  \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)\n  purgeIdle (s # sl) = []\n\ngoal (1 subgoal):\n 1. (\\<And>n st.\n        sl = replicate n (Idle st) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  sl = replicate n (Idle st)\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "obtain st1 where s: \"s = Idle st1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>st1. s = Idle st1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl = [] \\<Longrightarrow>\n  \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st)\n  purgeIdle (s # sl) = []\n\ngoal (1 subgoal):\n 1. (\\<And>st1. s = Idle st1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  s = Idle st1\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "have 1: \"hd (replicate n (Idle st)) = Idle st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (replicate n (Idle st)) = Idle st", "by (metis Cons.hyps(2) hd_replicate replicate_empty sl wffp)"], ["proof (state)\nthis:\n  hd (replicate n (Idle st)) = Idle st\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl = [] \\<Longrightarrow>\n        \\<exists>n st. 0 < n \\<and> sl = replicate n (Idle st);\n        purgeIdle (s # sl) = []\\<rbrakk>\n       \\<Longrightarrow> \\<exists>n st.\n                            0 < n \\<and> s # sl = replicate n (Idle st)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n st. 0 < n \\<and> s # sl = replicate n (Idle st)", "using Cons(1)"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. \\<exists>n st. 0 < n \\<and> s # sl = replicate n (Idle st)", "by (auto intro: exI[of _ \"Suc n\"] exI[of _ st] simp: sl 1 s)"], ["proof (state)\nthis:\n  \\<exists>n st. 0 < n \\<and> s # sl = replicate n (Idle st)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_hd_purgeIdle:\nassumes wsl: \"wffp sl\" and psl: \"purgeIdle sl \\<noteq> []\"\nand ist: \"isState s\" and hsl: \"hd sl \\<in> \\<delta> s\"\nshows \"hd (purgeIdle sl) \\<in> \\<delta> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "using wsl"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "proof(cases rule: wffp_cases3)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 2. \\<And>st u c sl1.\n       \\<lbrakk>sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 3. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "case (Idle n st)"], ["proof (state)\nthis:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (3 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 2. \\<And>st u c sl1.\n       \\<lbrakk>sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 3. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "using psl"], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "unfolding Idle"], ["proof (prove)\nusing this:\n  purgeIdle (map Idle (replicate n st)) \\<noteq> []\n\ngoal (1 subgoal):\n 1. hd (purgeIdle (map Idle (replicate n st))) \\<in> \\<delta> s", "by simp"], ["proof (state)\nthis:\n  hd (purgeIdle sl) \\<in> \\<delta> s\n\ngoal (2 subgoals):\n 1. \\<And>st u c sl1.\n       \\<lbrakk>sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 2. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>st u c sl1.\n       \\<lbrakk>sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 2. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "case (State st u c sl1)"], ["proof (state)\nthis:\n  sl = State st u c # sl1\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\n\ngoal (2 subgoals):\n 1. \\<And>st u c sl1.\n       \\<lbrakk>sl = State st u c # sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s\n 2. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "using psl hsl"], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> []\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "unfolding State"], ["proof (prove)\nusing this:\n  purgeIdle (State st u c # sl1) \\<noteq> []\n  hd (State st u c # sl1) \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. hd (purgeIdle (State st u c # sl1)) \\<in> \\<delta> s", "by simp"], ["proof (state)\nthis:\n  hd (purgeIdle sl) \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "case (Idle_State n st u c sl1)"], ["proof (state)\nthis:\n  0 < n\n  sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State (do st u c) u c)\n\ngoal (1 subgoal):\n 1. \\<And>n st u c sl1.\n       \\<lbrakk>0 < n;\n        sl = map Idle (replicate n st) @ [State (do st u c) u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and>\n        hd sl1 \\<in> \\<delta> (State (do st u c) u c)\\<rbrakk>\n       \\<Longrightarrow> hd (purgeIdle sl) \\<in> \\<delta> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "using psl \\<open>n > 0\\<close> ist hsl"], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> []\n  0 < n\n  isState s\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. hd (purgeIdle sl) \\<in> \\<delta> s", "unfolding Idle_State purgeIdle_append"], ["proof (prove)\nusing this:\n  purgeIdle (map Idle (replicate n st)) @\n  purgeIdle [State (do st u c) u c] @ purgeIdle sl1 \\<noteq>\n  []\n  0 < n\n  isState s\n  hd (map Idle (replicate n st) @ [State (do st u c) u c] @ sl1)\n  \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. hd (purgeIdle (map Idle (replicate n st)) @\n        purgeIdle [State (do st u c) u c] @ purgeIdle sl1)\n    \\<in> \\<delta> s", "by (cases s) auto"], ["proof (state)\nthis:\n  hd (purgeIdle sl) \\<in> \\<delta> s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_purgeIdle:\nassumes \"wffp sl\" and \"purgeIdle sl \\<noteq> []\"\nshows \"wffp (purgeIdle sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "proof(induction sl rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   wffp ys \\<longrightarrow>\n                   purgeIdle ys \\<noteq> [] \\<longrightarrow>\n                   wffp (purgeIdle ys);\n        wffp xs; purgeIdle xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle xs)", "case (1 sl)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length sl \\<longrightarrow>\n     wffp ys \\<longrightarrow>\n     purgeIdle ys \\<noteq> [] \\<longrightarrow> wffp (purgeIdle ys)\n  wffp sl\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   wffp ys \\<longrightarrow>\n                   purgeIdle ys \\<noteq> [] \\<longrightarrow>\n                   wffp (purgeIdle ys);\n        wffp xs; purgeIdle xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle xs)", "note IH = 1"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length sl \\<longrightarrow>\n     wffp ys \\<longrightarrow>\n     purgeIdle ys \\<noteq> [] \\<longrightarrow> wffp (purgeIdle ys)\n  wffp sl\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   wffp ys \\<longrightarrow>\n                   purgeIdle ys \\<noteq> [] \\<longrightarrow>\n                   wffp (purgeIdle ys);\n        wffp xs; purgeIdle xs \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle xs)", "from \\<open>wffp sl\\<close>"], ["proof (chain)\npicking this:\n  wffp sl", "show ?case"], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "proof(cases sl rule: wffp_cases2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)\n 2. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "case (Idle n st)"], ["proof (state)\nthis:\n  0 < n\n  sl = map Idle (replicate n st)\n\ngoal (2 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)\n 2. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "have \"purgeIdle sl = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle sl = []", "unfolding Idle"], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (map Idle (replicate n st)) = []", "by auto"], ["proof (state)\nthis:\n  purgeIdle sl = []\n\ngoal (2 subgoals):\n 1. \\<And>n st.\n       \\<lbrakk>0 < n; sl = map Idle (replicate n st)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)\n 2. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  purgeIdle sl = []\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "using \\<open>purgeIdle sl \\<noteq> []\\<close>"], ["proof (prove)\nusing this:\n  purgeIdle sl = []\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "by auto"], ["proof (state)\nthis:\n  wffp (purgeIdle sl)\n\ngoal (1 subgoal):\n 1. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "case (State n st st1 u c sl1)"], ["proof (state)\nthis:\n  sl = map Idle (replicate n st) @ [State st1 u c] @ sl1\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "hence 1: \"purgeIdle sl = State st1 u c # purgeIdle sl1\""], ["proof (prove)\nusing this:\n  sl = map Idle (replicate n st) @ [State st1 u c] @ sl1\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. purgeIdle sl = State st1 u c # purgeIdle sl1", "by (auto simp del: map_replicate simp add: purgeIdle_append)"], ["proof (state)\nthis:\n  purgeIdle sl = State st1 u c # purgeIdle sl1\n\ngoal (1 subgoal):\n 1. \\<And>n st st1 u c sl1.\n       \\<lbrakk>sl = map Idle (replicate n st) @ [State st1 u c] @ sl1;\n        sl1 \\<noteq> [] \\<Longrightarrow>\n        wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\\<rbrakk>\n       \\<Longrightarrow> wffp (purgeIdle sl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "proof(cases \"purgeIdle sl1 = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. purgeIdle sl1 = [] \\<Longrightarrow> wffp (purgeIdle sl)\n 2. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "case True"], ["proof (state)\nthis:\n  purgeIdle sl1 = []\n\ngoal (2 subgoals):\n 1. purgeIdle sl1 = [] \\<Longrightarrow> wffp (purgeIdle sl)\n 2. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "note psl1 = True"], ["proof (state)\nthis:\n  purgeIdle sl1 = []\n\ngoal (2 subgoals):\n 1. purgeIdle sl1 = [] \\<Longrightarrow> wffp (purgeIdle sl)\n 2. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "unfolding 1 psl1"], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp [State st1 u c]", "by auto"], ["proof (state)\nthis:\n  wffp (purgeIdle sl)\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "case False"], ["proof (state)\nthis:\n  purgeIdle sl1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "hence sl1NE: \"sl1 \\<noteq> []\""], ["proof (prove)\nusing this:\n  purgeIdle sl1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl1 \\<noteq> []", "by (cases sl1) auto"], ["proof (state)\nthis:\n  sl1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "hence sl1: \"wffp sl1\" and hsl1: \"hd sl1 \\<in> \\<delta> (State st1 u c)\""], ["proof (prove)\nusing this:\n  sl1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wffp sl1 &&& hd sl1 \\<in> \\<delta> (State st1 u c)", "by (metis State(2))+"], ["proof (state)\nthis:\n  wffp sl1\n  hd sl1 \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "have \"length sl1 < length sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sl1 < length sl", "using State"], ["proof (prove)\nusing this:\n  sl = map Idle (replicate n st) @ [State st1 u c] @ sl1\n  sl1 \\<noteq> [] \\<Longrightarrow>\n  wffp sl1 \\<and> hd sl1 \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. length sl1 < length sl", "by auto"], ["proof (state)\nthis:\n  length sl1 < length sl\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "hence sl1: \"wffp (purgeIdle sl1)\""], ["proof (prove)\nusing this:\n  length sl1 < length sl\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl1)", "using IH(1) sl1 False"], ["proof (prove)\nusing this:\n  length sl1 < length sl\n  \\<forall>ys.\n     length ys < length sl \\<longrightarrow>\n     wffp ys \\<longrightarrow>\n     purgeIdle ys \\<noteq> [] \\<longrightarrow> wffp (purgeIdle ys)\n  wffp sl1\n  purgeIdle sl1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl1)", "by auto"], ["proof (state)\nthis:\n  wffp (purgeIdle sl1)\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "moreover"], ["proof (state)\nthis:\n  wffp (purgeIdle sl1)\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "have \"hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)", "by (metis False GM_sec_model.wffp_hd_purgeIdle State(2) sl1NE state.discI(2))"], ["proof (state)\nthis:\n  hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. purgeIdle sl1 \\<noteq> [] \\<Longrightarrow> wffp (purgeIdle sl)", "ultimately"], ["proof (chain)\npicking this:\n  wffp (purgeIdle sl1)\n  hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)", "show ?thesis"], ["proof (prove)\nusing this:\n  wffp (purgeIdle sl1)\n  hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. wffp (purgeIdle sl)", "unfolding 1"], ["proof (prove)\nusing this:\n  wffp (purgeIdle sl1)\n  hd (purgeIdle sl1) \\<in> \\<delta> (State st1 u c)\n\ngoal (1 subgoal):\n 1. wffp (State st1 u c # purgeIdle sl1)", "by auto"], ["proof (state)\nthis:\n  wffp (purgeIdle sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wffp (purgeIdle sl)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wffp (purgeIdle sl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isState_purgeIdle:\n\"(\\<exists> sl. purgeIdle sl = sll) \\<longleftrightarrow> list_all isState sll\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>sl. purgeIdle sl = sll) = list_all isState sll", "unfolding purgeIdle_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>sl. filter isState sl = sll) = list_all isState sll", "by (metis Ball_set_list_all purgeIdle_def purgeIdle_set_isState filter_True)"], ["", "lemma wffp_last_purgeIdle:\nassumes \"wffp sl\" and \"purgeIdle sl \\<noteq> []\"\nshows \"getGMState (last (purgeIdle sl)) = getGMState (last sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)", "proof(induction sl rule: wffp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       purgeIdle [s] \\<noteq> [] \\<Longrightarrow>\n       local.getGMState (last (purgeIdle [s])) = local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "case (Singl s)"], ["proof (state)\nthis:\n  purgeIdle [s] \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       purgeIdle [s] \\<noteq> [] \\<Longrightarrow>\n       local.getGMState (last (purgeIdle [s])) = local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "thus ?case"], ["proof (prove)\nusing this:\n  purgeIdle [s] \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle [s])) = local.getGMState (last [s])", "by (cases s) auto"], ["proof (state)\nthis:\n  local.getGMState (last (purgeIdle [s])) = local.getGMState (last [s])\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "case (Cons s sl)"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n  local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)\n  purgeIdle (s # sl) \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "hence slNE: \"sl \\<noteq> []\""], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n  local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)\n  purgeIdle (s # sl) \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl \\<noteq> []", "by (metis wffp_NE)"], ["proof (state)\nthis:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n        local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl);\n        purgeIdle (s # sl) \\<noteq> []\\<rbrakk>\n       \\<Longrightarrow> local.getGMState (last (purgeIdle (s # sl))) =\n                         local.getGMState (last (s # sl))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "proof(cases \"purgeIdle sl = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "case True"], ["proof (state)\nthis:\n  purgeIdle sl = []\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "then"], ["proof (chain)\npicking this:\n  purgeIdle sl = []", "obtain n st where sl: \"sl = replicate n (Idle st)\""], ["proof (prove)\nusing this:\n  purgeIdle sl = []\n\ngoal (1 subgoal):\n 1. (\\<And>n st.\n        sl = replicate n (Idle st) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis Cons.hyps wffp_purgeIdle_Nil)"], ["proof (state)\nthis:\n  sl = replicate n (Idle st)\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "hence n: \"n > 0\""], ["proof (prove)\nusing this:\n  sl = replicate n (Idle st)\n\ngoal (1 subgoal):\n 1. 0 < n", "using slNE"], ["proof (prove)\nusing this:\n  sl = replicate n (Idle st)\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. 0 < n", "by auto"], ["proof (state)\nthis:\n  0 < n\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "hence hsl: \"hd sl = Idle st\" and lsl: \"last sl = Idle st\""], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. hd sl = Idle st &&& last sl = Idle st", "unfolding sl"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. hd (replicate n (Idle st)) = Idle st &&&\n    last (replicate n (Idle st)) = Idle st", "by auto"], ["proof (state)\nthis:\n  hd sl = Idle st\n  last sl = Idle st\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "have s: \"isState s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isState s", "using True Cons"], ["proof (prove)\nusing this:\n  purgeIdle sl = []\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n  local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)\n  purgeIdle (s # sl) \\<noteq> []\n\ngoal (1 subgoal):\n 1. isState s", "by (cases s) auto"], ["proof (state)\nthis:\n  isState s\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "have 1: \"getGMState s = st\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState s = st", "using \\<open>hd sl \\<in> \\<delta> s\\<close>"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. local.getGMState s = st", "unfolding hsl"], ["proof (prove)\nusing this:\n  Idle st \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. local.getGMState s = st", "by(cases s) auto"], ["proof (state)\nthis:\n  local.getGMState s = st\n\ngoal (2 subgoals):\n 1. purgeIdle sl = [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))\n 2. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "using slNE n 1 hsl lsl s"], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n  0 < n\n  local.getGMState s = st\n  hd sl = Idle st\n  last sl = Idle st\n  isState s\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "unfolding sl purgeIdle_replicate_Idle"], ["proof (prove)\nusing this:\n  replicate n (Idle st) \\<noteq> []\n  0 < n\n  local.getGMState s = st\n  hd (replicate n (Idle st)) = Idle st\n  last (replicate n (Idle st)) = Idle st\n  isState s\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # replicate n (Idle st)))) =\n    local.getGMState (last (s # replicate n (Idle st)))", "by (cases s) auto"], ["proof (state)\nthis:\n  local.getGMState (last (purgeIdle (s # sl))) =\n  local.getGMState (last (s # sl))\n\ngoal (1 subgoal):\n 1. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "case False"], ["proof (state)\nthis:\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n    local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "thus ?thesis"], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "using Cons"], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> []\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  purgeIdle sl \\<noteq> [] \\<Longrightarrow>\n  local.getGMState (last (purgeIdle sl)) = local.getGMState (last sl)\n  purgeIdle (s # sl) \\<noteq> []\n\ngoal (1 subgoal):\n 1. local.getGMState (last (purgeIdle (s # sl))) =\n    local.getGMState (last (s # sl))", "by (cases s) auto"], ["proof (state)\nthis:\n  local.getGMState (last (purgeIdle (s # sl))) =\n  local.getGMState (last (s # sl))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.getGMState (last (purgeIdle (s # sl))) =\n  local.getGMState (last (s # sl))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wffp_isState_doo:\nassumes \"wffp sl\" and \"list_all isState sl\"\nshows \"doo (getGMState (hd sl)) (map getGMUserCom (tl sl)) = getGMState (last sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n    local.getGMState (last sl)", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  list_all isState sl\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n    local.getGMState (last sl)", "proof(induction sl rule: wffp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "case (Cons s sl)"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "then"], ["proof (chain)\npicking this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)", "obtain st u c where s: \"s = State st u c\""], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)\n\ngoal (1 subgoal):\n 1. (\\<And>st u c.\n        s = State st u c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases s ) auto"], ["proof (state)\nthis:\n  s = State st u c\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "have sl: \"sl \\<noteq> []\" and sl1: \"sl = hd sl # tl sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] &&& sl = hd sl # tl sl", "using wffp_NE[OF \\<open>wffp sl\\<close>]"], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] &&& sl = hd sl # tl sl", "by auto"], ["proof (state)\nthis:\n  sl \\<noteq> []\n  sl = hd sl # tl sl\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "with Cons"], ["proof (chain)\npicking this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)\n  sl \\<noteq> []\n  sl = hd sl # tl sl", "obtain st1 u1 c1 where hsl: \"hd sl = State st1 u1 c1\""], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)\n  sl \\<noteq> []\n  sl = hd sl # tl sl\n\ngoal (1 subgoal):\n 1. (\\<And>st1 u1 c1.\n        hd sl = State st1 u1 c1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis isState_purgeIdle isState_def purgeIdle_Cons_iff)"], ["proof (state)\nthis:\n  hd sl = State st1 u1 c1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "have 1: \"getGMState (hd sl) = do st u1 c1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (hd sl) = do st u1 c1", "using \\<open>hd sl \\<in> \\<delta> s\\<close>"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> s\n\ngoal (1 subgoal):\n 1. local.getGMState (hd sl) = do st u1 c1", "unfolding hsl s"], ["proof (prove)\nusing this:\n  State st1 u1 c1 \\<in> \\<delta> (State st u c)\n\ngoal (1 subgoal):\n 1. local.getGMState (State st1 u1 c1) = do st u1 c1", "by simp"], ["proof (state)\nthis:\n  local.getGMState (hd sl) = do st u1 c1\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "have \"doo st (map getGMUserCom sl) = doo (do st u1 c1) (map getGMUserCom (tl sl))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doo st (map getGMUserCom sl) =\n    doo (do st u1 c1) (map getGMUserCom (tl sl))", "by (subst sl1) (simp add: 1 hsl)"], ["proof (state)\nthis:\n  doo st (map getGMUserCom sl) =\n  doo (do st u1 c1) (map getGMUserCom (tl sl))\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])\n 2. \\<And>s sl.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        list_all isState sl \\<Longrightarrow>\n        doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n        local.getGMState (last sl);\n        list_all isState (s # sl)\\<rbrakk>\n       \\<Longrightarrow> doo (local.getGMState (hd (s # sl)))\n                          (map getGMUserCom (tl (s # sl))) =\n                         local.getGMState (last (s # sl))", "thus ?case"], ["proof (prove)\nusing this:\n  doo st (map getGMUserCom sl) =\n  doo (do st u1 c1) (map getGMUserCom (tl sl))\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd (s # sl))) (map getGMUserCom (tl (s # sl))) =\n    local.getGMState (last (s # sl))", "using sl Cons"], ["proof (prove)\nusing this:\n  doo st (map getGMUserCom sl) =\n  doo (do st u1 c1) (map getGMUserCom (tl sl))\n  sl \\<noteq> []\n  hd sl \\<in> \\<delta> s\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n  list_all isState (s # sl)\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd (s # sl))) (map getGMUserCom (tl (s # sl))) =\n    local.getGMState (last (s # sl))", "unfolding 1 s"], ["proof (prove)\nusing this:\n  doo st (map getGMUserCom sl) =\n  doo (do st u1 c1) (map getGMUserCom (tl sl))\n  sl \\<noteq> []\n  hd sl \\<in> \\<delta> (State st u c)\n  wffp sl\n  list_all isState sl \\<Longrightarrow>\n  doo (do st u1 c1) (map getGMUserCom (tl sl)) = local.getGMState (last sl)\n  list_all isState (State st u c # sl)\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd (State st u c # sl)))\n     (map getGMUserCom (tl (State st u c # sl))) =\n    local.getGMState (last (State st u c # sl))", "by auto"], ["proof (state)\nthis:\n  doo (local.getGMState (hd (s # sl))) (map getGMUserCom (tl (s # sl))) =\n  local.getGMState (last (s # sl))\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       list_all isState [s] \\<Longrightarrow>\n       doo (local.getGMState (hd [s])) (map getGMUserCom (tl [s])) =\n       local.getGMState (last [s])", "qed auto"], ["", "lemma isState_hd_purgeIdle:\nassumes wsl: \"wffp sl\" and ist: \"isState (hd sl)\"\nshows \"purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl", "using ist"], ["proof (prove)\nusing this:\n  isState (hd sl)\n\ngoal (1 subgoal):\n 1. purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl", "by (intro conjI) (subst hd_Cons_tl[OF wffp_NE[OF wsl], symmetric], cases \"hd sl\", cases sl, auto)+"], ["", "lemma wffp_isState_doo_purgeIdle:\nfixes sl defines sll: \"sll \\<equiv> purgeIdle sl\"\nassumes wsl: \"wffp sl\" and ist: \"isState (hd sl)\"\nshows \"doo (getGMState (hd sl)) (map getGMUserCom (tl sll)) = getGMState (last sl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "note 1 = isState_hd_purgeIdle[OF wsl ist]"], ["proof (state)\nthis:\n  purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "hence wsll: \"wffp sll\""], ["proof (prove)\nusing this:\n  purgeIdle sl \\<noteq> [] \\<and> hd (purgeIdle sl) = hd sl\n\ngoal (1 subgoal):\n 1. wffp sll", "by (metis sll wffp_purgeIdle wsl)"], ["proof (state)\nthis:\n  wffp sll\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "hence \"doo (getGMState (hd sll)) (map getGMUserCom (tl sll)) = getGMState (last sll)\""], ["proof (prove)\nusing this:\n  wffp sll\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sll)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sll)", "by (metis wffp_isState_doo isState_purgeIdle sll)"], ["proof (state)\nthis:\n  doo (local.getGMState (hd sll)) (map getGMUserCom (tl sll)) =\n  local.getGMState (last sll)\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "thus ?thesis"], ["proof (prove)\nusing this:\n  doo (local.getGMState (hd sll)) (map getGMUserCom (tl sll)) =\n  local.getGMState (last sll)\n\ngoal (1 subgoal):\n 1. doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n    local.getGMState (last sl)", "by (metis 1 sll wffp_last_purgeIdle wsl)"], ["proof (state)\nthis:\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sll)) =\n  local.getGMState (last sl)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_getGMUserCom_surj:\nassumes \"isState s\"\nshows \"\\<exists> sl. wffp sl \\<and> list_all isState sl \\<and> hd sl = s \\<and> map getGMUserCom (tl sl) = ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sl.\n       wffp sl \\<and>\n       list_all isState sl \\<and>\n       hd sl = s \\<and> map getGMUserCom (tl sl) = ucl", "using assms"], ["proof (prove)\nusing this:\n  isState s\n\ngoal (1 subgoal):\n 1. \\<exists>sl.\n       wffp sl \\<and>\n       list_all isState sl \\<and>\n       hd sl = s \\<and> map getGMUserCom (tl sl) = ucl", "proof(induction ucl arbitrary: s rule: list_pair_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       isState s \\<Longrightarrow>\n       \\<exists>sl.\n          wffp sl \\<and>\n          list_all isState sl \\<and>\n          hd sl = s \\<and> map getGMUserCom (tl sl) = []\n 2. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "case Nil"], ["proof (state)\nthis:\n  isState s\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       isState s \\<Longrightarrow>\n       \\<exists>sl.\n          wffp sl \\<and>\n          list_all isState sl \\<and>\n          hd sl = s \\<and> map getGMUserCom (tl sl) = []\n 2. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "thus ?case"], ["proof (prove)\nusing this:\n  isState s\n\ngoal (1 subgoal):\n 1. \\<exists>sl.\n       wffp sl \\<and>\n       list_all isState sl \\<and>\n       hd sl = s \\<and> map getGMUserCom (tl sl) = []", "apply(intro exI[of _ \"[s]\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. isState s \\<Longrightarrow>\n    wffp [s] \\<and>\n    list_all isState [s] \\<and>\n    hd [s] = s \\<and> map getGMUserCom (tl [s]) = []", "by auto"], ["proof (state)\nthis:\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = s \\<and> map getGMUserCom (tl sl) = []\n\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "case (Cons u c ucl s)"], ["proof (state)\nthis:\n  isState ?s3 \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = ?s3 \\<and> map getGMUserCom (tl sl) = ucl\n  isState s\n\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "then"], ["proof (chain)\npicking this:\n  isState ?s3 \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = ?s3 \\<and> map getGMUserCom (tl sl) = ucl\n  isState s", "obtain st1 u1 c1 where s: \"s = State st1 u1 c1\""], ["proof (prove)\nusing this:\n  isState ?s3 \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = ?s3 \\<and> map getGMUserCom (tl sl) = ucl\n  isState s\n\ngoal (1 subgoal):\n 1. (\\<And>st1 u1 c1.\n        s = State st1 u1 c1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  s = State st1 u1 c1\n\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "define s1 where \"s1 = State (do st1 u c) u c\""], ["proof (state)\nthis:\n  s1 = State (do st1 u c) u c\n\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "obtain sl where sl: \"wffp sl \\<and> list_all isState sl\" and hsl: \"hd sl = s1\"\n  and msl: \"map getGMUserCom (tl sl) = ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl.\n        \\<lbrakk>wffp sl \\<and> list_all isState sl; hd sl = s1;\n         map getGMUserCom (tl sl) = ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(1)[of s1]"], ["proof (prove)\nusing this:\n  isState s1 \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = s1 \\<and> map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. (\\<And>sl.\n        \\<lbrakk>wffp sl \\<and> list_all isState sl; hd sl = s1;\n         map getGMUserCom (tl sl) = ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding s1_def"], ["proof (prove)\nusing this:\n  isState (State (do st1 u c) u c) \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = State (do st1 u c) u c \\<and> map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. (\\<And>sl.\n        \\<lbrakk>wffp sl \\<and> list_all isState sl;\n         hd sl = State (do st1 u c) u c;\n         map getGMUserCom (tl sl) = ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wffp sl \\<and> list_all isState sl\n  hd sl = s1\n  map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. \\<And>a b list s.\n       \\<lbrakk>\\<And>s.\n                   isState s \\<Longrightarrow>\n                   \\<exists>sl.\n                      wffp sl \\<and>\n                      list_all isState sl \\<and>\n                      hd sl = s \\<and> map getGMUserCom (tl sl) = list;\n        isState s\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl.\n                            wffp sl \\<and>\n                            list_all isState sl \\<and>\n                            hd sl = s \\<and>\n                            map getGMUserCom (tl sl) = (a, b) # list", "thus ?case"], ["proof (prove)\nusing this:\n  wffp sl \\<and> list_all isState sl\n  hd sl = s1\n  map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. \\<exists>sl.\n       wffp sl \\<and>\n       list_all isState sl \\<and>\n       hd sl = s \\<and> map getGMUserCom (tl sl) = (u, c) # ucl", "using s s1_def"], ["proof (prove)\nusing this:\n  wffp sl \\<and> list_all isState sl\n  hd sl = s1\n  map getGMUserCom (tl sl) = ucl\n  s = State st1 u1 c1\n  s1 = State (do st1 u c) u c\n\ngoal (1 subgoal):\n 1. \\<exists>sl.\n       wffp sl \\<and>\n       list_all isState sl \\<and>\n       hd sl = s \\<and> map getGMUserCom (tl sl) = (u, c) # ucl", "by (intro exI[of _ \"s # sl\"]) auto"], ["proof (state)\nthis:\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = s \\<and> map getGMUserCom (tl sl) = (u, c) # ucl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma purgeIdle_purge_ex:\nassumes \"wffp sl\" and \"list_all isState sl\" and \"map getGMUserCom (tl sl) = ucl\"\nshows \"\\<exists> sl'. hd sl' = ss' \\<and> wffp sl' \\<and>\n              list_all2 f (tl sl) (tl sl') \\<and>\n              map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl sl) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "using assms"], ["proof (prove)\nusing this:\n  wffp sl\n  list_all isState sl\n  map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl sl) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "proof(induction sl arbitrary: ucl ss' rule: wffp_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s ucl ss'.\n       \\<lbrakk>list_all isState [s];\n        map getGMUserCom (tl [s]) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl [s]) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl\n 2. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "case (Singl s ucl)"], ["proof (state)\nthis:\n  list_all isState [s]\n  map getGMUserCom (tl [s]) = ucl\n\ngoal (2 subgoals):\n 1. \\<And>s ucl ss'.\n       \\<lbrakk>list_all isState [s];\n        map getGMUserCom (tl [s]) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl [s]) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl\n 2. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "thus ?case"], ["proof (prove)\nusing this:\n  list_all isState [s]\n  map getGMUserCom (tl [s]) = ucl\n\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl [s]) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "apply (intro exI[of _ \"[ss']\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>list_all isState [s]; map getGMUserCom (tl [s]) = ucl\\<rbrakk>\n    \\<Longrightarrow> hd [ss'] = ss' \\<and>\n                      wffp [ss'] \\<and>\n                      list_all2 f (tl [s]) (tl [ss']) \\<and>\n                      map getGMUserCom (purgeIdle (tl [ss'])) = purge GH ucl", "by (cases ss') auto"], ["proof (state)\nthis:\n  \\<exists>sl'.\n     hd sl' = ss' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl [s]) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "case (Cons ss sl ucl ss')"], ["proof (state)\nthis:\n  hd sl \\<in> \\<delta> ss\n  wffp sl\n  \\<lbrakk>list_all isState sl; map getGMUserCom (tl sl) = ?ucl3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl'.\n                       hd sl' = ?ss'3 \\<and>\n                       wffp sl' \\<and>\n                       list_all2 f (tl sl) (tl sl') \\<and>\n                       map getGMUserCom (purgeIdle (tl sl')) =\n                       purge GH ?ucl3\n  list_all isState (ss # sl)\n  map getGMUserCom (tl (ss # sl)) = ucl\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "note wsl = \\<open>wffp sl\\<close>"], ["proof (state)\nthis:\n  wffp sl\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "hence slNE: \"sl \\<noteq> []\""], ["proof (prove)\nusing this:\n  wffp sl\n\ngoal (1 subgoal):\n 1. sl \\<noteq> []", "by (metis wffp_NE)"], ["proof (state)\nthis:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "obtain s sl1 where sl: \"sl = s # sl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s sl1. sl = s # sl1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wffp_NE[OF \\<open>wffp sl\\<close>]"], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>s sl1. sl = s # sl1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases sl) auto"], ["proof (state)\nthis:\n  sl = s # sl1\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "then"], ["proof (chain)\npicking this:\n  sl = s # sl1", "obtain st u c where s: \"s = State st u c\""], ["proof (prove)\nusing this:\n  sl = s # sl1\n\ngoal (1 subgoal):\n 1. (\\<And>st u c.\n        s = State st u c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons"], ["proof (prove)\nusing this:\n  sl = s # sl1\n  hd sl \\<in> \\<delta> ss\n  wffp sl\n  \\<lbrakk>list_all isState sl; map getGMUserCom (tl sl) = ?ucl3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl'.\n                       hd sl' = ?ss'3 \\<and>\n                       wffp sl' \\<and>\n                       list_all2 f (tl sl) (tl sl') \\<and>\n                       map getGMUserCom (purgeIdle (tl sl')) =\n                       purge GH ?ucl3\n  list_all isState (ss # sl)\n  map getGMUserCom (tl (ss # sl)) = ucl\n\ngoal (1 subgoal):\n 1. (\\<And>st u c.\n        s = State st u c \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases s) auto"], ["proof (state)\nthis:\n  s = State st u c\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "define ucl1 where \"ucl1 = tl ucl\""], ["proof (state)\nthis:\n  ucl1 = tl ucl\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "have ucl: \"ucl = (u,c) # ucl1\" and hsl: \"hd sl = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ucl = (u, c) # ucl1 &&& hd sl = s", "using Cons(5)"], ["proof (prove)\nusing this:\n  map getGMUserCom (tl (ss # sl)) = ucl\n\ngoal (1 subgoal):\n 1. ucl = (u, c) # ucl1 &&& hd sl = s", "unfolding s ucl1_def sl"], ["proof (prove)\nusing this:\n  map getGMUserCom (tl (ss # State st u c # sl1)) = ucl\n\ngoal (1 subgoal):\n 1. ucl = (u, c) # tl ucl &&& hd (State st u c # sl1) = State st u c", "by auto"], ["proof (state)\nthis:\n  ucl = (u, c) # ucl1\n  hd sl = s\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "have 1: \"list_all isState sl\" and 2: \"map getGMUserCom (tl sl) = ucl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all isState sl &&& map getGMUserCom (tl sl) = ucl1", "using Cons"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> ss\n  wffp sl\n  \\<lbrakk>list_all isState sl; map getGMUserCom (tl sl) = ?ucl3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl'.\n                       hd sl' = ?ss'3 \\<and>\n                       wffp sl' \\<and>\n                       list_all2 f (tl sl) (tl sl') \\<and>\n                       map getGMUserCom (purgeIdle (tl sl')) =\n                       purge GH ?ucl3\n  list_all isState (ss # sl)\n  map getGMUserCom (tl (ss # sl)) = ucl\n\ngoal (1 subgoal):\n 1. list_all isState sl &&& map getGMUserCom (tl sl) = ucl1", "unfolding ucl1_def s"], ["proof (prove)\nusing this:\n  hd sl \\<in> \\<delta> ss\n  wffp sl\n  \\<lbrakk>list_all isState sl; map getGMUserCom (tl sl) = ?ucl3\\<rbrakk>\n  \\<Longrightarrow> \\<exists>sl'.\n                       hd sl' = ?ss'3 \\<and>\n                       wffp sl' \\<and>\n                       list_all2 f (tl sl) (tl sl') \\<and>\n                       map getGMUserCom (purgeIdle (tl sl')) =\n                       purge GH ?ucl3\n  list_all isState (ss # sl)\n  map getGMUserCom (tl (ss # sl)) = ucl\n\ngoal (1 subgoal):\n 1. list_all isState sl &&& map getGMUserCom (tl sl) = tl ucl", "by auto"], ["proof (state)\nthis:\n  list_all isState sl\n  map getGMUserCom (tl sl) = ucl1\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "define st' where \"st' = getGMState ss'\""], ["proof (state)\nthis:\n  st' = local.getGMState ss'\n\ngoal (1 subgoal):\n 1. \\<And>s sl ucl ss'.\n       \\<lbrakk>hd sl \\<in> \\<delta> s; wffp sl;\n        \\<And>ucl ss'.\n           \\<lbrakk>list_all isState sl;\n            map getGMUserCom (tl sl) = ucl\\<rbrakk>\n           \\<Longrightarrow> \\<exists>sl'.\n                                hd sl' = ss' \\<and>\n                                wffp sl' \\<and>\n                                list_all2 f (tl sl) (tl sl') \\<and>\n                                map getGMUserCom (purgeIdle (tl sl')) =\n                                purge GH ucl;\n        list_all isState (s # sl);\n        map getGMUserCom (tl (s # sl)) = ucl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>sl'.\n                            hd sl' = ss' \\<and>\n                            wffp sl' \\<and>\n                            list_all2 f (tl (s # sl)) (tl sl') \\<and>\n                            map getGMUserCom (purgeIdle (tl sl')) =\n                            purge GH ucl", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "proof(cases \"u \\<in> GH\")"], ["proof (state)\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "case True"], ["proof (state)\nthis:\n  u \\<in> GH\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "note u = True"], ["proof (state)\nthis:\n  u \\<in> GH\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "define s' :: \"('St, 'U, 'C) state\" where \"s' = Idle st'\""], ["proof (state)\nthis:\n  s' = Idle st'\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "obtain sl' where hsl': \"hd sl' = s'\" and wsl': \"wffp sl'\"\n    and slsl': \"list_all2 f (tl sl) (tl sl')\" and m: \"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        \\<lbrakk>hd sl' = s'; wffp sl'; list_all2 f (tl sl) (tl sl');\n         map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(3)[OF 1 2, of s']"], ["proof (prove)\nusing this:\n  \\<exists>sl'.\n     hd sl' = s' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl sl) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        \\<lbrakk>hd sl' = s'; wffp sl'; list_all2 f (tl sl) (tl sl');\n         map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd sl' = s'\n  wffp sl'\n  list_all2 f (tl sl) (tl sl')\n  map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "hence sl'NE: \"sl' \\<noteq> []\""], ["proof (prove)\nusing this:\n  hd sl' = s'\n  wffp sl'\n  list_all2 f (tl sl) (tl sl')\n  map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (1 subgoal):\n 1. sl' \\<noteq> []", "by (metis wffp_NE)"], ["proof (state)\nthis:\n  sl' \\<noteq> []\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"wffp (ss' # sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "using wsl' hsl'"], ["proof (prove)\nusing this:\n  wffp sl'\n  hd sl' = s'\n\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "unfolding s'_def st'_def"], ["proof (prove)\nusing this:\n  wffp sl'\n  hd sl' = Idle (local.getGMState ss')\n\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "by (cases ss') auto"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "moreover"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "{"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"f s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s s'", "using u"], ["proof (prove)\nusing this:\n  u \\<in> GH\n\ngoal (1 subgoal):\n 1. f s s'", "unfolding s'_def st'_def s f_def"], ["proof (prove)\nusing this:\n  u \\<in> GH\n\ngoal (1 subgoal):\n 1. \\<forall>ua ca.\n       ua \\<notin> GH \\<longrightarrow>\n       (\\<exists>sta. State st u c = State sta ua ca) =\n       (\\<exists>st'. Idle (local.getGMState ss') = State st' ua ca)", "by blast"], ["proof (state)\nthis:\n  f s s'\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "hence \"list_all2 f sl sl'\""], ["proof (prove)\nusing this:\n  f s s'\n\ngoal (1 subgoal):\n 1. list_all2 f sl sl'", "using slsl' hsl hsl' slNE sl'NE"], ["proof (prove)\nusing this:\n  f s s'\n  list_all2 f (tl sl) (tl sl')\n  hd sl = s\n  hd sl' = s'\n  sl \\<noteq> []\n  sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_all2 f sl sl'", "by (metis list.sel(1,3) list_all2_Cons neq_Nil_conv)"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "}"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "moreover"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"map getGMUserCom (purgeIdle sl') = purge GH ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map getGMUserCom (purgeIdle sl') = purge GH ucl", "by (subst hd_Cons_tl[OF sl'NE, symmetric]) (auto simp: hsl' ucl s'_def u m)"], ["proof (state)\nthis:\n  map getGMUserCom (purgeIdle sl') = purge GH ucl\n\ngoal (2 subgoals):\n 1. u \\<in> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n 2. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "ultimately"], ["proof (chain)\npicking this:\n  wffp (ss' # sl')\n  list_all2 f sl sl'\n  map getGMUserCom (purgeIdle sl') = purge GH ucl", "show ?thesis"], ["proof (prove)\nusing this:\n  wffp (ss' # sl')\n  list_all2 f sl sl'\n  map getGMUserCom (purgeIdle sl') = purge GH ucl\n\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "by (intro exI[of _ \"ss' # sl'\"]) auto"], ["proof (state)\nthis:\n  \\<exists>sl'.\n     hd sl' = ss' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "case False"], ["proof (state)\nthis:\n  u \\<notin> GH\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "note u = False"], ["proof (state)\nthis:\n  u \\<notin> GH\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "define s' where \"s' = State (do st' u c) u c\""], ["proof (state)\nthis:\n  s' = State (do st' u c) u c\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "obtain sl' where hsl': \"hd sl' = s'\" and wsl': \"wffp sl'\"\n    and slsl': \"list_all2 f (tl sl) (tl sl')\" and m: \"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        \\<lbrakk>hd sl' = s'; wffp sl'; list_all2 f (tl sl) (tl sl');\n         map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using Cons(3)[OF 1 2, of s']"], ["proof (prove)\nusing this:\n  \\<exists>sl'.\n     hd sl' = s' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl sl) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        \\<lbrakk>hd sl' = s'; wffp sl'; list_all2 f (tl sl) (tl sl');\n         map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  hd sl' = s'\n  wffp sl'\n  list_all2 f (tl sl) (tl sl')\n  map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "hence sl'NE: \"sl' \\<noteq> []\""], ["proof (prove)\nusing this:\n  hd sl' = s'\n  wffp sl'\n  list_all2 f (tl sl) (tl sl')\n  map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl1\n\ngoal (1 subgoal):\n 1. sl' \\<noteq> []", "by (metis wffp_NE)"], ["proof (state)\nthis:\n  sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"wffp (ss' # sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "using wsl' hsl'"], ["proof (prove)\nusing this:\n  wffp sl'\n  hd sl' = s'\n\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "unfolding s'_def st'_def"], ["proof (prove)\nusing this:\n  wffp sl'\n  hd sl' = State (do (local.getGMState ss') u c) u c\n\ngoal (1 subgoal):\n 1. wffp (ss' # sl')", "by (cases ss') auto"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "moreover"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "{"], ["proof (state)\nthis:\n  wffp (ss' # sl')\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"f s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s s'", "unfolding s'_def st'_def s f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>ua ca.\n       ua \\<notin> GH \\<longrightarrow>\n       (\\<exists>sta. State st u c = State sta ua ca) =\n       (\\<exists>st'.\n           State (do (local.getGMState ss') u c) u c = State st' ua ca)", "by simp"], ["proof (state)\nthis:\n  f s s'\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "hence \"list_all2 f sl sl'\""], ["proof (prove)\nusing this:\n  f s s'\n\ngoal (1 subgoal):\n 1. list_all2 f sl sl'", "using slsl' hsl hsl' slNE sl'NE"], ["proof (prove)\nusing this:\n  f s s'\n  list_all2 f (tl sl) (tl sl')\n  hd sl = s\n  hd sl' = s'\n  sl \\<noteq> []\n  sl' \\<noteq> []\n\ngoal (1 subgoal):\n 1. list_all2 f sl sl'", "by (metis list.sel(1,3) list_all2_Cons neq_Nil_conv)"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "}"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "moreover"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "have \"map getGMUserCom (purgeIdle sl') = purge GH ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map getGMUserCom (purgeIdle sl') = purge GH ucl", "by (subst hd_Cons_tl[OF sl'NE, symmetric]) (auto simp: hsl' ucl s'_def u m)"], ["proof (state)\nthis:\n  map getGMUserCom (purgeIdle sl') = purge GH ucl\n\ngoal (1 subgoal):\n 1. u \\<notin> GH \\<Longrightarrow>\n    \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "ultimately"], ["proof (chain)\npicking this:\n  wffp (ss' # sl')\n  list_all2 f sl sl'\n  map getGMUserCom (purgeIdle sl') = purge GH ucl", "show ?thesis"], ["proof (prove)\nusing this:\n  wffp (ss' # sl')\n  list_all2 f sl sl'\n  map getGMUserCom (purgeIdle sl') = purge GH ucl\n\ngoal (1 subgoal):\n 1. \\<exists>sl'.\n       hd sl' = ss' \\<and>\n       wffp sl' \\<and>\n       list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n       map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl", "by (intro exI[of _ \"ss' # sl'\"]) auto"], ["proof (state)\nthis:\n  \\<exists>sl'.\n     hd sl' = ss' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>sl'.\n     hd sl' = ss' \\<and>\n     wffp sl' \\<and>\n     list_all2 f (tl (ss # sl)) (tl sl') \\<and>\n     map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma purgeIdle_getGMUserCom_purge:\nfixes sl sl'\ndefines \"ucl \\<equiv> map getGMUserCom (purgeIdle (tl sl))\"\n    and \"ucl' \\<equiv> map getGMUserCom (purgeIdle (tl sl'))\"\nassumes wsl: \"wffp sl\" and wsl': \"wffp sl'\" and f: \"list_all2 f sl sl'\"\nshows \"purge GH ucl = purge GH ucl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "have \"length sl = length sl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length sl = length sl'", "using f"], ["proof (prove)\nusing this:\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. length sl = length sl'", "by (metis list_all2_lengthD)"], ["proof (state)\nthis:\n  length sl = length sl'\n\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "thus ?thesis"], ["proof (prove)\nusing this:\n  length sl = length sl'\n\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "using assms"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  ucl \\<equiv> map getGMUserCom (purgeIdle (tl sl))\n  ucl' \\<equiv> map getGMUserCom (purgeIdle (tl sl'))\n  wffp sl\n  wffp sl'\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "proof(induction arbitrary: ucl ucl' rule: list_induct2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wffp []; wffp []; list_all2 f [] []\\<rbrakk>\n    \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl []))) =\n                      purge GH (map getGMUserCom (purgeIdle (tl [])))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>wffp xs; wffp ys; list_all2 f xs ys\\<rbrakk>\n        \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl xs))) =\n                          purge GH (map getGMUserCom (purgeIdle (tl ys)));\n        wffp (x # xs); wffp (y # ys); list_all2 f (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> purge GH\n                          (map getGMUserCom (purgeIdle (tl (x # xs)))) =\n                         purge GH\n                          (map getGMUserCom (purgeIdle (tl (y # ys))))", "case Nil"], ["proof (state)\nthis:\n  wffp []\n  wffp []\n  list_all2 f [] []\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wffp []; wffp []; list_all2 f [] []\\<rbrakk>\n    \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl []))) =\n                      purge GH (map getGMUserCom (purgeIdle (tl [])))\n 2. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>wffp xs; wffp ys; list_all2 f xs ys\\<rbrakk>\n        \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl xs))) =\n                          purge GH (map getGMUserCom (purgeIdle (tl ys)));\n        wffp (x # xs); wffp (y # ys); list_all2 f (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> purge GH\n                          (map getGMUserCom (purgeIdle (tl (x # xs)))) =\n                         purge GH\n                          (map getGMUserCom (purgeIdle (tl (y # ys))))", "thus ?case"], ["proof (prove)\nusing this:\n  wffp []\n  wffp []\n  list_all2 f [] []\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl []))) =\n    purge GH (map getGMUserCom (purgeIdle (tl [])))", "by auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl []))) =\n  purge GH (map getGMUserCom (purgeIdle (tl [])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>wffp xs; wffp ys; list_all2 f xs ys\\<rbrakk>\n        \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl xs))) =\n                          purge GH (map getGMUserCom (purgeIdle (tl ys)));\n        wffp (x # xs); wffp (y # ys); list_all2 f (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> purge GH\n                          (map getGMUserCom (purgeIdle (tl (x # xs)))) =\n                         purge GH\n                          (map getGMUserCom (purgeIdle (tl (y # ys))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>wffp xs; wffp ys; list_all2 f xs ys\\<rbrakk>\n        \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl xs))) =\n                          purge GH (map getGMUserCom (purgeIdle (tl ys)));\n        wffp (x # xs); wffp (y # ys); list_all2 f (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> purge GH\n                          (map getGMUserCom (purgeIdle (tl (x # xs)))) =\n                         purge GH\n                          (map getGMUserCom (purgeIdle (tl (y # ys))))", "case (Cons s sl s' sl')"], ["proof (state)\nthis:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n\ngoal (1 subgoal):\n 1. \\<And>x xs y ys.\n       \\<lbrakk>length xs = length ys;\n        \\<lbrakk>wffp xs; wffp ys; list_all2 f xs ys\\<rbrakk>\n        \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl xs))) =\n                          purge GH (map getGMUserCom (purgeIdle (tl ys)));\n        wffp (x # xs); wffp (y # ys); list_all2 f (x # xs) (y # ys)\\<rbrakk>\n       \\<Longrightarrow> purge GH\n                          (map getGMUserCom (purgeIdle (tl (x # xs)))) =\n                         purge GH\n                          (map getGMUserCom (purgeIdle (tl (y # ys))))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "proof(cases \"sl = []\")"], ["proof (state)\ngoal (2 subgoals):\n 1. sl = [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case True"], ["proof (state)\nthis:\n  sl = []\n\ngoal (2 subgoals):\n 1. sl = [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "hence \"sl' = []\""], ["proof (prove)\nusing this:\n  sl = []\n\ngoal (1 subgoal):\n 1. sl' = []", "using Cons"], ["proof (prove)\nusing this:\n  sl = []\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n\ngoal (1 subgoal):\n 1. sl' = []", "by auto"], ["proof (state)\nthis:\n  sl' = []\n\ngoal (2 subgoals):\n 1. sl = [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sl' = []\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "using True"], ["proof (prove)\nusing this:\n  sl' = []\n  sl = []\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "by auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case False"], ["proof (state)\nthis:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "hence sl: \"sl = hd sl # tl sl\""], ["proof (prove)\nusing this:\n  sl \\<noteq> []\n\ngoal (1 subgoal):\n 1. sl = hd sl # tl sl", "by (cases sl) auto"], ["proof (state)\nthis:\n  sl = hd sl # tl sl\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "hence sl': \"sl' = hd sl' # tl sl'\""], ["proof (prove)\nusing this:\n  sl = hd sl # tl sl\n\ngoal (1 subgoal):\n 1. sl' = hd sl' # tl sl'", "using \\<open>length sl = length sl'\\<close>"], ["proof (prove)\nusing this:\n  sl = hd sl # tl sl\n  length sl = length sl'\n\ngoal (1 subgoal):\n 1. sl' = hd sl' # tl sl'", "by (cases sl') auto"], ["proof (state)\nthis:\n  sl' = hd sl' # tl sl'\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "hence wsl[simp]: \"wffp sl\" and wsl'[simp]: \"wffp sl'\""], ["proof (prove)\nusing this:\n  sl' = hd sl' # tl sl'\n\ngoal (1 subgoal):\n 1. wffp sl &&& wffp sl'", "using sl Cons"], ["proof (prove)\nusing this:\n  sl' = hd sl' # tl sl'\n  sl = hd sl # tl sl\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n\ngoal (1 subgoal):\n 1. wffp sl &&& wffp sl'", "by (metis Cons.prems append_singl_rev list.distinct sl' wffp_imp_appendR)+"], ["proof (state)\nthis:\n  wffp sl\n  wffp sl'\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "have f: \"f (hd sl) (hd sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (hd sl) (hd sl')", "using \\<open>list_all2 f (s # sl) (s' # sl')\\<close> sl sl'"], ["proof (prove)\nusing this:\n  list_all2 f (s # sl) (s' # sl')\n  sl = hd sl # tl sl\n  sl' = hd sl' # tl sl'\n\ngoal (1 subgoal):\n 1. f (hd sl) (hd sl')", "by (metis list_all2_Cons)"], ["proof (state)\nthis:\n  f (hd sl) (hd sl')\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] \\<Longrightarrow>\n    purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "proof(cases \"hd sl\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (Idle st)"], ["proof (state)\nthis:\n  hd sl = Idle st\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl = Idle"], ["proof (state)\nthis:\n  hd sl = Idle st\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "proof(cases \"hd sl'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (Idle st')"], ["proof (state)\nthis:\n  hd sl' = Idle st'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl' = Idle"], ["proof (state)\nthis:\n  hd sl' = Idle st'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "apply(subst sl, subst sl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "using Cons"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # Idle st # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # Idle st' # tl sl'))))", "by auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (State st' u' c')"], ["proof (state)\nthis:\n  hd sl' = State st' u' c'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl' = State"], ["proof (state)\nthis:\n  hd sl' = State st' u' c'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "have u': \"u' \\<in> GH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u' \\<in> GH", "using f"], ["proof (prove)\nusing this:\n  f (hd sl) (hd sl')\n\ngoal (1 subgoal):\n 1. u' \\<in> GH", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  f (Idle st) (State st' u' c')\n\ngoal (1 subgoal):\n 1. u' \\<in> GH", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  u' \\<in> GH\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "apply(subst sl, subst sl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "using Cons u'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  u' \\<in> GH\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  u' \\<in> GH\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # Idle st # tl sl)))) =\n    purge GH\n     (map getGMUserCom (purgeIdle (tl (s' # State st' u' c' # tl sl'))))", "by auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (State st u c)"], ["proof (state)\nthis:\n  hd sl = State st u c\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl = State"], ["proof (state)\nthis:\n  hd sl = State st u c\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "proof(cases \"hd sl'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (Idle st')"], ["proof (state)\nthis:\n  hd sl' = Idle st'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl' = Idle"], ["proof (state)\nthis:\n  hd sl' = Idle st'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "have u: \"u \\<in> GH\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u \\<in> GH", "using f"], ["proof (prove)\nusing this:\n  f (hd sl) (hd sl')\n\ngoal (1 subgoal):\n 1. u \\<in> GH", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  f (State st u c) (Idle st')\n\ngoal (1 subgoal):\n 1. u \\<in> GH", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  u \\<in> GH\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       hd sl' = Idle x1 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n 2. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "apply(subst sl, subst sl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "using Cons u"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  u \\<in> GH\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  u \\<in> GH\n\ngoal (1 subgoal):\n 1. purge GH\n     (map getGMUserCom (purgeIdle (tl (s # State st u c # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # Idle st' # tl sl'))))", "by auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "case (State st' u' c')"], ["proof (state)\nthis:\n  hd sl' = State st' u' c'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "note hsl' = State"], ["proof (state)\nthis:\n  hd sl' = State st' u' c'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "have uu': \"(u' \\<in> GH \\<longleftrightarrow> u \\<in> GH) \\<and> (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u' \\<in> GH) = (u \\<in> GH) \\<and>\n    (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)", "using f"], ["proof (prove)\nusing this:\n  f (hd sl) (hd sl')\n\ngoal (1 subgoal):\n 1. (u' \\<in> GH) = (u \\<in> GH) \\<and>\n    (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  f (State st u c) (State st' u' c')\n\ngoal (1 subgoal):\n 1. (u' \\<in> GH) = (u \\<in> GH) \\<and>\n    (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)", "by (auto simp: f_def)"], ["proof (state)\nthis:\n  (u' \\<in> GH) = (u \\<in> GH) \\<and>\n  (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22 x23.\n       hd sl' = State x21 x22 x23 \\<Longrightarrow>\n       purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n       purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))", "apply(subst sl, subst sl')"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "using Cons uu'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  (u' \\<in> GH) = (u \\<in> GH) \\<and>\n  (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)\n\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl (s # hd sl # tl sl)))) =\n    purge GH (map getGMUserCom (purgeIdle (tl (s' # hd sl' # tl sl'))))", "unfolding hsl hsl'"], ["proof (prove)\nusing this:\n  length sl = length sl'\n  \\<lbrakk>wffp sl; wffp sl'; list_all2 f sl sl'\\<rbrakk>\n  \\<Longrightarrow> purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n                    purge GH (map getGMUserCom (purgeIdle (tl sl')))\n  wffp (s # sl)\n  wffp (s' # sl')\n  list_all2 f (s # sl) (s' # sl')\n  (u' \\<in> GH) = (u \\<in> GH) \\<and>\n  (u \\<notin> GH \\<longrightarrow> u' = u \\<and> c' = c)\n\ngoal (1 subgoal):\n 1. purge GH\n     (map getGMUserCom (purgeIdle (tl (s # State st u c # tl sl)))) =\n    purge GH\n     (map getGMUserCom (purgeIdle (tl (s' # State st' u' c' # tl sl'))))", "by (cases \"u \\<in> GH\") auto"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  purge GH (map getGMUserCom (purgeIdle (tl (s # sl)))) =\n  purge GH (map getGMUserCom (purgeIdle (tl (s' # sl'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  purge GH ucl = purge GH ucl'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nonintS_iff_nonint:\n\"nonintS \\<longleftrightarrow> nonint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonintS = nonint", "unfolding nonintS_def nonint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>sl sl'.\n        wffp sl \\<and>\n        wffp sl' \\<and>\n        hd sl = s0 \\<and>\n        hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n        g (last sl) (last sl')) =\n    (\\<forall>ucl.\n        \\<forall>u\\<in>GL.\n           out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u)", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "fix ucl u"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "assume\n  1: \"\\<forall>sl sl'. wffp sl \\<and> wffp sl' \\<and> hd sl = s0 \\<and> hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n               g (last sl) (last sl')\"\n  and u: \"u \\<in> GL\""], ["proof (state)\nthis:\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n     g (last sl) (last sl')\n  u \\<in> GL\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "obtain sl where wsl: \"wffp sl\" and l: \"list_all isState sl\" and hsl: \"hd sl = s0\"\n  and m: \"map getGMUserCom (tl sl) = ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sl.\n        \\<lbrakk>wffp sl; list_all isState sl; hd sl = s0;\n         map getGMUserCom (tl sl) = ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using map_getGMUserCom_surj[of s0]"], ["proof (prove)\nusing this:\n  isState s0 \\<Longrightarrow>\n  \\<exists>sl.\n     wffp sl \\<and>\n     list_all isState sl \\<and>\n     hd sl = s0 \\<and> map getGMUserCom (tl sl) = ?ucl\n\ngoal (1 subgoal):\n 1. (\\<And>sl.\n        \\<lbrakk>wffp sl; list_all isState sl; hd sl = s0;\n         map getGMUserCom (tl sl) = ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  wffp sl\n  list_all isState sl\n  hd sl = s0\n  map getGMUserCom (tl sl) = ucl\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "then"], ["proof (chain)\npicking this:\n  wffp sl\n  list_all isState sl\n  hd sl = s0\n  map getGMUserCom (tl sl) = ucl", "obtain sl' where hsl': \"hd sl' = hd sl\" and wsl': \"wffp sl'\" and f: \"list_all2 f (tl sl) (tl sl')\"\n  and m': \"map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\""], ["proof (prove)\nusing this:\n  wffp sl\n  list_all isState sl\n  hd sl = s0\n  map getGMUserCom (tl sl) = ucl\n\ngoal (1 subgoal):\n 1. (\\<And>sl'.\n        \\<lbrakk>hd sl' = hd sl; wffp sl'; list_all2 f (tl sl) (tl sl');\n         map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis purgeIdle_purge_ex)"], ["proof (state)\nthis:\n  hd sl' = hd sl\n  wffp sl'\n  list_all2 f (tl sl) (tl sl')\n  map getGMUserCom (purgeIdle (tl sl')) = purge GH ucl\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have slNE: \"sl \\<noteq> []\" and sl'NE: \"sl' \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sl \\<noteq> [] &&& sl' \\<noteq> []", "using wsl wsl'"], ["proof (prove)\nusing this:\n  wffp sl\n  wffp sl'\n\ngoal (1 subgoal):\n 1. sl \\<noteq> [] &&& sl' \\<noteq> []", "by (metis wffp_NE)+"], ["proof (state)\nthis:\n  sl \\<noteq> []\n  sl' \\<noteq> []\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have 2: \"getGMState (hd sl) = st0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (hd sl) = st0", "unfolding hsl"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState s0 = st0", "by auto"], ["proof (state)\nthis:\n  local.getGMState (hd sl) = st0\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have 3: \"tl (purgeIdle sl') = purgeIdle (tl sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (purgeIdle sl') = purgeIdle (tl sl')", "apply(subst hd_Cons_tl[OF sl'NE, symmetric], rule sym, subst hd_Cons_tl[OF sl'NE, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (tl (hd sl' # tl sl')) = tl (purgeIdle (hd sl' # tl sl'))", "unfolding hsl hsl'"], ["proof (prove)\ngoal (1 subgoal):\n 1. purgeIdle (tl (s0 # tl sl')) = tl (purgeIdle (s0 # tl sl'))", "by auto"], ["proof (state)\nthis:\n  tl (purgeIdle sl') = purgeIdle (tl sl')\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have f: \"list_all2 f sl sl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 f sl sl'", "apply (subst hd_Cons_tl[OF slNE, symmetric], subst hd_Cons_tl[OF sl'NE, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 f (hd sl # tl sl) (hd sl' # tl sl')", "using f hsl'"], ["proof (prove)\nusing this:\n  list_all2 f (tl sl) (tl sl')\n  hd sl' = hd sl\n\ngoal (1 subgoal):\n 1. list_all2 f (hd sl # tl sl) (hd sl' # tl sl')", "unfolding f_def"], ["proof (prove)\nusing this:\n  list_all2\n   (\\<lambda>s s'.\n       \\<forall>u c.\n          u \\<notin> GH \\<longrightarrow>\n          (\\<exists>st. s = State st u c) =\n          (\\<exists>st'. s' = State st' u c))\n   (tl sl) (tl sl')\n  hd sl' = hd sl\n\ngoal (1 subgoal):\n 1. list_all2\n     (\\<lambda>s s'.\n         \\<forall>u c.\n            u \\<notin> GH \\<longrightarrow>\n            (\\<exists>st. s = State st u c) =\n            (\\<exists>st'. s' = State st' u c))\n     (hd sl # tl sl) (hd sl' # tl sl')", "by auto"], ["proof (state)\nthis:\n  list_all2 f sl sl'\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "hence g: \"g (last sl) (last sl')\""], ["proof (prove)\nusing this:\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. g (last sl) (last sl')", "using 1 wsl wsl' hsl hsl'"], ["proof (prove)\nusing this:\n  list_all2 f sl sl'\n  \\<forall>sl sl'.\n     wffp sl \\<and>\n     wffp sl' \\<and>\n     hd sl = s0 \\<and>\n     hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n     g (last sl) (last sl')\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = hd sl\n\ngoal (1 subgoal):\n 1. g (last sl) (last sl')", "by auto"], ["proof (state)\nthis:\n  g (last sl) (last sl')\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "moreover"], ["proof (state)\nthis:\n  g (last sl) (last sl')\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have \"getGMState (last sl) = doo st0 ucl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last sl) = doo st0 ucl", "unfolding m[symmetric] 2[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last sl) =\n    doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl))", "using wffp_isState_doo[OF wsl l]"], ["proof (prove)\nusing this:\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl)) =\n  local.getGMState (last sl)\n\ngoal (1 subgoal):\n 1. local.getGMState (last sl) =\n    doo (local.getGMState (hd sl)) (map getGMUserCom (tl sl))", "by simp"], ["proof (state)\nthis:\n  local.getGMState (last sl) = doo st0 ucl\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "moreover"], ["proof (state)\nthis:\n  local.getGMState (last sl) = doo st0 ucl\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have \"getGMState (last sl') = doo st0 (purge GH ucl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last sl') = doo st0 (purge GH ucl)", "using wffp_isState_doo_purgeIdle[OF wsl']"], ["proof (prove)\nusing this:\n  isState (hd sl') \\<Longrightarrow>\n  doo (local.getGMState (hd sl')) (map getGMUserCom (tl (purgeIdle sl'))) =\n  local.getGMState (last sl')\n\ngoal (1 subgoal):\n 1. local.getGMState (last sl') = doo st0 (purge GH ucl)", "unfolding hsl' hsl m' 3"], ["proof (prove)\nusing this:\n  isState s0 \\<Longrightarrow>\n  doo (local.getGMState s0) (purge GH ucl) = local.getGMState (last sl')\n\ngoal (1 subgoal):\n 1. local.getGMState (last sl') = doo st0 (purge GH ucl)", "by auto"], ["proof (state)\nthis:\n  local.getGMState (last sl') = doo st0 (purge GH ucl)\n\ngoal (2 subgoals):\n 1. \\<And>ucl u.\n       \\<lbrakk>\\<forall>sl sl'.\n                   wffp sl \\<and>\n                   wffp sl' \\<and>\n                   hd sl = s0 \\<and>\n                   hd sl' = s0 \\<and> list_all2 f sl sl' \\<longrightarrow>\n                   g (last sl) (last sl');\n        u \\<in> GL\\<rbrakk>\n       \\<Longrightarrow> out (doo st0 ucl) u =\n                         out (doo st0 (purge GH ucl)) u\n 2. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "ultimately"], ["proof (chain)\npicking this:\n  g (last sl) (last sl')\n  local.getGMState (last sl) = doo st0 ucl\n  local.getGMState (last sl') = doo st0 (purge GH ucl)", "show \"out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\""], ["proof (prove)\nusing this:\n  g (last sl) (last sl')\n  local.getGMState (last sl) = doo st0 ucl\n  local.getGMState (last sl') = doo st0 (purge GH ucl)\n\ngoal (1 subgoal):\n 1. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u", "unfolding g_def"], ["proof (prove)\nusing this:\n  \\<forall>u1.\n     u1 \\<in> GL \\<longrightarrow>\n     out (local.getGMState (last sl)) u1 =\n     out (local.getGMState (last sl')) u1\n  local.getGMState (last sl) = doo st0 ucl\n  local.getGMState (last sl') = doo st0 (purge GH ucl)\n\ngoal (1 subgoal):\n 1. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u", "using u"], ["proof (prove)\nusing this:\n  \\<forall>u1.\n     u1 \\<in> GL \\<longrightarrow>\n     out (local.getGMState (last sl)) u1 =\n     out (local.getGMState (last sl')) u1\n  local.getGMState (last sl) = doo st0 ucl\n  local.getGMState (last sl') = doo st0 (purge GH ucl)\n  u \\<in> GL\n\ngoal (1 subgoal):\n 1. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u", "by auto"], ["proof (state)\nthis:\n  out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "fix sl sl'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "assume 1: \"\\<forall>ucl. \\<forall>u\\<in>GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\"\n  and wsl: \"wffp sl\" and wsl': \"wffp sl'\" and hsl: \"hd sl = s0\" and hsl': \"hd sl' = s0\"\n  and f: \"list_all2 f sl sl'\""], ["proof (state)\nthis:\n  \\<forall>ucl.\n     \\<forall>u\\<in>GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\n  wffp sl\n  wffp sl'\n  hd sl = s0\n  hd sl' = s0\n  list_all2 f sl sl'\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "define ucl where \"ucl = map getGMUserCom (tl (purgeIdle sl))\""], ["proof (state)\nthis:\n  ucl = map getGMUserCom (tl (purgeIdle sl))\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "define ucl' where \"ucl' = map getGMUserCom (tl (purgeIdle sl'))\""], ["proof (state)\nthis:\n  ucl' = map getGMUserCom (tl (purgeIdle sl'))\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have 2: \"tl (purgeIdle sl) = purgeIdle (tl sl)\" \"tl (purgeIdle sl') = purgeIdle (tl sl')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tl (purgeIdle sl) = purgeIdle (tl sl) &&&\n    tl (purgeIdle sl') = purgeIdle (tl sl')", "by (subst hd_Cons_tl[OF wffp_NE[OF wsl], symmetric, unfolded hsl], auto)[]\n     (subst hd_Cons_tl[OF wffp_NE[OF wsl'], symmetric, unfolded hsl'], auto)"], ["proof (state)\nthis:\n  tl (purgeIdle sl) = purgeIdle (tl sl)\n  tl (purgeIdle sl') = purgeIdle (tl sl')\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have \"purge GH ucl = purge GH ucl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH ucl = purge GH ucl'", "unfolding ucl_def ucl'_def 2"], ["proof (prove)\ngoal (1 subgoal):\n 1. purge GH (map getGMUserCom (purgeIdle (tl sl))) =\n    purge GH (map getGMUserCom (purgeIdle (tl sl')))", "by (metis purgeIdle_getGMUserCom_purge f wsl wsl')"], ["proof (state)\nthis:\n  purge GH ucl = purge GH ucl'\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "moreover"], ["proof (state)\nthis:\n  purge GH ucl = purge GH ucl'\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "have \"getGMState (last sl) = doo st0 ucl \\<and> getGMState (last sl') = doo st0 ucl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.getGMState (last sl) = doo st0 ucl \\<and>\n    local.getGMState (last sl') = doo st0 ucl'", "using wffp_isState_doo_purgeIdle[OF wsl] wffp_isState_doo_purgeIdle[OF wsl']"], ["proof (prove)\nusing this:\n  isState (hd sl) \\<Longrightarrow>\n  doo (local.getGMState (hd sl)) (map getGMUserCom (tl (purgeIdle sl))) =\n  local.getGMState (last sl)\n  isState (hd sl') \\<Longrightarrow>\n  doo (local.getGMState (hd sl')) (map getGMUserCom (tl (purgeIdle sl'))) =\n  local.getGMState (last sl')\n\ngoal (1 subgoal):\n 1. local.getGMState (last sl) = doo st0 ucl \\<and>\n    local.getGMState (last sl') = doo st0 ucl'", "unfolding hsl hsl' ucl_def ucl'_def"], ["proof (prove)\nusing this:\n  isState s0 \\<Longrightarrow>\n  doo (local.getGMState s0) (map getGMUserCom (tl (purgeIdle sl))) =\n  local.getGMState (last sl)\n  isState s0 \\<Longrightarrow>\n  doo (local.getGMState s0) (map getGMUserCom (tl (purgeIdle sl'))) =\n  local.getGMState (last sl')\n\ngoal (1 subgoal):\n 1. local.getGMState (last sl) =\n    doo st0 (map getGMUserCom (tl (purgeIdle sl))) \\<and>\n    local.getGMState (last sl') =\n    doo st0 (map getGMUserCom (tl (purgeIdle sl')))", "by auto"], ["proof (state)\nthis:\n  local.getGMState (last sl) = doo st0 ucl \\<and>\n  local.getGMState (last sl') = doo st0 ucl'\n\ngoal (1 subgoal):\n 1. \\<And>sl sl'.\n       \\<lbrakk>\\<forall>ucl.\n                   \\<forall>u\\<in>GL.\n                      out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u;\n        wffp sl; wffp sl'; hd sl = s0; hd sl' = s0;\n        list_all2 f sl sl'\\<rbrakk>\n       \\<Longrightarrow> g (last sl) (last sl')", "ultimately"], ["proof (chain)\npicking this:\n  purge GH ucl = purge GH ucl'\n  local.getGMState (last sl) = doo st0 ucl \\<and>\n  local.getGMState (last sl') = doo st0 ucl'", "show \"g (last sl) (last sl')\""], ["proof (prove)\nusing this:\n  purge GH ucl = purge GH ucl'\n  local.getGMState (last sl) = doo st0 ucl \\<and>\n  local.getGMState (last sl') = doo st0 ucl'\n\ngoal (1 subgoal):\n 1. g (last sl) (last sl')", "unfolding g_def"], ["proof (prove)\nusing this:\n  purge GH ucl = purge GH ucl'\n  local.getGMState (last sl) = doo st0 ucl \\<and>\n  local.getGMState (last sl') = doo st0 ucl'\n\ngoal (1 subgoal):\n 1. \\<forall>u1.\n       u1 \\<in> GL \\<longrightarrow>\n       out (local.getGMState (last sl)) u1 =\n       out (local.getGMState (last sl')) u1", "using 1"], ["proof (prove)\nusing this:\n  purge GH ucl = purge GH ucl'\n  local.getGMState (last sl) = doo st0 ucl \\<and>\n  local.getGMState (last sl') = doo st0 ucl'\n  \\<forall>ucl.\n     \\<forall>u\\<in>GL. out (doo st0 ucl) u = out (doo st0 (purge GH ucl)) u\n\ngoal (1 subgoal):\n 1. \\<forall>u1.\n       u1 \\<in> GL \\<longrightarrow>\n       out (local.getGMState (last sl)) u1 =\n       out (local.getGMState (last sl')) u1", "by metis"], ["proof (state)\nthis:\n  g (last sl) (last sl')\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem nonintSfmla_iff_nonint:\n\"nonintSfmla [] \\<longleftrightarrow> nonint\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nonintSfmla [] = nonint", "by (metis nonintSI_nonintS nonintS_iff_nonint nonintSfmla_nonintSI)"], ["", "(*<*)"], ["", "end"], ["", "(* context GM_sec_model *)\n(*>*)"], ["", "text\\<open>end-of-context GM-sec-model\\<close>"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}