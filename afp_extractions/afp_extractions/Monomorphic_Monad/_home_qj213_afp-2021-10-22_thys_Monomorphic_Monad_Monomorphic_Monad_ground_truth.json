{"file_name": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad/Monomorphic_Monad.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad", "problem_names": ["lemma (in comp_fun_idem) fold_set_union:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> Finite_Set.fold f x (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f x A) B\"", "lemma (in comp_fun_idem) ffold_set_union: \"ffold f x (A |\\<union>| B) = ffold f (ffold f x A) B\"", "lemma relcompp_top_top [simp]: \"top OO top = top\"", "lemma type_parametric [transfer_rule]: \"rel_itself TYPE('a) TYPE('b)\"", "lemma plus_multiset_parametric [transfer_rule]:\n  \"(rel_mset A ===> rel_mset A ===> rel_mset A) (+) (+)\"", "lemma Mempty_parametric [transfer_rule]: \"rel_mset A {#} {#}\"", "lemma fold_mset_parametric:\n  assumes 12: \"(A ===> B ===> B) f1 f2\"\n  and \"comp_fun_commute f1\" \"comp_fun_commute f2\"\n  shows \"(B ===> rel_mset A ===> B) (fold_mset f1) (fold_mset f2)\"", "lemma rel_fset_induct [consumes 1, case_names empty step, induct pred: rel_fset]:\n  assumes XY: \"rel_fset A X Y\"\n    and empty: \"P {||} {||}\"\n    and step: \"\\<And>X Y x y. \\<lbrakk> rel_fset A X Y; P X Y; A x y; x |\\<notin>| X \\<or> y |\\<notin>| Y \\<rbrakk> \\<Longrightarrow> P (finsert x X) (finsert y Y)\"\n  shows \"P X Y\"", "lemma ffold_parametric:\n  assumes 12: \"(A ===> B ===> B) f1 f2\"\n  and \"comp_fun_idem f1\" \"comp_fun_idem f2\"\n  shows \"(B ===> rel_fset A ===> B) (ffold f1) (ffold f2)\"", "lemma rel_set_Grp: \"rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {X. X \\<subseteq> A} (image f)\"", "lemma cUNION_assoc: \"cUNION (cUNION A f) g = cUNION A (\\<lambda>x. cUNION (f x) g)\"", "lemma cUnion_cempty [simp]: \"cUnion cempty = cempty\"", "lemma cUNION_cempty [simp]: \"cUNION cempty f = cempty\"", "lemma cUnion_cinsert: \"cUnion (cinsert x A) = cUn x (cUnion A)\"", "lemma cUNION_cinsert: \"cUNION (cinsert x A) f = cUn (f x) (cUNION A f)\"", "lemma cUnion_csingle [simp]: \"cUnion (csingle x) = x\"", "lemma cUNION_csingle [simp]: \"cUNION (csingle x) f = f x\"", "lemma cUNION_csingle2 [simp]: \"cUNION A csingle = A\"", "lemma cUNION_cUn: \"cUNION (cUn A B) f = cUn (cUNION A f) (cUNION B f)\"", "lemma cUNION_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_cset A ===> (A ===> rel_cset B) ===> rel_cset B) cUNION cUNION\"", "lemma three_neq_aux: \"\\<^bold>1 \\<noteq> \\<^bold>2\" \"\\<^bold>1 \\<noteq> \\<^bold>3\" \"\\<^bold>2 \\<noteq> \\<^bold>3\"", "lemmas three_neq [simp] = three_neq_aux three_neq_aux[symmetric]", "lemma bi_unique_rel_12_23 [simp, transfer_rule]: \"bi_unique rel_12_23\"", "lemma bi_unique_rel_12_21 [simp, transfer_rule]: \"bi_unique rel_12_21\"", "lemma bernoulli_pmf_0: \"bernoulli_pmf 0 = return_pmf False\"", "lemma bernoulli_pmf_1: \"bernoulli_pmf 1 = return_pmf True\"", "lemma bernoulli_Not: \"map_pmf Not (bernoulli_pmf r) = bernoulli_pmf (1 - r)\"", "lemma pmf_eqI_avoid: \"p = q\" if \"\\<And>i. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i\"", "lemma sequence_parametric [transfer_rule]:\n  \"((M ===> (A ===> M) ===> M) ===> list_all2 M ===> (list_all2 A ===> M) ===> M) monad_base.sequence monad_base.sequence\"", "lemma lift_parametric [transfer_rule]:\n  \"((A ===> M) ===> (M ===> (A ===> M) ===> M) ===> (A ===> A) ===> M ===> M) monad_base.lift monad_base.lift\"", "lemma bind_lift [simp]: \"bind (lift f x) g = bind x (g \\<circ> f)\"", "lemma lift_bind [simp]: \"lift f (bind m g) = bind m (\\<lambda>x. lift f (g x))\"", "lemma update_parametric [transfer_rule]: includes lifting_syntax shows  \n  \"(((S ===> M) ===> M) ===> (S ===> M ===> M) ===> (S ===> S) ===> M ===> M)\n   monad_state_base.update monad_state_base.update\"", "lemma put_update: \"put s (update f m) = put (f s) m\"", "lemma update_put: \"update f (put s m) = put s m\"", "lemma bind_update: \"bind (update f m) g = update f (bind m g)\"", "lemma update_get: \"update f (get g) = get (update f \\<circ> g \\<circ> f)\"", "lemma update_const: \"update (\\<lambda>_. s) m = put s m\"", "lemma update_update: \"update f (update g m) = update (g \\<circ> f) m\"", "lemma update_id: \"update id m = m\"", "lemma assert_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> M) ===> (M ===> (A ===> M) ===> M) ===> M ===> (A ===> (=)) ===> M ===> M)\n   monad_fail_base.assert monad_fail_base.assert\"", "lemma assert_fail: \"assert P fail = fail\"", "lemma catch_update: \"catch (update f m) m' = update f (catch m m')\"", "lemma ask_bind: \"ask (\\<lambda>r. bind (f r) (g r)) = bind (ask f) (\\<lambda>x. ask (\\<lambda>r. g r x))\"", "lemma sample_cong: \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> f x = g x) \\<Longrightarrow> sample p f = sample q g\" if \"p = q\"", "lemma pchoose_0: \"m \\<lhd> 0 \\<rhd> m' = m'\"", "lemma pchoose_1: \"m \\<lhd> 1 \\<rhd> m' = m\"", "lemma pchoose_idemp: \"m \\<lhd> r \\<rhd> m = m\"", "lemma pchoose_bind1: \"bind (m \\<lhd> r \\<rhd> m') f = bind m f \\<lhd> r \\<rhd> bind m' f\"", "lemma pchoose_bind2: \"bind m (\\<lambda>x. f x \\<lhd> p \\<rhd> g x) = bind m f \\<lhd> p \\<rhd> bind m g\"", "lemma pchoose_commute: \"m \\<lhd> 1 - r \\<rhd> m' = m' \\<lhd> r \\<rhd> m\"", "lemma pchoose_assoc: \"m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') = (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\" (is \"?lhs = ?rhs\")\n  if \"min 1 (max 0 p) = min 1 (max 0 r) * min 1 (max 0 s)\"\n  and \"1 - min 1 (max 0 s) = (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\"", "lemma pchoose_assoc': \"m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') = (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\"\n  if \"p = r * s\" and \"1 - s = (1 - p) * (1 - q)\"\n  and \"0 \\<le> p\" \"p \\<le> 1\" \"0 \\<le> q\" \"q \\<le> 1\" \"0 \\<le> r\" \"r \\<le> 1\" \"0 \\<le> s\" \"s \\<le> 1\"", "lemma sample_put: \"sample p (\\<lambda>x. put s (m x)) = put s (sample p m)\"", "lemma sample_update: \"sample p (\\<lambda>x. update f (m x)) = update f (sample p m)\"", "lemma assert_alt: \"assert P (alt m m') = alt (assert P m) (assert P m')\"", "lemma alt_update: \"alt (update f m) (update f m') = update f (alt m m')\"", "lemma altc_cong: \"cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow> altc C f = altc C g\"", "lemma monad_fail [locale_witness]: \"monad_fail return bind fail\"", "lemma monad_alt: \"monad_alt return bind alt\"", "lemmas return_id_parametric = id.ctr_transfer", "lemma rel_id_unfold: \n  \"rel_id A (return_id x) m' \\<longleftrightarrow> (\\<exists>x'. m' = return_id x' \\<and> A x x')\"\n  \"rel_id A m (return_id x') \\<longleftrightarrow> (\\<exists>x. m = return_id x \\<and> A x x')\"", "lemma rel_id_expand: \"M (extract m) (extract m') \\<Longrightarrow> rel_id M m m'\"", "lemma extract_bind [simp]: \"extract (bind_id x f) = extract (f (extract x))\"", "lemma bind_id_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_id A ===> (A ===> rel_id A) ===> rel_id A) bind_id bind_id\"", "lemma monad_id [locale_witness]: \"monad return_id bind_id\"", "lemma monad_commute_id [locale_witness]: \"monad_commute return_id bind_id\"", "lemma monad_discard_id [locale_witness]: \"monad_discard return_id bind_id\"", "lemma monad_duplicate_id [locale_witness]: \"monad_duplicate return_id bind_id\"", "lemma monad_prob [locale_witness]: \"monad return_pmf bind_pmf\"", "lemma monad_prob_prob [locale_witness]: \"monad_prob return_pmf bind_pmf bind_pmf\"", "lemma monad_commute_prob [locale_witness]: \"monad_commute return_pmf bind_pmf\"", "lemma monad_discard_prob [locale_witness]: \"monad_discard return_pmf bind_pmf\"", "lemma is_Done_return_resumption [simp]: \"is_Done (return_resumption x)\"", "lemma result_return_resumption [simp]: \"result (return_resumption x) = x\"", "lemma monad_resumption [locale_witness]: \"monad return_resumption bind_resumption\"", "lemma monad_resumption_resumption [locale_witness]:\n  \"monad_resumption return_resumption bind_resumption pause_resumption\"", "lemma phantom_optionT [simp]: \"phantom_optionT x = {}\"", "lemma rel_optionT'_phantom: \"rel_optionT' A = rel_optionT' top\"", "lemma map_optionT'_phantom: \"map_optionT' f = map_optionT' undefined\"", "lemma rel_optionTE:\n  assumes \"rel_optionT M m m'\"\n  obtains x y where \"m = OptionT x\" \"m' = OptionT y\" \"M x y\"", "lemma rel_optionT_simps [simp]: \"rel_optionT M (OptionT m) (OptionT m') \\<longleftrightarrow> M m m'\"", "lemma rel_optionT_eq [relator_eq]: \"rel_optionT (=) = (=)\"", "lemma rel_optionT_mono [relator_mono]: \"rel_optionT A \\<le> rel_optionT B\" if \"A \\<le> B\"", "lemma rel_optionT_distr [relator_distr]: \"rel_optionT A OO rel_optionT B = rel_optionT (A OO B)\"", "lemma rel_optionT_Grp: \"rel_optionT (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_optionT x \\<subseteq> A} (map_optionT f)\"", "lemma OptionT_parametric [transfer_rule]: \"(M ===> rel_optionT M) OptionT OptionT\"", "lemma run_option_parametric [transfer_rule]: \"(rel_optionT M ===> M) run_option run_option\"", "lemma case_optionT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_optionT M ===> X) case_optionT case_optionT\"", "lemma rec_optionT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_optionT M ===> X) rec_optionT rec_optionT\"", "lemma run_bind_option:\n  \"run_option (bind_option x f) = bind (run_option x) (\\<lambda>x. case x of None \\<Rightarrow> return None | Some y \\<Rightarrow> run_option (f y))\"", "lemma run_return_option [simp]: \"run_option (return_option x) = return (Some x)\"", "lemma run_fail_option [simp]: \"run_option fail_option = return None\"", "lemma run_catch_option [simp]: \n  \"run_option (catch_option m1 m2) = bind (run_option m1) (\\<lambda>x. if x = None then run_option m2 else return x)\"", "lemma monad_optionT [locale_witness]: \"monad return_option bind_option\" (is \"monad ?return ?bind\")", "lemma monad_fail_optionT [locale_witness]:\n  \"monad_fail return_option bind_option fail_option\"", "lemma monad_catch_optionT [locale_witness]:\n  \"monad_catch return_option bind_option fail_option catch_option\"", "lemma run_ask_option [simp]: \"run_option (ask_option f) = ask (\\<lambda>r. run_option (f r))\"", "lemma monad_reader_optionT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_option bind_option ask_option\"", "lemma run_get_option [simp]:\n  \"run_option (get_option f) = get (\\<lambda>s. run_option (f s))\"", "lemma run_put_option [simp]:\n  \"run_option (put_option s m) = put s (run_option m)\"", "lemma monad_state_optionT [locale_witness]:\n  \"monad_state return_option bind_option get_option put_option\"", "lemma monad_catch_state_optionT [locale_witness]:\n  \"monad_catch_state return_option bind_option fail_option catch_option get_option put_option\"", "lemma run_altc_sample_option [simp]: \"run_option (altc_sample_option altc_sample p f) = altc_sample p (\\<lambda>x. run_option (f x))\"", "lemma monad_prob_optionT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_option bind_option sample_option\"", "lemma monad_state_prob_optionT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_option bind_option get_option put_option sample_option\"", "lemma run_tell_option [simp]: \"run_option (tell_option w m) = tell w (run_option m)\"", "lemma monad_writer_optionT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_option bind_option tell_option\"", "lemma run_alt_option [simp]: \"run_option (alt_option m1 m2) = alt (run_option m1) (run_option m2)\"", "lemma monad_alt_optionT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_option bind_option alt_option\"", "lemma monad_state_alt_optionT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_option bind_option get_option put_option alt_option\"", "lemma monad_altc_optionT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_option bind_option altc_option\"", "lemma monad_altc3_optionT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_option bind_option altc_option\"", "lemma monad_state_altc_optionT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_option bind_option get_option put_option altc_option\"", "lemma run_pause_option [simp]: \"run_option (pause_option out c) = pause out (\\<lambda>i. run_option (c i))\"", "lemma monad_resumption_optionT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_option bind_option pause_option\"", "lemma monad_commute_optionT [locale_witness]:\n  assumes \"monad_commute return bind\"\n  and \"monad_discard return bind\"\n  shows \"monad_commute return_option bind_option\"", "lemma monad_duplicate_optionT [locale_witness]:\n  assumes \"monad_duplicate return bind\"\n    and \"monad_discard return bind\"\n  shows \"monad_duplicate return_option bind_option\"", "lemma return_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> A ===> rel_optionT M) return_option return_option\"", "lemma bind_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> (M ===> (rel_option A ===> M) ===> M)\n   ===> rel_optionT M ===> (A ===> rel_optionT M) ===> rel_optionT M)\n   bind_option bind_option\"", "lemma fail_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> rel_optionT M) fail_option fail_option\"", "lemma catch_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> (M ===> (rel_option A ===> M) ===> M)\n   ===> rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n  catch_option catch_option\"", "lemma ask_option_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_optionT M) ===> rel_optionT M) ask_option ask_option\"", "lemma get_option_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_optionT M) ===> rel_optionT M) get_option get_option\"", "lemma put_option_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_optionT M ===> rel_optionT M) put_option put_option\"", "lemma altc_sample_option_parametric [transfer_rule]:\n  \"((A ===> (P ===> M) ===> M) ===> A ===> (P ===> rel_optionT M) ===> rel_optionT M)\n   altc_sample_option altc_sample_option\"", "lemma alt_option_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_optionT M ===> rel_optionT M ===> rel_optionT M) alt_option alt_option\"", "lemma tell_option_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_optionT M ===> rel_optionT M) tell_option tell_option\"", "lemma pause_option_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_optionT M) ===> rel_optionT M)\n   pause_option pause_option\"", "lemma rel_envTI [intro!]: \"(R ===> M) f g \\<Longrightarrow> rel_envT R M (EnvT f) (EnvT g)\"", "lemma rel_envT_simps: \"rel_envT R M (EnvT f) (EnvT g) \\<longleftrightarrow> (R ===> M) f g\"", "lemma rel_envTE [cases pred]:\n  assumes \"rel_envT R M m m'\"\n  obtains f g where \"m = EnvT f\" \"m' = EnvT g\" \"(R ===> M) f g\"", "lemma rel_envT_eq [relator_eq]: \"rel_envT (=) (=) = (=)\"", "lemma rel_envT_mono [relator_mono]: \"\\<lbrakk> R \\<le> R'; M \\<le> M' \\<rbrakk> \\<Longrightarrow> rel_envT R' M \\<le> rel_envT R M'\"", "lemma EnvT_parametric [transfer_rule]: \"((R ===> M) ===> rel_envT R M) EnvT EnvT\"", "lemma run_env_parametric [transfer_rule]: \"(rel_envT R M ===> R ===> M) run_env run_env\"", "lemma rec_envT_parametric [transfer_rule]:\n  \"(((R ===> M) ===> X) ===> rel_envT R M ===> X) rec_envT rec_envT\"", "lemma case_envT_parametric [transfer_rule]:\n  \"(((R ===> M) ===> X) ===> rel_envT R M ===> X) case_envT case_envT\"", "lemma run_bind_env [simp]: \"run_env (bind_env x f) r = bind (run_env x r) (\\<lambda>y. run_env (f y) r)\"", "lemma run_return_env [simp]: \"run_env (return_env x) r = return x\"", "lemma run_ask_env [simp]: \"run_env (ask_env f) r = run_env (f r) r\"", "lemma monad_envT [locale_witness]: \"monad return_env bind_env\"", "lemma monad_reader_envT [locale_witness]:\n  \"monad_reader return_env bind_env ask_env\"", "lemma run_fail_env [simp]: \"run_env fail_env r = fail\"", "lemma monad_fail_envT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_env bind_env fail_env\"", "lemma run_catch_env [simp]: \"run_env (catch_env m1 m2) r = catch (run_env m1 r) (run_env m2 r)\"", "lemma monad_catch_envT [locale_witness]:\n  assumes \"monad_catch return bind fail catch\"\n  shows \"monad_catch return_env bind_env fail_env catch_env\"", "lemma run_get_env [simp]: \"run_env (get_env f) r = get (\\<lambda>s. run_env (f s) r)\"", "lemma run_put_env [simp]: \"run_env (put_env s m) r = put s (run_env m r)\"", "lemma monad_state_envT [locale_witness]:\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_env bind_env get_env put_env\"", "lemma run_sample_env [simp]: \"run_env (sample_env p f) r = sample p (\\<lambda>x. run_env (f x) r)\"", "lemma monad_prob_envT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_env bind_env sample_env\"", "lemma monad_state_prob_envT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_env bind_env get_env put_env sample_env\"", "lemma run_alt_env [simp]: \"run_env (alt_env m1 m2) r = alt (run_env m1 r) (run_env m2 r)\"", "lemma monad_alt_envT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_env bind_env alt_env\"", "lemma monad_fail_alt_envT [locale_witness]:\n  fixes fail\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_env bind_env (fail_env fail) alt_env\"", "lemma monad_state_alt_envT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_env bind_env get_env put_env alt_env\"", "lemma run_altc_env [simp]: \"run_env (altc_env C f) r = altc C (\\<lambda>c. run_env (f c) r)\"", "lemma monad_altc_envT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_env bind_env altc_env\"", "lemma monad_altc3_envT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_env bind_env altc_env\"", "lemma monad_state_altc_envT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_env bind_env get_env put_env altc_env\"", "lemma run_pause_env [simp]:\n  \"run_env (pause_env out c) r = pause out (\\<lambda>i. run_env (c i) r)\"", "lemma monad_resumption_envT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_env bind_env pause_env\"", "lemma run_tell_env [simp]: \"run_env (tell_env w m) r = tell w (run_env m r)\"", "lemma monad_writer_envT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_env bind_env tell_env\"", "lemma monad_commute_envT [locale_witness]:\n  assumes \"monad_commute return bind\"\n  shows \"monad_commute return_env bind_env\"", "lemma monad_discard_envT [locale_witness]:\n  assumes \"monad_discard return bind\"\n  shows \"monad_discard return_env bind_env\"", "lemma monad_duplicate_envT [locale_witness]:\n  assumes \"monad_duplicate return bind\"\n  shows \"monad_duplicate return_env bind_env\"", "lemma return_env_parametric [transfer_rule]:\n  \"((A ===> M) ===> A ===> rel_envT R M) return_env return_env\"", "lemma bind_env_parametric [transfer_rule]:\n  \"((M ===> (A ===> M) ===> M) ===> rel_envT R M ===> (A ===> rel_envT R M) ===> rel_envT R M)\n   bind_env bind_env\"", "lemma ask_env_parametric [transfer_rule]: \"((R ===> rel_envT R M) ===> rel_envT R M) ask_env ask_env\"", "lemma fail_env_parametric [transfer_rule]: \"(M ===> rel_envT R M) fail_env fail_env\"", "lemma catch_env_parametric [transfer_rule]: \n  \"((M ===> M ===> M) ===> rel_envT R M ===> rel_envT R M ===> rel_envT R M) catch_env catch_env\"", "lemma get_env_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_envT R M) ===> rel_envT R M) get_env get_env\"", "lemma put_env_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_envT R M ===> rel_envT R M) put_env put_env\"", "lemma sample_env_parametric [transfer_rule]:\n  \"((rel_pmf P ===> (P ===> M) ===> M) ===> rel_pmf P ===> (P ===> rel_envT R M) ===> rel_envT R M)\n  sample_env sample_env\"", "lemma alt_env_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_envT R M ===> rel_envT R M ===> rel_envT R M) alt_env alt_env\"", "lemma altc_env_parametric [transfer_rule]:\n  \"((rel_cset C ===> (C ===> M) ===> M) ===> rel_cset C ===> (C ===> rel_envT R M) ===> rel_envT R M) \n   altc_env altc_env\"", "lemma pause_env_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_envT R M) ===> rel_envT R M)\n   pause_env pause_env\"", "lemma tell_env_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_envT R M ===> rel_envT R M) tell_env tell_env\"", "lemma monad_set [locale_witness]: \"monad return_set bind_set\"", "lemma monad_fail_set [locale_witness]: \"monad_fail return_set bind_set fail_set\"", "lemma monad_lift_set [simp]: \"monad_base.lift return_set bind_set  = image\"", "lemma monad_alt_set [locale_witness]: \"monad_alt return_set bind_set alt_set\"", "lemma monad_altc_set [locale_witness]: \"monad_altc return_set bind_set altc_set\"", "lemma monad_altc3_set [locale_witness]:\n  \"monad_altc3 return_set bind_set (altc_set :: ('c, 'a set) altc)\"\n  if [locale_witness]: \"three TYPE('c)\"", "lemma phantom_nondetT [simp]: \"phantom_nondetT x = {}\"", "lemma rel_nondetT'_phantom: \"rel_nondetT' A = rel_nondetT' top\"", "lemma map_nondetT'_phantom: \"map_nondetT' f = map_nondetT' undefined\"", "lemma rel_nondetTE:\n  assumes \"rel_nondetT M m m'\"\n  obtains x y where \"m = NondetT x\" \"m' = NondetT y\" \"M x y\"", "lemma rel_nondetT_simps [simp]: \"rel_nondetT M (NondetT m) (NondetT m') \\<longleftrightarrow> M m m'\"", "lemma rel_nondetT_unfold: \n  \"\\<And>m m'. rel_nondetT M (NondetT m) m' \\<longleftrightarrow> (\\<exists>m''. m' = NondetT m'' \\<and> M m m'')\"\n  \"\\<And>m m'. rel_nondetT M m (NondetT m') \\<longleftrightarrow> (\\<exists>m''. m = NondetT m'' \\<and> M m'' m')\"", "lemma rel_nondetT_expand: \"M (run_nondet m) (run_nondet m') \\<Longrightarrow> rel_nondetT M m m'\"", "lemma rel_nondetT_eq [relator_eq]: \"rel_nondetT (=) = (=)\"", "lemma rel_nondetT_mono [relator_mono]: \"rel_nondetT A \\<le> rel_nondetT B\" if \"A \\<le> B\"", "lemma rel_nondetT_distr [relator_distr]: \"rel_nondetT A OO rel_nondetT B = rel_nondetT (A OO B)\"", "lemma rel_nondetT_Grp: \"rel_nondetT (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_nondetT x \\<subseteq> A} (map_nondetT f)\"", "lemma NondetT_parametric [transfer_rule]: \"(M ===> rel_nondetT M) NondetT NondetT\"", "lemma run_nondet_parametric [transfer_rule]: \"(rel_nondetT M ===> M) run_nondet run_nondet\"", "lemma case_nondetT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_nondetT M ===> X) case_nondetT case_nondetT\"", "lemma rec_nondetT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_nondetT M ===> X) rec_nondetT rec_nondetT\"", "lemma run_return_nondet [simp]: \"run_nondet (return_nondet x) = return (single x)\"", "lemma run_bind_nondet [simp]:\n  \"run_nondet (bind_nondet m f) = bind (run_nondet m) (\\<lambda>A. merge A (run_nondet \\<circ> f))\"", "lemma run_fail_nondet [simp]: \"run_nondet fail_nondet = return empty\"", "lemma run_alt_nondet [simp]:\n  \"run_nondet (alt_nondet m1 m2) = bind (run_nondet m1) (\\<lambda>A. bind (run_nondet m2) (\\<lambda>B. return (A \\<^bold>\\<union> B)))\"", "lemma run_get_nondet [simp]: \"run_nondet (get_nondet get f) = get (\\<lambda>s. run_nondet (f s))\" for get", "lemma run_put_nondet [simp]: \"run_nondet (put_nondet put s m) = put s (run_nondet m)\" for put", "lemma run_ask_nondet [simp]: \"run_nondet (ask_nondet ask f) = ask (\\<lambda>r. run_nondet (f r))\" for ask", "lemma bind_nondet_cong [cong]:\n  \"nondetM_base.bind_nondet bind merge = nondetM_base.bind_nondet bind merge\" for bind merge", "lemmas [code] = \n  nondetM_base.return_nondet_def\n  nondetM_base.bind_nondet_def\n  nondetM_base.fail_nondet_def\n  nondetM_base.alt_nondet_def\n  nondetM_base.get_nondet_def\n  nondetM_base.put_nondet_def\n  nondetM_base.ask_nondet_def", "lemma monad_nondetT [locale_witness]: \"monad return_nondet bind_nondet\"", "lemma monad_fail_nondetT [locale_witness]: \"monad_fail return_nondet bind_nondet fail_nondet\"", "lemma monad_alt_nondetT [locale_witness]: \"monad_alt return_nondet bind_nondet alt_nondet\"", "lemma monad_fail_alt_nondetT [locale_witness]:\n  \"monad_fail_alt return_nondet bind_nondet fail_nondet alt_nondet\"", "lemma monad_state_nondetT [locale_witness]:\n  \\<comment> \\<open>It's not really sensible to assume a commutative state monad, but let's prove it anyway ...\\<close>\n  fixes get put\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)\"", "lemma monad_state_alt_nondetT [locale_witness]:\n  fixes get put\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state_alt return_nondet bind_nondet (get_nondet get) (put_nondet put) alt_nondet\"", "lemmas nondetM_lemmas =\n  nondetM.monad_nondetT\n  nondetM.monad_fail_nondetT\n  nondetM.monad_alt_nondetT\n  nondetM.monad_fail_alt_nondetT\n  nondetM.monad_state_nondetT", "lemma monad_reader_nondetT: \"monad_reader return_nondet bind_nondet (ask_nondet ask)\"", "lemmas nondetM_ask_lemmas =\n  nondetM_ask.monad_reader_nondetT", "lemma return_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> (A ===> S) ===> A ===> rel_nondetT M)\n   nondetM_base.return_nondet nondetM_base.return_nondet\"", "lemma bind_nondet_parametric [transfer_rule]:\n  \"((M ===> (S ===> M) ===> M) ===> (S ===> (A ===> M) ===> M) ===> \n    rel_nondetT M ===> (A ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.bind_nondet nondetM_base.bind_nondet\"", "lemma fail_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> S ===> rel_nondetT M) nondetM_base.fail_nondet nondetM_base.fail_nondet\"", "lemma alt_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> (M ===> (S ===> M) ===> M) ===> (S ===> S ===> S) ===>\n    rel_nondetT M ===> rel_nondetT M ===> rel_nondetT M)\n   nondetM_base.alt_nondet nondetM_base.alt_nondet\"", "lemma get_nondet_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.get_nondet nondetM_base.get_nondet\"", "lemma put_nondet_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_nondetT M ===> rel_nondetT M) \n   nondetM_base.put_nondet nondetM_base.put_nondet\"", "lemma ask_nondet_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.ask_nondet nondetM_base.ask_nondet\"", "lemma lUnionM_empty [simp]: \"lUnionM [] = return []\"", "lemma lUnionM_Cons [simp]: \"lUnionM (x # M) = lunionM x (lUnionM M)\" for x M", "lemma lunionM_return_empty1 [simp]: \"lunionM (return []) x = x\" for x", "lemma lunionM_return_empty2 [simp]: \"lunionM x (return []) = x\" for x", "lemma lunionM_return_return [simp]: \"lunionM (return A) (return B) = return (A @ B)\" for A B", "lemma lunionM_assoc: \"lunionM (lunionM x y) z = lunionM x (lunionM y z)\" for x y z", "lemma lunionM_lUnionM1: \"lunionM (lUnionM A) x = foldr lunionM A x\" for A x", "lemma lUnionM_append [simp]: \"lUnionM (A @ B) = lunionM (lUnionM A) (lUnionM B)\" for A B", "lemma lUnionM_return [simp]: \"lUnionM (map (\\<lambda>x. return [x]) A) = return A\" for A", "lemma bind_lunionM: \"bind (lunionM m m') f = lunionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A @ B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x @ y)))\" for m m' f", "lemma list_nondetM: \"nondetM return bind lmerge [] (\\<lambda>x. [x]) (@)\"", "lemma list_nondetM_ask:\n  notes list_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask lmerge [] (\\<lambda>x. [x]) (@)\"", "lemmas list_nondetMs [locale_witness] =\n  nondetM_lemmas[OF list_nondetM]\n  nondetM_ask_lemmas[OF list_nondetM_ask]", "lemma lmerge_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((list_all2 A ===> M) ===> (M ===> (list_all2 A ===> M) ===> M)\n    ===> list_all2 A ===> (A ===> M) ===> M)\n   lmerge lmerge\"", "lemma munionM_comp_fun_commute: \"comp_fun_commute munionM\"", "lemma mUnionM_empty [simp]: \"mUnionM {#} = return {#}\"", "lemma mUnionM_add_mset [simp]: \"mUnionM (add_mset x M) = munionM x (mUnionM M)\" for x M", "lemma munionM_return_empty1 [simp]: \"munionM (return {#}) x = x\" for x", "lemma munionM_return_empty2 [simp]: \"munionM x (return {#}) = x\" for x", "lemma munionM_return_return [simp]: \"munionM (return A) (return B) = return (A + B)\" for A B", "lemma munionM_assoc: \"munionM (munionM x y) z = munionM x (munionM y z)\" for x y z", "lemma munionM_commute: \"munionM x y = munionM y x\" for x y", "lemma munionM_mUnionM1: \"munionM (mUnionM A) x = fold_mset munionM x A\" for A x", "lemma munionM_mUnionM2: \"munionM x (mUnionM A) = fold_mset munionM x A\" for x A", "lemma mUnionM_add [simp]: \"mUnionM (A + B) = munionM (mUnionM A) (mUnionM B)\" for A B", "lemma mUnionM_return [simp]: \"mUnionM (image_mset (\\<lambda>x. return {#x#}) A) = return A\" for A", "lemma bind_munionM: \"bind (munionM m m') f = munionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A + B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x + y)))\" for m m' f", "lemma mset_nondetM: \"nondetM return bind mmerge {#} (\\<lambda>x. {#x#}) (+)\"", "lemma mset_nondetM_ask:\n  notes mset_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask mmerge {#} (\\<lambda>x. {#x#}) (+)\"", "lemmas mset_nondetMs [locale_witness] =\n  nondetM_lemmas[OF mset_nondetM]\n  nondetM_ask_lemmas[OF mset_nondetM_ask]", "lemma mmerge_parametric:\n  includes lifting_syntax\n  assumes return [transfer_rule]: \"(rel_mset A ===> M) return1 return2\"\n    and bind [transfer_rule]: \"(M ===> (rel_mset A ===> M) ===> M) bind1 bind2\"\n    and comm1: \"monad_commute return1 bind1\"\n    and comm2: \"monad_commute return2 bind2\"\n  shows \"(rel_mset A ===> (A ===> M) ===> M) (mmerge return1 bind1) (mmerge return2 bind2)\"", "lemma funionM_comp_fun_commute: \"comp_fun_commute funionM\"", "lemma funionM_comp_fun_idem: \"comp_fun_idem funionM\"", "lemma fUnionM_empty [simp]: \"fUnionM {||} = return {||}\"", "lemma fUnionM_finset [simp]: \"fUnionM (finsert x M) = funionM x (fUnionM M)\" for x M", "lemma funionM_return_empty1 [simp]: \"funionM (return {||}) x = x\" for x", "lemma funionM_return_empty2 [simp]: \"funionM x (return {||}) = x\" for x", "lemma funionM_return_return [simp]: \"funionM (return A) (return B) = return (A |\\<union>| B)\" for A B", "lemma funionM_assoc: \"funionM (funionM x y) z = funionM x (funionM y z)\" for x y z", "lemma funionM_commute: \"funionM x y = funionM y x\" for x y", "lemma funionM_fUnionM1: \"funionM (fUnionM A) x = ffold funionM x A\" for A x", "lemma funionM_fUnionM2: \"funionM x (fUnionM A) = ffold funionM x A\" for x A", "lemma fUnionM_funion [simp]: \"fUnionM (A |\\<union>| B) = funionM (fUnionM A) (fUnionM B)\" for A B", "lemma fUnionM_return [simp]: \"fUnionM (fimage (\\<lambda>x. return {|x|}) A) = return A\" for A", "lemma bind_funionM: \"bind (funionM m m') f = funionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A |\\<union>| B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x |\\<union>| y)))\" for m m' f", "lemma fUnionM_return_fempty [simp]: \"fUnionM (fimage (\\<lambda>x. return {||}) A) = return {||}\" for A", "lemma funionM_bind: \"funionM (bind m f) (bind m g) = bind m (\\<lambda>x. funionM (f x) (g x))\" for m f g", "lemma fUnionM_funionM:\n \"fUnionM ((\\<lambda>y. funionM (f y) (g y)) |`| A) = funionM (fUnionM (f |`| A)) (fUnionM (g |`| A))\" for f g A", "lemma fset_nondetM: \"nondetM return bind fmerge {||} (\\<lambda>x. {|x|}) (|\\<union>|)\"", "lemma fset_nondetM_ask:\n  notes fset_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask fmerge {||} (\\<lambda>x. {|x|}) (|\\<union>|)\"", "lemmas fset_nondetMs [locale_witness] =\n  nondetM_lemmas[OF fset_nondetM]\n  nondetM_ask_lemmas[OF fset_nondetM_ask]", "lemma fmerge_bind:\n  \"fmerge A (\\<lambda>x. bind m' (\\<lambda>A'. fmerge A' (f x))) = bind m' (\\<lambda>A'. fmerge A (\\<lambda>x. fmerge A' (f x)))\"", "lemma fmerge_commute: \"fmerge A (\\<lambda>x. fmerge B (f x)) = fmerge B (\\<lambda>y. fmerge A (\\<lambda>x. f x y))\"", "lemma monad_commute_nondetT_fset [locale_witness]:\n  \"monad_commute return_nondet bind_nondet\"", "lemma fmerge_parametric:\n  includes lifting_syntax\n  assumes return [transfer_rule]: \"(rel_fset A ===> M) return1 return2\"\n    and bind [transfer_rule]: \"(M ===> (rel_fset A ===> M) ===> M) bind1 bind2\"\n    and comm1: \"monad_commute return1 bind1\" \"monad_duplicate return1 bind1\"\n    and comm2: \"monad_commute return2 bind2\" \"monad_duplicate return2 bind2\"\n  shows \"(rel_fset A ===> (A ===> M) ===> M) (fmerge return1 bind1) (fmerge return2 bind2)\"", "lemma run_altc_nondet [simp]: \"run_nondet (altc_nondet A f) = mergec A (run_nondet \\<circ> f)\"", "lemma extract_merge_id [simp]: \"extract (merge_id A f) = cUNION A (extract \\<circ> f)\"", "lemma merge_id_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_cset A ===> (A ===> rel_id (rel_cset A)) ===> rel_id (rel_cset A)) merge_id merge_id\"", "lemma cset_nondetM_id [locale_witness]: \"cset_nondetM return_id bind_id merge_id merge_id\"", "lemma run_merge_env [simp]: \"run_env (merge_env merge A f) r = merge A (\\<lambda>a. run_env (f a) r)\" for merge", "lemma merge_env_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((rel_cset C ===> (C ===> M) ===> M) ===> rel_cset C ===> (C ===> rel_envT R M) ===> rel_envT R M)\n   merge_env merge_env\"", "lemma cset_nondetM_envT [locale_witness]: \n  fixes return :: \"('a cset, 'm) return\" \n    and bind :: \"('a cset, 'm) bind\"\n    and merge :: \"('a, 'm, 'a cset) merge\"\n    and mergec :: \"('c, 'm, 'c cset) merge\"\n  assumes \"cset_nondetM return bind merge mergec\"\n  shows \"cset_nondetM (return_env return) (bind_env bind) (merge_env merge) (merge_env mergec)\"", "lemma rel_stateT_eq [relator_eq]: \"rel_stateT (=) (=) = (=)\"", "lemma rel_stateT_mono [relator_mono]: \"\\<lbrakk> S' \\<le> S; M \\<le> M' \\<rbrakk> \\<Longrightarrow> rel_stateT S M \\<le> rel_stateT S' M'\"", "lemma StateT_parametric [transfer_rule]: \"((S ===> M) ===> rel_stateT S M) StateT StateT\"", "lemma run_state_parametric [transfer_rule]: \"(rel_stateT S M ===> S ===> M) run_state run_state\"", "lemma case_stateT_parametric [transfer_rule]: \n  \"(((S ===> M) ===> A) ===> rel_stateT S M ===> A) case_stateT case_stateT\"", "lemma rec_stateT_parametric [transfer_rule]: \n  \"(((S ===> M) ===> A) ===> rel_stateT S M ===> A) rec_stateT rec_stateT\"", "lemma rel_stateT_Grp: \"rel_stateT (=) (BNF_Def.Grp UNIV f) = BNF_Def.Grp UNIV (map_stateT f)\"", "lemma run_put_state [simp]: \"run_state (put_state s m) s' = run_state m s\"", "lemma run_get_state [simp]: \"run_state (get_state f) s = run_state (f s) s\"", "lemma run_bind_state [simp]:\n  \"run_state (bind_state x f) s = bind (run_state x s) (\\<lambda>(a, s'). run_state (f a) s')\"", "lemma run_return_state [simp]:\n  \"run_state (return_state x) s = return (x, s)\"", "lemma monad_stateT [locale_witness]: \"monad return_state bind_state\" (is \"monad ?return ?bind\")", "lemma monad_state_stateT [locale_witness]:\n  \"monad_state return_state bind_state get_state put_state\"", "lemma run_fail_state [simp]: \"run_state fail_state s = fail\"", "lemma monad_fail_stateT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_state bind_state fail_state\" (is \"monad_fail ?return ?bind ?fail\")", "lemma run_ask_state [simp]:\n  \"run_state (ask_state f) s = ask (\\<lambda>r. run_state (f r) s)\"", "lemma monad_reader_stateT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_state bind_state ask_state\"", "lemma monad_reader_state_stateT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader_state return_state bind_state ask_state get_state put_state\"", "lemma run_altc_sample_state [simp]:\n  \"run_state (altc_sample_state altc_sample p f) s = altc_sample p (\\<lambda>x. run_state (f x) s)\"", "lemma monad_prob_stateT [locale_witness]: \"monad_prob return_state bind_state sample_state\"", "lemma monad_state_prob_stateT [locale_witness]:\n  \"monad_state_prob return_state bind_state get_state put_state sample_state\"", "lemma run_tell_state [simp]: \"run_state (tell_state w m) s = tell w (run_state m s)\"", "lemma monad_writer_stateT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_state bind_state tell_state\"", "lemma run_alt_state [simp]: \"run_state (alt_state m1 m2) s = alt (run_state m1 s) (run_state m2 s)\"", "lemma monad_alt_stateT [locale_witness]: \"monad_alt return_state bind_state alt_state\"", "lemma monad_state_alt_stateT [locale_witness]:\n  \"monad_state_alt return_state bind_state get_state put_state alt_state\"", "lemma monad_fail_alt_stateT [locale_witness]:\n  fixes fail\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_state bind_state (fail_state fail) alt_state\"", "lemma monad_altc_stateT [locale_witness]: \"monad_altc return_state bind_state altc_state\"", "lemma monad_state_altc_stateT [locale_witness]:\n  \"monad_state_altc return_state bind_state get_state put_state altc_state\"", "lemma monad_altc3_stateT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_state bind_state altc_state\"", "lemma run_pause_state [simp]:\n  \"run_state (pause_state out c) s = pause out (\\<lambda>i. run_state (c i) s)\"", "lemma monad_resumption_stateT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_state bind_state pause_state\"", "lemma return_state_parametric [transfer_rule]:\n  \"((rel_prod A S ===> M) ===> A ===> rel_stateT S M) return_state return_state\"", "lemma bind_state_parametric [transfer_rule]:\n  \"((M ===> (rel_prod A S ===> M) ===> M) ===> rel_stateT S M ===> (A ===> rel_stateT S M) ===> rel_stateT S M)\n   bind_state bind_state\"", "lemma get_state_parametric [transfer_rule]:\n  \"((S ===> rel_stateT S M) ===> rel_stateT S M) get_state get_state\"", "lemma put_state_parametric [transfer_rule]:\n  \"(S ===> rel_stateT S M ===> rel_stateT S M) put_state put_state\"", "lemma fail_state_parametric [transfer_rule]: \"(M ===> rel_stateT S M) fail_state fail_state\"", "lemma ask_state_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_stateT S M) ===> rel_stateT S M) ask_state ask_state\"", "lemma altc_sample_state_parametric [transfer_rule]:\n  \"((X ===> (P ===> M) ===> M) ===> X ===> (P ===> rel_stateT S M) ===> rel_stateT S M)\n   altc_sample_state altc_sample_state\"", "lemma tell_state_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_stateT S M ===> rel_stateT S M)\n   tell_state tell_state\"", "lemma alt_state_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_stateT S M ===> rel_stateT S M ===> rel_stateT S M)\n   alt_state alt_state\"", "lemma pause_state_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_stateT S M) ===> rel_stateT S M)\n   pause_state pause_state\"", "lemma run_return_writer [simp]: \"run_writer (return_writer x) = return (x, [])\"", "lemma run_bind_writer [simp]:\n  \"run_writer (bind_writer m f) = bind (run_writer m) (\\<lambda>(a, ws). bind (run_writer (f a)) (\\<lambda>(b, ws'). return (b, ws @ ws')))\"", "lemma run_tell_writer [simp]:\n  \"run_writer (tell_writer w m) = bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws))\"", "lemma monad_writerT [locale_witness]: \"monad return_writer bind_writer\"", "lemma monad_writer_writerT [locale_witness]: \"monad_writer return_writer bind_writer tell_writer\"", "lemma run_fail_writer [simp]: \"run_writer fail_writer = fail\"", "lemma monad_fail_writerT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_writer bind_writer fail_writer\"", "lemma run_get_writer [simp]: \"run_writer (get_writer f) = get (\\<lambda>s. run_writer (f s))\"", "lemma run_put_writer [simp]: \"run_writer (put_writer s m) = put s (run_writer m)\"", "lemma monad_state_writerT [locale_witness]:\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_writer bind_writer get_writer put_writer\"", "lemma run_altc_sample_writer [simp]:\n  \"run_writer (altc_sample_writer altc_sample p f) = altc_sample p (\\<lambda>p. run_writer (f p))\"", "lemma monad_prob_writerT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_writer bind_writer sample_writer\"", "lemma monad_state_prob_writerT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_writer bind_writer get_writer put_writer sample_writer\"", "lemma run_ask_writer [simp]: \"run_writer (ask_writer f) = ask (\\<lambda>r. run_writer (f r))\"", "lemma monad_reader_writerT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_writer bind_writer ask_writer\"", "lemma monad_reader_state_writerT [locale_witness]:\n  assumes \"monad_reader_state return bind ask get put\"\n  shows \"monad_reader_state return_writer bind_writer ask_writer get_writer put_writer\"", "lemma run_pause_writer [simp]:\n  \"run_writer (pause_writer out c) = pause out (\\<lambda>input. run_writer (c input))\"", "lemma monad_resumption_writerT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_writer bind_writer pause_writer\"", "lemma run_alt_writer [simp]: \"run_writer (alt_writer m m') = alt (run_writer m) (run_writer m')\"", "lemma monad_alt_writerT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_writer bind_writer alt_writer\"", "lemma monad_fail_alt_writerT [locale_witness]:\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_writer bind_writer fail_writer alt_writer\"", "lemma monad_state_alt_writerT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_writer bind_writer get_writer put_writer alt_writer\"", "lemma monad_altc_writerT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_writer bind_writer altc_writer\"", "lemma monad_altc3_writerT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_writer bind_writer altc_writer\"", "lemma monad_state_altc_writerT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_writer bind_writer get_writer put_writer altc_writer\"", "lemma return_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> A ===> rel_writerT W A M) return_writer return_writer\"", "lemma bind_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> (M ===> (rel_prod A (list_all2 W) ===> M) ===> M)\n   ===> rel_writerT W A M ===> (A ===> rel_writerT W A M) ===> rel_writerT W A M)\n   bind_writer bind_writer\"", "lemma tell_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> (M ===> (rel_prod A (list_all2 W) ===> M) ===> M)\n   ===> W ===> rel_writerT W A M ===> rel_writerT W A M)\n   tell_writer tell_writer\"", "lemma ask_writer_parametric [transfer_rule]: \n  \"(((R ===> M) ===> M) ===> (R ===> rel_writerT W A M) ===> rel_writerT W A M) ask_writer ask_writer\"", "lemma fail_writer_parametric [transfer_rule]:\n  \"(M ===> rel_writerT W A M) fail_writer fail_writer\"", "lemma get_writer_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_writerT W A M) ===> rel_writerT W A M) get_writer get_writer\"", "lemma put_writer_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_writerT W A M ===> rel_writerT W A M) put_writer put_writer\"", "lemma altc_sample_writer_parametric [transfer_rule]:\n  \"((X ===> (P ===> M) ===> M) ===> X ===> (P ===> rel_writerT W A M) ===> rel_writerT W A M)\n  altc_sample_writer altc_sample_writer\"", "lemma alt_writer_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_writerT W A M ===> rel_writerT W A M ===> rel_writerT W A M)\n   alt_writer alt_writer\"", "lemma pause_writer_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_writerT W A M) ===> rel_writerT W A M)\n   pause_writer pause_writer\"", "lemma run_callcc_cont [simp]: \"run_cont (callcc_cont f) k = run_cont (f (\\<lambda>x. ContT (\\<lambda>_. k x))) k\"", "lemma run_return_cont [simp]: \"run_cont (return_cont x) k = k x\"", "lemma run_bind_cont [simp]: \"run_cont (bind_cont m f) k = run_cont m (\\<lambda>x. run_cont (f x) k)\"", "lemma monad_contT [locale_witness]: \"monad return_cont bind_cont\" (is \"monad ?return ?bind\")", "lemma run_fail_cont [simp]: \"run_cont fail_cont k = fail\"", "lemma monad_fail_contT [locale_witness]: \"monad_fail return_cont bind_cont fail_cont\"", "lemma run_get_cont [simp]: \"run_cont (get_cont f) k = get (\\<lambda>s. run_cont (f s) k)\"", "lemma run_put_cont [simp]: \"run_cont (put_cont s m) k = put s (run_cont m k)\"", "lemma monad_state_contT [locale_witness]:\n  assumes \"monad_state return' bind' get put\" \\<comment> \\<open>We don't need the plain monad operations for lifting.\\<close>\n  shows \"monad_state return_cont bind_cont get_cont (put_cont :: ('s, ('a, 'm) contT) put)\"\n  (is \"monad_state ?return ?bind ?get ?put\")", "lemma hom_lift [simp]: \"h (m1.lift f m) = m2.lift f (h m)\"", "lemma monad_id_prob_hom [locale_witness]:\n  \"monad_hom return_id bind_id return_pmf bind_pmf prob_of_id\"", "lemma cr_id_prob_return [cr_id_prob_transfer]: \"(A ===> cr_id_prob A) return_id return_pmf\"", "lemma cr_id_prob_bind [cr_id_prob_transfer]: \n  \"(cr_id_prob A ===> (A ===> cr_id_prob B) ===> cr_id_prob B) bind_id bind_pmf\"", "lemma cr_id_prob_Grp: \"cr_id_prob (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_id x \\<subseteq> A} (return_pmf \\<circ> f \\<circ> extract)\"", "lemma cr_prod1_simps [simp]: \"cr_prod1 c' A a (b, c) \\<longleftrightarrow> A a b \\<and> c' = c\"", "lemma cr_prod1I: \"A a b \\<Longrightarrow> cr_prod1 c' A a (b, c')\"", "lemma cr_prod1_Pair_transfer [cr_envT_stateT_transfer]: \"(A ===> eq_onp ((=) c) ===> cr_prod1 c A) (\\<lambda>a _. a) Pair\"", "lemma cr_prod1_fst_transfer [cr_envT_stateT_transfer]: \"(cr_prod1 c A ===> A) (\\<lambda>a. a) fst\"", "lemma cr_prod1_case_prod_transfer [cr_envT_stateT_transfer]:\n  \"((A ===> eq_onp ((=) c) ===> C) ===> cr_prod1 c A ===> C) (\\<lambda>f a. f a c) case_prod\"", "lemma cr_prod1_Grp: \"cr_prod1 c (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (f b, c))\"", "lemma cr_envT_stateT_simps [simp]:\n  \"cr_envT_stateT s M (EnvT f) (StateT g) \\<longleftrightarrow> M (f s) (g s)\"", "lemma cr_envT_stateTE:\n  assumes \"cr_envT_stateT s M m1 m2\"\n  obtains f g where \"m1 = EnvT f\" \"m2 = StateT g\" \"(eq_onp ((=) s) ===> M) f g\"", "lemma cr_envT_stateTD: \"cr_envT_stateT s M m1 m2 \\<Longrightarrow> M (run_env m1 s) (run_state m2 s)\"", "lemma cr_envT_stateT_run [cr_envT_stateT_transfer]:\n  \"(cr_envT_stateT s M ===> eq_onp ((=) s) ===> M) run_env run_state\"", "lemma cr_envT_stateT_StateT_EnvT [cr_envT_stateT_transfer]:\n  \"((eq_onp ((=) s) ===> M) ===> cr_envT_stateT s M) EnvT StateT\"", "lemma cr_envT_stateT_rec [cr_envT_stateT_transfer]:\n  \"(((eq_onp ((=) s) ===> M) ===> C) ===> cr_envT_stateT s M ===> C) rec_envT rec_stateT\"", "lemma cr_envT_stateT_return [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_envT_stateT_transfer shows\n  \"((cr_prod1 s A ===> M) ===> A ===> cr_envT_stateT s M) return_env return_state\"", "lemma cr_envT_stateT_bind [cr_envT_stateT_transfer]:\n  \"((M ===> (cr_prod1 s A ===> M) ===> M) ===> cr_envT_stateT s M ===> (A ===> cr_envT_stateT s M) ===> cr_envT_stateT s M)\n   bind_env bind_state\"", "lemma cr_envT_stateT_ask_get [cr_envT_stateT_transfer]:\n  \"((eq_onp ((=) s) ===> cr_envT_stateT s M) ===> cr_envT_stateT s M) ask_env get_state\"", "lemma cr_envT_stateT_fail [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_envT_stateT_transfer shows\n  \"(M ===> cr_envT_stateT s M) fail_env fail_state\"", "lemma cr_spmf_prob_optionTI: \"rel_spmf A (run_option p) q \\<Longrightarrow> cr_spmf_prob_optionT A p q\"", "lemma cr_spmf_prob_optionTD: \"cr_spmf_prob_optionT A p q \\<Longrightarrow> rel_spmf A (run_option p) q\"", "lemma cr_spmf_prob_optionT_return_transfer:\n   \\<comment> \\<open>Cannot be used as a transfer rule in @{method transfer_prover} because @{term return_spmf} is not a constant.\\<close>\n  \"(A ===> cr_spmf_prob_optionT A) (return_option return_pmf) return_spmf\"", "lemma cr_spmf_prob_optionT_bind_transfer:\n  \"(cr_spmf_prob_optionT A ===> (A ===> cr_spmf_prob_optionT A) ===> cr_spmf_prob_optionT A)\n   (bind_option return_pmf bind_pmf) bind_spmf\"", "lemma cr_spmf_prob_optionT_fail_transfer:\n  \"cr_spmf_prob_optionT A (fail_option return_pmf) (return_pmf None)\"", "lemma spmf_of_prob_optionT_transfer: \"(cr_spmf_prob_optionT A ===> rel_spmf A) spmf_of_prob_optionT (\\<lambda>x. x)\"", "lemma prob_optionT_of_spmf_transfer: \"(rel_spmf A ===> cr_spmf_prob_optionT A) prob_optionT_of_spmf (\\<lambda>x. x)\"", "lemma cr_pmf_cset_Grp: \"cr_pmf_cset = BNF_Def.Grp UNIV cset_pmf\"", "lemma cr_pmf_cset_return_pmf [cr_prob_ndi_transfer]:\n  \"((=) ===> cr_pmf_cset) return_pmf csingle\"", "lemma cr_prob_ndi_Grp: \"cr_prob_ndi (BNF_Def.Grp UNIV f) = BNF_Def.Grp UNIV (NondetT \\<circ> return_id \\<circ> cimage f \\<circ> cset_pmf)\"", "lemma cr_ndi_prob_return [cr_prob_ndi_transfer]:\n  \"(A ===> cr_prob_ndi A) return_pmf return_nondet\"", "lemma cr_ndi_prob_bind [cr_prob_ndi_transfer]:\n  \"(cr_prob_ndi A ===> (A ===> cr_prob_ndi A) ===> cr_prob_ndi A) bind_pmf bind_nondet\"", "lemma cr_ndi_prob_sample [cr_prob_ndi_transfer]:\n  \"(cr_pmf_cset ===> ((=) ===> cr_prob_ndi A) ===> cr_prob_ndi A) bind_pmf altc_nondet\""], "translations": [["", "lemma (in comp_fun_idem) fold_set_union:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> Finite_Set.fold f x (A \\<union> B) = Finite_Set.fold f (Finite_Set.fold f x A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> Finite_Set.fold f x (A \\<union> B) =\n                      Finite_Set.fold f (Finite_Set.fold f x A) B", "by(induction A arbitrary: x rule: finite_induct)(simp_all add: fold_insert_idem2 del: fold_insert_idem)"], ["", "lemma (in comp_fun_idem) ffold_set_union: \"ffold f x (A |\\<union>| B) = ffold f (ffold f x A) B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ffold f x (A |\\<union>| B) = ffold f (ffold f x A) B", "including fset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. ffold f x (A |\\<union>| B) = ffold f (ffold f x A) B", "by(transfer fixing: f)(rule fold_set_union)"], ["", "lemma relcompp_top_top [simp]: \"top OO top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<top> OO \\<top> = \\<top>", "by(auto simp add: fun_eq_iff)"], ["", "attribute_setup locale_witness = \\<open>Scan.succeed Locale.witness_add\\<close>"], ["", "named_theorems monad_unfold \"Defining equations for overloaded monad operations\""], ["", "context includes lifting_syntax begin"], ["", "inductive rel_itself :: \"'a itself \\<Rightarrow> 'b itself \\<Rightarrow> bool\"\nwhere \"rel_itself TYPE(_) TYPE(_)\""], ["", "lemma type_parametric [transfer_rule]: \"rel_itself TYPE('a) TYPE('b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_itself TYPE('a) TYPE('b)", "by(simp add: rel_itself.simps)"], ["", "lemma plus_multiset_parametric [transfer_rule]:\n  \"(rel_mset A ===> rel_mset A ===> rel_mset A) (+) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset A ===> rel_mset A ===> rel_mset A) (+) (+)", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y; rel_mset A xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_mset A (x + xa) (y + ya)", "subgoal premises prems"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset A (x_ + xa_) (y_ + ya_)", "using prems"], ["proof (prove)\nusing this:\n  rel_mset A x_ y_\n  rel_mset A xa_ ya_\n\ngoal (1 subgoal):\n 1. rel_mset A (x_ + xa_) (y_ + ya_)", "by induction(auto intro: rel_mset_Plus)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Mempty_parametric [transfer_rule]: \"rel_mset A {#} {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_mset A {#} {#}", "by(fact rel_mset_Zero)"], ["", "lemma fold_mset_parametric:\n  assumes 12: \"(A ===> B ===> B) f1 f2\"\n  and \"comp_fun_commute f1\" \"comp_fun_commute f2\"\n  shows \"(B ===> rel_mset A ===> B) (fold_mset f1) (fold_mset f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> rel_mset A ===> B) (fold_mset f1) (fold_mset f2)", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_mset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (fold_mset f1 x xa) (fold_mset f2 y ya)", "interpret f1: comp_fun_commute f1"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute f1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_mset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (fold_mset f1 x xa) (fold_mset f2 y ya)", "interpret f2: comp_fun_commute f2"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute f2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_mset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (fold_mset f1 x xa) (fold_mset f2 y ya)", "show \"B (fold_mset f1 z1 X) (fold_mset f2 z2 Y)\" \n    if \"rel_mset A X Y\" \"B z1 z2\" for z1 z2 X Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (fold_mset f1 z1 X) (fold_mset f2 z2 Y)", "using that(1)"], ["proof (prove)\nusing this:\n  rel_mset A X Y\n\ngoal (1 subgoal):\n 1. B (fold_mset f1 z1 X) (fold_mset f2 z2 Y)", "by(induction R\\<equiv>A X Y)(simp_all add: that(2) 12[THEN rel_funD, THEN rel_funD])"], ["proof (state)\nthis:\n  \\<lbrakk>rel_mset A ?X ?Y; B ?z1.0 ?z2.0\\<rbrakk>\n  \\<Longrightarrow> B (fold_mset f1 ?z1.0 ?X) (fold_mset f2 ?z2.0 ?Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel_fset_induct [consumes 1, case_names empty step, induct pred: rel_fset]:\n  assumes XY: \"rel_fset A X Y\"\n    and empty: \"P {||} {||}\"\n    and step: \"\\<And>X Y x y. \\<lbrakk> rel_fset A X Y; P X Y; A x y; x |\\<notin>| X \\<or> y |\\<notin>| Y \\<rbrakk> \\<Longrightarrow> P (finsert x X) (finsert y Y)\"\n  shows \"P X Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P X Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P X Y", "from XY"], ["proof (chain)\npicking this:\n  rel_fset A X Y", "obtain Z where X: \"X = fst |`| Z\" and Y: \"Y = snd |`| Z\" and Z: \"fBall Z (\\<lambda>(x, y). A x y)\""], ["proof (prove)\nusing this:\n  rel_fset A X Y\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>X = fst |`| Z; Y = snd |`| Z;\n         fBall Z (\\<lambda>(x, y). A x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding fset.in_rel"], ["proof (prove)\nusing this:\n  \\<exists>z.\n     z \\<in> {x. fset x \\<subseteq> {(x, y). A x y}} \\<and>\n     fst |`| z = X \\<and> snd |`| z = Y\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<lbrakk>X = fst |`| Z; Y = snd |`| Z;\n         fBall Z (\\<lambda>(x, y). A x y)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: fBall.rep_eq)"], ["proof (state)\nthis:\n  X = fst |`| Z\n  Y = snd |`| Z\n  fBall Z (\\<lambda>(x, y). A x y)\n\ngoal (1 subgoal):\n 1. P X Y", "from Z"], ["proof (chain)\npicking this:\n  fBall Z (\\<lambda>(x, y). A x y)", "show ?thesis"], ["proof (prove)\nusing this:\n  fBall Z (\\<lambda>(x, y). A x y)\n\ngoal (1 subgoal):\n 1. P X Y", "unfolding X Y"], ["proof (prove)\nusing this:\n  fBall Z (\\<lambda>(x, y). A x y)\n\ngoal (1 subgoal):\n 1. P (fst |`| Z) (snd |`| Z)", "proof(induction Z)"], ["proof (state)\ngoal (2 subgoals):\n 1. fBall {||} (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n    P (fst |`| {||}) (snd |`| {||})\n 2. \\<And>x Z.\n       \\<lbrakk>x |\\<notin>| Z;\n        fBall Z (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n        P (fst |`| Z) (snd |`| Z);\n        fBall (finsert x Z) (\\<lambda>(x, y). A x y)\\<rbrakk>\n       \\<Longrightarrow> P (fst |`| finsert x Z) (snd |`| finsert x Z)", "case (insert xy Z)"], ["proof (state)\nthis:\n  xy |\\<notin>| Z\n  fBall Z\n   (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b) \\<Longrightarrow>\n  P (fst |`| Z) (snd |`| Z)\n  fBall (finsert xy Z) (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b)\n\ngoal (2 subgoals):\n 1. fBall {||} (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n    P (fst |`| {||}) (snd |`| {||})\n 2. \\<And>x Z.\n       \\<lbrakk>x |\\<notin>| Z;\n        fBall Z (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n        P (fst |`| Z) (snd |`| Z);\n        fBall (finsert x Z) (\\<lambda>(x, y). A x y)\\<rbrakk>\n       \\<Longrightarrow> P (fst |`| finsert x Z) (snd |`| finsert x Z)", "obtain x y where [simp]: \"xy = (x, y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y. xy = (x, y) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases xy)"], ["proof (state)\nthis:\n  xy = (x, y)\n\ngoal (2 subgoals):\n 1. fBall {||} (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n    P (fst |`| {||}) (snd |`| {||})\n 2. \\<And>x Z.\n       \\<lbrakk>x |\\<notin>| Z;\n        fBall Z (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n        P (fst |`| Z) (snd |`| Z);\n        fBall (finsert x Z) (\\<lambda>(x, y). A x y)\\<rbrakk>\n       \\<Longrightarrow> P (fst |`| finsert x Z) (snd |`| finsert x Z)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (fst |`| finsert xy Z) (snd |`| finsert xy Z)", "using insert"], ["proof (prove)\nusing this:\n  xy |\\<notin>| Z\n  fBall Z\n   (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b) \\<Longrightarrow>\n  P (fst |`| Z) (snd |`| Z)\n  fBall (finsert xy Z) (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b)\n\ngoal (1 subgoal):\n 1. P (fst |`| finsert xy Z) (snd |`| finsert xy Z)", "apply(cases \"x |\\<in>| fst |`| Z \\<and> y |\\<in>| snd |`| Z\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>xy |\\<notin>| Z;\n     fBall Z\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b) \\<Longrightarrow>\n     P (fst |`| Z) (snd |`| Z);\n     fBall (finsert xy Z)\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b);\n     x |\\<in>| fst |`| Z \\<and> y |\\<in>| snd |`| Z\\<rbrakk>\n    \\<Longrightarrow> P (fst |`| finsert xy Z) (snd |`| finsert xy Z)\n 2. \\<lbrakk>xy |\\<notin>| Z;\n     fBall Z\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b) \\<Longrightarrow>\n     P (fst |`| Z) (snd |`| Z);\n     fBall (finsert xy Z)\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b);\n     \\<not> (x |\\<in>| fst |`| Z \\<and> y |\\<in>| snd |`| Z)\\<rbrakk>\n    \\<Longrightarrow> P (fst |`| finsert xy Z) (snd |`| finsert xy Z)", "apply(simp add: finsert_absorb)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xy |\\<notin>| Z;\n     fBall Z\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b) \\<Longrightarrow>\n     P (fst |`| Z) (snd |`| Z);\n     fBall (finsert xy Z)\n      (\\<lambda>a. case a of (a, b) \\<Rightarrow> A a b);\n     \\<not> (x |\\<in>| fst |`| Z \\<and> y |\\<in>| snd |`| Z)\\<rbrakk>\n    \\<Longrightarrow> P (fst |`| finsert xy Z) (snd |`| finsert xy Z)", "apply(auto intro!: step simp add: fset.in_rel fBall.rep_eq; blast)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  P (fst |`| finsert xy Z) (snd |`| finsert xy Z)\n\ngoal (1 subgoal):\n 1. fBall {||} (\\<lambda>(x, y). A x y) \\<Longrightarrow>\n    P (fst |`| {||}) (snd |`| {||})", "qed(simp add: assms)"], ["proof (state)\nthis:\n  P X Y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ffold_parametric:\n  assumes 12: \"(A ===> B ===> B) f1 f2\"\n  and \"comp_fun_idem f1\" \"comp_fun_idem f2\"\n  shows \"(B ===> rel_fset A ===> B) (ffold f1) (ffold f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B ===> rel_fset A ===> B) (ffold f1) (ffold f2)", "proof(rule rel_funI)+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_fset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (ffold f1 x xa) (ffold f2 y ya)", "interpret f1: comp_fun_idem f1"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem f1", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_fset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (ffold f1 x xa) (ffold f2 y ya)", "interpret f2: comp_fun_idem f2"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem f2", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>B x y; rel_fset A xa ya\\<rbrakk>\n       \\<Longrightarrow> B (ffold f1 x xa) (ffold f2 y ya)", "show \"B (ffold f1 z1 X) (ffold f2 z2 Y)\" \n    if \"rel_fset A X Y\" \"B z1 z2\" for z1 z2 X Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. B (ffold f1 z1 X) (ffold f2 z2 Y)", "using that(1)"], ["proof (prove)\nusing this:\n  rel_fset A X Y\n\ngoal (1 subgoal):\n 1. B (ffold f1 z1 X) (ffold f2 z2 Y)", "by(induction)(simp_all add: that(2) 12[THEN rel_funD, THEN rel_funD])"], ["proof (state)\nthis:\n  \\<lbrakk>rel_fset A ?X ?Y; B ?z1.0 ?z2.0\\<rbrakk>\n  \\<Longrightarrow> B (ffold f1 ?z1.0 ?X) (ffold f2 ?z2.0 ?Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma rel_set_Grp: \"rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {X. X \\<subseteq> A} (image f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_set (BNF_Def.Grp A f) = BNF_Def.Grp {X. X \\<subseteq> A} ((`) f)", "by(auto simp add: fun_eq_iff Grp_def rel_set_def)"], ["", "context includes cset.lifting begin"], ["", "lemma cUNION_assoc: \"cUNION (cUNION A f) g = cUNION A (\\<lambda>x. cUNION (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage g (cUnion (cimage f A))) =\n    cUnion (cimage (\\<lambda>x. cUnion (cimage g (f x))) A)", "by transfer auto"], ["", "lemma cUnion_cempty [simp]: \"cUnion cempty = cempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion cempty = cempty", "by transfer simp"], ["", "lemma cUNION_cempty [simp]: \"cUNION cempty f = cempty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage f cempty) = cempty", "by simp"], ["", "lemma cUnion_cinsert: \"cUnion (cinsert x A) = cUn x (cUnion A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cinsert x A) = cUn x (cUnion A)", "by transfer simp"], ["", "lemma cUNION_cinsert: \"cUNION (cinsert x A) f = cUn (f x) (cUNION A f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage f (cinsert x A)) = cUn (f x) (cUnion (cimage f A))", "by (simp add: cUnion_cinsert)"], ["", "lemma cUnion_csingle [simp]: \"cUnion (csingle x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (csingle x) = x", "by (simp add: cUnion_cinsert)"], ["", "lemma cUNION_csingle [simp]: \"cUNION (csingle x) f = f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage f (csingle x)) = f x", "by simp"], ["", "lemma cUNION_csingle2 [simp]: \"cUNION A csingle = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage csingle A) = A", "by (fact cUN_csingleton)"], ["", "lemma cUNION_cUn: \"cUNION (cUn A B) f = cUn (cUNION A f) (cUNION B f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion (cimage f (cUn A B)) =\n    cUn (cUnion (cimage f A)) (cUnion (cimage f B))", "by simp"], ["", "lemma cUNION_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_cset A ===> (A ===> rel_cset B) ===> rel_cset B) cUNION cUNION\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset A ===> (A ===> rel_cset B) ===> rel_cset B)\n     (\\<lambda>A f. cUnion (cimage f A)) (\\<lambda>A f. cUnion (cimage f A))", "unfolding rel_fun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x y.\n       rel_cset A x y \\<longrightarrow>\n       (\\<forall>xa ya.\n           (\\<forall>x y.\n               A x y \\<longrightarrow>\n               rel_cset B (xa x) (ya y)) \\<longrightarrow>\n           rel_cset B (cUnion (cimage xa x)) (cUnion (cimage ya y)))", "by transfer(blast intro: rel_set_UNION)"], ["", "end"], ["", "locale three =\n  fixes tytok :: \"'a itself\"\n  assumes ex_three: \"\\<exists>x y z :: 'a. x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z\"\nbegin"], ["", "definition threes :: \"'a \\<times> 'a \\<times> 'a\" where\n  \"threes = (SOME (x, y, z). x \\<noteq> y \\<and> x \\<noteq> z \\<and> y \\<noteq> z)\""], ["", "definition three\\<^sub>1 :: 'a (\"\\<^bold>1\") where \"\\<^bold>1 = fst threes\""], ["", "definition three\\<^sub>2 :: 'a (\"\\<^bold>2\") where \"\\<^bold>2 = fst (snd threes)\""], ["", "definition three\\<^sub>3 :: 'a (\"\\<^bold>3\") where \"\\<^bold>3 = snd (snd (threes))\""], ["", "lemma three_neq_aux: \"\\<^bold>1 \\<noteq> \\<^bold>2\" \"\\<^bold>1 \\<noteq> \\<^bold>3\" \"\\<^bold>2 \\<noteq> \\<^bold>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>1 \\<noteq> \\<^bold>2 &&&\n    \\<^bold>1 \\<noteq> \\<^bold>3 &&& \\<^bold>2 \\<noteq> \\<^bold>3", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<^bold>1 \\<noteq> \\<^bold>2\n 2. \\<^bold>1 \\<noteq> \\<^bold>3\n 3. \\<^bold>2 \\<noteq> \\<^bold>3", "have \"\\<^bold>1 \\<noteq> \\<^bold>2 \\<and> \\<^bold>1 \\<noteq> \\<^bold>3 \\<and> \\<^bold>2 \\<noteq> \\<^bold>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>1 \\<noteq> \\<^bold>2 \\<and>\n    \\<^bold>1 \\<noteq> \\<^bold>3 \\<and> \\<^bold>2 \\<noteq> \\<^bold>3", "unfolding three\\<^sub>1_def three\\<^sub>2_def three\\<^sub>3_def threes_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (SOME p.\n            fst p \\<noteq> fst (snd p) \\<and>\n            fst p \\<noteq> snd (snd p) \\<and>\n            fst (snd p) \\<noteq> snd (snd p)) \\<noteq>\n    fst (snd (SOME p.\n                 fst p \\<noteq> fst (snd p) \\<and>\n                 fst p \\<noteq> snd (snd p) \\<and>\n                 fst (snd p) \\<noteq> snd (snd p))) \\<and>\n    fst (SOME p.\n            fst p \\<noteq> fst (snd p) \\<and>\n            fst p \\<noteq> snd (snd p) \\<and>\n            fst (snd p) \\<noteq> snd (snd p)) \\<noteq>\n    snd (snd (SOME p.\n                 fst p \\<noteq> fst (snd p) \\<and>\n                 fst p \\<noteq> snd (snd p) \\<and>\n                 fst (snd p) \\<noteq> snd (snd p))) \\<and>\n    fst (snd (SOME p.\n                 fst p \\<noteq> fst (snd p) \\<and>\n                 fst p \\<noteq> snd (snd p) \\<and>\n                 fst (snd p) \\<noteq> snd (snd p))) \\<noteq>\n    snd (snd (SOME p.\n                 fst p \\<noteq> fst (snd p) \\<and>\n                 fst p \\<noteq> snd (snd p) \\<and>\n                 fst (snd p) \\<noteq> snd (snd p)))", "by(rule someI_ex)(use ex_three in auto)"], ["proof (state)\nthis:\n  \\<^bold>1 \\<noteq> \\<^bold>2 \\<and>\n  \\<^bold>1 \\<noteq> \\<^bold>3 \\<and> \\<^bold>2 \\<noteq> \\<^bold>3\n\ngoal (3 subgoals):\n 1. \\<^bold>1 \\<noteq> \\<^bold>2\n 2. \\<^bold>1 \\<noteq> \\<^bold>3\n 3. \\<^bold>2 \\<noteq> \\<^bold>3", "then"], ["proof (chain)\npicking this:\n  \\<^bold>1 \\<noteq> \\<^bold>2 \\<and>\n  \\<^bold>1 \\<noteq> \\<^bold>3 \\<and> \\<^bold>2 \\<noteq> \\<^bold>3", "show \"\\<^bold>1 \\<noteq> \\<^bold>2\" \"\\<^bold>1 \\<noteq> \\<^bold>3\" \"\\<^bold>2 \\<noteq> \\<^bold>3\""], ["proof (prove)\nusing this:\n  \\<^bold>1 \\<noteq> \\<^bold>2 \\<and>\n  \\<^bold>1 \\<noteq> \\<^bold>3 \\<and> \\<^bold>2 \\<noteq> \\<^bold>3\n\ngoal (1 subgoal):\n 1. \\<^bold>1 \\<noteq> \\<^bold>2 &&&\n    \\<^bold>1 \\<noteq> \\<^bold>3 &&& \\<^bold>2 \\<noteq> \\<^bold>3", "by simp_all"], ["proof (state)\nthis:\n  \\<^bold>1 \\<noteq> \\<^bold>2\n  \\<^bold>1 \\<noteq> \\<^bold>3\n  \\<^bold>2 \\<noteq> \\<^bold>3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas three_neq [simp] = three_neq_aux three_neq_aux[symmetric]"], ["", "inductive rel_12_23 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"rel_12_23 \\<^bold>1 \\<^bold>2\"\n| \"rel_12_23 \\<^bold>2 \\<^bold>3\""], ["", "lemma bi_unique_rel_12_23 [simp, transfer_rule]: \"bi_unique rel_12_23\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique rel_12_23", "by(auto simp add: bi_unique_def rel_12_23.simps)"], ["", "inductive rel_12_21 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> bool\" where\n  \"rel_12_21 \\<^bold>1 \\<^bold>2\"\n| \"rel_12_21 \\<^bold>2 \\<^bold>1\""], ["", "lemma bi_unique_rel_12_21 [simp, transfer_rule]: \"bi_unique rel_12_21\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique rel_12_21", "by(auto simp add: bi_unique_def rel_12_21.simps)"], ["", "end"], ["", "lemma bernoulli_pmf_0: \"bernoulli_pmf 0 = return_pmf False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 0 = return_pmf False", "by(rule pmf_eqI)(simp split: split_indicator)"], ["", "lemma bernoulli_pmf_1: \"bernoulli_pmf 1 = return_pmf True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bernoulli_pmf 1 = return_pmf True", "by(rule pmf_eqI)(simp split: split_indicator)"], ["", "lemma bernoulli_Not: \"map_pmf Not (bernoulli_pmf r) = bernoulli_pmf (1 - r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf Not (bernoulli_pmf r) = bernoulli_pmf (1 - r)", "apply(rule pmf_eqI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf Not (bernoulli_pmf r)) i = pmf (bernoulli_pmf (1 - r)) i", "apply(rewrite in \"pmf _ \\<hole> = _\" not_not[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       pmf (map_pmf Not (bernoulli_pmf r)) (\\<not> \\<not> i) =\n       pmf (bernoulli_pmf (1 - r)) i", "apply(subst pmf_map_inj')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. inj Not\n 2. \\<And>i.\n       pmf (bernoulli_pmf r) (\\<not> i) = pmf (bernoulli_pmf (1 - r)) i", "apply(simp_all add: inj_on_def bernoulli_pmf.rep_eq min_def max_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pmf_eqI_avoid: \"p = q\" if \"\\<And>i. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q", "proof(rule pmf_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. pmf p i = pmf q i", "show \"pmf p i = pmf q i\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf p i = pmf q i", "proof(cases \"i = x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "case [simp]: True"], ["proof (state)\nthis:\n  i = x\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "have \"pmf p i = measure_pmf.prob p {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf p i = measure_pmf.prob p {i}", "by(simp add: measure_pmf_single)"], ["proof (state)\nthis:\n  pmf p i = measure_pmf.prob p {i}\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "also"], ["proof (state)\nthis:\n  pmf p i = measure_pmf.prob p {i}\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "have \"\\<dots> = 1 - measure_pmf.prob p (UNIV - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p {i} = 1 - measure_pmf.prob p (UNIV - {i})", "by(subst measure_pmf.prob_compl[unfolded space_measure_pmf]) simp_all"], ["proof (state)\nthis:\n  measure_pmf.prob p {i} = 1 - measure_pmf.prob p (UNIV - {i})\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "also"], ["proof (state)\nthis:\n  measure_pmf.prob p {i} = 1 - measure_pmf.prob p (UNIV - {i})\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "have \"measure_pmf.prob p (UNIV - {i}) = measure_pmf.prob q (UNIV - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob p (UNIV - {i}) = measure_pmf.prob q (UNIV - {i})", "unfolding integral_pmf[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. integral\\<^sup>L (count_space (UNIV - {i})) (pmf p) =\n    integral\\<^sup>L (count_space (UNIV - {i})) (pmf q)", "by(rule Bochner_Integration.integral_cong)(auto intro: that)"], ["proof (state)\nthis:\n  measure_pmf.prob p (UNIV - {i}) = measure_pmf.prob q (UNIV - {i})\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "also"], ["proof (state)\nthis:\n  measure_pmf.prob p (UNIV - {i}) = measure_pmf.prob q (UNIV - {i})\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "have \"1 - \\<dots> = measure_pmf.prob q {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - measure_pmf.prob q (UNIV - {i}) = measure_pmf.prob q {i}", "by(subst measure_pmf.prob_compl[unfolded space_measure_pmf]) simp_all"], ["proof (state)\nthis:\n  1 - measure_pmf.prob q (UNIV - {i}) = measure_pmf.prob q {i}\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "also"], ["proof (state)\nthis:\n  1 - measure_pmf.prob q (UNIV - {i}) = measure_pmf.prob q {i}\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "have \"\\<dots> = pmf q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.prob q {i} = pmf q i", "by(simp add: measure_pmf_single)"], ["proof (state)\nthis:\n  measure_pmf.prob q {i} = pmf q i\n\ngoal (2 subgoals):\n 1. i = x \\<Longrightarrow> pmf p i = pmf q i\n 2. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "finally"], ["proof (chain)\npicking this:\n  pmf p i = pmf q i", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf p i = pmf q i\n\ngoal (1 subgoal):\n 1. pmf p i = pmf q i", "."], ["proof (state)\nthis:\n  pmf p i = pmf q i\n\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "case False"], ["proof (state)\nthis:\n  i \\<noteq> x\n\ngoal (1 subgoal):\n 1. i \\<noteq> x \\<Longrightarrow> pmf p i = pmf q i", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> x", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> x\n\ngoal (1 subgoal):\n 1. pmf p i = pmf q i", "by(rule that)"], ["proof (state)\nthis:\n  pmf p i = pmf q i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf p ?i = pmf q ?i\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>Locales for monomorphic monads\\<close>"], ["", "subsection \\<open>Plain monad\\<close>"], ["", "type_synonym ('a, 'm) bind = \"'m \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "type_synonym ('a, 'm) return = \"'a \\<Rightarrow> 'm\""], ["", "locale monad_base =\n  fixes return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\nbegin"], ["", "primrec sequence :: \"'m list \\<Rightarrow> ('a list \\<Rightarrow> 'm) \\<Rightarrow> 'm\"\nwhere\n  \"sequence [] f = f []\"\n| \"sequence (x # xs) f = bind x (\\<lambda>a. sequence xs (f \\<circ> (#) a))\""], ["", "definition lift :: \"('a \\<Rightarrow> 'a) \\<Rightarrow> 'm \\<Rightarrow> 'm\"\nwhere \"lift f x = bind x (\\<lambda>x. return (f x))\""], ["", "end"], ["", "declare\n  monad_base.sequence.simps [code]\n  monad_base.lift_def [code]"], ["", "context includes lifting_syntax begin"], ["", "lemma sequence_parametric [transfer_rule]:\n  \"((M ===> (A ===> M) ===> M) ===> list_all2 M ===> (list_all2 A ===> M) ===> M) monad_base.sequence monad_base.sequence\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (A ===> M) ===> M) ===>\n     list_all2 M ===> (list_all2 A ===> M) ===> M)\n     monad_base.sequence monad_base.sequence", "unfolding monad_base.sequence_def[abs_def]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (A ===> M) ===> M) ===>\n     list_all2 M ===> (list_all2 A ===> M) ===> M)\n     (\\<lambda>bind.\n         rec_list (\\<lambda>f. f [])\n          (\\<lambda>x xs xsa f. bind x (\\<lambda>a. xsa (f \\<circ> (#) a))))\n     (\\<lambda>bind.\n         rec_list (\\<lambda>f. f [])\n          (\\<lambda>x xs xsa f. bind x (\\<lambda>a. xsa (f \\<circ> (#) a))))", "by transfer_prover"], ["", "lemma lift_parametric [transfer_rule]:\n  \"((A ===> M) ===> (M ===> (A ===> M) ===> M) ===> (A ===> A) ===> M ===> M) monad_base.lift monad_base.lift\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===>\n     (M ===> (A ===> M) ===> M) ===> (A ===> A) ===> M ===> M)\n     monad_base.lift monad_base.lift", "unfolding monad_base.lift_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===>\n     (M ===> (A ===> M) ===> M) ===> (A ===> A) ===> M ===> M)\n     (\\<lambda>return bind f x. bind x (\\<lambda>x. return (f x)))\n     (\\<lambda>return bind f x. bind x (\\<lambda>x. return (f x)))", "by transfer_prover"], ["", "end"], ["", "locale monad = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  assumes bind_assoc: \"\\<And>(x :: 'm) f g. bind (bind x f) g = bind x (\\<lambda>y. bind (f y) g)\" \n  and return_bind: \"\\<And>x f. bind (return x) f = f x\"\n  and bind_return: \"\\<And>x. bind x return = x\"\nbegin"], ["", "lemma bind_lift [simp]: \"bind (lift f x) g = bind x (g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (lift f x) g = bind x (g \\<circ> f)", "by(simp add: lift_def bind_assoc return_bind o_def)"], ["", "lemma lift_bind [simp]: \"lift f (bind m g) = bind m (\\<lambda>x. lift f (g x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift f (bind m g) = bind m (\\<lambda>x. lift f (g x))", "by(simp add: lift_def bind_assoc)"], ["", "end"], ["", "subsection \\<open>State\\<close>"], ["", "type_synonym ('s, 'm) get = \"('s \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "type_synonym ('s, 'm) put = \"'s \\<Rightarrow> 'm \\<Rightarrow> 'm\""], ["", "locale monad_state_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\nbegin"], ["", "definition update :: \"('s \\<Rightarrow> 's) \\<Rightarrow> 'm \\<Rightarrow> 'm\"\nwhere \"update f m = get (\\<lambda>s. put (f s) m)\""], ["", "end"], ["", "declare monad_state_base.update_def [code]"], ["", "lemma update_parametric [transfer_rule]: includes lifting_syntax shows  \n  \"(((S ===> M) ===> M) ===> (S ===> M ===> M) ===> (S ===> S) ===> M ===> M)\n   monad_state_base.update monad_state_base.update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> M ===> M) ===> (S ===> S) ===> M ===> M)\n     monad_state_base.update monad_state_base.update", "unfolding monad_state_base.update_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> M ===> M) ===> (S ===> S) ===> M ===> M)\n     (\\<lambda>get put f m. get (\\<lambda>s. put (f s) m))\n     (\\<lambda>get put f m. get (\\<lambda>s. put (f s) m))", "by transfer_prover"], ["", "locale monad_state = monad_state_base return bind get put + monad return bind \n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  +\n  assumes put_get: \"\\<And>f. put s (get f) = put s (f s)\"\n  and get_get: \"\\<And>f. get (\\<lambda>s. get (f s)) = get (\\<lambda>s. f s s)\"\n  and put_put: \"put s (put s' m) = put s' m\"\n  and get_put: \"get (\\<lambda>s. put s m) = m\"\n  and get_const: \"\\<And>m. get (\\<lambda>_. m) = m\"\n  and bind_get: \"\\<And>f g. bind (get f) g = get (\\<lambda>s. bind (f s) g)\"\n  and bind_put: \"\\<And>f. bind (put s m) f = put s (bind m f)\"\nbegin"], ["", "lemma put_update: \"put s (update f m) = put (f s) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. put s (update f m) = put (f s) m", "by(simp add: update_def put_get put_put)"], ["", "lemma update_put: \"update f (put s m) = put s m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update f (put s m) = put s m", "by(simp add: update_def put_put get_const)"], ["", "lemma bind_update: \"bind (update f m) g = update f (bind m g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (update f m) g = update f (bind m g)", "by(simp add: update_def bind_get bind_put)"], ["", "lemma update_get: \"update f (get g) = get (update f \\<circ> g \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update f (get g) = get (update f \\<circ> g \\<circ> f)", "by(simp add: update_def put_get get_get o_def)"], ["", "lemma update_const: \"update (\\<lambda>_. s) m = put s m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update (\\<lambda>_. s) m = put s m", "by(simp add: update_def get_const)"], ["", "lemma update_update: \"update f (update g m) = update (g \\<circ> f) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update f (update g m) = update (g \\<circ> f) m", "by(simp add: update_def put_get put_put)"], ["", "lemma update_id: \"update id m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update id m = m", "by(simp add: update_def get_put)"], ["", "end"], ["", "subsection \\<open>Failure\\<close>"], ["", "type_synonym 'm fail = \"'m\""], ["", "locale monad_fail_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes fail :: \"'m fail\"\nbegin"], ["", "definition assert :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'm \\<Rightarrow> 'm\"\nwhere \"assert P m = bind m (\\<lambda>x. if P x then return x else fail)\""], ["", "end"], ["", "declare monad_fail_base.assert_def [code]"], ["", "lemma assert_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((A ===> M) ===> (M ===> (A ===> M) ===> M) ===> M ===> (A ===> (=)) ===> M ===> M)\n   monad_fail_base.assert monad_fail_base.assert\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===>\n     (M ===> (A ===> M) ===> M) ===> M ===> (A ===> (=)) ===> M ===> M)\n     monad_fail_base.assert monad_fail_base.assert", "unfolding monad_fail_base.assert_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===>\n     (M ===> (A ===> M) ===> M) ===> M ===> (A ===> (=)) ===> M ===> M)\n     (\\<lambda>return bind fail P m.\n         bind m (\\<lambda>x. if P x then return x else fail))\n     (\\<lambda>return bind fail P m.\n         bind m (\\<lambda>x. if P x then return x else fail))", "by transfer_prover"], ["", "locale monad_fail = monad_fail_base return bind fail + monad return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and fail :: \"'m fail\"\n  +\n  assumes fail_bind: \"\\<And>f. bind fail f = fail\"\nbegin"], ["", "lemma assert_fail: \"assert P fail = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert P fail = fail", "by(simp add: assert_def fail_bind)"], ["", "end"], ["", "subsection \\<open>Exception\\<close>"], ["", "type_synonym 'm catch = \"'m \\<Rightarrow> 'm \\<Rightarrow> 'm\""], ["", "locale monad_catch_base = monad_fail_base return bind fail\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and fail :: \"'m fail\"\n  +\n  fixes catch :: \"'m catch\""], ["", "locale monad_catch = monad_catch_base return bind fail catch + monad_fail return bind fail\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and fail :: \"'m fail\"\n  and catch :: \"'m catch\"\n  +\n  assumes catch_return: \"catch (return x) m = return x\"\n  and catch_fail: \"catch fail m = m\"\n  and catch_fail2: \"catch m fail = m\"\n  and catch_assoc: \"catch (catch m m') m'' = catch m (catch m' m'')\""], ["", "locale monad_catch_state = monad_catch return bind fail catch + monad_state return bind get put\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and fail :: \"'m fail\"\n  and catch :: \"'m catch\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  +\n  assumes catch_get: \"catch (get f) m = get (\\<lambda>s. catch (f s) m)\"\n  and catch_put: \"catch (put s m) m' = put s (catch m m')\"\nbegin"], ["", "lemma catch_update: \"catch (update f m) m' = update f (catch m m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. catch (update f m) m' = update f (catch m m')", "by(simp add: update_def catch_get catch_put)"], ["", "end"], ["", "subsection \\<open>Reader\\<close>"], ["", "text \\<open>As ask takes a continuation, we have to restate the monad laws for ask\\<close>"], ["", "type_synonym ('r, 'm) ask = \"('r \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "locale monad_reader_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes ask :: \"('r, 'm) ask\""], ["", "locale monad_reader = monad_reader_base return bind ask + monad return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and ask :: \"('r, 'm) ask\"\n  +\n  assumes ask_ask: \"\\<And>f. ask (\\<lambda>r. ask (f r)) = ask (\\<lambda>r. f r r)\"\n  and ask_const: \"ask (\\<lambda>_. m) = m\"\n  and bind_ask: \"\\<And>f g. bind (ask f) g = ask (\\<lambda>r. bind (f r) g)\"\n  and bind_ask2: \"\\<And>f. bind m (\\<lambda>x. ask (f x)) = ask (\\<lambda>r. bind m (\\<lambda>x. f x r))\"\nbegin"], ["", "lemma ask_bind: \"ask (\\<lambda>r. bind (f r) (g r)) = bind (ask f) (\\<lambda>x. ask (\\<lambda>r. g r x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ask (\\<lambda>r. bind (f r) (g r)) =\n    bind (ask f) (\\<lambda>x. ask (\\<lambda>r. g r x))", "by(simp add: bind_ask bind_ask2 ask_ask)"], ["", "end"], ["", "locale monad_reader_state =\n  monad_reader return bind ask +\n  monad_state return bind get put\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and ask :: \"('r, 'm) ask\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  +\n  assumes ask_get: \"\\<And>f. ask (\\<lambda>r. get (f r)) = get (\\<lambda>s. ask (\\<lambda>r. f r s))\"\n  and put_ask: \"\\<And>f. put s (ask f) = ask (\\<lambda>r. put s (f r))\""], ["", "subsection \\<open>Probability\\<close>"], ["", "type_synonym ('p, 'm) sample = \"'p pmf \\<Rightarrow> ('p \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "locale monad_prob_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes sample :: \"('p, 'm) sample\""], ["", "locale monad_prob = monad return bind + monad_prob_base return bind sample\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and sample :: \"('p, 'm) sample\"\n  +\n  assumes sample_const: \"\\<And>p m. sample p (\\<lambda>_. m) = m\"\n  and sample_return_pmf: \"\\<And>x f. sample (return_pmf x) f = f x\"\n  and sample_bind_pmf: \"\\<And>p f g. sample (bind_pmf p f) g = sample p (\\<lambda>x. sample (f x) g)\"\n  and sample_commute: \"\\<And>p q f. sample p (\\<lambda>x. sample q (f x)) = sample q (\\<lambda>y. sample p (\\<lambda>x. f x y))\"\n  \\<comment> \\<open>We'd like to state that we can combine independent samples rather than just commute them, but that's not possible with a monomorphic sampling operation\\<close>\n  and bind_sample1: \"\\<And>p f g. bind (sample p f) g = sample p (\\<lambda>x. bind (f x) g)\"\n  and bind_sample2: \"\\<And>m f p. bind m (\\<lambda>y. sample p (f y)) = sample p (\\<lambda>x. bind m (\\<lambda>y. f y x))\"\n  and sample_parametric: \"\\<And>R. bi_unique R \\<Longrightarrow> rel_fun (rel_pmf R) (rel_fun (rel_fun R (=)) (=)) sample sample\"\nbegin"], ["", "lemma sample_cong: \"(\\<And>x. x \\<in> set_pmf p \\<Longrightarrow> f x = g x) \\<Longrightarrow> sample p f = sample q g\" if \"p = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> set_pmf p \\<Longrightarrow> f x = g x) \\<Longrightarrow>\n    sample p f = sample q g", "by(rule sample_parametric[where R=\"eq_onp (\\<lambda>x. x \\<in> set_pmf p)\", THEN rel_funD, THEN rel_funD])\n    (simp_all add: bi_unique_def eq_onp_def rel_fun_def pmf.rel_refl_strong that)"], ["", "end"], ["", "text \\<open>We can implement binary probabilistic choice using @{term sample} provided that the sample space\n  contains at least three elements.\\<close>"], ["", "locale monad_prob3 = monad_prob return bind sample + three \"TYPE('p)\"\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and sample :: \"('p, 'm) sample\"\nbegin"], ["", "definition pchoose :: \"real \\<Rightarrow> 'm \\<Rightarrow> 'm \\<Rightarrow> 'm\" where\n  \"pchoose r m m' = sample (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf r)) (\\<lambda>x. if x = \\<^bold>1 then m else m')\""], ["", "abbreviation pchoose_syntax :: \"'m \\<Rightarrow> real \\<Rightarrow> 'm \\<Rightarrow> 'm\" (\"_ \\<lhd> _ \\<rhd> _\" [100, 0, 100] 99) where\n  \"m \\<lhd> r \\<rhd> m' \\<equiv> pchoose r m m'\""], ["", "lemma pchoose_0: \"m \\<lhd> 0 \\<rhd> m' = m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> 0 \\<rhd> m' = m'", "by(simp add: pchoose_def bernoulli_pmf_0 sample_return_pmf)"], ["", "lemma pchoose_1: \"m \\<lhd> 1 \\<rhd> m' = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> 1 \\<rhd> m' = m", "by(simp add: pchoose_def bernoulli_pmf_1 sample_return_pmf)"], ["", "lemma pchoose_idemp: \"m \\<lhd> r \\<rhd> m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> r \\<rhd> m = m", "by(simp add: pchoose_def sample_const)"], ["", "lemma pchoose_bind1: \"bind (m \\<lhd> r \\<rhd> m') f = bind m f \\<lhd> r \\<rhd> bind m' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (m \\<lhd> r \\<rhd> m') f = bind m f \\<lhd> r \\<rhd> bind m' f", "by(simp add: pchoose_def bind_sample1 if_distrib[where f=\"\\<lambda>m. bind m _\"])"], ["", "lemma pchoose_bind2: \"bind m (\\<lambda>x. f x \\<lhd> p \\<rhd> g x) = bind m f \\<lhd> p \\<rhd> bind m g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m (\\<lambda>x. f x \\<lhd> p \\<rhd> g x) =\n    bind m f \\<lhd> p \\<rhd> bind m g", "by(auto simp add: pchoose_def bind_sample2 intro!: arg_cong2[where f=sample])"], ["", "lemma pchoose_commute: \"m \\<lhd> 1 - r \\<rhd> m' = m' \\<lhd> r \\<rhd> m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> 1 - r \\<rhd> m' = m' \\<lhd> r \\<rhd> m", "apply(simp add: pchoose_def bernoulli_Not[symmetric] pmf.map_comp o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample\n     (map_pmf (\\<lambda>x. if \\<not> x then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n     (\\<lambda>x. if x = \\<^bold>1 then m else m') =\n    sample\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n     (\\<lambda>x. if x = \\<^bold>1 then m' else m)", "apply(rule sample_parametric[where R=rel_12_21, THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bi_unique rel_12_21\n 2. rel_pmf rel_12_21\n     (map_pmf (\\<lambda>x. if \\<not> x then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n 3. rel_fun rel_12_21 (=) (\\<lambda>x. if x = \\<^bold>1 then m else m')\n     (\\<lambda>x. if x = \\<^bold>1 then m' else m)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique rel_12_21", "by(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_pmf rel_12_21\n     (map_pmf (\\<lambda>x. if \\<not> x then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n 2. rel_fun rel_12_21 (=) (\\<lambda>x. if x = \\<^bold>1 then m else m')\n     (\\<lambda>x. if x = \\<^bold>1 then m' else m)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_pmf rel_12_21\n     (map_pmf (\\<lambda>x. if \\<not> x then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf r))", "by(rule pmf.map_transfer[where Rb=\"(=)\", THEN rel_funD, THEN rel_funD])\n            (simp_all add: rel_fun_def rel_12_21.simps pmf.rel_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun rel_12_21 (=) (\\<lambda>x. if x = \\<^bold>1 then m else m')\n     (\\<lambda>x. if x = \\<^bold>1 then m' else m)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun rel_12_21 (=) (\\<lambda>x. if x = \\<^bold>1 then m else m')\n     (\\<lambda>x. if x = \\<^bold>1 then m' else m)", "by(simp add: rel_fun_def rel_12_21.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pchoose_assoc: \"m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') = (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\" (is \"?lhs = ?rhs\")\n  if \"min 1 (max 0 p) = min 1 (max 0 r) * min 1 (max 0 s)\"\n  and \"1 - min 1 (max 0 s) = (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "let ?f = \"(\\<lambda>x. if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'')\""], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "let ?p = \"bind_pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf p))\n     (\\<lambda>x. if x = \\<^bold>1 then return_pmf \\<^bold>1 else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3) (bernoulli_pmf q))\""], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "let ?q = \"bind_pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf s))\n     (\\<lambda>x. if x = \\<^bold>1 then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf r) else return_pmf \\<^bold>3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "have [simp]: \"{x. \\<not> x} = {False}\" \"{x. x} = {True}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<not> x} = {False} &&& {x. x} = {True}", "by auto"], ["proof (state)\nthis:\n  {x. \\<not> x} = {False}\n  {x. x} = {True}\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "have \"?lhs = sample ?p ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    sample\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf p) \\<bind>\n      (\\<lambda>x.\n          if x = \\<^bold>1 then return_pmf \\<^bold>1\n          else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                (bernoulli_pmf q)))\n     (\\<lambda>x.\n         if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'')", "by(auto simp add: pchoose_def sample_bind_pmf if_distrib[where f=\"\\<lambda>x. sample x _\"] sample_return_pmf rel_fun_def rel_12_23.simps pmf.rel_eq cong: if_cong intro!: sample_cong[OF refl] sample_parametric[where R=\"rel_12_23\", THEN rel_funD, THEN rel_funD] pmf.map_transfer[where Rb=\"(=)\", THEN rel_funD, THEN rel_funD])"], ["proof (state)\nthis:\n  m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n  sample\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p) \\<bind>\n    (\\<lambda>x.\n        if x = \\<^bold>1 then return_pmf \\<^bold>1\n        else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n              (bernoulli_pmf q)))\n   (\\<lambda>x.\n       if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'')\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "also"], ["proof (state)\nthis:\n  m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n  sample\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p) \\<bind>\n    (\\<lambda>x.\n        if x = \\<^bold>1 then return_pmf \\<^bold>1\n        else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n              (bernoulli_pmf q)))\n   (\\<lambda>x.\n       if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'')\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "have \"?p = ?q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p) \\<bind>\n    (\\<lambda>x.\n        if x = \\<^bold>1 then return_pmf \\<^bold>1\n        else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n              (bernoulli_pmf q)) =\n    map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf s) \\<bind>\n    (\\<lambda>x.\n        if x = \\<^bold>1\n        then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n              (bernoulli_pmf r)\n        else return_pmf \\<^bold>3)", "proof(rule pmf_eqI_avoid)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<noteq> ?x \\<Longrightarrow>\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf p) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1 then return_pmf \\<^bold>1\n                else map_pmf\n                      (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                      (bernoulli_pmf q)))\n        i =\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf s) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1\n                then map_pmf\n                      (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                      (bernoulli_pmf r)\n                else return_pmf \\<^bold>3))\n        i", "fix i :: \"'p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<noteq> ?x \\<Longrightarrow>\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf p) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1 then return_pmf \\<^bold>1\n                else map_pmf\n                      (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                      (bernoulli_pmf q)))\n        i =\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf s) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1\n                then map_pmf\n                      (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                      (bernoulli_pmf r)\n                else return_pmf \\<^bold>3))\n        i", "assume \"i \\<noteq> \\<^bold>2\""], ["proof (state)\nthis:\n  i \\<noteq> \\<^bold>2\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<noteq> ?x \\<Longrightarrow>\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf p) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1 then return_pmf \\<^bold>1\n                else map_pmf\n                      (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                      (bernoulli_pmf q)))\n        i =\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf s) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1\n                then map_pmf\n                      (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                      (bernoulli_pmf r)\n                else return_pmf \\<^bold>3))\n        i", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> \\<^bold>2", "consider (one) \"i = \\<^bold>1\" | (three) \"i = \\<^bold>3\" | (other) \"i \\<noteq> \\<^bold>1\" \"i \\<noteq> \\<^bold>2\" \"i \\<noteq> \\<^bold>3\""], ["proof (prove)\nusing this:\n  i \\<noteq> \\<^bold>2\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i = \\<^bold>1 \\<Longrightarrow> thesis;\n     i = \\<^bold>3 \\<Longrightarrow> thesis;\n     \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n      i \\<noteq> \\<^bold>3\\<rbrakk>\n     \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by metis"], ["proof (state)\nthis:\n  \\<lbrakk>i = \\<^bold>1 \\<Longrightarrow> ?thesis;\n   i = \\<^bold>3 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n    i \\<noteq> \\<^bold>3\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<noteq> ?x \\<Longrightarrow>\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf p) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1 then return_pmf \\<^bold>1\n                else map_pmf\n                      (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                      (bernoulli_pmf q)))\n        i =\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf s) \\<bind>\n            (\\<lambda>x.\n                if x = \\<^bold>1\n                then map_pmf\n                      (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                      (bernoulli_pmf r)\n                else return_pmf \\<^bold>3))\n        i", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>i = \\<^bold>1 \\<Longrightarrow> ?thesis;\n   i = \\<^bold>3 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n    i \\<noteq> \\<^bold>3\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis", "show \"pmf ?p i = pmf ?q i\""], ["proof (prove)\nusing this:\n  \\<lbrakk>i = \\<^bold>1 \\<Longrightarrow> ?thesis;\n   i = \\<^bold>3 \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n    i \\<noteq> \\<^bold>3\\<rbrakk>\n   \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "case [simp]: one"], ["proof (state)\nthis:\n  i = \\<^bold>1\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"pmf ?p i = measure_pmf.expectation (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf p)) (indicator {\\<^bold>1})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf p))\n     (indicat_real {\\<^bold>1})", "unfolding pmf_bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf p))\n     (\\<lambda>x.\n         pmf (if x = \\<^bold>1 then return_pmf \\<^bold>1\n              else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                    (bernoulli_pmf q))\n          i) =\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf p))\n     (indicat_real {\\<^bold>1})", "by(rule arg_cong2[where f=measure_pmf.expectation, OF refl])(auto simp add: fun_eq_iff pmf_eq_0_set_pmf)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p))\n   (indicat_real {\\<^bold>1})\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p))\n   (indicat_real {\\<^bold>1})\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = min 1 (max 0 p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf p))\n     (indicat_real {\\<^bold>1}) =\n    min 1 (max 0 p)", "by(simp add: vimage_def)(simp add: measure_pmf_single bernoulli_pmf.rep_eq)"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p))\n   (indicat_real {\\<^bold>1}) =\n  min 1 (max 0 p)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf p))\n   (indicat_real {\\<^bold>1}) =\n  min 1 (max 0 p)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = min 1 (max 0 s) * min 1 (max 0 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min 1 (max 0 p) = min 1 (max 0 s) * min 1 (max 0 r)", "using that(1)"], ["proof (prove)\nusing this:\n  min 1 (max 0 p) = min 1 (max 0 r) * min 1 (max 0 s)\n\ngoal (1 subgoal):\n 1. min 1 (max 0 p) = min 1 (max 0 s) * min 1 (max 0 r)", "by simp"], ["proof (state)\nthis:\n  min 1 (max 0 p) = min 1 (max 0 s) * min 1 (max 0 r)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  min 1 (max 0 p) = min 1 (max 0 s) * min 1 (max 0 r)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = measure_pmf.expectation (bernoulli_pmf s)\n            (\\<lambda>x. indicator {True} x * pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf r)) \\<^bold>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min 1 (max 0 s) * min 1 (max 0 r) =\n    measure_pmf.expectation (bernoulli_pmf s)\n     (\\<lambda>x.\n         indicat_real {True} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n               (bernoulli_pmf r))\n          \\<^bold>1)", "by(simp add: pmf_map vimage_def measure_pmf_single)(simp add:  bernoulli_pmf.rep_eq)"], ["proof (state)\nthis:\n  min 1 (max 0 s) * min 1 (max 0 r) =\n  measure_pmf.expectation (bernoulli_pmf s)\n   (\\<lambda>x.\n       indicat_real {True} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf r))\n        \\<^bold>1)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  min 1 (max 0 s) * min 1 (max 0 r) =\n  measure_pmf.expectation (bernoulli_pmf s)\n   (\\<lambda>x.\n       indicat_real {True} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf r))\n        \\<^bold>1)\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = pmf ?q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf s)\n     (\\<lambda>x.\n         indicat_real {True} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n               (bernoulli_pmf r))\n          \\<^bold>1) =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "unfolding pmf_bind integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf s)\n     (\\<lambda>x.\n         indicat_real {True} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n               (bernoulli_pmf r))\n          \\<^bold>1) =\n    measure_pmf.expectation (bernoulli_pmf s)\n     (\\<lambda>x.\n         pmf (if (if x then \\<^bold>1 else \\<^bold>2) = \\<^bold>1\n              then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                    (bernoulli_pmf r)\n              else return_pmf \\<^bold>3)\n          i)", "by(rule arg_cong2[where f=measure_pmf.expectation, OF refl])(auto simp add: fun_eq_iff pmf_eq_0_set_pmf)"], ["proof (state)\nthis:\n  measure_pmf.expectation (bernoulli_pmf s)\n   (\\<lambda>x.\n       indicat_real {True} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n             (bernoulli_pmf r))\n        \\<^bold>1) =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (3 subgoals):\n 1. i = \\<^bold>1 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 3. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "."], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "case [simp]: three"], ["proof (state)\nthis:\n  i = \\<^bold>3\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"pmf ?p i = measure_pmf.expectation (bernoulli_pmf p)\n            (\\<lambda>x. indicator {False} x * pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3) (bernoulli_pmf q)) \\<^bold>3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    measure_pmf.expectation (bernoulli_pmf p)\n     (\\<lambda>x.\n         indicat_real {False} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n               (bernoulli_pmf q))\n          \\<^bold>3)", "unfolding pmf_bind integral_map_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf p)\n     (\\<lambda>x.\n         pmf (if (if x then \\<^bold>1 else \\<^bold>2) = \\<^bold>1\n              then return_pmf \\<^bold>1\n              else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                    (bernoulli_pmf q))\n          i) =\n    measure_pmf.expectation (bernoulli_pmf p)\n     (\\<lambda>x.\n         indicat_real {False} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n               (bernoulli_pmf q))\n          \\<^bold>3)", "by(rule arg_cong2[where f=measure_pmf.expectation, OF refl])(auto simp add: fun_eq_iff pmf_eq_0_set_pmf)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  measure_pmf.expectation (bernoulli_pmf p)\n   (\\<lambda>x.\n       indicat_real {False} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n             (bernoulli_pmf q))\n        \\<^bold>3)\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  measure_pmf.expectation (bernoulli_pmf p)\n   (\\<lambda>x.\n       indicat_real {False} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n             (bernoulli_pmf q))\n        \\<^bold>3)\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation (bernoulli_pmf p)\n     (\\<lambda>x.\n         indicat_real {False} x *\n         pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n               (bernoulli_pmf q))\n          \\<^bold>3) =\n    (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))", "by(simp add: pmf_map vimage_def measure_pmf_single)(simp add:  bernoulli_pmf.rep_eq)"], ["proof (state)\nthis:\n  measure_pmf.expectation (bernoulli_pmf p)\n   (\\<lambda>x.\n       indicat_real {False} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n             (bernoulli_pmf q))\n        \\<^bold>3) =\n  (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  measure_pmf.expectation (bernoulli_pmf p)\n   (\\<lambda>x.\n       indicat_real {False} x *\n       pmf (map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n             (bernoulli_pmf q))\n        \\<^bold>3) =\n  (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = 1 - min 1 (max 0 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q)) = 1 - min 1 (max 0 s)", "using that(2)"], ["proof (prove)\nusing this:\n  1 - min 1 (max 0 s) = (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q))\n\ngoal (1 subgoal):\n 1. (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q)) = 1 - min 1 (max 0 s)", "by simp"], ["proof (state)\nthis:\n  (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q)) = 1 - min 1 (max 0 s)\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  (1 - min 1 (max 0 p)) * (1 - min 1 (max 0 q)) = 1 - min 1 (max 0 s)\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = measure_pmf.expectation (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2) (bernoulli_pmf s)) (indicator {\\<^bold>2})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 - min 1 (max 0 s) =\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf s))\n     (indicat_real {\\<^bold>2})", "by(simp add: vimage_def)(simp add: measure_pmf_single bernoulli_pmf.rep_eq)"], ["proof (state)\nthis:\n  1 - min 1 (max 0 s) =\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf s))\n   (indicat_real {\\<^bold>2})\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "also"], ["proof (state)\nthis:\n  1 - min 1 (max 0 s) =\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf s))\n   (indicat_real {\\<^bold>2})\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "have \"\\<dots> = pmf ?q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf s))\n     (indicat_real {\\<^bold>2}) =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "unfolding pmf_bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf s))\n     (indicat_real {\\<^bold>2}) =\n    measure_pmf.expectation\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf s))\n     (\\<lambda>x.\n         pmf (if x = \\<^bold>1\n              then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                    (bernoulli_pmf r)\n              else return_pmf \\<^bold>3)\n          i)", "by(rule Bochner_Integration.integral_cong_AE)(auto simp add: fun_eq_iff pmf_eq_0_set_pmf AE_measure_pmf_iff)"], ["proof (state)\nthis:\n  measure_pmf.expectation\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf s))\n   (indicat_real {\\<^bold>2}) =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (2 subgoals):\n 1. i = \\<^bold>3 \\<Longrightarrow>\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i\n 2. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "finally"], ["proof (chain)\npicking this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "."], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "case other"], ["proof (state)\nthis:\n  i \\<noteq> \\<^bold>1\n  i \\<noteq> \\<^bold>2\n  i \\<noteq> \\<^bold>3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "then"], ["proof (chain)\npicking this:\n  i \\<noteq> \\<^bold>1\n  i \\<noteq> \\<^bold>2\n  i \\<noteq> \\<^bold>3", "have \"pmf ?p i = 0\" \"pmf ?q i = 0\""], ["proof (prove)\nusing this:\n  i \\<noteq> \\<^bold>1\n  i \\<noteq> \\<^bold>2\n  i \\<noteq> \\<^bold>3\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    0 &&&\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i =\n    0", "by(auto simp add: pmf_eq_0_set_pmf)"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  0\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i =\n  0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> \\<^bold>1; i \\<noteq> \\<^bold>2;\n     i \\<noteq> \\<^bold>3\\<rbrakk>\n    \\<Longrightarrow> pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf p) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1 then return_pmf \\<^bold>1\n                               else map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>2 else \\<^bold>3)\n                                     (bernoulli_pmf q)))\n                       i =\n                      pmf (map_pmf\n                            (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                            (bernoulli_pmf s) \\<bind>\n                           (\\<lambda>x.\n                               if x = \\<^bold>1\n                               then map_pmf\n                                     (\\<lambda>b.\n   if b then \\<^bold>1 else \\<^bold>2)\n                                     (bernoulli_pmf r)\n                               else return_pmf \\<^bold>3))\n                       i", "then"], ["proof (chain)\npicking this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  0\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i =\n  0", "show ?thesis"], ["proof (prove)\nusing this:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  0\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i =\n  0\n\ngoal (1 subgoal):\n 1. pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf p) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1 then return_pmf \\<^bold>1\n             else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                   (bernoulli_pmf q)))\n     i =\n    pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n          (bernoulli_pmf s) \\<bind>\n         (\\<lambda>x.\n             if x = \\<^bold>1\n             then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                   (bernoulli_pmf r)\n             else return_pmf \\<^bold>3))\n     i", "by simp"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf p) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1 then return_pmf \\<^bold>1\n           else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n                 (bernoulli_pmf q)))\n   i =\n  pmf (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n        (bernoulli_pmf s) \\<bind>\n       (\\<lambda>x.\n           if x = \\<^bold>1\n           then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                 (bernoulli_pmf r)\n           else return_pmf \\<^bold>3))\n   i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n   (bernoulli_pmf p) \\<bind>\n  (\\<lambda>x.\n      if x = \\<^bold>1 then return_pmf \\<^bold>1\n      else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n            (bernoulli_pmf q)) =\n  map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n   (bernoulli_pmf s) \\<bind>\n  (\\<lambda>x.\n      if x = \\<^bold>1\n      then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n            (bernoulli_pmf r)\n      else return_pmf \\<^bold>3)\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "also"], ["proof (state)\nthis:\n  map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n   (bernoulli_pmf p) \\<bind>\n  (\\<lambda>x.\n      if x = \\<^bold>1 then return_pmf \\<^bold>1\n      else map_pmf (\\<lambda>b. if b then \\<^bold>2 else \\<^bold>3)\n            (bernoulli_pmf q)) =\n  map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n   (bernoulli_pmf s) \\<bind>\n  (\\<lambda>x.\n      if x = \\<^bold>1\n      then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n            (bernoulli_pmf r)\n      else return_pmf \\<^bold>3)\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "have \"sample ?q ?f = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample\n     (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n       (bernoulli_pmf s) \\<bind>\n      (\\<lambda>x.\n          if x = \\<^bold>1\n          then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n                (bernoulli_pmf r)\n          else return_pmf \\<^bold>3))\n     (\\<lambda>x.\n         if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "by(auto simp add: pchoose_def sample_bind_pmf if_distrib[where f=\"\\<lambda>x. sample x _\"] sample_return_pmf cong: if_cong intro!: sample_cong[OF refl])"], ["proof (state)\nthis:\n  sample\n   (map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n     (bernoulli_pmf s) \\<bind>\n    (\\<lambda>x.\n        if x = \\<^bold>1\n        then map_pmf (\\<lambda>b. if b then \\<^bold>1 else \\<^bold>2)\n              (bernoulli_pmf r)\n        else return_pmf \\<^bold>3))\n   (\\<lambda>x.\n       if x = \\<^bold>1 then m else if x = \\<^bold>2 then m' else m'') =\n  (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "finally"], ["proof (chain)\npicking this:\n  m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n  (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "show ?thesis"], ["proof (prove)\nusing this:\n  m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n  (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\n\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "."], ["proof (state)\nthis:\n  m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n  (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pchoose_assoc': \"m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') = (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''\"\n  if \"p = r * s\" and \"1 - s = (1 - p) * (1 - q)\"\n  and \"0 \\<le> p\" \"p \\<le> 1\" \"0 \\<le> q\" \"q \\<le> 1\" \"0 \\<le> r\" \"r \\<le> 1\" \"0 \\<le> s\" \"s \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<lhd> p \\<rhd> (m' \\<lhd> q \\<rhd> m'') =\n    (m \\<lhd> r \\<rhd> m') \\<lhd> s \\<rhd> m''", "by(rule pchoose_assoc; use that in \\<open>simp add: min_def max_def\\<close>)"], ["", "end"], ["", "locale monad_state_prob = monad_state return bind get put + monad_prob return bind sample\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  and sample :: \"('p, 'm) sample\"\n  +\n  assumes sample_get: \"sample p (\\<lambda>x. get (f x)) = get (\\<lambda>s. sample p (\\<lambda>x. f x s))\"\nbegin"], ["", "lemma sample_put: \"sample p (\\<lambda>x. put s (m x)) = put s (sample p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "fix UU"], ["proof (state)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "have \"sample p (\\<lambda>x. put s (m x)) = sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) =\n    sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x))", "by(simp add: bind_put return_bind)"], ["proof (state)\nthis:\n  sample p (\\<lambda>x. put s (m x)) =\n  sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x))\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "also"], ["proof (state)\nthis:\n  sample p (\\<lambda>x. put s (m x)) =\n  sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x))\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "have \"\\<dots> = bind (put s (return UU)) (\\<lambda>_. sample p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x)) =\n    bind (put s (return UU)) (\\<lambda>_. sample p m)", "by(simp add: bind_sample2)"], ["proof (state)\nthis:\n  sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x)) =\n  bind (put s (return UU)) (\\<lambda>_. sample p m)\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "also"], ["proof (state)\nthis:\n  sample p (\\<lambda>x. bind (put s (return UU)) (\\<lambda>_. m x)) =\n  bind (put s (return UU)) (\\<lambda>_. sample p m)\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "have \"\\<dots> = put s (sample p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (put s (return UU)) (\\<lambda>_. sample p m) = put s (sample p m)", "by(simp add: bind_put return_bind)"], ["proof (state)\nthis:\n  bind (put s (return UU)) (\\<lambda>_. sample p m) = put s (sample p m)\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "finally"], ["proof (chain)\npicking this:\n  sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "show ?thesis"], ["proof (prove)\nusing this:\n  sample p (\\<lambda>x. put s (m x)) = put s (sample p m)\n\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. put s (m x)) = put s (sample p m)", "."], ["proof (state)\nthis:\n  sample p (\\<lambda>x. put s (m x)) = put s (sample p m)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sample_update: \"sample p (\\<lambda>x. update f (m x)) = update f (sample p m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample p (\\<lambda>x. update f (m x)) = update f (sample p m)", "by(simp add: update_def sample_get sample_put)"], ["", "end"], ["", "subsection \\<open>Nondeterministic choice\\<close>"], ["", "subsubsection \\<open>Binary choice\\<close>"], ["", "type_synonym 'm alt = \"'m \\<Rightarrow> 'm \\<Rightarrow> 'm\""], ["", "locale monad_alt_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes alt :: \"'m alt\""], ["", "locale monad_alt = monad return bind + monad_alt_base return bind alt\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and alt :: \"'m alt\"\n  + \\<comment> \\<open>Laws taken from Gibbons, Hinze: Just do it\\<close>\n  assumes alt_assoc: \"alt (alt m1 m2) m3 = alt m1 (alt m2 m3)\"\n  and bind_alt1: \"bind (alt m m') f = alt (bind m f) (bind m' f)\""], ["", "locale monad_fail_alt = monad_fail return bind fail + monad_alt return bind alt\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and fail :: \"'m fail\"\n  and alt :: \"'m alt\"\n  +\n  assumes alt_fail1: \"alt fail m = m\"\n  and alt_fail2: \"alt m fail = m\"\nbegin"], ["", "lemma assert_alt: \"assert P (alt m m') = alt (assert P m) (assert P m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. assert P (alt m m') = alt (assert P m) (assert P m')", "by(simp add: assert_def bind_alt1)"], ["", "end"], ["", "locale monad_state_alt = monad_state return bind get put + monad_alt return bind alt\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  and alt :: \"'m alt\"\n  +\n  assumes alt_get: \"alt (get f) (get g) = get (\\<lambda>x. alt (f x) (g x))\"\n  and alt_put: \"alt (put s m) (put s m') = put s (alt m m')\"\n  \\<comment> \\<open>Unlike for @{term sample}, we must require both @{text alt_get} and @{text alt_put} because\n  we do not require that @{term bind} right-distributes over @{term alt}.\\<close>\nbegin"], ["", "lemma alt_update: \"alt (update f m) (update f m') = update f (alt m m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt (update f m) (update f m') = update f (alt m m')", "by(simp add: update_def alt_get alt_put)"], ["", "end"], ["", "subsubsection \\<open>Countable choice\\<close>"], ["", "type_synonym ('c, 'm) altc = \"'c cset \\<Rightarrow> ('c \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "locale monad_altc_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes altc :: \"('c, 'm) altc\"\nbegin"], ["", "definition fail :: \"'m fail\" where \"fail = altc cempty (\\<lambda>_. undefined)\""], ["", "end"], ["", "declare monad_altc_base.fail_def [code]"], ["", "locale monad_altc = monad return bind + monad_altc_base return bind altc\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and altc :: \"('c, 'm) altc\"\n  +\n  assumes bind_altc1: \"\\<And>C g f. bind (altc C g) f = altc C (\\<lambda>c. bind (g c) f)\"\n  and altc_single: \"\\<And>x f. altc (csingle x) f = f x\"\n  and altc_cUNION: \"\\<And>C f g. altc (cUNION C f) g = altc C (\\<lambda>x. altc (f x) g)\"\n  \\<comment> \\<open>We do not assume @{text altc_const} like for @{text sample} because the choice set might be empty\\<close>\n  and altc_parametric: \"\\<And>R. bi_unique R \\<Longrightarrow> rel_fun (rel_cset R) (rel_fun (rel_fun R (=)) (=)) altc altc\"\nbegin"], ["", "lemma altc_cong: \"cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow> altc C f = altc C g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow> altc C f = altc C g", "apply(rule altc_parametric[where R=\"eq_onp (\\<lambda>x. cin x C)\", THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    bi_unique (eq_onp (\\<lambda>x. cin x C))\n 2. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_cset (eq_onp (\\<lambda>x. cin x C)) C C\n 3. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_fun (eq_onp (\\<lambda>x. cin x C)) (=) f g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    bi_unique (eq_onp (\\<lambda>x. cin x C))", "by(simp add: bi_unique_def eq_onp_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_cset (eq_onp (\\<lambda>x. cin x C)) C C\n 2. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_fun (eq_onp (\\<lambda>x. cin x C)) (=) f g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_cset (eq_onp (\\<lambda>x. cin x C)) C C", "by(simp add: cset.rel_eq_onp eq_onp_same_args pred_cset_def cin_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_fun (eq_onp (\\<lambda>x. cin x C)) (=) f g", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. cBall C (\\<lambda>x. f x = g x) \\<Longrightarrow>\n    rel_fun (eq_onp (\\<lambda>x. cin x C)) (=) f g", "by(simp add: rel_fun_def eq_onp_def cBall_def cin_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma monad_fail [locale_witness]: \"monad_fail return bind fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return bind fail", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. bind fail f = fail", "show \"bind fail f = fail\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind fail f = fail", "by(simp add: fail_def bind_altc1 cong: altc_cong)"], ["proof (state)\nthis:\n  bind fail ?f = fail\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>We can implement \\<open>alt\\<close> via \\<open>altc\\<close> only if we know that there are sufficiently\n  many elements in the choice type @{typ 'c}. For the associativity law, we need at least\n  three elements.\\<close>"], ["", "locale monad_altc3 = monad_altc return bind altc + three \"TYPE('c)\"\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and altc :: \"('c, 'm) altc\"\nbegin"], ["", "definition alt :: \"'m alt\"\nwhere \"alt m1 m2 = altc (cinsert \\<^bold>1 (csingle \\<^bold>2)) (\\<lambda>c. if c = \\<^bold>1 then m1 else m2)\""], ["", "lemma monad_alt: \"monad_alt return bind alt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return bind alt", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)\n 2. \\<And>m m' f. bind (alt m m') f = alt (bind m f) (bind m' f)", "show \"bind (alt m m') f = alt (bind m f) (bind m' f)\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (alt m m') f = alt (bind m f) (bind m' f)", "by(simp add: alt_def bind_altc1 if_distrib[where f=\"\\<lambda>m. bind m _\"])"], ["proof (state)\nthis:\n  bind (alt ?m ?m') ?f = alt (bind ?m ?f) (bind ?m' ?f)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "fix m1 m2 m3 :: 'm"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "let ?C = \"cUNION (cinsert \\<^bold>1 (csingle \\<^bold>2)) (\\<lambda>c. if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2) else csingle \\<^bold>3)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "let ?D = \"cUNION (cinsert \\<^bold>1 (csingle \\<^bold>2)) (\\<lambda>c. if c = \\<^bold>1 then csingle \\<^bold>1 else cinsert \\<^bold>2 (csingle \\<^bold>3))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "let ?f = \"\\<lambda>c. if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "have \"alt (alt m1 m2) m3 = altc ?C ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alt (alt m1 m2) m3 =\n    altc\n     (cUnion\n       (cimage\n         (\\<lambda>c.\n             if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n             else csingle \\<^bold>3)\n         (cinsert \\<^bold>1 (csingle \\<^bold>2))))\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)", "by (simp only: altc_cUNION) (auto simp add: alt_def altc_single intro!: altc_cong)"], ["proof (state)\nthis:\n  alt (alt m1 m2) m3 =\n  altc\n   (cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n           else csingle \\<^bold>3)\n       (cinsert \\<^bold>1 (csingle \\<^bold>2))))\n   (\\<lambda>c.\n       if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "also"], ["proof (state)\nthis:\n  alt (alt m1 m2) m3 =\n  altc\n   (cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n           else csingle \\<^bold>3)\n       (cinsert \\<^bold>1 (csingle \\<^bold>2))))\n   (\\<lambda>c.\n       if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "have \"?C = ?D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n           else csingle \\<^bold>3)\n       (cinsert \\<^bold>1 (csingle \\<^bold>2))) =\n    cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then csingle \\<^bold>1\n           else cinsert \\<^bold>2 (csingle \\<^bold>3))\n       (cinsert \\<^bold>1 (csingle \\<^bold>2)))", "including cset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n           else csingle \\<^bold>3)\n       (cinsert \\<^bold>1 (csingle \\<^bold>2))) =\n    cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then csingle \\<^bold>1\n           else cinsert \\<^bold>2 (csingle \\<^bold>3))\n       (cinsert \\<^bold>1 (csingle \\<^bold>2)))", "by transfer(auto simp add: insert_commute)"], ["proof (state)\nthis:\n  cUnion\n   (cimage\n     (\\<lambda>c.\n         if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n         else csingle \\<^bold>3)\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))) =\n  cUnion\n   (cimage\n     (\\<lambda>c.\n         if c = \\<^bold>1 then csingle \\<^bold>1\n         else cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2)))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "also"], ["proof (state)\nthis:\n  cUnion\n   (cimage\n     (\\<lambda>c.\n         if c = \\<^bold>1 then cinsert \\<^bold>1 (csingle \\<^bold>2)\n         else csingle \\<^bold>3)\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))) =\n  cUnion\n   (cimage\n     (\\<lambda>c.\n         if c = \\<^bold>1 then csingle \\<^bold>1\n         else cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2)))\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "have \"altc ?D ?f = alt m1 (alt m2 m3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. altc\n     (cUnion\n       (cimage\n         (\\<lambda>c.\n             if c = \\<^bold>1 then csingle \\<^bold>1\n             else cinsert \\<^bold>2 (csingle \\<^bold>3))\n         (cinsert \\<^bold>1 (csingle \\<^bold>2))))\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3) =\n    alt m1 (alt m2 m3)", "apply (simp only: altc_cUNION)"], ["proof (prove)\ngoal (1 subgoal):\n 1. altc (cinsert \\<^bold>1 (csingle \\<^bold>2))\n     (\\<lambda>x.\n         altc\n          (if x = \\<^bold>1 then csingle \\<^bold>1\n           else cinsert \\<^bold>2 (csingle \\<^bold>3))\n          (\\<lambda>c.\n              if c = \\<^bold>1 then m1\n              else if c = \\<^bold>2 then m2 else m3)) =\n    alt m1 (alt m2 m3)", "apply (clarsimp simp add: alt_def altc_single intro!: altc_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. altc (cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3) =\n    altc (cinsert \\<^bold>1 (csingle \\<^bold>2))\n     (\\<lambda>c. if c = \\<^bold>1 then m2 else m3)", "apply (rule altc_parametric [where R=\"conversep rel_12_23\", THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (3 subgoals):\n 1. bi_unique rel_12_23\\<inverse>\\<inverse>\n 2. rel_cset rel_12_23\\<inverse>\\<inverse>\n     (cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))\n 3. rel_fun rel_12_23\\<inverse>\\<inverse> (=)\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n     (\\<lambda>c. if c = \\<^bold>1 then m2 else m3)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. bi_unique rel_12_23\\<inverse>\\<inverse>", "by simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. rel_cset rel_12_23\\<inverse>\\<inverse>\n     (cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))\n 2. rel_fun rel_12_23\\<inverse>\\<inverse> (=)\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n     (\\<lambda>c. if c = \\<^bold>1 then m2 else m3)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_cset rel_12_23\\<inverse>\\<inverse>\n     (cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))", "including cset.lifting"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_cset rel_12_23\\<inverse>\\<inverse>\n     (cinsert \\<^bold>2 (csingle \\<^bold>3))\n     (cinsert \\<^bold>1 (csingle \\<^bold>2))", "by transfer\n      (simp add: rel_set_def rel_12_23.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun rel_12_23\\<inverse>\\<inverse> (=)\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n     (\\<lambda>c. if c = \\<^bold>1 then m2 else m3)", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_fun rel_12_23\\<inverse>\\<inverse> (=)\n     (\\<lambda>c.\n         if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3)\n     (\\<lambda>c. if c = \\<^bold>1 then m2 else m3)", "by (simp add: rel_fun_def rel_12_23.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  altc\n   (cUnion\n     (cimage\n       (\\<lambda>c.\n           if c = \\<^bold>1 then csingle \\<^bold>1\n           else cinsert \\<^bold>2 (csingle \\<^bold>3))\n       (cinsert \\<^bold>1 (csingle \\<^bold>2))))\n   (\\<lambda>c.\n       if c = \\<^bold>1 then m1 else if c = \\<^bold>2 then m2 else m3) =\n  alt m1 (alt m2 m3)\n\ngoal (1 subgoal):\n 1. \\<And>m1 m2 m3. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "finally"], ["proof (chain)\npicking this:\n  alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "show \"alt (alt m1 m2) m3 = alt m1 (alt m2 m3)\""], ["proof (prove)\nusing this:\n  alt (alt m1 m2) m3 = alt m1 (alt m2 m3)\n\ngoal (1 subgoal):\n 1. alt (alt m1 m2) m3 = alt m1 (alt m2 m3)", "."], ["proof (state)\nthis:\n  alt (alt m1 m2) m3 = alt m1 (alt m2 m3)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale monad_state_altc =\n  monad_state return bind get put +\n  monad_altc return bind altc\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\n  and altc :: \"('c, 'm) altc\"\n  +\n  assumes altc_get: \"\\<And>C f. altc C (\\<lambda>c. get (f c)) = get (\\<lambda>s. altc C (\\<lambda>c. f c s))\"\n  and altc_put: \"\\<And>C f. altc C (\\<lambda>c. put s (f c)) = put s (altc C f)\""], ["", "subsection \\<open>Writer monad\\<close>"], ["", "type_synonym ('w, 'm) tell = \"'w \\<Rightarrow> 'm \\<Rightarrow> 'm\""], ["", "locale monad_writer_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes tell :: \"('w, 'm) tell\""], ["", "locale monad_writer = monad_writer_base return bind tell + monad return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and tell :: \"('w, 'm) tell\"\n  +\n  assumes bind_tell: \"\\<And>w m f. bind (tell w m) f = tell w (bind m f)\""], ["", "subsection \\<open>Resumption monad\\<close>"], ["", "type_synonym ('o, 'i, 'm) pause = \"'o \\<Rightarrow> ('i \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "locale monad_resumption_base = monad_base return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  fixes pause :: \"('o, 'i, 'm) pause\""], ["", "locale monad_resumption = monad_resumption_base return bind pause + monad return bind \n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and pause :: \"('o, 'i, 'm) pause\"\n  +\n  assumes bind_pause: \"bind (pause out c) f = pause out (\\<lambda>i. bind (c i) f)\""], ["", "subsection \\<open>Commutative monad\\<close>"], ["", "locale monad_commute = monad return bind \n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  assumes bind_commute: \"bind m (\\<lambda>x. bind m' (f x)) = bind m' (\\<lambda>y. bind m (\\<lambda>x. f x y))\""], ["", "subsection \\<open>Discardable monad\\<close>"], ["", "locale monad_discard = monad return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  assumes bind_const: \"bind m (\\<lambda>_. m') = m'\""], ["", "subsection \\<open>Duplicable monad\\<close>"], ["", "locale monad_duplicate = monad return bind\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  +\n  assumes bind_duplicate: \"bind m (\\<lambda>x. bind m (f x)) = bind m (\\<lambda>x. f x x)\""], ["", "section \\<open>Monad implementations\\<close>"], ["", "subsection \\<open>Identity monad\\<close>"], ["", "text \\<open>We need a type constructor such that we can overload the monad operations\\<close>"], ["", "datatype 'a id = return_id (\"extract\": 'a)"], ["", "lemmas return_id_parametric = id.ctr_transfer"], ["", "lemma rel_id_unfold: \n  \"rel_id A (return_id x) m' \\<longleftrightarrow> (\\<exists>x'. m' = return_id x' \\<and> A x x')\"\n  \"rel_id A m (return_id x') \\<longleftrightarrow> (\\<exists>x. m = return_id x \\<and> A x x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_id A (return_id x) m' =\n    (\\<exists>x'. m' = return_id x' \\<and> A x x') &&&\n    rel_id A m (return_id x') = (\\<exists>x. m = return_id x \\<and> A x x')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_id A (return_id x) m' =\n    (\\<exists>x'. m' = return_id x' \\<and> A x x')", "by(cases m'; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_id A m (return_id x') = (\\<exists>x. m = return_id x \\<and> A x x')", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_id A m (return_id x') = (\\<exists>x. m = return_id x \\<and> A x x')", "by(cases m; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_id_expand: \"M (extract m) (extract m') \\<Longrightarrow> rel_id M m m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (extract m) (extract m') \\<Longrightarrow> rel_id M m m'", "by(cases m; cases m'; simp)"], ["", "subsubsection \\<open>Plain monad\\<close>"], ["", "primrec bind_id :: \"('a, 'a id) bind\"\nwhere \"bind_id (return_id x) f = f x\""], ["", "lemma extract_bind [simp]: \"extract (bind_id x f) = extract (f (extract x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract (bind_id x f) = extract (f (extract x))", "by(cases x) simp"], ["", "lemma bind_id_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_id A ===> (A ===> rel_id A) ===> rel_id A) bind_id bind_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_id A ===> (A ===> rel_id A) ===> rel_id A) bind_id bind_id", "unfolding bind_id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_id A ===> (A ===> rel_id A) ===> rel_id A)\n     (rec_id (\\<lambda>x f. f x)) (rec_id (\\<lambda>x f. f x))", "by transfer_prover"], ["", "lemma monad_id [locale_witness]: \"monad return_id bind_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return_id bind_id", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       bind_id (bind_id x f) g = bind_id x (\\<lambda>y. bind_id (f y) g)\n 2. \\<And>x f. bind_id (return_id x) f = f x\n 3. \\<And>x. bind_id x return_id = x", "show \"bind_id (bind_id x f) g = bind_id x (\\<lambda>x. bind_id (f x) g)\" \n    for x :: \"'a id\" and f :: \"'a \\<Rightarrow> 'a id\" and g :: \"'a \\<Rightarrow> 'a id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id (bind_id x f) g = bind_id x (\\<lambda>x. bind_id (f x) g)", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id (bind_id ?x ?f) ?g = bind_id ?x (\\<lambda>x. bind_id (?f x) ?g)\n\ngoal (2 subgoals):\n 1. \\<And>x f. bind_id (return_id x) f = f x\n 2. \\<And>x. bind_id x return_id = x", "show \"bind_id (return_id x) f = f x\" for f :: \"'a \\<Rightarrow> 'a id\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id (return_id x) f = f x", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id (return_id ?x) ?f = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. bind_id x return_id = x", "show \"bind_id x return_id = x\" for x :: \"'a id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id x return_id = x", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id ?x return_id = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_commute_id [locale_witness]: \"monad_commute return_id bind_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return_id bind_id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       bind_id m (\\<lambda>x. bind_id m' (f x)) =\n       bind_id m' (\\<lambda>y. bind_id m (\\<lambda>x. f x y))", "show \"bind_id m (\\<lambda>x. bind_id m' (f x)) = bind_id m' (\\<lambda>y. bind_id m (\\<lambda>x. f x y))\" for m m' :: \"'a id\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id m (\\<lambda>x. bind_id m' (f x)) =\n    bind_id m' (\\<lambda>y. bind_id m (\\<lambda>x. f x y))", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id ?m (\\<lambda>x. bind_id ?m' (?f x)) =\n  bind_id ?m' (\\<lambda>y. bind_id ?m (\\<lambda>x. ?f x y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_discard_id [locale_witness]: \"monad_discard return_id bind_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return_id bind_id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'. bind_id m (\\<lambda>_. m') = m'", "show \"bind_id m (\\<lambda>_. m') = m'\" for m m' :: \"'a id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id m (\\<lambda>_. m') = m'", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id ?m (\\<lambda>_. ?m') = ?m'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_duplicate_id [locale_witness]: \"monad_duplicate return_id bind_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate return_id bind_id", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       bind_id m (\\<lambda>x. bind_id m (f x)) =\n       bind_id m (\\<lambda>x. f x x)", "show \"bind_id m (\\<lambda>x. bind_id m (f x)) = bind_id m (\\<lambda>x. f x x)\" for m :: \"'a id\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id m (\\<lambda>x. bind_id m (f x)) = bind_id m (\\<lambda>x. f x x)", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  bind_id ?m (\\<lambda>x. bind_id ?m (?f x)) =\n  bind_id ?m (\\<lambda>x. ?f x x)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Probability monad\\<close>"], ["", "text \\<open>We don't know of a sensible probability monad transformer, so we define the plain probability monad.\\<close>"], ["", "type_synonym 'a prob = \"'a pmf\""], ["", "lemma monad_prob [locale_witness]: \"monad return_pmf bind_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return_pmf (\\<bind>)", "by unfold_locales(simp_all add: bind_assoc_pmf bind_return_pmf bind_return_pmf')"], ["", "lemma monad_prob_prob [locale_witness]: \"monad_prob return_pmf bind_pmf bind_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return_pmf (\\<bind>) (\\<bind>)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return_pmf (\\<bind>) (\\<bind>)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p m. p \\<bind> (\\<lambda>_. m) = m\n 2. \\<And>x f. return_pmf x \\<bind> f = f x\n 3. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 4. \\<And>p q f.\n       p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n       q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 6. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf p (\\<lambda>_. m) = m\" for p :: \"'b pmf\" and m :: \"'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>_. m) = m", "by(rule bind_pmf_const)"], ["proof (state)\nthis:\n  ?p \\<bind> (\\<lambda>_. ?m) = ?m\n\ngoal (6 subgoals):\n 1. \\<And>x f. return_pmf x \\<bind> f = f x\n 2. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 3. \\<And>p q f.\n       p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n       q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))\n 4. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 5. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf (return_pmf x) f = f x\" for f :: \"'b \\<Rightarrow> 'a prob\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_pmf x \\<bind> f = f x", "by(rule bind_return_pmf)"], ["proof (state)\nthis:\n  return_pmf ?x \\<bind> ?f = ?f ?x\n\ngoal (5 subgoals):\n 1. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 2. \\<And>p q f.\n       p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n       q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))\n 3. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 4. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf (bind_pmf p f) g = bind_pmf p (\\<lambda>x. bind_pmf (f x) g)\"\n    for p :: \"'b pmf\" and f :: \"'b \\<Rightarrow> 'b pmf\" and g :: \"'b \\<Rightarrow> 'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)", "by(rule bind_assoc_pmf)"], ["proof (state)\nthis:\n  ?p \\<bind> ?f \\<bind> ?g = ?p \\<bind> (\\<lambda>x. ?f x \\<bind> ?g)\n\ngoal (4 subgoals):\n 1. \\<And>p q f.\n       p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n       q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))\n 2. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 3. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf p (\\<lambda>x. bind_pmf q (f x)) = bind_pmf q (\\<lambda>y. bind_pmf p (\\<lambda>x. f x y))\"\n    for p q :: \"'b pmf\" and f :: \"'b \\<Rightarrow> 'b \\<Rightarrow> 'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> (\\<lambda>x. q \\<bind> f x) =\n    q \\<bind> (\\<lambda>y. p \\<bind> (\\<lambda>x. f x y))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  ?p \\<bind> (\\<lambda>x. ?q \\<bind> ?f x) =\n  ?q \\<bind> (\\<lambda>y. ?p \\<bind> (\\<lambda>x. ?f x y))\n\ngoal (3 subgoals):\n 1. \\<And>p f g.\n       p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)\n 2. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf (bind_pmf p f) g = bind_pmf p (\\<lambda>x. bind_pmf (f x) g)\"\n    for p :: \"'b pmf\" and f :: \"'b \\<Rightarrow> 'a prob\" and g :: \"'a \\<Rightarrow> 'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<bind> f \\<bind> g = p \\<bind> (\\<lambda>x. f x \\<bind> g)", "by(simp add: bind_assoc_pmf)"], ["proof (state)\nthis:\n  ?p \\<bind> ?f \\<bind> ?g = ?p \\<bind> (\\<lambda>x. ?f x \\<bind> ?g)\n\ngoal (2 subgoals):\n 1. \\<And>m f p.\n       m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n       p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"bind_pmf m (\\<lambda>y. bind_pmf p (f y)) = bind_pmf p (\\<lambda>x. bind_pmf m (\\<lambda>y. f y x))\"\n    for m :: \"'a prob\" and p :: \"'b pmf\" and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> 'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>y. p \\<bind> f y) =\n    p \\<bind> (\\<lambda>x. m \\<bind> (\\<lambda>y. f y x))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  ?m \\<bind> (\\<lambda>y. ?p \\<bind> ?f y) =\n  ?p \\<bind> (\\<lambda>x. ?m \\<bind> (\\<lambda>y. ?f y x))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "show \"(rel_pmf R ===> (R ===> (=)) ===> (=)) bind_pmf bind_pmf\" for R :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)", "by transfer_prover"], ["proof (state)\nthis:\n  (rel_pmf ?R1 ===> (?R1 ===> (=)) ===> (=)) (\\<bind>) (\\<bind>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_commute_prob [locale_witness]: \"monad_commute return_pmf bind_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return_pmf (\\<bind>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       m \\<bind> (\\<lambda>x. m' \\<bind> f x) =\n       m' \\<bind> (\\<lambda>y. m \\<bind> (\\<lambda>x. f x y))", "show \"bind_pmf m (\\<lambda>x. bind_pmf m' (f x)) = bind_pmf m' (\\<lambda>y. bind_pmf m (\\<lambda>x. f x y))\"\n    for m m' :: \"'a prob\" and f :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a prob\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>x. m' \\<bind> f x) =\n    m' \\<bind> (\\<lambda>y. m \\<bind> (\\<lambda>x. f x y))", "by(rule bind_commute_pmf)"], ["proof (state)\nthis:\n  ?m \\<bind> (\\<lambda>x. ?m' \\<bind> ?f x) =\n  ?m' \\<bind> (\\<lambda>y. ?m \\<bind> (\\<lambda>x. ?f x y))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_discard_prob [locale_witness]: \"monad_discard return_pmf bind_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return_pmf (\\<bind>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'. m \\<bind> (\\<lambda>_. m') = m'", "show \"bind_pmf m (\\<lambda>_. m') = m'\" for m m' :: \"'a pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<bind> (\\<lambda>_. m') = m'", "by(simp)"], ["proof (state)\nthis:\n  ?m \\<bind> (\\<lambda>_. ?m') = ?m'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Resumption\\<close>"], ["", "text \\<open>\n  We cannot define a resumption monad transformer because the codatatype recursion would have to\n  go through a type variable. If we plug in something like unbounded non-determinism, then the\n  HOL type does not exist.\n\\<close>"], ["", "codatatype ('o, 'i, 'a) resumption = is_Done: Done (result: 'a) | Pause (\"output\": 'o) (resume: \"'i \\<Rightarrow> ('o, 'i, 'a) resumption\")"], ["", "subsubsection \\<open>Plain monad\\<close>"], ["", "definition return_resumption :: \"'a \\<Rightarrow> ('o, 'i, 'a) resumption\"\nwhere \"return_resumption = Done\""], ["", "primcorec bind_resumption :: \"('o, 'i, 'a) resumption \\<Rightarrow> ('a \\<Rightarrow> ('o, 'i, 'a) resumption) \\<Rightarrow> ('o, 'i, 'a) resumption\"\nwhere \"bind_resumption m f = (if is_Done m then f (result m) else Pause (output m) (\\<lambda>i. bind_resumption (resume m i) f))\""], ["", "definition pause_resumption :: \"'o \\<Rightarrow> ('i \\<Rightarrow> ('o, 'i, 'a) resumption) \\<Rightarrow> ('o, 'i, 'a) resumption\"\nwhere \"pause_resumption = Pause\""], ["", "lemma is_Done_return_resumption [simp]: \"is_Done (return_resumption x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_Done (return_resumption x)", "by(simp add: return_resumption_def)"], ["", "lemma result_return_resumption [simp]: \"result (return_resumption x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. result (return_resumption x) = x", "by(simp add: return_resumption_def)"], ["", "lemma monad_resumption [locale_witness]: \"monad return_resumption bind_resumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return_resumption bind_resumption", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       bind_resumption (bind_resumption x f) g =\n       bind_resumption x (\\<lambda>y. bind_resumption (f y) g)\n 2. \\<And>x f. bind_resumption (return_resumption x) f = f x\n 3. \\<And>x. bind_resumption x return_resumption = x", "show \"bind_resumption (bind_resumption x f) g = bind_resumption x (\\<lambda>y. bind_resumption (f y) g)\"\n    for x :: \"('o, 'i, 'a) resumption\" and f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_resumption (bind_resumption x f) g =\n    bind_resumption x (\\<lambda>y. bind_resumption (f y) g)", "by(coinduction arbitrary: x f g rule: resumption.coinduct_strong) auto"], ["proof (state)\nthis:\n  bind_resumption (bind_resumption ?x1 ?f1) ?g1 =\n  bind_resumption ?x1 (\\<lambda>y. bind_resumption (?f1 y) ?g1)\n\ngoal (2 subgoals):\n 1. \\<And>x f. bind_resumption (return_resumption x) f = f x\n 2. \\<And>x. bind_resumption x return_resumption = x", "show \"bind_resumption (return_resumption x) f = f x\" for x and f :: \"'a \\<Rightarrow> ('o, 'i, 'a) resumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_resumption (return_resumption x) f = f x", "by(rule resumption.expand)(simp_all add: return_resumption_def)"], ["proof (state)\nthis:\n  bind_resumption (return_resumption ?x2) ?f2 = ?f2 ?x2\n\ngoal (1 subgoal):\n 1. \\<And>x. bind_resumption x return_resumption = x", "show \"bind_resumption x return_resumption = x\" for x :: \"('o, 'i, 'a) resumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_resumption x return_resumption = x", "by(coinduction arbitrary: x rule: resumption.coinduct_strong) auto"], ["proof (state)\nthis:\n  bind_resumption ?x3 return_resumption = ?x3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_resumption_resumption [locale_witness]:\n  \"monad_resumption return_resumption bind_resumption pause_resumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption return_resumption bind_resumption pause_resumption", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c f.\n       bind_resumption (pause_resumption out c) f =\n       pause_resumption out (\\<lambda>i. bind_resumption (c i) f)", "show \"bind_resumption (pause_resumption out c) f = pause_resumption out (\\<lambda>i. bind_resumption (c i) f)\"\n    for out c and f :: \"'a \\<Rightarrow> ('o, 'i, 'a) resumption\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_resumption (pause_resumption out c) f =\n    pause_resumption out (\\<lambda>i. bind_resumption (c i) f)", "by(rule resumption.expand)(simp_all add: pause_resumption_def)"], ["proof (state)\nthis:\n  bind_resumption (pause_resumption ?out1 ?c1) ?f1 =\n  pause_resumption ?out1 (\\<lambda>i. bind_resumption (?c1 i) ?f1)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Failure and exception monad transformer\\<close>"], ["", "text \\<open>\n  The phantom type variable @{typ 'a} is needed to avoid hidden polymorphism when overloading the\n  monad operations for the failure monad transformer.\n\\<close>"], ["", "datatype (plugins del: transfer) (phantom_optionT: 'a, set_optionT: 'm) optionT =\n  OptionT (run_option: 'm)\n  for rel: rel_optionT' \n      map: map_optionT'"], ["", "text \\<open>\n  We define our own relator and mapper such that the phantom variable does not need any relation.\n\\<close>"], ["", "lemma phantom_optionT [simp]: \"phantom_optionT x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phantom_optionT x = {}", "by(cases x) simp"], ["", "context includes lifting_syntax begin"], ["", "lemma rel_optionT'_phantom: \"rel_optionT' A = rel_optionT' top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT' A = rel_optionT' \\<top>", "by(auto 4 4 intro: optionT.rel_mono antisym optionT.rel_mono_strong)"], ["", "lemma map_optionT'_phantom: \"map_optionT' f = map_optionT' undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_optionT' f = map_optionT' undefined", "by(auto 4 4 intro: optionT.map_cong)"], ["", "definition map_optionT :: \"('m \\<Rightarrow> 'm') \\<Rightarrow> ('a, 'm) optionT \\<Rightarrow> ('b, 'm') optionT\"\nwhere \"map_optionT = map_optionT' undefined\""], ["", "definition rel_optionT :: \"('m \\<Rightarrow> 'm' \\<Rightarrow> bool) \\<Rightarrow> ('a, 'm) optionT \\<Rightarrow> ('b, 'm') optionT \\<Rightarrow> bool\"\nwhere \"rel_optionT = rel_optionT' top\""], ["", "lemma rel_optionTE:\n  assumes \"rel_optionT M m m'\"\n  obtains x y where \"m = OptionT x\" \"m' = OptionT y\" \"M x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>m = OptionT x; m' = OptionT y; M x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rel_optionT M m m'\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>m = OptionT x; m' = OptionT y; M x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m; cases m'; simp add: rel_optionT_def)"], ["", "lemma rel_optionT_simps [simp]: \"rel_optionT M (OptionT m) (OptionT m') \\<longleftrightarrow> M m m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT M (OptionT m) (OptionT m') = M m m'", "by(simp add: rel_optionT_def)"], ["", "lemma rel_optionT_eq [relator_eq]: \"rel_optionT (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT (=) = (=)", "by(auto simp add: fun_eq_iff rel_optionT_def intro: optionT.rel_refl_strong elim: optionT.rel_cases)"], ["", "lemma rel_optionT_mono [relator_mono]: \"rel_optionT A \\<le> rel_optionT B\" if \"A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT A \\<le> rel_optionT B", "by(simp add: rel_optionT_def optionT.rel_mono that)"], ["", "lemma rel_optionT_distr [relator_distr]: \"rel_optionT A OO rel_optionT B = rel_optionT (A OO B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT A OO rel_optionT B = rel_optionT (A OO B)", "by(simp add: rel_optionT_def optionT.rel_compp[symmetric])"], ["", "lemma rel_optionT_Grp: \"rel_optionT (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_optionT x \\<subseteq> A} (map_optionT f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_optionT (BNF_Def.Grp A f) =\n    BNF_Def.Grp {x. set_optionT x \\<subseteq> A} (map_optionT f)", "by(simp add: rel_optionT_def rel_optionT'_phantom[of \"BNF_Def.Grp UNIV undefined\", symmetric] optionT.rel_Grp map_optionT_def)"], ["", "lemma OptionT_parametric [transfer_rule]: \"(M ===> rel_optionT M) OptionT OptionT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_optionT M) OptionT OptionT", "by(simp add: rel_fun_def rel_optionT_def)"], ["", "lemma run_option_parametric [transfer_rule]: \"(rel_optionT M ===> M) run_option run_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_optionT M ===> M) run_option run_option", "by(auto simp add: rel_fun_def rel_optionT_def elim: optionT.rel_cases)"], ["", "lemma case_optionT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_optionT M ===> X) case_optionT case_optionT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> X) ===> rel_optionT M ===> X) case_optionT case_optionT", "by(auto simp add: rel_fun_def rel_optionT_def split: optionT.split)"], ["", "lemma rec_optionT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_optionT M ===> X) rec_optionT rec_optionT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> X) ===> rel_optionT M ===> X) rec_optionT rec_optionT", "by(auto simp add: rel_fun_def elim: rel_optionTE)"], ["", "end"], ["", "subsubsection \\<open>Plain monad, failure, and exceptions\\<close>"], ["", "context\n  fixes return :: \"('a option, 'm) return\"\n  and bind :: \"('a option, 'm) bind\"\nbegin"], ["", "definition return_option :: \"('a, ('a, 'm) optionT) return\"\nwhere \"return_option x = OptionT (return (Some x))\""], ["", "primrec bind_option :: \"('a, ('a, 'm) optionT) bind\"\nwhere [code_unfold, monad_unfold]:\n  \"bind_option (OptionT x) f = \n   OptionT (bind x (\\<lambda>x. case x of None \\<Rightarrow> return (None :: 'a option) | Some y \\<Rightarrow> run_option (f y)))\""], ["", "definition fail_option :: \"('a, 'm) optionT fail\"\nwhere [code_unfold, monad_unfold]: \"fail_option = OptionT (return None)\""], ["", "definition catch_option :: \"('a, 'm) optionT catch\"\nwhere \"catch_option m h = OptionT (bind (run_option m) (\\<lambda>x. if x = None then run_option h else return x))\""], ["", "lemma run_bind_option:\n  \"run_option (bind_option x f) = bind (run_option x) (\\<lambda>x. case x of None \\<Rightarrow> return None | Some y \\<Rightarrow> run_option (f y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.bind_option x f) =\n    bind (run_option x)\n     (\\<lambda>x.\n         case x of None \\<Rightarrow> return None\n         | Some y \\<Rightarrow> run_option (f y))", "by(cases x) simp"], ["", "lemma run_return_option [simp]: \"run_option (return_option x) = return (Some x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.return_option x) = return (Some x)", "by(simp add: return_option_def)"], ["", "lemma run_fail_option [simp]: \"run_option fail_option = return None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option local.fail_option = return None", "by(simp add: fail_option_def)"], ["", "lemma run_catch_option [simp]: \n  \"run_option (catch_option m1 m2) = bind (run_option m1) (\\<lambda>x. if x = None then run_option m2 else return x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.catch_option m1 m2) =\n    bind (run_option m1)\n     (\\<lambda>x. if x = None then run_option m2 else return x)", "by(simp add: catch_option_def)"], ["", "context\n  assumes monad: \"monad return bind\"\nbegin"], ["", "interpretation monad return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return bind", "by(rule monad)"], ["", "lemma monad_optionT [locale_witness]: \"monad return_option bind_option\" (is \"monad ?return ?bind\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad local.return_option local.bind_option", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       local.bind_option (local.bind_option x f) g =\n       local.bind_option x (\\<lambda>y. local.bind_option (f y) g)\n 2. \\<And>x f. local.bind_option (local.return_option x) f = f x\n 3. \\<And>x. local.bind_option x local.return_option = x", "show \"?bind (?bind x f) g = ?bind x (\\<lambda>x. ?bind (f x) g)\"  for x f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.bind_option x f) g =\n    local.bind_option x (\\<lambda>x. local.bind_option (f x) g)", "by(rule optionT.expand)(auto simp add: bind_assoc run_bind_option return_bind intro!: arg_cong2[where f=bind] split: option.split)"], ["proof (state)\nthis:\n  local.bind_option (local.bind_option ?x ?f) ?g =\n  local.bind_option ?x (\\<lambda>x. local.bind_option (?f x) ?g)\n\ngoal (2 subgoals):\n 1. \\<And>x f. local.bind_option (local.return_option x) f = f x\n 2. \\<And>x. local.bind_option x local.return_option = x", "show \"?bind (?return x) f = f x\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.return_option x) f = f x", "by(rule optionT.expand)(simp add: run_bind_option return_bind return_option_def)"], ["proof (state)\nthis:\n  local.bind_option (local.return_option ?x) ?f = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. local.bind_option x local.return_option = x", "show \"?bind x ?return = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option x local.return_option = x", "by(rule optionT.expand)(simp add: run_bind_option option.case_distrib[symmetric] case_option_id bind_return cong del: option.case_cong)"], ["proof (state)\nthis:\n  local.bind_option ?x local.return_option = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_fail_optionT [locale_witness]:\n  \"monad_fail return_option bind_option fail_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail local.return_option local.bind_option local.fail_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. local.bind_option local.fail_option f = local.fail_option", "show \"bind_option fail_option f = fail_option\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option local.fail_option f = local.fail_option", "by(rule optionT.expand)(simp add: run_bind_option return_bind)"], ["proof (state)\nthis:\n  local.bind_option local.fail_option ?f = local.fail_option\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_catch_optionT [locale_witness]:\n  \"monad_catch return_option bind_option fail_option catch_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch local.return_option local.bind_option local.fail_option\n     local.catch_option", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x m.\n       local.catch_option (local.return_option x) m = local.return_option x\n 2. \\<And>m. local.catch_option local.fail_option m = m\n 3. \\<And>m. local.catch_option m local.fail_option = m\n 4. \\<And>m m' m''.\n       local.catch_option (local.catch_option m m') m'' =\n       local.catch_option m (local.catch_option m' m'')", "show \"catch_option (return_option x) m = return_option x\" for x m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option (local.return_option x) m = local.return_option x", "by(rule optionT.expand)(simp add: return_bind)"], ["proof (state)\nthis:\n  local.catch_option (local.return_option ?x) ?m = local.return_option ?x\n\ngoal (3 subgoals):\n 1. \\<And>m. local.catch_option local.fail_option m = m\n 2. \\<And>m. local.catch_option m local.fail_option = m\n 3. \\<And>m m' m''.\n       local.catch_option (local.catch_option m m') m'' =\n       local.catch_option m (local.catch_option m' m'')", "show \"catch_option fail_option m = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option local.fail_option m = m", "by(rule optionT.expand)(simp add: return_bind)"], ["proof (state)\nthis:\n  local.catch_option local.fail_option ?m = ?m\n\ngoal (2 subgoals):\n 1. \\<And>m. local.catch_option m local.fail_option = m\n 2. \\<And>m m' m''.\n       local.catch_option (local.catch_option m m') m'' =\n       local.catch_option m (local.catch_option m' m'')", "show \"catch_option m fail_option = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option m local.fail_option = m", "by(rule optionT.expand)(simp add: bind_return if_distrib[where f=\"return\", symmetric] cong del: if_weak_cong)"], ["proof (state)\nthis:\n  local.catch_option ?m local.fail_option = ?m\n\ngoal (1 subgoal):\n 1. \\<And>m m' m''.\n       local.catch_option (local.catch_option m m') m'' =\n       local.catch_option m (local.catch_option m' m'')", "show \"catch_option (catch_option m m') m'' = catch_option m (catch_option m' m'')\" for m m' m''"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option (local.catch_option m m') m'' =\n    local.catch_option m (local.catch_option m' m'')", "by(rule optionT.expand)(auto simp add: bind_assoc fun_eq_iff return_bind intro!: arg_cong2[where f=bind])"], ["proof (state)\nthis:\n  local.catch_option (local.catch_option ?m ?m') ?m'' =\n  local.catch_option ?m (local.catch_option ?m' ?m'')\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Reader\\<close>"], ["", "context\n  fixes ask :: \"('r, 'm) ask\"\nbegin"], ["", "definition ask_option :: \"('r, ('a, 'm) optionT) ask\" \nwhere [code_unfold, monad_unfold]: \"ask_option f = OptionT (ask (\\<lambda>r. run_option (f r)))\""], ["", "lemma run_ask_option [simp]: \"run_option (ask_option f) = ask (\\<lambda>r. run_option (f r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.ask_option f) = ask (\\<lambda>r. run_option (f r))", "by(simp add: ask_option_def)"], ["", "lemma monad_reader_optionT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_option bind_option ask_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_option local.bind_option local.ask_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_option local.bind_option local.ask_option", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_option local.bind_option local.ask_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_option local.bind_option local.ask_option", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       local.ask_option (\\<lambda>r. local.ask_option (f r)) =\n       local.ask_option (\\<lambda>r. f r r)\n 2. \\<And>m. local.ask_option (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_option (local.ask_option f) g =\n       local.ask_option (\\<lambda>r. local.bind_option (f r) g)\n 4. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.ask_option (f x)) =\n       local.ask_option\n        (\\<lambda>r. local.bind_option m (\\<lambda>x. f x r))", "show \"ask_option (\\<lambda>r. ask_option (f r)) = ask_option (\\<lambda>r. f r r)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_option (\\<lambda>r. local.ask_option (f r)) =\n    local.ask_option (\\<lambda>r. f r r)", "by(rule optionT.expand)(simp add: ask_ask)"], ["proof (state)\nthis:\n  local.ask_option (\\<lambda>r. local.ask_option (?f r)) =\n  local.ask_option (\\<lambda>r. ?f r r)\n\ngoal (3 subgoals):\n 1. \\<And>m. local.ask_option (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_option (local.ask_option f) g =\n       local.ask_option (\\<lambda>r. local.bind_option (f r) g)\n 3. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.ask_option (f x)) =\n       local.ask_option\n        (\\<lambda>r. local.bind_option m (\\<lambda>x. f x r))", "show \"ask_option (\\<lambda>_. x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_option (\\<lambda>_. x) = x", "by(rule optionT.expand)(simp add: ask_const)"], ["proof (state)\nthis:\n  local.ask_option (\\<lambda>_. ?x) = ?x\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_option (local.ask_option f) g =\n       local.ask_option (\\<lambda>r. local.bind_option (f r) g)\n 2. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.ask_option (f x)) =\n       local.ask_option\n        (\\<lambda>r. local.bind_option m (\\<lambda>x. f x r))", "show \"bind_option (ask_option f) g = ask_option (\\<lambda>r. bind_option (f r) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.ask_option f) g =\n    local.ask_option (\\<lambda>r. local.bind_option (f r) g)", "by(rule optionT.expand)(simp add: bind_ask run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.ask_option ?f) ?g =\n  local.ask_option (\\<lambda>r. local.bind_option (?f r) ?g)\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.ask_option (f x)) =\n       local.ask_option\n        (\\<lambda>r. local.bind_option m (\\<lambda>x. f x r))", "show \"bind_option m (\\<lambda>x. ask_option (f x)) = ask_option (\\<lambda>r. bind_option m (\\<lambda>x. f x r))\" for m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option m (\\<lambda>x. local.ask_option (f x)) =\n    local.ask_option (\\<lambda>r. local.bind_option m (\\<lambda>x. f x r))", "by(rule optionT.expand)(auto simp add: bind_ask2[symmetric] run_bind_option ask_const del: ext intro!: arg_cong2[where f=bind] ext split: option.split)"], ["proof (state)\nthis:\n  local.bind_option ?m (\\<lambda>x. local.ask_option (?f x)) =\n  local.ask_option (\\<lambda>r. local.bind_option ?m (\\<lambda>x. ?f x r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_reader local.return_option local.bind_option local.ask_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>State\\<close>"], ["", "context\n  fixes get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\nbegin"], ["", "definition get_option :: \"('s, ('a, 'm) optionT) get\"\nwhere \"get_option f = OptionT (get (\\<lambda>s. run_option (f s)))\""], ["", "primrec put_option :: \"('s, ('a, 'm) optionT) put\"\nwhere \"put_option s (OptionT m) = OptionT (put s m)\""], ["", "lemma run_get_option [simp]:\n  \"run_option (get_option f) = get (\\<lambda>s. run_option (f s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.get_option f) = get (\\<lambda>s. run_option (f s))", "by(simp add: get_option_def)"], ["", "lemma run_put_option [simp]:\n  \"run_option (put_option s m) = put s (run_option m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.put_option s m) = put s (run_option m)", "by(cases m)(simp)"], ["", "context\n  assumes state: \"monad_state return bind get put\"\nbegin"], ["", "interpretation monad_state return bind get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return bind get put", "by(fact state)"], ["", "lemma monad_state_optionT [locale_witness]:\n  \"monad_state return_option bind_option get_option put_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_option local.bind_option local.get_option\n     local.put_option", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f.\n       local.put_option s (local.get_option f) = local.put_option s (f s)\n 2. \\<And>f.\n       local.get_option (\\<lambda>s. local.get_option (f s)) =\n       local.get_option (\\<lambda>s. f s s)\n 3. \\<And>s s' m.\n       local.put_option s (local.put_option s' m) = local.put_option s' m\n 4. \\<And>m. local.get_option (\\<lambda>s. local.put_option s m) = m\n 5. \\<And>m. local.get_option (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 7. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"put_option s (get_option f) = put_option s (f s)\" for s f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_option s (local.get_option f) = local.put_option s (f s)", "by(rule optionT.expand)(simp add: put_get)"], ["proof (state)\nthis:\n  local.put_option ?s1 (local.get_option ?f1) =\n  local.put_option ?s1 (?f1 ?s1)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       local.get_option (\\<lambda>s. local.get_option (f s)) =\n       local.get_option (\\<lambda>s. f s s)\n 2. \\<And>s s' m.\n       local.put_option s (local.put_option s' m) = local.put_option s' m\n 3. \\<And>m. local.get_option (\\<lambda>s. local.put_option s m) = m\n 4. \\<And>m. local.get_option (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 6. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"get_option (\\<lambda>s. get_option (f s)) = get_option (\\<lambda>s. f s s)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_option (\\<lambda>s. local.get_option (f s)) =\n    local.get_option (\\<lambda>s. f s s)", "by(rule optionT.expand)(simp add: get_get)"], ["proof (state)\nthis:\n  local.get_option (\\<lambda>s. local.get_option (?f1 s)) =\n  local.get_option (\\<lambda>s. ?f1 s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m.\n       local.put_option s (local.put_option s' m) = local.put_option s' m\n 2. \\<And>m. local.get_option (\\<lambda>s. local.put_option s m) = m\n 3. \\<And>m. local.get_option (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 5. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"put_option s (put_option s' m) = put_option s' m\" for s s' m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_option s (local.put_option s' m) = local.put_option s' m", "by(rule optionT.expand)(simp add: put_put)"], ["proof (state)\nthis:\n  local.put_option ?s1 (local.put_option ?s'1 ?m1) =\n  local.put_option ?s'1 ?m1\n\ngoal (4 subgoals):\n 1. \\<And>m. local.get_option (\\<lambda>s. local.put_option s m) = m\n 2. \\<And>m. local.get_option (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 4. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"get_option (\\<lambda>s. put_option s m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_option (\\<lambda>s. local.put_option s m) = m", "by(rule optionT.expand)(simp add: get_put)"], ["proof (state)\nthis:\n  local.get_option (\\<lambda>s. local.put_option s ?m1) = ?m1\n\ngoal (3 subgoals):\n 1. \\<And>m. local.get_option (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 3. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"get_option (\\<lambda>_. m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_option (\\<lambda>_. m) = m", "by(rule optionT.expand)(simp add: get_const)"], ["proof (state)\nthis:\n  local.get_option (\\<lambda>_. ?m1) = ?m1\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_option (local.get_option f) g =\n       local.get_option (\\<lambda>s. local.bind_option (f s) g)\n 2. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"bind_option (get_option f) g = get_option (\\<lambda>s. bind_option (f s) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.get_option f) g =\n    local.get_option (\\<lambda>s. local.bind_option (f s) g)", "by(rule optionT.expand)(simp add: bind_get run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.get_option ?f1) ?g1 =\n  local.get_option (\\<lambda>s. local.bind_option (?f1 s) ?g1)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       local.bind_option (local.put_option s m) f =\n       local.put_option s (local.bind_option m f)", "show \"bind_option (put_option s m) f = put_option s (bind_option m f)\" for s m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.put_option s m) f =\n    local.put_option s (local.bind_option m f)", "by(rule optionT.expand)(simp add: bind_put run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.put_option ?s1 ?m1) ?f1 =\n  local.put_option ?s1 (local.bind_option ?m1 ?f1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_catch_state_optionT [locale_witness]:\n  \"monad_catch_state return_option bind_option fail_option catch_option get_option put_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch_state local.return_option local.bind_option\n     local.fail_option local.catch_option local.get_option local.put_option", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f m.\n       local.catch_option (local.get_option f) m =\n       local.get_option (\\<lambda>s. local.catch_option (f s) m)\n 2. \\<And>s m m'.\n       local.catch_option (local.put_option s m) m' =\n       local.put_option s (local.catch_option m m')", "show \"catch_option (get_option f) m = get_option (\\<lambda>s. catch_option (f s) m)\" for f m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option (local.get_option f) m =\n    local.get_option (\\<lambda>s. local.catch_option (f s) m)", "by(rule optionT.expand)(simp add: bind_get)"], ["proof (state)\nthis:\n  local.catch_option (local.get_option ?f1) ?m1 =\n  local.get_option (\\<lambda>s. local.catch_option (?f1 s) ?m1)\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       local.catch_option (local.put_option s m) m' =\n       local.put_option s (local.catch_option m m')", "show \"catch_option (put_option s m) m' = put_option s (catch_option m m')\" for s m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_option (local.put_option s m) m' =\n    local.put_option s (local.catch_option m m')", "by(rule optionT.expand)(simp add: bind_put)"], ["proof (state)\nthis:\n  local.catch_option (local.put_option ?s1 ?m1) ?m'1 =\n  local.put_option ?s1 (local.catch_option ?m1 ?m'1)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Probability\\<close>"], ["", "definition altc_sample_option :: \"('x \\<Rightarrow> ('b \\<Rightarrow> 'm) \\<Rightarrow> 'm) \\<Rightarrow> 'x \\<Rightarrow> ('b \\<Rightarrow> ('a, 'm) optionT) \\<Rightarrow> ('a, 'm) optionT\"\n  where \"altc_sample_option altc_sample p f = OptionT (altc_sample p (\\<lambda>x. run_option (f x)))\""], ["", "lemma run_altc_sample_option [simp]: \"run_option (altc_sample_option altc_sample p f) = altc_sample p (\\<lambda>x. run_option (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.altc_sample_option altc_sample p f) =\n    altc_sample p (\\<lambda>x. run_option (f x))", "by(simp add: altc_sample_option_def)"], ["", "context\n  fixes sample :: \"('p, 'm) sample\"\nbegin"], ["", "abbreviation sample_option :: \"('p, ('a, 'm) optionT) sample\"\nwhere \"sample_option \\<equiv> altc_sample_option sample\""], ["", "lemma monad_prob_optionT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_option bind_option sample_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "interpret monad_prob return bind sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return bind sample", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "note sample_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_pmf ?R) (rel_fun (rel_fun ?R (=)) (=)) sample sample\n\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_option local.bind_option local.sample_option", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p m. local.sample_option p (\\<lambda>_. m) = m\n 2. \\<And>x f. local.sample_option (return_pmf x) f = f x\n 3. \\<And>p f g.\n       local.sample_option (p \\<bind> f) g =\n       local.sample_option p (\\<lambda>x. local.sample_option (f x) g)\n 4. \\<And>p q f.\n       local.sample_option p (\\<lambda>x. local.sample_option q (f x)) =\n       local.sample_option q\n        (\\<lambda>y. local.sample_option p (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       local.bind_option (local.sample_option p f) g =\n       local.sample_option p (\\<lambda>x. local.bind_option (f x) g)\n 6. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"sample_option p (\\<lambda>_. x) = x\" for p x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_option p (\\<lambda>_. x) = x", "by(rule optionT.expand)(simp add: sample_const)"], ["proof (state)\nthis:\n  local.sample_option ?p2 (\\<lambda>_. ?x2) = ?x2\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.sample_option (return_pmf x) f = f x\n 2. \\<And>p f g.\n       local.sample_option (p \\<bind> f) g =\n       local.sample_option p (\\<lambda>x. local.sample_option (f x) g)\n 3. \\<And>p q f.\n       local.sample_option p (\\<lambda>x. local.sample_option q (f x)) =\n       local.sample_option q\n        (\\<lambda>y. local.sample_option p (\\<lambda>x. f x y))\n 4. \\<And>p f g.\n       local.bind_option (local.sample_option p f) g =\n       local.sample_option p (\\<lambda>x. local.bind_option (f x) g)\n 5. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"sample_option (return_pmf x) f = f x\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_option (return_pmf x) f = f x", "by(rule optionT.expand)(simp add: sample_return_pmf)"], ["proof (state)\nthis:\n  local.sample_option (return_pmf ?x2) ?f2 = ?f2 ?x2\n\ngoal (5 subgoals):\n 1. \\<And>p f g.\n       local.sample_option (p \\<bind> f) g =\n       local.sample_option p (\\<lambda>x. local.sample_option (f x) g)\n 2. \\<And>p q f.\n       local.sample_option p (\\<lambda>x. local.sample_option q (f x)) =\n       local.sample_option q\n        (\\<lambda>y. local.sample_option p (\\<lambda>x. f x y))\n 3. \\<And>p f g.\n       local.bind_option (local.sample_option p f) g =\n       local.sample_option p (\\<lambda>x. local.bind_option (f x) g)\n 4. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"sample_option (bind_pmf p f) g = sample_option p (\\<lambda>x. sample_option (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_option (p \\<bind> f) g =\n    local.sample_option p (\\<lambda>x. local.sample_option (f x) g)", "by(rule optionT.expand)(simp add: sample_bind_pmf)"], ["proof (state)\nthis:\n  local.sample_option (?p2 \\<bind> ?f2) ?g2 =\n  local.sample_option ?p2 (\\<lambda>x. local.sample_option (?f2 x) ?g2)\n\ngoal (4 subgoals):\n 1. \\<And>p q f.\n       local.sample_option p (\\<lambda>x. local.sample_option q (f x)) =\n       local.sample_option q\n        (\\<lambda>y. local.sample_option p (\\<lambda>x. f x y))\n 2. \\<And>p f g.\n       local.bind_option (local.sample_option p f) g =\n       local.sample_option p (\\<lambda>x. local.bind_option (f x) g)\n 3. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"sample_option p (\\<lambda>x. sample_option q (f x)) = sample_option q (\\<lambda>y. sample_option p (\\<lambda>x. f x y))\" for p q f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_option p (\\<lambda>x. local.sample_option q (f x)) =\n    local.sample_option q\n     (\\<lambda>y. local.sample_option p (\\<lambda>x. f x y))", "by(rule optionT.expand)(auto intro!: sample_commute)"], ["proof (state)\nthis:\n  local.sample_option ?p2 (\\<lambda>x. local.sample_option ?q2 (?f2 x)) =\n  local.sample_option ?q2\n   (\\<lambda>y. local.sample_option ?p2 (\\<lambda>x. ?f2 x y))\n\ngoal (3 subgoals):\n 1. \\<And>p f g.\n       local.bind_option (local.sample_option p f) g =\n       local.sample_option p (\\<lambda>x. local.bind_option (f x) g)\n 2. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"bind_option (sample_option p f) g = sample_option p (\\<lambda>x. bind_option (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.sample_option p f) g =\n    local.sample_option p (\\<lambda>x. local.bind_option (f x) g)", "by(rule optionT.expand)(auto simp add: bind_sample1 run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.sample_option ?p2 ?f2) ?g2 =\n  local.sample_option ?p2 (\\<lambda>x. local.bind_option (?f2 x) ?g2)\n\ngoal (2 subgoals):\n 1. \\<And>m f p.\n       local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n       local.sample_option p\n        (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show \"bind_option m (\\<lambda>y. sample_option p (f y)) = sample_option p (\\<lambda>x. bind_option m (\\<lambda>y. f y x))\" for m p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option m (\\<lambda>y. local.sample_option p (f y)) =\n    local.sample_option p\n     (\\<lambda>x. local.bind_option m (\\<lambda>y. f y x))", "by(rule optionT.expand)(auto simp add: bind_sample2[symmetric] run_bind_option sample_const del: ext intro!: arg_cong2[where f=bind] ext split: option.split)"], ["proof (state)\nthis:\n  local.bind_option ?m2 (\\<lambda>y. local.sample_option ?p2 (?f2 y)) =\n  local.sample_option ?p2\n   (\\<lambda>x. local.bind_option ?m2 (\\<lambda>y. ?f2 y x))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n        local.sample_option", "show  \"(rel_pmf R ===> (R ===> (=)) ===> (=)) sample_option sample_option\" \n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_option\n     local.sample_option", "unfolding altc_sample_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f. OptionT (sample p (\\<lambda>x. run_option (f x))))\n     (\\<lambda>p f. OptionT (sample p (\\<lambda>x. run_option (f x))))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R2 \\<Longrightarrow>\n  (rel_pmf ?R2 ===> (?R2 ===> (=)) ===> (=)) local.sample_option\n   local.sample_option\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_prob local.return_option local.bind_option local.sample_option\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_prob_optionT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_option bind_option get_option put_option sample_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_option local.bind_option local.get_option\n     local.put_option local.sample_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_option local.bind_option local.get_option\n     local.put_option local.sample_option", "interpret monad_state_prob return bind get put sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob return bind get put sample", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_option local.bind_option local.get_option\n     local.put_option local.sample_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_option local.bind_option local.get_option\n     local.put_option local.sample_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f.\n       local.sample_option p (\\<lambda>x. local.get_option (f x)) =\n       local.get_option\n        (\\<lambda>s. local.sample_option p (\\<lambda>x. f x s))", "show \"sample_option p (\\<lambda>x. get_option (f x)) = get_option (\\<lambda>s. sample_option p (\\<lambda>x. f x s))\" for p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_option p (\\<lambda>x. local.get_option (f x)) =\n    local.get_option (\\<lambda>s. local.sample_option p (\\<lambda>x. f x s))", "by(rule optionT.expand)(simp add: sample_get)"], ["proof (state)\nthis:\n  local.sample_option ?p2 (\\<lambda>x. local.get_option (?f2 x)) =\n  local.get_option\n   (\\<lambda>s. local.sample_option ?p2 (\\<lambda>x. ?f2 x s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_prob local.return_option local.bind_option local.get_option\n   local.put_option local.sample_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Writer\\<close>"], ["", "context\n  fixes tell :: \"('w, 'm) tell\"\nbegin"], ["", "definition tell_option :: \"('w, ('a, 'm) optionT) tell\" \nwhere \"tell_option w m = OptionT (tell w (run_option m))\""], ["", "lemma run_tell_option [simp]: \"run_option (tell_option w m) = tell w (run_option m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.tell_option w m) = tell w (run_option m)", "by(simp add: tell_option_def)"], ["", "lemma monad_writer_optionT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_option bind_option tell_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_option local.bind_option local.tell_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_option local.bind_option local.tell_option", "interpret monad_writer return bind tell"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer return bind tell", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_option local.bind_option local.tell_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_option local.bind_option local.tell_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w m f.\n       local.bind_option (local.tell_option w m) f =\n       local.tell_option w (local.bind_option m f)", "show \"bind_option (tell_option w m) f = tell_option w (bind_option m f)\" for w m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.tell_option w m) f =\n    local.tell_option w (local.bind_option m f)", "by(rule optionT.expand)(simp add: run_bind_option bind_tell)"], ["proof (state)\nthis:\n  local.bind_option (local.tell_option ?w3 ?m3) ?f3 =\n  local.tell_option ?w3 (local.bind_option ?m3 ?f3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_writer local.return_option local.bind_option local.tell_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Binary Non-determinism\\<close>"], ["", "context\n  fixes alt :: \"'m alt\"\nbegin"], ["", "definition alt_option :: \"('a, 'm) optionT alt\"\nwhere \"alt_option m1 m2 = OptionT (alt (run_option m1) (run_option m2))\""], ["", "lemma run_alt_option [simp]: \"run_option (alt_option m1 m2) = alt (run_option m1) (run_option m2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.alt_option m1 m2) =\n    alt (run_option m1) (run_option m2)", "by(simp add: alt_option_def)"], ["", "lemma monad_alt_optionT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_option bind_option alt_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_option local.bind_option local.alt_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_option local.bind_option local.alt_option", "interpret monad_alt return bind alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return bind alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_option local.bind_option local.alt_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_option local.bind_option local.alt_option", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3.\n       local.alt_option (local.alt_option m1 m2) m3 =\n       local.alt_option m1 (local.alt_option m2 m3)\n 2. \\<And>m m' f.\n       local.bind_option (local.alt_option m m') f =\n       local.alt_option (local.bind_option m f) (local.bind_option m' f)", "show \"alt_option (alt_option m1 m2) m3 = alt_option m1 (alt_option m2 m3)\" for m1 m2 m3"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_option (local.alt_option m1 m2) m3 =\n    local.alt_option m1 (local.alt_option m2 m3)", "by(rule optionT.expand)(simp add: alt_assoc)"], ["proof (state)\nthis:\n  local.alt_option (local.alt_option ?m1.4 ?m2.4) ?m3.4 =\n  local.alt_option ?m1.4 (local.alt_option ?m2.4 ?m3.4)\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option (local.alt_option m m') f =\n       local.alt_option (local.bind_option m f) (local.bind_option m' f)", "show \"bind_option (alt_option m m') f = alt_option (bind_option m f) (bind_option m' f)\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.alt_option m m') f =\n    local.alt_option (local.bind_option m f) (local.bind_option m' f)", "by(rule optionT.expand)(simp add: bind_alt1 run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.alt_option ?m4 ?m'4) ?f4 =\n  local.alt_option (local.bind_option ?m4 ?f4) (local.bind_option ?m'4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_alt local.return_option local.bind_option local.alt_option\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The @{term fail} of @{typ \"(_, _) optionT\"} does not combine with @{term \"alt\"} of the inner monad\n  because @{typ \"(_, _) optionT\"} injects failures with @{term \"return None\"} into the inner monad.\n\\<close>"], ["", "lemma monad_state_alt_optionT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_option bind_option get_option put_option alt_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_option local.bind_option local.get_option\n     local.put_option local.alt_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_option local.bind_option local.get_option\n     local.put_option local.alt_option", "interpret monad_state_alt return bind get put alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt return bind get put alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_option local.bind_option local.get_option\n     local.put_option local.alt_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_option local.bind_option local.get_option\n     local.put_option local.alt_option", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.alt_option (local.get_option f) (local.get_option g) =\n       local.get_option (\\<lambda>x. local.alt_option (f x) (g x))\n 2. \\<And>s m m'.\n       local.alt_option (local.put_option s m) (local.put_option s m') =\n       local.put_option s (local.alt_option m m')", "show \"alt_option (get_option f) (get_option g) = get_option (\\<lambda>x. alt_option (f x) (g x))\"\n      for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_option (local.get_option f) (local.get_option g) =\n    local.get_option (\\<lambda>x. local.alt_option (f x) (g x))", "by(rule optionT.expand)(simp add: alt_get)"], ["proof (state)\nthis:\n  local.alt_option (local.get_option ?f4) (local.get_option ?g4) =\n  local.get_option (\\<lambda>x. local.alt_option (?f4 x) (?g4 x))\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       local.alt_option (local.put_option s m) (local.put_option s m') =\n       local.put_option s (local.alt_option m m')", "show \"alt_option (put_option s m) (put_option s m') = put_option s (alt_option m m')\"\n      for s m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_option (local.put_option s m) (local.put_option s m') =\n    local.put_option s (local.alt_option m m')", "by(rule optionT.expand)(simp add: alt_put)"], ["proof (state)\nthis:\n  local.alt_option (local.put_option ?s4 ?m4) (local.put_option ?s4 ?m'4) =\n  local.put_option ?s4 (local.alt_option ?m4 ?m'4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_alt local.return_option local.bind_option local.get_option\n   local.put_option local.alt_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Countable Non-determinism\\<close>"], ["", "context\n  fixes altc :: \"('c, 'm) altc\"\nbegin"], ["", "abbreviation altc_option :: \"('c, ('a, 'm) optionT) altc\"\nwhere \"altc_option \\<equiv> altc_sample_option altc\""], ["", "lemma monad_altc_optionT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_option bind_option altc_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "interpret monad_altc return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "note altc_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_cset ?R) (rel_fun (rel_fun ?R (=)) (=)) altc altc\n\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_option local.bind_option local.altc_option", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       local.bind_option (local.altc_option C g) f =\n       local.altc_option C (\\<lambda>c. local.bind_option (g c) f)\n 2. \\<And>x f. local.altc_option (csingle x) f = f x\n 3. \\<And>C f g.\n       local.altc_option (cUnion (cimage f C)) g =\n       local.altc_option C (\\<lambda>x. local.altc_option (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_option\n        local.altc_option", "show \"bind_option (altc_option C g) f = altc_option C (\\<lambda>c. bind_option (g c) f)\" for C g f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.altc_option C g) f =\n    local.altc_option C (\\<lambda>c. local.bind_option (g c) f)", "by(rule optionT.expand)(simp add: run_bind_option bind_altc1 o_def)"], ["proof (state)\nthis:\n  local.bind_option (local.altc_option ?C4 ?g4) ?f4 =\n  local.altc_option ?C4 (\\<lambda>c. local.bind_option (?g4 c) ?f4)\n\ngoal (3 subgoals):\n 1. \\<And>x f. local.altc_option (csingle x) f = f x\n 2. \\<And>C f g.\n       local.altc_option (cUnion (cimage f C)) g =\n       local.altc_option C (\\<lambda>x. local.altc_option (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_option\n        local.altc_option", "show \"altc_option (csingle x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_option (csingle x) f = f x", "by(rule optionT.expand)(simp add: bind_altc1 altc_single)"], ["proof (state)\nthis:\n  local.altc_option (csingle ?x4) ?f4 = ?f4 ?x4\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       local.altc_option (cUnion (cimage f C)) g =\n       local.altc_option C (\\<lambda>x. local.altc_option (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_option\n        local.altc_option", "show \"altc_option (cUNION C f) g = altc_option C (\\<lambda>x. altc_option (f x) g)\" for C f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_option (cUnion (cimage f C)) g =\n    local.altc_option C (\\<lambda>x. local.altc_option (f x) g)", "by(rule optionT.expand)(simp add: bind_altc1 altc_cUNION o_def)"], ["proof (state)\nthis:\n  local.altc_option (cUnion (cimage ?f4 ?C4)) ?g4 =\n  local.altc_option ?C4 (\\<lambda>x. local.altc_option (?f4 x) ?g4)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_option\n        local.altc_option", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) altc_option altc_option\"\n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_option\n     local.altc_option", "unfolding altc_sample_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f. OptionT (altc p (\\<lambda>x. run_option (f x))))\n     (\\<lambda>p f. OptionT (altc p (\\<lambda>x. run_option (f x))))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R4 \\<Longrightarrow>\n  (rel_cset ?R4 ===> (?R4 ===> (=)) ===> (=)) local.altc_option\n   local.altc_option\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_altc local.return_option local.bind_option local.altc_option\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_altc3_optionT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_option bind_option altc_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_option local.bind_option local.altc_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_option local.bind_option local.altc_option", "interpret monad_altc3 return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_option local.bind_option local.altc_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_option local.bind_option local.altc_option", ".."], ["proof (state)\nthis:\n  monad_altc3 local.return_option local.bind_option local.altc_option\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_altc_optionT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_option bind_option get_option put_option altc_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_option local.bind_option local.get_option\n     local.put_option local.altc_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_option local.bind_option local.get_option\n     local.put_option local.altc_option", "interpret monad_state_altc return bind get put altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc return bind get put altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_option local.bind_option local.get_option\n     local.put_option local.altc_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_option local.bind_option local.get_option\n     local.put_option local.altc_option", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C f.\n       local.altc_option C (\\<lambda>c. local.get_option (f c)) =\n       local.get_option\n        (\\<lambda>s. local.altc_option C (\\<lambda>c. f c s))\n 2. \\<And>s C f.\n       local.altc_option C (\\<lambda>c. local.put_option s (f c)) =\n       local.put_option s (local.altc_option C f)", "show \"altc_option C (\\<lambda>c. get_option (f c)) = get_option (\\<lambda>s. altc_option C (\\<lambda>c. f c s))\"\n      for C f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_option C (\\<lambda>c. local.get_option (f c)) =\n    local.get_option (\\<lambda>s. local.altc_option C (\\<lambda>c. f c s))", "by(rule optionT.expand)(simp add: o_def altc_get)"], ["proof (state)\nthis:\n  local.altc_option ?C4 (\\<lambda>c. local.get_option (?f4 c)) =\n  local.get_option (\\<lambda>s. local.altc_option ?C4 (\\<lambda>c. ?f4 c s))\n\ngoal (1 subgoal):\n 1. \\<And>s C f.\n       local.altc_option C (\\<lambda>c. local.put_option s (f c)) =\n       local.put_option s (local.altc_option C f)", "show \"altc_option C (\\<lambda>c. put_option s (f c)) = put_option s (altc_option C f)\"\n      for C s f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_option C (\\<lambda>c. local.put_option s (f c)) =\n    local.put_option s (local.altc_option C f)", "by(rule optionT.expand)(simp add: o_def altc_put)"], ["proof (state)\nthis:\n  local.altc_option ?C4 (\\<lambda>c. local.put_option ?s4 (?f4 c)) =\n  local.put_option ?s4 (local.altc_option ?C4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_altc local.return_option local.bind_option local.get_option\n   local.put_option local.altc_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Resumption\\<close>"], ["", "context\n  fixes pause :: \"('o, 'i, 'm) pause\"\nbegin"], ["", "definition pause_option :: \"('o, 'i, ('a, 'm) optionT) pause\"\nwhere \"pause_option out c = OptionT (pause out (\\<lambda>i. run_option (c i)))\""], ["", "lemma run_pause_option [simp]: \"run_option (pause_option out c) = pause out (\\<lambda>i. run_option (c i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option (local.pause_option out c) =\n    pause out (\\<lambda>i. run_option (c i))", "by(simp add: pause_option_def)"], ["", "lemma monad_resumption_optionT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_option bind_option pause_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_option local.bind_option\n     local.pause_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_option local.bind_option\n     local.pause_option", "interpret monad_resumption return bind pause"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption return bind pause", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_option local.bind_option\n     local.pause_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_option local.bind_option\n     local.pause_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c f.\n       local.bind_option (local.pause_option out c) f =\n       local.pause_option out (\\<lambda>i. local.bind_option (c i) f)", "show \"bind_option (pause_option out c) f = pause_option out (\\<lambda>i. bind_option (c i) f)\" for out c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_option (local.pause_option out c) f =\n    local.pause_option out (\\<lambda>i. local.bind_option (c i) f)", "by(rule optionT.expand)(simp add: bind_pause run_bind_option)"], ["proof (state)\nthis:\n  local.bind_option (local.pause_option ?out7 ?c7) ?f7 =\n  local.pause_option ?out7 (\\<lambda>i. local.bind_option (?c7 i) ?f7)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_resumption local.return_option local.bind_option local.pause_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Commutativity\\<close>"], ["", "lemma monad_commute_optionT [locale_witness]:\n  assumes \"monad_commute return bind\"\n  and \"monad_discard return bind\"\n  shows \"monad_commute return_option bind_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute local.return_option local.bind_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_commute local.return_option local.bind_option", "interpret monad_commute return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_commute local.return_option local.bind_option", "interpret monad_discard return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_commute local.return_option local.bind_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute local.return_option local.bind_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "fix m m' f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "have \"run_option (bind_option m (\\<lambda>x. bind_option m' (f x))) = \n      bind (run_option m) (\\<lambda>x. bind (run_option m') (\\<lambda>y. case (x, y) of (Some x', Some y') \\<Rightarrow> run_option (f x' y') | _ \\<Rightarrow> return None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option\n     (local.bind_option m (\\<lambda>x. local.bind_option m' (f x))) =\n    bind (run_option m)\n     (\\<lambda>x.\n         bind (run_option m')\n          (\\<lambda>y.\n              case (x, y) of (None, b) \\<Rightarrow> return None\n              | (Some x', None) \\<Rightarrow> return None\n              | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))", "by(auto simp add: run_bind_option bind_const cong del: option.case_cong del: ext intro!: arg_cong2[where f=bind] ext split: option.split)"], ["proof (state)\nthis:\n  run_option\n   (local.bind_option m (\\<lambda>x. local.bind_option m' (f x))) =\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m')\n        (\\<lambda>y.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "also"], ["proof (state)\nthis:\n  run_option\n   (local.bind_option m (\\<lambda>x. local.bind_option m' (f x))) =\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m')\n        (\\<lambda>y.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "have \"\\<dots> = bind (run_option m') (\\<lambda>y. bind (run_option m) (\\<lambda>x. case (x, y) of (Some x', Some y') \\<Rightarrow> run_option (f x' y') | _ \\<Rightarrow> return None))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_option m)\n     (\\<lambda>x.\n         bind (run_option m')\n          (\\<lambda>y.\n              case (x, y) of (None, b) \\<Rightarrow> return None\n              | (Some x', None) \\<Rightarrow> return None\n              | (Some x', Some y') \\<Rightarrow> run_option (f x' y'))) =\n    bind (run_option m')\n     (\\<lambda>y.\n         bind (run_option m)\n          (\\<lambda>x.\n              case (x, y) of (None, b) \\<Rightarrow> return None\n              | (Some x', None) \\<Rightarrow> return None\n              | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))", "by(rule bind_commute)"], ["proof (state)\nthis:\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m')\n        (\\<lambda>y.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y'))) =\n  bind (run_option m')\n   (\\<lambda>y.\n       bind (run_option m)\n        (\\<lambda>x.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "also"], ["proof (state)\nthis:\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m')\n        (\\<lambda>y.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y'))) =\n  bind (run_option m')\n   (\\<lambda>y.\n       bind (run_option m)\n        (\\<lambda>x.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "have \"\\<dots> = run_option (bind_option m' (\\<lambda>y. bind_option m (\\<lambda>x. f x y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_option m')\n     (\\<lambda>y.\n         bind (run_option m)\n          (\\<lambda>x.\n              case (x, y) of (None, b) \\<Rightarrow> return None\n              | (Some x', None) \\<Rightarrow> return None\n              | (Some x', Some y') \\<Rightarrow> run_option (f x' y'))) =\n    run_option\n     (local.bind_option m'\n       (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y)))", "by(auto simp add: run_bind_option bind_const case_option_collapse cong del: option.case_cong del: ext intro!: arg_cong2[where f=bind] ext split: option.split)"], ["proof (state)\nthis:\n  bind (run_option m')\n   (\\<lambda>y.\n       bind (run_option m)\n        (\\<lambda>x.\n            case (x, y) of (None, b) \\<Rightarrow> return None\n            | (Some x', None) \\<Rightarrow> return None\n            | (Some x', Some y') \\<Rightarrow> run_option (f x' y'))) =\n  run_option\n   (local.bind_option m'\n     (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y)))\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n       local.bind_option m'\n        (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "finally"], ["proof (chain)\npicking this:\n  run_option\n   (local.bind_option m (\\<lambda>x. local.bind_option m' (f x))) =\n  run_option\n   (local.bind_option m'\n     (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y)))", "show \"bind_option m (\\<lambda>x. bind_option m' (f x)) = bind_option m' (\\<lambda>y. bind_option m (\\<lambda>x. f x y))\""], ["proof (prove)\nusing this:\n  run_option\n   (local.bind_option m (\\<lambda>x. local.bind_option m' (f x))) =\n  run_option\n   (local.bind_option m'\n     (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y)))\n\ngoal (1 subgoal):\n 1. local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n    local.bind_option m'\n     (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))", "by(rule optionT.expand)"], ["proof (state)\nthis:\n  local.bind_option m (\\<lambda>x. local.bind_option m' (f x)) =\n  local.bind_option m' (\\<lambda>y. local.bind_option m (\\<lambda>x. f x y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_commute local.return_option local.bind_option\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Duplicability\\<close>"], ["", "lemma monad_duplicate_optionT [locale_witness]:\n  assumes \"monad_duplicate return bind\"\n    and \"monad_discard return bind\"\n  shows \"monad_duplicate return_option bind_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_option local.bind_option", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_option local.bind_option", "interpret monad_duplicate return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_option local.bind_option", "interpret monad_discard return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_option local.bind_option", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_option local.bind_option", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n       local.bind_option m (\\<lambda>x. f x x)", "fix m f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n       local.bind_option m (\\<lambda>x. f x x)", "have \"run_option (bind_option m (\\<lambda>x. bind_option m (f x))) =\n          bind (run_option m) (\\<lambda>x. bind (run_option m) (\\<lambda>y. case x of None \\<Rightarrow> return None | Some x' \\<Rightarrow> (case y of None \\<Rightarrow> return None | Some y' \\<Rightarrow> run_option (f x' y'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_option\n     (local.bind_option m (\\<lambda>x. local.bind_option m (f x))) =\n    bind (run_option m)\n     (\\<lambda>x.\n         bind (run_option m)\n          (\\<lambda>y.\n              case x of None \\<Rightarrow> return None\n              | Some x' \\<Rightarrow>\n                  case y of None \\<Rightarrow> return None\n                  | Some y' \\<Rightarrow> run_option (f x' y')))", "by(auto intro!: arg_cong2[where f=bind] simp add: fun_eq_iff bind_const run_bind_option split: option.split)"], ["proof (state)\nthis:\n  run_option (local.bind_option m (\\<lambda>x. local.bind_option m (f x))) =\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m)\n        (\\<lambda>y.\n            case x of None \\<Rightarrow> return None\n            | Some x' \\<Rightarrow>\n                case y of None \\<Rightarrow> return None\n                | Some y' \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n       local.bind_option m (\\<lambda>x. f x x)", "also"], ["proof (state)\nthis:\n  run_option (local.bind_option m (\\<lambda>x. local.bind_option m (f x))) =\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m)\n        (\\<lambda>y.\n            case x of None \\<Rightarrow> return None\n            | Some x' \\<Rightarrow>\n                case y of None \\<Rightarrow> return None\n                | Some y' \\<Rightarrow> run_option (f x' y')))\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n       local.bind_option m (\\<lambda>x. f x x)", "have \"\\<dots> = run_option (bind_option m (\\<lambda>x. f x x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_option m)\n     (\\<lambda>x.\n         bind (run_option m)\n          (\\<lambda>y.\n              case x of None \\<Rightarrow> return None\n              | Some x' \\<Rightarrow>\n                  case y of None \\<Rightarrow> return None\n                  | Some y' \\<Rightarrow> run_option (f x' y'))) =\n    run_option (local.bind_option m (\\<lambda>x. f x x))", "by(simp add: bind_duplicate run_bind_option cong: option.case_cong)"], ["proof (state)\nthis:\n  bind (run_option m)\n   (\\<lambda>x.\n       bind (run_option m)\n        (\\<lambda>y.\n            case x of None \\<Rightarrow> return None\n            | Some x' \\<Rightarrow>\n                case y of None \\<Rightarrow> return None\n                | Some y' \\<Rightarrow> run_option (f x' y'))) =\n  run_option (local.bind_option m (\\<lambda>x. f x x))\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n       local.bind_option m (\\<lambda>x. f x x)", "finally"], ["proof (chain)\npicking this:\n  run_option (local.bind_option m (\\<lambda>x. local.bind_option m (f x))) =\n  run_option (local.bind_option m (\\<lambda>x. f x x))", "show \"bind_option m (\\<lambda>x. bind_option m (f x)) = bind_option m (\\<lambda>x. f x x)\""], ["proof (prove)\nusing this:\n  run_option (local.bind_option m (\\<lambda>x. local.bind_option m (f x))) =\n  run_option (local.bind_option m (\\<lambda>x. f x x))\n\ngoal (1 subgoal):\n 1. local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n    local.bind_option m (\\<lambda>x. f x x)", "by(rule optionT.expand)"], ["proof (state)\nthis:\n  local.bind_option m (\\<lambda>x. local.bind_option m (f x)) =\n  local.bind_option m (\\<lambda>x. f x x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_duplicate local.return_option local.bind_option\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Parametricity\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma return_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> A ===> rel_optionT M) return_option return_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===> A ===> rel_optionT M) return_option\n     return_option", "unfolding return_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===> A ===> rel_optionT M)\n     (\\<lambda>return x. OptionT (return (Some x)))\n     (\\<lambda>return x. OptionT (return (Some x)))", "by transfer_prover"], ["", "lemma bind_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> (M ===> (rel_option A ===> M) ===> M)\n   ===> rel_optionT M ===> (A ===> rel_optionT M) ===> rel_optionT M)\n   bind_option bind_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===>\n     (M ===> (rel_option A ===> M) ===> M) ===>\n     rel_optionT M ===> (A ===> rel_optionT M) ===> rel_optionT M)\n     bind_option bind_option", "unfolding bind_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===>\n     (M ===> (rel_option A ===> M) ===> M) ===>\n     rel_optionT M ===> (A ===> rel_optionT M) ===> rel_optionT M)\n     (\\<lambda>return bind.\n         rec_optionT\n          (\\<lambda>x f.\n              OptionT\n               (bind x\n                 (\\<lambda>x.\n                     case x of None \\<Rightarrow> return None\n                     | Some y \\<Rightarrow> run_option (f y)))))\n     (\\<lambda>return bind.\n         rec_optionT\n          (\\<lambda>x f.\n              OptionT\n               (bind x\n                 (\\<lambda>x.\n                     case x of None \\<Rightarrow> return None\n                     | Some y \\<Rightarrow> run_option (f y)))))", "by transfer_prover"], ["", "lemma fail_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> rel_optionT M) fail_option fail_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===> rel_optionT M) fail_option fail_option", "unfolding fail_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===> rel_optionT M)\n     (\\<lambda>return. OptionT (return None))\n     (\\<lambda>return. OptionT (return None))", "by transfer_prover"], ["", "lemma catch_option_parametric [transfer_rule]:\n  \"((rel_option A ===> M) ===> (M ===> (rel_option A ===> M) ===> M)\n   ===> rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n  catch_option catch_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===>\n     (M ===> (rel_option A ===> M) ===> M) ===>\n     rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n     catch_option catch_option", "unfolding catch_option_def Option.is_none_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_option A ===> M) ===>\n     (M ===> (rel_option A ===> M) ===> M) ===>\n     rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n     (\\<lambda>return bind m h.\n         OptionT\n          (bind (run_option m)\n            (\\<lambda>x.\n                if Option.is_none x then run_option h else return x)))\n     (\\<lambda>return bind m h.\n         OptionT\n          (bind (run_option m)\n            (\\<lambda>x.\n                if Option.is_none x then run_option h else return x)))", "by transfer_prover"], ["", "lemma ask_option_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_optionT M) ===> rel_optionT M) ask_option ask_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_optionT M) ===> rel_optionT M)\n     ask_option ask_option", "unfolding ask_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_optionT M) ===> rel_optionT M)\n     (\\<lambda>ask f. OptionT (ask (\\<lambda>r. run_option (f r))))\n     (\\<lambda>ask f. OptionT (ask (\\<lambda>r. run_option (f r))))", "by transfer_prover"], ["", "lemma get_option_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_optionT M) ===> rel_optionT M) get_option get_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===> (S ===> rel_optionT M) ===> rel_optionT M)\n     get_option get_option", "unfolding get_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===> (S ===> rel_optionT M) ===> rel_optionT M)\n     (\\<lambda>get f. OptionT (get (\\<lambda>s. run_option (f s))))\n     (\\<lambda>get f. OptionT (get (\\<lambda>s. run_option (f s))))", "by transfer_prover"], ["", "lemma put_option_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_optionT M ===> rel_optionT M) put_option put_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_optionT M ===> rel_optionT M)\n     put_option put_option", "unfolding put_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_optionT M ===> rel_optionT M)\n     (\\<lambda>put uu uua.\n         rec_optionT (\\<lambda>m s. OptionT (put s m)) uua uu)\n     (\\<lambda>put uu uua.\n         rec_optionT (\\<lambda>m s. OptionT (put s m)) uua uu)", "by transfer_prover"], ["", "lemma altc_sample_option_parametric [transfer_rule]:\n  \"((A ===> (P ===> M) ===> M) ===> A ===> (P ===> rel_optionT M) ===> rel_optionT M)\n   altc_sample_option altc_sample_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (P ===> M) ===> M) ===>\n     A ===> (P ===> rel_optionT M) ===> rel_optionT M)\n     altc_sample_option altc_sample_option", "unfolding altc_sample_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> (P ===> M) ===> M) ===>\n     A ===> (P ===> rel_optionT M) ===> rel_optionT M)\n     (\\<lambda>altc_sample p f.\n         OptionT (altc_sample p (\\<lambda>x. run_option (f x))))\n     (\\<lambda>altc_sample p f.\n         OptionT (altc_sample p (\\<lambda>x. run_option (f x))))", "by transfer_prover"], ["", "lemma alt_option_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_optionT M ===> rel_optionT M ===> rel_optionT M) alt_option alt_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n     alt_option alt_option", "unfolding alt_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_optionT M ===> rel_optionT M ===> rel_optionT M)\n     (\\<lambda>alt m1 m2. OptionT (alt (run_option m1) (run_option m2)))\n     (\\<lambda>alt m1 m2. OptionT (alt (run_option m1) (run_option m2)))", "by transfer_prover"], ["", "lemma tell_option_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_optionT M ===> rel_optionT M) tell_option tell_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===> W ===> rel_optionT M ===> rel_optionT M)\n     tell_option tell_option", "unfolding tell_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===> W ===> rel_optionT M ===> rel_optionT M)\n     (\\<lambda>tell w m. OptionT (tell w (run_option m)))\n     (\\<lambda>tell w m. OptionT (tell w (run_option m)))", "by transfer_prover"], ["", "lemma pause_option_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_optionT M) ===> rel_optionT M)\n   pause_option pause_option\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_optionT M) ===> rel_optionT M)\n     pause_option pause_option", "unfolding pause_option_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_optionT M) ===> rel_optionT M)\n     (\\<lambda>pause out c.\n         OptionT (pause out (\\<lambda>i. run_option (c i))))\n     (\\<lambda>pause out c.\n         OptionT (pause out (\\<lambda>i. run_option (c i))))", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Reader monad transformer\\<close>"], ["", "datatype ('r, 'm) envT = EnvT (run_env: \"'r \\<Rightarrow> 'm\")"], ["", "context includes lifting_syntax begin"], ["", "definition rel_envT :: \"('r \\<Rightarrow> 'r' \\<Rightarrow> bool) \\<Rightarrow> ('m \\<Rightarrow> 'm' \\<Rightarrow> bool) \\<Rightarrow> ('r, 'm) envT \\<Rightarrow> ('r', 'm') envT \\<Rightarrow> bool\"\nwhere \"rel_envT R M = BNF_Def.vimage2p run_env run_env (R ===> M)\""], ["", "lemma rel_envTI [intro!]: \"(R ===> M) f g \\<Longrightarrow> rel_envT R M (EnvT f) (EnvT g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (R ===> M) f g \\<Longrightarrow> local.rel_envT R M (EnvT f) (EnvT g)", "by(simp add: rel_envT_def BNF_Def.vimage2p_def)"], ["", "lemma rel_envT_simps: \"rel_envT R M (EnvT f) (EnvT g) \\<longleftrightarrow> (R ===> M) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_envT R M (EnvT f) (EnvT g) = (R ===> M) f g", "by(simp add: rel_envT_def BNF_Def.vimage2p_def)"], ["", "lemma rel_envTE [cases pred]:\n  assumes \"rel_envT R M m m'\"\n  obtains f g where \"m = EnvT f\" \"m' = EnvT g\" \"(R ===> M) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>m = EnvT f; m' = EnvT g; (R ===> M) f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  local.rel_envT R M m m'\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>m = EnvT f; m' = EnvT g; (R ===> M) f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m; cases m'; auto  simp add: rel_envT_simps)"], ["", "lemma rel_envT_eq [relator_eq]: \"rel_envT (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.rel_envT (=) (=) = (=)", "by(auto simp add: rel_envT_def rel_fun_eq BNF_Def.vimage2p_def fun_eq_iff intro: envT.expand)"], ["", "lemma rel_envT_mono [relator_mono]: \"\\<lbrakk> R \\<le> R'; M \\<le> M' \\<rbrakk> \\<Longrightarrow> rel_envT R' M \\<le> rel_envT R M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R \\<le> R'; M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> local.rel_envT R' M \\<le> local.rel_envT R M'", "by(simp add: rel_envT_def predicate2I vimage2p_mono fun_mono)"], ["", "lemma EnvT_parametric [transfer_rule]: \"((R ===> M) ===> rel_envT R M) EnvT EnvT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> M) ===> local.rel_envT R M) EnvT EnvT", "by(simp add: rel_funI rel_envT_simps)"], ["", "lemma run_env_parametric [transfer_rule]: \"(rel_envT R M ===> R ===> M) run_env run_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (local.rel_envT R M ===> R ===> M) run_env run_env", "by(auto elim!: rel_envTE)"], ["", "lemma rec_envT_parametric [transfer_rule]:\n  \"(((R ===> M) ===> X) ===> rel_envT R M ===> X) rec_envT rec_envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> X) ===> local.rel_envT R M ===> X) rec_envT rec_envT", "by(auto 4 4 elim!: rel_envTE dest: rel_funD)"], ["", "lemma case_envT_parametric [transfer_rule]:\n  \"(((R ===> M) ===> X) ===> rel_envT R M ===> X) case_envT case_envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> X) ===> local.rel_envT R M ===> X) case_envT case_envT", "by(auto 4 4 elim!: rel_envTE dest: rel_funD)"], ["", "end"], ["", "subsubsection \\<open>Plain monad and ask\\<close>"], ["", "context\n  fixes return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\nbegin"], ["", "definition return_env :: \"('a, ('r, 'm) envT) return\"\nwhere \"return_env x = EnvT (\\<lambda>_. return x)\""], ["", "primrec bind_env :: \"('a, ('r, 'm) envT) bind\"\nwhere \"bind_env (EnvT x) f = EnvT (\\<lambda>r. bind (x r) (\\<lambda>y. run_env (f y) r))\""], ["", "definition ask_env :: \"('r, ('r, 'm) envT) ask\"\nwhere \"ask_env f = EnvT (\\<lambda>r. run_env (f r) r)\""], ["", "lemma run_bind_env [simp]: \"run_env (bind_env x f) r = bind (run_env x r) (\\<lambda>y. run_env (f y) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.bind_env x f) r =\n    bind (run_env x r) (\\<lambda>y. run_env (f y) r)", "by(cases x) simp"], ["", "lemma run_return_env [simp]: \"run_env (return_env x) r = return x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.return_env x) r = return x", "by(simp add: return_env_def)"], ["", "lemma run_ask_env [simp]: \"run_env (ask_env f) r = run_env (f r) r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.ask_env f) r = run_env (f r) r", "by(simp add: ask_env_def)"], ["", "context\n  assumes monad: \"monad return bind\"\nbegin"], ["", "interpretation monad return \"bind :: ('a, 'm) bind\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return bind", "by(fact monad)"], ["", "lemma monad_envT [locale_witness]: \"monad return_env bind_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad local.return_env local.bind_env", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       local.bind_env (local.bind_env x f) g =\n       local.bind_env x (\\<lambda>y. local.bind_env (f y) g)\n 2. \\<And>x f. local.bind_env (local.return_env x) f = f x\n 3. \\<And>x. local.bind_env x local.return_env = x", "show \"bind_env (bind_env x f) g = bind_env x (\\<lambda>x. bind_env (f x) g)\" \n    for x :: \"('r, 'm) envT\" and f :: \"'a \\<Rightarrow> ('r, 'm) envT\" and g :: \"'a \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.bind_env x f) g =\n    local.bind_env x (\\<lambda>x. local.bind_env (f x) g)", "by(rule envT.expand)(auto simp add: bind_assoc return_bind)"], ["proof (state)\nthis:\n  local.bind_env (local.bind_env ?x4 ?f4) ?g4 =\n  local.bind_env ?x4 (\\<lambda>x. local.bind_env (?f4 x) ?g4)\n\ngoal (2 subgoals):\n 1. \\<And>x f. local.bind_env (local.return_env x) f = f x\n 2. \\<And>x. local.bind_env x local.return_env = x", "show \"bind_env (return_env x) f = f x\" for f :: \"'a \\<Rightarrow> ('r, 'm) envT\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.return_env x) f = f x", "by(rule envT.expand)(simp add: return_bind return_env_def)"], ["proof (state)\nthis:\n  local.bind_env (local.return_env ?x5) ?f5 = ?f5 ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x. local.bind_env x local.return_env = x", "show \"bind_env x (return_env :: ('a, ('r, 'm) envT) return) = x\" for x :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env x local.return_env = x", "by(rule envT.expand)(simp add: bind_return fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_env ?x6 local.return_env = ?x6\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_reader_envT [locale_witness]:\n  \"monad_reader return_env bind_env ask_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_env local.bind_env local.ask_env", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       local.ask_env (\\<lambda>r. local.ask_env (f r)) =\n       local.ask_env (\\<lambda>r. f r r)\n 2. \\<And>m. local.ask_env (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_env (local.ask_env f) g =\n       local.ask_env (\\<lambda>r. local.bind_env (f r) g)\n 4. \\<And>m f.\n       local.bind_env m (\\<lambda>x. local.ask_env (f x)) =\n       local.ask_env (\\<lambda>r. local.bind_env m (\\<lambda>x. f x r))", "show \"ask_env (\\<lambda>r. ask_env (f r)) = ask_env (\\<lambda>r. f r r)\" for f :: \"'r \\<Rightarrow> 'r \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_env (\\<lambda>r. local.ask_env (f r)) =\n    local.ask_env (\\<lambda>r. f r r)", "by(rule envT.expand)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.ask_env (\\<lambda>r. local.ask_env (?f4 r)) =\n  local.ask_env (\\<lambda>r. ?f4 r r)\n\ngoal (3 subgoals):\n 1. \\<And>m. local.ask_env (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_env (local.ask_env f) g =\n       local.ask_env (\\<lambda>r. local.bind_env (f r) g)\n 3. \\<And>m f.\n       local.bind_env m (\\<lambda>x. local.ask_env (f x)) =\n       local.ask_env (\\<lambda>r. local.bind_env m (\\<lambda>x. f x r))", "show \"ask_env (\\<lambda>_. x) = x\" for x :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_env (\\<lambda>_. x) = x", "by(rule envT.expand)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.ask_env (\\<lambda>_. ?x5) = ?x5\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_env (local.ask_env f) g =\n       local.ask_env (\\<lambda>r. local.bind_env (f r) g)\n 2. \\<And>m f.\n       local.bind_env m (\\<lambda>x. local.ask_env (f x)) =\n       local.ask_env (\\<lambda>r. local.bind_env m (\\<lambda>x. f x r))", "show \"bind_env (ask_env f) g = ask_env (\\<lambda>r. bind_env (f r) g)\" for f :: \"'r \\<Rightarrow> ('r, 'm) envT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.ask_env f) g =\n    local.ask_env (\\<lambda>r. local.bind_env (f r) g)", "by(rule envT.expand)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_env (local.ask_env ?f6) ?g6 =\n  local.ask_env (\\<lambda>r. local.bind_env (?f6 r) ?g6)\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_env m (\\<lambda>x. local.ask_env (f x)) =\n       local.ask_env (\\<lambda>r. local.bind_env m (\\<lambda>x. f x r))", "show \"bind_env m (\\<lambda>x. ask_env (f x)) = ask_env (\\<lambda>r. bind_env m (\\<lambda>x. f x r))\" for m :: \"('r, 'm) envT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env m (\\<lambda>x. local.ask_env (f x)) =\n    local.ask_env (\\<lambda>r. local.bind_env m (\\<lambda>x. f x r))", "by(rule envT.expand)(auto simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_env ?m7 (\\<lambda>x. local.ask_env (?f7 x)) =\n  local.ask_env (\\<lambda>r. local.bind_env ?m7 (\\<lambda>x. ?f7 x r))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Failure\\<close>"], ["", "context\n  fixes fail :: \"'m fail\"\nbegin"], ["", "definition fail_env :: \"('r, 'm) envT fail\"\nwhere \"fail_env = EnvT (\\<lambda>r. fail)\""], ["", "lemma run_fail_env [simp]: \"run_env fail_env r = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env local.fail_env r = fail", "by(simp add: fail_env_def)"], ["", "lemma monad_fail_envT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_env bind_env fail_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail local.return_env local.bind_env local.fail_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_env local.bind_env local.fail_env", "interpret monad_fail return bind fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return bind fail", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_env local.bind_env local.fail_env", "have \"bind_env fail_env f = fail_env\" for f :: \"'a \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env local.fail_env f = local.fail_env", "by(rule envT.expand)(simp add: fun_eq_iff fail_bind)"], ["proof (state)\nthis:\n  local.bind_env local.fail_env ?f5 = local.fail_env\n\ngoal (1 subgoal):\n 1. monad_fail local.return_env local.bind_env local.fail_env", "then"], ["proof (chain)\npicking this:\n  local.bind_env local.fail_env ?f5 = local.fail_env", "show ?thesis"], ["proof (prove)\nusing this:\n  local.bind_env local.fail_env ?f5 = local.fail_env\n\ngoal (1 subgoal):\n 1. monad_fail local.return_env local.bind_env local.fail_env", "by unfold_locales"], ["proof (state)\nthis:\n  monad_fail local.return_env local.bind_env local.fail_env\n\ngoal:\nNo subgoals!", "qed"], ["", "context\n  fixes catch :: \"'m catch\"\nbegin"], ["", "definition catch_env :: \"('r, 'm) envT catch\"\nwhere \"catch_env m1 m2 = EnvT (\\<lambda>r. catch (run_env m1 r) (run_env m2 r))\""], ["", "lemma run_catch_env [simp]: \"run_env (catch_env m1 m2) r = catch (run_env m1 r) (run_env m2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.catch_env m1 m2) r = catch (run_env m1 r) (run_env m2 r)", "by(simp add: catch_env_def)"], ["", "lemma monad_catch_envT [locale_witness]:\n  assumes \"monad_catch return bind fail catch\"\n  shows \"monad_catch return_env bind_env fail_env catch_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch local.return_env local.bind_env local.fail_env\n     local.catch_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_catch local.return_env local.bind_env local.fail_env\n     local.catch_env", "interpret monad_catch return bind fail catch"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch return bind fail catch", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_catch local.return_env local.bind_env local.fail_env\n     local.catch_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch local.return_env local.bind_env local.fail_env\n     local.catch_env", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x m. local.catch_env (local.return_env x) m = local.return_env x\n 2. \\<And>m. local.catch_env local.fail_env m = m\n 3. \\<And>m. local.catch_env m local.fail_env = m\n 4. \\<And>m m' m''.\n       local.catch_env (local.catch_env m m') m'' =\n       local.catch_env m (local.catch_env m' m'')", "show \"catch_env (return_env x) m = return_env x\" for x and m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_env (local.return_env x) m = local.return_env x", "by(rule envT.expand)(simp add: fun_eq_iff catch_return)"], ["proof (state)\nthis:\n  local.catch_env (local.return_env ?x6) ?m6 = local.return_env ?x6\n\ngoal (3 subgoals):\n 1. \\<And>m. local.catch_env local.fail_env m = m\n 2. \\<And>m. local.catch_env m local.fail_env = m\n 3. \\<And>m m' m''.\n       local.catch_env (local.catch_env m m') m'' =\n       local.catch_env m (local.catch_env m' m'')", "show \"catch_env fail_env m = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_env local.fail_env m = m", "by(rule envT.expand)(simp add: fun_eq_iff catch_fail)"], ["proof (state)\nthis:\n  local.catch_env local.fail_env ?m7 = ?m7\n\ngoal (2 subgoals):\n 1. \\<And>m. local.catch_env m local.fail_env = m\n 2. \\<And>m m' m''.\n       local.catch_env (local.catch_env m m') m'' =\n       local.catch_env m (local.catch_env m' m'')", "show \"catch_env m fail_env = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_env m local.fail_env = m", "by(rule envT.expand)(simp add: fun_eq_iff catch_fail2)"], ["proof (state)\nthis:\n  local.catch_env ?m8 local.fail_env = ?m8\n\ngoal (1 subgoal):\n 1. \\<And>m m' m''.\n       local.catch_env (local.catch_env m m') m'' =\n       local.catch_env m (local.catch_env m' m'')", "show \"catch_env (catch_env m m') m'' = catch_env m (catch_env m' m'')\"\n      for m m' m'' :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.catch_env (local.catch_env m m') m'' =\n    local.catch_env m (local.catch_env m' m'')", "by(rule envT.expand)(simp add: fun_eq_iff catch_assoc)"], ["proof (state)\nthis:\n  local.catch_env (local.catch_env ?m9 ?m'9) ?m''9 =\n  local.catch_env ?m9 (local.catch_env ?m'9 ?m''9)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_catch local.return_env local.bind_env local.fail_env local.catch_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>State\\<close>"], ["", "context\n  fixes get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\nbegin"], ["", "definition get_env :: \"('s, ('r, 'm) envT) get\"\nwhere \"get_env f = EnvT (\\<lambda>r. get (\\<lambda>s. run_env (f s) r))\""], ["", "definition put_env :: \"('s, ('r, 'm) envT) put\"\nwhere \"put_env s m = EnvT (\\<lambda>r. put s (run_env m r))\""], ["", "lemma run_get_env [simp]: \"run_env (get_env f) r = get (\\<lambda>s. run_env (f s) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.get_env f) r = get (\\<lambda>s. run_env (f s) r)", "by(simp add: get_env_def)"], ["", "lemma run_put_env [simp]: \"run_env (put_env s m) r = put s (run_env m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.put_env s m) r = put s (run_env m r)", "by(simp add: put_env_def)"], ["", "lemma monad_state_envT [locale_witness]:\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_env bind_env get_env put_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_env local.bind_env local.get_env local.put_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state local.return_env local.bind_env local.get_env local.put_env", "interpret monad_state return bind get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return bind get put", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state local.return_env local.bind_env local.get_env local.put_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_env local.bind_env local.get_env local.put_env", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f. local.put_env s (local.get_env f) = local.put_env s (f s)\n 2. \\<And>f.\n       local.get_env (\\<lambda>s. local.get_env (f s)) =\n       local.get_env (\\<lambda>s. f s s)\n 3. \\<And>s s' m. local.put_env s (local.put_env s' m) = local.put_env s' m\n 4. \\<And>m. local.get_env (\\<lambda>s. local.put_env s m) = m\n 5. \\<And>m. local.get_env (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 7. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"put_env s (get_env f) = put_env s (f s)\" for s :: 's and f :: \"'s \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_env s (local.get_env f) = local.put_env s (f s)", "by(rule envT.expand)(simp add: fun_eq_iff put_get)"], ["proof (state)\nthis:\n  local.put_env ?s8 (local.get_env ?f8) = local.put_env ?s8 (?f8 ?s8)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       local.get_env (\\<lambda>s. local.get_env (f s)) =\n       local.get_env (\\<lambda>s. f s s)\n 2. \\<And>s s' m. local.put_env s (local.put_env s' m) = local.put_env s' m\n 3. \\<And>m. local.get_env (\\<lambda>s. local.put_env s m) = m\n 4. \\<And>m. local.get_env (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 6. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"get_env (\\<lambda>s. get_env (f s)) = get_env (\\<lambda>s. f s s)\" for f :: \"'s \\<Rightarrow> 's \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_env (\\<lambda>s. local.get_env (f s)) =\n    local.get_env (\\<lambda>s. f s s)", "by(rule envT.expand)(simp add: fun_eq_iff get_get)"], ["proof (state)\nthis:\n  local.get_env (\\<lambda>s. local.get_env (?f9 s)) =\n  local.get_env (\\<lambda>s. ?f9 s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m. local.put_env s (local.put_env s' m) = local.put_env s' m\n 2. \\<And>m. local.get_env (\\<lambda>s. local.put_env s m) = m\n 3. \\<And>m. local.get_env (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 5. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"put_env s (put_env s' m) = put_env s' m\" for s s' :: 's and m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_env s (local.put_env s' m) = local.put_env s' m", "by(rule envT.expand)(simp add: fun_eq_iff put_put)"], ["proof (state)\nthis:\n  local.put_env ?s10 (local.put_env ?s'10 ?m10) = local.put_env ?s'10 ?m10\n\ngoal (4 subgoals):\n 1. \\<And>m. local.get_env (\\<lambda>s. local.put_env s m) = m\n 2. \\<And>m. local.get_env (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 4. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"get_env (\\<lambda>s. put_env s m) = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_env (\\<lambda>s. local.put_env s m) = m", "by(rule envT.expand)(simp add: fun_eq_iff get_put)"], ["proof (state)\nthis:\n  local.get_env (\\<lambda>s. local.put_env s ?m11) = ?m11\n\ngoal (3 subgoals):\n 1. \\<And>m. local.get_env (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 3. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"get_env (\\<lambda>_. m) = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_env (\\<lambda>_. m) = m", "by(rule envT.expand)(simp add: fun_eq_iff get_const)"], ["proof (state)\nthis:\n  local.get_env (\\<lambda>_. ?m12) = ?m12\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_env (local.get_env f) g =\n       local.get_env (\\<lambda>s. local.bind_env (f s) g)\n 2. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"bind_env (get_env f) g = get_env (\\<lambda>s. bind_env (f s) g)\" for f :: \"'s \\<Rightarrow> ('r, 'm) envT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.get_env f) g =\n    local.get_env (\\<lambda>s. local.bind_env (f s) g)", "by(rule envT.expand)(simp add: fun_eq_iff bind_get)"], ["proof (state)\nthis:\n  local.bind_env (local.get_env ?f13) ?g13 =\n  local.get_env (\\<lambda>s. local.bind_env (?f13 s) ?g13)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       local.bind_env (local.put_env s m) f =\n       local.put_env s (local.bind_env m f)", "show \"bind_env (put_env s m) f = put_env s (bind_env m f)\" for s and m :: \"('r, 'm) envT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.put_env s m) f =\n    local.put_env s (local.bind_env m f)", "by(rule envT.expand)(simp add: fun_eq_iff bind_put)"], ["proof (state)\nthis:\n  local.bind_env (local.put_env ?s14 ?m14) ?f14 =\n  local.put_env ?s14 (local.bind_env ?m14 ?f14)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state local.return_env local.bind_env local.get_env local.put_env\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Probability\\<close>"], ["", "context\n  fixes sample :: \"('p, 'm) sample\"\nbegin"], ["", "definition sample_env :: \"('p, ('r, 'm) envT) sample\"\nwhere \"sample_env p f = EnvT (\\<lambda>r. sample p (\\<lambda>x. run_env (f x) r))\""], ["", "lemma run_sample_env [simp]: \"run_env (sample_env p f) r = sample p (\\<lambda>x. run_env (f x) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.sample_env p f) r =\n    sample p (\\<lambda>x. run_env (f x) r)", "by(simp add: sample_env_def)"], ["", "lemma monad_prob_envT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_env bind_env sample_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "interpret monad_prob return bind sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return bind sample", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "note sample_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_pmf ?R) (rel_fun (rel_fun ?R (=)) (=)) sample sample\n\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_env local.bind_env local.sample_env", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p m. local.sample_env p (\\<lambda>_. m) = m\n 2. \\<And>x f. local.sample_env (return_pmf x) f = f x\n 3. \\<And>p f g.\n       local.sample_env (p \\<bind> f) g =\n       local.sample_env p (\\<lambda>x. local.sample_env (f x) g)\n 4. \\<And>p q f.\n       local.sample_env p (\\<lambda>x. local.sample_env q (f x)) =\n       local.sample_env q\n        (\\<lambda>y. local.sample_env p (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       local.bind_env (local.sample_env p f) g =\n       local.sample_env p (\\<lambda>x. local.bind_env (f x) g)\n 6. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"sample_env p (\\<lambda>_. x) = x\" for p :: \"'p pmf\" and x :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_env p (\\<lambda>_. x) = x", "by(rule envT.expand)(simp add: fun_eq_iff sample_const)"], ["proof (state)\nthis:\n  local.sample_env ?p9 (\\<lambda>_. ?x9) = ?x9\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.sample_env (return_pmf x) f = f x\n 2. \\<And>p f g.\n       local.sample_env (p \\<bind> f) g =\n       local.sample_env p (\\<lambda>x. local.sample_env (f x) g)\n 3. \\<And>p q f.\n       local.sample_env p (\\<lambda>x. local.sample_env q (f x)) =\n       local.sample_env q\n        (\\<lambda>y. local.sample_env p (\\<lambda>x. f x y))\n 4. \\<And>p f g.\n       local.bind_env (local.sample_env p f) g =\n       local.sample_env p (\\<lambda>x. local.bind_env (f x) g)\n 5. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"sample_env (return_pmf x) f = f x\" for f :: \"'p \\<Rightarrow> ('r, 'm) envT\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_env (return_pmf x) f = f x", "by(rule envT.expand)(simp add: fun_eq_iff sample_return_pmf)"], ["proof (state)\nthis:\n  local.sample_env (return_pmf ?x10) ?f10 = ?f10 ?x10\n\ngoal (5 subgoals):\n 1. \\<And>p f g.\n       local.sample_env (p \\<bind> f) g =\n       local.sample_env p (\\<lambda>x. local.sample_env (f x) g)\n 2. \\<And>p q f.\n       local.sample_env p (\\<lambda>x. local.sample_env q (f x)) =\n       local.sample_env q\n        (\\<lambda>y. local.sample_env p (\\<lambda>x. f x y))\n 3. \\<And>p f g.\n       local.bind_env (local.sample_env p f) g =\n       local.sample_env p (\\<lambda>x. local.bind_env (f x) g)\n 4. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"sample_env (bind_pmf p f) g = sample_env p (\\<lambda>x. sample_env (f x) g)\" for f and g :: \"'p \\<Rightarrow> ('r, 'm) envT\" and p"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_env (p \\<bind> f) g =\n    local.sample_env p (\\<lambda>x. local.sample_env (f x) g)", "by(rule envT.expand)(simp add: fun_eq_iff sample_bind_pmf)"], ["proof (state)\nthis:\n  local.sample_env (?p11 \\<bind> ?f11) ?g11 =\n  local.sample_env ?p11 (\\<lambda>x. local.sample_env (?f11 x) ?g11)\n\ngoal (4 subgoals):\n 1. \\<And>p q f.\n       local.sample_env p (\\<lambda>x. local.sample_env q (f x)) =\n       local.sample_env q\n        (\\<lambda>y. local.sample_env p (\\<lambda>x. f x y))\n 2. \\<And>p f g.\n       local.bind_env (local.sample_env p f) g =\n       local.sample_env p (\\<lambda>x. local.bind_env (f x) g)\n 3. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"sample_env p (\\<lambda>x. sample_env q (f x)) = sample_env q (\\<lambda>y. sample_env p (\\<lambda>x. f x y))\"\n      for p q :: \"'p pmf\" and f :: \"'p \\<Rightarrow> 'p \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_env p (\\<lambda>x. local.sample_env q (f x)) =\n    local.sample_env q (\\<lambda>y. local.sample_env p (\\<lambda>x. f x y))", "by(rule envT.expand)(auto simp add: fun_eq_iff intro: sample_commute)"], ["proof (state)\nthis:\n  local.sample_env ?p12 (\\<lambda>x. local.sample_env ?q12 (?f12 x)) =\n  local.sample_env ?q12\n   (\\<lambda>y. local.sample_env ?p12 (\\<lambda>x. ?f12 x y))\n\ngoal (3 subgoals):\n 1. \\<And>p f g.\n       local.bind_env (local.sample_env p f) g =\n       local.sample_env p (\\<lambda>x. local.bind_env (f x) g)\n 2. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"bind_env (sample_env p f) g = sample_env p (\\<lambda>x. bind_env (f x) g)\"\n      for p and f :: \"'p \\<Rightarrow> ('r, 'm) envT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.sample_env p f) g =\n    local.sample_env p (\\<lambda>x. local.bind_env (f x) g)", "by(rule envT.expand)(simp add: fun_eq_iff bind_sample1)"], ["proof (state)\nthis:\n  local.bind_env (local.sample_env ?p13 ?f13) ?g13 =\n  local.sample_env ?p13 (\\<lambda>x. local.bind_env (?f13 x) ?g13)\n\ngoal (2 subgoals):\n 1. \\<And>m f p.\n       local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n       local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"bind_env m (\\<lambda>y. sample_env p (f y)) = sample_env p (\\<lambda>x. bind_env m (\\<lambda>y. f y x))\"\n      for m p and f :: \"'a \\<Rightarrow> 'p \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env m (\\<lambda>y. local.sample_env p (f y)) =\n    local.sample_env p (\\<lambda>x. local.bind_env m (\\<lambda>y. f y x))", "by(rule envT.expand)(simp add: fun_eq_iff bind_sample2)"], ["proof (state)\nthis:\n  local.bind_env ?m14 (\\<lambda>y. local.sample_env ?p14 (?f14 y)) =\n  local.sample_env ?p14\n   (\\<lambda>x. local.bind_env ?m14 (\\<lambda>y. ?f14 y x))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env\n        local.sample_env", "show \"(rel_pmf R ===> (R ===> (=)) ===> (=)) sample_env sample_env\"\n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_env local.sample_env", "unfolding sample_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f.\n         EnvT (\\<lambda>r. sample p (\\<lambda>x. run_env (f x) r)))\n     (\\<lambda>p f.\n         EnvT (\\<lambda>r. sample p (\\<lambda>x. run_env (f x) r)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R15 \\<Longrightarrow>\n  (rel_pmf ?R15 ===> (?R15 ===> (=)) ===> (=)) local.sample_env\n   local.sample_env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_prob local.return_env local.bind_env local.sample_env\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_prob_envT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_env bind_env get_env put_env sample_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_env local.bind_env local.get_env\n     local.put_env local.sample_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_env local.bind_env local.get_env\n     local.put_env local.sample_env", "interpret monad_state_prob return bind get put sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob return bind get put sample", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_env local.bind_env local.get_env\n     local.put_env local.sample_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_env local.bind_env local.get_env\n     local.put_env local.sample_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f.\n       local.sample_env p (\\<lambda>x. local.get_env (f x)) =\n       local.get_env (\\<lambda>s. local.sample_env p (\\<lambda>x. f x s))", "show \"sample_env p (\\<lambda>x. get_env (f x)) = get_env (\\<lambda>s. sample_env p (\\<lambda>x. f x s))\"\n      for p and f :: \"'p \\<Rightarrow> 's \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_env p (\\<lambda>x. local.get_env (f x)) =\n    local.get_env (\\<lambda>s. local.sample_env p (\\<lambda>x. f x s))", "by(rule envT.expand)(simp add: fun_eq_iff sample_get)"], ["proof (state)\nthis:\n  local.sample_env ?p9 (\\<lambda>x. local.get_env (?f9 x)) =\n  local.get_env (\\<lambda>s. local.sample_env ?p9 (\\<lambda>x. ?f9 x s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_prob local.return_env local.bind_env local.get_env\n   local.put_env local.sample_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Binary Non-determinism\\<close>"], ["", "context\n  fixes alt :: \"'m alt\"\nbegin"], ["", "definition alt_env :: \"('r, 'm) envT alt\"\nwhere \"alt_env m1 m2 = EnvT (\\<lambda>r. alt (run_env m1 r) (run_env m2 r))\""], ["", "lemma run_alt_env [simp]: \"run_env (alt_env m1 m2) r = alt (run_env m1 r) (run_env m2 r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.alt_env m1 m2) r = alt (run_env m1 r) (run_env m2 r)", "by(simp add: alt_env_def)"], ["", "lemma monad_alt_envT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_env bind_env alt_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_env local.bind_env local.alt_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_env local.bind_env local.alt_env", "interpret monad_alt return bind alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return bind alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_env local.bind_env local.alt_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_env local.bind_env local.alt_env", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3.\n       local.alt_env (local.alt_env m1 m2) m3 =\n       local.alt_env m1 (local.alt_env m2 m3)\n 2. \\<And>m m' f.\n       local.bind_env (local.alt_env m m') f =\n       local.alt_env (local.bind_env m f) (local.bind_env m' f)", "show \"alt_env (alt_env m1 m2) m3 = alt_env m1 (alt_env m2 m3)\" for m1 m2 m3 :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_env (local.alt_env m1 m2) m3 =\n    local.alt_env m1 (local.alt_env m2 m3)", "by(rule envT.expand)(simp add: fun_eq_iff alt_assoc)"], ["proof (state)\nthis:\n  local.alt_env (local.alt_env ?m1.10 ?m2.10) ?m3.10 =\n  local.alt_env ?m1.10 (local.alt_env ?m2.10 ?m3.10)\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_env (local.alt_env m m') f =\n       local.alt_env (local.bind_env m f) (local.bind_env m' f)", "show \"bind_env (alt_env m m') f = alt_env (bind_env m f) (bind_env m' f)\" for m m' :: \"('r, 'm) envT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.alt_env m m') f =\n    local.alt_env (local.bind_env m f) (local.bind_env m' f)", "by(rule envT.expand)(simp add: fun_eq_iff bind_alt1)"], ["proof (state)\nthis:\n  local.bind_env (local.alt_env ?m11 ?m'11) ?f11 =\n  local.alt_env (local.bind_env ?m11 ?f11) (local.bind_env ?m'11 ?f11)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_alt local.return_env local.bind_env local.alt_env\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_fail_alt_envT [locale_witness]:\n  fixes fail\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_env bind_env (fail_env fail) alt_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_env local.bind_env (local.fail_env fail)\n     local.alt_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_env local.bind_env (local.fail_env fail)\n     local.alt_env", "interpret monad_fail_alt return bind fail alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt return bind fail alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_env local.bind_env (local.fail_env fail)\n     local.alt_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_env local.bind_env (local.fail_env fail)\n     local.alt_env", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. local.alt_env (local.fail_env fail) m = m\n 2. \\<And>m. local.alt_env m (local.fail_env fail) = m", "show \"alt_env (fail_env fail) m = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_env (local.fail_env fail) m = m", "by(rule envT.expand)(simp add: alt_fail1 fun_eq_iff)"], ["proof (state)\nthis:\n  local.alt_env (local.fail_env fail) ?m10 = ?m10\n\ngoal (1 subgoal):\n 1. \\<And>m. local.alt_env m (local.fail_env fail) = m", "show \"alt_env m (fail_env fail) = m\" for m :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_env m (local.fail_env fail) = m", "by(rule envT.expand)(simp add: alt_fail2 fun_eq_iff)"], ["proof (state)\nthis:\n  local.alt_env ?m11 (local.fail_env fail) = ?m11\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_fail_alt local.return_env local.bind_env (local.fail_env fail)\n   local.alt_env\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_alt_envT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_env bind_env get_env put_env alt_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_env local.bind_env local.get_env\n     local.put_env local.alt_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_env local.bind_env local.get_env\n     local.put_env local.alt_env", "interpret monad_state_alt return bind get put alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt return bind get put alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_env local.bind_env local.get_env\n     local.put_env local.alt_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_env local.bind_env local.get_env\n     local.put_env local.alt_env", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.alt_env (local.get_env f) (local.get_env g) =\n       local.get_env (\\<lambda>x. local.alt_env (f x) (g x))\n 2. \\<And>s m m'.\n       local.alt_env (local.put_env s m) (local.put_env s m') =\n       local.put_env s (local.alt_env m m')", "show \"alt_env (get_env f) (get_env g) = get_env (\\<lambda>x. alt_env (f x) (g x))\"\n      for f g :: \"'s \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_env (local.get_env f) (local.get_env g) =\n    local.get_env (\\<lambda>x. local.alt_env (f x) (g x))", "by(rule envT.expand)(simp add: fun_eq_iff alt_get)"], ["proof (state)\nthis:\n  local.alt_env (local.get_env ?f9) (local.get_env ?g9) =\n  local.get_env (\\<lambda>x. local.alt_env (?f9 x) (?g9 x))\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       local.alt_env (local.put_env s m) (local.put_env s m') =\n       local.put_env s (local.alt_env m m')", "show \"alt_env (put_env s m) (put_env s m') = put_env s (alt_env m m')\"\n      for s and m m' :: \"('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_env (local.put_env s m) (local.put_env s m') =\n    local.put_env s (local.alt_env m m')", "by(rule envT.expand)(simp add: fun_eq_iff alt_put)"], ["proof (state)\nthis:\n  local.alt_env (local.put_env ?s9 ?m9) (local.put_env ?s9 ?m'9) =\n  local.put_env ?s9 (local.alt_env ?m9 ?m'9)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_alt local.return_env local.bind_env local.get_env\n   local.put_env local.alt_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Countable Non-determinism\\<close>"], ["", "context\n  fixes altc :: \"('c, 'm) altc\"\nbegin"], ["", "definition altc_env :: \"('c, ('r, 'm) envT) altc\"\nwhere \"altc_env C f = EnvT (\\<lambda>r. altc C (\\<lambda>c. run_env (f c) r))\""], ["", "lemma run_altc_env [simp]: \"run_env (altc_env C f) r = altc C (\\<lambda>c. run_env (f c) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.altc_env C f) r = altc C (\\<lambda>c. run_env (f c) r)", "by(simp add: altc_env_def)"], ["", "lemma monad_altc_envT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_env bind_env altc_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "interpret monad_altc return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "note altc_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_cset ?R) (rel_fun (rel_fun ?R (=)) (=)) altc altc\n\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_env local.bind_env local.altc_env", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       local.bind_env (local.altc_env C g) f =\n       local.altc_env C (\\<lambda>c. local.bind_env (g c) f)\n 2. \\<And>x f. local.altc_env (csingle x) f = f x\n 3. \\<And>C f g.\n       local.altc_env (cUnion (cimage f C)) g =\n       local.altc_env C (\\<lambda>x. local.altc_env (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_env local.altc_env", "show \"bind_env (altc_env C g) f = altc_env C (\\<lambda>c. bind_env (g c) f)\" for C g and f :: \"'a \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.altc_env C g) f =\n    local.altc_env C (\\<lambda>c. local.bind_env (g c) f)", "by(rule envT.expand)(simp add: fun_eq_iff bind_altc1)"], ["proof (state)\nthis:\n  local.bind_env (local.altc_env ?C10 ?g10) ?f10 =\n  local.altc_env ?C10 (\\<lambda>c. local.bind_env (?g10 c) ?f10)\n\ngoal (3 subgoals):\n 1. \\<And>x f. local.altc_env (csingle x) f = f x\n 2. \\<And>C f g.\n       local.altc_env (cUnion (cimage f C)) g =\n       local.altc_env C (\\<lambda>x. local.altc_env (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_env local.altc_env", "show \"altc_env (csingle x) f = f x\" for x and f :: \"'c \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_env (csingle x) f = f x", "by(rule envT.expand)(simp add: fun_eq_iff altc_single)"], ["proof (state)\nthis:\n  local.altc_env (csingle ?x10) ?f10 = ?f10 ?x10\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       local.altc_env (cUnion (cimage f C)) g =\n       local.altc_env C (\\<lambda>x. local.altc_env (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_env local.altc_env", "show \"altc_env (cUNION C f) g = altc_env C (\\<lambda>x. altc_env (f x) g)\" for C f and g :: \"'c \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_env (cUnion (cimage f C)) g =\n    local.altc_env C (\\<lambda>x. local.altc_env (f x) g)", "by(rule envT.expand)(simp add: fun_eq_iff altc_cUNION)"], ["proof (state)\nthis:\n  local.altc_env (cUnion (cimage ?f10 ?C10)) ?g10 =\n  local.altc_env ?C10 (\\<lambda>x. local.altc_env (?f10 x) ?g10)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_env local.altc_env", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) altc_env altc_env\" if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_env local.altc_env", "unfolding altc_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>C f. EnvT (\\<lambda>r. altc C (\\<lambda>c. run_env (f c) r)))\n     (\\<lambda>C f. EnvT (\\<lambda>r. altc C (\\<lambda>c. run_env (f c) r)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R11 \\<Longrightarrow>\n  (rel_cset ?R11 ===> (?R11 ===> (=)) ===> (=)) local.altc_env\n   local.altc_env\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_altc local.return_env local.bind_env local.altc_env\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_altc3_envT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_env bind_env altc_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_env local.bind_env local.altc_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_env local.bind_env local.altc_env", "interpret monad_altc3 return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_env local.bind_env local.altc_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_env local.bind_env local.altc_env", ".."], ["proof (state)\nthis:\n  monad_altc3 local.return_env local.bind_env local.altc_env\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_altc_envT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_env bind_env get_env put_env altc_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_env local.bind_env local.get_env\n     local.put_env local.altc_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_env local.bind_env local.get_env\n     local.put_env local.altc_env", "interpret monad_state_altc return bind get put altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc return bind get put altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_env local.bind_env local.get_env\n     local.put_env local.altc_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_env local.bind_env local.get_env\n     local.put_env local.altc_env", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C f.\n       local.altc_env C (\\<lambda>c. local.get_env (f c)) =\n       local.get_env (\\<lambda>s. local.altc_env C (\\<lambda>c. f c s))\n 2. \\<And>s C f.\n       local.altc_env C (\\<lambda>c. local.put_env s (f c)) =\n       local.put_env s (local.altc_env C f)", "show \"altc_env C (\\<lambda>c. get_env (f c)) = get_env (\\<lambda>s. altc_env C (\\<lambda>c. f c s))\"\n      for C and f :: \"'c \\<Rightarrow> 's \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_env C (\\<lambda>c. local.get_env (f c)) =\n    local.get_env (\\<lambda>s. local.altc_env C (\\<lambda>c. f c s))", "by(rule envT.expand)(simp add: fun_eq_iff altc_get)"], ["proof (state)\nthis:\n  local.altc_env ?C10 (\\<lambda>c. local.get_env (?f10 c)) =\n  local.get_env (\\<lambda>s. local.altc_env ?C10 (\\<lambda>c. ?f10 c s))\n\ngoal (1 subgoal):\n 1. \\<And>s C f.\n       local.altc_env C (\\<lambda>c. local.put_env s (f c)) =\n       local.put_env s (local.altc_env C f)", "show \"altc_env C (\\<lambda>c. put_env s (f c)) = put_env s (altc_env C f)\"\n      for C s and f :: \"'c \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_env C (\\<lambda>c. local.put_env s (f c)) =\n    local.put_env s (local.altc_env C f)", "by(rule envT.expand)(simp add: fun_eq_iff altc_put)"], ["proof (state)\nthis:\n  local.altc_env ?C10 (\\<lambda>c. local.put_env ?s10 (?f10 c)) =\n  local.put_env ?s10 (local.altc_env ?C10 ?f10)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_altc local.return_env local.bind_env local.get_env\n   local.put_env local.altc_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Resumption\\<close>"], ["", "context\n  fixes pause :: \"('o, 'i, 'm) pause\"\nbegin"], ["", "definition pause_env :: \"('o, 'i, ('r, 'm) envT) pause\"\nwhere \"pause_env out c = EnvT (\\<lambda>r. pause out (\\<lambda>i. run_env (c i) r))\""], ["", "lemma run_pause_env [simp]:\n  \"run_env (pause_env out c) r = pause out (\\<lambda>i. run_env (c i) r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.pause_env out c) r =\n    pause out (\\<lambda>i. run_env (c i) r)", "by(simp add: pause_env_def)"], ["", "lemma monad_resumption_envT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_env bind_env pause_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_env local.bind_env local.pause_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_env local.bind_env local.pause_env", "interpret monad_resumption return bind pause"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption return bind pause", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_env local.bind_env local.pause_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_env local.bind_env local.pause_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c f.\n       local.bind_env (local.pause_env out c) f =\n       local.pause_env out (\\<lambda>i. local.bind_env (c i) f)", "show \"bind_env (pause_env out c) f = pause_env out (\\<lambda>i. bind_env (c i) f)\" for out f and c :: \"'i \\<Rightarrow> ('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.pause_env out c) f =\n    local.pause_env out (\\<lambda>i. local.bind_env (c i) f)", "by(rule envT.expand)(simp add: fun_eq_iff bind_pause)"], ["proof (state)\nthis:\n  local.bind_env (local.pause_env ?out12 ?c12) ?f12 =\n  local.pause_env ?out12 (\\<lambda>i. local.bind_env (?c12 i) ?f12)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_resumption local.return_env local.bind_env local.pause_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Writer\\<close>"], ["", "context\n  fixes tell :: \"('w, 'm) tell\"\nbegin"], ["", "definition tell_env :: \"('w, ('r, 'm) envT) tell\"\nwhere \"tell_env w m = EnvT (\\<lambda>r. tell w (run_env m r))\""], ["", "lemma run_tell_env [simp]: \"run_env (tell_env w m) r = tell w (run_env m r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (local.tell_env w m) r = tell w (run_env m r)", "by(simp add: tell_env_def)"], ["", "lemma monad_writer_envT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_env bind_env tell_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_env local.bind_env local.tell_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_env local.bind_env local.tell_env", "interpret monad_writer return bind tell"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer return bind tell", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_env local.bind_env local.tell_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_env local.bind_env local.tell_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w m f.\n       local.bind_env (local.tell_env w m) f =\n       local.tell_env w (local.bind_env m f)", "show \"bind_env (tell_env w m) f = tell_env w (bind_env m f)\" for w and m :: \"('r, 'm) envT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env (local.tell_env w m) f =\n    local.tell_env w (local.bind_env m f)", "by(rule envT.expand)(simp add: bind_tell fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_env (local.tell_env ?w13 ?m13) ?f13 =\n  local.tell_env ?w13 (local.bind_env ?m13 ?f13)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_writer local.return_env local.bind_env local.tell_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Commutativity\\<close>"], ["", "lemma monad_commute_envT [locale_witness]:\n  assumes \"monad_commute return bind\"\n  shows \"monad_commute return_env bind_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute local.return_env local.bind_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_commute local.return_env local.bind_env", "interpret monad_commute return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_commute local.return_env local.bind_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute local.return_env local.bind_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_env m (\\<lambda>x. local.bind_env m' (f x)) =\n       local.bind_env m' (\\<lambda>y. local.bind_env m (\\<lambda>x. f x y))", "show \"bind_env m (\\<lambda>x. bind_env m' (f x)) = bind_env m' (\\<lambda>y. bind_env m (\\<lambda>x. f x y))\"\n      for f and m m' :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env m (\\<lambda>x. local.bind_env m' (f x)) =\n    local.bind_env m' (\\<lambda>y. local.bind_env m (\\<lambda>x. f x y))", "by(rule envT.expand)(auto simp add: fun_eq_iff intro: bind_commute)"], ["proof (state)\nthis:\n  local.bind_env ?m13 (\\<lambda>x. local.bind_env ?m'13 (?f13 x)) =\n  local.bind_env ?m'13\n   (\\<lambda>y. local.bind_env ?m13 (\\<lambda>x. ?f13 x y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_commute local.return_env local.bind_env\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Discardability\\<close>"], ["", "lemma monad_discard_envT [locale_witness]:\n  assumes \"monad_discard return bind\"\n  shows \"monad_discard return_env bind_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard local.return_env local.bind_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_discard local.return_env local.bind_env", "interpret monad_discard return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_discard local.return_env local.bind_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard local.return_env local.bind_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m'. local.bind_env m (\\<lambda>_. m') = m'", "show \"bind_env m (\\<lambda>_. m') = m'\" for m m' :: \"('r, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env m (\\<lambda>_. m') = m'", "by(rule envT.expand)(simp add: fun_eq_iff bind_const)"], ["proof (state)\nthis:\n  local.bind_env ?m13 (\\<lambda>_. ?m'13) = ?m'13\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_discard local.return_env local.bind_env\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Duplicability\\<close>"], ["", "lemma monad_duplicate_envT [locale_witness]:\n  assumes \"monad_duplicate return bind\"\n  shows \"monad_duplicate return_env bind_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_env local.bind_env", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_env local.bind_env", "interpret monad_duplicate return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate return bind", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_env local.bind_env", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate local.return_env local.bind_env", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_env m (\\<lambda>x. local.bind_env m (f x)) =\n       local.bind_env m (\\<lambda>x. f x x)", "show \"bind_env m (\\<lambda>x. bind_env m (f x)) = bind_env m (\\<lambda>x. f x x)\" for m :: \"('b, 'm) envT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_env m (\\<lambda>x. local.bind_env m (f x)) =\n    local.bind_env m (\\<lambda>x. f x x)", "by(rule envT.expand)(simp add: fun_eq_iff bind_duplicate)"], ["proof (state)\nthis:\n  local.bind_env ?m12 (\\<lambda>x. local.bind_env ?m12 (?f12 x)) =\n  local.bind_env ?m12 (\\<lambda>x. ?f12 x x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_duplicate local.return_env local.bind_env\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Parametricity\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma return_env_parametric [transfer_rule]:\n  \"((A ===> M) ===> A ===> rel_envT R M) return_env return_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===> A ===> Monomorphic_Monad.rel_envT R M) return_env\n     return_env", "unfolding return_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> M) ===> A ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>return x. EnvT (\\<lambda>_. return x))\n     (\\<lambda>return x. EnvT (\\<lambda>_. return x))", "by transfer_prover"], ["", "lemma bind_env_parametric [transfer_rule]:\n  \"((M ===> (A ===> M) ===> M) ===> rel_envT R M ===> (A ===> rel_envT R M) ===> rel_envT R M)\n   bind_env bind_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (A ===> M) ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     (A ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     bind_env bind_env", "unfolding bind_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (A ===> M) ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     (A ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>bind.\n         rec_envT\n          (\\<lambda>x f.\n              EnvT (\\<lambda>r. bind (x r) (\\<lambda>y. run_env (f y) r))))\n     (\\<lambda>bind.\n         rec_envT\n          (\\<lambda>x f.\n              EnvT (\\<lambda>r. bind (x r) (\\<lambda>y. run_env (f y) r))))", "by transfer_prover"], ["", "lemma ask_env_parametric [transfer_rule]: \"((R ===> rel_envT R M) ===> rel_envT R M) ask_env ask_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     ask_env ask_env", "unfolding ask_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((R ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>f. EnvT (\\<lambda>r. run_env (f r) r))\n     (\\<lambda>f. EnvT (\\<lambda>r. run_env (f r) r))", "by transfer_prover"], ["", "lemma fail_env_parametric [transfer_rule]: \"(M ===> rel_envT R M) fail_env fail_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> Monomorphic_Monad.rel_envT R M) fail_env fail_env", "unfolding fail_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>fail. EnvT (\\<lambda>r. fail))\n     (\\<lambda>fail. EnvT (\\<lambda>r. fail))", "by transfer_prover"], ["", "lemma catch_env_parametric [transfer_rule]: \n  \"((M ===> M ===> M) ===> rel_envT R M ===> rel_envT R M ===> rel_envT R M) catch_env catch_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     catch_env catch_env", "unfolding catch_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>catch m1 m2.\n         EnvT (\\<lambda>r. catch (run_env m1 r) (run_env m2 r)))\n     (\\<lambda>catch m1 m2.\n         EnvT (\\<lambda>r. catch (run_env m1 r) (run_env m2 r)))", "by transfer_prover"], ["", "lemma get_env_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_envT R M) ===> rel_envT R M) get_env get_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     get_env get_env", "unfolding get_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>get f. EnvT (\\<lambda>r. get (\\<lambda>s. run_env (f s) r)))\n     (\\<lambda>get f. EnvT (\\<lambda>r. get (\\<lambda>s. run_env (f s) r)))", "by transfer_prover"], ["", "lemma put_env_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_envT R M ===> rel_envT R M) put_env put_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===>\n     S ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     put_env put_env", "unfolding put_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===>\n     S ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>put s m. EnvT (\\<lambda>r. put s (run_env m r)))\n     (\\<lambda>put s m. EnvT (\\<lambda>r. put s (run_env m r)))", "by transfer_prover"], ["", "lemma sample_env_parametric [transfer_rule]:\n  \"((rel_pmf P ===> (P ===> M) ===> M) ===> rel_pmf P ===> (P ===> rel_envT R M) ===> rel_envT R M)\n  sample_env sample_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_pmf P ===> (P ===> M) ===> M) ===>\n     rel_pmf P ===>\n     (P ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     sample_env sample_env", "unfolding sample_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_pmf P ===> (P ===> M) ===> M) ===>\n     rel_pmf P ===>\n     (P ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>sample p f.\n         EnvT (\\<lambda>r. sample p (\\<lambda>x. run_env (f x) r)))\n     (\\<lambda>sample p f.\n         EnvT (\\<lambda>r. sample p (\\<lambda>x. run_env (f x) r)))", "by transfer_prover"], ["", "lemma alt_env_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_envT R M ===> rel_envT R M ===> rel_envT R M) alt_env alt_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     alt_env alt_env", "unfolding alt_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     Monomorphic_Monad.rel_envT R M ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>alt m1 m2.\n         EnvT (\\<lambda>r. alt (run_env m1 r) (run_env m2 r)))\n     (\\<lambda>alt m1 m2.\n         EnvT (\\<lambda>r. alt (run_env m1 r) (run_env m2 r)))", "by transfer_prover"], ["", "lemma altc_env_parametric [transfer_rule]:\n  \"((rel_cset C ===> (C ===> M) ===> M) ===> rel_cset C ===> (C ===> rel_envT R M) ===> rel_envT R M) \n   altc_env altc_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_cset C ===> (C ===> M) ===> M) ===>\n     rel_cset C ===>\n     (C ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     altc_env altc_env", "unfolding altc_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_cset C ===> (C ===> M) ===> M) ===>\n     rel_cset C ===>\n     (C ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>altc C f.\n         EnvT (\\<lambda>r. altc C (\\<lambda>c. run_env (f c) r)))\n     (\\<lambda>altc C f.\n         EnvT (\\<lambda>r. altc C (\\<lambda>c. run_env (f c) r)))", "by transfer_prover"], ["", "lemma pause_env_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_envT R M) ===> rel_envT R M)\n   pause_env pause_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===>\n     (In ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     pause_env pause_env", "unfolding pause_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===>\n     (In ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>pause out c.\n         EnvT (\\<lambda>r. pause out (\\<lambda>i. run_env (c i) r)))\n     (\\<lambda>pause out c.\n         EnvT (\\<lambda>r. pause out (\\<lambda>i. run_env (c i) r)))", "by transfer_prover"], ["", "lemma tell_env_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_envT R M ===> rel_envT R M) tell_env tell_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===>\n     W ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     tell_env tell_env", "unfolding tell_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===>\n     W ===>\n     Monomorphic_Monad.rel_envT R M ===> Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>tell w m. EnvT (\\<lambda>r. tell w (run_env m r)))\n     (\\<lambda>tell w m. EnvT (\\<lambda>r. tell w (run_env m r)))", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Unbounded non-determinism\\<close>"], ["", "abbreviation (input) return_set :: \"('a, 'a set) return\" where \"return_set x \\<equiv> {x}\""], ["", "abbreviation (input) bind_set :: \"('a, 'a set) bind\" where \"bind_set \\<equiv> \\<lambda>A f. \\<Union> (f ` A)\""], ["", "abbreviation (input) fail_set :: \"'a set fail\" where \"fail_set \\<equiv> {}\""], ["", "abbreviation (input) alt_set :: \"'a set alt\" where \"alt_set \\<equiv> (\\<union>)\""], ["", "abbreviation (input) altc_set :: \"('c, 'a set) altc\" where \"altc_set C \\<equiv> \\<lambda>f. \\<Union> (f ` rcset C)\""], ["", "lemma monad_set [locale_witness]: \"monad return_set bind_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A))", "by unfold_locales auto"], ["", "lemma monad_fail_set [locale_witness]: \"monad_fail return_set bind_set fail_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A)) {}", "by unfold_locales auto"], ["", "lemma monad_lift_set [simp]: \"monad_base.lift return_set bind_set  = image\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_base.lift (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A)) = (`)", "by(auto simp add: monad_base.lift_def o_def fun_eq_iff)"], ["", "lemma monad_alt_set [locale_witness]: \"monad_alt return_set bind_set alt_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A)) (\\<union>)", "by unfold_locales auto"], ["", "lemma monad_altc_set [locale_witness]: \"monad_altc return_set bind_set altc_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A))\n     (\\<lambda>C f. \\<Union> (f ` rcset C))", "including cset.lifting lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A))\n     (\\<lambda>C f. \\<Union> (f ` rcset C))", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       \\<Union> (f ` \\<Union> (g ` rcset C)) =\n       (\\<Union>c\\<in>rcset C. \\<Union> (f ` g c))\n 2. \\<And>x f. \\<Union> (f ` rcset (csingle x)) = f x\n 3. \\<And>C f g.\n       \\<Union> (g ` rcset (cUnion (cimage f C))) =\n       (\\<Union>x\\<in>rcset C. \\<Union> (g ` rcset (f x)))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=))\n        (\\<lambda>C f. \\<Union> (f ` rcset C))\n        (\\<lambda>C f. \\<Union> (f ` rcset C))", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) (\\<lambda>C f. \\<Union> (f ` rcset C)) (\\<lambda>C f. \\<Union> (f ` rcset C))\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>C f. \\<Union> (f ` rcset C))\n     (\\<lambda>C f. \\<Union> (f ` rcset C))", "by transfer_prover"], ["proof (state)\nthis:\n  (rel_cset ?R1 ===> (?R1 ===> (=)) ===> (=))\n   (\\<lambda>C f. \\<Union> (f ` rcset C))\n   (\\<lambda>C f. \\<Union> (f ` rcset C))\n\ngoal (3 subgoals):\n 1. \\<And>C g f.\n       \\<Union> (f ` \\<Union> (g ` rcset C)) =\n       (\\<Union>c\\<in>rcset C. \\<Union> (f ` g c))\n 2. \\<And>x f. \\<Union> (f ` rcset (csingle x)) = f x\n 3. \\<And>C f g.\n       \\<Union> (g ` rcset (cUnion (cimage f C))) =\n       (\\<Union>x\\<in>rcset C. \\<Union> (g ` rcset (f x)))", "qed(transfer; auto; fail)+"], ["", "lemma monad_altc3_set [locale_witness]:\n  \"monad_altc3 return_set bind_set (altc_set :: ('c, 'a set) altc)\"\n  if [locale_witness]: \"three TYPE('c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 (\\<lambda>x. {x}) (\\<lambda>A f. \\<Union> (f ` A))\n     (\\<lambda>C f. \\<Union> (f ` rcset C))", ".."], ["", "subsection \\<open>Non-determinism transformer\\<close>"], ["", "datatype (plugins del: transfer) (phantom_nondetT: 'a, set_nondetT: 'm) nondetT = NondetT (run_nondet: 'm)\n  for map: map_nondetT'\n      rel: rel_nondetT'"], ["", "text \\<open>\n  We define our own relator and mapper such that the phantom variable does not need any relation.\n\\<close>"], ["", "lemma phantom_nondetT [simp]: \"phantom_nondetT x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. phantom_nondetT x = {}", "by(cases x) simp"], ["", "context includes lifting_syntax begin"], ["", "lemma rel_nondetT'_phantom: \"rel_nondetT' A = rel_nondetT' top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT' A = rel_nondetT' \\<top>", "by(auto 4 4 intro: nondetT.rel_mono antisym nondetT.rel_mono_strong)"], ["", "lemma map_nondetT'_phantom: \"map_nondetT' f = map_nondetT' undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_nondetT' f = map_nondetT' undefined", "by(auto 4 4 intro: nondetT.map_cong)"], ["", "definition map_nondetT :: \"('m \\<Rightarrow> 'm') \\<Rightarrow> ('a, 'm) nondetT \\<Rightarrow> ('b, 'm') nondetT\"\nwhere \"map_nondetT = map_nondetT' undefined\""], ["", "definition rel_nondetT :: \"('m \\<Rightarrow> 'm' \\<Rightarrow> bool) \\<Rightarrow> ('a, 'm) nondetT \\<Rightarrow> ('b, 'm') nondetT \\<Rightarrow> bool\"\nwhere \"rel_nondetT = rel_nondetT' top\""], ["", "lemma rel_nondetTE:\n  assumes \"rel_nondetT M m m'\"\n  obtains x y where \"m = NondetT x\" \"m' = NondetT y\" \"M x y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>m = NondetT x; m' = NondetT y; M x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  rel_nondetT M m m'\n\ngoal (1 subgoal):\n 1. (\\<And>x y.\n        \\<lbrakk>m = NondetT x; m' = NondetT y; M x y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m; cases m'; simp add: rel_nondetT_def)"], ["", "lemma rel_nondetT_simps [simp]: \"rel_nondetT M (NondetT m) (NondetT m') \\<longleftrightarrow> M m m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT M (NondetT m) (NondetT m') = M m m'", "by(simp add: rel_nondetT_def)"], ["", "lemma rel_nondetT_unfold: \n  \"\\<And>m m'. rel_nondetT M (NondetT m) m' \\<longleftrightarrow> (\\<exists>m''. m' = NondetT m'' \\<and> M m m'')\"\n  \"\\<And>m m'. rel_nondetT M m (NondetT m') \\<longleftrightarrow> (\\<exists>m''. m = NondetT m'' \\<and> M m'' m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m m'.\n        rel_nondetT M (NondetT m) m' =\n        (\\<exists>m''. m' = NondetT m'' \\<and> M m m'')) &&&\n    (\\<And>m m'.\n        rel_nondetT M m (NondetT m') =\n        (\\<exists>m''. m = NondetT m'' \\<and> M m'' m'))", "subgoal for m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT M (NondetT m) m' =\n    (\\<exists>m''. m' = NondetT m'' \\<and> M m m'')", "by(cases m'; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>m m'.\n       rel_nondetT M m (NondetT m') =\n       (\\<exists>m''. m = NondetT m'' \\<and> M m'' m')", "subgoal for m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT M m (NondetT m') =\n    (\\<exists>m''. m = NondetT m'' \\<and> M m'' m')", "by(cases m; simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_nondetT_expand: \"M (run_nondet m) (run_nondet m') \\<Longrightarrow> rel_nondetT M m m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M (run_nondet m) (run_nondet m') \\<Longrightarrow> rel_nondetT M m m'", "by(cases m; cases m'; simp)"], ["", "lemma rel_nondetT_eq [relator_eq]: \"rel_nondetT (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT (=) = (=)", "by(auto simp add: fun_eq_iff rel_nondetT_def intro: nondetT.rel_refl_strong elim: nondetT.rel_cases)"], ["", "lemma rel_nondetT_mono [relator_mono]: \"rel_nondetT A \\<le> rel_nondetT B\" if \"A \\<le> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT A \\<le> rel_nondetT B", "by(simp add: rel_nondetT_def nondetT.rel_mono that)"], ["", "lemma rel_nondetT_distr [relator_distr]: \"rel_nondetT A OO rel_nondetT B = rel_nondetT (A OO B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT A OO rel_nondetT B = rel_nondetT (A OO B)", "by(simp add: rel_nondetT_def nondetT.rel_compp[symmetric])"], ["", "lemma rel_nondetT_Grp: \"rel_nondetT (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_nondetT x \\<subseteq> A} (map_nondetT f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_nondetT (BNF_Def.Grp A f) =\n    BNF_Def.Grp {x. set_nondetT x \\<subseteq> A} (map_nondetT f)", "by(simp add: rel_nondetT_def rel_nondetT'_phantom[of \"BNF_Def.Grp UNIV undefined\", symmetric] nondetT.rel_Grp map_nondetT_def)"], ["", "lemma NondetT_parametric [transfer_rule]: \"(M ===> rel_nondetT M) NondetT NondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_nondetT M) NondetT NondetT", "by(simp add: rel_fun_def rel_nondetT_def)"], ["", "lemma run_nondet_parametric [transfer_rule]: \"(rel_nondetT M ===> M) run_nondet run_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_nondetT M ===> M) run_nondet run_nondet", "by(auto simp add: rel_fun_def rel_nondetT_def elim: nondetT.rel_cases)"], ["", "lemma case_nondetT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_nondetT M ===> X) case_nondetT case_nondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> X) ===> rel_nondetT M ===> X) case_nondetT case_nondetT", "by(auto simp add: rel_fun_def rel_nondetT_def split: nondetT.split)"], ["", "lemma rec_nondetT_parametric [transfer_rule]:\n  \"((M ===> X) ===> rel_nondetT M ===> X) rec_nondetT rec_nondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> X) ===> rel_nondetT M ===> X) rec_nondetT rec_nondetT", "by(auto simp add: rel_fun_def elim: rel_nondetTE)"], ["", "end"], ["", "subsubsection \\<open>Generic implementation\\<close>"], ["", "type_synonym ('a, 'm, 's) merge = \"'s \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "locale nondetM_base = monad_base return bind\n  for return :: \"('s, 'm) return\"\n  and bind :: \"('s, 'm) bind\"\n  and merge :: \"('a, 'm, 's) merge\"\n  and empty :: \"'s\"\n  and single :: \"'a \\<Rightarrow> 's\"\n  and union :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"  (infixl \"\\<^bold>\\<union>\" 65)\nbegin"], ["", "definition return_nondet :: \"('a, ('a, 'm) nondetT) return\"\nwhere \"return_nondet x = NondetT (return (single x))\""], ["", "definition bind_nondet :: \"('a, ('a, 'm) nondetT) bind\"\nwhere \"bind_nondet m f = NondetT (bind (run_nondet m) (\\<lambda>A. merge A (run_nondet \\<circ> f)))\""], ["", "definition fail_nondet :: \"('a, 'm) nondetT fail\"\nwhere \"fail_nondet = NondetT (return empty)\""], ["", "definition alt_nondet :: \"('a, 'm) nondetT alt\"\nwhere \"alt_nondet m1 m2 = NondetT (bind (run_nondet m1) (\\<lambda>A. bind (run_nondet m2) (\\<lambda>B. return (A \\<^bold>\\<union> B))))\""], ["", "definition get_nondet :: \"('state, 'm) get \\<Rightarrow> ('state, ('a, 'm) nondetT) get\"\nwhere \"get_nondet get f = NondetT (get (\\<lambda>s. run_nondet (f s)))\" for get"], ["", "definition put_nondet :: \"('state, 'm) put \\<Rightarrow> ('state, ('a, 'm) nondetT) put\"\nwhere \"put_nondet put s m = NondetT (put s (run_nondet m))\" for put"], ["", "definition ask_nondet :: \"('r, 'm) ask \\<Rightarrow> ('r, ('a, 'm) nondetT) ask\"\nwhere \"ask_nondet ask f = NondetT (ask (\\<lambda>r. run_nondet (f r)))\""], ["", "text \\<open>\n  The canonical lift of sampling into @{typ \"(_, _) nondetT\"} does not satisfy @{const monad_prob},\n  because sampling does not distribute over bind backwards. Intuitively, if we sample first,\n  then the same sample is used in all non-deterministic choices. But if we sample later,\n  each non-deterministic choice may sample a different value.\n\\<close>"], ["", "lemma run_return_nondet [simp]: \"run_nondet (return_nondet x) = return (single x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (return_nondet x) = return (single x)", "by(simp add: return_nondet_def)"], ["", "lemma run_bind_nondet [simp]:\n  \"run_nondet (bind_nondet m f) = bind (run_nondet m) (\\<lambda>A. merge A (run_nondet \\<circ> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (bind_nondet m f) =\n    bind (run_nondet m) (\\<lambda>A. merge A (run_nondet \\<circ> f))", "by(simp add: bind_nondet_def)"], ["", "lemma run_fail_nondet [simp]: \"run_nondet fail_nondet = return empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet fail_nondet = return empty", "by(simp add: fail_nondet_def)"], ["", "lemma run_alt_nondet [simp]:\n  \"run_nondet (alt_nondet m1 m2) = bind (run_nondet m1) (\\<lambda>A. bind (run_nondet m2) (\\<lambda>B. return (A \\<^bold>\\<union> B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (alt_nondet m1 m2) =\n    bind (run_nondet m1)\n     (\\<lambda>A.\n         bind (run_nondet m2) (\\<lambda>B. return (A \\<^bold>\\<union> B)))", "by(simp add: alt_nondet_def)"], ["", "lemma run_get_nondet [simp]: \"run_nondet (get_nondet get f) = get (\\<lambda>s. run_nondet (f s))\" for get"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (get_nondet get f) = get (\\<lambda>s. run_nondet (f s))", "by(simp add: get_nondet_def)"], ["", "lemma run_put_nondet [simp]: \"run_nondet (put_nondet put s m) = put s (run_nondet m)\" for put"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (put_nondet put s m) = put s (run_nondet m)", "by(simp add: put_nondet_def)"], ["", "lemma run_ask_nondet [simp]: \"run_nondet (ask_nondet ask f) = ask (\\<lambda>r. run_nondet (f r))\" for ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (ask_nondet ask f) = ask (\\<lambda>r. run_nondet (f r))", "by(simp add: ask_nondet_def)"], ["", "end"], ["", "lemma bind_nondet_cong [cong]:\n  \"nondetM_base.bind_nondet bind merge = nondetM_base.bind_nondet bind merge\" for bind merge"], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM_base.bind_nondet bind merge =\n    nondetM_base.bind_nondet bind merge", ".."], ["", "lemmas [code] = \n  nondetM_base.return_nondet_def\n  nondetM_base.bind_nondet_def\n  nondetM_base.fail_nondet_def\n  nondetM_base.alt_nondet_def\n  nondetM_base.get_nondet_def\n  nondetM_base.put_nondet_def\n  nondetM_base.ask_nondet_def"], ["", "locale nondetM = nondetM_base return bind merge empty single union\n  +\n  monad_commute return bind\n  for return :: \"('s, 'm) return\"\n  and bind :: \"('s, 'm) bind\"\n  and merge :: \"('a, 'm, 's) merge\"\n  and empty :: \"'s\"\n  and single :: \"'a \\<Rightarrow> 's\"\n  and union :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" (infixl \"\\<^bold>\\<union>\" 65)\n  +\n  assumes bind_merge_merge:\n    \"\\<And>y f g. bind (merge y f) (\\<lambda>A. merge A g) = merge y (\\<lambda>x. bind (f x) (\\<lambda>A. merge A g))\"\n  and merge_empty: \"\\<And>f. merge empty f = return empty\"\n  and merge_single: \"\\<And>x f. merge (single x) f = f x\"\n  and merge_single2: \"\\<And>A. merge A (\\<lambda>x. return (single x)) = return A\"\n  and merge_union: \"\\<And>A B f. merge (A \\<^bold>\\<union> B) f = bind (merge A f) (\\<lambda>A'. bind (merge B f) (\\<lambda>B'. return (A' \\<^bold>\\<union> B')))\"\n  and union_assoc: \"\\<And>A B C. (A \\<^bold>\\<union> B) \\<^bold>\\<union> C = A \\<^bold>\\<union> (B \\<^bold>\\<union> C)\"\n  and empty_union: \"\\<And>A. empty \\<^bold>\\<union> A = A\"\n  and union_empty: \"\\<And>A. A \\<^bold>\\<union> empty = A\"\nbegin"], ["", "lemma monad_nondetT [locale_witness]: \"monad return_nondet bind_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return_nondet bind_nondet", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       bind_nondet (bind_nondet x f) g =\n       bind_nondet x (\\<lambda>y. bind_nondet (f y) g)\n 2. \\<And>x f. bind_nondet (return_nondet x) f = f x\n 3. \\<And>x. bind_nondet x return_nondet = x", "show \"bind_nondet (bind_nondet x f) g = bind_nondet x (\\<lambda>y. bind_nondet (f y) g)\" for x f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (bind_nondet x f) g =\n    bind_nondet x (\\<lambda>y. bind_nondet (f y) g)", "by(rule nondetT.expand)(simp add: bind_assoc bind_merge_merge o_def)"], ["proof (state)\nthis:\n  bind_nondet (bind_nondet ?x3 ?f3) ?g3 =\n  bind_nondet ?x3 (\\<lambda>y. bind_nondet (?f3 y) ?g3)\n\ngoal (2 subgoals):\n 1. \\<And>x f. bind_nondet (return_nondet x) f = f x\n 2. \\<And>x. bind_nondet x return_nondet = x", "show \"bind_nondet (return_nondet x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (return_nondet x) f = f x", "by(rule nondetT.expand)(simp add: return_bind merge_single)"], ["proof (state)\nthis:\n  bind_nondet (return_nondet ?x3) ?f3 = ?f3 ?x3\n\ngoal (1 subgoal):\n 1. \\<And>x. bind_nondet x return_nondet = x", "show \"bind_nondet x return_nondet = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet x return_nondet = x", "by(rule nondetT.expand)(simp add: bind_return o_def merge_single2)"], ["proof (state)\nthis:\n  bind_nondet ?x3 return_nondet = ?x3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_fail_nondetT [locale_witness]: \"monad_fail return_nondet bind_nondet fail_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return_nondet bind_nondet fail_nondet", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. bind_nondet fail_nondet f = fail_nondet", "show \"bind_nondet fail_nondet f = fail_nondet\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet fail_nondet f = fail_nondet", "by(rule nondetT.expand)(simp add: return_bind merge_empty)"], ["proof (state)\nthis:\n  bind_nondet fail_nondet ?f3 = fail_nondet\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_alt_nondetT [locale_witness]: \"monad_alt return_nondet bind_nondet alt_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return_nondet bind_nondet alt_nondet", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3.\n       alt_nondet (alt_nondet m1 m2) m3 = alt_nondet m1 (alt_nondet m2 m3)\n 2. \\<And>m m' f.\n       bind_nondet (alt_nondet m m') f =\n       alt_nondet (bind_nondet m f) (bind_nondet m' f)", "show \"alt_nondet (alt_nondet m1 m2) m3 = alt_nondet m1 (alt_nondet m2 m3)\" for m1 m2 m3"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_nondet (alt_nondet m1 m2) m3 = alt_nondet m1 (alt_nondet m2 m3)", "by(rule nondetT.expand)(simp add: bind_assoc return_bind union_assoc)"], ["proof (state)\nthis:\n  alt_nondet (alt_nondet ?m1.3 ?m2.3) ?m3.3 =\n  alt_nondet ?m1.3 (alt_nondet ?m2.3 ?m3.3)\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       bind_nondet (alt_nondet m m') f =\n       alt_nondet (bind_nondet m f) (bind_nondet m' f)", "show \"bind_nondet (alt_nondet m m') f = alt_nondet (bind_nondet m f) (bind_nondet m' f)\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (alt_nondet m m') f =\n    alt_nondet (bind_nondet m f) (bind_nondet m' f)", "apply(rule nondetT.expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (bind_nondet (alt_nondet m m') f) =\n    run_nondet (alt_nondet (bind_nondet m f) (bind_nondet m' f))", "apply(simp add: bind_assoc return_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m)\n     (\\<lambda>y.\n         bind (run_nondet m')\n          (\\<lambda>ya.\n              merge (y \\<^bold>\\<union> ya) (run_nondet \\<circ> f))) =\n    bind (run_nondet m)\n     (\\<lambda>y.\n         bind (merge y (run_nondet \\<circ> f))\n          (\\<lambda>A.\n              bind (run_nondet m')\n               (\\<lambda>y.\n                   bind (merge y (run_nondet \\<circ> f))\n                    (\\<lambda>B. return (A \\<^bold>\\<union> B)))))", "apply(subst (2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m)\n     (\\<lambda>y.\n         bind (run_nondet m')\n          (\\<lambda>ya.\n              merge (y \\<^bold>\\<union> ya) (run_nondet \\<circ> f))) =\n    bind (run_nondet m)\n     (\\<lambda>y.\n         bind (run_nondet m')\n          (\\<lambda>ya.\n              bind (merge y (run_nondet \\<circ> f))\n               (\\<lambda>x.\n                   bind (merge ya (run_nondet \\<circ> f))\n                    (\\<lambda>B. return (x \\<^bold>\\<union> B)))))", "apply(simp add: merge_union)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind_nondet (alt_nondet ?m3 ?m'3) ?f3 =\n  alt_nondet (bind_nondet ?m3 ?f3) (bind_nondet ?m'3 ?f3)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_fail_alt_nondetT [locale_witness]:\n  \"monad_fail_alt return_nondet bind_nondet fail_nondet alt_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt return_nondet bind_nondet fail_nondet alt_nondet", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. alt_nondet fail_nondet m = m\n 2. \\<And>m. alt_nondet m fail_nondet = m", "show \"alt_nondet fail_nondet m = m\" for  m"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_nondet fail_nondet m = m", "by(rule nondetT.expand)(simp add: return_bind bind_return empty_union)"], ["proof (state)\nthis:\n  alt_nondet fail_nondet ?m3 = ?m3\n\ngoal (1 subgoal):\n 1. \\<And>m. alt_nondet m fail_nondet = m", "show \"alt_nondet m fail_nondet = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_nondet m fail_nondet = m", "by(rule nondetT.expand)(simp add: return_bind bind_return union_empty)"], ["proof (state)\nthis:\n  alt_nondet ?m3 fail_nondet = ?m3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_nondetT [locale_witness]:\n  \\<comment> \\<open>It's not really sensible to assume a commutative state monad, but let's prove it anyway ...\\<close>\n  fixes get put\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)", "interpret monad_state return bind get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return bind get put", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f. put_nondet put s (get_nondet get f) = put_nondet put s (f s)\n 2. \\<And>f.\n       get_nondet get (\\<lambda>s. get_nondet get (f s)) =\n       get_nondet get (\\<lambda>s. f s s)\n 3. \\<And>s s' m.\n       put_nondet put s (put_nondet put s' m) = put_nondet put s' m\n 4. \\<And>m. get_nondet get (\\<lambda>s. put_nondet put s m) = m\n 5. \\<And>m. get_nondet get (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 7. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"put_nondet put s (get_nondet get f) = put_nondet put s (f s)\" for s f"], ["proof (prove)\ngoal (1 subgoal):\n 1. put_nondet put s (get_nondet get f) = put_nondet put s (f s)", "by(rule nondetT.expand)(simp add: put_get)"], ["proof (state)\nthis:\n  put_nondet put ?s3 (get_nondet get ?f3) = put_nondet put ?s3 (?f3 ?s3)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       get_nondet get (\\<lambda>s. get_nondet get (f s)) =\n       get_nondet get (\\<lambda>s. f s s)\n 2. \\<And>s s' m.\n       put_nondet put s (put_nondet put s' m) = put_nondet put s' m\n 3. \\<And>m. get_nondet get (\\<lambda>s. put_nondet put s m) = m\n 4. \\<And>m. get_nondet get (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 6. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"get_nondet get (\\<lambda>s. get_nondet get (f s)) = get_nondet get (\\<lambda>s. f s s)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_nondet get (\\<lambda>s. get_nondet get (f s)) =\n    get_nondet get (\\<lambda>s. f s s)", "by(rule nondetT.expand)(simp add: get_get)"], ["proof (state)\nthis:\n  get_nondet get (\\<lambda>s. get_nondet get (?f3 s)) =\n  get_nondet get (\\<lambda>s. ?f3 s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m.\n       put_nondet put s (put_nondet put s' m) = put_nondet put s' m\n 2. \\<And>m. get_nondet get (\\<lambda>s. put_nondet put s m) = m\n 3. \\<And>m. get_nondet get (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 5. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"put_nondet put s (put_nondet put s' m) = put_nondet put s' m\" for s s' m"], ["proof (prove)\ngoal (1 subgoal):\n 1. put_nondet put s (put_nondet put s' m) = put_nondet put s' m", "by(rule nondetT.expand)(simp add: put_put)"], ["proof (state)\nthis:\n  put_nondet put ?s3 (put_nondet put ?s'3 ?m3) = put_nondet put ?s'3 ?m3\n\ngoal (4 subgoals):\n 1. \\<And>m. get_nondet get (\\<lambda>s. put_nondet put s m) = m\n 2. \\<And>m. get_nondet get (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 4. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"get_nondet get (\\<lambda>s. put_nondet put s m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_nondet get (\\<lambda>s. put_nondet put s m) = m", "by(rule nondetT.expand)(simp add: get_put)"], ["proof (state)\nthis:\n  get_nondet get (\\<lambda>s. put_nondet put s ?m3) = ?m3\n\ngoal (3 subgoals):\n 1. \\<And>m. get_nondet get (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 3. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"get_nondet get (\\<lambda>_. m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. get_nondet get (\\<lambda>_. m) = m", "by(rule nondetT.expand)(simp add: get_const)"], ["proof (state)\nthis:\n  get_nondet get (\\<lambda>_. ?m3) = ?m3\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       bind_nondet (get_nondet get f) g =\n       get_nondet get (\\<lambda>s. bind_nondet (f s) g)\n 2. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"bind_nondet (get_nondet get f) g = get_nondet get (\\<lambda>s. bind_nondet (f s) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (get_nondet get f) g =\n    get_nondet get (\\<lambda>s. bind_nondet (f s) g)", "by(rule nondetT.expand)(simp add: bind_get)"], ["proof (state)\nthis:\n  bind_nondet (get_nondet get ?f3) ?g3 =\n  get_nondet get (\\<lambda>s. bind_nondet (?f3 s) ?g3)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       bind_nondet (put_nondet put s m) f =\n       put_nondet put s (bind_nondet m f)", "show \"bind_nondet (put_nondet put s m) f = put_nondet put s (bind_nondet m f)\" for s m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (put_nondet put s m) f = put_nondet put s (bind_nondet m f)", "by(rule nondetT.expand)(simp add: bind_put)"], ["proof (state)\nthis:\n  bind_nondet (put_nondet put ?s3 ?m3) ?f3 =\n  put_nondet put ?s3 (bind_nondet ?m3 ?f3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state return_nondet bind_nondet (get_nondet get) (put_nondet put)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_alt_nondetT [locale_witness]:\n  fixes get put\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state_alt return_nondet bind_nondet (get_nondet get) (put_nondet put) alt_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt return_nondet bind_nondet (get_nondet get)\n     (put_nondet put) alt_nondet", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt return_nondet bind_nondet (get_nondet get)\n     (put_nondet put) alt_nondet", "interpret monad_state return bind get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return bind get put", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt return_nondet bind_nondet (get_nondet get)\n     (put_nondet put) alt_nondet", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt return_nondet bind_nondet (get_nondet get)\n     (put_nondet put) alt_nondet", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       alt_nondet (get_nondet get f) (get_nondet get g) =\n       get_nondet get (\\<lambda>x. alt_nondet (f x) (g x))\n 2. \\<And>s m m'.\n       alt_nondet (put_nondet put s m) (put_nondet put s m') =\n       put_nondet put s (alt_nondet m m')", "show \"alt_nondet (get_nondet get f) (get_nondet get g) = get_nondet get (\\<lambda>x. alt_nondet (f x) (g x))\"\n      for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_nondet (get_nondet get f) (get_nondet get g) =\n    get_nondet get (\\<lambda>x. alt_nondet (f x) (g x))", "apply(rule nondetT.expand; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (get (\\<lambda>s. run_nondet (f s)))\n     (\\<lambda>A.\n         bind (get (\\<lambda>s. run_nondet (g s)))\n          (\\<lambda>B. return (A \\<^bold>\\<union> B))) =\n    get (\\<lambda>s.\n            bind (run_nondet (f s))\n             (\\<lambda>A.\n                 bind (run_nondet (g s))\n                  (\\<lambda>B. return (A \\<^bold>\\<union> B))))", "apply(subst bind_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            bind (run_nondet (f s))\n             (\\<lambda>A.\n                 bind (get (\\<lambda>s. run_nondet (g s)))\n                  (\\<lambda>B. return (A \\<^bold>\\<union> B)))) =\n    get (\\<lambda>s.\n            bind (run_nondet (f s))\n             (\\<lambda>A.\n                 bind (run_nondet (g s))\n                  (\\<lambda>B. return (A \\<^bold>\\<union> B))))", "apply(subst (1 2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            bind (get (\\<lambda>s. run_nondet (g s)))\n             (\\<lambda>y.\n                 bind (run_nondet (f s))\n                  (\\<lambda>x. return (x \\<^bold>\\<union> y)))) =\n    get (\\<lambda>s.\n            bind (run_nondet (g s))\n             (\\<lambda>y.\n                 bind (run_nondet (f s))\n                  (\\<lambda>x. return (x \\<^bold>\\<union> y))))", "apply(simp add: bind_get get_get)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  alt_nondet (get_nondet get ?f3) (get_nondet get ?g3) =\n  get_nondet get (\\<lambda>x. alt_nondet (?f3 x) (?g3 x))\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       alt_nondet (put_nondet put s m) (put_nondet put s m') =\n       put_nondet put s (alt_nondet m m')", "show \"alt_nondet (put_nondet put s m) (put_nondet put s m') = put_nondet put s (alt_nondet m m')\"\n      for s m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. alt_nondet (put_nondet put s m) (put_nondet put s m') =\n    put_nondet put s (alt_nondet m m')", "apply(rule nondetT.expand; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (put s (run_nondet m))\n     (\\<lambda>A.\n         bind (put s (run_nondet m'))\n          (\\<lambda>B. return (A \\<^bold>\\<union> B))) =\n    put s\n     (bind (run_nondet m)\n       (\\<lambda>A.\n           bind (run_nondet m')\n            (\\<lambda>B. return (A \\<^bold>\\<union> B))))", "apply(subst bind_put)"], ["proof (prove)\ngoal (1 subgoal):\n 1. put s\n     (bind (run_nondet m)\n       (\\<lambda>A.\n           bind (put s (run_nondet m'))\n            (\\<lambda>B. return (A \\<^bold>\\<union> B)))) =\n    put s\n     (bind (run_nondet m)\n       (\\<lambda>A.\n           bind (run_nondet m')\n            (\\<lambda>B. return (A \\<^bold>\\<union> B))))", "apply(subst (1 2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. put s\n     (bind (put s (run_nondet m'))\n       (\\<lambda>y.\n           bind (run_nondet m)\n            (\\<lambda>x. return (x \\<^bold>\\<union> y)))) =\n    put s\n     (bind (run_nondet m')\n       (\\<lambda>y.\n           bind (run_nondet m) (\\<lambda>x. return (x \\<^bold>\\<union> y))))", "apply(simp add: bind_put put_put)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  alt_nondet (put_nondet put ?s3 ?m3) (put_nondet put ?s3 ?m'3) =\n  put_nondet put ?s3 (alt_nondet ?m3 ?m'3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_alt return_nondet bind_nondet (get_nondet get)\n   (put_nondet put) alt_nondet\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas nondetM_lemmas =\n  nondetM.monad_nondetT\n  nondetM.monad_fail_nondetT\n  nondetM.monad_alt_nondetT\n  nondetM.monad_fail_alt_nondetT\n  nondetM.monad_state_nondetT"], ["", "locale nondetM_ask = nondetM return bind merge empty single union\n  for return :: \"('s, 'm) return\"\n  and bind :: \"('s, 'm) bind\"\n  and ask :: \"('r, 'm) ask\"\n  and merge :: \"('a, 'm, 's) merge\"\n  and empty :: \"'s\"\n  and single :: \"'a \\<Rightarrow> 's\"\n  and union :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\" (infixl \"\\<^bold>\\<union>\" 65)\n  +\n  assumes monad_reader: \"monad_reader return bind ask\"\n  assumes merge_ask:\n    \"\\<And>A (f :: 'a \\<Rightarrow> 'r \\<Rightarrow> ('a, 'm) nondetT). merge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n     ask (\\<lambda>r. merge A (\\<lambda>x. run_nondet (f x r)))\"\nbegin"], ["", "interpretation monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by(fact monad_reader)"], ["", "lemma monad_reader_nondetT: \"monad_reader return_nondet bind_nondet (ask_nondet ask)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return_nondet bind_nondet (ask_nondet ask)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       ask_nondet ask (\\<lambda>r. ask_nondet ask (f r)) =\n       ask_nondet ask (\\<lambda>r. f r r)\n 2. \\<And>m. ask_nondet ask (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       bind_nondet (ask_nondet ask f) g =\n       ask_nondet ask (\\<lambda>r. bind_nondet (f r) g)\n 4. \\<And>m f.\n       bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) =\n       ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))", "show \"ask_nondet ask (\\<lambda>r. ask_nondet ask (f r)) = ask_nondet ask (\\<lambda>r. f r r)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. ask_nondet ask (\\<lambda>r. ask_nondet ask (f r)) =\n    ask_nondet ask (\\<lambda>r. f r r)", "by(rule nondetT.expand)(simp add: ask_ask)"], ["proof (state)\nthis:\n  ask_nondet ask (\\<lambda>r. ask_nondet ask (?f3 r)) =\n  ask_nondet ask (\\<lambda>r. ?f3 r r)\n\ngoal (3 subgoals):\n 1. \\<And>m. ask_nondet ask (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       bind_nondet (ask_nondet ask f) g =\n       ask_nondet ask (\\<lambda>r. bind_nondet (f r) g)\n 3. \\<And>m f.\n       bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) =\n       ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))", "show \"ask_nondet ask (\\<lambda>_. m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. ask_nondet ask (\\<lambda>_. m) = m", "by(rule nondetT.expand)(simp add: ask_const)"], ["proof (state)\nthis:\n  ask_nondet ask (\\<lambda>_. ?m3) = ?m3\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       bind_nondet (ask_nondet ask f) g =\n       ask_nondet ask (\\<lambda>r. bind_nondet (f r) g)\n 2. \\<And>m f.\n       bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) =\n       ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))", "show \"bind_nondet (ask_nondet ask f) g = ask_nondet ask (\\<lambda>r. bind_nondet (f r) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (ask_nondet ask f) g =\n    ask_nondet ask (\\<lambda>r. bind_nondet (f r) g)", "by(rule nondetT.expand)(simp add: bind_ask)"], ["proof (state)\nthis:\n  bind_nondet (ask_nondet ask ?f3) ?g3 =\n  ask_nondet ask (\\<lambda>r. bind_nondet (?f3 r) ?g3)\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) =\n       ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))", "show \"bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) = ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))\" for f m"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet m (\\<lambda>x. ask_nondet ask (f x)) =\n    ask_nondet ask (\\<lambda>r. bind_nondet m (\\<lambda>x. f x r))", "by(rule nondetT.expand)(simp add: bind_ask2[symmetric] o_def merge_ask)"], ["proof (state)\nthis:\n  bind_nondet ?m3 (\\<lambda>x. ask_nondet ask (?f3 x)) =\n  ask_nondet ask (\\<lambda>r. bind_nondet ?m3 (\\<lambda>x. ?f3 x r))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemmas nondetM_ask_lemmas =\n  nondetM_ask.monad_reader_nondetT"], ["", "subsubsection \\<open>Parametricity\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma return_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> (A ===> S) ===> A ===> rel_nondetT M)\n   nondetM_base.return_nondet nondetM_base.return_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===> (A ===> S) ===> A ===> rel_nondetT M)\n     nondetM_base.return_nondet nondetM_base.return_nondet", "unfolding nondetM_base.return_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===> (A ===> S) ===> A ===> rel_nondetT M)\n     (\\<lambda>return single x. NondetT (return (single x)))\n     (\\<lambda>return single x. NondetT (return (single x)))", "by transfer_prover"], ["", "lemma bind_nondet_parametric [transfer_rule]:\n  \"((M ===> (S ===> M) ===> M) ===> (S ===> (A ===> M) ===> M) ===> \n    rel_nondetT M ===> (A ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.bind_nondet nondetM_base.bind_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (S ===> M) ===> M) ===>\n     (S ===> (A ===> M) ===> M) ===>\n     rel_nondetT M ===> (A ===> rel_nondetT M) ===> rel_nondetT M)\n     nondetM_base.bind_nondet nondetM_base.bind_nondet", "unfolding nondetM_base.bind_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (S ===> M) ===> M) ===>\n     (S ===> (A ===> M) ===> M) ===>\n     rel_nondetT M ===> (A ===> rel_nondetT M) ===> rel_nondetT M)\n     (\\<lambda>bind merge m f.\n         NondetT\n          (bind (run_nondet m)\n            (\\<lambda>A. merge A (run_nondet \\<circ> f))))\n     (\\<lambda>bind merge m f.\n         NondetT\n          (bind (run_nondet m)\n            (\\<lambda>A. merge A (run_nondet \\<circ> f))))", "by transfer_prover"], ["", "lemma fail_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> S ===> rel_nondetT M) nondetM_base.fail_nondet nondetM_base.fail_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===> S ===> rel_nondetT M) nondetM_base.fail_nondet\n     nondetM_base.fail_nondet", "unfolding nondetM_base.fail_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===> S ===> rel_nondetT M)\n     (\\<lambda>return empty. NondetT (return empty))\n     (\\<lambda>return empty. NondetT (return empty))", "by transfer_prover"], ["", "lemma alt_nondet_parametric [transfer_rule]:\n  \"((S ===> M) ===> (M ===> (S ===> M) ===> M) ===> (S ===> S ===> S) ===>\n    rel_nondetT M ===> rel_nondetT M ===> rel_nondetT M)\n   nondetM_base.alt_nondet nondetM_base.alt_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===>\n     (M ===> (S ===> M) ===> M) ===>\n     (S ===> S ===> S) ===>\n     rel_nondetT M ===> rel_nondetT M ===> rel_nondetT M)\n     nondetM_base.alt_nondet nondetM_base.alt_nondet", "unfolding nondetM_base.alt_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===>\n     (M ===> (S ===> M) ===> M) ===>\n     (S ===> S ===> S) ===>\n     rel_nondetT M ===> rel_nondetT M ===> rel_nondetT M)\n     (\\<lambda>return bind union m1 m2.\n         NondetT\n          (bind (run_nondet m1)\n            (\\<lambda>A.\n                bind (run_nondet m2) (\\<lambda>B. return (union A B)))))\n     (\\<lambda>return bind union m1 m2.\n         NondetT\n          (bind (run_nondet m1)\n            (\\<lambda>A.\n                bind (run_nondet m2) (\\<lambda>B. return (union A B)))))", "by transfer_prover"], ["", "lemma get_nondet_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.get_nondet nondetM_base.get_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===> (S ===> rel_nondetT M) ===> rel_nondetT M)\n     nondetM_base.get_nondet nondetM_base.get_nondet", "unfolding nondetM_base.get_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===> (S ===> rel_nondetT M) ===> rel_nondetT M)\n     (\\<lambda>get f. NondetT (get (\\<lambda>s. run_nondet (f s))))\n     (\\<lambda>get f. NondetT (get (\\<lambda>s. run_nondet (f s))))", "by transfer_prover"], ["", "lemma put_nondet_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_nondetT M ===> rel_nondetT M) \n   nondetM_base.put_nondet nondetM_base.put_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_nondetT M ===> rel_nondetT M)\n     nondetM_base.put_nondet nondetM_base.put_nondet", "unfolding nondetM_base.put_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_nondetT M ===> rel_nondetT M)\n     (\\<lambda>put s m. NondetT (put s (run_nondet m)))\n     (\\<lambda>put s m. NondetT (put s (run_nondet m)))", "by transfer_prover"], ["", "lemma ask_nondet_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_nondetT M) ===> rel_nondetT M)\n   nondetM_base.ask_nondet nondetM_base.ask_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_nondetT M) ===> rel_nondetT M)\n     nondetM_base.ask_nondet nondetM_base.ask_nondet", "unfolding nondetM_base.ask_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_nondetT M) ===> rel_nondetT M)\n     (\\<lambda>ask f. NondetT (ask (\\<lambda>r. run_nondet (f r))))\n     (\\<lambda>ask f. NondetT (ask (\\<lambda>r. run_nondet (f r))))", "by transfer_prover"], ["", "end"], ["", "subsubsection \\<open>Implementation using lists\\<close>"], ["", "context \n  fixes return :: \"('a list, 'm) return\"\n    and bind :: \"('a list, 'm) bind\"\n    and lunionM lUnionM \n  defines \"lunionM m1 m2 \\<equiv> bind m1 (\\<lambda>A. bind m2 (\\<lambda>B. return (A @ B)))\"\n    and \"lUnionM ms \\<equiv> foldr lunionM ms (return [])\"\nbegin"], ["", "definition lmerge :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\" where\n  \"lmerge A f = lUnionM (map f A)\""], ["", "context\n  assumes \"monad_commute return bind\"\nbegin"], ["", "interpretation monad_commute return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return bind", "by fact"], ["", "interpretation nondetM_base return bind lmerge \"[]\" \"\\<lambda>x. [x]\" \"(@)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma lUnionM_empty [simp]: \"lUnionM [] = return []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lUnionM [] = return []", "by(simp add: lUnionM_def)"], ["", "lemma lUnionM_Cons [simp]: \"lUnionM (x # M) = lunionM x (lUnionM M)\" for x M"], ["proof (prove)\ngoal (1 subgoal):\n 1. lUnionM (x # M) = lunionM x (lUnionM M)", "by(simp add: lUnionM_def)"], ["", "lemma lunionM_return_empty1 [simp]: \"lunionM (return []) x = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunionM (return []) x = x", "by(simp add: lunionM_def return_bind bind_return)"], ["", "lemma lunionM_return_empty2 [simp]: \"lunionM x (return []) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunionM x (return []) = x", "by(simp add: lunionM_def return_bind bind_return)"], ["", "lemma lunionM_return_return [simp]: \"lunionM (return A) (return B) = return (A @ B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunionM (return A) (return B) = return (A @ B)", "by(simp add: lunionM_def return_bind)"], ["", "lemma lunionM_assoc: \"lunionM (lunionM x y) z = lunionM x (lunionM y z)\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunionM (lunionM x y) z = lunionM x (lunionM y z)", "by(simp add: lunionM_def bind_assoc return_bind)"], ["", "lemma lunionM_lUnionM1: \"lunionM (lUnionM A) x = foldr lunionM A x\" for A x"], ["proof (prove)\ngoal (1 subgoal):\n 1. lunionM (lUnionM A) x = foldr lunionM A x", "by(induction A arbitrary: x)(simp_all add: lunionM_assoc)"], ["", "lemma lUnionM_append [simp]: \"lUnionM (A @ B) = lunionM (lUnionM A) (lUnionM B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. lUnionM (A @ B) = lunionM (lUnionM A) (lUnionM B)", "by(subst lunionM_lUnionM1)(simp add: lUnionM_def)"], ["", "lemma lUnionM_return [simp]: \"lUnionM (map (\\<lambda>x. return [x]) A) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. lUnionM (map (\\<lambda>x. return [x]) A) = return A", "by(induction A) simp_all"], ["", "lemma bind_lunionM: \"bind (lunionM m m') f = lunionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A @ B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x @ y)))\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (lunionM m m') f = lunionM (bind m f) (bind m' f)", "apply(simp add: bind_assoc return_bind lunionM_def that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind m'\n          (\\<lambda>ya.\n              bind (f y)\n               (\\<lambda>x. bind (f ya) (\\<lambda>y. return (x @ y))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y. bind (f y) (\\<lambda>B. return (A @ B)))))", "apply(subst (2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>y.\n              bind m'\n               (\\<lambda>x. bind (f x) (\\<lambda>ya. return (y @ ya))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y. bind (f y) (\\<lambda>B. return (A @ B)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma list_nondetM: \"nondetM return bind lmerge [] (\\<lambda>x. [x]) (@)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM return bind local.lmerge [] (\\<lambda>x. [x]) (@)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>y f g.\n       bind (local.lmerge y f) (\\<lambda>A. local.lmerge A g) =\n       local.lmerge y\n        (\\<lambda>x. bind (f x) (\\<lambda>A. local.lmerge A g))\n 2. \\<And>f. local.lmerge [] f = return []\n 3. \\<And>x f. local.lmerge [x] f = f x\n 4. \\<And>A. local.lmerge A (\\<lambda>x. return [x]) = return A\n 5. \\<And>A B f.\n       local.lmerge (A @ B) f =\n       bind (local.lmerge A f)\n        (\\<lambda>A'.\n            bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))\n 6. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 7. \\<And>A. [] @ A = A\n 8. \\<And>A. A @ [] = A", "show \"bind (lmerge y f) (\\<lambda>A. lmerge A g) = lmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. lmerge A g))\" for y f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (local.lmerge y f) (\\<lambda>A. local.lmerge A g) =\n    local.lmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. local.lmerge A g))", "apply(induction y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bind (local.lmerge [] f) (\\<lambda>A. local.lmerge A g) =\n    local.lmerge [] (\\<lambda>x. bind (f x) (\\<lambda>A. local.lmerge A g))\n 2. \\<And>a y.\n       bind (local.lmerge y f) (\\<lambda>A. local.lmerge A g) =\n       local.lmerge y\n        (\\<lambda>x.\n            bind (f x) (\\<lambda>A. local.lmerge A g)) \\<Longrightarrow>\n       bind (local.lmerge (a # y) f) (\\<lambda>A. local.lmerge A g) =\n       local.lmerge (a # y)\n        (\\<lambda>x. bind (f x) (\\<lambda>A. local.lmerge A g))", "apply(simp_all add: lmerge_def return_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       bind (lUnionM (map f y)) (\\<lambda>A. lUnionM (map g A)) =\n       lUnionM\n        (map (\\<lambda>x. bind (f x) (\\<lambda>A. lUnionM (map g A)))\n          y) \\<Longrightarrow>\n       bind (lunionM (f a) (lUnionM (map f y)))\n        (\\<lambda>A. lUnionM (map g A)) =\n       lunionM (bind (f a) (\\<lambda>A. lUnionM (map g A)))\n        (lUnionM\n          (map (\\<lambda>x. bind (f x) (\\<lambda>A. lUnionM (map g A))) y))", "apply(subst bind_lunionM; simp add: lunionM_def o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind (local.lmerge ?y1 ?f1) (\\<lambda>A. local.lmerge A ?g1) =\n  local.lmerge ?y1\n   (\\<lambda>x. bind (?f1 x) (\\<lambda>A. local.lmerge A ?g1))\n\ngoal (7 subgoals):\n 1. \\<And>f. local.lmerge [] f = return []\n 2. \\<And>x f. local.lmerge [x] f = f x\n 3. \\<And>A. local.lmerge A (\\<lambda>x. return [x]) = return A\n 4. \\<And>A B f.\n       local.lmerge (A @ B) f =\n       bind (local.lmerge A f)\n        (\\<lambda>A'.\n            bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))\n 5. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 6. \\<And>A. [] @ A = A\n 7. \\<And>A. A @ [] = A", "show \"lmerge [] f = return []\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lmerge [] f = return []", "by(simp add: lmerge_def)"], ["proof (state)\nthis:\n  local.lmerge [] ?f1 = return []\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.lmerge [x] f = f x\n 2. \\<And>A. local.lmerge A (\\<lambda>x. return [x]) = return A\n 3. \\<And>A B f.\n       local.lmerge (A @ B) f =\n       bind (local.lmerge A f)\n        (\\<lambda>A'.\n            bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))\n 4. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 5. \\<And>A. [] @ A = A\n 6. \\<And>A. A @ [] = A", "show \"lmerge [x] f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lmerge [x] f = f x", "by(simp add: lmerge_def)"], ["proof (state)\nthis:\n  local.lmerge [?x1] ?f1 = ?f1 ?x1\n\ngoal (5 subgoals):\n 1. \\<And>A. local.lmerge A (\\<lambda>x. return [x]) = return A\n 2. \\<And>A B f.\n       local.lmerge (A @ B) f =\n       bind (local.lmerge A f)\n        (\\<lambda>A'.\n            bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))\n 3. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 4. \\<And>A. [] @ A = A\n 5. \\<And>A. A @ [] = A", "show \"lmerge A (\\<lambda>x. return [x]) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lmerge A (\\<lambda>x. return [x]) = return A", "by(simp add: lmerge_def)"], ["proof (state)\nthis:\n  local.lmerge ?A1 (\\<lambda>x. return [x]) = return ?A1\n\ngoal (4 subgoals):\n 1. \\<And>A B f.\n       local.lmerge (A @ B) f =\n       bind (local.lmerge A f)\n        (\\<lambda>A'.\n            bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))\n 2. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 3. \\<And>A. [] @ A = A\n 4. \\<And>A. A @ [] = A", "show \"lmerge (A @ B) f = bind (lmerge A f) (\\<lambda>A'. bind (lmerge B f) (\\<lambda>B'. return (A' @ B')))\"\n    for f A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lmerge (A @ B) f =\n    bind (local.lmerge A f)\n     (\\<lambda>A'. bind (local.lmerge B f) (\\<lambda>B'. return (A' @ B')))", "by(simp add: lmerge_def lunionM_def)"], ["proof (state)\nthis:\n  local.lmerge (?A1 @ ?B1) ?f1 =\n  bind (local.lmerge ?A1 ?f1)\n   (\\<lambda>A'.\n       bind (local.lmerge ?B1 ?f1) (\\<lambda>B'. return (A' @ B')))\n\ngoal (3 subgoals):\n 1. \\<And>A B C. (A @ B) @ C = A @ B @ C\n 2. \\<And>A. [] @ A = A\n 3. \\<And>A. A @ [] = A", "qed simp_all"], ["", "lemma list_nondetM_ask:\n  notes list_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask lmerge [] (\\<lambda>x. [x]) (@)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM_ask return bind ask local.lmerge [] (\\<lambda>x. [x]) (@)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.lmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.lmerge A (\\<lambda>x. run_nondet (f x r)))", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.lmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.lmerge A (\\<lambda>x. run_nondet (f x r)))", "show \"lmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) = ask (\\<lambda>r. lmerge A (\\<lambda>x. run_nondet (f x r)))\"\n    for A and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'm) nondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.lmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n    ask (\\<lambda>r. local.lmerge A (\\<lambda>x. run_nondet (f x r)))", "unfolding lmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lUnionM (map (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) A) =\n    ask (\\<lambda>r. lUnionM (map (\\<lambda>x. run_nondet (f x r)) A))", "by(induction A)(simp_all add: ask_const lunionM_def bind_ask bind_ask2 ask_ask)"], ["proof (state)\nthis:\n  local.lmerge ?A1 (\\<lambda>x. ask (\\<lambda>r. run_nondet (?f1 x r))) =\n  ask (\\<lambda>r. local.lmerge ?A1 (\\<lambda>x. run_nondet (?f1 x r)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas list_nondetMs [locale_witness] =\n  nondetM_lemmas[OF list_nondetM]\n  nondetM_ask_lemmas[OF list_nondetM_ask]"], ["", "end"], ["", "end"], ["", "lemma lmerge_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((list_all2 A ===> M) ===> (M ===> (list_all2 A ===> M) ===> M)\n    ===> list_all2 A ===> (A ===> M) ===> M)\n   lmerge lmerge\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((list_all2 A ===> M) ===>\n     (M ===> (list_all2 A ===> M) ===> M) ===>\n     list_all2 A ===> (A ===> M) ===> M)\n     lmerge lmerge", "unfolding lmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((list_all2 A ===> M) ===>\n     (M ===> (list_all2 A ===> M) ===> M) ===>\n     list_all2 A ===> (A ===> M) ===> M)\n     (\\<lambda>return bind A f.\n         foldr\n          (\\<lambda>m1 m2.\n              bind m1 (\\<lambda>A. bind m2 (\\<lambda>B. return (A @ B))))\n          (map f A) (return []))\n     (\\<lambda>return bind A f.\n         foldr\n          (\\<lambda>m1 m2.\n              bind m1 (\\<lambda>A. bind m2 (\\<lambda>B. return (A @ B))))\n          (map f A) (return []))", "by transfer_prover"], ["", "subsubsection \\<open>Implementation using multisets\\<close>"], ["", "context \n  fixes return :: \"('a multiset, 'm) return\"\n    and bind :: \"('a multiset, 'm) bind\"\n    and munionM mUnionM\n  defines \"munionM m1 m2 \\<equiv> bind m1 (\\<lambda>A. bind m2 (\\<lambda>B. return (A + B)))\"\n    and \"mUnionM \\<equiv> fold_mset munionM (return {#})\"\nbegin"], ["", "definition mmerge :: \"'a multiset \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\"\nwhere \"mmerge A f = mUnionM (image_mset f A)\""], ["", "context\n  assumes \"monad_commute return bind\"\nbegin"], ["", "interpretation monad_commute return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return bind", "by fact"], ["", "interpretation nondetM_base return bind mmerge \"{#}\" \"\\<lambda>x. {#x#}\" \"(+)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma munionM_comp_fun_commute: \"comp_fun_commute munionM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute munionM", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x. munionM y \\<circ> munionM x = munionM x \\<circ> munionM y", "apply(simp add: fun_eq_iff bind_assoc return_bind munionM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<forall>xa.\n          bind y\n           (\\<lambda>A.\n               bind x\n                (\\<lambda>y.\n                    bind xa (\\<lambda>ya. return (A + (y + ya))))) =\n          bind x\n           (\\<lambda>A.\n               bind y\n                (\\<lambda>y. bind xa (\\<lambda>ya. return (A + (y + ya)))))", "apply(subst bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<forall>xa.\n          bind x\n           (\\<lambda>ya.\n               bind y\n                (\\<lambda>x. bind xa (\\<lambda>y. return (x + (ya + y))))) =\n          bind x\n           (\\<lambda>A.\n               bind y\n                (\\<lambda>y. bind xa (\\<lambda>ya. return (A + (y + ya)))))", "apply(simp add: union_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation comp_fun_commute munionM"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute munionM", "by(rule munionM_comp_fun_commute)"], ["", "lemma mUnionM_empty [simp]: \"mUnionM {#} = return {#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mUnionM {#} = return {#}", "by(simp add: mUnionM_def)"], ["", "lemma mUnionM_add_mset [simp]: \"mUnionM (add_mset x M) = munionM x (mUnionM M)\" for x M"], ["proof (prove)\ngoal (1 subgoal):\n 1. mUnionM (add_mset x M) = munionM x (mUnionM M)", "by(simp add: mUnionM_def)"], ["", "lemma munionM_return_empty1 [simp]: \"munionM (return {#}) x = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM (return {#}) x = x", "by(simp add: munionM_def return_bind bind_return)"], ["", "lemma munionM_return_empty2 [simp]: \"munionM x (return {#}) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM x (return {#}) = x", "by(simp add: munionM_def return_bind bind_return)"], ["", "lemma munionM_return_return [simp]: \"munionM (return A) (return B) = return (A + B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM (return A) (return B) = return (A + B)", "by(simp add: munionM_def return_bind)"], ["", "lemma munionM_assoc: \"munionM (munionM x y) z = munionM x (munionM y z)\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM (munionM x y) z = munionM x (munionM y z)", "by(simp add: munionM_def bind_assoc return_bind add.assoc)"], ["", "lemma munionM_commute: \"munionM x y = munionM y x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM x y = munionM y x", "unfolding munionM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind x (\\<lambda>A. bind y (\\<lambda>B. return (A + B))) =\n    bind y (\\<lambda>A. bind x (\\<lambda>B. return (A + B)))", "by(subst bind_commute)(simp add: add.commute)"], ["", "lemma munionM_mUnionM1: \"munionM (mUnionM A) x = fold_mset munionM x A\" for A x"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM (mUnionM A) x = fold_mset munionM x A", "by(induction A arbitrary: x)(simp_all add: munionM_assoc)"], ["", "lemma munionM_mUnionM2: \"munionM x (mUnionM A) = fold_mset munionM x A\" for x A"], ["proof (prove)\ngoal (1 subgoal):\n 1. munionM x (mUnionM A) = fold_mset munionM x A", "by(subst munionM_commute)(rule munionM_mUnionM1)"], ["", "lemma mUnionM_add [simp]: \"mUnionM (A + B) = munionM (mUnionM A) (mUnionM B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. mUnionM (A + B) = munionM (mUnionM A) (mUnionM B)", "by(subst munionM_mUnionM2)(simp add: mUnionM_def)"], ["", "lemma mUnionM_return [simp]: \"mUnionM (image_mset (\\<lambda>x. return {#x#}) A) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. mUnionM {#return {#x#}. x \\<in># A#} = return A", "by(induction A) simp_all"], ["", "lemma bind_munionM: \"bind (munionM m m') f = munionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A + B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x + y)))\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (munionM m m') f = munionM (bind m f) (bind m' f)", "apply(simp add: bind_assoc return_bind munionM_def that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind m'\n          (\\<lambda>ya.\n              bind (f y)\n               (\\<lambda>x. bind (f ya) (\\<lambda>y. return (x + y))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y. bind (f y) (\\<lambda>B. return (A + B)))))", "apply(subst (2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>y.\n              bind m'\n               (\\<lambda>x. bind (f x) (\\<lambda>ya. return (y + ya))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y. bind (f y) (\\<lambda>B. return (A + B)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mset_nondetM: \"nondetM return bind mmerge {#} (\\<lambda>x. {#x#}) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM return bind local.mmerge {#} (\\<lambda>x. {#x#}) (+)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>y f g.\n       bind (local.mmerge y f) (\\<lambda>A. local.mmerge A g) =\n       local.mmerge y\n        (\\<lambda>x. bind (f x) (\\<lambda>A. local.mmerge A g))\n 2. \\<And>f. local.mmerge {#} f = return {#}\n 3. \\<And>x f. local.mmerge {#x#} f = f x\n 4. \\<And>A. local.mmerge A (\\<lambda>x. return {#x#}) = return A\n 5. \\<And>A B f.\n       local.mmerge (A + B) f =\n       bind (local.mmerge A f)\n        (\\<lambda>A'.\n            bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))\n 6. \\<And>A B C. A + B + C = A + (B + C)\n 7. \\<And>A. {#} + A = A\n 8. \\<And>A. A + {#} = A", "show \"bind (mmerge y f) (\\<lambda>A. mmerge A g) = mmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. mmerge A g))\" for y f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (local.mmerge y f) (\\<lambda>A. local.mmerge A g) =\n    local.mmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. local.mmerge A g))", "apply(induction y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bind (local.mmerge {#} f) (\\<lambda>A. local.mmerge A g) =\n    local.mmerge {#} (\\<lambda>x. bind (f x) (\\<lambda>A. local.mmerge A g))\n 2. \\<And>x y.\n       bind (local.mmerge y f) (\\<lambda>A. local.mmerge A g) =\n       local.mmerge y\n        (\\<lambda>x.\n            bind (f x) (\\<lambda>A. local.mmerge A g)) \\<Longrightarrow>\n       bind (local.mmerge (add_mset x y) f) (\\<lambda>A. local.mmerge A g) =\n       local.mmerge (add_mset x y)\n        (\\<lambda>x. bind (f x) (\\<lambda>A. local.mmerge A g))", "apply(simp_all add: return_bind mmerge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       bind (mUnionM (image_mset f y))\n        (\\<lambda>A. mUnionM (image_mset g A)) =\n       mUnionM\n        {#bind (f x) (\\<lambda>A. mUnionM (image_mset g A))\n        . x \\<in># y#} \\<Longrightarrow>\n       bind (munionM (f x) (mUnionM (image_mset f y)))\n        (\\<lambda>A. mUnionM (image_mset g A)) =\n       munionM (bind (f x) (\\<lambda>A. mUnionM (image_mset g A)))\n        (mUnionM\n          {#bind (f x) (\\<lambda>A. mUnionM (image_mset g A)). x \\<in># y#})", "apply(subst bind_munionM; simp add: munionM_def o_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind (local.mmerge ?y1 ?f1) (\\<lambda>A. local.mmerge A ?g1) =\n  local.mmerge ?y1\n   (\\<lambda>x. bind (?f1 x) (\\<lambda>A. local.mmerge A ?g1))\n\ngoal (7 subgoals):\n 1. \\<And>f. local.mmerge {#} f = return {#}\n 2. \\<And>x f. local.mmerge {#x#} f = f x\n 3. \\<And>A. local.mmerge A (\\<lambda>x. return {#x#}) = return A\n 4. \\<And>A B f.\n       local.mmerge (A + B) f =\n       bind (local.mmerge A f)\n        (\\<lambda>A'.\n            bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))\n 5. \\<And>A B C. A + B + C = A + (B + C)\n 6. \\<And>A. {#} + A = A\n 7. \\<And>A. A + {#} = A", "show \"mmerge {#} f = return {#}\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mmerge {#} f = return {#}", "by(simp add: mmerge_def)"], ["proof (state)\nthis:\n  local.mmerge {#} ?f1 = return {#}\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.mmerge {#x#} f = f x\n 2. \\<And>A. local.mmerge A (\\<lambda>x. return {#x#}) = return A\n 3. \\<And>A B f.\n       local.mmerge (A + B) f =\n       bind (local.mmerge A f)\n        (\\<lambda>A'.\n            bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))\n 4. \\<And>A B C. A + B + C = A + (B + C)\n 5. \\<And>A. {#} + A = A\n 6. \\<And>A. A + {#} = A", "show \"mmerge {#x#} f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mmerge {#x#} f = f x", "by(simp add: mmerge_def)"], ["proof (state)\nthis:\n  local.mmerge {#?x1#} ?f1 = ?f1 ?x1\n\ngoal (5 subgoals):\n 1. \\<And>A. local.mmerge A (\\<lambda>x. return {#x#}) = return A\n 2. \\<And>A B f.\n       local.mmerge (A + B) f =\n       bind (local.mmerge A f)\n        (\\<lambda>A'.\n            bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))\n 3. \\<And>A B C. A + B + C = A + (B + C)\n 4. \\<And>A. {#} + A = A\n 5. \\<And>A. A + {#} = A", "show \"mmerge A (\\<lambda>x. return {#x#}) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mmerge A (\\<lambda>x. return {#x#}) = return A", "by(simp add: mmerge_def)"], ["proof (state)\nthis:\n  local.mmerge ?A1 (\\<lambda>x. return {#x#}) = return ?A1\n\ngoal (4 subgoals):\n 1. \\<And>A B f.\n       local.mmerge (A + B) f =\n       bind (local.mmerge A f)\n        (\\<lambda>A'.\n            bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))\n 2. \\<And>A B C. A + B + C = A + (B + C)\n 3. \\<And>A. {#} + A = A\n 4. \\<And>A. A + {#} = A", "show \"mmerge (A + B) f = bind (mmerge A f) (\\<lambda>A'. bind (mmerge B f) (\\<lambda>B'. return (A' + B')))\"\n    for f A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mmerge (A + B) f =\n    bind (local.mmerge A f)\n     (\\<lambda>A'. bind (local.mmerge B f) (\\<lambda>B'. return (A' + B')))", "by(simp add: mmerge_def munionM_def)"], ["proof (state)\nthis:\n  local.mmerge (?A1 + ?B1) ?f1 =\n  bind (local.mmerge ?A1 ?f1)\n   (\\<lambda>A'.\n       bind (local.mmerge ?B1 ?f1) (\\<lambda>B'. return (A' + B')))\n\ngoal (3 subgoals):\n 1. \\<And>A B C. A + B + C = A + (B + C)\n 2. \\<And>A. {#} + A = A\n 3. \\<And>A. A + {#} = A", "qed simp_all"], ["", "lemma mset_nondetM_ask:\n  notes mset_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask mmerge {#} (\\<lambda>x. {#x#}) (+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM_ask return bind ask local.mmerge {#} (\\<lambda>x. {#x#}) (+)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.mmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.mmerge A (\\<lambda>x. run_nondet (f x r)))", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.mmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.mmerge A (\\<lambda>x. run_nondet (f x r)))", "show \"mmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) = ask (\\<lambda>r. mmerge A (\\<lambda>x. run_nondet (f x r)))\"\n    for A and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'm) nondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n    ask (\\<lambda>r. local.mmerge A (\\<lambda>x. run_nondet (f x r)))", "unfolding mmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mUnionM {#ask (\\<lambda>r. run_nondet (f x r)). x \\<in># A#} =\n    ask (\\<lambda>r. mUnionM {#run_nondet (f x r). x \\<in># A#})", "by(induction A)(simp_all add: ask_const munionM_def bind_ask bind_ask2 ask_ask)"], ["proof (state)\nthis:\n  local.mmerge ?A1 (\\<lambda>x. ask (\\<lambda>r. run_nondet (?f1 x r))) =\n  ask (\\<lambda>r. local.mmerge ?A1 (\\<lambda>x. run_nondet (?f1 x r)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas mset_nondetMs [locale_witness] =\n  nondetM_lemmas[OF mset_nondetM]\n  nondetM_ask_lemmas[OF mset_nondetM_ask]"], ["", "end"], ["", "end"], ["", "lemma mmerge_parametric:\n  includes lifting_syntax\n  assumes return [transfer_rule]: \"(rel_mset A ===> M) return1 return2\"\n    and bind [transfer_rule]: \"(M ===> (rel_mset A ===> M) ===> M) bind1 bind2\"\n    and comm1: \"monad_commute return1 bind1\"\n    and comm2: \"monad_commute return2 bind2\"\n  shows \"(rel_mset A ===> (A ===> M) ===> M) (mmerge return1 bind1) (mmerge return2 bind2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset A ===> (A ===> M) ===> M) (mmerge return1 bind1)\n     (mmerge return2 bind2)", "unfolding mmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_mset A ===> (A ===> M) ===> M)\n     (\\<lambda>A f.\n         fold_mset\n          (\\<lambda>m1 m2.\n              bind1 m1 (\\<lambda>A. bind1 m2 (\\<lambda>B. return1 (A + B))))\n          (return1 {#}) (image_mset f A))\n     (\\<lambda>A f.\n         fold_mset\n          (\\<lambda>m1 m2.\n              bind2 m1 (\\<lambda>A. bind2 m2 (\\<lambda>B. return2 (A + B))))\n          (return2 {#}) (image_mset f A))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y; (A ===> M) xa ya\\<rbrakk>\n       \\<Longrightarrow> M (fold_mset\n                             (\\<lambda>m1 m2.\n                                 bind1 m1\n                                  (\\<lambda>A.\nbind1 m2 (\\<lambda>B. return1 (A + B))))\n                             (return1 {#}) (image_mset xa x))\n                          (fold_mset\n                            (\\<lambda>m1 m2.\n                                bind2 m1\n                                 (\\<lambda>A.\n                                     bind2 m2\n(\\<lambda>B. return2 (A + B))))\n                            (return2 {#}) (image_mset ya y))", "apply(drule (1) multiset.map_transfer[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y;\n        rel_mset M (image_mset xa x) (image_mset ya y)\\<rbrakk>\n       \\<Longrightarrow> M (fold_mset\n                             (\\<lambda>m1 m2.\n                                 bind1 m1\n                                  (\\<lambda>A.\nbind1 m2 (\\<lambda>B. return1 (A + B))))\n                             (return1 {#}) (image_mset xa x))\n                          (fold_mset\n                            (\\<lambda>m1 m2.\n                                bind2 m1\n                                 (\\<lambda>A.\n                                     bind2 m2\n(\\<lambda>B. return2 (A + B))))\n                            (return2 {#}) (image_mset ya y))", "apply(rule fold_mset_parametric[OF _ munionM_comp_fun_commute[OF comm1] munionM_comp_fun_commute[OF comm2], THEN rel_funD, THEN rel_funD, rotated -1], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y;\n        rel_mset M (image_mset xa x) (image_mset ya y)\\<rbrakk>\n       \\<Longrightarrow> (M ===> M ===> M)\n                          (\\<lambda>m1 m2.\n                              bind1 m1\n                               (\\<lambda>A.\n                                   bind1 m2 (\\<lambda>B. return1 (A + B))))\n                          (\\<lambda>m1 m2.\n                              bind2 m1\n                               (\\<lambda>A.\n                                   bind2 m2 (\\<lambda>B. return2 (A + B))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y;\n        rel_mset M (image_mset xa x) (image_mset ya y)\\<rbrakk>\n       \\<Longrightarrow> M (return1 {#}) (return2 {#})", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> M ===> M)\n     (\\<lambda>m1 m2.\n         bind1 m1 (\\<lambda>A. bind1 m2 (\\<lambda>B. return1 (A + B))))\n     (\\<lambda>m1 m2.\n         bind2 m1 (\\<lambda>A. bind2 m2 (\\<lambda>B. return2 (A + B))))", "by transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_mset A x y;\n        rel_mset M (image_mset xa x) (image_mset ya y)\\<rbrakk>\n       \\<Longrightarrow> M (return1 {#}) (return2 {#})", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (return1 {#}) (return2 {#})", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Implementation using finite sets\\<close>"], ["", "context \n  fixes return :: \"('a fset, 'm) return\"\n    and bind :: \"('a fset, 'm) bind\"\n    and funionM fUnionM\n  defines \"funionM m1 m2 \\<equiv> bind m1 (\\<lambda>A. bind m2 (\\<lambda>B. return (A |\\<union>| B)))\"\n    and \"fUnionM \\<equiv> ffold funionM (return {||})\"\nbegin"], ["", "definition fmerge :: \"'a fset \\<Rightarrow> ('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\"\nwhere \"fmerge A f = fUnionM (fimage f A)\""], ["", "context\n  assumes \"monad_commute return bind\"\n  and \"monad_duplicate return bind\"\nbegin"], ["", "interpretation monad_commute return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return bind", "by fact"], ["", "interpretation monad_duplicate return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_duplicate return bind", "by fact"], ["", "interpretation nondetM_base return bind fmerge \"{||}\" \"\\<lambda>x. {|x|}\" \"(|\\<union>|)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma funionM_comp_fun_commute: \"comp_fun_commute funionM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute funionM", "apply(unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x. funionM y \\<circ> funionM x = funionM x \\<circ> funionM y", "apply(simp add: fun_eq_iff bind_assoc return_bind funionM_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<forall>xa.\n          bind y\n           (\\<lambda>A.\n               bind x\n                (\\<lambda>y.\n                    bind xa\n                     (\\<lambda>ya.\n                         return (A |\\<union>| (y |\\<union>| ya))))) =\n          bind x\n           (\\<lambda>A.\n               bind y\n                (\\<lambda>y.\n                    bind xa\n                     (\\<lambda>ya.\n                         return (A |\\<union>| (y |\\<union>| ya)))))", "apply(subst bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y x.\n       \\<forall>xa.\n          bind x\n           (\\<lambda>ya.\n               bind y\n                (\\<lambda>x.\n                    bind xa\n                     (\\<lambda>y.\n                         return (x |\\<union>| (ya |\\<union>| y))))) =\n          bind x\n           (\\<lambda>A.\n               bind y\n                (\\<lambda>y.\n                    bind xa\n                     (\\<lambda>ya.\n                         return (A |\\<union>| (y |\\<union>| ya)))))", "apply(simp add: funion_ac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "interpretation comp_fun_commute funionM"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute funionM", "by(rule funionM_comp_fun_commute)"], ["", "lemma funionM_comp_fun_idem: \"comp_fun_idem funionM\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem funionM", "by(unfold_locales)(simp add: fun_eq_iff funionM_def bind_assoc bind_duplicate return_bind)"], ["", "interpretation comp_fun_idem funionM"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem funionM", "by(rule funionM_comp_fun_idem)"], ["", "lemma fUnionM_empty [simp]: \"fUnionM {||} = return {||}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM {||} = return {||}", "by(simp add: fUnionM_def)"], ["", "lemma fUnionM_finset [simp]: \"fUnionM (finsert x M) = funionM x (fUnionM M)\" for x M"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM (finsert x M) = funionM x (fUnionM M)", "by(simp add: fUnionM_def)"], ["", "lemma funionM_return_empty1 [simp]: \"funionM (return {||}) x = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM (return {||}) x = x", "by(simp add: funionM_def return_bind bind_return)"], ["", "lemma funionM_return_empty2 [simp]: \"funionM x (return {||}) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM x (return {||}) = x", "by(simp add: funionM_def return_bind bind_return)"], ["", "lemma funionM_return_return [simp]: \"funionM (return A) (return B) = return (A |\\<union>| B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM (return A) (return B) = return (A |\\<union>| B)", "by(simp add: funionM_def return_bind)"], ["", "lemma funionM_assoc: \"funionM (funionM x y) z = funionM x (funionM y z)\" for x y z"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM (funionM x y) z = funionM x (funionM y z)", "by(simp add: funionM_def bind_assoc return_bind funion_assoc)"], ["", "lemma funionM_commute: \"funionM x y = funionM y x\" for x y"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM x y = funionM y x", "unfolding funionM_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind x (\\<lambda>A. bind y (\\<lambda>B. return (A |\\<union>| B))) =\n    bind y (\\<lambda>A. bind x (\\<lambda>B. return (A |\\<union>| B)))", "by(subst bind_commute)(simp add: funion_commute)"], ["", "lemma funionM_fUnionM1: \"funionM (fUnionM A) x = ffold funionM x A\" for A x"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM (fUnionM A) x = ffold funionM x A", "by(induction A arbitrary: x)(simp_all add: funionM_assoc)"], ["", "lemma funionM_fUnionM2: \"funionM x (fUnionM A) = ffold funionM x A\" for x A"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM x (fUnionM A) = ffold funionM x A", "by(subst funionM_commute)(rule funionM_fUnionM1)"], ["", "lemma fUnionM_funion [simp]: \"fUnionM (A |\\<union>| B) = funionM (fUnionM A) (fUnionM B)\" for A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM (A |\\<union>| B) = funionM (fUnionM A) (fUnionM B)", "by(subst funionM_fUnionM2)(simp add: fUnionM_def ffold_set_union)"], ["", "lemma fUnionM_return [simp]: \"fUnionM (fimage (\\<lambda>x. return {|x|}) A) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM ((\\<lambda>x. return {|x|}) |`| A) = return A", "by(induction A) simp_all"], ["", "lemma bind_funionM: \"bind (funionM m m') f = funionM (bind m f) (bind m' f)\"\n  if \"\\<And>A B. f (A |\\<union>| B) = bind (f A) (\\<lambda>x. bind (f B) (\\<lambda>y. return (x |\\<union>| y)))\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (funionM m m') f = funionM (bind m f) (bind m' f)", "apply(simp add: bind_assoc return_bind funionM_def that)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind m'\n          (\\<lambda>ya.\n              bind (f y)\n               (\\<lambda>x.\n                   bind (f ya) (\\<lambda>y. return (x |\\<union>| y))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y.\n                   bind (f y) (\\<lambda>B. return (A |\\<union>| B)))))", "apply(subst (2) bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>y.\n              bind m'\n               (\\<lambda>x.\n                   bind (f x) (\\<lambda>ya. return (y |\\<union>| ya))))) =\n    bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m'\n               (\\<lambda>y.\n                   bind (f y) (\\<lambda>B. return (A |\\<union>| B)))))", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma fUnionM_return_fempty [simp]: \"fUnionM (fimage (\\<lambda>x. return {||}) A) = return {||}\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM ((\\<lambda>x. return {||}) |`| A) = return {||}", "by(induction A) simp_all"], ["", "lemma funionM_bind: \"funionM (bind m f) (bind m g) = bind m (\\<lambda>x. funionM (f x) (g x))\" for m f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. funionM (bind m f) (bind m g) = bind m (\\<lambda>x. funionM (f x) (g x))", "unfolding funionM_def bind_assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>y.\n         bind (f y)\n          (\\<lambda>A.\n              bind m\n               (\\<lambda>y.\n                   bind (g y) (\\<lambda>B. return (A |\\<union>| B))))) =\n    bind m\n     (\\<lambda>x.\n         bind (f x)\n          (\\<lambda>A. bind (g x) (\\<lambda>B. return (A |\\<union>| B))))", "by(subst bind_commute)(simp add: bind_duplicate)"], ["", "lemma fUnionM_funionM:\n \"fUnionM ((\\<lambda>y. funionM (f y) (g y)) |`| A) = funionM (fUnionM (f |`| A)) (fUnionM (g |`| A))\" for f g A"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM ((\\<lambda>y. funionM (f y) (g y)) |`| A) =\n    funionM (fUnionM (f |`| A)) (fUnionM (g |`| A))", "by(induction A)(simp_all add: funionM_assoc funionM_commute fun_left_comm)"], ["", "lemma fset_nondetM: \"nondetM return bind fmerge {||} (\\<lambda>x. {|x|}) (|\\<union>|)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM return bind local.fmerge {||} (\\<lambda>x. {|x|}) (|\\<union>|)", "proof"], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>y f g.\n       bind (local.fmerge y f) (\\<lambda>A. local.fmerge A g) =\n       local.fmerge y\n        (\\<lambda>x. bind (f x) (\\<lambda>A. local.fmerge A g))\n 2. \\<And>f. local.fmerge {||} f = return {||}\n 3. \\<And>x f. local.fmerge {|x|} f = f x\n 4. \\<And>A. local.fmerge A (\\<lambda>x. return {|x|}) = return A\n 5. \\<And>A B f.\n       local.fmerge (A |\\<union>| B) f =\n       bind (local.fmerge A f)\n        (\\<lambda>A'.\n            bind (local.fmerge B f)\n             (\\<lambda>B'. return (A' |\\<union>| B')))\n 6. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 7. \\<And>A. {||} |\\<union>| A = A\n 8. \\<And>A. A |\\<union>| {||} = A", "show \"bind (fmerge y f) (\\<lambda>A. fmerge A g) = fmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. fmerge A g))\" for y f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (local.fmerge y f) (\\<lambda>A. local.fmerge A g) =\n    local.fmerge y (\\<lambda>x. bind (f x) (\\<lambda>A. local.fmerge A g))", "apply(induction y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bind (local.fmerge {||} f) (\\<lambda>A. local.fmerge A g) =\n    local.fmerge {||}\n     (\\<lambda>x. bind (f x) (\\<lambda>A. local.fmerge A g))\n 2. \\<And>x y.\n       \\<lbrakk>x |\\<notin>| y;\n        bind (local.fmerge y f) (\\<lambda>A. local.fmerge A g) =\n        local.fmerge y\n         (\\<lambda>x. bind (f x) (\\<lambda>A. local.fmerge A g))\\<rbrakk>\n       \\<Longrightarrow> bind (local.fmerge (finsert x y) f)\n                          (\\<lambda>A. local.fmerge A g) =\n                         local.fmerge (finsert x y)\n                          (\\<lambda>x.\n                              bind (f x) (\\<lambda>A. local.fmerge A g))", "apply(simp_all add: return_bind fmerge_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x |\\<notin>| y;\n        bind (fUnionM (f |`| y)) (\\<lambda>A. fUnionM (g |`| A)) =\n        fUnionM\n         ((\\<lambda>x. bind (f x) (\\<lambda>A. fUnionM (g |`| A))) |`|\n          y)\\<rbrakk>\n       \\<Longrightarrow> bind (funionM (f x) (fUnionM (f |`| y)))\n                          (\\<lambda>A. fUnionM (g |`| A)) =\n                         funionM\n                          (bind (f x) (\\<lambda>A. fUnionM (g |`| A)))\n                          (fUnionM\n                            ((\\<lambda>x.\n                                 bind (f x)\n                                  (\\<lambda>A. fUnionM (g |`| A))) |`|\n                             y))", "apply(subst bind_funionM; simp add: funionM_def o_def fimage_funion)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind (local.fmerge ?y1 ?f1) (\\<lambda>A. local.fmerge A ?g1) =\n  local.fmerge ?y1\n   (\\<lambda>x. bind (?f1 x) (\\<lambda>A. local.fmerge A ?g1))\n\ngoal (7 subgoals):\n 1. \\<And>f. local.fmerge {||} f = return {||}\n 2. \\<And>x f. local.fmerge {|x|} f = f x\n 3. \\<And>A. local.fmerge A (\\<lambda>x. return {|x|}) = return A\n 4. \\<And>A B f.\n       local.fmerge (A |\\<union>| B) f =\n       bind (local.fmerge A f)\n        (\\<lambda>A'.\n            bind (local.fmerge B f)\n             (\\<lambda>B'. return (A' |\\<union>| B')))\n 5. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 6. \\<And>A. {||} |\\<union>| A = A\n 7. \\<And>A. A |\\<union>| {||} = A", "show \"fmerge {||} f = return {||}\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge {||} f = return {||}", "by(simp add: fmerge_def)"], ["proof (state)\nthis:\n  local.fmerge {||} ?f1 = return {||}\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.fmerge {|x|} f = f x\n 2. \\<And>A. local.fmerge A (\\<lambda>x. return {|x|}) = return A\n 3. \\<And>A B f.\n       local.fmerge (A |\\<union>| B) f =\n       bind (local.fmerge A f)\n        (\\<lambda>A'.\n            bind (local.fmerge B f)\n             (\\<lambda>B'. return (A' |\\<union>| B')))\n 4. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 5. \\<And>A. {||} |\\<union>| A = A\n 6. \\<And>A. A |\\<union>| {||} = A", "show \"fmerge {|x|} f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge {|x|} f = f x", "by(simp add: fmerge_def)"], ["proof (state)\nthis:\n  local.fmerge {|?x1|} ?f1 = ?f1 ?x1\n\ngoal (5 subgoals):\n 1. \\<And>A. local.fmerge A (\\<lambda>x. return {|x|}) = return A\n 2. \\<And>A B f.\n       local.fmerge (A |\\<union>| B) f =\n       bind (local.fmerge A f)\n        (\\<lambda>A'.\n            bind (local.fmerge B f)\n             (\\<lambda>B'. return (A' |\\<union>| B')))\n 3. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 4. \\<And>A. {||} |\\<union>| A = A\n 5. \\<And>A. A |\\<union>| {||} = A", "show \"fmerge A (\\<lambda>x. return {|x|}) = return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge A (\\<lambda>x. return {|x|}) = return A", "by(simp add: fmerge_def)"], ["proof (state)\nthis:\n  local.fmerge ?A1 (\\<lambda>x. return {|x|}) = return ?A1\n\ngoal (4 subgoals):\n 1. \\<And>A B f.\n       local.fmerge (A |\\<union>| B) f =\n       bind (local.fmerge A f)\n        (\\<lambda>A'.\n            bind (local.fmerge B f)\n             (\\<lambda>B'. return (A' |\\<union>| B')))\n 2. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 3. \\<And>A. {||} |\\<union>| A = A\n 4. \\<And>A. A |\\<union>| {||} = A", "show \"fmerge (A |\\<union>| B) f = bind (fmerge A f) (\\<lambda>A'. bind (fmerge B f) (\\<lambda>B'. return (A' |\\<union>| B')))\"\n    for f A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge (A |\\<union>| B) f =\n    bind (local.fmerge A f)\n     (\\<lambda>A'.\n         bind (local.fmerge B f) (\\<lambda>B'. return (A' |\\<union>| B')))", "by(simp add: fmerge_def funionM_def fimage_funion)"], ["proof (state)\nthis:\n  local.fmerge (?A1 |\\<union>| ?B1) ?f1 =\n  bind (local.fmerge ?A1 ?f1)\n   (\\<lambda>A'.\n       bind (local.fmerge ?B1 ?f1) (\\<lambda>B'. return (A' |\\<union>| B')))\n\ngoal (3 subgoals):\n 1. \\<And>A B C. A |\\<union>| B |\\<union>| C = A |\\<union>| (B |\\<union>| C)\n 2. \\<And>A. {||} |\\<union>| A = A\n 3. \\<And>A. A |\\<union>| {||} = A", "qed auto"], ["", "lemma fset_nondetM_ask:\n  notes fset_nondetM[locale_witness]\n  assumes [locale_witness]: \"monad_reader return bind ask\"\n  shows \"nondetM_ask return bind ask fmerge {||} (\\<lambda>x. {|x|}) (|\\<union>|)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM_ask return bind ask local.fmerge {||} (\\<lambda>x. {|x|})\n     (|\\<union>|)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.fmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.fmerge A (\\<lambda>x. run_nondet (f x r)))", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A f.\n       local.fmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n       ask (\\<lambda>r. local.fmerge A (\\<lambda>x. run_nondet (f x r)))", "show \"fmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) = ask (\\<lambda>r. fmerge A (\\<lambda>x. run_nondet (f x r)))\"\n    for A and f :: \"'a \\<Rightarrow> 'b \\<Rightarrow> ('a, 'm) nondetT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge A (\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) =\n    ask (\\<lambda>r. local.fmerge A (\\<lambda>x. run_nondet (f x r)))", "unfolding fmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fUnionM ((\\<lambda>x. ask (\\<lambda>r. run_nondet (f x r))) |`| A) =\n    ask (\\<lambda>r. fUnionM ((\\<lambda>x. run_nondet (f x r)) |`| A))", "by(induction A)(simp_all add: ask_const funionM_def bind_ask bind_ask2 ask_ask)"], ["proof (state)\nthis:\n  local.fmerge ?A1 (\\<lambda>x. ask (\\<lambda>r. run_nondet (?f1 x r))) =\n  ask (\\<lambda>r. local.fmerge ?A1 (\\<lambda>x. run_nondet (?f1 x r)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas fset_nondetMs [locale_witness] =\n  nondetM_lemmas[OF fset_nondetM]\n  nondetM_ask_lemmas[OF fset_nondetM_ask]"], ["", "context\n  assumes \"monad_discard return bind\"\nbegin"], ["", "interpretation monad_discard return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_discard return bind", "by fact"], ["", "lemma fmerge_bind:\n  \"fmerge A (\\<lambda>x. bind m' (\\<lambda>A'. fmerge A' (f x))) = bind m' (\\<lambda>A'. fmerge A (\\<lambda>x. fmerge A' (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge A\n     (\\<lambda>x. bind m' (\\<lambda>A'. local.fmerge A' (f x))) =\n    bind m'\n     (\\<lambda>A'. local.fmerge A (\\<lambda>x. local.fmerge A' (f x)))", "by(induction A)(simp_all add: fmerge_def bind_const funionM_bind)"], ["", "lemma fmerge_commute: \"fmerge A (\\<lambda>x. fmerge B (f x)) = fmerge B (\\<lambda>y. fmerge A (\\<lambda>x. f x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.fmerge A (\\<lambda>x. local.fmerge B (f x)) =\n    local.fmerge B (\\<lambda>y. local.fmerge A (\\<lambda>x. f x y))", "by(induction A)(simp_all add: fmerge_def fUnionM_funionM)"], ["", "lemma monad_commute_nondetT_fset [locale_witness]:\n  \"monad_commute return_nondet bind_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_commute return_nondet bind_nondet", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       bind_nondet m (\\<lambda>x. bind_nondet m' (f x)) =\n       bind_nondet m' (\\<lambda>y. bind_nondet m (\\<lambda>x. f x y))", "show \"bind_nondet m (\\<lambda>x. bind_nondet m' (f x)) = bind_nondet m' (\\<lambda>y. bind_nondet m (\\<lambda>x. f x y))\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet m (\\<lambda>x. bind_nondet m' (f x)) =\n    bind_nondet m' (\\<lambda>y. bind_nondet m (\\<lambda>x. f x y))", "apply(rule nondetT.expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (bind_nondet m (\\<lambda>x. bind_nondet m' (f x))) =\n    run_nondet\n     (bind_nondet m' (\\<lambda>y. bind_nondet m (\\<lambda>x. f x y)))", "apply(simp add: o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m)\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m')\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f x xa))))) =\n    bind (run_nondet m')\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f xa x)))))", "apply(subst fmerge_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m)\n     (\\<lambda>A.\n         bind (run_nondet m')\n          (\\<lambda>A'.\n              local.fmerge A\n               (\\<lambda>x.\n                   local.fmerge A' (\\<lambda>xa. run_nondet (f x xa))))) =\n    bind (run_nondet m')\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f xa x)))))", "apply(subst bind_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m')\n     (\\<lambda>y.\n         bind (run_nondet m)\n          (\\<lambda>x.\n              local.fmerge x\n               (\\<lambda>x.\n                   local.fmerge y (\\<lambda>xa. run_nondet (f x xa))))) =\n    bind (run_nondet m')\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f xa x)))))", "apply(subst fmerge_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m')\n     (\\<lambda>y.\n         bind (run_nondet m)\n          (\\<lambda>x.\n              local.fmerge y\n               (\\<lambda>y.\n                   local.fmerge x (\\<lambda>x. run_nondet (f x y))))) =\n    bind (run_nondet m')\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f xa x)))))", "apply(subst fmerge_bind[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (run_nondet m')\n     (\\<lambda>y.\n         local.fmerge y\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A'.\n                   local.fmerge A' (\\<lambda>xa. run_nondet (f xa x))))) =\n    bind (run_nondet m')\n     (\\<lambda>A.\n         local.fmerge A\n          (\\<lambda>x.\n              bind (run_nondet m)\n               (\\<lambda>A.\n                   local.fmerge A (\\<lambda>xa. run_nondet (f xa x)))))", "apply(rule refl)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind_nondet ?m1 (\\<lambda>x. bind_nondet ?m'1 (?f1 x)) =\n  bind_nondet ?m'1 (\\<lambda>y. bind_nondet ?m1 (\\<lambda>x. ?f1 x y))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "lemma fmerge_parametric:\n  includes lifting_syntax\n  assumes return [transfer_rule]: \"(rel_fset A ===> M) return1 return2\"\n    and bind [transfer_rule]: \"(M ===> (rel_fset A ===> M) ===> M) bind1 bind2\"\n    and comm1: \"monad_commute return1 bind1\" \"monad_duplicate return1 bind1\"\n    and comm2: \"monad_commute return2 bind2\" \"monad_duplicate return2 bind2\"\n  shows \"(rel_fset A ===> (A ===> M) ===> M) (fmerge return1 bind1) (fmerge return2 bind2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_fset A ===> (A ===> M) ===> M) (fmerge return1 bind1)\n     (fmerge return2 bind2)", "unfolding fmerge_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_fset A ===> (A ===> M) ===> M)\n     (\\<lambda>A f.\n         ffold\n          (\\<lambda>m1 m2.\n              bind1 m1\n               (\\<lambda>A.\n                   bind1 m2 (\\<lambda>B. return1 (A |\\<union>| B))))\n          (return1 {||}) (f |`| A))\n     (\\<lambda>A f.\n         ffold\n          (\\<lambda>m1 m2.\n              bind2 m1\n               (\\<lambda>A.\n                   bind2 m2 (\\<lambda>B. return2 (A |\\<union>| B))))\n          (return2 {||}) (f |`| A))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_fset A x y; (A ===> M) xa ya\\<rbrakk>\n       \\<Longrightarrow> M (ffold\n                             (\\<lambda>m1 m2.\n                                 bind1 m1\n                                  (\\<lambda>A.\nbind1 m2 (\\<lambda>B. return1 (A |\\<union>| B))))\n                             (return1 {||}) (xa |`| x))\n                          (ffold\n                            (\\<lambda>m1 m2.\n                                bind2 m1\n                                 (\\<lambda>A.\n                                     bind2 m2\n(\\<lambda>B. return2 (A |\\<union>| B))))\n                            (return2 {||}) (ya |`| y))", "apply(drule (1) fset.map_transfer[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_fset A x y; rel_fset M (xa |`| x) (ya |`| y)\\<rbrakk>\n       \\<Longrightarrow> M (ffold\n                             (\\<lambda>m1 m2.\n                                 bind1 m1\n                                  (\\<lambda>A.\nbind1 m2 (\\<lambda>B. return1 (A |\\<union>| B))))\n                             (return1 {||}) (xa |`| x))\n                          (ffold\n                            (\\<lambda>m1 m2.\n                                bind2 m1\n                                 (\\<lambda>A.\n                                     bind2 m2\n(\\<lambda>B. return2 (A |\\<union>| B))))\n                            (return2 {||}) (ya |`| y))", "apply(rule ffold_parametric[OF _ funionM_comp_fun_idem[OF comm1] funionM_comp_fun_idem[OF comm2], THEN rel_funD, THEN rel_funD, rotated -1], assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_fset A x y; rel_fset M (xa |`| x) (ya |`| y)\\<rbrakk>\n       \\<Longrightarrow> (M ===> M ===> M)\n                          (\\<lambda>m1 m2.\n                              bind1 m1\n                               (\\<lambda>A.\n                                   bind1 m2\n                                    (\\<lambda>B. return1 (A |\\<union>| B))))\n                          (\\<lambda>m1 m2.\n                              bind2 m1\n                               (\\<lambda>A.\n                                   bind2 m2\n                                    (\\<lambda>B. return2 (A |\\<union>| B))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_fset A x y; rel_fset M (xa |`| x) (ya |`| y)\\<rbrakk>\n       \\<Longrightarrow> M (return1 {||}) (return2 {||})", "subgoal premises [transfer_rule]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> M ===> M)\n     (\\<lambda>m1 m2.\n         bind1 m1\n          (\\<lambda>A. bind1 m2 (\\<lambda>B. return1 (A |\\<union>| B))))\n     (\\<lambda>m1 m2.\n         bind2 m1\n          (\\<lambda>A. bind2 m2 (\\<lambda>B. return2 (A |\\<union>| B))))", "by transfer_prover"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_fset A x y; rel_fset M (xa |`| x) (ya |`| y)\\<rbrakk>\n       \\<Longrightarrow> M (return1 {||}) (return2 {||})", "subgoal premises"], ["proof (prove)\ngoal (1 subgoal):\n 1. M (return1 {||}) (return2 {||})", "by transfer_prover"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Implementation using countable sets\\<close>"], ["", "text \\<open>For non-finite choices, we cannot generically construct the merge operation. So we formalize\n  in a locale what can be proven generically and then prove instances of the locale for concrete\n  locale implementations.\n\n  We need two separate merge parameters because we must merge effects over choices (type @{typ 'c})\n  and effects over the non-deterministic results (type @{typ 'a}) of computations.\n\\<close>"], ["", "locale cset_nondetM_base =\n  nondetM_base return bind merge cempty csingle cUn\n  for return :: \"('a cset, 'm) return\"\n  and bind :: \"('a cset, 'm) bind\"\n  and merge :: \"('a, 'm, 'a cset) merge\"\n  and mergec :: \"('c, 'm, 'c cset) merge\"\nbegin"], ["", "definition altc_nondet :: \"('c, ('a, 'm) nondetT) altc\" where\n  \"altc_nondet A f = NondetT (mergec A (run_nondet \\<circ> f))\""], ["", "lemma run_altc_nondet [simp]: \"run_nondet (altc_nondet A f) = mergec A (run_nondet \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_nondet (altc_nondet A f) = mergec A (run_nondet \\<circ> f)", "by(simp add: altc_nondet_def)"], ["", "end"], ["", "locale cset_nondetM =\n  cset_nondetM_base return bind merge mergec\n  +\n  monad_commute return bind\n  +\n  monad_duplicate return bind\n  for return :: \"('a cset, 'm) return\"\n  and bind :: \"('a cset, 'm) bind\"\n  and merge :: \"('a, 'm, 'a cset) merge\"\n  and mergec :: \"('c, 'm, 'c cset) merge\"\n  +\n  assumes bind_merge_merge:\n    \"\\<And>y f g. bind (merge y f) (\\<lambda>A. merge A g) = merge y (\\<lambda>x. bind (f x) (\\<lambda>A. merge A g))\"\n  and merge_empty: \"\\<And>f. merge cempty f = return cempty\"\n  and merge_single: \"\\<And>x f. merge (csingle x) f = f x\"\n  and merge_single2: \"\\<And>A. merge A (\\<lambda>x. return (csingle x)) = return A\"\n  and merge_union: \"\\<And>A B f. merge (cUn A B) f = bind (merge A f) (\\<lambda>A'. bind (merge B f) (\\<lambda>B'. return (cUn A' B')))\"\n  and bind_mergec_merge:\n    \"\\<And>y f g. bind (mergec y f) (\\<lambda>A. merge A g) = mergec y (\\<lambda>x. bind (f x) (\\<lambda>A. merge A g))\"\n  and mergec_single: \"\\<And>x f. mergec (csingle x) f = f x\"\n  and mergec_UNION: \"\\<And>C f g. mergec (cUNION C f) g = mergec C (\\<lambda>x. mergec (f x) g)\"\n  and mergec_parametric [transfer_rule]:\n    \"\\<And>R. bi_unique R \\<Longrightarrow> rel_fun (rel_cset R) (rel_fun (rel_fun R (=)) (=)) mergec mergec\"\nbegin"], ["", "interpretation nondetM return bind merge cempty csingle cUn"], ["proof (prove)\ngoal (1 subgoal):\n 1. nondetM return bind merge cempty csingle cUn", "by(unfold_locales; (rule bind_merge_merge merge_empty merge_single merge_single2 merge_union | simp add: cUn_assoc)?)"], ["", "sublocale nondet: monad_altc return_nondet bind_nondet altc_nondet"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return_nondet bind_nondet altc_nondet", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return_nondet bind_nondet altc_nondet", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       bind_nondet (altc_nondet C g) f =\n       altc_nondet C (\\<lambda>c. bind_nondet (g c) f)\n 2. \\<And>x f. altc_nondet (csingle x) f = f x\n 3. \\<And>C f g.\n       altc_nondet (cUnion (cimage f C)) g =\n       altc_nondet C (\\<lambda>x. altc_nondet (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet", "show \"bind_nondet (altc_nondet C g) f = altc_nondet C (\\<lambda>c. bind_nondet (g c) f)\" for C g f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_nondet (altc_nondet C g) f =\n    altc_nondet C (\\<lambda>c. bind_nondet (g c) f)", "by(rule nondetT.expand)(simp add: bind_mergec_merge o_def)"], ["proof (state)\nthis:\n  bind_nondet (altc_nondet ?C3 ?g3) ?f3 =\n  altc_nondet ?C3 (\\<lambda>c. bind_nondet (?g3 c) ?f3)\n\ngoal (3 subgoals):\n 1. \\<And>x f. altc_nondet (csingle x) f = f x\n 2. \\<And>C f g.\n       altc_nondet (cUnion (cimage f C)) g =\n       altc_nondet C (\\<lambda>x. altc_nondet (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet", "show \"altc_nondet (csingle x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. altc_nondet (csingle x) f = f x", "by(rule nondetT.expand)(simp add: mergec_single)"], ["proof (state)\nthis:\n  altc_nondet (csingle ?x3) ?f3 = ?f3 ?x3\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       altc_nondet (cUnion (cimage f C)) g =\n       altc_nondet C (\\<lambda>x. altc_nondet (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet", "show \"altc_nondet (cUNION C f) g = altc_nondet C (\\<lambda>x. altc_nondet (f x) g)\" for C f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. altc_nondet (cUnion (cimage f C)) g =\n    altc_nondet C (\\<lambda>x. altc_nondet (f x) g)", "by(rule nondetT.expand)(simp add: o_def mergec_UNION)"], ["proof (state)\nthis:\n  altc_nondet (cUnion (cimage ?f3 ?C3)) ?g3 =\n  altc_nondet ?C3 (\\<lambda>x. altc_nondet (?f3 x) ?g3)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet\" \n    if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) altc_nondet altc_nondet", "unfolding altc_nondet_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>A f. NondetT (mergec A (run_nondet \\<circ> f)))\n     (\\<lambda>A f. NondetT (mergec A (run_nondet \\<circ> f)))", "by(transfer_prover)"], ["proof (state)\nthis:\n  bi_unique ?R3 \\<Longrightarrow>\n  (rel_cset ?R3 ===> (?R3 ===> (=)) ===> (=)) altc_nondet altc_nondet\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale cset_nondetM3 =\n  cset_nondetM return bind merge mergec\n  +\n  three \"TYPE('c)\"\n  for return :: \"('a cset, 'm) return\"\n  and bind :: \"('a cset, 'm) bind\"\n  and merge :: \"('a, 'm, 'a cset) merge\"\n  and mergec :: \"('c, 'm, 'c cset) merge\"\nbegin"], ["", "interpretation nondet: monad_altc3 return_nondet bind_nondet altc_nondet"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 return_nondet bind_nondet altc_nondet", ".."], ["", "end"], ["", "paragraph \\<open>Identity monad\\<close>"], ["", "definition merge_id :: \"('c, 'a cset id, 'c cset) merge\" where\n  \"merge_id A f = return_id (cUNION A (extract \\<circ> f))\""], ["", "lemma extract_merge_id [simp]: \"extract (merge_id A f) = cUNION A (extract \\<circ> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extract (merge_id A f) = cUnion (cimage (extract \\<circ> f) A)", "by(simp add: merge_id_def)"], ["", "lemma merge_id_parametric [transfer_rule]: includes lifting_syntax shows\n  \"(rel_cset A ===> (A ===> rel_id (rel_cset A)) ===> rel_id (rel_cset A)) merge_id merge_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset A ===> (A ===> rel_id (rel_cset A)) ===> rel_id (rel_cset A))\n     merge_id merge_id", "unfolding merge_id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset A ===> (A ===> rel_id (rel_cset A)) ===> rel_id (rel_cset A))\n     (\\<lambda>A f. return_id (cUnion (cimage (extract \\<circ> f) A)))\n     (\\<lambda>A f. return_id (cUnion (cimage (extract \\<circ> f) A)))", "by transfer_prover"], ["", "lemma cset_nondetM_id [locale_witness]: \"cset_nondetM return_id bind_id merge_id merge_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM return_id bind_id merge_id merge_id", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM return_id bind_id merge_id merge_id", "proof(unfold_locales)"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>y f g.\n       bind_id (merge_id y f) (\\<lambda>A. merge_id A g) =\n       merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))\n 2. \\<And>f. merge_id cempty f = return_id cempty\n 3. \\<And>x f. merge_id (csingle x) f = f x\n 4. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 5. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 6. \\<And>y f g.\n       bind_id (merge_id y f) (\\<lambda>A. merge_id A g) =\n       merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))\n 7. \\<And>x f. merge_id (csingle x) f = f x\n 8. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 9. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"bind_id (merge_id y f) (\\<lambda>A. merge_id A g) = merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))\"\n    for y and f :: \"'c \\<Rightarrow> 'd cset id\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_id (merge_id y f) (\\<lambda>A. merge_id A g) =\n    merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))", "by(rule id.expand)(simp add: o_def cUNION_assoc)"], ["proof (state)\nthis:\n  bind_id (merge_id ?y1 ?f1) (\\<lambda>A. merge_id A ?g1) =\n  merge_id ?y1 (\\<lambda>x. bind_id (?f1 x) (\\<lambda>A. merge_id A ?g1))\n\ngoal (8 subgoals):\n 1. \\<And>f. merge_id cempty f = return_id cempty\n 2. \\<And>x f. merge_id (csingle x) f = f x\n 3. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 4. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 5. \\<And>y f g.\n       bind_id (merge_id y f) (\\<lambda>A. merge_id A g) =\n       merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))\n 6. \\<And>x f. merge_id (csingle x) f = f x\n 7. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 8. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "then"], ["proof (chain)\npicking this:\n  bind_id (merge_id ?y1 ?f1) (\\<lambda>A. merge_id A ?g1) =\n  merge_id ?y1 (\\<lambda>x. bind_id (?f1 x) (\\<lambda>A. merge_id A ?g1))", "show \"bind_id (merge_id y f) (\\<lambda>A. merge_id A g) = merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))\"\n    for y and f :: \"'c \\<Rightarrow> 'd cset id\" and g"], ["proof (prove)\nusing this:\n  bind_id (merge_id ?y1 ?f1) (\\<lambda>A. merge_id A ?g1) =\n  merge_id ?y1 (\\<lambda>x. bind_id (?f1 x) (\\<lambda>A. merge_id A ?g1))\n\ngoal (1 subgoal):\n 1. bind_id (merge_id y f) (\\<lambda>A. merge_id A g) =\n    merge_id y (\\<lambda>x. bind_id (f x) (\\<lambda>A. merge_id A g))", "by this"], ["proof (state)\nthis:\n  bind_id (merge_id ?y2 ?f2) (\\<lambda>A. merge_id A ?g2) =\n  merge_id ?y2 (\\<lambda>x. bind_id (?f2 x) (\\<lambda>A. merge_id A ?g2))\n\ngoal (7 subgoals):\n 1. \\<And>f. merge_id cempty f = return_id cempty\n 2. \\<And>x f. merge_id (csingle x) f = f x\n 3. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 4. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 5. \\<And>x f. merge_id (csingle x) f = f x\n 6. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"merge_id cempty f = return_id cempty\" for f :: \"'a \\<Rightarrow> 'a cset id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_id cempty f = return_id cempty", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  merge_id cempty ?f2 = return_id cempty\n\ngoal (6 subgoals):\n 1. \\<And>x f. merge_id (csingle x) f = f x\n 2. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 3. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 4. \\<And>x f. merge_id (csingle x) f = f x\n 5. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"merge_id (csingle x) f = f x\" for x and f :: \"'c \\<Rightarrow> 'a cset id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_id (csingle x) f = f x", "by(rule id.expand) simp"], ["proof (state)\nthis:\n  merge_id (csingle ?x3) ?f3 = ?f3 ?x3\n\ngoal (5 subgoals):\n 1. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 2. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 3. \\<And>x f. merge_id (csingle x) f = f x\n 4. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "then"], ["proof (chain)\npicking this:\n  merge_id (csingle ?x3) ?f3 = ?f3 ?x3", "show \"merge_id (csingle x) f = f x\" for x and f :: \"'c \\<Rightarrow> 'a cset id\""], ["proof (prove)\nusing this:\n  merge_id (csingle ?x3) ?f3 = ?f3 ?x3\n\ngoal (1 subgoal):\n 1. merge_id (csingle x) f = f x", "by this"], ["proof (state)\nthis:\n  merge_id (csingle ?x4) ?f4 = ?f4 ?x4\n\ngoal (4 subgoals):\n 1. \\<And>A. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\n 2. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 3. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A\" for A :: \"'a cset\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_id A (\\<lambda>x. return_id (csingle x)) = return_id A", "by(rule id.expand)(simp add: o_def)"], ["proof (state)\nthis:\n  merge_id ?A4 (\\<lambda>x. return_id (csingle x)) = return_id ?A4\n\ngoal (3 subgoals):\n 1. \\<And>A B f.\n       merge_id (cUn A B) f =\n       bind_id (merge_id A f)\n        (\\<lambda>A'.\n            bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\n 2. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"merge_id (cUn A B) f = bind_id (merge_id A f) (\\<lambda>A'. bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))\"\n    for A B and f :: \"'a \\<Rightarrow> 'a cset id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_id (cUn A B) f =\n    bind_id (merge_id A f)\n     (\\<lambda>A'.\n         bind_id (merge_id B f) (\\<lambda>B'. return_id (cUn A' B')))", "by(rule id.expand)(simp add: cUNION_cUn)"], ["proof (state)\nthis:\n  merge_id (cUn ?A4 ?B4) ?f4 =\n  bind_id (merge_id ?A4 ?f4)\n   (\\<lambda>A'.\n       bind_id (merge_id ?B4 ?f4) (\\<lambda>B'. return_id (cUn A' B')))\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       merge_id (cUnion (cimage f C)) g =\n       merge_id C (\\<lambda>x. merge_id (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"merge_id (cUNION C f) g = merge_id C (\\<lambda>x. merge_id (f x) g)\"\n    for C and f :: \"'b \\<Rightarrow> 'b cset\" and g :: \"'b \\<Rightarrow> 'a cset id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_id (cUnion (cimage f C)) g =\n    merge_id C (\\<lambda>x. merge_id (f x) g)", "by(rule id.expand)(simp add: o_def cUNION_assoc)"], ["proof (state)\nthis:\n  merge_id (cUnion (cimage ?f4 ?C4)) ?g4 =\n  merge_id ?C4 (\\<lambda>x. merge_id (?f4 x) ?g4)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id\"\n    if \"bi_unique R\" for R :: \"'b \\<Rightarrow> 'b \\<Rightarrow> bool\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) merge_id merge_id", "unfolding merge_id_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>A f. return_id (cUnion (cimage (extract \\<circ> f) A)))\n     (\\<lambda>A f. return_id (cUnion (cimage (extract \\<circ> f) A)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R5 \\<Longrightarrow>\n  (rel_cset ?R5 ===> (?R5 ===> (=)) ===> (=)) merge_id merge_id\n\ngoal:\nNo subgoals!", "qed"], ["", "paragraph \\<open>Reader monad transformer\\<close>"], ["", "definition merge_env :: \"('c, 'm, 'c cset) merge \\<Rightarrow> ('c, ('r, 'm) envT, 'c cset) merge\" where \n  \"merge_env merge A f = EnvT (\\<lambda>r. merge A (\\<lambda>a. run_env (f a) r))\" for merge"], ["", "lemma run_merge_env [simp]: \"run_env (merge_env merge A f) r = merge A (\\<lambda>a. run_env (f a) r)\" for merge"], ["proof (prove)\ngoal (1 subgoal):\n 1. run_env (merge_env merge A f) r = merge A (\\<lambda>a. run_env (f a) r)", "by(simp add: merge_env_def)"], ["", "lemma merge_env_parametric [transfer_rule]: includes lifting_syntax shows\n  \"((rel_cset C ===> (C ===> M) ===> M) ===> rel_cset C ===> (C ===> rel_envT R M) ===> rel_envT R M)\n   merge_env merge_env\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_cset C ===> (C ===> M) ===> M) ===>\n     rel_cset C ===>\n     (C ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     merge_env merge_env", "unfolding merge_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_cset C ===> (C ===> M) ===> M) ===>\n     rel_cset C ===>\n     (C ===> Monomorphic_Monad.rel_envT R M) ===>\n     Monomorphic_Monad.rel_envT R M)\n     (\\<lambda>merge A f.\n         EnvT (\\<lambda>r. merge A (\\<lambda>a. run_env (f a) r)))\n     (\\<lambda>merge A f.\n         EnvT (\\<lambda>r. merge A (\\<lambda>a. run_env (f a) r)))", "by transfer_prover"], ["", "lemma cset_nondetM_envT [locale_witness]: \n  fixes return :: \"('a cset, 'm) return\" \n    and bind :: \"('a cset, 'm) bind\"\n    and merge :: \"('a, 'm, 'a cset) merge\"\n    and mergec :: \"('c, 'm, 'c cset) merge\"\n  assumes \"cset_nondetM return bind merge mergec\"\n  shows \"cset_nondetM (return_env return) (bind_env bind) (merge_env merge) (merge_env mergec)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n     (merge_env mergec)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n     (merge_env mergec)", "interpret cset_nondetM return bind merge"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM return bind merge mergec", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n     (merge_env mergec)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n     (merge_env mergec)", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n     (merge_env mergec)", "proof"], ["proof (state)\ngoal (9 subgoals):\n 1. \\<And>y f g.\n       bind_env bind (merge_env merge y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env merge y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 2. \\<And>f. merge_env merge cempty f = return_env return cempty\n 3. \\<And>x f. merge_env merge (csingle x) f = f x\n 4. \\<And>A.\n       merge_env merge A (\\<lambda>x. return_env return (csingle x)) =\n       return_env return A\n 5. \\<And>A B f.\n       merge_env merge (cUn A B) f =\n       bind_env bind (merge_env merge A f)\n        (\\<lambda>A'.\n            bind_env bind (merge_env merge B f)\n             (\\<lambda>B'. return_env return (cUn A' B')))\n 6. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 7. \\<And>x f. merge_env mergec (csingle x) f = f x\n 8. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 9. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"bind_env bind (merge_env merge y f) (\\<lambda>A. merge_env merge A g) =\n      merge_env merge y (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\"\n      for y and f :: \"'a \\<Rightarrow> ('b, 'm) envT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_env bind (merge_env merge y f) (\\<lambda>A. merge_env merge A g) =\n    merge_env merge y\n     (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))", "by(rule envT.expand)(simp add: fun_eq_iff cUNION_assoc bind_merge_merge)"], ["proof (state)\nthis:\n  bind_env bind (merge_env merge ?y1 ?f1)\n   (\\<lambda>A. merge_env merge A ?g1) =\n  merge_env merge ?y1\n   (\\<lambda>x. bind_env bind (?f1 x) (\\<lambda>A. merge_env merge A ?g1))\n\ngoal (8 subgoals):\n 1. \\<And>f. merge_env merge cempty f = return_env return cempty\n 2. \\<And>x f. merge_env merge (csingle x) f = f x\n 3. \\<And>A.\n       merge_env merge A (\\<lambda>x. return_env return (csingle x)) =\n       return_env return A\n 4. \\<And>A B f.\n       merge_env merge (cUn A B) f =\n       bind_env bind (merge_env merge A f)\n        (\\<lambda>A'.\n            bind_env bind (merge_env merge B f)\n             (\\<lambda>B'. return_env return (cUn A' B')))\n 5. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 6. \\<And>x f. merge_env mergec (csingle x) f = f x\n 7. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 8. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env merge cempty f = return_env return cempty\" for f :: \"'a \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env merge cempty f = return_env return cempty", "by(rule envT.expand)(simp add: fun_eq_iff merge_empty)"], ["proof (state)\nthis:\n  merge_env merge cempty ?f1 = return_env return cempty\n\ngoal (7 subgoals):\n 1. \\<And>x f. merge_env merge (csingle x) f = f x\n 2. \\<And>A.\n       merge_env merge A (\\<lambda>x. return_env return (csingle x)) =\n       return_env return A\n 3. \\<And>A B f.\n       merge_env merge (cUn A B) f =\n       bind_env bind (merge_env merge A f)\n        (\\<lambda>A'.\n            bind_env bind (merge_env merge B f)\n             (\\<lambda>B'. return_env return (cUn A' B')))\n 4. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 5. \\<And>x f. merge_env mergec (csingle x) f = f x\n 6. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env merge (csingle x) f = f x\" for f :: \"'a \\<Rightarrow> ('b, 'm) envT\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env merge (csingle x) f = f x", "by(rule envT.expand)(simp add: fun_eq_iff merge_single)"], ["proof (state)\nthis:\n  merge_env merge (csingle ?x1) ?f1 = ?f1 ?x1\n\ngoal (6 subgoals):\n 1. \\<And>A.\n       merge_env merge A (\\<lambda>x. return_env return (csingle x)) =\n       return_env return A\n 2. \\<And>A B f.\n       merge_env merge (cUn A B) f =\n       bind_env bind (merge_env merge A f)\n        (\\<lambda>A'.\n            bind_env bind (merge_env merge B f)\n             (\\<lambda>B'. return_env return (cUn A' B')))\n 3. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 4. \\<And>x f. merge_env mergec (csingle x) f = f x\n 5. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env merge A (\\<lambda>x. return_env return (csingle x)) = return_env return A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env merge A (\\<lambda>x. return_env return (csingle x)) =\n    return_env return A", "by(rule envT.expand)(simp add: fun_eq_iff merge_single2)"], ["proof (state)\nthis:\n  merge_env merge ?A2 (\\<lambda>x. return_env return (csingle x)) =\n  return_env return ?A2\n\ngoal (5 subgoals):\n 1. \\<And>A B f.\n       merge_env merge (cUn A B) f =\n       bind_env bind (merge_env merge A f)\n        (\\<lambda>A'.\n            bind_env bind (merge_env merge B f)\n             (\\<lambda>B'. return_env return (cUn A' B')))\n 2. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 3. \\<And>x f. merge_env mergec (csingle x) f = f x\n 4. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env merge (cUn A B) f =\n      bind_env bind (merge_env merge A f) (\\<lambda>A'. bind_env bind (merge_env merge B f) (\\<lambda>B'. return_env return (cUn A' B')))\"\n      for A B and f :: \"'a \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env merge (cUn A B) f =\n    bind_env bind (merge_env merge A f)\n     (\\<lambda>A'.\n         bind_env bind (merge_env merge B f)\n          (\\<lambda>B'. return_env return (cUn A' B')))", "by(rule envT.expand)(simp add: fun_eq_iff merge_union)"], ["proof (state)\nthis:\n  merge_env merge (cUn ?A2 ?B2) ?f2 =\n  bind_env bind (merge_env merge ?A2 ?f2)\n   (\\<lambda>A'.\n       bind_env bind (merge_env merge ?B2 ?f2)\n        (\\<lambda>B'. return_env return (cUn A' B')))\n\ngoal (4 subgoals):\n 1. \\<And>y f g.\n       bind_env bind (merge_env mergec y f)\n        (\\<lambda>A. merge_env merge A g) =\n       merge_env mergec y\n        (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\n 2. \\<And>x f. merge_env mergec (csingle x) f = f x\n 3. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"bind_env bind (merge_env mergec y f) (\\<lambda>A. merge_env merge A g) =\n      merge_env mergec y (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))\"\n      for y and f :: \"'c \\<Rightarrow> ('b, 'm) envT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_env bind (merge_env mergec y f) (\\<lambda>A. merge_env merge A g) =\n    merge_env mergec y\n     (\\<lambda>x. bind_env bind (f x) (\\<lambda>A. merge_env merge A g))", "by(rule envT.expand)(simp add: fun_eq_iff cUNION_assoc bind_mergec_merge)"], ["proof (state)\nthis:\n  bind_env bind (merge_env mergec ?y2 ?f2)\n   (\\<lambda>A. merge_env merge A ?g2) =\n  merge_env mergec ?y2\n   (\\<lambda>x. bind_env bind (?f2 x) (\\<lambda>A. merge_env merge A ?g2))\n\ngoal (3 subgoals):\n 1. \\<And>x f. merge_env mergec (csingle x) f = f x\n 2. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env mergec (csingle x) f = f x\" for f :: \"'c \\<Rightarrow> ('b, 'm) envT\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env mergec (csingle x) f = f x", "by(rule envT.expand)(simp add: fun_eq_iff mergec_single)"], ["proof (state)\nthis:\n  merge_env mergec (csingle ?x2) ?f2 = ?f2 ?x2\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       merge_env mergec (cUnion (cimage f C)) g =\n       merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"merge_env mergec (cUNION C f) g = merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)\"\n      for C f and g :: \"'c \\<Rightarrow> ('b, 'm) envT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. merge_env mergec (cUnion (cimage f C)) g =\n    merge_env mergec C (\\<lambda>x. merge_env mergec (f x) g)", "by(rule envT.expand)(simp add: fun_eq_iff mergec_UNION)"], ["proof (state)\nthis:\n  merge_env mergec (cUnion (cimage ?f2 ?C2)) ?g2 =\n  merge_env mergec ?C2 (\\<lambda>x. merge_env mergec (?f2 x) ?g2)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n        (merge_env mergec)", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec) (merge_env mergec)\" \n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) (merge_env mergec)\n     (merge_env mergec)", "unfolding merge_env_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>A f.\n         EnvT (\\<lambda>r. mergec A (\\<lambda>a. run_env (f a) r)))\n     (\\<lambda>A f.\n         EnvT (\\<lambda>r. mergec A (\\<lambda>a. run_env (f a) r)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R3 \\<Longrightarrow>\n  (rel_cset ?R3 ===> (?R3 ===> (=)) ===> (=)) (merge_env mergec)\n   (merge_env mergec)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cset_nondetM (return_env return) (bind_env bind) (merge_env merge)\n   (merge_env mergec)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* paragraph \\<open>Exception monad transformer\\<close>\n\ntext \\<open>Failure in the non-determinism transformer is absorbed by choice. So there is no way to handle \n  failures. In contrast, in this combination, we choose that failures abort all choices.\\<close>\n\ncontext\n  fixes return :: \"('a cset option, 'm) return\"\n    and bind :: \"('a cset option, 'm) bind\"\n    and merge :: \"('a option, 'm, 'a option cset) merge\"\nbegin\n\ndefinition merge_option :: \"('a, ('a cset, 'm) optionT, 'a cset) merge\" where\n  \"merge_option A f = \n  OptionT (merge (cimage Some A) (\\<lambda>x. case x of None \\<Rightarrow> return None\n                                      | Some x' \\<Rightarrow> run_option (f x')))\"\nlemma run_merge_optionT [simp]:\n  \"run_option (merge_option A f) = \n  merge (cimage Some A) (\\<lambda>x. case x of None \\<Rightarrow> return None | Some x' \\<Rightarrow> run_option (f x'))\"\n  by(simp add: merge_option_def)\n\ndefinition return_optionT_cset :: \"('a option cset, 'm) return\" where\n  \"return_optionT_cset A = (if cin None A then return None else return (Some (cimage the A)))\"\n\ndefinition bind_optionT_cset :: \"('a option cset, 'm) bind\" where\n  \"bind_optionT_cset m f = \n   bind m (\\<lambda>x. case x of None \\<Rightarrow> return None | Some A \\<Rightarrow> f (cimage Some A))\"\n\n(* lemma\n  assumes \"monad return_optionT_cset bind_optionT_cset\"\n  shows \"monad return bind\"\nproof -\n  interpret monad return_optionT_cset bind_optionT_cset by fact\n  show ?thesis\n  proof(unfold_locales)\n    show \"bind (return x) f = f x\" for x f\n      using return_bind[of \"case x of None \\<Rightarrow> csingle None | Some A \\<Rightarrow> cimage Some A\" ff]\n      apply(simp add: bind_optionT_cset_def return_optionT_cset_def split: option.split_asm)\n    subgoal for m f g\n      using bind_assoc[of m \"\\<lambda>A. if cin None A then return None else f (Some (cimage the A))\" \"\\<lambda>A. if cin None A then return None else g (Some (cimage the A))\"]\n      apply(simp add: bind_optionT_cset_def)\n      apply(subst (asm) if_distrib[where f=\"\\<lambda>m. bind m _\"])\n *)\n\nlemma cset_nondetM_optionT [locale_witness]:\n  assumes \"monad_commute return bind\"\n    and \"monad_discard return bind\"\n    and \"monad_duplicate return bind\"\n    and \"cset_nondetM return_optionT_cset bind_optionT_cset merge\"\n  shows \"cset_nondetM (return_option return) (bind_option return bind) merge_option\"\nproof -\n  interpret monad_commute return bind by fact\n  interpret monad_discard return bind by fact\n  interpret monad_duplicate return bind by fact\n  interpret *: cset_nondetM return_optionT_cset bind_optionT_cset merge by fact\n  show ?thesis\n  proof\n    show \"bind_option return bind (merge_option y f)\n        (\\<lambda>A. merge_option A g) =\n       merge_option y\n        (\\<lambda>x. bind_option return bind (f x) (\\<lambda>A. merge_option A g))\" for y f g\n      apply(rule optionT.expand)\n      apply(simp add: run_bind_option cong del: option.case_cong) *)"], ["", "subsection \\<open>State transformer\\<close>"], ["", "datatype ('s, 'm) stateT = StateT (run_state: \"'s \\<Rightarrow> 'm\")\n  for rel: rel_stateT'"], ["", "text \\<open>\n  We define a more general relator for @{typ \"(_, _) stateT\"} than the one generated\n  by the datatype package such that we can also show parametricity in the state.\n\\<close>"], ["", "context includes lifting_syntax begin"], ["", "definition rel_stateT :: \"('s \\<Rightarrow> 's' \\<Rightarrow> bool) \\<Rightarrow> ('m \\<Rightarrow> 'm' \\<Rightarrow> bool) \\<Rightarrow> ('s, 'm) stateT \\<Rightarrow> ('s', 'm') stateT \\<Rightarrow> bool\"\nwhere \"rel_stateT S M m m' \\<longleftrightarrow> (S ===> M) (run_state m) (run_state m')\""], ["", "lemma rel_stateT_eq [relator_eq]: \"rel_stateT (=) (=) = (=)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stateT (=) (=) = (=)", "by(auto simp add: rel_stateT_def fun_eq_iff rel_fun_eq intro: stateT.expand)"], ["", "lemma rel_stateT_mono [relator_mono]: \"\\<lbrakk> S' \\<le> S; M \\<le> M' \\<rbrakk> \\<Longrightarrow> rel_stateT S M \\<le> rel_stateT S' M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>S' \\<le> S; M \\<le> M'\\<rbrakk>\n    \\<Longrightarrow> rel_stateT S M \\<le> rel_stateT S' M'", "by(rule predicate2I)(simp add: rel_stateT_def fun_mono[THEN predicate2D])"], ["", "lemma StateT_parametric [transfer_rule]: \"((S ===> M) ===> rel_stateT S M) StateT StateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M) ===> rel_stateT S M) StateT StateT", "by(auto simp add: rel_stateT_def)"], ["", "lemma run_state_parametric [transfer_rule]: \"(rel_stateT S M ===> S ===> M) run_state run_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_stateT S M ===> S ===> M) run_state run_state", "by(auto simp add: rel_stateT_def)"], ["", "lemma case_stateT_parametric [transfer_rule]: \n  \"(((S ===> M) ===> A) ===> rel_stateT S M ===> A) case_stateT case_stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> A) ===> rel_stateT S M ===> A) case_stateT case_stateT", "by(auto 4 3 split: stateT.split simp add: rel_stateT_def del: rel_funI intro!: rel_funI dest: rel_funD)"], ["", "lemma rec_stateT_parametric [transfer_rule]: \n  \"(((S ===> M) ===> A) ===> rel_stateT S M ===> A) rec_stateT rec_stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> A) ===> rel_stateT S M ===> A) rec_stateT rec_stateT", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>((S ===> M) ===> A) x y; rel_stateT S M xa ya\\<rbrakk>\n       \\<Longrightarrow> A (rec_stateT x xa) (rec_stateT y ya)", "subgoal for \\<dots> m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>((S ===> M) ===> A) x_ y_; rel_stateT S M m m'\\<rbrakk>\n    \\<Longrightarrow> A (rec_stateT x_ m) (rec_stateT y_ m')", "by(cases m; cases m')(auto 4 3 simp add: rel_stateT_def del: rel_funI intro!: rel_funI dest: rel_funD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma rel_stateT_Grp: \"rel_stateT (=) (BNF_Def.Grp UNIV f) = BNF_Def.Grp UNIV (map_stateT f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stateT (=) (BNF_Def.Grp UNIV f) = BNF_Def.Grp UNIV (map_stateT f)", "by(auto simp add: fun_eq_iff Grp_def rel_stateT_def rel_fun_def stateT.map_sel intro: stateT.expand)"], ["", "end"], ["", "subsubsection \\<open>Plain monad, get, and put\\<close>"], ["", "context \n  fixes return :: \"('a \\<times> 's, 'm) return\"\n  and bind :: \"('a \\<times> 's, 'm) bind\"\nbegin"], ["", "primrec bind_state :: \"('a, ('s, 'm) stateT) bind\"\nwhere \"bind_state (StateT x) f = StateT (\\<lambda>s. bind (x s) (\\<lambda>(a, s'). run_state (f a) s'))\""], ["", "definition return_state :: \"('a, ('s, 'm) stateT) return\"\nwhere \"return_state x = StateT (\\<lambda>s. return (x, s))\""], ["", "definition get_state :: \"('s, ('s, 'm) stateT) get\"\nwhere \"get_state f = StateT (\\<lambda>s. run_state (f s) s)\""], ["", "primrec put_state :: \"('s, ('s, 'm) stateT) put\"\nwhere \"put_state s (StateT f) = StateT (\\<lambda>_. f s)\""], ["", "lemma run_put_state [simp]: \"run_state (put_state s m) s' = run_state m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.put_state s m) s' = run_state m s", "by(cases m) simp"], ["", "lemma run_get_state [simp]: \"run_state (get_state f) s = run_state (f s) s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.get_state f) s = run_state (f s) s", "by(simp add: get_state_def)"], ["", "lemma run_bind_state [simp]:\n  \"run_state (bind_state x f) s = bind (run_state x s) (\\<lambda>(a, s'). run_state (f a) s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.bind_state x f) s =\n    bind (run_state x s) (\\<lambda>(a, s'). run_state (f a) s')", "by(cases x)(simp)"], ["", "lemma run_return_state [simp]:\n  \"run_state (return_state x) s = return (x, s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.return_state x) s = return (x, s)", "by(simp add: return_state_def)"], ["", "context\n  assumes monad: \"monad return bind\"\nbegin"], ["", "interpretation monad return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return bind", "by(fact monad)"], ["", "lemma monad_stateT [locale_witness]: \"monad return_state bind_state\" (is \"monad ?return ?bind\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad local.return_state local.bind_state", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       local.bind_state (local.bind_state x f) g =\n       local.bind_state x (\\<lambda>y. local.bind_state (f y) g)\n 2. \\<And>x f. local.bind_state (local.return_state x) f = f x\n 3. \\<And>x. local.bind_state x local.return_state = x", "show \"?bind (?bind x f) g = ?bind x (\\<lambda>x. ?bind (f x) g)\" for x and f g :: \"'a \\<Rightarrow> ('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.bind_state x f) g =\n    local.bind_state x (\\<lambda>x. local.bind_state (f x) g)", "by(rule stateT.expand ext)+(simp add: bind_assoc split_def)"], ["proof (state)\nthis:\n  local.bind_state (local.bind_state ?x ?f) ?g =\n  local.bind_state ?x (\\<lambda>x. local.bind_state (?f x) ?g)\n\ngoal (2 subgoals):\n 1. \\<And>x f. local.bind_state (local.return_state x) f = f x\n 2. \\<And>x. local.bind_state x local.return_state = x", "show \"?bind (?return x) f = f x\" for f :: \"'a \\<Rightarrow> ('s, 'm) stateT\" and x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.return_state x) f = f x", "by(rule stateT.expand ext)+(simp add: return_bind)"], ["proof (state)\nthis:\n  local.bind_state (local.return_state ?x) ?f = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. local.bind_state x local.return_state = x", "show \"?bind x ?return = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state x local.return_state = x", "by(rule stateT.expand ext)+(simp add: bind_return)"], ["proof (state)\nthis:\n  local.bind_state ?x local.return_state = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_stateT [locale_witness]:\n  \"monad_state return_state bind_state get_state put_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_state local.bind_state local.get_state\n     local.put_state", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f.\n       local.put_state s (local.get_state f) = local.put_state s (f s)\n 2. \\<And>f.\n       local.get_state (\\<lambda>s. local.get_state (f s)) =\n       local.get_state (\\<lambda>s. f s s)\n 3. \\<And>s s' m.\n       local.put_state s (local.put_state s' m) = local.put_state s' m\n 4. \\<And>m. local.get_state (\\<lambda>s. local.put_state s m) = m\n 5. \\<And>m. local.get_state (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 7. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"put_state s (get_state f) = put_state s (f s)\" for f :: \"'s \\<Rightarrow> ('s, 'm) stateT\" and s :: \"'s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_state s (local.get_state f) = local.put_state s (f s)", "by(rule stateT.expand)(simp add: get_state_def fun_eq_iff)"], ["proof (state)\nthis:\n  local.put_state ?s (local.get_state ?f) = local.put_state ?s (?f ?s)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       local.get_state (\\<lambda>s. local.get_state (f s)) =\n       local.get_state (\\<lambda>s. f s s)\n 2. \\<And>s s' m.\n       local.put_state s (local.put_state s' m) = local.put_state s' m\n 3. \\<And>m. local.get_state (\\<lambda>s. local.put_state s m) = m\n 4. \\<And>m. local.get_state (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 6. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"get_state (\\<lambda>s. get_state (f s)) = get_state (\\<lambda>s. f s s)\" for f :: \"'s \\<Rightarrow> 's \\<Rightarrow> ('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_state (\\<lambda>s. local.get_state (f s)) =\n    local.get_state (\\<lambda>s. f s s)", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_state (\\<lambda>s. local.get_state (?f s)) =\n  local.get_state (\\<lambda>s. ?f s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m.\n       local.put_state s (local.put_state s' m) = local.put_state s' m\n 2. \\<And>m. local.get_state (\\<lambda>s. local.put_state s m) = m\n 3. \\<And>m. local.get_state (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 5. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"put_state s (put_state s' m) = put_state s' m\" for s s' :: 's and m :: \"('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_state s (local.put_state s' m) = local.put_state s' m", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.put_state ?s (local.put_state ?s' ?m) = local.put_state ?s' ?m\n\ngoal (4 subgoals):\n 1. \\<And>m. local.get_state (\\<lambda>s. local.put_state s m) = m\n 2. \\<And>m. local.get_state (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 4. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"get_state (\\<lambda>s :: 's. put_state s m) = m\" for m :: \"('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_state (\\<lambda>s. local.put_state s m) = m", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_state (\\<lambda>s. local.put_state s ?m) = ?m\n\ngoal (3 subgoals):\n 1. \\<And>m. local.get_state (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 3. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"get_state (\\<lambda>_. m) = m\" for m :: \"('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_state (\\<lambda>_. m) = m", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_state (\\<lambda>_. ?m) = ?m\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_state (local.get_state f) g =\n       local.get_state (\\<lambda>s. local.bind_state (f s) g)\n 2. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"bind_state (get_state f) g = get_state (\\<lambda>s. bind_state (f s) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.get_state f) g =\n    local.get_state (\\<lambda>s. local.bind_state (f s) g)", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_state (local.get_state ?f) ?g =\n  local.get_state (\\<lambda>s. local.bind_state (?f s) ?g)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       local.bind_state (local.put_state s m) f =\n       local.put_state s (local.bind_state m f)", "show \"bind_state (put_state s m) f = put_state s (bind_state m f)\" for s :: 's and m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.put_state s m) f =\n    local.put_state s (local.bind_state m f)", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_state (local.put_state ?s ?m) ?f =\n  local.put_state ?s (local.bind_state ?m ?f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n  We cannot define a generic lifting operation for state like in Haskell.\n  If we separate the monad type variable from the element type variable, then\n  \\<open>lift\\<close> should have type \\<open>'a 'm => (('a \\<times> 's) 'm) stateT\\<close>, but this means\n  that the type of results must change, which does not work for monomorphic monads.\n\n  Instead, we must lift all operations individually. \\<open>lift_definition\\<close> does not work\n  because the monad transformer type is typically larger than the base type, but\n  \\<open>lift_definition\\<close> only works if the lifted type is no bigger.\n\\<close>"], ["", "subsubsection \\<open>Failure\\<close>"], ["", "context\n  fixes fail :: \"'m fail\"\nbegin"], ["", "definition fail_state :: \"('s, 'm) stateT fail\"\nwhere \"fail_state = StateT (\\<lambda>s. fail)\""], ["", "lemma run_fail_state [simp]: \"run_state fail_state s = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state local.fail_state s = fail", "by(simp add: fail_state_def)"], ["", "lemma monad_fail_stateT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_state bind_state fail_state\" (is \"monad_fail ?return ?bind ?fail\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail local.return_state local.bind_state local.fail_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_state local.bind_state local.fail_state", "interpret monad_fail return bind fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return bind fail", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_state local.bind_state local.fail_state", "have \"?bind ?fail f = ?fail\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state local.fail_state f = local.fail_state", "by(rule stateT.expand)(simp add: fun_eq_iff fail_bind)"], ["proof (state)\nthis:\n  local.bind_state local.fail_state ?f = local.fail_state\n\ngoal (1 subgoal):\n 1. monad_fail local.return_state local.bind_state local.fail_state", "then"], ["proof (chain)\npicking this:\n  local.bind_state local.fail_state ?f = local.fail_state", "show ?thesis"], ["proof (prove)\nusing this:\n  local.bind_state local.fail_state ?f = local.fail_state\n\ngoal (1 subgoal):\n 1. monad_fail local.return_state local.bind_state local.fail_state", "by unfold_locales"], ["proof (state)\nthis:\n  monad_fail local.return_state local.bind_state local.fail_state\n\ngoal:\nNo subgoals!", "qed"], ["", "notepad begin"], ["proof (state)", "text \\<open>\n    \\<open>catch\\<close> cannot be lifted through the state monad according to @{term monad_catch_state}\n   because there is now way to communicate the state updates to the handler.\n  \\<close>"], ["proof (state)", "fix catch :: \"'m catch\""], ["proof (state)", "assume \"monad_catch return bind fail catch\""], ["proof (state)\nthis:\n  monad_catch return bind fail catch", "then"], ["proof (chain)\npicking this:\n  monad_catch return bind fail catch", "interpret monad_catch return bind fail catch"], ["proof (prove)\nusing this:\n  monad_catch return bind fail catch\n\ngoal (1 subgoal):\n 1. monad_catch return bind fail catch", "."], ["proof (state)", "define catch_state :: \"('s, 'm) stateT catch\" where\n    \"catch_state m1 m2 = StateT (\\<lambda>s. catch (run_state m1 s) (run_state m2 s))\" for m1 m2"], ["proof (state)\nthis:\n  catch_state ?m1.0 ?m2.0 =\n  StateT (\\<lambda>s. catch (run_state ?m1.0 s) (run_state ?m2.0 s))", "have \"monad_catch return_state bind_state fail_state catch_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_catch local.return_state local.bind_state local.fail_state\n     catch_state", "by(unfold_locales; rule stateT.expand; simp add: fun_eq_iff catch_state_def catch_return catch_fail catch_fail2 catch_assoc)"], ["proof (state)\nthis:\n  monad_catch local.return_state local.bind_state local.fail_state\n   catch_state", "end"], ["", "end"], ["", "subsubsection \\<open>Reader\\<close>"], ["", "context\n  fixes ask :: \"('r, 'm) ask\"\nbegin"], ["", "definition ask_state :: \"('r, ('s, 'm) stateT) ask\"\nwhere \"ask_state f = StateT (\\<lambda>s. ask (\\<lambda>r. run_state (f r) s))\""], ["", "lemma run_ask_state [simp]:\n  \"run_state (ask_state f) s = ask (\\<lambda>r. run_state (f r) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.ask_state f) s = ask (\\<lambda>r. run_state (f r) s)", "by(simp add: ask_state_def)"], ["", "lemma monad_reader_stateT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_state bind_state ask_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_state local.bind_state local.ask_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_state local.bind_state local.ask_state", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_state local.bind_state local.ask_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_state local.bind_state local.ask_state", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       local.ask_state (\\<lambda>r. local.ask_state (f r)) =\n       local.ask_state (\\<lambda>r. f r r)\n 2. \\<And>m. local.ask_state (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_state (local.ask_state f) g =\n       local.ask_state (\\<lambda>r. local.bind_state (f r) g)\n 4. \\<And>m f.\n       local.bind_state m (\\<lambda>x. local.ask_state (f x)) =\n       local.ask_state (\\<lambda>r. local.bind_state m (\\<lambda>x. f x r))", "show \"ask_state (\\<lambda>r. ask_state (f r)) = ask_state (\\<lambda>r. f r r)\" for f :: \"'r \\<Rightarrow> 'r \\<Rightarrow> ('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_state (\\<lambda>r. local.ask_state (f r)) =\n    local.ask_state (\\<lambda>r. f r r)", "by(rule stateT.expand)(simp add: fun_eq_iff ask_ask)"], ["proof (state)\nthis:\n  local.ask_state (\\<lambda>r. local.ask_state (?f r)) =\n  local.ask_state (\\<lambda>r. ?f r r)\n\ngoal (3 subgoals):\n 1. \\<And>m. local.ask_state (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_state (local.ask_state f) g =\n       local.ask_state (\\<lambda>r. local.bind_state (f r) g)\n 3. \\<And>m f.\n       local.bind_state m (\\<lambda>x. local.ask_state (f x)) =\n       local.ask_state (\\<lambda>r. local.bind_state m (\\<lambda>x. f x r))", "show \"ask_state (\\<lambda>_. x) = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_state (\\<lambda>_. x) = x", "by(rule stateT.expand)(simp add: fun_eq_iff ask_const)"], ["proof (state)\nthis:\n  local.ask_state (\\<lambda>_. ?x) = ?x\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_state (local.ask_state f) g =\n       local.ask_state (\\<lambda>r. local.bind_state (f r) g)\n 2. \\<And>m f.\n       local.bind_state m (\\<lambda>x. local.ask_state (f x)) =\n       local.ask_state (\\<lambda>r. local.bind_state m (\\<lambda>x. f x r))", "show \"bind_state (ask_state f) g = ask_state (\\<lambda>r. bind_state (f r) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.ask_state f) g =\n    local.ask_state (\\<lambda>r. local.bind_state (f r) g)", "by(rule stateT.expand)(simp add: fun_eq_iff bind_ask)"], ["proof (state)\nthis:\n  local.bind_state (local.ask_state ?f) ?g =\n  local.ask_state (\\<lambda>r. local.bind_state (?f r) ?g)\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_state m (\\<lambda>x. local.ask_state (f x)) =\n       local.ask_state (\\<lambda>r. local.bind_state m (\\<lambda>x. f x r))", "show \"bind_state m (\\<lambda>x. ask_state (f x)) = ask_state (\\<lambda>r. bind_state m (\\<lambda>x. f x r))\" for m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state m (\\<lambda>x. local.ask_state (f x)) =\n    local.ask_state (\\<lambda>r. local.bind_state m (\\<lambda>x. f x r))", "by(rule stateT.expand)(simp add: fun_eq_iff bind_ask2 split_def)"], ["proof (state)\nthis:\n  local.bind_state ?m (\\<lambda>x. local.ask_state (?f x)) =\n  local.ask_state (\\<lambda>r. local.bind_state ?m (\\<lambda>x. ?f x r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_reader local.return_state local.bind_state local.ask_state\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_reader_state_stateT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader_state return_state bind_state ask_state get_state put_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_state local.bind_state local.ask_state\n     local.get_state local.put_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_state local.bind_state local.ask_state\n     local.get_state local.put_state", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_state local.bind_state local.ask_state\n     local.get_state local.put_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_state local.bind_state local.ask_state\n     local.get_state local.put_state", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       local.ask_state (\\<lambda>r. local.get_state (f r)) =\n       local.get_state (\\<lambda>s. local.ask_state (\\<lambda>r. f r s))\n 2. \\<And>s f.\n       local.put_state s (local.ask_state f) =\n       local.ask_state (\\<lambda>r. local.put_state s (f r))", "show \"ask_state (\\<lambda>r. get_state (f r)) = get_state (\\<lambda>s. ask_state (\\<lambda>r. f r s))\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_state (\\<lambda>r. local.get_state (f r)) =\n    local.get_state (\\<lambda>s. local.ask_state (\\<lambda>r. f r s))", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.ask_state (\\<lambda>r. local.get_state (?f r)) =\n  local.get_state (\\<lambda>s. local.ask_state (\\<lambda>r. ?f r s))\n\ngoal (1 subgoal):\n 1. \\<And>s f.\n       local.put_state s (local.ask_state f) =\n       local.ask_state (\\<lambda>r. local.put_state s (f r))", "show \"put_state m (ask_state f) = ask_state (\\<lambda>r. put_state m (f r))\" for m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_state m (local.ask_state f) =\n    local.ask_state (\\<lambda>r. local.put_state m (f r))", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.put_state ?m (local.ask_state ?f) =\n  local.ask_state (\\<lambda>r. local.put_state ?m (?f r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_reader_state local.return_state local.bind_state local.ask_state\n   local.get_state local.put_state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Probability\\<close>"], ["", "definition altc_sample_state :: \"('x \\<Rightarrow> ('b \\<Rightarrow> 'm) \\<Rightarrow> 'm) \\<Rightarrow> 'x \\<Rightarrow> ('b \\<Rightarrow> ('s, 'm) stateT) \\<Rightarrow> ('s, 'm) stateT\"\nwhere \"altc_sample_state altc_sample p f = StateT (\\<lambda>s. altc_sample p (\\<lambda>x. run_state (f x) s))\""], ["", "lemma run_altc_sample_state [simp]:\n  \"run_state (altc_sample_state altc_sample p f) s = altc_sample p (\\<lambda>x. run_state (f x) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.altc_sample_state altc_sample p f) s =\n    altc_sample p (\\<lambda>x. run_state (f x) s)", "by(simp add: altc_sample_state_def)"], ["", "context\n  fixes sample :: \"('p, 'm) sample\"\nbegin"], ["", "abbreviation sample_state :: \"('p, ('s, 'm) stateT) sample\" where\n  \"sample_state \\<equiv> altc_sample_state sample\""], ["", "context\n  assumes \"monad_prob return bind sample\"\nbegin"], ["", "interpretation monad_prob return bind sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return bind sample", "by(fact)"], ["", "lemma monad_prob_stateT [locale_witness]: \"monad_prob return_state bind_state sample_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_state local.bind_state local.sample_state", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_state local.bind_state local.sample_state", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p m. local.sample_state p (\\<lambda>_. m) = m\n 2. \\<And>x f. local.sample_state (return_pmf x) f = f x\n 3. \\<And>p f g.\n       local.sample_state (p \\<bind> f) g =\n       local.sample_state p (\\<lambda>x. local.sample_state (f x) g)\n 4. \\<And>p q f.\n       local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n       local.sample_state q\n        (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 6. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "note sample_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  (rel_pmf ?R ===> (?R ===> (=)) ===> (=)) sample sample\n\ngoal (7 subgoals):\n 1. \\<And>p m. local.sample_state p (\\<lambda>_. m) = m\n 2. \\<And>x f. local.sample_state (return_pmf x) f = f x\n 3. \\<And>p f g.\n       local.sample_state (p \\<bind> f) g =\n       local.sample_state p (\\<lambda>x. local.sample_state (f x) g)\n 4. \\<And>p q f.\n       local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n       local.sample_state q\n        (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 6. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"sample_state p (\\<lambda>_. x) = x\" for p x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_state p (\\<lambda>_. x) = x", "by(rule stateT.expand)(simp add: fun_eq_iff sample_const)"], ["proof (state)\nthis:\n  local.sample_state ?p2 (\\<lambda>_. ?x2) = ?x2\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.sample_state (return_pmf x) f = f x\n 2. \\<And>p f g.\n       local.sample_state (p \\<bind> f) g =\n       local.sample_state p (\\<lambda>x. local.sample_state (f x) g)\n 3. \\<And>p q f.\n       local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n       local.sample_state q\n        (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))\n 4. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 5. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"sample_state (return_pmf x) f = f x\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_state (return_pmf x) f = f x", "by(rule stateT.expand)(simp add: fun_eq_iff sample_return_pmf)"], ["proof (state)\nthis:\n  local.sample_state (return_pmf ?x2) ?f2 = ?f2 ?x2\n\ngoal (5 subgoals):\n 1. \\<And>p f g.\n       local.sample_state (p \\<bind> f) g =\n       local.sample_state p (\\<lambda>x. local.sample_state (f x) g)\n 2. \\<And>p q f.\n       local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n       local.sample_state q\n        (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))\n 3. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 4. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"sample_state (bind_pmf p f) g = sample_state p (\\<lambda>x. sample_state (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_state (p \\<bind> f) g =\n    local.sample_state p (\\<lambda>x. local.sample_state (f x) g)", "by(rule stateT.expand)(simp add: fun_eq_iff sample_bind_pmf)"], ["proof (state)\nthis:\n  local.sample_state (?p2 \\<bind> ?f2) ?g2 =\n  local.sample_state ?p2 (\\<lambda>x. local.sample_state (?f2 x) ?g2)\n\ngoal (4 subgoals):\n 1. \\<And>p q f.\n       local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n       local.sample_state q\n        (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))\n 2. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 3. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"sample_state p (\\<lambda>x. sample_state q (f x)) = sample_state q (\\<lambda>y. sample_state p (\\<lambda>x. f x y))\" for p q f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_state p (\\<lambda>x. local.sample_state q (f x)) =\n    local.sample_state q\n     (\\<lambda>y. local.sample_state p (\\<lambda>x. f x y))", "by(rule stateT.expand)(auto simp add: fun_eq_iff intro: sample_commute)"], ["proof (state)\nthis:\n  local.sample_state ?p2 (\\<lambda>x. local.sample_state ?q2 (?f2 x)) =\n  local.sample_state ?q2\n   (\\<lambda>y. local.sample_state ?p2 (\\<lambda>x. ?f2 x y))\n\ngoal (3 subgoals):\n 1. \\<And>p f g.\n       local.bind_state (local.sample_state p f) g =\n       local.sample_state p (\\<lambda>x. local.bind_state (f x) g)\n 2. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"bind_state (sample_state p f) g = sample_state p (\\<lambda>x. bind_state (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.sample_state p f) g =\n    local.sample_state p (\\<lambda>x. local.bind_state (f x) g)", "by(rule stateT.expand)(simp add: fun_eq_iff bind_sample1)"], ["proof (state)\nthis:\n  local.bind_state (local.sample_state ?p2 ?f2) ?g2 =\n  local.sample_state ?p2 (\\<lambda>x. local.bind_state (?f2 x) ?g2)\n\ngoal (2 subgoals):\n 1. \\<And>m f p.\n       local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n       local.sample_state p\n        (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"bind_state m (\\<lambda>y. sample_state p (f y)) = sample_state p (\\<lambda>x. bind_state m (\\<lambda>y. f y x))\" for m p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state m (\\<lambda>y. local.sample_state p (f y)) =\n    local.sample_state p\n     (\\<lambda>x. local.bind_state m (\\<lambda>y. f y x))", "by(rule stateT.expand)(simp add: fun_eq_iff bind_sample2 split_def)"], ["proof (state)\nthis:\n  local.bind_state ?m2 (\\<lambda>y. local.sample_state ?p2 (?f2 y)) =\n  local.sample_state ?p2\n   (\\<lambda>x. local.bind_state ?m2 (\\<lambda>y. ?f2 y x))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n        local.sample_state", "show \"(rel_pmf R ===> (R ===> (=)) ===> (=)) sample_state sample_state\"\n    if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_state\n     local.sample_state", "unfolding altc_sample_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f.\n         StateT (\\<lambda>s. sample p (\\<lambda>x. run_state (f x) s)))\n     (\\<lambda>p f.\n         StateT (\\<lambda>s. sample p (\\<lambda>x. run_state (f x) s)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R2 \\<Longrightarrow>\n  (rel_pmf ?R2 ===> (?R2 ===> (=)) ===> (=)) local.sample_state\n   local.sample_state\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_prob_stateT [locale_witness]:\n  \"monad_state_prob return_state bind_state get_state put_state sample_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_state local.bind_state local.get_state\n     local.put_state local.sample_state", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f.\n       local.sample_state p (\\<lambda>x. local.get_state (f x)) =\n       local.get_state\n        (\\<lambda>s. local.sample_state p (\\<lambda>x. f x s))", "show \"sample_state p (\\<lambda>x. get_state (f x)) = get_state (\\<lambda>s. sample_state p (\\<lambda>x. f x s))\" for p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_state p (\\<lambda>x. local.get_state (f x)) =\n    local.get_state (\\<lambda>s. local.sample_state p (\\<lambda>x. f x s))", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.sample_state ?p2 (\\<lambda>x. local.get_state (?f2 x)) =\n  local.get_state (\\<lambda>s. local.sample_state ?p2 (\\<lambda>x. ?f2 x s))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Writer\\<close>"], ["", "context\n  fixes tell :: \"('w, 'm) tell\"\nbegin"], ["", "definition tell_state :: \"('w, ('s, 'm) stateT) tell\"\nwhere \"tell_state w m = StateT (\\<lambda>s. tell w (run_state m s))\""], ["", "lemma run_tell_state [simp]: \"run_state (tell_state w m) s = tell w (run_state m s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.tell_state w m) s = tell w (run_state m s)", "by(simp add: tell_state_def)"], ["", "lemma monad_writer_stateT [locale_witness]:\n  assumes \"monad_writer return bind tell\"\n  shows \"monad_writer return_state bind_state tell_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_state local.bind_state local.tell_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_state local.bind_state local.tell_state", "interpret monad_writer return bind tell"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer return bind tell", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_writer local.return_state local.bind_state local.tell_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_state local.bind_state local.tell_state", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w m f.\n       local.bind_state (local.tell_state w m) f =\n       local.tell_state w (local.bind_state m f)", "show \"bind_state (tell_state w m) f = tell_state w (bind_state m f)\" for w m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.tell_state w m) f =\n    local.tell_state w (local.bind_state m f)", "by(rule stateT.expand)(simp add: bind_tell fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_state (local.tell_state ?w3 ?m3) ?f3 =\n  local.tell_state ?w3 (local.bind_state ?m3 ?f3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_writer local.return_state local.bind_state local.tell_state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Binary Non-determinism\\<close>"], ["", "context\n  fixes alt :: \"'m alt\"\nbegin"], ["", "definition alt_state :: \"('s, 'm) stateT alt\"\nwhere \"alt_state m1 m2 = StateT (\\<lambda>s. alt (run_state m1 s) (run_state m2 s))\""], ["", "lemma run_alt_state [simp]: \"run_state (alt_state m1 m2) s = alt (run_state m1 s) (run_state m2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.alt_state m1 m2) s =\n    alt (run_state m1 s) (run_state m2 s)", "by(simp add: alt_state_def)"], ["", "context assumes \"monad_alt return bind alt\" begin"], ["", "interpretation monad_alt return bind alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return bind alt", "by fact"], ["", "lemma monad_alt_stateT [locale_witness]: \"monad_alt return_state bind_state alt_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_state local.bind_state local.alt_state", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3.\n       local.alt_state (local.alt_state m1 m2) m3 =\n       local.alt_state m1 (local.alt_state m2 m3)\n 2. \\<And>m m' f.\n       local.bind_state (local.alt_state m m') f =\n       local.alt_state (local.bind_state m f) (local.bind_state m' f)", "show \"alt_state (alt_state m1 m2) m3 = alt_state m1 (alt_state m2 m3)\" for m1 m2 m3"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_state (local.alt_state m1 m2) m3 =\n    local.alt_state m1 (local.alt_state m2 m3)", "by(rule stateT.expand)(simp add: alt_assoc fun_eq_iff)"], ["proof (state)\nthis:\n  local.alt_state (local.alt_state ?m1.4 ?m2.4) ?m3.4 =\n  local.alt_state ?m1.4 (local.alt_state ?m2.4 ?m3.4)\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_state (local.alt_state m m') f =\n       local.alt_state (local.bind_state m f) (local.bind_state m' f)", "show \"bind_state (alt_state m m') f = alt_state (bind_state m f) (bind_state m' f)\" for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.alt_state m m') f =\n    local.alt_state (local.bind_state m f) (local.bind_state m' f)", "by(rule stateT.expand)(simp add: bind_alt1 fun_eq_iff)"], ["proof (state)\nthis:\n  local.bind_state (local.alt_state ?m4 ?m'4) ?f4 =\n  local.alt_state (local.bind_state ?m4 ?f4) (local.bind_state ?m'4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_alt_stateT [locale_witness]:\n  \"monad_state_alt return_state bind_state get_state put_state alt_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_state local.bind_state local.get_state\n     local.put_state local.alt_state", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.alt_state (local.get_state f) (local.get_state g) =\n       local.get_state (\\<lambda>x. local.alt_state (f x) (g x))\n 2. \\<And>s m m'.\n       local.alt_state (local.put_state s m) (local.put_state s m') =\n       local.put_state s (local.alt_state m m')", "show \"alt_state (get_state f) (get_state g) = get_state (\\<lambda>x. alt_state (f x) (g x))\"\n    for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_state (local.get_state f) (local.get_state g) =\n    local.get_state (\\<lambda>x. local.alt_state (f x) (g x))", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.alt_state (local.get_state ?f4) (local.get_state ?g4) =\n  local.get_state (\\<lambda>x. local.alt_state (?f4 x) (?g4 x))\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       local.alt_state (local.put_state s m) (local.put_state s m') =\n       local.put_state s (local.alt_state m m')", "show \"alt_state (put_state s m) (put_state s m') = put_state s (alt_state m m')\"\n    for s m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_state (local.put_state s m) (local.put_state s m') =\n    local.put_state s (local.alt_state m m')", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.alt_state (local.put_state ?s4 ?m4) (local.put_state ?s4 ?m'4) =\n  local.put_state ?s4 (local.alt_state ?m4 ?m'4)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma monad_fail_alt_stateT [locale_witness]:\n  fixes fail\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_state bind_state (fail_state fail) alt_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_state local.bind_state\n     (local.fail_state fail) local.alt_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_state local.bind_state\n     (local.fail_state fail) local.alt_state", "interpret monad_fail_alt return bind fail alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt return bind fail alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_state local.bind_state\n     (local.fail_state fail) local.alt_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_state local.bind_state\n     (local.fail_state fail) local.alt_state", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. local.alt_state (local.fail_state fail) m = m\n 2. \\<And>m. local.alt_state m (local.fail_state fail) = m", "show  \"alt_state (fail_state fail) m = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_state (local.fail_state fail) m = m", "by(rule stateT.expand)(simp add: fun_eq_iff alt_fail1)"], ["proof (state)\nthis:\n  local.alt_state (local.fail_state fail) ?m4 = ?m4\n\ngoal (1 subgoal):\n 1. \\<And>m. local.alt_state m (local.fail_state fail) = m", "show \"alt_state m (fail_state fail) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_state m (local.fail_state fail) = m", "by(rule stateT.expand)(simp add: fun_eq_iff alt_fail2)"], ["proof (state)\nthis:\n  local.alt_state ?m4 (local.fail_state fail) = ?m4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_fail_alt local.return_state local.bind_state (local.fail_state fail)\n   local.alt_state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Countable Non-determinism\\<close>"], ["", "context\n  fixes altc :: \"('c, 'm) altc\"\nbegin"], ["", "abbreviation altc_state :: \"('c, ('s, 'm) stateT) altc\"\nwhere \"altc_state \\<equiv> altc_sample_state altc\""], ["", "context\n  includes lifting_syntax\n  assumes \"monad_altc return bind altc\" \nbegin"], ["", "interpretation monad_altc return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return bind altc", "by fact"], ["", "lemma monad_altc_stateT [locale_witness]: \"monad_altc return_state bind_state altc_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_state local.bind_state local.altc_state", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       local.bind_state (local.altc_state C g) f =\n       local.altc_state C (\\<lambda>c. local.bind_state (g c) f)\n 2. \\<And>x f. local.altc_state (csingle x) f = f x\n 3. \\<And>C f g.\n       local.altc_state (cUnion (cimage f C)) g =\n       local.altc_state C (\\<lambda>x. local.altc_state (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n        local.altc_state", "note altc_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  (rel_cset ?R ===> (?R ===> (=)) ===> (=)) altc altc\n\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       local.bind_state (local.altc_state C g) f =\n       local.altc_state C (\\<lambda>c. local.bind_state (g c) f)\n 2. \\<And>x f. local.altc_state (csingle x) f = f x\n 3. \\<And>C f g.\n       local.altc_state (cUnion (cimage f C)) g =\n       local.altc_state C (\\<lambda>x. local.altc_state (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n        local.altc_state", "show \"bind_state (altc_state C g) f = altc_state C (\\<lambda>c. bind_state (g c) f)\" for C g f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.altc_state C g) f =\n    local.altc_state C (\\<lambda>c. local.bind_state (g c) f)", "by(rule stateT.expand)(simp add: fun_eq_iff bind_altc1)"], ["proof (state)\nthis:\n  local.bind_state (local.altc_state ?C4 ?g4) ?f4 =\n  local.altc_state ?C4 (\\<lambda>c. local.bind_state (?g4 c) ?f4)\n\ngoal (3 subgoals):\n 1. \\<And>x f. local.altc_state (csingle x) f = f x\n 2. \\<And>C f g.\n       local.altc_state (cUnion (cimage f C)) g =\n       local.altc_state C (\\<lambda>x. local.altc_state (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n        local.altc_state", "show \"altc_state (csingle x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_state (csingle x) f = f x", "by(rule stateT.expand)(simp add: fun_eq_iff altc_single)"], ["proof (state)\nthis:\n  local.altc_state (csingle ?x4) ?f4 = ?f4 ?x4\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       local.altc_state (cUnion (cimage f C)) g =\n       local.altc_state C (\\<lambda>x. local.altc_state (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n        local.altc_state", "show \"altc_state (cUNION C f) g = altc_state C (\\<lambda>x. altc_state (f x) g)\" for C f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_state (cUnion (cimage f C)) g =\n    local.altc_state C (\\<lambda>x. local.altc_state (f x) g)", "by(rule stateT.expand)(simp add: fun_eq_iff altc_cUNION)"], ["proof (state)\nthis:\n  local.altc_state (cUnion (cimage ?f4 ?C4)) ?g4 =\n  local.altc_state ?C4 (\\<lambda>x. local.altc_state (?f4 x) ?g4)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n        local.altc_state", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) altc_state altc_state\" if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_state\n     local.altc_state", "unfolding altc_sample_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f.\n         StateT (\\<lambda>s. altc p (\\<lambda>x. run_state (f x) s)))\n     (\\<lambda>p f.\n         StateT (\\<lambda>s. altc p (\\<lambda>x. run_state (f x) s)))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R4 \\<Longrightarrow>\n  (rel_cset ?R4 ===> (?R4 ===> (=)) ===> (=)) local.altc_state\n   local.altc_state\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_altc_stateT [locale_witness]:\n  \"monad_state_altc return_state bind_state get_state put_state altc_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_state local.bind_state local.get_state\n     local.put_state local.altc_state", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C f.\n       local.altc_state C (\\<lambda>c. local.get_state (f c)) =\n       local.get_state (\\<lambda>s. local.altc_state C (\\<lambda>c. f c s))\n 2. \\<And>s C f.\n       local.altc_state C (\\<lambda>c. local.put_state s (f c)) =\n       local.put_state s (local.altc_state C f)", "show \"altc_state C (\\<lambda>c. get_state (f c)) = get_state (\\<lambda>s. altc_state C (\\<lambda>c. f c s))\"\n    for C and f :: \"'c \\<Rightarrow> 's \\<Rightarrow> ('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_state C (\\<lambda>c. local.get_state (f c)) =\n    local.get_state (\\<lambda>s. local.altc_state C (\\<lambda>c. f c s))", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.altc_state ?C4 (\\<lambda>c. local.get_state (?f4 c)) =\n  local.get_state (\\<lambda>s. local.altc_state ?C4 (\\<lambda>c. ?f4 c s))\n\ngoal (1 subgoal):\n 1. \\<And>s C f.\n       local.altc_state C (\\<lambda>c. local.put_state s (f c)) =\n       local.put_state s (local.altc_state C f)", "show \"altc_state C (\\<lambda>c. put_state s (f c)) = put_state s (altc_state C f)\"\n    for C s and f :: \"'c \\<Rightarrow> ('s, 'm) stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_state C (\\<lambda>c. local.put_state s (f c)) =\n    local.put_state s (local.altc_state C f)", "by(rule stateT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  local.altc_state ?C4 (\\<lambda>c. local.put_state ?s4 (?f4 c)) =\n  local.put_state ?s4 (local.altc_state ?C4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma monad_altc3_stateT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_state bind_state altc_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_state local.bind_state local.altc_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_state local.bind_state local.altc_state", "interpret monad_altc3 return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_state local.bind_state local.altc_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_state local.bind_state local.altc_state", ".."], ["proof (state)\nthis:\n  monad_altc3 local.return_state local.bind_state local.altc_state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Resumption\\<close>"], ["", "context\n  fixes pause :: \"('o, 'i, 'm) pause\"\nbegin"], ["", "definition pause_state :: \"('o, 'i, ('s, 'm) stateT) pause\"\nwhere \"pause_state out c = StateT (\\<lambda>s. pause out (\\<lambda>i. run_state (c i) s))\""], ["", "lemma run_pause_state [simp]:\n  \"run_state (pause_state out c) s = pause out (\\<lambda>i. run_state (c i) s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (local.pause_state out c) s =\n    pause out (\\<lambda>i. run_state (c i) s)", "by(simp add: pause_state_def)"], ["", "lemma monad_resumption_stateT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_state bind_state pause_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_state local.bind_state local.pause_state", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_state local.bind_state local.pause_state", "interpret monad_resumption return bind pause"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption return bind pause", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_state local.bind_state local.pause_state", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_state local.bind_state local.pause_state", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c f.\n       local.bind_state (local.pause_state out c) f =\n       local.pause_state out (\\<lambda>i. local.bind_state (c i) f)", "show \"bind_state (pause_state out c) f = pause_state out (\\<lambda>i. bind_state (c i) f)\" for out c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_state (local.pause_state out c) f =\n    local.pause_state out (\\<lambda>i. local.bind_state (c i) f)", "by(rule stateT.expand)(simp add: fun_eq_iff bind_pause)"], ["proof (state)\nthis:\n  local.bind_state (local.pause_state ?out5 ?c5) ?f5 =\n  local.pause_state ?out5 (\\<lambda>i. local.bind_state (?c5 i) ?f5)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_resumption local.return_state local.bind_state local.pause_state\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Parametricity\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma return_state_parametric [transfer_rule]:\n  \"((rel_prod A S ===> M) ===> A ===> rel_stateT S M) return_state return_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A S ===> M) ===> A ===> rel_stateT S M) return_state\n     return_state", "unfolding return_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A S ===> M) ===> A ===> rel_stateT S M)\n     (\\<lambda>return x. StateT (\\<lambda>s. return (x, s)))\n     (\\<lambda>return x. StateT (\\<lambda>s. return (x, s)))", "by transfer_prover"], ["", "lemma bind_state_parametric [transfer_rule]:\n  \"((M ===> (rel_prod A S ===> M) ===> M) ===> rel_stateT S M ===> (A ===> rel_stateT S M) ===> rel_stateT S M)\n   bind_state bind_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (rel_prod A S ===> M) ===> M) ===>\n     rel_stateT S M ===> (A ===> rel_stateT S M) ===> rel_stateT S M)\n     bind_state bind_state", "unfolding bind_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (rel_prod A S ===> M) ===> M) ===>\n     rel_stateT S M ===> (A ===> rel_stateT S M) ===> rel_stateT S M)\n     (\\<lambda>bind.\n         rec_stateT\n          (\\<lambda>x f.\n              StateT\n               (\\<lambda>s.\n                   bind (x s) (\\<lambda>(a, s'). run_state (f a) s'))))\n     (\\<lambda>bind.\n         rec_stateT\n          (\\<lambda>x f.\n              StateT\n               (\\<lambda>s.\n                   bind (x s) (\\<lambda>(a, s'). run_state (f a) s'))))", "by transfer_prover"], ["", "lemma get_state_parametric [transfer_rule]:\n  \"((S ===> rel_stateT S M) ===> rel_stateT S M) get_state get_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> rel_stateT S M) ===> rel_stateT S M) get_state get_state", "unfolding get_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> rel_stateT S M) ===> rel_stateT S M)\n     (\\<lambda>f. StateT (\\<lambda>s. run_state (f s) s))\n     (\\<lambda>f. StateT (\\<lambda>s. run_state (f s) s))", "by transfer_prover"], ["", "lemma put_state_parametric [transfer_rule]:\n  \"(S ===> rel_stateT S M ===> rel_stateT S M) put_state put_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> rel_stateT S M ===> rel_stateT S M) put_state put_state", "unfolding put_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (S ===> rel_stateT S M ===> rel_stateT S M)\n     (\\<lambda>uu uua.\n         rec_stateT (\\<lambda>f s. StateT (\\<lambda>_. f s)) uua uu)\n     (\\<lambda>uu uua.\n         rec_stateT (\\<lambda>f s. StateT (\\<lambda>_. f s)) uua uu)", "by transfer_prover"], ["", "lemma fail_state_parametric [transfer_rule]: \"(M ===> rel_stateT S M) fail_state fail_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_stateT S M) fail_state fail_state", "unfolding fail_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_stateT S M) (\\<lambda>fail. StateT (\\<lambda>s. fail))\n     (\\<lambda>fail. StateT (\\<lambda>s. fail))", "by transfer_prover"], ["", "lemma ask_state_parametric [transfer_rule]:\n  \"(((R ===> M) ===> M) ===> (R ===> rel_stateT S M) ===> rel_stateT S M) ask_state ask_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_stateT S M) ===> rel_stateT S M)\n     ask_state ask_state", "unfolding ask_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===> (R ===> rel_stateT S M) ===> rel_stateT S M)\n     (\\<lambda>ask f.\n         StateT (\\<lambda>s. ask (\\<lambda>r. run_state (f r) s)))\n     (\\<lambda>ask f.\n         StateT (\\<lambda>s. ask (\\<lambda>r. run_state (f r) s)))", "by transfer_prover"], ["", "lemma altc_sample_state_parametric [transfer_rule]:\n  \"((X ===> (P ===> M) ===> M) ===> X ===> (P ===> rel_stateT S M) ===> rel_stateT S M)\n   altc_sample_state altc_sample_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> (P ===> M) ===> M) ===>\n     X ===> (P ===> rel_stateT S M) ===> rel_stateT S M)\n     altc_sample_state altc_sample_state", "unfolding altc_sample_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> (P ===> M) ===> M) ===>\n     X ===> (P ===> rel_stateT S M) ===> rel_stateT S M)\n     (\\<lambda>altc_sample p f.\n         StateT (\\<lambda>s. altc_sample p (\\<lambda>x. run_state (f x) s)))\n     (\\<lambda>altc_sample p f.\n         StateT (\\<lambda>s. altc_sample p (\\<lambda>x. run_state (f x) s)))", "by transfer_prover"], ["", "lemma tell_state_parametric [transfer_rule]:\n  \"((W ===> M ===> M) ===> W ===> rel_stateT S M ===> rel_stateT S M)\n   tell_state tell_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===> W ===> rel_stateT S M ===> rel_stateT S M)\n     tell_state tell_state", "unfolding tell_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((W ===> M ===> M) ===> W ===> rel_stateT S M ===> rel_stateT S M)\n     (\\<lambda>tell w m. StateT (\\<lambda>s. tell w (run_state m s)))\n     (\\<lambda>tell w m. StateT (\\<lambda>s. tell w (run_state m s)))", "by transfer_prover"], ["", "lemma alt_state_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_stateT S M ===> rel_stateT S M ===> rel_stateT S M)\n   alt_state alt_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_stateT S M ===> rel_stateT S M ===> rel_stateT S M)\n     alt_state alt_state", "unfolding alt_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_stateT S M ===> rel_stateT S M ===> rel_stateT S M)\n     (\\<lambda>alt m1 m2.\n         StateT (\\<lambda>s. alt (run_state m1 s) (run_state m2 s)))\n     (\\<lambda>alt m1 m2.\n         StateT (\\<lambda>s. alt (run_state m1 s) (run_state m2 s)))", "by transfer_prover"], ["", "lemma pause_state_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_stateT S M) ===> rel_stateT S M)\n   pause_state pause_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_stateT S M) ===> rel_stateT S M)\n     pause_state pause_state", "unfolding pause_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_stateT S M) ===> rel_stateT S M)\n     (\\<lambda>pause out c.\n         StateT (\\<lambda>s. pause out (\\<lambda>i. run_state (c i) s)))\n     (\\<lambda>pause out c.\n         StateT (\\<lambda>s. pause out (\\<lambda>i. run_state (c i) s)))", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Writer monad transformer\\<close>"], ["", "text \\<open>\n  We implement a simple writer monad which collects all the output in a list. It would also have\n  been possible to use a monoid instead. The phantom type variables @{typ 'a} and @{typ 'w} are needed to\n  avoid hidden polymorphism when overloading the monad operations for the writer monad\n  transformer.\n\\<close>"], ["", "datatype ('w, 'a, 'm) writerT = WriterT (run_writer: 'm)"], ["", "context\n  fixes return :: \"('a \\<times> 'w list, 'm) return\"\n  and bind :: \"('a \\<times> 'w list, 'm) bind\"\nbegin"], ["", "definition return_writer :: \"('a, ('w, 'a, 'm) writerT) return\"\nwhere \"return_writer x = WriterT (return (x, []))\""], ["", "definition bind_writer :: \"('a, ('w, 'a, 'm) writerT) bind\"\nwhere \"bind_writer m f = WriterT (bind (run_writer m) (\\<lambda>(a, ws). bind (run_writer (f a)) (\\<lambda>(b, ws'). return (b, ws @ ws'))))\""], ["", "definition tell_writer :: \"('w, ('w, 'a, 'm) writerT) tell\"\nwhere \"tell_writer w m = WriterT (bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws)))\""], ["", "lemma run_return_writer [simp]: \"run_writer (return_writer x) = return (x, [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.return_writer x) = return (x, [])", "by(simp add: return_writer_def)"], ["", "lemma run_bind_writer [simp]:\n  \"run_writer (bind_writer m f) = bind (run_writer m) (\\<lambda>(a, ws). bind (run_writer (f a)) (\\<lambda>(b, ws'). return (b, ws @ ws')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.bind_writer m f) =\n    bind (run_writer m)\n     (\\<lambda>(a, ws).\n         bind (run_writer (f a)) (\\<lambda>(b, ws'). return (b, ws @ ws')))", "by(simp add: bind_writer_def)"], ["", "lemma run_tell_writer [simp]:\n  \"run_writer (tell_writer w m) = bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.tell_writer w m) =\n    bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws))", "by(simp add: tell_writer_def)"], ["", "context\n  assumes \"monad return bind\"\nbegin"], ["", "interpretation monad return bind"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return bind", "by fact"], ["", "lemma monad_writerT [locale_witness]: \"monad return_writer bind_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad local.return_writer local.bind_writer", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       local.bind_writer (local.bind_writer x f) g =\n       local.bind_writer x (\\<lambda>y. local.bind_writer (f y) g)\n 2. \\<And>x f. local.bind_writer (local.return_writer x) f = f x\n 3. \\<And>x. local.bind_writer x local.return_writer = x", "show \"bind_writer (bind_writer x f) g = bind_writer x (\\<lambda>y. bind_writer (f y) g)\" for x f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.bind_writer x f) g =\n    local.bind_writer x (\\<lambda>y. local.bind_writer (f y) g)", "by(rule writerT.expand)(simp add: bind_assoc split_def return_bind)"], ["proof (state)\nthis:\n  local.bind_writer (local.bind_writer ?x ?f) ?g =\n  local.bind_writer ?x (\\<lambda>y. local.bind_writer (?f y) ?g)\n\ngoal (2 subgoals):\n 1. \\<And>x f. local.bind_writer (local.return_writer x) f = f x\n 2. \\<And>x. local.bind_writer x local.return_writer = x", "show \"bind_writer (return_writer x) f = f x\" for  x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.return_writer x) f = f x", "by(rule writerT.expand)(simp add: bind_return return_bind)"], ["proof (state)\nthis:\n  local.bind_writer (local.return_writer ?x) ?f = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. local.bind_writer x local.return_writer = x", "show \"bind_writer x return_writer = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer x local.return_writer = x", "by(rule writerT.expand)(simp add: bind_return return_bind)"], ["proof (state)\nthis:\n  local.bind_writer ?x local.return_writer = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_writer_writerT [locale_witness]: \"monad_writer return_writer bind_writer tell_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_writer local.return_writer local.bind_writer local.tell_writer", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w m f.\n       local.bind_writer (local.tell_writer w m) f =\n       local.tell_writer w (local.bind_writer m f)", "show \"bind_writer (tell_writer w m) f = tell_writer w (bind_writer m f)\" for w m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.tell_writer w m) f =\n    local.tell_writer w (local.bind_writer m f)", "by(rule writerT.expand)(simp add: bind_assoc split_def return_bind)"], ["proof (state)\nthis:\n  local.bind_writer (local.tell_writer ?w ?m) ?f =\n  local.tell_writer ?w (local.bind_writer ?m ?f)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Failure\\<close>"], ["", "context\n  fixes fail :: \"'m fail\"\nbegin"], ["", "definition fail_writer :: \"('w, 'a, 'm) writerT fail\"\nwhere \"fail_writer = WriterT fail\""], ["", "lemma run_fail_writer [simp]: \"run_writer fail_writer = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer local.fail_writer = fail", "by(simp add: fail_writer_def)"], ["", "lemma monad_fail_writerT [locale_witness]:\n  assumes \"monad_fail return bind fail\"\n  shows \"monad_fail return_writer bind_writer fail_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail local.return_writer local.bind_writer local.fail_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_writer local.bind_writer local.fail_writer", "interpret monad_fail return bind fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return bind fail", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail local.return_writer local.bind_writer local.fail_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail local.return_writer local.bind_writer local.fail_writer", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. local.bind_writer local.fail_writer f = local.fail_writer", "show \"bind_writer fail_writer f = fail_writer\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer local.fail_writer f = local.fail_writer", "by(rule writerT.expand)(simp add: fail_bind)"], ["proof (state)\nthis:\n  local.bind_writer local.fail_writer ?f = local.fail_writer\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_fail local.return_writer local.bind_writer local.fail_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Just like for the state monad, we cannot lift @{term catch} because the output before the failure would be lost.\n\\<close>"], ["", "subsubsection \\<open>State\\<close>"], ["", "context\n  fixes get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\nbegin"], ["", "definition get_writer :: \"('s, ('w, 'a, 'm) writerT) get\"\nwhere \"get_writer f = WriterT (get (\\<lambda>s. run_writer (f s)))\""], ["", "definition put_writer :: \"('s, ('w, 'a, 'm) writerT) put\"\nwhere \"put_writer s m = WriterT (put s (run_writer m))\""], ["", "lemma run_get_writer [simp]: \"run_writer (get_writer f) = get (\\<lambda>s. run_writer (f s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.get_writer f) = get (\\<lambda>s. run_writer (f s))", "by(simp add: get_writer_def)"], ["", "lemma run_put_writer [simp]: \"run_writer (put_writer s m) = put s (run_writer m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.put_writer s m) = put s (run_writer m)", "by(simp add: put_writer_def)"], ["", "lemma monad_state_writerT [locale_witness]:\n  assumes \"monad_state return bind get put\"\n  shows \"monad_state return_writer bind_writer get_writer put_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_writer local.bind_writer local.get_writer\n     local.put_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state local.return_writer local.bind_writer local.get_writer\n     local.put_writer", "interpret monad_state return bind get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return bind get put", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state local.return_writer local.bind_writer local.get_writer\n     local.put_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state local.return_writer local.bind_writer local.get_writer\n     local.put_writer", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f.\n       local.put_writer s (local.get_writer f) = local.put_writer s (f s)\n 2. \\<And>f.\n       local.get_writer (\\<lambda>s. local.get_writer (f s)) =\n       local.get_writer (\\<lambda>s. f s s)\n 3. \\<And>s s' m.\n       local.put_writer s (local.put_writer s' m) = local.put_writer s' m\n 4. \\<And>m. local.get_writer (\\<lambda>s. local.put_writer s m) = m\n 5. \\<And>m. local.get_writer (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 7. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"put_writer s (get_writer f) = put_writer s (f s)\" for s f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_writer s (local.get_writer f) = local.put_writer s (f s)", "by(rule writerT.expand)(simp add: put_get)"], ["proof (state)\nthis:\n  local.put_writer ?s (local.get_writer ?f) = local.put_writer ?s (?f ?s)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       local.get_writer (\\<lambda>s. local.get_writer (f s)) =\n       local.get_writer (\\<lambda>s. f s s)\n 2. \\<And>s s' m.\n       local.put_writer s (local.put_writer s' m) = local.put_writer s' m\n 3. \\<And>m. local.get_writer (\\<lambda>s. local.put_writer s m) = m\n 4. \\<And>m. local.get_writer (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 6. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"get_writer (\\<lambda>s. get_writer (f s)) = get_writer (\\<lambda>s. f s s)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_writer (\\<lambda>s. local.get_writer (f s)) =\n    local.get_writer (\\<lambda>s. f s s)", "by(rule writerT.expand)(simp add: get_get)"], ["proof (state)\nthis:\n  local.get_writer (\\<lambda>s. local.get_writer (?f s)) =\n  local.get_writer (\\<lambda>s. ?f s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m.\n       local.put_writer s (local.put_writer s' m) = local.put_writer s' m\n 2. \\<And>m. local.get_writer (\\<lambda>s. local.put_writer s m) = m\n 3. \\<And>m. local.get_writer (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 5. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"put_writer s (put_writer s' m) = put_writer s' m\" for s s' m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_writer s (local.put_writer s' m) = local.put_writer s' m", "by(rule writerT.expand)(simp add: put_put)"], ["proof (state)\nthis:\n  local.put_writer ?s (local.put_writer ?s' ?m) = local.put_writer ?s' ?m\n\ngoal (4 subgoals):\n 1. \\<And>m. local.get_writer (\\<lambda>s. local.put_writer s m) = m\n 2. \\<And>m. local.get_writer (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 4. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"get_writer (\\<lambda>s. put_writer s m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_writer (\\<lambda>s. local.put_writer s m) = m", "by(rule writerT.expand)(simp add: get_put)"], ["proof (state)\nthis:\n  local.get_writer (\\<lambda>s. local.put_writer s ?m) = ?m\n\ngoal (3 subgoals):\n 1. \\<And>m. local.get_writer (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 3. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"get_writer (\\<lambda>_. m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_writer (\\<lambda>_. m) = m", "by(rule writerT.expand)(simp add: get_const)"], ["proof (state)\nthis:\n  local.get_writer (\\<lambda>_. ?m) = ?m\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_writer (local.get_writer f) g =\n       local.get_writer (\\<lambda>s. local.bind_writer (f s) g)\n 2. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"bind_writer (get_writer f) g = get_writer (\\<lambda>s. bind_writer (f s) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.get_writer f) g =\n    local.get_writer (\\<lambda>s. local.bind_writer (f s) g)", "by(rule writerT.expand)(simp add: bind_get)"], ["proof (state)\nthis:\n  local.bind_writer (local.get_writer ?f) ?g =\n  local.get_writer (\\<lambda>s. local.bind_writer (?f s) ?g)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       local.bind_writer (local.put_writer s m) f =\n       local.put_writer s (local.bind_writer m f)", "show \"bind_writer (put_writer s m) f = put_writer s (bind_writer m f)\" for s m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.put_writer s m) f =\n    local.put_writer s (local.bind_writer m f)", "by(rule writerT.expand)(simp add: bind_put)"], ["proof (state)\nthis:\n  local.bind_writer (local.put_writer ?s ?m) ?f =\n  local.put_writer ?s (local.bind_writer ?m ?f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state local.return_writer local.bind_writer local.get_writer\n   local.put_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection  \\<open>Probability\\<close>"], ["", "definition altc_sample_writer :: \"('x \\<Rightarrow> ('b \\<Rightarrow> 'm) \\<Rightarrow> 'm) \\<Rightarrow> 'x \\<Rightarrow> ('b \\<Rightarrow> ('w, 'a, 'm) writerT) \\<Rightarrow> ('w, 'a, 'm) writerT\"\nwhere \"altc_sample_writer altc_sample p f = WriterT (altc_sample p (\\<lambda>p. run_writer (f p)))\""], ["", "lemma run_altc_sample_writer [simp]:\n  \"run_writer (altc_sample_writer altc_sample p f) = altc_sample p (\\<lambda>p. run_writer (f p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.altc_sample_writer altc_sample p f) =\n    altc_sample p (\\<lambda>p. run_writer (f p))", "by(simp add: altc_sample_writer_def)"], ["", "context\n  fixes sample :: \"('p, 'm) sample\"\nbegin"], ["", "abbreviation sample_writer :: \"('p, ('w, 'a, 'm) writerT) sample\"\nwhere \"sample_writer \\<equiv> altc_sample_writer sample\""], ["", "lemma monad_prob_writerT [locale_witness]:\n  assumes \"monad_prob return bind sample\"\n  shows \"monad_prob return_writer bind_writer sample_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "interpret monad_prob return bind sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob return bind sample", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "note sample_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_pmf ?R) (rel_fun (rel_fun ?R (=)) (=)) sample sample\n\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_prob local.return_writer local.bind_writer local.sample_writer", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>p m. local.sample_writer p (\\<lambda>_. m) = m\n 2. \\<And>x f. local.sample_writer (return_pmf x) f = f x\n 3. \\<And>p f g.\n       local.sample_writer (p \\<bind> f) g =\n       local.sample_writer p (\\<lambda>x. local.sample_writer (f x) g)\n 4. \\<And>p q f.\n       local.sample_writer p (\\<lambda>x. local.sample_writer q (f x)) =\n       local.sample_writer q\n        (\\<lambda>y. local.sample_writer p (\\<lambda>x. f x y))\n 5. \\<And>p f g.\n       local.bind_writer (local.sample_writer p f) g =\n       local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)\n 6. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 7. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"sample_writer p (\\<lambda>_. m) = m\" for p m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_writer p (\\<lambda>_. m) = m", "by(rule writerT.expand)(simp add: sample_const)"], ["proof (state)\nthis:\n  local.sample_writer ?p1 (\\<lambda>_. ?m1) = ?m1\n\ngoal (6 subgoals):\n 1. \\<And>x f. local.sample_writer (return_pmf x) f = f x\n 2. \\<And>p f g.\n       local.sample_writer (p \\<bind> f) g =\n       local.sample_writer p (\\<lambda>x. local.sample_writer (f x) g)\n 3. \\<And>p q f.\n       local.sample_writer p (\\<lambda>x. local.sample_writer q (f x)) =\n       local.sample_writer q\n        (\\<lambda>y. local.sample_writer p (\\<lambda>x. f x y))\n 4. \\<And>p f g.\n       local.bind_writer (local.sample_writer p f) g =\n       local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)\n 5. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 6. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"sample_writer (return_pmf x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_writer (return_pmf x) f = f x", "by(rule writerT.expand)(simp add: sample_return_pmf)"], ["proof (state)\nthis:\n  local.sample_writer (return_pmf ?x1) ?f1 = ?f1 ?x1\n\ngoal (5 subgoals):\n 1. \\<And>p f g.\n       local.sample_writer (p \\<bind> f) g =\n       local.sample_writer p (\\<lambda>x. local.sample_writer (f x) g)\n 2. \\<And>p q f.\n       local.sample_writer p (\\<lambda>x. local.sample_writer q (f x)) =\n       local.sample_writer q\n        (\\<lambda>y. local.sample_writer p (\\<lambda>x. f x y))\n 3. \\<And>p f g.\n       local.bind_writer (local.sample_writer p f) g =\n       local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)\n 4. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 5. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"sample_writer (p \\<bind> f) g = sample_writer p (\\<lambda>x. sample_writer (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_writer (p \\<bind> f) g =\n    local.sample_writer p (\\<lambda>x. local.sample_writer (f x) g)", "by(rule writerT.expand)(simp add: sample_bind_pmf)"], ["proof (state)\nthis:\n  local.sample_writer (?p1 \\<bind> ?f1) ?g1 =\n  local.sample_writer ?p1 (\\<lambda>x. local.sample_writer (?f1 x) ?g1)\n\ngoal (4 subgoals):\n 1. \\<And>p q f.\n       local.sample_writer p (\\<lambda>x. local.sample_writer q (f x)) =\n       local.sample_writer q\n        (\\<lambda>y. local.sample_writer p (\\<lambda>x. f x y))\n 2. \\<And>p f g.\n       local.bind_writer (local.sample_writer p f) g =\n       local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)\n 3. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"sample_writer p (\\<lambda>x. sample_writer q (f x)) = sample_writer q (\\<lambda>y. sample_writer p (\\<lambda>x. f x y))\"\n      for p q f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_writer p (\\<lambda>x. local.sample_writer q (f x)) =\n    local.sample_writer q\n     (\\<lambda>y. local.sample_writer p (\\<lambda>x. f x y))", "by(rule writerT.expand)(auto intro: sample_commute)"], ["proof (state)\nthis:\n  local.sample_writer ?p1 (\\<lambda>x. local.sample_writer ?q1 (?f1 x)) =\n  local.sample_writer ?q1\n   (\\<lambda>y. local.sample_writer ?p1 (\\<lambda>x. ?f1 x y))\n\ngoal (3 subgoals):\n 1. \\<And>p f g.\n       local.bind_writer (local.sample_writer p f) g =\n       local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)\n 2. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"bind_writer (sample_writer p f) g = sample_writer p (\\<lambda>x. bind_writer (f x) g)\" for p f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.sample_writer p f) g =\n    local.sample_writer p (\\<lambda>x. local.bind_writer (f x) g)", "by(rule writerT.expand)(simp add: bind_sample1)"], ["proof (state)\nthis:\n  local.bind_writer (local.sample_writer ?p1 ?f1) ?g1 =\n  local.sample_writer ?p1 (\\<lambda>x. local.bind_writer (?f1 x) ?g1)\n\ngoal (2 subgoals):\n 1. \\<And>m f p.\n       local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n       local.sample_writer p\n        (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"bind_writer m (\\<lambda>y. sample_writer p (f y)) = sample_writer p (\\<lambda>x. bind_writer m (\\<lambda>y. f y x))\"\n      for m p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer m (\\<lambda>y. local.sample_writer p (f y)) =\n    local.sample_writer p\n     (\\<lambda>x. local.bind_writer m (\\<lambda>y. f y x))", "by(rule writerT.expand)(simp add: bind_sample2[symmetric] bind_sample1 split_def)"], ["proof (state)\nthis:\n  local.bind_writer ?m1 (\\<lambda>y. local.sample_writer ?p1 (?f1 y)) =\n  local.sample_writer ?p1\n   (\\<lambda>x. local.bind_writer ?m1 (\\<lambda>y. ?f1 y x))\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n        local.sample_writer", "show \"(rel_pmf R ===> (R ===> (=)) ===> (=)) sample_writer sample_writer\"\n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=)) local.sample_writer\n     local.sample_writer", "unfolding altc_sample_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_pmf R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f. WriterT (sample p (\\<lambda>p. run_writer (f p))))\n     (\\<lambda>p f. WriterT (sample p (\\<lambda>p. run_writer (f p))))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R1 \\<Longrightarrow>\n  (rel_pmf ?R1 ===> (?R1 ===> (=)) ===> (=)) local.sample_writer\n   local.sample_writer\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_prob local.return_writer local.bind_writer local.sample_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_prob_writerT [locale_witness]:\n  assumes \"monad_state_prob return bind get put sample\"\n  shows \"monad_state_prob return_writer bind_writer get_writer put_writer sample_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.sample_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.sample_writer", "interpret monad_state_prob return bind get put sample"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob return bind get put sample", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.sample_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_prob local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.sample_writer", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p f.\n       local.sample_writer p (\\<lambda>x. local.get_writer (f x)) =\n       local.get_writer\n        (\\<lambda>s. local.sample_writer p (\\<lambda>x. f x s))", "show \"sample_writer p (\\<lambda>x. get_writer (f x)) = get_writer (\\<lambda>s. sample_writer p (\\<lambda>x. f x s))\" for p f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.sample_writer p (\\<lambda>x. local.get_writer (f x)) =\n    local.get_writer (\\<lambda>s. local.sample_writer p (\\<lambda>x. f x s))", "by(rule writerT.expand)(simp add: sample_get)"], ["proof (state)\nthis:\n  local.sample_writer ?p1 (\\<lambda>x. local.get_writer (?f1 x)) =\n  local.get_writer\n   (\\<lambda>s. local.sample_writer ?p1 (\\<lambda>x. ?f1 x s))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_prob local.return_writer local.bind_writer local.get_writer\n   local.put_writer local.sample_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Reader\\<close>"], ["", "context\n  fixes ask :: \"('r, 'm) ask\"\nbegin"], ["", "definition ask_writer :: \"('r, ('w, 'a, 'm) writerT) ask\"\nwhere \"ask_writer f = WriterT (ask (\\<lambda>r. run_writer (f r)))\""], ["", "lemma run_ask_writer [simp]: \"run_writer (ask_writer f) = ask (\\<lambda>r. run_writer (f r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.ask_writer f) = ask (\\<lambda>r. run_writer (f r))", "by(simp add: ask_writer_def)"], ["", "lemma monad_reader_writerT [locale_witness]:\n  assumes \"monad_reader return bind ask\"\n  shows \"monad_reader return_writer bind_writer ask_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_writer local.bind_writer local.ask_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_writer local.bind_writer local.ask_writer", "interpret monad_reader return bind ask"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader return bind ask", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader local.return_writer local.bind_writer local.ask_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader local.return_writer local.bind_writer local.ask_writer", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f.\n       local.ask_writer (\\<lambda>r. local.ask_writer (f r)) =\n       local.ask_writer (\\<lambda>r. f r r)\n 2. \\<And>m. local.ask_writer (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       local.bind_writer (local.ask_writer f) g =\n       local.ask_writer (\\<lambda>r. local.bind_writer (f r) g)\n 4. \\<And>m f.\n       local.bind_writer m (\\<lambda>x. local.ask_writer (f x)) =\n       local.ask_writer\n        (\\<lambda>r. local.bind_writer m (\\<lambda>x. f x r))", "show \"ask_writer (\\<lambda>r. ask_writer (f r)) = ask_writer (\\<lambda>r. f r r)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_writer (\\<lambda>r. local.ask_writer (f r)) =\n    local.ask_writer (\\<lambda>r. f r r)", "by(rule writerT.expand)(simp add: ask_ask)"], ["proof (state)\nthis:\n  local.ask_writer (\\<lambda>r. local.ask_writer (?f2 r)) =\n  local.ask_writer (\\<lambda>r. ?f2 r r)\n\ngoal (3 subgoals):\n 1. \\<And>m. local.ask_writer (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       local.bind_writer (local.ask_writer f) g =\n       local.ask_writer (\\<lambda>r. local.bind_writer (f r) g)\n 3. \\<And>m f.\n       local.bind_writer m (\\<lambda>x. local.ask_writer (f x)) =\n       local.ask_writer\n        (\\<lambda>r. local.bind_writer m (\\<lambda>x. f x r))", "show \"ask_writer (\\<lambda>_. m) = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_writer (\\<lambda>_. m) = m", "by(rule writerT.expand)(simp add: ask_const)"], ["proof (state)\nthis:\n  local.ask_writer (\\<lambda>_. ?m2) = ?m2\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.bind_writer (local.ask_writer f) g =\n       local.ask_writer (\\<lambda>r. local.bind_writer (f r) g)\n 2. \\<And>m f.\n       local.bind_writer m (\\<lambda>x. local.ask_writer (f x)) =\n       local.ask_writer\n        (\\<lambda>r. local.bind_writer m (\\<lambda>x. f x r))", "show \"bind_writer (ask_writer f) g = ask_writer (\\<lambda>r. bind_writer (f r) g)\" for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.ask_writer f) g =\n    local.ask_writer (\\<lambda>r. local.bind_writer (f r) g)", "by(rule writerT.expand)(simp add: bind_ask)"], ["proof (state)\nthis:\n  local.bind_writer (local.ask_writer ?f2) ?g2 =\n  local.ask_writer (\\<lambda>r. local.bind_writer (?f2 r) ?g2)\n\ngoal (1 subgoal):\n 1. \\<And>m f.\n       local.bind_writer m (\\<lambda>x. local.ask_writer (f x)) =\n       local.ask_writer\n        (\\<lambda>r. local.bind_writer m (\\<lambda>x. f x r))", "show \"bind_writer m (\\<lambda>x. ask_writer (f x)) = ask_writer (\\<lambda>r. bind_writer m (\\<lambda>x. f x r))\"\n      for m f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer m (\\<lambda>x. local.ask_writer (f x)) =\n    local.ask_writer (\\<lambda>r. local.bind_writer m (\\<lambda>x. f x r))", "by(rule writerT.expand)(simp add: split_def bind_ask2[symmetric] bind_ask)"], ["proof (state)\nthis:\n  local.bind_writer ?m2 (\\<lambda>x. local.ask_writer (?f2 x)) =\n  local.ask_writer (\\<lambda>r. local.bind_writer ?m2 (\\<lambda>x. ?f2 x r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_reader local.return_writer local.bind_writer local.ask_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_reader_state_writerT [locale_witness]:\n  assumes \"monad_reader_state return bind ask get put\"\n  shows \"monad_reader_state return_writer bind_writer ask_writer get_writer put_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_writer local.bind_writer\n     local.ask_writer local.get_writer local.put_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_writer local.bind_writer\n     local.ask_writer local.get_writer local.put_writer", "interpret monad_reader_state return bind ask get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader_state return bind ask get put", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_writer local.bind_writer\n     local.ask_writer local.get_writer local.put_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_reader_state local.return_writer local.bind_writer\n     local.ask_writer local.get_writer local.put_writer", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       local.ask_writer (\\<lambda>r. local.get_writer (f r)) =\n       local.get_writer (\\<lambda>s. local.ask_writer (\\<lambda>r. f r s))\n 2. \\<And>s f.\n       local.put_writer s (local.ask_writer f) =\n       local.ask_writer (\\<lambda>r. local.put_writer s (f r))", "show \"ask_writer (\\<lambda>r. get_writer (f r)) = get_writer (\\<lambda>s. ask_writer (\\<lambda>r. f r s))\"\n      for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ask_writer (\\<lambda>r. local.get_writer (f r)) =\n    local.get_writer (\\<lambda>s. local.ask_writer (\\<lambda>r. f r s))", "by(rule writerT.expand)(simp add: ask_get)"], ["proof (state)\nthis:\n  local.ask_writer (\\<lambda>r. local.get_writer (?f2 r)) =\n  local.get_writer (\\<lambda>s. local.ask_writer (\\<lambda>r. ?f2 r s))\n\ngoal (1 subgoal):\n 1. \\<And>s f.\n       local.put_writer s (local.ask_writer f) =\n       local.ask_writer (\\<lambda>r. local.put_writer s (f r))", "show \"put_writer s (ask_writer f) = ask_writer (\\<lambda>r. put_writer s (f r))\" for s f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_writer s (local.ask_writer f) =\n    local.ask_writer (\\<lambda>r. local.put_writer s (f r))", "by(rule writerT.expand)(simp add: put_ask)"], ["proof (state)\nthis:\n  local.put_writer ?s2 (local.ask_writer ?f2) =\n  local.ask_writer (\\<lambda>r. local.put_writer ?s2 (?f2 r))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_reader_state local.return_writer local.bind_writer local.ask_writer\n   local.get_writer local.put_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Resumption\\<close>"], ["", "context\n  fixes pause :: \"('o, 'i, 'm) pause\"\nbegin"], ["", "definition pause_writer :: \"('o, 'i, ('w, 'a, 'm) writerT) pause\"\nwhere \"pause_writer out c = WriterT (pause out (\\<lambda>input. run_writer (c input)))\""], ["", "lemma run_pause_writer [simp]:\n  \"run_writer (pause_writer out c) = pause out (\\<lambda>input. run_writer (c input))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.pause_writer out c) =\n    pause out (\\<lambda>input. run_writer (c input))", "by(simp add: pause_writer_def)"], ["", "lemma monad_resumption_writerT [locale_witness]:\n  assumes \"monad_resumption return bind pause\"\n  shows \"monad_resumption return_writer bind_writer pause_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_writer local.bind_writer\n     local.pause_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_writer local.bind_writer\n     local.pause_writer", "interpret monad_resumption return bind pause"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption return bind pause", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_resumption local.return_writer local.bind_writer\n     local.pause_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_resumption local.return_writer local.bind_writer\n     local.pause_writer", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>out c f.\n       local.bind_writer (local.pause_writer out c) f =\n       local.pause_writer out (\\<lambda>i. local.bind_writer (c i) f)", "show \"bind_writer (pause_writer out c) f = pause_writer out (\\<lambda>i. bind_writer (c i) f)\" for out c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.pause_writer out c) f =\n    local.pause_writer out (\\<lambda>i. local.bind_writer (c i) f)", "by(rule writerT.expand)(simp add: bind_pause)"], ["proof (state)\nthis:\n  local.bind_writer (local.pause_writer ?out3 ?c3) ?f3 =\n  local.pause_writer ?out3 (\\<lambda>i. local.bind_writer (?c3 i) ?f3)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_resumption local.return_writer local.bind_writer local.pause_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Binary Non-determinism\\<close>"], ["", "context\n  fixes alt :: \"'m alt\"\nbegin"], ["", "definition alt_writer :: \"('w, 'a, 'm) writerT alt\"\nwhere \"alt_writer m m' = WriterT (alt (run_writer m) (run_writer m'))\""], ["", "lemma run_alt_writer [simp]: \"run_writer (alt_writer m m') = alt (run_writer m) (run_writer m')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_writer (local.alt_writer m m') = alt (run_writer m) (run_writer m')", "by(simp add: alt_writer_def)"], ["", "lemma monad_alt_writerT [locale_witness]:\n  assumes \"monad_alt return bind alt\"\n  shows \"monad_alt return_writer bind_writer alt_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_writer local.bind_writer local.alt_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_writer local.bind_writer local.alt_writer", "interpret monad_alt return bind alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt return bind alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_alt local.return_writer local.bind_writer local.alt_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_alt local.return_writer local.bind_writer local.alt_writer", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m1 m2 m3.\n       local.alt_writer (local.alt_writer m1 m2) m3 =\n       local.alt_writer m1 (local.alt_writer m2 m3)\n 2. \\<And>m m' f.\n       local.bind_writer (local.alt_writer m m') f =\n       local.alt_writer (local.bind_writer m f) (local.bind_writer m' f)", "show \"alt_writer (alt_writer m1 m2) m3 = alt_writer m1 (alt_writer m2 m3)\" \n      for m1 m2 m3"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_writer (local.alt_writer m1 m2) m3 =\n    local.alt_writer m1 (local.alt_writer m2 m3)", "by(rule writerT.expand)(simp add: alt_assoc)"], ["proof (state)\nthis:\n  local.alt_writer (local.alt_writer ?m1.4 ?m2.4) ?m3.4 =\n  local.alt_writer ?m1.4 (local.alt_writer ?m2.4 ?m3.4)\n\ngoal (1 subgoal):\n 1. \\<And>m m' f.\n       local.bind_writer (local.alt_writer m m') f =\n       local.alt_writer (local.bind_writer m f) (local.bind_writer m' f)", "show \"bind_writer (alt_writer m m') f = alt_writer (bind_writer m f) (bind_writer m' f)\"\n      for m m' f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.alt_writer m m') f =\n    local.alt_writer (local.bind_writer m f) (local.bind_writer m' f)", "by(rule writerT.expand)(simp add: bind_alt1)"], ["proof (state)\nthis:\n  local.bind_writer (local.alt_writer ?m4 ?m'4) ?f4 =\n  local.alt_writer (local.bind_writer ?m4 ?f4) (local.bind_writer ?m'4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_alt local.return_writer local.bind_writer local.alt_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_fail_alt_writerT [locale_witness]:\n  assumes \"monad_fail_alt return bind fail alt\"\n  shows \"monad_fail_alt return_writer bind_writer fail_writer alt_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_writer local.bind_writer local.fail_writer\n     local.alt_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_writer local.bind_writer local.fail_writer\n     local.alt_writer", "interpret monad_fail_alt return bind fail alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt return bind fail alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_writer local.bind_writer local.fail_writer\n     local.alt_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail_alt local.return_writer local.bind_writer local.fail_writer\n     local.alt_writer", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>m. local.alt_writer local.fail_writer m = m\n 2. \\<And>m. local.alt_writer m local.fail_writer = m", "show \"alt_writer fail_writer m = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_writer local.fail_writer m = m", "by(rule writerT.expand)(simp add: alt_fail1)"], ["proof (state)\nthis:\n  local.alt_writer local.fail_writer ?m4 = ?m4\n\ngoal (1 subgoal):\n 1. \\<And>m. local.alt_writer m local.fail_writer = m", "show \"alt_writer m fail_writer = m\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_writer m local.fail_writer = m", "by(rule writerT.expand)(simp add: alt_fail2)"], ["proof (state)\nthis:\n  local.alt_writer ?m4 local.fail_writer = ?m4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_fail_alt local.return_writer local.bind_writer local.fail_writer\n   local.alt_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_alt_writerT [locale_witness]:\n  assumes \"monad_state_alt return bind get put alt\"\n  shows \"monad_state_alt return_writer bind_writer get_writer put_writer alt_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.alt_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.alt_writer", "interpret monad_state_alt return bind get put alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt return bind get put alt", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.alt_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_alt local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.alt_writer", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       local.alt_writer (local.get_writer f) (local.get_writer g) =\n       local.get_writer (\\<lambda>x. local.alt_writer (f x) (g x))\n 2. \\<And>s m m'.\n       local.alt_writer (local.put_writer s m) (local.put_writer s m') =\n       local.put_writer s (local.alt_writer m m')", "show \"alt_writer (get_writer f) (get_writer g) = get_writer (\\<lambda>x. alt_writer (f x) (g x))\"\n      for f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_writer (local.get_writer f) (local.get_writer g) =\n    local.get_writer (\\<lambda>x. local.alt_writer (f x) (g x))", "by(rule writerT.expand)(simp add: alt_get)"], ["proof (state)\nthis:\n  local.alt_writer (local.get_writer ?f4) (local.get_writer ?g4) =\n  local.get_writer (\\<lambda>x. local.alt_writer (?f4 x) (?g4 x))\n\ngoal (1 subgoal):\n 1. \\<And>s m m'.\n       local.alt_writer (local.put_writer s m) (local.put_writer s m') =\n       local.put_writer s (local.alt_writer m m')", "show \"alt_writer (put_writer s m) (put_writer s m') = put_writer s (alt_writer m m')\"\n      for s m m'"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.alt_writer (local.put_writer s m) (local.put_writer s m') =\n    local.put_writer s (local.alt_writer m m')", "by(rule writerT.expand)(simp add: alt_put)"], ["proof (state)\nthis:\n  local.alt_writer (local.put_writer ?s4 ?m4) (local.put_writer ?s4 ?m'4) =\n  local.put_writer ?s4 (local.alt_writer ?m4 ?m'4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_alt local.return_writer local.bind_writer local.get_writer\n   local.put_writer local.alt_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Countable Non-determinism\\<close>"], ["", "context\n  fixes altc :: \"('c, 'm) altc\"\nbegin"], ["", "abbreviation altc_writer :: \"('c, ('w, 'a, 'm) writerT) altc\"\nwhere \"altc_writer \\<equiv> altc_sample_writer altc\""], ["", "lemma monad_altc_writerT [locale_witness]:\n  assumes \"monad_altc return bind altc\"\n  shows \"monad_altc return_writer bind_writer altc_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "interpret monad_altc return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "note altc_parametric[transfer_rule]"], ["proof (state)\nthis:\n  bi_unique ?R \\<Longrightarrow>\n  rel_fun (rel_cset ?R) (rel_fun (rel_fun ?R (=)) (=)) altc altc\n\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc local.return_writer local.bind_writer local.altc_writer", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>C g f.\n       local.bind_writer (local.altc_writer C g) f =\n       local.altc_writer C (\\<lambda>c. local.bind_writer (g c) f)\n 2. \\<And>x f. local.altc_writer (csingle x) f = f x\n 3. \\<And>C f g.\n       local.altc_writer (cUnion (cimage f C)) g =\n       local.altc_writer C (\\<lambda>x. local.altc_writer (f x) g)\n 4. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_writer\n        local.altc_writer", "show \"bind_writer (altc_writer C g) f = altc_writer C (\\<lambda>c. bind_writer (g c) f)\" for C g f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.bind_writer (local.altc_writer C g) f =\n    local.altc_writer C (\\<lambda>c. local.bind_writer (g c) f)", "by(rule writerT.expand)(simp add: bind_altc1 o_def)"], ["proof (state)\nthis:\n  local.bind_writer (local.altc_writer ?C4 ?g4) ?f4 =\n  local.altc_writer ?C4 (\\<lambda>c. local.bind_writer (?g4 c) ?f4)\n\ngoal (3 subgoals):\n 1. \\<And>x f. local.altc_writer (csingle x) f = f x\n 2. \\<And>C f g.\n       local.altc_writer (cUnion (cimage f C)) g =\n       local.altc_writer C (\\<lambda>x. local.altc_writer (f x) g)\n 3. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_writer\n        local.altc_writer", "show \"altc_writer (csingle x) f = f x\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_writer (csingle x) f = f x", "by(rule writerT.expand)(simp add: altc_single)"], ["proof (state)\nthis:\n  local.altc_writer (csingle ?x4) ?f4 = ?f4 ?x4\n\ngoal (2 subgoals):\n 1. \\<And>C f g.\n       local.altc_writer (cUnion (cimage f C)) g =\n       local.altc_writer C (\\<lambda>x. local.altc_writer (f x) g)\n 2. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_writer\n        local.altc_writer", "show \"altc_writer (cUNION C f) g = altc_writer C (\\<lambda>x. altc_writer (f x) g)\" for C f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_writer (cUnion (cimage f C)) g =\n    local.altc_writer C (\\<lambda>x. local.altc_writer (f x) g)", "by(rule writerT.expand)(simp add: altc_cUNION o_def)"], ["proof (state)\nthis:\n  local.altc_writer (cUnion (cimage ?f4 ?C4)) ?g4 =\n  local.altc_writer ?C4 (\\<lambda>x. local.altc_writer (?f4 x) ?g4)\n\ngoal (1 subgoal):\n 1. \\<And>R.\n       bi_unique R \\<Longrightarrow>\n       (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_writer\n        local.altc_writer", "show \"(rel_cset R ===> (R ===> (=)) ===> (=)) altc_writer altc_writer\"\n      if [transfer_rule]: \"bi_unique R\" for R"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=)) local.altc_writer\n     local.altc_writer", "unfolding altc_sample_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_cset R ===> (R ===> (=)) ===> (=))\n     (\\<lambda>p f. WriterT (altc p (\\<lambda>p. run_writer (f p))))\n     (\\<lambda>p f. WriterT (altc p (\\<lambda>p. run_writer (f p))))", "by transfer_prover"], ["proof (state)\nthis:\n  bi_unique ?R4 \\<Longrightarrow>\n  (rel_cset ?R4 ===> (?R4 ===> (=)) ===> (=)) local.altc_writer\n   local.altc_writer\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_altc local.return_writer local.bind_writer local.altc_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_altc3_writerT [locale_witness]:\n  assumes \"monad_altc3 return bind altc\"\n  shows \"monad_altc3 return_writer bind_writer altc_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_writer local.bind_writer local.altc_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_writer local.bind_writer local.altc_writer", "interpret monad_altc3 return bind altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 return bind altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_writer local.bind_writer local.altc_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_altc3 local.return_writer local.bind_writer local.altc_writer", ".."], ["proof (state)\nthis:\n  monad_altc3 local.return_writer local.bind_writer local.altc_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma monad_state_altc_writerT [locale_witness]:\n  assumes \"monad_state_altc return bind get put altc\"\n  shows \"monad_state_altc return_writer bind_writer get_writer put_writer altc_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.altc_writer", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.altc_writer", "interpret monad_state_altc return bind get put altc"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc return bind get put altc", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.altc_writer", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state_altc local.return_writer local.bind_writer local.get_writer\n     local.put_writer local.altc_writer", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C f.\n       local.altc_writer C (\\<lambda>c. local.get_writer (f c)) =\n       local.get_writer\n        (\\<lambda>s. local.altc_writer C (\\<lambda>c. f c s))\n 2. \\<And>s C f.\n       local.altc_writer C (\\<lambda>c. local.put_writer s (f c)) =\n       local.put_writer s (local.altc_writer C f)", "show \"altc_writer C (\\<lambda>c. get_writer (f c)) = get_writer (\\<lambda>s. altc_writer C (\\<lambda>c. f c s))\"\n      for C and f :: \"'c \\<Rightarrow> 's \\<Rightarrow> ('w, 'a, 'm) writerT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_writer C (\\<lambda>c. local.get_writer (f c)) =\n    local.get_writer (\\<lambda>s. local.altc_writer C (\\<lambda>c. f c s))", "by(rule writerT.expand)(simp add: o_def altc_get)"], ["proof (state)\nthis:\n  local.altc_writer ?C4 (\\<lambda>c. local.get_writer (?f4 c)) =\n  local.get_writer (\\<lambda>s. local.altc_writer ?C4 (\\<lambda>c. ?f4 c s))\n\ngoal (1 subgoal):\n 1. \\<And>s C f.\n       local.altc_writer C (\\<lambda>c. local.put_writer s (f c)) =\n       local.put_writer s (local.altc_writer C f)", "show \"altc_writer C (\\<lambda>c. put_writer s (f c)) = put_writer s (altc_writer C f)\"\n      for C s and f :: \"'c \\<Rightarrow> ('w, 'a, 'm) writerT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.altc_writer C (\\<lambda>c. local.put_writer s (f c)) =\n    local.put_writer s (local.altc_writer C f)", "by(rule writerT.expand)(simp add: o_def altc_put)"], ["proof (state)\nthis:\n  local.altc_writer ?C4 (\\<lambda>c. local.put_writer ?s4 (?f4 c)) =\n  local.put_writer ?s4 (local.altc_writer ?C4 ?f4)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state_altc local.return_writer local.bind_writer local.get_writer\n   local.put_writer local.altc_writer\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"], ["", "end"], ["", "end"], ["", "subsubsection \\<open>Parametricity\\<close>"], ["", "context includes lifting_syntax begin"], ["", "lemma return_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> A ===> rel_writerT W A M) return_writer return_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===> A ===> rel_writerT W A M)\n     return_writer return_writer", "unfolding return_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===> A ===> rel_writerT W A M)\n     (\\<lambda>return x. WriterT (return (x, [])))\n     (\\<lambda>return x. WriterT (return (x, [])))", "by transfer_prover"], ["", "lemma bind_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> (M ===> (rel_prod A (list_all2 W) ===> M) ===> M)\n   ===> rel_writerT W A M ===> (A ===> rel_writerT W A M) ===> rel_writerT W A M)\n   bind_writer bind_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===>\n     (M ===> (rel_prod A (list_all2 W) ===> M) ===> M) ===>\n     rel_writerT W A M ===>\n     (A ===> rel_writerT W A M) ===> rel_writerT W A M)\n     bind_writer bind_writer", "unfolding bind_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===>\n     (M ===> (rel_prod A (list_all2 W) ===> M) ===> M) ===>\n     rel_writerT W A M ===>\n     (A ===> rel_writerT W A M) ===> rel_writerT W A M)\n     (\\<lambda>return bind m f.\n         WriterT\n          (bind (run_writer m)\n            (\\<lambda>(a, ws).\n                bind (run_writer (f a))\n                 (\\<lambda>(b, ws'). return (b, ws @ ws')))))\n     (\\<lambda>return bind m f.\n         WriterT\n          (bind (run_writer m)\n            (\\<lambda>(a, ws).\n                bind (run_writer (f a))\n                 (\\<lambda>(b, ws'). return (b, ws @ ws')))))", "by transfer_prover"], ["", "lemma tell_writer_parametric [transfer_rule]:\n  \"((rel_prod A (list_all2 W) ===> M) ===> (M ===> (rel_prod A (list_all2 W) ===> M) ===> M)\n   ===> W ===> rel_writerT W A M ===> rel_writerT W A M)\n   tell_writer tell_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===>\n     (M ===> (rel_prod A (list_all2 W) ===> M) ===> M) ===>\n     W ===> rel_writerT W A M ===> rel_writerT W A M)\n     tell_writer tell_writer", "unfolding tell_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_prod A (list_all2 W) ===> M) ===>\n     (M ===> (rel_prod A (list_all2 W) ===> M) ===> M) ===>\n     W ===> rel_writerT W A M ===> rel_writerT W A M)\n     (\\<lambda>return bind w m.\n         WriterT\n          (bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws))))\n     (\\<lambda>return bind w m.\n         WriterT\n          (bind (run_writer m) (\\<lambda>(a, ws). return (a, w # ws))))", "by transfer_prover"], ["", "lemma ask_writer_parametric [transfer_rule]: \n  \"(((R ===> M) ===> M) ===> (R ===> rel_writerT W A M) ===> rel_writerT W A M) ask_writer ask_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===>\n     (R ===> rel_writerT W A M) ===> rel_writerT W A M)\n     ask_writer ask_writer", "unfolding ask_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((R ===> M) ===> M) ===>\n     (R ===> rel_writerT W A M) ===> rel_writerT W A M)\n     (\\<lambda>ask f. WriterT (ask (\\<lambda>r. run_writer (f r))))\n     (\\<lambda>ask f. WriterT (ask (\\<lambda>r. run_writer (f r))))", "by transfer_prover"], ["", "lemma fail_writer_parametric [transfer_rule]:\n  \"(M ===> rel_writerT W A M) fail_writer fail_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_writerT W A M) fail_writer fail_writer", "unfolding fail_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> rel_writerT W A M) WriterT WriterT", "by transfer_prover"], ["", "lemma get_writer_parametric [transfer_rule]:\n  \"(((S ===> M) ===> M) ===> (S ===> rel_writerT W A M) ===> rel_writerT W A M) get_writer get_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> rel_writerT W A M) ===> rel_writerT W A M)\n     get_writer get_writer", "unfolding get_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((S ===> M) ===> M) ===>\n     (S ===> rel_writerT W A M) ===> rel_writerT W A M)\n     (\\<lambda>get f. WriterT (get (\\<lambda>s. run_writer (f s))))\n     (\\<lambda>get f. WriterT (get (\\<lambda>s. run_writer (f s))))", "by transfer_prover"], ["", "lemma put_writer_parametric [transfer_rule]:\n  \"((S ===> M ===> M) ===> S ===> rel_writerT W A M ===> rel_writerT W A M) put_writer put_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_writerT W A M ===> rel_writerT W A M)\n     put_writer put_writer", "unfolding put_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((S ===> M ===> M) ===> S ===> rel_writerT W A M ===> rel_writerT W A M)\n     (\\<lambda>put s m. WriterT (put s (run_writer m)))\n     (\\<lambda>put s m. WriterT (put s (run_writer m)))", "by transfer_prover"], ["", "lemma altc_sample_writer_parametric [transfer_rule]:\n  \"((X ===> (P ===> M) ===> M) ===> X ===> (P ===> rel_writerT W A M) ===> rel_writerT W A M)\n  altc_sample_writer altc_sample_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> (P ===> M) ===> M) ===>\n     X ===> (P ===> rel_writerT W A M) ===> rel_writerT W A M)\n     altc_sample_writer altc_sample_writer", "unfolding altc_sample_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((X ===> (P ===> M) ===> M) ===>\n     X ===> (P ===> rel_writerT W A M) ===> rel_writerT W A M)\n     (\\<lambda>altc_sample p f.\n         WriterT (altc_sample p (\\<lambda>p. run_writer (f p))))\n     (\\<lambda>altc_sample p f.\n         WriterT (altc_sample p (\\<lambda>p. run_writer (f p))))", "by transfer_prover"], ["", "lemma alt_writer_parametric [transfer_rule]:\n  \"((M ===> M ===> M) ===> rel_writerT W A M ===> rel_writerT W A M ===> rel_writerT W A M)\n   alt_writer alt_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_writerT W A M ===> rel_writerT W A M ===> rel_writerT W A M)\n     alt_writer alt_writer", "unfolding alt_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> M ===> M) ===>\n     rel_writerT W A M ===> rel_writerT W A M ===> rel_writerT W A M)\n     (\\<lambda>alt m m'. WriterT (alt (run_writer m) (run_writer m')))\n     (\\<lambda>alt m m'. WriterT (alt (run_writer m) (run_writer m')))", "by transfer_prover"], ["", "lemma pause_writer_parametric [transfer_rule]:\n  \"((Out ===> (In ===> M) ===> M) ===> Out ===> (In ===> rel_writerT W A M) ===> rel_writerT W A M)\n   pause_writer pause_writer\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_writerT W A M) ===> rel_writerT W A M)\n     pause_writer pause_writer", "unfolding pause_writer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((Out ===> (In ===> M) ===> M) ===>\n     Out ===> (In ===> rel_writerT W A M) ===> rel_writerT W A M)\n     (\\<lambda>pause out c.\n         WriterT (pause out (\\<lambda>input. run_writer (c input))))\n     (\\<lambda>pause out c.\n         WriterT (pause out (\\<lambda>input. run_writer (c input))))", "by transfer_prover"], ["", "end"], ["", "subsection \\<open>Continuation monad transformer\\<close>"], ["", "datatype ('a, 'm) contT = ContT (run_cont: \"('a \\<Rightarrow> 'm) \\<Rightarrow> 'm\")"], ["", "subsubsection \\<open>CallCC\\<close>"], ["", "type_synonym ('a, 'm) callcc = \"(('a \\<Rightarrow> 'm) \\<Rightarrow> 'm) \\<Rightarrow> 'm\""], ["", "definition callcc_cont :: \"('a, ('a, 'm) contT) callcc\"\nwhere \"callcc_cont f = ContT (\\<lambda>k. run_cont (f (\\<lambda>x. ContT (\\<lambda>_. k x))) k)\""], ["", "lemma run_callcc_cont [simp]: \"run_cont (callcc_cont f) k = run_cont (f (\\<lambda>x. ContT (\\<lambda>_. k x))) k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont (callcc_cont f) k =\n    run_cont (f (\\<lambda>x. ContT (\\<lambda>_. k x))) k", "by(simp add: callcc_cont_def)"], ["", "subsubsection \\<open>Plain monad\\<close>"], ["", "definition return_cont :: \"('a, ('a, 'm) contT) return\"\nwhere \"return_cont x = ContT (\\<lambda>k. k x)\""], ["", "definition bind_cont :: \"('a, ('a, 'm) contT) bind\"\nwhere \"bind_cont m f = ContT (\\<lambda>k. run_cont m (\\<lambda>x. run_cont (f x) k))\""], ["", "lemma run_return_cont [simp]: \"run_cont (return_cont x) k = k x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont (return_cont x) k = k x", "by(simp add: return_cont_def)"], ["", "lemma run_bind_cont [simp]: \"run_cont (bind_cont m f) k = run_cont m (\\<lambda>x. run_cont (f x) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont (bind_cont m f) k = run_cont m (\\<lambda>x. run_cont (f x) k)", "by(simp add: bind_cont_def)"], ["", "lemma monad_contT [locale_witness]: \"monad return_cont bind_cont\" (is \"monad ?return ?bind\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad return_cont bind_cont", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f g.\n       bind_cont (bind_cont x f) g =\n       bind_cont x (\\<lambda>y. bind_cont (f y) g)\n 2. \\<And>x f. bind_cont (return_cont x) f = f x\n 3. \\<And>x. bind_cont x return_cont = x", "show \"?bind (?bind x f) g = ?bind x (\\<lambda>x. ?bind (f x) g)\" for x f g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont (bind_cont x f) g =\n    bind_cont x (\\<lambda>x. bind_cont (f x) g)", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont (bind_cont ?x ?f) ?g =\n  bind_cont ?x (\\<lambda>x. bind_cont (?f x) ?g)\n\ngoal (2 subgoals):\n 1. \\<And>x f. bind_cont (return_cont x) f = f x\n 2. \\<And>x. bind_cont x return_cont = x", "show \"?bind (?return x) f = f x\" for f x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont (return_cont x) f = f x", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont (return_cont ?x) ?f = ?f ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. bind_cont x return_cont = x", "show \"?bind x ?return = x\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont x return_cont = x", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont ?x return_cont = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Failure\\<close>"], ["", "context\n  fixes fail :: \"'m fail\"\nbegin"], ["", "definition fail_cont :: \"('a, 'm) contT fail\"\nwhere \"fail_cont = ContT (\\<lambda>_. fail)\""], ["", "lemma run_fail_cont [simp]: \"run_cont fail_cont k = fail\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont local.fail_cont k = fail", "by(simp add: fail_cont_def)"], ["", "lemma monad_fail_contT [locale_witness]: \"monad_fail return_cont bind_cont fail_cont\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return_cont bind_cont local.fail_cont", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. bind_cont local.fail_cont f = local.fail_cont", "show \"bind_cont fail_cont f = fail_cont\" for f :: \"'a \\<Rightarrow> ('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont local.fail_cont f = local.fail_cont", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont local.fail_cont ?f1 = local.fail_cont\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>State\\<close>"], ["", "context\n  fixes get :: \"('s, 'm) get\"\n  and put :: \"('s, 'm) put\"\nbegin"], ["", "definition get_cont :: \"('s, ('a, 'm) contT) get\"\nwhere \"get_cont f = ContT (\\<lambda>k. get (\\<lambda>s. run_cont (f s) k))\""], ["", "definition put_cont :: \"('s, ('a, 'm) contT) put\"\nwhere \"put_cont s m = ContT (\\<lambda>k. put s (run_cont m k))\""], ["", "lemma run_get_cont [simp]: \"run_cont (get_cont f) k = get (\\<lambda>s. run_cont (f s) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont (local.get_cont f) k = get (\\<lambda>s. run_cont (f s) k)", "by(simp add: get_cont_def)"], ["", "lemma run_put_cont [simp]: \"run_cont (put_cont s m) k = put s (run_cont m k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_cont (local.put_cont s m) k = put s (run_cont m k)", "by(simp add: put_cont_def)"], ["", "lemma monad_state_contT [locale_witness]:\n  assumes \"monad_state return' bind' get put\" \\<comment> \\<open>We don't need the plain monad operations for lifting.\\<close>\n  shows \"monad_state return_cont bind_cont get_cont (put_cont :: ('s, ('a, 'm) contT) put)\"\n  (is \"monad_state ?return ?bind ?get ?put\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return_cont bind_cont local.get_cont local.put_cont", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state return_cont bind_cont local.get_cont local.put_cont", "interpret monad_state return' bind' get put"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return' bind' get put", "by(fact assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. monad_state return_cont bind_cont local.get_cont local.put_cont", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_state return_cont bind_cont local.get_cont local.put_cont", "proof"], ["proof (state)\ngoal (7 subgoals):\n 1. \\<And>s f. local.put_cont s (local.get_cont f) = local.put_cont s (f s)\n 2. \\<And>f.\n       local.get_cont (\\<lambda>s. local.get_cont (f s)) =\n       local.get_cont (\\<lambda>s. f s s)\n 3. \\<And>s s' m.\n       local.put_cont s (local.put_cont s' m) = local.put_cont s' m\n 4. \\<And>m. local.get_cont (\\<lambda>s. local.put_cont s m) = m\n 5. \\<And>m. local.get_cont (\\<lambda>_. m) = m\n 6. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 7. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"put_cont s (get_cont f) = put_cont s (f s)\" for s :: 's and f :: \"'s \\<Rightarrow> ('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_cont s (local.get_cont f) = local.put_cont s (f s)", "by(rule contT.expand)(simp add: put_get fun_eq_iff)"], ["proof (state)\nthis:\n  local.put_cont ?s2 (local.get_cont ?f2) = local.put_cont ?s2 (?f2 ?s2)\n\ngoal (6 subgoals):\n 1. \\<And>f.\n       local.get_cont (\\<lambda>s. local.get_cont (f s)) =\n       local.get_cont (\\<lambda>s. f s s)\n 2. \\<And>s s' m.\n       local.put_cont s (local.put_cont s' m) = local.put_cont s' m\n 3. \\<And>m. local.get_cont (\\<lambda>s. local.put_cont s m) = m\n 4. \\<And>m. local.get_cont (\\<lambda>_. m) = m\n 5. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 6. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"get_cont (\\<lambda>s. get_cont (f s)) = get_cont (\\<lambda>s. f s s)\" for f :: \"'s \\<Rightarrow> 's \\<Rightarrow> ('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_cont (\\<lambda>s. local.get_cont (f s)) =\n    local.get_cont (\\<lambda>s. f s s)", "by(rule contT.expand)(simp add: get_get fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_cont (\\<lambda>s. local.get_cont (?f2 s)) =\n  local.get_cont (\\<lambda>s. ?f2 s s)\n\ngoal (5 subgoals):\n 1. \\<And>s s' m.\n       local.put_cont s (local.put_cont s' m) = local.put_cont s' m\n 2. \\<And>m. local.get_cont (\\<lambda>s. local.put_cont s m) = m\n 3. \\<And>m. local.get_cont (\\<lambda>_. m) = m\n 4. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 5. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"put_cont s (put_cont s' m) = put_cont s' m\" for s s' and m :: \"('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.put_cont s (local.put_cont s' m) = local.put_cont s' m", "by(rule contT.expand)(simp add: put_put fun_eq_iff)"], ["proof (state)\nthis:\n  local.put_cont ?s2 (local.put_cont ?s'2 ?m2) = local.put_cont ?s'2 ?m2\n\ngoal (4 subgoals):\n 1. \\<And>m. local.get_cont (\\<lambda>s. local.put_cont s m) = m\n 2. \\<And>m. local.get_cont (\\<lambda>_. m) = m\n 3. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 4. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"get_cont (\\<lambda>s. put_cont s m) = m\" for m :: \"('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_cont (\\<lambda>s. local.put_cont s m) = m", "by(rule contT.expand)(simp add: get_put fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_cont (\\<lambda>s. local.put_cont s ?m2) = ?m2\n\ngoal (3 subgoals):\n 1. \\<And>m. local.get_cont (\\<lambda>_. m) = m\n 2. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 3. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"get_cont (\\<lambda>_. m) = m\" for m :: \"('a, 'm) contT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.get_cont (\\<lambda>_. m) = m", "by(rule contT.expand)(simp add: get_const fun_eq_iff)"], ["proof (state)\nthis:\n  local.get_cont (\\<lambda>_. ?m2) = ?m2\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       bind_cont (local.get_cont f) g =\n       local.get_cont (\\<lambda>s. bind_cont (f s) g)\n 2. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"bind_cont (get_cont f) g = get_cont (\\<lambda>s. bind_cont (f s) g)\"\n      for f :: \"'s \\<Rightarrow> ('a, 'm) contT\" and g"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont (local.get_cont f) g =\n    local.get_cont (\\<lambda>s. bind_cont (f s) g)", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont (local.get_cont ?f2) ?g2 =\n  local.get_cont (\\<lambda>s. bind_cont (?f2 s) ?g2)\n\ngoal (1 subgoal):\n 1. \\<And>s m f.\n       bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "show \"bind_cont (put_cont s m) f = put_cont s (bind_cont m f)\" for s and m :: \"('a, 'm) contT\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind_cont (local.put_cont s m) f = local.put_cont s (bind_cont m f)", "by(rule contT.expand)(simp add: fun_eq_iff)"], ["proof (state)\nthis:\n  bind_cont (local.put_cont ?s2 ?m2) ?f2 =\n  local.put_cont ?s2 (bind_cont ?m2 ?f2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monad_state return_cont bind_cont local.get_cont local.put_cont\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \\<open>Locales for monad homomorphisms\\<close>"], ["", "locale monad_hom = m1: monad return1 bind1 +\n  m2: monad return2 bind2\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_return: \"\\<And>x. h (return1 x) = return2 x\"\n  and hom_bind: \"\\<And>x f. h (bind1 x f) = bind2 (h x) (h \\<circ> f)\"\nbegin"], ["", "lemma hom_lift [simp]: \"h (m1.lift f m) = m2.lift f (h m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h (m1.lift f m) = m2.lift f (h m)", "by(simp add: m1.lift_def m2.lift_def hom_bind hom_return o_def)"], ["", "end"], ["", "locale monad_state_hom = m1: monad_state return1 bind1 get1 put1 + \n  m2: monad_state return2 bind2 get2 put2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and get1 :: \"('s, 'm1) get\"\n  and put1 :: \"('s, 'm1) put\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and get2 :: \"('s, 'm2) get\"\n  and put2 :: \"('s, 'm2) put\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_get [simp]: \"h (get1 f) = get2 (h \\<circ> f)\"\n  and hom_put [simp]: \"h (put1 s m) = put2 s (h m)\""], ["", "locale monad_fail_hom = m1: monad_fail return1 bind1 fail1 + \n  m2: monad_fail return2 bind2 fail2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and fail1 :: \"'m1 fail\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and fail2 :: \"'m2 fail\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_fail [simp]: \"h fail1 = fail2\""], ["", "locale monad_catch_hom = m1: monad_catch return1 bind1 fail1 catch1 +\n  m2: monad_catch return2 bind2 fail2 catch2 +\n  monad_fail_hom return1 bind1 fail1 return2 bind2 fail2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and fail1 :: \"'m1 fail\"\n  and catch1 :: \"'m1 catch\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and fail2 :: \"'m2 fail\"\n  and catch2 :: \"'m2 catch\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_catch [simp]: \"h (catch1 m1 m2) = catch2 (h m1) (h m2)\""], ["", "locale monad_reader_hom = m1: monad_reader return1 bind1 ask1 +\n  m2: monad_reader return2 bind2 ask2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and ask1 :: \"('r, 'm1) ask\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and ask2 :: \"('r, 'm2) ask\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_ask [simp]: \"h (ask1 f) = ask2 (h \\<circ> f)\""], ["", "locale monad_prob_hom = m1: monad_prob return1 bind1 sample1 +\n  m2: monad_prob return2 bind2 sample2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and sample1 :: \"('p, 'm1) sample\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and sample2 :: \"('p, 'm2) sample\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_sample [simp]: \"h (sample1 p f) = sample2 p (h \\<circ> f)\""], ["", "locale monad_alt_hom = m1: monad_alt return1 bind1 alt1 +\n  m2: monad_alt return2 bind2 alt2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and alt1 :: \"'m1 alt\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and alt2 :: \"'m2 alt\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_alt [simp]: \"h (alt1 m m') = alt2 (h m) (h m')\""], ["", "locale monad_altc_hom = m1: monad_altc return1 bind1 altc1 +\n  m2: monad_altc return2 bind2 altc2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and altc1 :: \"('c, 'm1) altc\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and altc2 :: \"('c, 'm2) altc\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_altc [simp]: \"h (altc1 C f) = altc2 C (h \\<circ> f)\""], ["", "locale monad_writer_hom = m1: monad_writer return1 bind1 tell1 +\n  m2: monad_writer return2 bind2 tell2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and tell1 :: \"('w, 'm1) tell\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and tell2 :: \"('w, 'm2) tell\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_tell [simp]: \"h (tell1 w m) = tell2 w (h m)\""], ["", "locale monad_resumption_hom = m1: monad_resumption return1 bind1 pause1 +\n  m2: monad_resumption return2 bind2 pause2 +\n  monad_hom return1 bind1 return2 bind2 h\n  for return1 :: \"('a, 'm1) return\"\n  and bind1 :: \"('a, 'm1) bind\"\n  and pause1 :: \"('o, 'i, 'm1) pause\"\n  and return2 :: \"('a, 'm2) return\"\n  and bind2 :: \"('a, 'm2) bind\"\n  and pause2 :: \"('o, 'i, 'm2) pause\"\n  and h :: \"'m1 \\<Rightarrow> 'm2\"\n  +\n  assumes hom_pause [simp]: \"h (pause1 out c) = pause2 out (h \\<circ> c)\""], ["", "section \\<open>Switching between monads\\<close>"], ["", "text \\<open>Homomorphisms are functional relations between monads. In general, it is more\n  convenient to use arbitrary relations as embeddings because arbitrary relations allow us to\n  change the type of values in a monad. As different monad transformers change the value type in \n  different ways, the embeddings must also support such changes in values. \\<close>"], ["", "context includes lifting_syntax begin"], ["", "subsection \\<open>Embedding Identity into Probability\\<close>"], ["", "named_theorems cr_id_prob_transfer"], ["", "definition prob_of_id :: \"'a id \\<Rightarrow> 'a prob\" where\n  \"prob_of_id m = return_pmf (extract m)\""], ["", "lemma monad_id_prob_hom [locale_witness]:\n  \"monad_hom return_id bind_id return_pmf bind_pmf prob_of_id\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_hom return_id bind_id return_pmf (\\<bind>) prob_of_id", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. prob_of_id (return_id x) = return_pmf x\n 2. \\<And>x f.\n       prob_of_id (bind_id x f) = prob_of_id x \\<bind> prob_of_id \\<circ> f", "show \"prob_of_id (return_id x) = return_pmf x\" for x :: 'a"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_of_id (return_id x) = return_pmf x", "by(simp add: prob_of_id_def)"], ["proof (state)\nthis:\n  prob_of_id (return_id ?x) = return_pmf ?x\n\ngoal (1 subgoal):\n 1. \\<And>x f.\n       prob_of_id (bind_id x f) = prob_of_id x \\<bind> prob_of_id \\<circ> f", "show \"prob_of_id (bind_id x f) = prob_of_id x \\<bind> prob_of_id \\<circ> f\" for x :: \"'a id\" and f"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_of_id (bind_id x f) = prob_of_id x \\<bind> prob_of_id \\<circ> f", "by(simp add: prob_of_id_def bind_return_pmf)"], ["proof (state)\nthis:\n  prob_of_id (bind_id ?x ?f) = prob_of_id ?x \\<bind> prob_of_id \\<circ> ?f\n\ngoal:\nNo subgoals!", "qed"], ["", "inductive cr_id_prob :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a id \\<Rightarrow> 'b prob \\<Rightarrow> bool\" for A\nwhere \"A x y \\<Longrightarrow> cr_id_prob A (return_id x) (return_pmf y)\""], ["", "inductive_simps cr_id_prob_simps [simp]: \"cr_id_prob A (return_id x) (return_pmf y)\""], ["", "lemma cr_id_prob_return [cr_id_prob_transfer]: \"(A ===> cr_id_prob A) return_id return_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> cr_id_prob A) return_id return_pmf", "by(simp add: rel_fun_def)"], ["", "lemma cr_id_prob_bind [cr_id_prob_transfer]: \n  \"(cr_id_prob A ===> (A ===> cr_id_prob B) ===> cr_id_prob B) bind_id bind_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_id_prob A ===> (A ===> cr_id_prob B) ===> cr_id_prob B) bind_id\n     (\\<bind>)", "by(auto simp add: rel_fun_def bind_return_pmf elim!: cr_id_prob.cases)"], ["", "lemma cr_id_prob_Grp: \"cr_id_prob (BNF_Def.Grp A f) = BNF_Def.Grp {x. set_id x \\<subseteq> A} (return_pmf \\<circ> f \\<circ> extract)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_id_prob (BNF_Def.Grp A f) =\n    BNF_Def.Grp {x. set_id x \\<subseteq> A}\n     (return_pmf \\<circ> f \\<circ> extract)", "apply(auto simp add: Grp_def fun_eq_iff simp add: cr_id_prob.simps intro: id.expand)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       set_id x \\<subseteq> A \\<Longrightarrow>\n       \\<exists>xa.\n          x = return_id xa \\<and> f (extract x) = f xa \\<and> xa \\<in> A", "subgoal for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_id x \\<subseteq> A \\<Longrightarrow>\n    \\<exists>xa.\n       x = return_id xa \\<and> f (extract x) = f xa \\<and> xa \\<in> A", "by(cases x) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>State and Reader\\<close>"], ["", "text \\<open>When no state updates are needed, the operation @{term get} can be replaced by @{term ask}.\\<close>"], ["", "named_theorems cr_envT_stateT_transfer"], ["", "definition cr_prod1 :: \"'c \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'b \\<times> 'c \\<Rightarrow> bool\"\nwhere \"cr_prod1 c' A = (\\<lambda>a (b, c). A a b \\<and> c' = c)\""], ["", "lemma cr_prod1_simps [simp]: \"cr_prod1 c' A a (b, c) \\<longleftrightarrow> A a b \\<and> c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_prod1 c' A a (b, c) = (A a b \\<and> c' = c)", "by(simp add: cr_prod1_def)"], ["", "lemma cr_prod1I: \"A a b \\<Longrightarrow> cr_prod1 c' A a (b, c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A a b \\<Longrightarrow> cr_prod1 c' A a (b, c')", "by simp"], ["", "lemma cr_prod1_Pair_transfer [cr_envT_stateT_transfer]: \"(A ===> eq_onp ((=) c) ===> cr_prod1 c A) (\\<lambda>a _. a) Pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> eq_onp ((=) c) ===> cr_prod1 c A) (\\<lambda>a _. a) Pair", "by(auto simp add: rel_fun_def eq_onp_def)"], ["", "lemma cr_prod1_fst_transfer [cr_envT_stateT_transfer]: \"(cr_prod1 c A ===> A) (\\<lambda>a. a) fst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_prod1 c A ===> A) (\\<lambda>a. a) fst", "by(auto simp add: rel_fun_def)"], ["", "lemma cr_prod1_case_prod_transfer [cr_envT_stateT_transfer]:\n  \"((A ===> eq_onp ((=) c) ===> C) ===> cr_prod1 c A ===> C) (\\<lambda>f a. f a c) case_prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((A ===> eq_onp ((=) c) ===> C) ===> cr_prod1 c A ===> C)\n     (\\<lambda>f a. f a c) case_prod", "by(simp add: rel_fun_def eq_onp_def)"], ["", "lemma cr_prod1_Grp: \"cr_prod1 c (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (f b, c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_prod1 c (BNF_Def.Grp A f) = BNF_Def.Grp A (\\<lambda>b. (f b, c))", "by(auto simp add: Grp_def fun_eq_iff)"], ["", "definition cr_envT_stateT :: \"'s \\<Rightarrow> ('m1 \\<Rightarrow> 'm2 \\<Rightarrow> bool) \\<Rightarrow> ('s, 'm1) envT \\<Rightarrow> ('s, 'm2) stateT \\<Rightarrow> bool\"\nwhere \"cr_envT_stateT s M m1 m2 = (eq_onp ((=) s) ===> M) (run_env m1) (run_state m2)\""], ["", "lemma cr_envT_stateT_simps [simp]:\n  \"cr_envT_stateT s M (EnvT f) (StateT g) \\<longleftrightarrow> M (f s) (g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_envT_stateT s M (EnvT f) (StateT g) = M (f s) (g s)", "by(simp add: cr_envT_stateT_def rel_fun_def eq_onp_def)"], ["", "lemma cr_envT_stateTE:\n  assumes \"cr_envT_stateT s M m1 m2\"\n  obtains f g where \"m1 = EnvT f\" \"m2 = StateT g\" \"(eq_onp ((=) s) ===> M) f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>m1 = EnvT f; m2 = StateT g;\n         (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  cr_envT_stateT s M m1 m2\n\ngoal (1 subgoal):\n 1. (\\<And>f g.\n        \\<lbrakk>m1 = EnvT f; m2 = StateT g;\n         (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(cases m1; cases m2; auto simp add: eq_onp_def)"], ["", "lemma cr_envT_stateTD: \"cr_envT_stateT s M m1 m2 \\<Longrightarrow> M (run_env m1 s) (run_state m2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_envT_stateT s M m1 m2 \\<Longrightarrow>\n    M (run_env m1 s) (run_state m2 s)", "by(auto elim!: cr_envT_stateTE dest: rel_funD simp add: eq_onp_def)"], ["", "lemma cr_envT_stateT_run [cr_envT_stateT_transfer]:\n  \"(cr_envT_stateT s M ===> eq_onp ((=) s) ===> M) run_env run_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_envT_stateT s M ===> eq_onp ((=) s) ===> M) run_env run_state", "by(rule rel_funI)(auto elim!: cr_envT_stateTE)"], ["", "lemma cr_envT_stateT_StateT_EnvT [cr_envT_stateT_transfer]:\n  \"((eq_onp ((=) s) ===> M) ===> cr_envT_stateT s M) EnvT StateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eq_onp ((=) s) ===> M) ===> cr_envT_stateT s M) EnvT StateT", "by(auto 4 3 dest: rel_funD simp add: eq_onp_def)"], ["", "lemma cr_envT_stateT_rec [cr_envT_stateT_transfer]:\n  \"(((eq_onp ((=) s) ===> M) ===> C) ===> cr_envT_stateT s M ===> C) rec_envT rec_stateT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((eq_onp ((=) s) ===> M) ===> C) ===> cr_envT_stateT s M ===> C)\n     rec_envT rec_stateT", "by(auto simp add: rel_fun_def elim!: cr_envT_stateTE)"], ["", "lemma cr_envT_stateT_return [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_envT_stateT_transfer shows\n  \"((cr_prod1 s A ===> M) ===> A ===> cr_envT_stateT s M) return_env return_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((cr_prod1 s A ===> M) ===> A ===> cr_envT_stateT s M) return_env\n     return_state", "unfolding return_env_def return_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((cr_prod1 s A ===> M) ===> A ===> cr_envT_stateT s M)\n     (\\<lambda>return x. EnvT (\\<lambda>_. return x))\n     (\\<lambda>return x. StateT (\\<lambda>s. return (x, s)))", "by transfer_prover"], ["", "lemma cr_envT_stateT_bind [cr_envT_stateT_transfer]:\n  \"((M ===> (cr_prod1 s A ===> M) ===> M) ===> cr_envT_stateT s M ===> (A ===> cr_envT_stateT s M) ===> cr_envT_stateT s M)\n   bind_env bind_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((M ===> (cr_prod1 s A ===> M) ===> M) ===>\n     cr_envT_stateT s M ===>\n     (A ===> cr_envT_stateT s M) ===> cr_envT_stateT s M)\n     bind_env bind_state", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>(M ===> (cr_prod1 s A ===> M) ===> M) x y;\n        cr_envT_stateT s M xa ya; (A ===> cr_envT_stateT s M) xb yb\\<rbrakk>\n       \\<Longrightarrow> cr_envT_stateT s M (bind_env x xa xb)\n                          (bind_state y ya yb)", "apply(erule cr_envT_stateTE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya xb yb f g.\n       \\<lbrakk>(M ===> (cr_prod1 s A ===> M) ===> M) x y;\n        (A ===> cr_envT_stateT s M) xb yb; xa = EnvT f; ya = StateT g;\n        (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n       \\<Longrightarrow> cr_envT_stateT s M (bind_env x xa xb)\n                          (bind_state y ya yb)", "apply(clarsimp simp add: split_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb yb f g.\n       \\<lbrakk>(M ===> (cr_prod1 s A ===> M) ===> M) x y;\n        (A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n       \\<Longrightarrow> M (x (f s) (\\<lambda>y. run_env (xb y) s))\n                          (y (g s)\n                            (\\<lambda>p. run_state (yb (fst p)) (snd p)))", "apply(drule rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xb yb f g.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n       \\<Longrightarrow> M (?x10 x y xb yb f g) (?y10 x y xb yb f g)\n 2. \\<And>x y xb yb f g.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g;\n        ((cr_prod1 s A ===> M) ===> M) (x (?x10 x y xb yb f g))\n         (y (?y10 x y xb yb f g))\\<rbrakk>\n       \\<Longrightarrow> M (x (f s) (\\<lambda>y. run_env (xb y) s))\n                          (y (g s)\n                            (\\<lambda>p. run_state (yb (fst p)) (snd p)))", "apply(erule rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xb yb f g.\n       (A ===> cr_envT_stateT s M) xb yb \\<Longrightarrow>\n       eq_onp ((=) s) (?x13 x y xb yb f g) (?y13 x y xb yb f g)\n 2. \\<And>x y xb yb f g.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g;\n        ((cr_prod1 s A ===> M) ===> M) (x (f (?x13 x y xb yb f g)))\n         (y (g (?y13 x y xb yb f g)))\\<rbrakk>\n       \\<Longrightarrow> M (x (f s) (\\<lambda>y. run_env (xb y) s))\n                          (y (g s)\n                            (\\<lambda>p. run_state (yb (fst p)) (snd p)))", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb yb f g.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g;\n        ((cr_prod1 s A ===> M) ===> M) (x (f s)) (y (g s))\\<rbrakk>\n       \\<Longrightarrow> M (x (f s) (\\<lambda>y. run_env (xb y) s))\n                          (y (g s)\n                            (\\<lambda>p. run_state (yb (fst p)) (snd p)))", "apply(erule rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb yb f g.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g\\<rbrakk>\n       \\<Longrightarrow> (cr_prod1 s A ===> M)\n                          (\\<lambda>y. run_env (xb y) s)\n                          (\\<lambda>p. run_state (yb (fst p)) (snd p))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xb yb f g xa ya.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g; cr_prod1 s A xa ya\\<rbrakk>\n       \\<Longrightarrow> M (run_env (xb xa) s)\n                          (run_state (yb (fst ya)) (snd ya))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb yb f g xa a.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g; A xa a\\<rbrakk>\n       \\<Longrightarrow> M (run_env (xb xa) s) (run_state (yb a) s)", "apply(rule cr_envT_stateT_run[THEN rel_funD, THEN rel_funD, where B=M])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb yb f g xa a.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g; A xa a\\<rbrakk>\n       \\<Longrightarrow> cr_envT_stateT (?s24 xb yb f g xa a) M (xb xa)\n                          (yb a)\n 2. \\<And>xb yb f g xa a.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g; A xa a\\<rbrakk>\n       \\<Longrightarrow> eq_onp ((=) (?s24 xb yb f g xa a)) s s", "apply(erule (1) rel_funD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xb yb f g xa a.\n       \\<lbrakk>(A ===> cr_envT_stateT s M) xb yb;\n        (eq_onp ((=) s) ===> M) f g; A xa a\\<rbrakk>\n       \\<Longrightarrow> eq_onp ((=) s) s s", "apply(simp add: eq_onp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cr_envT_stateT_ask_get [cr_envT_stateT_transfer]:\n  \"((eq_onp ((=) s) ===> cr_envT_stateT s M) ===> cr_envT_stateT s M) ask_env get_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eq_onp ((=) s) ===> cr_envT_stateT s M) ===> cr_envT_stateT s M)\n     ask_env get_state", "unfolding ask_env_def get_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((eq_onp ((=) s) ===> cr_envT_stateT s M) ===> cr_envT_stateT s M)\n     (\\<lambda>f. EnvT (\\<lambda>r. run_env (f r) r))\n     (\\<lambda>f. StateT (\\<lambda>s. run_state (f s) s))", "apply(rule rel_funI)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (eq_onp ((=) s) ===> cr_envT_stateT s M) x y \\<Longrightarrow>\n       cr_envT_stateT s M (EnvT (\\<lambda>r. run_env (x r) r))\n        (StateT (\\<lambda>s. run_state (y s) s))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       (eq_onp ((=) s) ===> cr_envT_stateT s M) x y \\<Longrightarrow>\n       M (run_env (x s) s) (run_state (y s) s)", "apply(rule cr_envT_stateT_run[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (eq_onp ((=) s) ===> cr_envT_stateT s M) x y \\<Longrightarrow>\n       cr_envT_stateT (?s4 x y) M (x s) (y s)\n 2. \\<And>x y.\n       (eq_onp ((=) s) ===> cr_envT_stateT s M) x y \\<Longrightarrow>\n       eq_onp ((=) (?s4 x y)) s s", "apply(erule rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. eq_onp ((=) s) s s\n 2. \\<And>x y.\n       (eq_onp ((=) s) ===> cr_envT_stateT s M) x y \\<Longrightarrow>\n       eq_onp ((=) s) s s", "apply(simp_all add: eq_onp_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cr_envT_stateT_fail [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_envT_stateT_transfer shows\n  \"(M ===> cr_envT_stateT s M) fail_env fail_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> cr_envT_stateT s M) fail_env fail_state", "unfolding fail_env_def fail_state_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (M ===> cr_envT_stateT s M) (\\<lambda>fail. EnvT (\\<lambda>r. fail))\n     (\\<lambda>fail. StateT (\\<lambda>s. fail))", "by transfer_prover"], ["", "subsection \\<open>@{typ \"_ spmf\"} and @{typ \"(_, _ prob) optionT\"}\\<close>"], ["", "text \\<open>\n  This section defines the mapping between the @{typ \"_ spmf\"} monad and the monad obtained by\n  composing transforming @{typ \"_ prob\"} with @{typ \"(_, _) optionT\"}.\n\\<close>"], ["", "definition cr_spmf_prob_optionT :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> ('a, 'a option prob) optionT \\<Rightarrow> 'b spmf \\<Rightarrow> bool\"\nwhere \"cr_spmf_prob_optionT A p q \\<longleftrightarrow> rel_spmf A (run_option p) q\""], ["", "lemma cr_spmf_prob_optionTI: \"rel_spmf A (run_option p) q \\<Longrightarrow> cr_spmf_prob_optionT A p q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_spmf A (run_option p) q \\<Longrightarrow> cr_spmf_prob_optionT A p q", "by(simp add: cr_spmf_prob_optionT_def)"], ["", "lemma cr_spmf_prob_optionTD: \"cr_spmf_prob_optionT A p q \\<Longrightarrow> rel_spmf A (run_option p) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_spmf_prob_optionT A p q \\<Longrightarrow> rel_spmf A (run_option p) q", "by(simp add: cr_spmf_prob_optionT_def)"], ["", "lemma cr_spmf_prob_optionT_return_transfer:\n   \\<comment> \\<open>Cannot be used as a transfer rule in @{method transfer_prover} because @{term return_spmf} is not a constant.\\<close>\n  \"(A ===> cr_spmf_prob_optionT A) (return_option return_pmf) return_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> cr_spmf_prob_optionT A) (return_option return_pmf) return_spmf", "by(simp add: rel_fun_def cr_spmf_prob_optionTI)"], ["", "lemma cr_spmf_prob_optionT_bind_transfer:\n  \"(cr_spmf_prob_optionT A ===> (A ===> cr_spmf_prob_optionT A) ===> cr_spmf_prob_optionT A)\n   (bind_option return_pmf bind_pmf) bind_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_spmf_prob_optionT A ===>\n     (A ===> cr_spmf_prob_optionT A) ===> cr_spmf_prob_optionT A)\n     (bind_option return_pmf (\\<bind>)) (\\<bind>)", "by(rule rel_funI cr_spmf_prob_optionTI)+\n  (auto 4 4 simp add: run_bind_option bind_spmf_def dest!: cr_spmf_prob_optionTD dest: rel_funD intro: rel_pmf_bindI split: option.split)"], ["", "lemma cr_spmf_prob_optionT_fail_transfer:\n  \"cr_spmf_prob_optionT A (fail_option return_pmf) (return_pmf None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_spmf_prob_optionT A (fail_option return_pmf) (return_pmf None)", "by(rule cr_spmf_prob_optionTI) simp"], ["", "abbreviation (input) spmf_of_prob_optionT :: \"('a, 'a option prob) optionT \\<Rightarrow> 'a spmf\" \nwhere \"spmf_of_prob_optionT \\<equiv> run_option\""], ["", "abbreviation (input) prob_optionT_of_spmf :: \"'a spmf \\<Rightarrow> ('a, 'a option prob) optionT\"\nwhere \"prob_optionT_of_spmf \\<equiv> OptionT\""], ["", "lemma spmf_of_prob_optionT_transfer: \"(cr_spmf_prob_optionT A ===> rel_spmf A) spmf_of_prob_optionT (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_spmf_prob_optionT A ===> rel_spmf A) run_option (\\<lambda>x. x)", "by(auto simp add: rel_fun_def dest: cr_spmf_prob_optionTD)"], ["", "lemma prob_optionT_of_spmf_transfer: \"(rel_spmf A ===> cr_spmf_prob_optionT A) prob_optionT_of_spmf (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (rel_spmf A ===> cr_spmf_prob_optionT A) OptionT (\\<lambda>x. x)", "by(auto simp add: rel_fun_def intro: cr_spmf_prob_optionTI)"], ["", "subsection \\<open>Probabilities and countable non-determinism\\<close>"], ["", "named_theorems cr_prob_ndi_transfer"], ["", "context includes cset.lifting begin"], ["", "interpretation cset_nondetM return_id bind_id merge_id merge_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM return_id bind_id merge_id merge_id", ".."], ["", "lift_definition cset_pmf :: \"'a pmf \\<Rightarrow> 'a cset\" is set_pmf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pmf. countable (set_pmf pmf)", "by simp"], ["", "inductive cr_pmf_cset :: \"'a pmf \\<Rightarrow> 'a cset \\<Rightarrow> bool\" for p where\n  \"cr_pmf_cset p (cset_pmf p)\""], ["", "lemma cr_pmf_cset_Grp: \"cr_pmf_cset = BNF_Def.Grp UNIV cset_pmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_pmf_cset = BNF_Def.Grp UNIV cset_pmf", "by(simp add: fun_eq_iff cr_pmf_cset.simps Grp_def)"], ["", "lemma cr_pmf_cset_return_pmf [cr_prob_ndi_transfer]:\n  \"((=) ===> cr_pmf_cset) return_pmf csingle\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===> cr_pmf_cset) return_pmf csingle", "by(simp add: cr_pmf_cset.simps rel_fun_def)(transfer; simp)"], ["", "inductive cr_prob_ndi :: \"('a \\<Rightarrow> 'b \\<Rightarrow> bool) \\<Rightarrow> 'a prob \\<Rightarrow> ('b, 'b cset id) nondetT \\<Rightarrow> bool\" \n  for A p B where\n  \"cr_prob_ndi A p B\" if \"rel_set A (set_pmf p) (rcset (extract (run_nondet B)))\""], ["", "lemma cr_prob_ndi_Grp: \"cr_prob_ndi (BNF_Def.Grp UNIV f) = BNF_Def.Grp UNIV (NondetT \\<circ> return_id \\<circ> cimage f \\<circ> cset_pmf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cr_prob_ndi (BNF_Def.Grp UNIV f) =\n    BNF_Def.Grp UNIV\n     (NondetT \\<circ> return_id \\<circ> cimage f \\<circ> cset_pmf)", "by(simp add: fun_eq_iff cr_prob_ndi.simps rel_set_Grp)\n    (auto simp add: Grp_def cimage.rep_eq cset_pmf.rep_eq cin.rep_eq intro!: nondetT.expand id.expand)"], ["", "lemma cr_ndi_prob_return [cr_prob_ndi_transfer]:\n  \"(A ===> cr_prob_ndi A) return_pmf return_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ===> cr_prob_ndi A) return_pmf return_nondet", "by(simp add: rel_fun_def cr_prob_ndi.simps)(transfer; simp add: rel_set_def)"], ["", "lemma cr_ndi_prob_bind [cr_prob_ndi_transfer]:\n  \"(cr_prob_ndi A ===> (A ===> cr_prob_ndi A) ===> cr_prob_ndi A) bind_pmf bind_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_prob_ndi A ===> (A ===> cr_prob_ndi A) ===> cr_prob_ndi A) (\\<bind>)\n     bind_nondet", "apply (clarsimp simp add: cr_prob_ndi.simps cUnion.rep_eq cimage.rep_eq intro!: rel_funI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set A (\\<Union>M\\<in>set_pmf x. set_pmf (xa M))\n                          (\\<Union>x\\<in>rcset (extract (run_nondet y)).\n                              rcset (extract (run_nondet (ya x))))", "apply(rule Union_transfer[THEN rel_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set (rel_set A)\n                          ((\\<lambda>M. set_pmf (xa M)) ` set_pmf x)\n                          ((\\<lambda>x.\n                               rcset (extract (run_nondet (ya x)))) `\n                           rcset (extract (run_nondet y)))", "apply(rule image_transfer[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> (?A18 x y xa ya ===> rel_set A)\n                          (\\<lambda>M. set_pmf (xa M))\n                          (\\<lambda>x. rcset (extract (run_nondet (ya x))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set (?A18 x y xa ya) (set_pmf x)\n                          (rcset (extract (run_nondet y)))", "apply(rule rel_funI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya; ?A18 x y xa ya xb yb\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya yb))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set (?A18 x y xa ya) (set_pmf x)\n                          (rcset (extract (run_nondet y)))", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        A (?x23 x y xa ya xb yb) (?y23 x y xa ya xb yb);\n        cr_prob_ndi A (xa (?x23 x y xa ya xb yb))\n         (ya (?y23 x y xa ya xb yb))\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya yb))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set\n                          (\\<lambda>xb yb.\n                              A (?x23 x y xa ya xb yb)\n                               (?y23 x y xa ya xb yb))\n                          (set_pmf x) (rcset (extract (run_nondet y)))", "apply(erule cr_prob_ndi.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y xa ya xb yb.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        A (?x23 x y xa ya xb yb) (?y23 x y xa ya xb yb);\n        rel_set A (set_pmf (xa (?x23 x y xa ya xb yb)))\n         (rcset (extract (run_nondet (ya (?y23 x y xa ya xb yb)))))\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya yb))))\n 2. \\<And>x y xa ya.\n       \\<lbrakk>rel_set A (set_pmf x) (rcset (extract (run_nondet y)));\n        (A ===> cr_prob_ndi A) xa ya\\<rbrakk>\n       \\<Longrightarrow> rel_set\n                          (\\<lambda>xb yb.\n                              A (?x23 x y xa ya xb yb)\n                               (?y23 x y xa ya xb yb))\n                          (set_pmf x) (rcset (extract (run_nondet y)))", "apply assumption+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma cr_ndi_prob_sample [cr_prob_ndi_transfer]:\n  \"(cr_pmf_cset ===> ((=) ===> cr_prob_ndi A) ===> cr_prob_ndi A) bind_pmf altc_nondet\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cr_pmf_cset ===> ((=) ===> cr_prob_ndi A) ===> cr_prob_ndi A) (\\<bind>)\n     altc_nondet", "apply(clarsimp intro!: rel_funI simp add: cr_pmf_cset.simps cr_prob_ndi.simps cUnion.rep_eq cimage.rep_eq cset_pmf.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set A (\\<Union>M\\<in>set_pmf x. set_pmf (xa M))\n        (\\<Union>x\\<in>set_pmf x. rcset (extract (run_nondet (ya x))))", "apply(rule Union_transfer[THEN rel_funD])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (rel_set A) ((\\<lambda>M. set_pmf (xa M)) ` set_pmf x)\n        ((\\<lambda>x. rcset (extract (run_nondet (ya x)))) ` set_pmf x)", "apply(rule image_transfer[THEN rel_funD, THEN rel_funD])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       (?A19 x xa ya ===> rel_set A) (\\<lambda>M. set_pmf (xa M))\n        (\\<lambda>x. rcset (extract (run_nondet (ya x))))\n 2. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (?A19 x xa ya) (set_pmf x) (set_pmf x)", "apply(rule rel_funI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ya xb y.\n       \\<lbrakk>((=) ===> cr_prob_ndi A) xa ya; ?A19 x xa ya xb y\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya y))))\n 2. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (?A19 x xa ya) (set_pmf x) (set_pmf x)", "apply(drule (1) rel_funD)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ya xb y.\n       \\<lbrakk>?x24 x xa ya xb y = ?y24 x xa ya xb y;\n        cr_prob_ndi A (xa (?x24 x xa ya xb y))\n         (ya (?y24 x xa ya xb y))\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya y))))\n 2. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (\\<lambda>xb y. ?x24 x xa ya xb y = ?y24 x xa ya xb y)\n        (set_pmf x) (set_pmf x)", "apply(erule cr_prob_ndi.cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xa ya xb y.\n       \\<lbrakk>?x24 x xa ya xb y = ?y24 x xa ya xb y;\n        rel_set A (set_pmf (xa (?x24 x xa ya xb y)))\n         (rcset (extract (run_nondet (ya (?y24 x xa ya xb y)))))\\<rbrakk>\n       \\<Longrightarrow> rel_set A (set_pmf (xa xb))\n                          (rcset (extract (run_nondet (ya y))))\n 2. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (\\<lambda>xb y. ?x24 x xa ya xb y = ?y24 x xa ya xb y)\n        (set_pmf x) (set_pmf x)", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa ya.\n       ((=) ===> cr_prob_ndi A) xa ya \\<Longrightarrow>\n       rel_set (=) (set_pmf x) (set_pmf x)", "apply(simp add: rel_set_eq)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"], ["", "end"]]}