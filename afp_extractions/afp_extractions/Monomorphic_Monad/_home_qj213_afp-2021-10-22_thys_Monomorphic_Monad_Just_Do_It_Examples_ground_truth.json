{"file_name": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad/Just_Do_It_Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad", "problem_names": ["lemma repeat_1: \"repeat 1 mx = mx\"", "lemma repeat_add: \"repeat (n + m) mx = bind (repeat n mx) (\\<lambda>_. repeat m mx)\"", "lemma hanoi_correct: \"hanoi n = repeat (2 ^ n - 1) (tick (return ()))\"", "lemma work_alt_def: \"work xs = (if 0 \\<in> set xs then fail else return (prod_list xs))\"", "lemma fastprod_correct: \"fastprod xs = return (prod_list xs)\""], "translations": [["", "lemma repeat_1: \"repeat 1 mx = mx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat 1 mx = mx", "by(simp add: bind_return)"], ["", "lemma repeat_add: \"repeat (n + m) mx = bind (repeat n mx) (\\<lambda>_. repeat m mx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. repeat (n + m) mx = bind (repeat n mx) (\\<lambda>_. repeat m mx)", "by(induction n)(simp_all add: return_bind bind_assoc)"], ["", "lemma hanoi_correct: \"hanoi n = repeat (2 ^ n - 1) (tick (return ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hanoi n = repeat (2 ^ n - 1) (tick (return ()))", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. local.hanoi 0 = repeat (2 ^ 0 - 1) (tick (return ()))\n 2. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. local.hanoi 0 = repeat (2 ^ 0 - 1) (tick (return ()))\n 2. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hanoi 0 = repeat (2 ^ 0 - 1) (tick (return ()))", "by simp"], ["proof (state)\nthis:\n  local.hanoi 0 = repeat (2 ^ 0 - 1) (tick (return ()))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "case (Suc n)"], ["proof (state)\nthis:\n  local.hanoi n = repeat (2 ^ n - 1) (tick (return ()))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "have \"hanoi (Suc n) = repeat ((2 ^ n - 1) + 1 + (2 ^ n - 1)) (tick (return ()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.hanoi (Suc n) =\n    repeat (2 ^ n - 1 + 1 + (2 ^ n - 1)) (tick (return ()))", "by(simp only: hanoi.simps repeat_add repeat_1 Suc.IH bind_assoc bind_tick return_bind)"], ["proof (state)\nthis:\n  local.hanoi (Suc n) =\n  repeat (2 ^ n - 1 + 1 + (2 ^ n - 1)) (tick (return ()))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "also"], ["proof (state)\nthis:\n  local.hanoi (Suc n) =\n  repeat (2 ^ n - 1 + 1 + (2 ^ n - 1)) (tick (return ()))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "have \"(2 ^ n - 1) + 1 + (2 ^ n - 1) = (2 ^ Suc n - 1 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ n - 1 + 1 + (2 ^ n - 1) = 2 ^ Suc n - 1", "by simp"], ["proof (state)\nthis:\n  2 ^ n - 1 + 1 + (2 ^ n - 1) = 2 ^ Suc n - 1\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       local.hanoi n =\n       repeat (2 ^ n - 1) (tick (return ())) \\<Longrightarrow>\n       local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "finally"], ["proof (chain)\npicking this:\n  local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "show ?case"], ["proof (prove)\nusing this:\n  local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))\n\ngoal (1 subgoal):\n 1. local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))", "."], ["proof (state)\nthis:\n  local.hanoi (Suc n) = repeat (2 ^ Suc n - 1) (tick (return ()))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Fast product\\<close>"], ["", "locale fast_product_base = monad_catch_base return bind fail catch\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and catch :: \"'m catch\"\nbegin"], ["", "primrec work :: \"int list \\<Rightarrow> 'm\"\nwhere \n  \"work [] = return 1\"\n| \"work (x # xs) = (if x = 0 then fail else bind (work xs) (\\<lambda>i. return (x * i)))\""], ["", "definition fastprod :: \"int list \\<Rightarrow> 'm\"\n  where \"fastprod xs = catch (work xs) (return 0)\""], ["", "end"], ["", "locale fast_product = fast_product_base return bind fail catch + monad_catch return bind fail catch\n   for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and catch :: \"'m catch\"\nbegin"], ["", "lemma work_alt_def: \"work xs = (if 0 \\<in> set xs then fail else return (prod_list xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. work xs = (if 0 \\<in> set xs then fail else return (prod_list xs))", "by(induction xs)(simp_all add: fail_bind return_bind)"], ["", "lemma fastprod_correct: \"fastprod xs = return (prod_list xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fastprod xs = return (prod_list xs)", "by(simp add: fastprod_def work_alt_def catch_fail catch_return prod_list_zero_iff[symmetric])"], ["", "end"], ["", "end"]]}