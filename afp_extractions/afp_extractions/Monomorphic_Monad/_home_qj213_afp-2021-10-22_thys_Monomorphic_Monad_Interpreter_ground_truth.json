{"file_name": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad/Interpreter.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Monomorphic_Monad", "problem_names": ["lemma apply_eq_onp: includes lifting_syntax shows \"(eq_onp P ===> (=) ===> (=)) apply apply\"", "lemma rel_exp_simps [simp]:\n  \"rel_exp V (Var x) e' \\<longleftrightarrow> (\\<exists>y. e' = Var y \\<and> V x y)\"\n  \"rel_exp V (Const n) e' \\<longleftrightarrow> e' = Const n\"\n  \"rel_exp V (Plus e1 e2) e' \\<longleftrightarrow> (\\<exists>e1' e2'. e' = Plus e1' e2' \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V (Div e1 e2) e' \\<longleftrightarrow> (\\<exists>e1' e2'. e' = Div e1' e2' \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V e (Var y) \\<longleftrightarrow> (\\<exists>x. e = Var x \\<and> V x y)\"\n  \"rel_exp V e (Const n) \\<longleftrightarrow> e = Const n\"\n  \"rel_exp V e (Plus e1' e2') \\<longleftrightarrow> (\\<exists>e1 e2. e = Plus e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V e (Div e1' e2') \\<longleftrightarrow> (\\<exists>e1 e2. e = Div e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"", "lemma finite_vars [simp]: \"finite (vars e)\"", "lemma compositional: \"eval E (subst \\<sigma> e) = eval (eval E \\<circ> \\<sigma>) e\"", "lemma eval_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(((=) ===> M) ===> (M ===> ((=) ===> M) ===> M) ===> M ===> (V ===> M) ===> rel_exp V ===> M)\n   exp_base.eval exp_base.eval\"", "lemma eval_cong:\n  assumes \"\\<And>x. x \\<in> vars e \\<Longrightarrow> E x = E' x\"\n  shows \"eval E e = eval E' e\"", "lemma case_option_apply: \"case_option none some x y = case_option (none y) (\\<lambda>a. some a y) x\"", "lemma (in monad_base) bind_if2:\n  \"bind m (\\<lambda>x. if b then t x else e x) = (if b then bind m t else bind m e)\"", "lemma (in monad_base) bind_case_option2:\n  \"bind m (\\<lambda>x. case_option (none x) (some x) y) = case_option (bind m none) (\\<lambda>a. bind m (\\<lambda>x. some x a)) y\"", "lemma memo_cong [cong, fundef_cong]: \"\\<lbrakk> x = y; f y = g y \\<rbrakk> \\<Longrightarrow> memo f x = memo g y\"", "lemma memo_idem: \"memo (memo f) x = memo f x\"", "lemma memo_same:\n  \"bind (memo f x) (\\<lambda>a. bind (memo f x) (g a)) = bind (memo f x) (\\<lambda>a. g a a)\"", "lemma memo_commute:\n  assumes f_bind: \"\\<And>m x g. bind m (\\<lambda>a. bind (f x) (g a)) = bind (f x) (\\<lambda>b. bind m (\\<lambda>a. g a b))\"\n    and f_get: \"\\<And>x g. get (\\<lambda>s. bind (f x) (g s)) = bind (f x) (\\<lambda>a. get (\\<lambda>s. g s a))\"\n  shows \"bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) = bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))\"", "lemma lookup_alt_def: \"lookup x = get (\\<lambda>s. case apply s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\"", "lemmas [code] =\n  prob_exp_base.sample_var_def\n  prob_exp_base.lazy_def\n  prob_exp_base.eager_def", "lemma comp_fun_commute_sample_var: \"comp_fun_commute (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))\"", "lemma comp_fun_idem_sample_var: \"comp_fun_idem (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))\"", "lemma sample_vars_empty [simp]: \"sample_vars X {} m = m\"", "lemma sample_vars_insert: \n  \"finite A \\<Longrightarrow> sample_vars X (insert x A) m = bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X A m)\"", "lemma sample_vars_insert2: \n  \"finite A \\<Longrightarrow> sample_vars X (insert x A) m = sample_vars X A (bind (memo (sample_var X) x) (\\<lambda>_. m))\"", "lemma sample_vars_union:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> sample_vars X (A \\<union> B) m = sample_vars X A (sample_vars X B m)\"", "lemma memo_lookup:\n  \"bind (memo f x) (\\<lambda>i. bind (lookup x) (g i)) = bind (memo f x) (\\<lambda>i. g i i)\"", "lemma lazy_eq_eager:\n  assumes put_fail: \"\\<And>s. put s fail = fail\"\n  shows \"lazy X e = eager X e\"", "lemma lookup_alt_def:\n  \"lookup x = ask (\\<lambda>s. case apply s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\"", "lemma eval_reverse:\n  \"eval E (Var x) = E x\"\n  \"eval E (Const i) = return i\"\n  \"eval E (Plus e1 e2) = bind (eval E e2) (\\<lambda>j. bind (eval E e1) (\\<lambda>i. return (i + j)))\"\n  \"eval E (Div e1 e2) = bind (eval E e2) (\\<lambda>j. bind (eval E e1) (\\<lambda>i. if j = 0 then fail else return (i div j)))\"", "lemma cr_id_prob_eval:\n  notes [transfer_rule] = cr_id_prob_transfer shows\n  \"rel_stateT (=) (rel_optionT (cr_id_prob (=)))\n     (SFI.eval SFI_lookup e)\n     (SFP.eval SFP_lookup e)\"", "lemma cr_envT_stateT_lookup':\n  notes [transfer_rule] = cr_envT_stateT_transfer apply_eq_onp shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n   RFI_lookup SFI_lookup\"", "lemma cr_envT_stateT_eval':\n  notes [transfer_rule] = cr_envT_stateT_transfer cr_envT_stateT_lookup' shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n  (RFI.eval RFI_lookup) (SFI.eval SFI_lookup)\"", "lemma cr_envT_stateT_lookup [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_id_prob_transfer cr_envT_stateT_transfer apply_eq_onp shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n   RFI_lookup SFP_lookup\"", "lemma cr_envT_stateT_eval [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_id_prob_transfer cr_envT_stateT_transfer shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n  (RFI.eval RFI_lookup) (SFP.eval SFP_lookup)\"", "lemma prob_eval_lookup:\n  \"run_state (SFP.eval SFP_lookup e) E = \n   map_optionT (return_pmf \\<circ> map_option (\\<lambda>b. (b, E)) \\<circ> extract) (run_env (RFI.eval RFI_lookup e) E)\""], "translations": [["", "lemma apply_eq_onp: includes lifting_syntax shows \"(eq_onp P ===> (=) ===> (=)) apply apply\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq_onp P ===> (=) ===> (=)) apply apply", "by(simp add: rel_fun_def eq_onp_def)"], ["", "subsubsection \\<open>Basic interpreter\\<close>"], ["", "datatype (vars: 'v) exp = Var 'v | Const int | Plus \"'v exp\" \"'v exp\" | Div \"'v exp\" \"'v exp\""], ["", "lemma rel_exp_simps [simp]:\n  \"rel_exp V (Var x) e' \\<longleftrightarrow> (\\<exists>y. e' = Var y \\<and> V x y)\"\n  \"rel_exp V (Const n) e' \\<longleftrightarrow> e' = Const n\"\n  \"rel_exp V (Plus e1 e2) e' \\<longleftrightarrow> (\\<exists>e1' e2'. e' = Plus e1' e2' \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V (Div e1 e2) e' \\<longleftrightarrow> (\\<exists>e1' e2'. e' = Div e1' e2' \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V e (Var y) \\<longleftrightarrow> (\\<exists>x. e = Var x \\<and> V x y)\"\n  \"rel_exp V e (Const n) \\<longleftrightarrow> e = Const n\"\n  \"rel_exp V e (Plus e1' e2') \\<longleftrightarrow> (\\<exists>e1 e2. e = Plus e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\"\n  \"rel_exp V e (Div e1' e2') \\<longleftrightarrow> (\\<exists>e1 e2. e = Div e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((rel_exp V (Var x) e' = (\\<exists>y. e' = Var y \\<and> V x y) &&&\n      rel_exp V (Const n) e' = (e' = Const n)) &&&\n     rel_exp V (Plus e1 e2) e' =\n     (\\<exists>e1' e2'.\n         e' = Plus e1' e2' \\<and>\n         rel_exp V e1 e1' \\<and> rel_exp V e2 e2') &&&\n     rel_exp V (Div e1 e2) e' =\n     (\\<exists>e1' e2'.\n         e' = Div e1' e2' \\<and>\n         rel_exp V e1 e1' \\<and> rel_exp V e2 e2')) &&&\n    (rel_exp V e (Var y) = (\\<exists>x. e = Var x \\<and> V x y) &&&\n     rel_exp V e (Const n) = (e = Const n)) &&&\n    rel_exp V e (Plus e1' e2') =\n    (\\<exists>e1 e2.\n        e = Plus e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2') &&&\n    rel_exp V e (Div e1' e2') =\n    (\\<exists>e1 e2.\n        e = Div e1 e2 \\<and> rel_exp V e1 e1' \\<and> rel_exp V e2 e2')", "by(auto elim: exp.rel_cases)"], ["", "lemma finite_vars [simp]: \"finite (vars e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (vars e)", "by induction auto"], ["", "locale exp_base = monad_fail_base return bind fail\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\nbegin"], ["", "context fixes E :: \"'v \\<Rightarrow> 'm\" begin"], ["", "primrec eval :: \"'v exp \\<Rightarrow> 'm\"\nwhere\n  \"eval (Var x) = E x\"\n| \"eval (Const i) = return i\"\n| \"eval (Plus e1 e2) = bind (eval e1) (\\<lambda>i. bind (eval e2) (\\<lambda>j. return (i + j)))\"\n| \"eval (Div e1 e2) = bind (eval e1) (\\<lambda>i. bind (eval e2) (\\<lambda>j. if j = 0 then fail else return (i div j)))\""], ["", "end"], ["", "context fixes \\<sigma> :: \"'v \\<Rightarrow> 'w exp\" begin"], ["", "primrec subst :: \"'v exp \\<Rightarrow> 'w exp\"\nwhere\n  \"subst (Const n) = Const n\"\n| \"subst (Var x) = \\<sigma> x\"\n| \"subst (Plus e1 e2) = Plus (subst e1) (subst e2)\"\n| \"subst (Div e1 e2) = Div (subst e1) (subst e2)\""], ["", "end"], ["", "lemma compositional: \"eval E (subst \\<sigma> e) = eval (eval E \\<circ> \\<sigma>) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval E (subst \\<sigma> e) = eval (eval E \\<circ> \\<sigma>) e", "by induction simp_all"], ["", "end"], ["", "lemma eval_parametric [transfer_rule]:\n  includes lifting_syntax shows\n  \"(((=) ===> M) ===> (M ===> ((=) ===> M) ===> M) ===> M ===> (V ===> M) ===> rel_exp V ===> M)\n   exp_base.eval exp_base.eval\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> M) ===>\n     (M ===> ((=) ===> M) ===> M) ===>\n     M ===> (V ===> M) ===> rel_exp V ===> M)\n     exp_base.eval exp_base.eval", "unfolding exp_base.eval_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((=) ===> M) ===>\n     (M ===> ((=) ===> M) ===> M) ===>\n     M ===> (V ===> M) ===> rel_exp V ===> M)\n     (\\<lambda>return bind fail E.\n         rec_exp E return\n          (\\<lambda>e1 e2 e1a e2a.\n              bind e1a (\\<lambda>i. bind e2a (\\<lambda>j. return (i + j))))\n          (\\<lambda>e1 e2 e1a e2a.\n              bind e1a\n               (\\<lambda>i.\n                   bind e2a\n                    (\\<lambda>j.\n                        if j = 0 then fail else return (i div j)))))\n     (\\<lambda>return bind fail E.\n         rec_exp E return\n          (\\<lambda>e1 e2 e1a e2a.\n              bind e1a (\\<lambda>i. bind e2a (\\<lambda>j. return (i + j))))\n          (\\<lambda>e1 e2 e1a e2a.\n              bind e1a\n               (\\<lambda>i.\n                   bind e2a\n                    (\\<lambda>j.\n                        if j = 0 then fail else return (i div j)))))", "by transfer_prover"], ["", "declare exp_base.eval.simps [code]"], ["", "context exp_base begin"], ["", "lemma eval_cong:\n  assumes \"\\<And>x. x \\<in> vars e \\<Longrightarrow> E x = E' x\"\n  shows \"eval E e = eval E' e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "including lifting_syntax"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "define V where \"V \\<equiv> eq_onp (\\<lambda>x. x \\<in> vars e)\""], ["proof (state)\nthis:\n  V \\<equiv> eq_onp (\\<lambda>x. x \\<in> vars e)\n\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "have [transfer_rule]: \"rel_exp V e e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_exp V e e", "by(rule exp.rel_refl_strong)(simp add: V_def eq_onp_def)"], ["proof (state)\nthis:\n  rel_exp V e e\n\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "have [transfer_rule]: \"(V ===> (=)) E E'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V ===> (=)) E E'", "using assms"], ["proof (prove)\nusing this:\n  ?x2 \\<in> vars e \\<Longrightarrow> E ?x2 = E' ?x2\n\ngoal (1 subgoal):\n 1. (V ===> (=)) E E'", "by(auto simp add: V_def rel_fun_def eq_onp_def)"], ["proof (state)\nthis:\n  (V ===> (=)) E E'\n\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval E e = eval E' e", "by transfer_prover"], ["proof (state)\nthis:\n  eval E e = eval E' e\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Memoisation\\<close>"], ["", "lemma case_option_apply: \"case_option none some x y = case_option (none y) (\\<lambda>a. some a y) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case x of None \\<Rightarrow> none | Some x \\<Rightarrow> some x) y =\n    (case x of None \\<Rightarrow> none y | Some a \\<Rightarrow> some a y)", "by(simp split: option.split)"], ["", "lemma (in monad_base) bind_if2:\n  \"bind m (\\<lambda>x. if b then t x else e x) = (if b then bind m t else bind m e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m (\\<lambda>x. if b then t x else e x) =\n    (if b then bind m t else bind m e)", "by simp"], ["", "lemma (in monad_base) bind_case_option2:\n  \"bind m (\\<lambda>x. case_option (none x) (some x) y) = case_option (bind m none) (\\<lambda>a. bind m (\\<lambda>x. some x a)) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind m\n     (\\<lambda>x.\n         case y of None \\<Rightarrow> none x\n         | Some xa \\<Rightarrow> some x xa) =\n    (case y of None \\<Rightarrow> bind m none\n     | Some a \\<Rightarrow> bind m (\\<lambda>x. some x a))", "by(simp split: option.split)"], ["", "locale memoization_base = monad_state_base return bind get put\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('k \\<rightharpoonup> 'a, 'm) get\"\n  and put :: \"('k \\<rightharpoonup> 'a, 'm) put\"\nbegin"], ["", "definition memo :: \"('k \\<Rightarrow> 'm) \\<Rightarrow> 'k \\<Rightarrow> 'm\"\nwhere\n  \"memo f x = \n   get (\\<lambda>table. \n   case table x of Some y \\<Rightarrow> return y \n   | None \\<Rightarrow> bind (f x) (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (return y)))\""], ["", "lemma memo_cong [cong, fundef_cong]: \"\\<lbrakk> x = y; f y = g y \\<rbrakk> \\<Longrightarrow> memo f x = memo g y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = y; f y = g y\\<rbrakk> \\<Longrightarrow> memo f x = memo g y", "by(simp add: memo_def cong del: option.case_cong_weak)"], ["", "end"], ["", "declare memoization_base.memo_def [code]"], ["", "locale memoization = memoization_base return bind get put + monad_state return bind get put\n  for return :: \"('a, 'm) return\"\n  and bind :: \"('a, 'm) bind\"\n  and get :: \"('k \\<rightharpoonup> 'a, 'm) get\"\n  and put :: \"('k \\<rightharpoonup> 'a, 'm) put\"\nbegin"], ["", "lemma memo_idem: \"memo (memo f) x = memo f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "have \"memo (memo f) x = get \n    (\\<lambda>table. case table x of \n       None \\<Rightarrow> get (\\<lambda>table'. bind (case table' x of None \\<Rightarrow> bind (f x) (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (return y))\n                                                | Some x \\<Rightarrow> return x)\n                             (\\<lambda>y. update (\\<lambda>m. m ++ [x \\<mapsto> y]) (return y)))\n      | Some y \\<Rightarrow> get (\\<lambda>_. return y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memo (memo f) x =\n    get (\\<lambda>table.\n            case table x of\n            None \\<Rightarrow>\n              get (\\<lambda>table'.\n                      bind\n                       (case table' x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>y.\n                               update (\\<lambda>m. m(x \\<mapsto> y))\n                                (return y))\n                        | Some x \\<Rightarrow> return x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m ++ [x \\<mapsto> y])\n                            (return y)))\n            | Some y \\<Rightarrow> get (\\<lambda>_. return y))", "by(simp add: memo_def get_const bind_get cong del: option.case_cong_weak)"], ["proof (state)\nthis:\n  memo (memo f) x =\n  get (\\<lambda>table.\n          case table x of\n          None \\<Rightarrow>\n            get (\\<lambda>table'.\n                    bind\n                     (case table' x of\n                      None \\<Rightarrow>\n                        bind (f x)\n                         (\\<lambda>y.\n                             update (\\<lambda>m. m(x \\<mapsto> y))\n                              (return y))\n                      | Some x \\<Rightarrow> return x)\n                     (\\<lambda>y.\n                         update (\\<lambda>m. m ++ [x \\<mapsto> y])\n                          (return y)))\n          | Some y \\<Rightarrow> get (\\<lambda>_. return y))\n\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "also"], ["proof (state)\nthis:\n  memo (memo f) x =\n  get (\\<lambda>table.\n          case table x of\n          None \\<Rightarrow>\n            get (\\<lambda>table'.\n                    bind\n                     (case table' x of\n                      None \\<Rightarrow>\n                        bind (f x)\n                         (\\<lambda>y.\n                             update (\\<lambda>m. m(x \\<mapsto> y))\n                              (return y))\n                      | Some x \\<Rightarrow> return x)\n                     (\\<lambda>y.\n                         update (\\<lambda>m. m ++ [x \\<mapsto> y])\n                          (return y)))\n          | Some y \\<Rightarrow> get (\\<lambda>_. return y))\n\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "have \"\\<dots> = memo f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>table.\n            case table x of\n            None \\<Rightarrow>\n              get (\\<lambda>table'.\n                      bind\n                       (case table' x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>y.\n                               update (\\<lambda>m. m(x \\<mapsto> y))\n                                (return y))\n                        | Some x \\<Rightarrow> return x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m ++ [x \\<mapsto> y])\n                            (return y)))\n            | Some y \\<Rightarrow> get (\\<lambda>_. return y)) =\n    memo f x", "by(simp add: option.case_distrib[where h=\"get\", symmetric] get_get case_option_apply bind_assoc update_update bind_update return_bind o_def memo_def cong: option.case_cong)"], ["proof (state)\nthis:\n  get (\\<lambda>table.\n          case table x of\n          None \\<Rightarrow>\n            get (\\<lambda>table'.\n                    bind\n                     (case table' x of\n                      None \\<Rightarrow>\n                        bind (f x)\n                         (\\<lambda>y.\n                             update (\\<lambda>m. m(x \\<mapsto> y))\n                              (return y))\n                      | Some x \\<Rightarrow> return x)\n                     (\\<lambda>y.\n                         update (\\<lambda>m. m ++ [x \\<mapsto> y])\n                          (return y)))\n          | Some y \\<Rightarrow> get (\\<lambda>_. return y)) =\n  memo f x\n\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "finally"], ["proof (chain)\npicking this:\n  memo (memo f) x = memo f x", "show ?thesis"], ["proof (prove)\nusing this:\n  memo (memo f) x = memo f x\n\ngoal (1 subgoal):\n 1. memo (memo f) x = memo f x", "."], ["proof (state)\nthis:\n  memo (memo f) x = memo f x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma memo_same:\n  \"bind (memo f x) (\\<lambda>a. bind (memo f x) (g a)) = bind (memo f x) (\\<lambda>a. g a a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f x) (g a)) =\n    bind (memo f x) (\\<lambda>a. g a a)", "apply(simp cong: option.case_cong add: memo_def bind_get option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc bind_update return_bind update_get o_def get_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some xa \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>y.\n                               update (\\<lambda>m. m(x \\<mapsto> y))\n                                (g xa y))\n                        | Some x2 \\<Rightarrow> g xa x2)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(subst (3) get_const[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              get (\\<lambda>_.\n                      bind (f x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m(x \\<mapsto> y)) (g y y)))\n            | Some xa \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>y.\n                               update (\\<lambda>m. m(x \\<mapsto> y))\n                                (g xa y))\n                        | Some x \\<Rightarrow> g xa x)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(subst option.case_distrib[where h=get, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            get (case s x of\n                 None \\<Rightarrow>\n                   \\<lambda>_.\n                      bind (f x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n                 | Some xa \\<Rightarrow>\n                     \\<lambda>s.\n                        case s x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>y.\n                               update (\\<lambda>m. m(x \\<mapsto> y))\n                                (g xa y))\n                        | Some x \\<Rightarrow> g xa x)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(subst get_get)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            (case s x of\n             None \\<Rightarrow>\n               \\<lambda>_.\n                  bind (f x)\n                   (\\<lambda>y.\n                       update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n             | Some xa \\<Rightarrow>\n                 \\<lambda>s.\n                    case s x of\n                    None \\<Rightarrow>\n                      bind (f x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m(x \\<mapsto> y)) (g xa y))\n                    | Some x \\<Rightarrow> g xa x)\n             s) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(simp add: case_option_apply cong: option.case_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma memo_commute:\n  assumes f_bind: \"\\<And>m x g. bind m (\\<lambda>a. bind (f x) (g a)) = bind (f x) (\\<lambda>b. bind m (\\<lambda>a. g a b))\"\n    and f_get: \"\\<And>x g. get (\\<lambda>s. bind (f x) (g s)) = bind (f x) (\\<lambda>a. get (\\<lambda>s. g s a))\"\n  shows \"bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) = bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n    bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n    bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))", "note option.case_cong[cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?option = ?option';\n   ?option' = None \\<Longrightarrow> ?f1.0 = ?g1.0;\n   \\<And>x2.\n      ?option' = Some x2 \\<Longrightarrow> ?f2.0 x2 = ?g2.0 x2\\<rbrakk>\n  \\<Longrightarrow> (case ?option of None \\<Rightarrow> ?f1.0\n                     | Some x2 \\<Rightarrow> ?f2.0 x2) =\n                    (case ?option' of None \\<Rightarrow> ?g1.0\n                     | Some x2 \\<Rightarrow> ?g2.0 x2)\n\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n    bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))", "have update_f: \"update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))\" for F x g"], ["proof (prove)\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "fix UU"], ["proof (state)\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "have \"update F (bind (f x) g) = bind (update F (return UU)) (\\<lambda>_. bind (f x) g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. update F (bind (f x) g) =\n    bind (update F (return UU)) (\\<lambda>_. bind (f x) g)", "by(simp add: bind_update return_bind)"], ["proof (state)\nthis:\n  update F (bind (f x) g) =\n  bind (update F (return UU)) (\\<lambda>_. bind (f x) g)\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "also"], ["proof (state)\nthis:\n  update F (bind (f x) g) =\n  bind (update F (return UU)) (\\<lambda>_. bind (f x) g)\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "have \"\\<dots> = bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (update F (return UU)) (\\<lambda>_. bind (f x) g) =\n    bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a))", "by(rule f_bind)"], ["proof (state)\nthis:\n  bind (update F (return UU)) (\\<lambda>_. bind (f x) g) =\n  bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a))\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "also"], ["proof (state)\nthis:\n  bind (update F (return UU)) (\\<lambda>_. bind (f x) g) =\n  bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a))\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "have \"\\<dots> = bind (f x) (\\<lambda>a. update F (g a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a)) =\n    bind (f x) (\\<lambda>a. update F (g a))", "by(simp add: bind_update return_bind)"], ["proof (state)\nthis:\n  bind (f x) (\\<lambda>a. bind (update F (return UU)) (\\<lambda>_. g a)) =\n  bind (f x) (\\<lambda>a. update F (g a))\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "finally"], ["proof (chain)\npicking this:\n  update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "show ?thesis"], ["proof (prove)\nusing this:\n  update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))\n\ngoal (1 subgoal):\n 1. update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))", "."], ["proof (state)\nthis:\n  update F (bind (f x) g) = bind (f x) (\\<lambda>a. update F (g a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  update ?F (bind (f ?x) ?g) = bind (f ?x) (\\<lambda>a. update ?F (?g a))\n\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n    bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n    bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))", "apply(clarsimp simp add: memo_def bind_get option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc bind_update return_bind update_get o_def f_get[symmetric] option.case_distrib[where h=\"get\", symmetric] get_get case_option_apply if_distrib[where f=\"case_option _ _\"] if_distrib[where f=\"update _\"] option.case_distrib[where h=\"update _\"] update_f update_update cong: if_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>ya.\n                   if y = x\n                   then update (\\<lambda>m. m(x \\<mapsto> ya)) (g ya ya)\n                   else case s y of\n                        None \\<Rightarrow>\n                          bind (f y)\n                           (\\<lambda>a.\n                               update\n                                (\\<lambda>xa. xa(x \\<mapsto> ya, y \\<mapsto>\n                                    a))\n                                (g ya a))\n                        | Some xa \\<Rightarrow>\n                            update (\\<lambda>m. m(x \\<mapsto> ya))\n                             (g ya xa))\n            | Some a \\<Rightarrow>\n                case s y of\n                None \\<Rightarrow>\n                  bind (f y)\n                   (\\<lambda>ya.\n                       update (\\<lambda>m. m(y \\<mapsto> ya)) (g a ya))\n                | Some x2 \\<Rightarrow> g a x2) =\n    get (\\<lambda>s.\n            case s y of\n            None \\<Rightarrow>\n              bind (f y)\n               (\\<lambda>ya.\n                   if x = y\n                   then update (\\<lambda>m. m(y \\<mapsto> ya)) (g ya ya)\n                   else case s x of\n                        None \\<Rightarrow>\n                          bind (f x)\n                           (\\<lambda>a.\n                               update\n                                (\\<lambda>xa. xa(y \\<mapsto> ya, x \\<mapsto>\n                                    a))\n                                (g a ya))\n                        | Some x \\<Rightarrow>\n                            update (\\<lambda>m. m(y \\<mapsto> ya)) (g x ya))\n            | Some a \\<Rightarrow>\n                case s x of\n                None \\<Rightarrow>\n                  bind (f x)\n                   (\\<lambda>y.\n                       update (\\<lambda>m. m(x \\<mapsto> y)) (g y a))\n                | Some x \\<Rightarrow> g x a)", "apply(clarsimp intro!: arg_cong[where f=\"get\"] ext split!: option.split simp add: bind_if2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s y = None; x \\<noteq> y; s x = None\\<rbrakk>\n       \\<Longrightarrow> bind (f x)\n                          (\\<lambda>ya.\n                              bind (f y)\n                               (\\<lambda>a.\n                                   update\n                                    (\\<lambda>xa. xa(x \\<mapsto> ya, y \n  \\<mapsto> a))\n                                    (g ya a))) =\n                         bind (f y)\n                          (\\<lambda>ya.\n                              bind (f x)\n                               (\\<lambda>a.\n                                   update\n                                    (\\<lambda>xa. xa(y \\<mapsto> ya, x \n  \\<mapsto> a))\n                                    (g a ya)))", "apply(subst f_bind)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>s y = None; x \\<noteq> y; s x = None\\<rbrakk>\n       \\<Longrightarrow> bind (f y)\n                          (\\<lambda>b.\n                              bind (f x)\n                               (\\<lambda>a.\n                                   update\n                                    (\\<lambda>xa. xa(x \\<mapsto> a, y \n  \\<mapsto> b))\n                                    (g a b))) =\n                         bind (f y)\n                          (\\<lambda>ya.\n                              bind (f x)\n                               (\\<lambda>a.\n                                   update\n                                    (\\<lambda>xa. xa(y \\<mapsto> ya, x \n  \\<mapsto> a))\n                                    (g a ya)))", "apply(simp add: fun_upd_twist)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  bind (memo f x) (\\<lambda>a. bind (memo f y) (g a)) =\n  bind (memo f y) (\\<lambda>b. bind (memo f x) (\\<lambda>a. g a b))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open>Probabilistic interpreter\\<close>"], ["", "locale memo_exp_base =\n  exp_base return bind fail +\n  memoization_base return bind get put\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\nbegin"], ["", "definition lookup :: \"'v \\<Rightarrow> 'm\"\nwhere \"lookup x = get (\\<lambda>s. case s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\""], ["", "lemma lookup_alt_def: \"lookup x = get (\\<lambda>s. case apply s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup x =\n    get (\\<lambda>s.\n            case apply s x of None \\<Rightarrow> fail\n            | Some y \\<Rightarrow> return y)", "by(simp add: apply_def lookup_def)"], ["", "end"], ["", "locale prob_exp_base =\n  memo_exp_base return bind fail get put +\n  monad_prob_base return bind sample\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and sample :: \"(int, 'm) sample\"\nbegin"], ["", "definition sample_var :: \"('v \\<Rightarrow> int pmf) \\<Rightarrow> 'v \\<Rightarrow> 'm\"\nwhere \"sample_var X x = sample (X x) return\""], ["", "definition lazy :: \"('v \\<Rightarrow> int pmf) \\<Rightarrow> 'v exp \\<Rightarrow> 'm\"\nwhere \"lazy X \\<equiv> eval (memo (sample_var X))\""], ["", "definition sample_vars :: \"('v \\<Rightarrow> int pmf) \\<Rightarrow> 'v set \\<Rightarrow> 'm \\<Rightarrow> 'm\"\nwhere \"sample_vars X A m = Finite_Set.fold (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) m A\""], ["", "definition eager :: \"('v \\<Rightarrow> int pmf) \\<Rightarrow> 'v exp \\<Rightarrow> 'm\" where\n  \"eager p e = sample_vars p (vars e) (eval lookup e)\""], ["", "end"], ["", "lemmas [code] =\n  prob_exp_base.sample_var_def\n  prob_exp_base.lazy_def\n  prob_exp_base.eager_def"], ["", "locale prob_exp = prob_exp_base return bind fail get put sample + \n  memoization return bind get put +\n  monad_state_prob return bind get put sample +\n  monad_fail return bind fail\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and sample :: \"(int, 'm) sample\"\nbegin"], ["", "lemma comp_fun_commute_sample_var: \"comp_fun_commute (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))", "by unfold_locales(auto intro!: memo_commute simp add: fun_eq_iff sample_var_def bind_sample1 bind_sample2 return_bind sample_get)"], ["", "interpretation sample_var: comp_fun_commute \"\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)\"\n  rewrites \"\\<And>X m A. Finite_Set.fold (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) m A \\<equiv> sample_vars X A m\"\n  for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_commute\n     (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) &&&\n    (\\<And>X m A.\n        Finite_Set.fold\n         (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) m\n         A \\<equiv>\n        sample_vars X A m)", "by(rule comp_fun_commute_sample_var)(simp add: sample_vars_def)"], ["", "lemma comp_fun_idem_sample_var: \"comp_fun_idem (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem\n     (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m))", "by unfold_locales(simp add: fun_eq_iff memo_same)"], ["", "interpretation sample_var: comp_fun_idem \"\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)\"\n  rewrites \"\\<And>X m A. Finite_Set.fold (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) m A \\<equiv> sample_vars X A m\"\n  for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. comp_fun_idem\n     (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) &&&\n    (\\<And>X m A.\n        Finite_Set.fold\n         (\\<lambda>x m. bind (memo (sample_var X) x) (\\<lambda>_. m)) m\n         A \\<equiv>\n        sample_vars X A m)", "by(rule comp_fun_idem_sample_var)(simp add: sample_vars_def)"], ["", "lemma sample_vars_empty [simp]: \"sample_vars X {} m = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X {} m = m", "by(simp add: sample_vars_def)"], ["", "lemma sample_vars_insert: \n  \"finite A \\<Longrightarrow> sample_vars X (insert x A) m = bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X A m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sample_vars X (insert x A) m =\n    bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X A m)", "by(fact sample_var.fold_insert_idem)"], ["", "lemma sample_vars_insert2: \n  \"finite A \\<Longrightarrow> sample_vars X (insert x A) m = sample_vars X A (bind (memo (sample_var X) x) (\\<lambda>_. m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite A \\<Longrightarrow>\n    sample_vars X (insert x A) m =\n    sample_vars X A (bind (memo (sample_var X) x) (\\<lambda>_. m))", "by(fact sample_var.fold_insert_idem2)"], ["", "lemma sample_vars_union:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> sample_vars X (A \\<union> B) m = sample_vars X A (sample_vars X B m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> sample_vars X (A \\<union> B) m =\n                      sample_vars X A (sample_vars X B m)", "by(subst Un_commute)(rule sample_var.fold_set_union)"], ["", "lemma memo_lookup:\n  \"bind (memo f x) (\\<lambda>i. bind (lookup x) (g i)) = bind (memo f x) (\\<lambda>i. g i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo f x) (\\<lambda>i. bind (lookup x) (g i)) =\n    bind (memo f x) (\\<lambda>i. g i i)", "apply(simp cong del: option.case_cong_weak add: lookup_def memo_def bind_get option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc bind_update return_bind update_get o_def get_const)"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some xa \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s x of None \\<Rightarrow> bind fail (g xa)\n                        | Some x \\<Rightarrow> g xa x)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(subst (3) get_const[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              get (\\<lambda>_.\n                      bind (f x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m(x \\<mapsto> y)) (g y y)))\n            | Some xa \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s x of None \\<Rightarrow> bind fail (g xa)\n                        | Some x \\<Rightarrow> g xa x)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(subst option.case_distrib[where h=get, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. get (\\<lambda>s.\n            get (case s x of\n                 None \\<Rightarrow>\n                   \\<lambda>_.\n                      bind (f x)\n                       (\\<lambda>y.\n                           update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n                 | Some xa \\<Rightarrow>\n                     \\<lambda>s.\n                        case s x of None \\<Rightarrow> bind fail (g xa)\n                        | Some x \\<Rightarrow> g xa x)) =\n    get (\\<lambda>s.\n            case s x of\n            None \\<Rightarrow>\n              bind (f x)\n               (\\<lambda>y. update (\\<lambda>m. m(x \\<mapsto> y)) (g y y))\n            | Some x \\<Rightarrow> g x x)", "apply(simp add: get_get case_option_apply cong: option.case_cong)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma lazy_eq_eager:\n  assumes put_fail: \"\\<And>s. put s fail = fail\"\n  shows \"lazy X e = eager X e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "note option.case_cong [cong]"], ["proof (state)\nthis:\n  \\<lbrakk>?option = ?option';\n   ?option' = None \\<Longrightarrow> ?f1.0 = ?g1.0;\n   \\<And>x2.\n      ?option' = Some x2 \\<Longrightarrow> ?f2.0 x2 = ?g2.0 x2\\<rbrakk>\n  \\<Longrightarrow> (case ?option of None \\<Rightarrow> ?f1.0\n                     | Some x2 \\<Rightarrow> ?f2.0 x2) =\n                    (case ?option' of None \\<Rightarrow> ?g1.0\n                     | Some x2 \\<Rightarrow> ?g2.0 x2)\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_var_get: \"bind (sample_var X x) (\\<lambda>i. get (f i)) = get (\\<lambda>s. bind (sample_var X x) (\\<lambda>i. f i s))\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (sample_var X x) (\\<lambda>i. get (f i)) =\n    get (\\<lambda>s. bind (sample_var X x) (\\<lambda>i. f i s))", "by(simp add: sample_var_def bind_sample1 return_bind sample_get)"], ["proof (state)\nthis:\n  bind (sample_var X ?x2) (\\<lambda>i. get (?f2 i)) =\n  get (\\<lambda>s. bind (sample_var X ?x2) (\\<lambda>i. ?f2 i s))\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have update_fail [simp]: \"update f fail = fail\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. update f fail = fail", "by(simp add: update_def put_fail get_const)"], ["proof (state)\nthis:\n  update ?f2 fail = fail\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_vars_fail: \"sample_vars X A fail = fail\" if \"finite A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X A fail = fail", "using that"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. sample_vars X A fail = fail", "by induction(simp_all add: memo_def bind_get option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc bind_update return_bind sample_var_def bind_sample1 sample_const case_option_collapse get_const cong del: option.case_cong_weak)"], ["proof (state)\nthis:\n  finite ?A2 \\<Longrightarrow> sample_vars X ?A2 fail = fail\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_var_const: \"bind (sample_var X x) (\\<lambda>_. m) = m\" for x m"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (sample_var X x) (\\<lambda>_. m) = m", "by(simp add: sample_var_def bind_sample1 return_bind sample_const)"], ["proof (state)\nthis:\n  bind (sample_var X ?x2) (\\<lambda>_. ?m2) = ?m2\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_var_lookup_same: \"bind (memo (sample_var X) x) (\\<lambda>i. bind (lookup x) (f i)) = bind (memo (sample_var X) x) (\\<lambda>i. f i i)\" for x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. bind (lookup x) (f i)) =\n    bind (memo (sample_var X) x) (\\<lambda>i. f i i)", "by(simp add: lookup_def bind_get memo_def option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc bind_update return_bind update_get sample_var_get option.case_distrib[where h=get, symmetric] get_get case_option_apply)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) ?x2) (\\<lambda>i. bind (lookup ?x2) (?f2 i)) =\n  bind (memo (sample_var X) ?x2) (\\<lambda>i. ?f2 i i)\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_var_lookup_other: \"bind (memo (sample_var X) y) (\\<lambda>i. bind (lookup x) (f i)) = bind (lookup x) (\\<lambda>j. bind (memo (sample_var X) y) (\\<lambda>i. f i j))\"\n    if \"x \\<noteq> y\" for x y f"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) y) (\\<lambda>i. bind (lookup x) (f i)) =\n    bind (lookup x)\n     (\\<lambda>j. bind (memo (sample_var X) y) (\\<lambda>i. f i j))", "using that"], ["proof (prove)\nusing this:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) y) (\\<lambda>i. bind (lookup x) (f i)) =\n    bind (lookup x)\n     (\\<lambda>j. bind (memo (sample_var X) y) (\\<lambda>i. f i j))", "apply(simp add: lookup_def memo_def bind_get option.case_distrib[where h=\"\\<lambda>x. bind x _\"] bind_assoc return_bind bind_update update_get sample_var_get fail_bind option.case_distrib[where h=get, symmetric] get_get case_option_apply)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    get (\\<lambda>s.\n            case s y of\n            None \\<Rightarrow>\n              bind (sample_var X y)\n               (\\<lambda>ya.\n                   update (\\<lambda>m. m(y \\<mapsto> ya))\n                    (case s x of None \\<Rightarrow> fail\n                     | Some x2 \\<Rightarrow> f ya x2))\n            | Some a \\<Rightarrow>\n                case s x of None \\<Rightarrow> fail\n                | Some x2 \\<Rightarrow> f a x2) =\n    get (\\<lambda>s.\n            case s x of None \\<Rightarrow> fail\n            | Some x \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s y of\n                        None \\<Rightarrow>\n                          bind (sample_var X y)\n                           (\\<lambda>ya.\n                               update (\\<lambda>m. m(y \\<mapsto> ya))\n                                (f ya x))\n                        | Some xa \\<Rightarrow> f xa x))", "apply(subst (13) get_const[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow>\n    get (\\<lambda>s.\n            case s y of\n            None \\<Rightarrow>\n              bind (sample_var X y)\n               (\\<lambda>ya.\n                   update (\\<lambda>m. m(y \\<mapsto> ya))\n                    (case s x of None \\<Rightarrow> fail\n                     | Some x \\<Rightarrow> f ya x))\n            | Some a \\<Rightarrow>\n                case s x of None \\<Rightarrow> fail\n                | Some x \\<Rightarrow> f a x) =\n    get (\\<lambda>s.\n            case s x of None \\<Rightarrow> get (\\<lambda>_. fail)\n            | Some x \\<Rightarrow>\n                get (\\<lambda>s.\n                        case s y of\n                        None \\<Rightarrow>\n                          bind (sample_var X y)\n                           (\\<lambda>ya.\n                               update (\\<lambda>m. m(y \\<mapsto> ya))\n                                (f ya x))\n                        | Some xa \\<Rightarrow> f xa x))", "apply(clarsimp simp add: option.case_distrib[where h=get, symmetric] get_get case_option_apply fun_eq_iff sample_var_const intro!: arg_cong[where f=get] split: option.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?x2 \\<noteq> ?y2 \\<Longrightarrow>\n  bind (memo (sample_var X) ?y2) (\\<lambda>i. bind (lookup ?x2) (?f2 i)) =\n  bind (lookup ?x2)\n   (\\<lambda>j. bind (memo (sample_var X) ?y2) (\\<lambda>i. ?f2 i j))\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have sample_vars_lookup: \"sample_vars X V (bind (lookup x) f) = bind (lookup x) (\\<lambda>i. sample_vars X V (f i))\" \n    if \"finite V\" \"x \\<notin> V\" for V x f"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X V (bind (lookup x) f) =\n    bind (lookup x) (\\<lambda>i. sample_vars X V (f i))", "using that"], ["proof (prove)\nusing this:\n  finite V\n  x \\<notin> V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (lookup x) f) =\n    bind (lookup x) (\\<lambda>i. sample_vars X V (f i))", "by(induction)(auto simp add: sample_var_lookup_other bind_return)"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?V2; ?x2 \\<notin> ?V2\\<rbrakk>\n  \\<Longrightarrow> sample_vars X ?V2 (bind (lookup ?x2) ?f2) =\n                    bind (lookup ?x2)\n                     (\\<lambda>i. sample_vars X ?V2 (?f2 i))\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have lazy_sample_vars: \"sample_vars X V (bind (lazy X e) f) = bind (lazy X e) (\\<lambda>i. sample_vars X V (f i))\"\n    if \"finite V\" for f e V"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X V (bind (lazy X e) f) =\n    bind (lazy X e) (\\<lambda>i. sample_vars X V (f i))", "using that"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (lazy X e) f) =\n    bind (lazy X e) (\\<lambda>i. sample_vars X V (f i))", "unfolding lazy_def"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval (memo (sample_var X)) e) f) =\n    bind (eval (memo (sample_var X)) e) (\\<lambda>i. sample_vars X V (f i))", "proof(induction e arbitrary: f)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "case (Var x)"], ["proof (state)\nthis:\n  finite V\n\ngoal (4 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "have \"bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) = sample_vars X V (bind (memo (sample_var X) x) f)\" (is \"?lhs V = ?rhs V\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "using Var"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "proof(cases \"x \\<in> V\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V; x \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V; x \\<notin> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "fix V"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "assume False: \"x \\<notin> V\" and fin: \"finite V\""], ["proof (state)\nthis:\n  x \\<notin> V\n  finite V\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "have \"?lhs V = bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i)))", "by(simp add: sample_var_lookup_same)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i)))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "have \"\\<dots> = bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X V (bind (lookup x) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i))) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X V (bind (lookup x) f))", "using fin False"], ["proof (prove)\nusing this:\n  finite V\n  x \\<notin> V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i))) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X V (bind (lookup x) f))", "by(simp add: sample_vars_lookup)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X V (bind (lookup x) f))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. bind (lookup x) (\\<lambda>i. sample_vars X V (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X V (bind (lookup x) f))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "have \"\\<dots> = sample_vars X (insert x V) (bind (lookup x) f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X V (bind (lookup x) f)) =\n    sample_vars X (insert x V) (bind (lookup x) f)", "using fin"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X V (bind (lookup x) f)) =\n    sample_vars X (insert x V) (bind (lookup x) f)", "by(simp add: sample_vars_insert)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X V (bind (lookup x) f)) =\n  sample_vars X (insert x V) (bind (lookup x) f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X V (bind (lookup x) f)) =\n  sample_vars X (insert x V) (bind (lookup x) f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "have \"\\<dots> = sample_vars X V (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (insert x V) (bind (lookup x) f) =\n    sample_vars X V\n     (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f))", "using fin"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X (insert x V) (bind (lookup x) f) =\n    sample_vars X V\n     (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f))", "by(simp only: sample_vars_insert2)"], ["proof (state)\nthis:\n  sample_vars X (insert x V) (bind (lookup x) f) =\n  sample_vars X V\n   (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  sample_vars X (insert x V) (bind (lookup x) f) =\n  sample_vars X V\n   (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "have \"\\<dots> = ?rhs V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X V\n     (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "by(simp add: sample_var_lookup_same)"], ["proof (state)\nthis:\n  sample_vars X V\n   (bind (memo (sample_var X) x) (\\<lambda>_. bind (lookup x) f)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)\n 2. \\<lbrakk>finite V__; x \\<notin> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "finally"], ["proof (chain)\npicking this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)", "show \"?lhs V = ?rhs V\""], ["proof (prove)\nusing this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "."], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V__; x \\<in> V__\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V__ (f i)) =\n                      sample_vars X V__ (bind (memo (sample_var X) x) f)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> ?Va4; finite ?Va4\\<rbrakk>\n  \\<Longrightarrow> bind (memo (sample_var X) x)\n                     (\\<lambda>i. sample_vars X ?Va4 (f i)) =\n                    sample_vars X ?Va4 (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "note False = this"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<notin> ?Va4; finite ?Va4\\<rbrakk>\n  \\<Longrightarrow> bind (memo (sample_var X) x)\n                     (\\<lambda>i. sample_vars X ?Va4 (f i)) =\n                    sample_vars X ?Va4 (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "case True"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "hence V: \"V = insert x (V - {x})\""], ["proof (prove)\nusing this:\n  x \\<in> V\n\ngoal (1 subgoal):\n 1. V = insert x (V - {x})", "by auto"], ["proof (state)\nthis:\n  V = insert x (V - {x})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "have \"?lhs V = bind (memo (sample_var X) x) (\\<lambda>i. bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X (V - {x}) (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>i.\n         bind (memo (sample_var X) x)\n          (\\<lambda>_. sample_vars X (V - {x}) (f i)))", "using Var"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>i.\n         bind (memo (sample_var X) x)\n          (\\<lambda>_. sample_vars X (V - {x}) (f i)))", "by(subst V)(simp add: sample_vars_insert del: Diff_insert0 insert_Diff_single)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>i.\n       bind (memo (sample_var X) x)\n        (\\<lambda>_. sample_vars X (V - {x}) (f i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>i.\n       bind (memo (sample_var X) x)\n        (\\<lambda>_. sample_vars X (V - {x}) (f i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "have \"\\<dots> = bind (memo (sample_var X) x) (\\<lambda>_. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X (V - {x}) (f i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>i.\n         bind (memo (sample_var X) x)\n          (\\<lambda>_. sample_vars X (V - {x}) (f i))) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_.\n         bind (memo (sample_var X) x)\n          (\\<lambda>i. sample_vars X (V - {x}) (f i)))", "by(simp add: memo_same)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>i.\n       bind (memo (sample_var X) x)\n        (\\<lambda>_. sample_vars X (V - {x}) (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_.\n       bind (memo (sample_var X) x)\n        (\\<lambda>i. sample_vars X (V - {x}) (f i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>i.\n       bind (memo (sample_var X) x)\n        (\\<lambda>_. sample_vars X (V - {x}) (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_.\n       bind (memo (sample_var X) x)\n        (\\<lambda>i. sample_vars X (V - {x}) (f i)))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "have \"\\<dots> = bind (memo (sample_var X) x) (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_.\n         bind (memo (sample_var X) x)\n          (\\<lambda>i. sample_vars X (V - {x}) (f i))) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f))", "using Var"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_.\n         bind (memo (sample_var X) x)\n          (\\<lambda>i. sample_vars X (V - {x}) (f i))) =\n    bind (memo (sample_var X) x)\n     (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f))", "by(subst False)(simp_all)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_.\n       bind (memo (sample_var X) x)\n        (\\<lambda>i. sample_vars X (V - {x}) (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "also"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_.\n       bind (memo (sample_var X) x)\n        (\\<lambda>i. sample_vars X (V - {x}) (f i))) =\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "have \"\\<dots> = ?rhs V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_.\n         sample_vars X (V - {x}) (bind (memo (sample_var X) x) f)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "using Var"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x)\n     (\\<lambda>_.\n         sample_vars X (V - {x}) (bind (memo (sample_var X) x) f)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "by(rewrite in \"_ = \\<hole>\" V)(simp add: sample_vars_insert del: Diff_insert0 insert_Diff_single)"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x)\n   (\\<lambda>_. sample_vars X (V - {x}) (bind (memo (sample_var X) x) f)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>finite V; x \\<in> V\\<rbrakk>\n    \\<Longrightarrow> bind (memo (sample_var X) x)\n                       (\\<lambda>i. sample_vars X V (f i)) =\n                      sample_vars X V (bind (memo (sample_var X) x) f)", "finally"], ["proof (chain)\npicking this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)", "show ?thesis"], ["proof (prove)\nusing this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n    sample_vars X V (bind (memo (sample_var X) x) f)", "."], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (4 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "then"], ["proof (chain)\npicking this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)", "show ?case"], ["proof (prove)\nusing this:\n  bind (memo (sample_var X) x) (\\<lambda>i. sample_vars X V (f i)) =\n  sample_vars X V (bind (memo (sample_var X) x) f)\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f) =\n    bind (eval (memo (sample_var X)) (Var x))\n     (\\<lambda>i. sample_vars X V (f i))", "by simp"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f) =\n  bind (eval (memo (sample_var X)) (Var x))\n   (\\<lambda>i. sample_vars X V (f i))\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "case (Const x)"], ["proof (state)\nthis:\n  finite V\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       finite V \\<Longrightarrow>\n       sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x))\n        (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "then"], ["proof (chain)\npicking this:\n  finite V", "show ?case"], ["proof (prove)\nusing this:\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n    bind (eval (memo (sample_var X)) (Const x))\n     (\\<lambda>i. sample_vars X V (f i))", "by(simp add: return_bind)"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval (memo (sample_var X)) (Const x)) f) =\n  bind (eval (memo (sample_var X)) (Const x))\n   (\\<lambda>i. sample_vars X V (f i))\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "case (Plus e1 e2)"], ["proof (state)\nthis:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "then"], ["proof (chain)\npicking this:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V", "show ?case"], ["proof (prove)\nusing this:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval (memo (sample_var X)) (Plus e1 e2)) f) =\n    bind (eval (memo (sample_var X)) (Plus e1 e2))\n     (\\<lambda>i. sample_vars X V (f i))", "by(simp add: bind_assoc return_bind)"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval (memo (sample_var X)) (Plus e1 e2)) f) =\n  bind (eval (memo (sample_var X)) (Plus e1 e2))\n   (\\<lambda>i. sample_vars X V (f i))\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "case (Div e1 e2)"], ["proof (state)\nthis:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   finite V \\<Longrightarrow>\n                   sample_vars X V\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1)\n                    (\\<lambda>i. sample_vars X V (f i));\n        \\<And>f.\n           finite V \\<Longrightarrow>\n           sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2)\n            (\\<lambda>i. sample_vars X V (f i));\n        finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2))\n                          (\\<lambda>i. sample_vars X V (f i))", "then"], ["proof (chain)\npicking this:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V", "show ?case"], ["proof (prove)\nusing this:\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e1) ?f2) =\n  bind (eval (memo (sample_var X)) e1) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V \\<Longrightarrow>\n  sample_vars X V (bind (eval (memo (sample_var X)) e2) ?f2) =\n  bind (eval (memo (sample_var X)) e2) (\\<lambda>i. sample_vars X V (?f2 i))\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval (memo (sample_var X)) (Div e1 e2)) f) =\n    bind (eval (memo (sample_var X)) (Div e1 e2))\n     (\\<lambda>i. sample_vars X V (f i))", "apply(simp add: bind_assoc if_distrib[where f=\"\\<lambda>x. bind x _\"] fail_bind return_bind cong del: if_weak_cong)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f.\n                sample_vars X V (bind (eval (memo (sample_var X)) e1) f) =\n                bind (eval (memo (sample_var X)) e1)\n                 (\\<lambda>i. sample_vars X V (f i));\n     \\<And>f.\n        sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n        bind (eval (memo (sample_var X)) e2)\n         (\\<lambda>i. sample_vars X V (f i));\n     finite V\\<rbrakk>\n    \\<Longrightarrow> bind (eval (memo (sample_var X)) e1)\n                       (\\<lambda>i.\n                           bind (eval (memo (sample_var X)) e2)\n                            (\\<lambda>ia.\n                                sample_vars X V\n                                 (if ia = 0 then fail else f (i div ia)))) =\n                      bind (eval (memo (sample_var X)) e1)\n                       (\\<lambda>y.\n                           bind (eval (memo (sample_var X)) e2)\n                            (\\<lambda>ya.\n                                if ya = 0 then fail\n                                else sample_vars X V (f (y div ya))))", "apply(subst (6) sample_vars_fail[OF \\<open>finite V\\<close>, symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>f.\n                sample_vars X V (bind (eval (memo (sample_var X)) e1) f) =\n                bind (eval (memo (sample_var X)) e1)\n                 (\\<lambda>i. sample_vars X V (f i));\n     \\<And>f.\n        sample_vars X V (bind (eval (memo (sample_var X)) e2) f) =\n        bind (eval (memo (sample_var X)) e2)\n         (\\<lambda>i. sample_vars X V (f i));\n     finite V\\<rbrakk>\n    \\<Longrightarrow> bind (eval (memo (sample_var X)) e1)\n                       (\\<lambda>i.\n                           bind (eval (memo (sample_var X)) e2)\n                            (\\<lambda>ia.\n                                sample_vars X V\n                                 (if ia = 0 then fail else f (i div ia)))) =\n                      bind (eval (memo (sample_var X)) e1)\n                       (\\<lambda>y.\n                           bind (eval (memo (sample_var X)) e2)\n                            (\\<lambda>ya.\n                                if ya = 0 then sample_vars X V fail\n                                else sample_vars X V (f (y div ya))))", "apply(simp add: if_distrib[where f=\"sample_vars _ _\", symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval (memo (sample_var X)) (Div e1 e2)) f) =\n  bind (eval (memo (sample_var X)) (Div e1 e2))\n   (\\<lambda>i. sample_vars X V (f i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?V2 \\<Longrightarrow>\n  sample_vars X ?V2 (bind (lazy X ?e2) ?f2) =\n  bind (lazy X ?e2) (\\<lambda>i. sample_vars X ?V2 (?f2 i))\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "define V where \"V \\<equiv> vars e\""], ["proof (state)\nthis:\n  V \\<equiv> vars e\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "then"], ["proof (chain)\npicking this:\n  V \\<equiv> vars e", "have \"vars e \\<subseteq> V\" \"finite V\""], ["proof (prove)\nusing this:\n  V \\<equiv> vars e\n\ngoal (1 subgoal):\n 1. vars e \\<subseteq> V &&& finite V", "by simp_all"], ["proof (state)\nthis:\n  vars e \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "then"], ["proof (chain)\npicking this:\n  vars e \\<subseteq> V\n  finite V", "have \"sample_vars X V (bind (eval lookup e) f) = sample_vars X V (bind (lazy X e) f)\" for f"], ["proof (prove)\nusing this:\n  vars e \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval lookup e) f) =\n    sample_vars X V (bind (lazy X e) f)", "unfolding lazy_def"], ["proof (prove)\nusing this:\n  vars e \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval lookup e) f) =\n    sample_vars X V (bind (eval (memo (sample_var X)) e) f)", "proof(induction e arbitrary: f)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Var x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Var x)) f)\n 2. \\<And>x f.\n       \\<lbrakk>vars (Const x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Const x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Const x)) f)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Plus e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Plus e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2)) f)\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Div e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Div e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2)) f)", "case (Var x)"], ["proof (state)\nthis:\n  vars (Var x) \\<subseteq> V\n  finite V\n\ngoal (4 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Var x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Var x)) f)\n 2. \\<And>x f.\n       \\<lbrakk>vars (Const x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Const x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Const x)) f)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Plus e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Plus e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2)) f)\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Div e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Div e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2)) f)", "then"], ["proof (chain)\npicking this:\n  vars (Var x) \\<subseteq> V\n  finite V", "have V: \"V = insert x (V - {x})\""], ["proof (prove)\nusing this:\n  vars (Var x) \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. V = insert x (V - {x})", "by auto"], ["proof (state)\nthis:\n  V = insert x (V - {x})\n\ngoal (4 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Var x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Var x)) f)\n 2. \\<And>x f.\n       \\<lbrakk>vars (Const x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Const x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Const x)) f)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Plus e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Plus e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2)) f)\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Div e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Div e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2)) f)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval lookup (Var x)) f) =\n    sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f)", "using Var"], ["proof (prove)\nusing this:\n  vars (Var x) \\<subseteq> V\n  finite V\n\ngoal (1 subgoal):\n 1. sample_vars X V (bind (eval lookup (Var x)) f) =\n    sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f)", "apply(subst (1 2) V)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n    \\<Longrightarrow> sample_vars X (insert x (V - {x}))\n                       (bind (eval lookup (Var x)) f) =\n                      sample_vars X (insert x (V - {x}))\n                       (bind (eval (memo (sample_var X)) (Var x)) f)", "apply(subst (1 2) sample_vars_insert2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n    \\<Longrightarrow> finite (V - {x})\n 2. \\<lbrakk>vars (Var x) \\<subseteq> V; finite V\\<rbrakk>\n    \\<Longrightarrow> sample_vars X (V - {x})\n                       (bind (memo (sample_var X) x)\n                         (\\<lambda>_. bind (eval lookup (Var x)) f)) =\n                      sample_vars X (V - {x})\n                       (bind (memo (sample_var X) x)\n                         (\\<lambda>_.\n                             bind (eval (memo (sample_var X)) (Var x)) f))", "apply(simp_all add: memo_same memo_lookup)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval lookup (Var x)) f) =\n  sample_vars X V (bind (eval (memo (sample_var X)) (Var x)) f)\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       \\<lbrakk>vars (Const x) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V (bind (eval lookup (Const x)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Const x)) f)\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Plus e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Plus e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2)) f)\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   \\<lbrakk>vars e1 \\<subseteq> V; finite V\\<rbrakk>\n                   \\<Longrightarrow> sample_vars X V\n(bind (eval lookup e1) f) =\n                                     sample_vars X V\n(bind (eval (memo (sample_var X)) e1) f);\n        \\<And>f.\n           \\<lbrakk>vars e2 \\<subseteq> V; finite V\\<rbrakk>\n           \\<Longrightarrow> sample_vars X V (bind (eval lookup e2) f) =\n                             sample_vars X V\n                              (bind (eval (memo (sample_var X)) e2) f);\n        vars (Div e1 e2) \\<subseteq> V; finite V\\<rbrakk>\n       \\<Longrightarrow> sample_vars X V\n                          (bind (eval lookup (Div e1 e2)) f) =\n                         sample_vars X V\n                          (bind (eval (memo (sample_var X)) (Div e1 e2)) f)", "qed(simp_all add: bind_assoc lazy_sample_vars[unfolded lazy_def])"], ["proof (state)\nthis:\n  sample_vars X V (bind (eval lookup e) ?f2) =\n  sample_vars X V (bind (lazy X e) ?f2)\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "note this[of return, unfolded V_def]"], ["proof (state)\nthis:\n  sample_vars X (vars e) (bind (eval lookup e) return) =\n  sample_vars X (vars e) (bind (lazy X e) return)\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "also"], ["proof (state)\nthis:\n  sample_vars X (vars e) (bind (eval lookup e) return) =\n  sample_vars X (vars e) (bind (lazy X e) return)\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "have \"sample_vars X (vars e) (bind (lazy X e) f) = bind (lazy X e) f\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars e) (bind (lazy X e) f) = bind (lazy X e) f", "unfolding lazy_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars e) (bind (eval (memo (sample_var X)) e) f) =\n    bind (eval (memo (sample_var X)) e) f", "proof(induction e arbitrary: f)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Var x))\n        (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x)) f\n 2. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "{"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Var x))\n        (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x)) f\n 2. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "case Var"], ["proof (state)\nthis:\n  \n\ngoal (4 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Var x))\n        (bind (eval (memo (sample_var X)) (Var x)) f) =\n       bind (eval (memo (sample_var X)) (Var x)) f\n 2. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 4. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars (Var x_))\n     (bind (eval (memo (sample_var X)) (Var x_)) f) =\n    bind (eval (memo (sample_var X)) (Var x_)) f", "by(simp add: memo_same bind_return)"], ["proof (state)\nthis:\n  sample_vars X (vars (Var x_))\n   (bind (eval (memo (sample_var X)) (Var x_)) f) =\n  bind (eval (memo (sample_var X)) (Var x_)) f\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "}"], ["proof (state)\nthis:\n  sample_vars X (vars (Var ?x5))\n   (bind (eval (memo (sample_var X)) (Var ?x5)) ?fa4) =\n  bind (eval (memo (sample_var X)) (Var ?x5)) ?fa4\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "{"], ["proof (state)\nthis:\n  sample_vars X (vars (Var ?x5))\n   (bind (eval (memo (sample_var X)) (Var ?x5)) ?fa4) =\n  bind (eval (memo (sample_var X)) (Var ?x5)) ?fa4\n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "case Const"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>x f.\n       sample_vars X (vars (Const x))\n        (bind (eval (memo (sample_var X)) (Const x)) f) =\n       bind (eval (memo (sample_var X)) (Const x)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 3. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars (Const x_))\n     (bind (eval (memo (sample_var X)) (Const x_)) f) =\n    bind (eval (memo (sample_var X)) (Const x_)) f", "by(simp add: bind_return)"], ["proof (state)\nthis:\n  sample_vars X (vars (Const x_))\n   (bind (eval (memo (sample_var X)) (Const x_)) f) =\n  bind (eval (memo (sample_var X)) (Const x_)) f\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "}"], ["proof (state)\nthis:\n  sample_vars X (vars (Const ?x5))\n   (bind (eval (memo (sample_var X)) (Const ?x5)) ?fa4) =\n  bind (eval (memo (sample_var X)) (Const ?x5)) ?fa4\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "{"], ["proof (state)\nthis:\n  sample_vars X (vars (Const ?x5))\n   (bind (eval (memo (sample_var X)) (Const ?x5)) ?fa4) =\n  bind (eval (memo (sample_var X)) (Const ?x5)) ?fa4\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "case Plus"], ["proof (state)\nthis:\n  sample_vars X (vars e1_) (bind (eval (memo (sample_var X)) e1_) ?f2) =\n  bind (eval (memo (sample_var X)) e1_) ?f2\n  sample_vars X (vars e2_) (bind (eval (memo (sample_var X)) e2_) ?f2) =\n  bind (eval (memo (sample_var X)) e2_) ?f2\n\ngoal (2 subgoals):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Plus e1 e2))\n                          (bind (eval (memo (sample_var X)) (Plus e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Plus e1 e2)) f\n 2. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars (Plus e1_ e2_))\n     (bind (eval (memo (sample_var X)) (Plus e1_ e2_)) f) =\n    bind (eval (memo (sample_var X)) (Plus e1_ e2_)) f", "by(simp add: bind_assoc sample_vars_union lazy_sample_vars[unfolded lazy_def] Plus.IH)"], ["proof (state)\nthis:\n  sample_vars X (vars (Plus e1_ e2_))\n   (bind (eval (memo (sample_var X)) (Plus e1_ e2_)) f) =\n  bind (eval (memo (sample_var X)) (Plus e1_ e2_)) f\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f.\n              sample_vars X (vars ?e1.5)\n               (bind (eval (memo (sample_var X)) ?e1.5) f) =\n              bind (eval (memo (sample_var X)) ?e1.5) f;\n   \\<And>f.\n      sample_vars X (vars ?e2.5)\n       (bind (eval (memo (sample_var X)) ?e2.5) f) =\n      bind (eval (memo (sample_var X)) ?e2.5) f\\<rbrakk>\n  \\<Longrightarrow> sample_vars X (vars (Plus ?e1.5 ?e2.5))\n                     (bind (eval (memo (sample_var X)) (Plus ?e1.5 ?e2.5))\n                       ?fa4) =\n                    bind (eval (memo (sample_var X)) (Plus ?e1.5 ?e2.5))\n                     ?fa4\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f.\n              sample_vars X (vars ?e1.5)\n               (bind (eval (memo (sample_var X)) ?e1.5) f) =\n              bind (eval (memo (sample_var X)) ?e1.5) f;\n   \\<And>f.\n      sample_vars X (vars ?e2.5)\n       (bind (eval (memo (sample_var X)) ?e2.5) f) =\n      bind (eval (memo (sample_var X)) ?e2.5) f\\<rbrakk>\n  \\<Longrightarrow> sample_vars X (vars (Plus ?e1.5 ?e2.5))\n                     (bind (eval (memo (sample_var X)) (Plus ?e1.5 ?e2.5))\n                       ?fa4) =\n                    bind (eval (memo (sample_var X)) (Plus ?e1.5 ?e2.5))\n                     ?fa4\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "case Div"], ["proof (state)\nthis:\n  sample_vars X (vars e1_) (bind (eval (memo (sample_var X)) e1_) ?f2) =\n  bind (eval (memo (sample_var X)) e1_) ?f2\n  sample_vars X (vars e2_) (bind (eval (memo (sample_var X)) e2_) ?f2) =\n  bind (eval (memo (sample_var X)) e2_) ?f2\n\ngoal (1 subgoal):\n 1. \\<And>e1 e2 f.\n       \\<lbrakk>\\<And>f.\n                   sample_vars X (vars e1)\n                    (bind (eval (memo (sample_var X)) e1) f) =\n                   bind (eval (memo (sample_var X)) e1) f;\n        \\<And>f.\n           sample_vars X (vars e2)\n            (bind (eval (memo (sample_var X)) e2) f) =\n           bind (eval (memo (sample_var X)) e2) f\\<rbrakk>\n       \\<Longrightarrow> sample_vars X (vars (Div e1 e2))\n                          (bind (eval (memo (sample_var X)) (Div e1 e2))\n                            f) =\n                         bind (eval (memo (sample_var X)) (Div e1 e2)) f", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_vars X (vars (Div e1_ e2_))\n     (bind (eval (memo (sample_var X)) (Div e1_ e2_)) f) =\n    bind (eval (memo (sample_var X)) (Div e1_ e2_)) f", "by(simp add: bind_assoc sample_vars_union lazy_sample_vars[unfolded lazy_def] Div.IH)"], ["proof (state)\nthis:\n  sample_vars X (vars (Div e1_ e2_))\n   (bind (eval (memo (sample_var X)) (Div e1_ e2_)) f) =\n  bind (eval (memo (sample_var X)) (Div e1_ e2_)) f\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>f.\n              sample_vars X (vars ?e1.5)\n               (bind (eval (memo (sample_var X)) ?e1.5) f) =\n              bind (eval (memo (sample_var X)) ?e1.5) f;\n   \\<And>f.\n      sample_vars X (vars ?e2.5)\n       (bind (eval (memo (sample_var X)) ?e2.5) f) =\n      bind (eval (memo (sample_var X)) ?e2.5) f\\<rbrakk>\n  \\<Longrightarrow> sample_vars X (vars (Div ?e1.5 ?e2.5))\n                     (bind (eval (memo (sample_var X)) (Div ?e1.5 ?e2.5))\n                       ?fa4) =\n                    bind (eval (memo (sample_var X)) (Div ?e1.5 ?e2.5)) ?fa4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sample_vars X (vars e) (bind (lazy X e) ?f2) = bind (lazy X e) ?f2\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "finally"], ["proof (chain)\npicking this:\n  sample_vars X (vars e) (bind (eval lookup e) return) =\n  bind (lazy X e) return", "show ?thesis"], ["proof (prove)\nusing this:\n  sample_vars X (vars e) (bind (eval lookup e) return) =\n  bind (lazy X e) return\n\ngoal (1 subgoal):\n 1. lazy X e = eager X e", "by(simp add: bind_return V_def eager_def)"], ["proof (state)\nthis:\n  lazy X e = eager X e\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "interpretation F: exp_base\n  \"return_option return_id\"\n  \"bind_option return_id bind_id\"\n  \"fail_option return_id\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "value [code] \"F.eval (\\<lambda>x. return_option return_id 5) (Plus (Var ''a'') (Const 7))\""], ["", "subsubsection \\<open>Moving between monad instances\\<close>"], ["", "global_interpretation SFI: memo_exp_base\n  \"return_state (return_option (return_id :: ((int \\<times> ('b \\<rightharpoonup> int)) option, _) return))\"\n  \"bind_state (bind_option return_id bind_id)\"\n  \"fail_state (fail_option return_id)\"\n  \"get_state\"\n  \"put_state\"\n  defines SFI_lookup = SFI.lookup"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "interpretation SFI: memoization\n  \"return_state (return_option (return_id :: ((int \\<times> ('b \\<rightharpoonup> int)) option, _) return))\"\n  \"bind_state (bind_option return_id bind_id)\"\n  \"get_state\"\n  \"put_state\""], ["proof (prove)\ngoal (1 subgoal):\n 1. memoization (return_state (return_option return_id))\n     (bind_state (bind_option return_id bind_id)) get_state put_state", ".."], ["", "global_interpretation SFP: prob_exp\n  \"return_state (return_option return_pmf)\"\n  \"bind_state (bind_option return_pmf bind_pmf)\"\n  \"fail_state (fail_option return_pmf)\"\n  \"get_state\"\n  \"put_state\"\n  \"sample_state (sample_option bind_pmf)\"\n  defines SFP_lookup = SFP.lookup"], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_exp (return_state (return_option return_pmf))\n     (bind_state (bind_option return_pmf bind_pmf))\n     (fail_state (fail_option return_pmf)) get_state put_state\n     (sample_state (sample_option bind_pmf))", ".."], ["", "interpretation FSP: prob_exp\n  \"return_option (return_state (return_pmf :: (int option \\<times> ('b \\<rightharpoonup> int), _) return))\"\n  \"bind_option (return_state return_pmf) (bind_state bind_pmf)\"\n  \"fail_option (return_state return_pmf)\"\n  \"get_option get_state\"\n  \"put_option put_state\"\n  \"sample_option (sample_state bind_pmf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prob_exp (return_option (return_state return_pmf))\n     (bind_option (return_state return_pmf) (bind_state bind_pmf))\n     (fail_option (return_state return_pmf)) (get_option get_state)\n     (put_option put_state) (sample_option (sample_state bind_pmf))", ".."], ["", "locale reader_exp_base = exp_base return bind fail + monad_reader_base return bind ask\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and ask :: \"('v \\<rightharpoonup> int, 'm) ask\"\nbegin"], ["", "definition lookup :: \"'v \\<Rightarrow> 'm\" where\n  \"lookup x = ask (\\<lambda>s. case s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\""], ["", "lemma lookup_alt_def:\n  \"lookup x = ask (\\<lambda>s. case apply s x of None \\<Rightarrow> fail | Some y \\<Rightarrow> return y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup x =\n    ask (\\<lambda>s.\n            case apply s x of None \\<Rightarrow> fail\n            | Some y \\<Rightarrow> return y)", "by(simp add: lookup_def apply_def)"], ["", "end"], ["", "locale exp_commute = exp_base return bind fail + monad_commute return bind\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\nbegin"], ["", "lemma eval_reverse:\n  \"eval E (Var x) = E x\"\n  \"eval E (Const i) = return i\"\n  \"eval E (Plus e1 e2) = bind (eval E e2) (\\<lambda>j. bind (eval E e1) (\\<lambda>i. return (i + j)))\"\n  \"eval E (Div e1 e2) = bind (eval E e2) (\\<lambda>j. bind (eval E e1) (\\<lambda>i. if j = 0 then fail else return (i div j)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eval E (Var x) = E x &&& eval E (Const i) = return i) &&&\n    eval E (Plus e1 e2) =\n    bind (eval E e2)\n     (\\<lambda>j. bind (eval E e1) (\\<lambda>i. return (i + j))) &&&\n    eval E (Div e1 e2) =\n    bind (eval E e2)\n     (\\<lambda>j.\n         bind (eval E e1)\n          (\\<lambda>i. if j = 0 then fail else return (i div j)))", "by(simp; rule bind_commute)+"], ["", "end"], ["", "global_interpretation RFI: reader_exp_base \n  \"return_env (return_option return_id)\"\n  \"bind_env (bind_option return_id bind_id)\"\n  \"fail_env (fail_option return_id)\"\n  ask_env\n  defines RFI_lookup = RFI.lookup"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "context includes lifting_syntax begin"], ["", "lemma cr_id_prob_eval:\n  notes [transfer_rule] = cr_id_prob_transfer shows\n  \"rel_stateT (=) (rel_optionT (cr_id_prob (=)))\n     (SFI.eval SFI_lookup e)\n     (SFP.eval SFP_lookup e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stateT (=) (rel_optionT (cr_id_prob (=))) (SFI.eval SFI_lookup e)\n     (SFP.eval SFP_lookup e)", "unfolding SFP.lookup_def SFI.lookup_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_stateT (=) (rel_optionT (cr_id_prob (=)))\n     (SFI.eval\n       (\\<lambda>x.\n           get_state\n            (\\<lambda>s.\n                case s x of\n                None \\<Rightarrow> fail_state (fail_option return_id)\n                | Some x \\<Rightarrow>\n                    return_state (return_option return_id) x))\n       e)\n     (SFP.eval\n       (\\<lambda>x.\n           get_state\n            (\\<lambda>s.\n                case s x of\n                None \\<Rightarrow> fail_state (fail_option return_pmf)\n                | Some x \\<Rightarrow>\n                    return_state (return_option return_pmf) x))\n       e)", "by transfer_prover"], ["", "lemma cr_envT_stateT_lookup':\n  notes [transfer_rule] = cr_envT_stateT_transfer apply_eq_onp shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n   RFI_lookup SFI_lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n     RFI_lookup SFI_lookup", "unfolding RFI.lookup_alt_def SFI.lookup_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n     (\\<lambda>x.\n         ask_env\n          (\\<lambda>s.\n              case apply s x of\n              None \\<Rightarrow> fail_env (fail_option return_id)\n              | Some x \\<Rightarrow>\n                  return_env (return_option return_id) x))\n     (\\<lambda>x.\n         get_state\n          (\\<lambda>s.\n              case apply s x of\n              None \\<Rightarrow> fail_state (fail_option return_id)\n              | Some x \\<Rightarrow>\n                  return_state (return_option return_id) x))", "by transfer_prover"], ["", "lemma cr_envT_stateT_eval':\n  notes [transfer_rule] = cr_envT_stateT_transfer cr_envT_stateT_lookup' shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n  (RFI.eval RFI_lookup) (SFI.eval SFI_lookup)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X (rel_optionT (rel_id (rel_option (cr_prod1 X (=))))))\n     (RFI.eval RFI_lookup) (SFI.eval SFI_lookup)", "by transfer_prover"], ["", "lemma cr_envT_stateT_lookup [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_id_prob_transfer cr_envT_stateT_transfer apply_eq_onp shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n   RFI_lookup SFP_lookup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X\n      (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n     RFI_lookup SFP_lookup", "unfolding RFI.lookup_alt_def SFP.lookup_alt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X\n      (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n     (\\<lambda>x.\n         ask_env\n          (\\<lambda>s.\n              case apply s x of\n              None \\<Rightarrow> fail_env (fail_option return_id)\n              | Some x \\<Rightarrow>\n                  return_env (return_option return_id) x))\n     (\\<lambda>x.\n         get_state\n          (\\<lambda>s.\n              case apply s x of\n              None \\<Rightarrow> fail_state (fail_option return_pmf)\n              | Some x \\<Rightarrow>\n                  return_state (return_option return_pmf) x))", "by transfer_prover"], ["", "lemma cr_envT_stateT_eval [cr_envT_stateT_transfer]:\n  notes [transfer_rule] = cr_id_prob_transfer cr_envT_stateT_transfer shows\n  \"((=) ===> cr_envT_stateT X (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n  (RFI.eval RFI_lookup) (SFP.eval SFP_lookup)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((=) ===>\n     cr_envT_stateT X\n      (rel_optionT (cr_id_prob (rel_option (cr_prod1 X (=))))))\n     (RFI.eval RFI_lookup) (SFP.eval SFP_lookup)", "by transfer_prover"], ["", "lemma prob_eval_lookup:\n  \"run_state (SFP.eval SFP_lookup e) E = \n   map_optionT (return_pmf \\<circ> map_option (\\<lambda>b. (b, E)) \\<circ> extract) (run_env (RFI.eval RFI_lookup e) E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. run_state (SFP.eval SFP_lookup e) E =\n    map_optionT\n     (return_pmf \\<circ> map_option (\\<lambda>b. (b, E)) \\<circ> extract)\n     (run_env (RFI.eval RFI_lookup e) E)", "by(rule cr_envT_stateT_eval[of E, THEN rel_funD, OF refl, unfolded eq_alt, unfolded cr_prod1_Grp option.rel_Grp cr_id_prob_Grp rel_optionT_Grp, simplified, THEN cr_envT_stateTD, unfolded BNF_Def.Grp_def, THEN conjunct1])"], ["", "end"], ["", "subsection \\<open>Non-deterministic interpreter\\<close>"], ["", "locale choose_base = monad_altc_base return bind altc\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and altc :: \"(int, 'm) altc\"\nbegin"], ["", "definition choose_var :: \"('v \\<Rightarrow> int cset) \\<Rightarrow> 'v \\<Rightarrow> 'm\" where\n  \"choose_var X x = altc (X x) return\""], ["", "end"], ["", "declare choose_base.choose_var_def [code]"], ["", "locale nondet_exp_base = choose_base return bind altc\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and altc :: \"(int, 'm) altc\"\nbegin"], ["", "sublocale memo_exp_base return bind fail get put"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition lazy where \"lazy X = eval (memo (choose_var X))\""], ["", "end"], ["", "locale nondet_exp =\n  monad_state_altc return bind get put altc +\n  nondet_exp_base return bind get put altc + \n  memoization return bind get put\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and altc :: \"(int, 'm) altc\"\nbegin"], ["", "sublocale monad_fail return bind fail"], ["proof (prove)\ngoal (1 subgoal):\n 1. monad_fail return bind fail", "by(rule monad_fail)"], ["", "end"], ["", "global_interpretation NI: cset_nondetM return_id bind_id merge_id merge_id \n  defines NI_return = NI.return_nondet\n    and NI_bind = NI.bind_nondet\n    and NI_altc = NI.altc_nondet"], ["proof (prove)\ngoal (1 subgoal):\n 1. cset_nondetM return_id bind_id merge_id merge_id", ".."], ["", "global_interpretation SNI: nondet_exp\n  \"return_state NI_return\"\n  \"bind_state NI_bind\"\n  \"get_state\"\n  \"put_state\"\n  \"altc_state NI_altc\"\n  defines SNI_lazy = SNI.lazy"], ["proof (prove)\ngoal (1 subgoal):\n 1. nondet_exp (return_state NI_return) (bind_state NI_bind) get_state\n     put_state (altc_state NI_altc)", ".."], ["", "value \"run_state (SNI_lazy (\\<lambda>x. cinsert 0 (cinsert 1 cempty)) (Div (Const 2) (Var (CHR ''x'')))) Map.empty\""], ["", "locale nondet_fail_exp_base = choose_base return bind altc\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and altc :: \"(int, 'm) altc\"\nbegin"], ["", "sublocale memo_exp_base return bind fail get put"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition lazy where \"lazy X = eval (memo (choose_var X))\""], ["", "end"], ["", "locale nondet_fail_exp =\n  monad_state_altc return bind get put altc +\n  nondet_fail_exp_base return bind fail get put altc + \n  memoization return bind get put +\n  fail: monad_fail return bind fail\n  for return :: \"(int, 'm) return\"\n  and bind :: \"(int, 'm) bind\"\n  and fail :: \"'m fail\"\n  and get :: \"('v \\<rightharpoonup> int, 'm) get\"\n  and put :: \"('v \\<rightharpoonup> int, 'm) put\"\n  and altc :: \"(int, 'm) altc\""], ["", "global_interpretation SFNI: nondet_fail_exp\n  \"return_state (return_option NI_return)\"\n  \"bind_state (bind_option NI_return NI_bind)\"\n  \"fail_state (fail_option NI_return)\"\n  \"get_state\"\n  \"put_state\"\n  \"altc_state (altc_option NI_altc)\"\n  defines SFNI_lazy = SFNI.lazy"], ["proof (prove)\ngoal (1 subgoal):\n 1. nondet_fail_exp (return_state (return_option NI_return))\n     (bind_state (bind_option NI_return NI_bind))\n     (fail_state (fail_option NI_return)) get_state put_state\n     (altc_state (altc_option NI_altc))", ".."], ["", "value \"run_state (SFP.lazy (\\<lambda>x. pmf_of_set {0, 1}) (Div (Const 2) (Var (CHR ''x'')))) Map.empty\""], ["", "value \"run_state (SFNI_lazy (\\<lambda>x. cinsert 0 (cinsert 1 cempty)) (Div (Const 2) (Var (CHR ''x'')))) Map.empty\""], ["", "end"]]}