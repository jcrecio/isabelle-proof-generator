{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Lib/Fofu_Abs_Base.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma swap_in_iff_inv: \"prod.swap p \\<in> S \\<longleftrightarrow> p \\<in> S\\<inverse>\"", "lemma length_filter_disj_or_conv:\n  assumes \"\\<And>x. x\\<in>set xs \\<longrightarrow> \\<not>(P x \\<and> Q x)\"\n  shows \"length [x \\<leftarrow> xs. P x \\<or> Q x] = length (filter P xs) + length (filter Q xs)\"", "lemma sum_arb:\n  assumes A_fin: \"finite A\"\n      and x_mem: \"x \\<in> A\" \n      and x_dif: \"\\<forall>y\\<in>A. y \\<noteq> x \\<longrightarrow> g y = h y\"\n    shows \"(\\<Sum>a\\<in>A. g a) = (\\<Sum>a\\<in>A - {x}. h a) + g x\"", "lemma trcl_cons_conv: \n  \"(u,a#xs,v)\\<in>trcl R \\<longleftrightarrow> (\\<exists>uh. (u,a,uh)\\<in>R \\<and> (uh,xs,v)\\<in>trcl R)\"", "lemma trcl_conc_conv: \n  \"(u,xs@ys,v)\\<in>trcl R \\<longleftrightarrow> (\\<exists>uh. (u,xs,uh)\\<in>trcl R \\<and> (uh,ys,v)\\<in>trcl R)\"", "lemmas trcl_conv = trcl_cons_conv trcl_conc_conv\n  \\<comment> \\<open>Adding these to simpset will split all cons and append operations in paths\\<close>"], "translations": [["", "lemma swap_in_iff_inv: \"prod.swap p \\<in> S \\<longleftrightarrow> p \\<in> S\\<inverse>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prod.swap p \\<in> S) = (p \\<in> S\\<inverse>)", "apply (cases p)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       p = (a, b) \\<Longrightarrow>\n       (prod.swap p \\<in> S) = (p \\<in> S\\<inverse>)", "by auto"], ["", "(* TODO: Move *)"], ["", "lemma length_filter_disj_or_conv:\n  assumes \"\\<And>x. x\\<in>set xs \\<longrightarrow> \\<not>(P x \\<and> Q x)\"\n  shows \"length [x \\<leftarrow> xs. P x \\<or> Q x] = length (filter P xs) + length (filter Q xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. P x \\<or> Q x) xs) =\n    length (filter P xs) + length (filter Q xs)", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set xs \\<longrightarrow> \\<not> (P ?x \\<and> Q ?x)\n\ngoal (1 subgoal):\n 1. length (filter (\\<lambda>x. P x \\<or> Q x) xs) =\n    length (filter P xs) + length (filter Q xs)", "by (induction xs) auto"], ["", "(* TODO: Move. Extract an element from a summation, combined with congruence. *)"], ["", "lemma sum_arb:\n  assumes A_fin: \"finite A\"\n      and x_mem: \"x \\<in> A\" \n      and x_dif: \"\\<forall>y\\<in>A. y \\<noteq> x \\<longrightarrow> g y = h y\"\n    shows \"(\\<Sum>a\\<in>A. g a) = (\\<Sum>a\\<in>A - {x}. h a) + g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "have \"A = (A - {x}) \\<union> {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = A - {x} \\<union> {x}", "using x_mem"], ["proof (prove)\nusing this:\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. A = A - {x} \\<union> {x}", "by auto"], ["proof (state)\nthis:\n  A = A - {x} \\<union> {x}\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "moreover"], ["proof (state)\nthis:\n  A = A - {x} \\<union> {x}\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "note sum.union_disjoint[of \"A - {x}\" \"{x}\" g]"], ["proof (state)\nthis:\n  \\<lbrakk>finite (A - {x}); finite {x};\n   (A - {x}) \\<inter> {x} = {}\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x} \\<union> {x}) =\n                    sum g (A - {x}) + sum g {x}\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>finite (A - {x}); finite {x};\n   (A - {x}) \\<inter> {x} = {}\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x} \\<union> {x}) =\n                    sum g (A - {x}) + sum g {x}\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "note sum.cong[of \"A - {x}\" \"A - {x}\" g h]"], ["proof (state)\nthis:\n  \\<lbrakk>A - {x} = A - {x};\n   \\<And>xa. xa \\<in> A - {x} \\<Longrightarrow> g xa = h xa\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x}) = sum h (A - {x})\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "ultimately"], ["proof (chain)\npicking this:\n  A = A - {x} \\<union> {x}\n  \\<lbrakk>finite (A - {x}); finite {x};\n   (A - {x}) \\<inter> {x} = {}\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x} \\<union> {x}) =\n                    sum g (A - {x}) + sum g {x}\n  \\<lbrakk>A - {x} = A - {x};\n   \\<And>xa. xa \\<in> A - {x} \\<Longrightarrow> g xa = h xa\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x}) = sum h (A - {x})", "show ?thesis"], ["proof (prove)\nusing this:\n  A = A - {x} \\<union> {x}\n  \\<lbrakk>finite (A - {x}); finite {x};\n   (A - {x}) \\<inter> {x} = {}\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x} \\<union> {x}) =\n                    sum g (A - {x}) + sum g {x}\n  \\<lbrakk>A - {x} = A - {x};\n   \\<And>xa. xa \\<in> A - {x} \\<Longrightarrow> g xa = h xa\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x}) = sum h (A - {x})\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "using A_fin x_dif"], ["proof (prove)\nusing this:\n  A = A - {x} \\<union> {x}\n  \\<lbrakk>finite (A - {x}); finite {x};\n   (A - {x}) \\<inter> {x} = {}\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x} \\<union> {x}) =\n                    sum g (A - {x}) + sum g {x}\n  \\<lbrakk>A - {x} = A - {x};\n   \\<And>xa. xa \\<in> A - {x} \\<Longrightarrow> g xa = h xa\\<rbrakk>\n  \\<Longrightarrow> sum g (A - {x}) = sum h (A - {x})\n  finite A\n  \\<forall>y\\<in>A. y \\<noteq> x \\<longrightarrow> g y = h y\n\ngoal (1 subgoal):\n 1. sum g A = sum h (A - {x}) + g x", "by auto"], ["proof (state)\nthis:\n  sum g A = sum h (A - {x}) + g x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trcl_cons_conv: \n  \"(u,a#xs,v)\\<in>trcl R \\<longleftrightarrow> (\\<exists>uh. (u,a,uh)\\<in>R \\<and> (uh,xs,v)\\<in>trcl R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, a # xs, v) \\<in> trcl R) =\n    (\\<exists>uh. (u, a, uh) \\<in> R \\<and> (uh, xs, v) \\<in> trcl R)", "by (auto dest!: trcl_uncons)"], ["", "lemma trcl_conc_conv: \n  \"(u,xs@ys,v)\\<in>trcl R \\<longleftrightarrow> (\\<exists>uh. (u,xs,uh)\\<in>trcl R \\<and> (uh,ys,v)\\<in>trcl R)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((u, xs @ ys, v) \\<in> trcl R) =\n    (\\<exists>uh. (u, xs, uh) \\<in> trcl R \\<and> (uh, ys, v) \\<in> trcl R)", "by (auto dest!: trcl_unconcat intro: trcl_concat)"], ["", "lemmas trcl_conv = trcl_cons_conv trcl_conc_conv\n  \\<comment> \\<open>Adding these to simpset will split all cons and append operations in paths\\<close>"], ["", "end"]]}