{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Graph.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma finite_Image: fixes R shows \"\\<lbrakk> finite R \\<rbrakk> \\<Longrightarrow> finite (R `` A)\"", "lemma map_eq_appendE: \n  assumes \"map f ls = fl@fl'\"\n  obtains l l' where \"ls=l@l'\" and \"map f l=fl\" and  \"map f l' = fl'\"", "lemma (in Graph) pathVertices_fwd: \n    assumes \"isPath u p v\"\n    shows \"pathVertices u p = pathVertices_fwd u p\"", "lemma V_alt: \"V = fst`E \\<union> snd`E\"", "lemma E_ss_VxV: \"E \\<subseteq> V\\<times>V\"", "lemma adjacent_nodes_ss_V: \"adjacent_nodes u \\<subseteq> V\"", "lemma Vfin_imp_Efin[simp, intro]: assumes \"finite V\" shows \"finite E\"", "lemma Efin_imp_Vfin: \"finite E \\<Longrightarrow> finite V\"", "lemma zero_cap_simp[simp]: \"(u,v)\\<notin>E \\<Longrightarrow> c (u,v) = 0\"", "lemma succ_ss_V: \"E``{u} \\<subseteq> V\"", "lemma pred_ss_V: \"E\\<inverse>``{u} \\<subseteq> V\"", "lemma \n  incoming_edges: \"incoming u \\<subseteq> E\" and\n  outgoing_edges: \"outgoing u \\<subseteq> E\" and\n  incoming'_edges: \"incoming' U \\<subseteq> E\" and\n  outgoing'_edges: \"outgoing' U \\<subseteq> E\"", "lemma \n  incoming_alt: \"incoming u = (\\<lambda>v. (v,u))`(E\\<inverse>``{u})\" and\n  outgoing_alt: \"outgoing u = Pair u`(E``{u})\"", "lemma \n  finite_incoming[simp, intro]: \"finite V \\<Longrightarrow> finite (incoming u)\" and\n  finite_outgoing[simp, intro]: \"finite V \\<Longrightarrow> finite (outgoing u)\"", "lemma \n  finite_incoming'[simp, intro]: \"finite V \\<Longrightarrow> finite (incoming' U)\" and\n  finite_outgoing'[simp, intro]: \"finite V \\<Longrightarrow> finite (outgoing' U)\"", "lemma sum_outgoing_pointwise: \"(\\<Sum>e\\<in>outgoing u. g e) = (\\<Sum>v\\<in>E``{u}. g (u,v))\"", "lemma sum_incoming_pointwise: \"(\\<Sum>e\\<in>incoming u. g e) = (\\<Sum>v\\<in>E\\<inverse>``{u}. g (v,u))\"", "lemma (in Finite_Graph) sum_incoming_extend:  \n  assumes \"\\<And>v. \\<lbrakk> v\\<in>V; (v,u)\\<notin>E \\<rbrakk> \\<Longrightarrow> g (v,u) = 0\"\n  shows \"(\\<Sum>e\\<in>incoming u. g e) = (\\<Sum>v\\<in>V. g (v,u))\"", "lemma (in Finite_Graph) sum_outgoing_extend:  \n  assumes \"\\<And>v. \\<lbrakk> v\\<in>V; (u,v)\\<notin>E \\<rbrakk> \\<Longrightarrow> g (u,v) = 0\"\n  shows \"(\\<Sum>e\\<in>outgoing u. g e) = (\\<Sum>v\\<in>V. g (u,v))\"", "lemma (in Finite_Graph) sum_outgoing_alt: \"\\<lbrakk>\\<forall>e. 0 \\<le> g e \\<and> g e \\<le> c e\\<rbrakk> \\<Longrightarrow>\n  \\<forall>v \\<in> V. (\\<Sum>e \\<in> outgoing v. g e) = (\\<Sum>u \\<in> V. g (v, u))\"", "lemma (in Finite_Graph) sum_incoming_alt: \"\\<lbrakk>\\<forall>e. 0 \\<le> g e \\<and> g e \\<le> c e\\<rbrakk> \\<Longrightarrow>\n  \\<forall>v \\<in> V. (\\<Sum>e \\<in> incoming v. g e) = (\\<Sum>u \\<in> V. g (u, v))\"", "lemma (in Finite_Graph) finite_E[simp,intro!]: \"finite E\"", "lemma (in Graph) Finite_Graph_EI: \"finite E \\<Longrightarrow> Finite_Graph c\"", "lemma (in Finite_Graph) adjacent_nodes_finite[simp, intro!]: \"finite (adjacent_nodes u)\"", "lemma transfer_path:\n  \\<comment> \\<open>Transfer path to another graph\\<close>\n  assumes \"set p\\<inter>E \\<subseteq> Graph.E c'\"\n  assumes \"isPath u p v\"\n  shows \"Graph.isPath c' u p v\"", "lemma isPath_append[split_path_simps]: \n  \"isPath u (p1 @ p2) v \\<longleftrightarrow> (\\<exists>w. isPath u p1 w \\<and> isPath w p2 v)\"", "lemma isPath_head[split_path_simps]: \n  \"isPath u (e#p) v \\<longleftrightarrow> fst e = u \\<and> e \\<in> E \\<and> isPath (snd e) p v\"", "lemma isPath_head2: \n  \"isPath u (e#p) v \\<Longrightarrow> (p = [] \\<or> (p \\<noteq> [] \\<and> fst (hd p) = snd e))\"", "lemma isPath_tail: \n  \"isPath u (p@[e]) v \\<longleftrightarrow> isPath u p (fst e) \\<and> e \\<in> E \\<and> snd e = v\"", "lemma isPath_tail2: \n  \"isPath u (p@[e]) v \\<Longrightarrow> (p = [] \\<or> (p \\<noteq> [] \\<and> snd (last p) = fst e))\"", "lemma isPath_append_edge: \n  \"isPath v p v' \\<Longrightarrow> (v',v'')\\<in>E \\<Longrightarrow> isPath v (p@[(v',v'')]) v''\"", "lemma isPath_edgeset: \"\\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk> \\<Longrightarrow> e \\<in> E\"", "lemma isPath_rtc: \"isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*\"", "lemma rtc_isPath: \"(u, v) \\<in> E\\<^sup>* \\<Longrightarrow> (\\<exists>p. isPath u p v)\"", "lemma rtci_isPath: \"(v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow> (\\<exists>p. isPath u p v)\"", "lemma isPath_ex_edge1: \n  assumes \"isPath u p v\"\n  assumes \"(u1, v1) \\<in> set p\"\n  assumes \"u1 \\<noteq> u\"\n  shows \"\\<exists>u2. (u2, u1) \\<in> set p\"", "lemma isPath_ex_edge2: \n  assumes \"isPath u p v\"\n  assumes \"(u1, v1) \\<in> set p\"\n  assumes \"v1 \\<noteq> v\"\n  shows \"\\<exists>v2. (v1, v2) \\<in> set p\"", "lemma (in Graph) pathVertices_fwd_simps[simp]: \n  \"pathVertices_fwd s ([]) = [s]\"  \n  \"pathVertices_fwd s (e#p) = s#pathVertices_fwd (snd e) p\"  \n  \"pathVertices_fwd s (p@[e]) = pathVertices_fwd s p@[snd e]\"\n  \"pathVertices_fwd s (p1@e#p2) \n    = pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2\"\n  \"s\\<in>set (pathVertices_fwd s p)\"", "lemma pathVertices_alt: \"p \\<noteq> [] \n    \\<Longrightarrow> pathVertices u p = map fst p @ [snd (last p)]\"", "lemma pathVertices_singleton_iff[simp]: \"pathVertices s p = [u] \\<longleftrightarrow> (p=[] \\<and> s=u)\"", "lemma length_pathVertices_eq[simp]: \"length (pathVertices u p) = length p + 1\"", "lemma pathVertices_edgeset: \"\\<lbrakk>u\\<in>V; isPath u p v\\<rbrakk> \\<Longrightarrow> set (pathVertices u p) \\<subseteq> V\"", "lemma pathVertices_append: \"pathVertices u (p1 @ p2) = \nbutlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2\"", "lemma split_path_at_vertex: \n  assumes \"u\\<in>set (pathVertices_fwd s p)\"\n  assumes \"isPath s p t\"\n  obtains p1 p2 where \"p=p1@p2\" \"isPath s p1 u\" \"isPath u p2 t\"", "lemma split_path_at_vertex_complete: \n  assumes \"isPath s p t\" \"pathVertices_fwd s p = pv1@u#pv2\" \n  obtains p1 p2 where \n    \"p=p1@p2\" \n    \"isPath s p1 u\" \"pathVertices_fwd s p1 = pv1@[u]\" \n    \"isPath u p2 t\" \"pathVertices_fwd u p2 = u#pv2\"", "lemma isPath_fwd_cases: \n  assumes \"isPath s p t\"\n  obtains \"p=[]\" \"t=s\"\n    | p' u where \"p=(s,u)#p'\" \"(s,u)\\<in>E\" \"isPath u p' t\"", "lemma isPath_bwd_cases: \n  assumes \"isPath s p t\"\n  obtains \"p=[]\" \"t=s\"\n    | p' u where \"p=p'@[(u,t)]\" \"isPath s p' u\" \"(u,t)\\<in>E\"", "lemma pathVertices_edge: \"isPath s p t \\<Longrightarrow> e \\<in> set p \\<Longrightarrow> \n  \\<exists>vs1 vs2. pathVertices_fwd s p = vs1 @ fst e # snd e # vs2\"", "lemma pathVertices_edge_old: \"isPath u p v \\<Longrightarrow> e \\<in> set p \\<Longrightarrow> \n  \\<exists>vs1 vs2. pathVertices u p = vs1 @ fst e # snd e # vs2\"", "lemma connected_refl[simp, intro!]: \"connected v v\"", "lemma connected_append_edge: \"connected u v \\<Longrightarrow> (v,w)\\<in>E \\<Longrightarrow> connected u w\"", "lemma connected_inV_iff: \"\\<lbrakk>connected u v\\<rbrakk> \\<Longrightarrow> v\\<in>V \\<longleftrightarrow> u\\<in>V\"", "lemma connected_edgeRtc: \"connected u v \\<longleftrightarrow> (u, v) \\<in> E\\<^sup>*\"", "lemma reachable_ss_V: \"s \\<in> V \\<Longrightarrow> reachableNodes s \\<subseteq> V\"", "lemma reachableNodes_E_closed: \"E``reachableNodes s \\<subseteq> reachableNodes s\"", "lemma isSimplePath_fwd: \"isSimplePath s p t \n  \\<longleftrightarrow> isPath s p t \\<and> distinct (pathVertices_fwd s p)\"", "lemma isSimplePath_singelton[split_path_simps]: \n  \"isSimplePath u [e] v \\<longleftrightarrow> (e=(u,v) \\<and> u\\<noteq>v \\<and> (u,v)\\<in>E)\"", "lemma (in Graph) isSimplePath_append[split_path_simps]: \n  \"isSimplePath s (p1@p2) t \n    \\<longleftrightarrow> (\\<exists>u. \n      isSimplePath s p1 u \n    \\<and> isSimplePath u p2 t \n    \\<and> set (pathVertices_fwd s p1) \\<inter> set (pathVertices_fwd u p2) = {u})\"  \n  (is \"_ \\<longleftrightarrow> ?R\")", "lemma (in Graph) isSimplePath_cons[split_path_simps]: \n  \"isSimplePath s (e#p) t \n  \\<longleftrightarrow> (\\<exists>u. e=(s,u) \\<and> s\\<noteq>u \\<and> (s,u)\\<in>E \n        \\<and> isSimplePath u p t \\<and> s\\<notin>set (pathVertices_fwd u p))\"", "lemma (in Finite_Graph) simplePath_length_less_V:\n  assumes UIV: \"u\\<in>V\"\n  assumes P: \"isSimplePath u p v\" \n  shows \"length p < card V\"", "lemma split_simple_path: \"isSimplePath u (p1@p2) v \n  \\<Longrightarrow> (\\<exists>w. isSimplePath u p1 w \\<and> isSimplePath w p2 v)\"", "lemma simplePath_empty_conv[simp]: \"isSimplePath s [] t \\<longleftrightarrow> s=t\"", "lemma simplePath_same_conv[simp]: \"isSimplePath s p s \\<longleftrightarrow> p=[]\"", "lemma isSPath_pathLE: \"isPath s p t \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t\"", "lemma isSPath_no_selfloop: \"isSimplePath u p v \\<Longrightarrow> (u1, u1) \\<notin> set p\"", "lemma isSPath_sg_outgoing: \"\\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p; v1 \\<noteq> v2\\<rbrakk> \n  \\<Longrightarrow> (u1, v2) \\<notin> set p\"", "lemma isSPath_sg_incoming: \n  \"\\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p; u1 \\<noteq> u2\\<rbrakk> \\<Longrightarrow> (u2, v1) \\<notin> set p\"", "lemma isSPath_nt_parallel:\n  assumes SP: \"isSimplePath s p t\"\n  assumes EIP: \"e\\<in>set p\"\n  shows \"prod.swap e \\<notin> set p\"", "lemma isSPath_nt_parallel_old: \n  \"isSimplePath u p v \\<Longrightarrow> (\\<forall>(u, v) \\<in> set p. (v, u) \\<notin> set p)\"", "lemma isSPath_distinct: \"isSimplePath u p v \\<Longrightarrow> distinct p\"", "lemma adjacent_edges_not_on_path:\n  assumes PATH: \"isPath s p t\"\n  assumes VNV: \"v\\<notin>set (pathVertices_fwd s p)\"\n  shows \"adjacent v \\<inter> set p = {}\"", "lemma adjacent_edges_on_simple_path:\n  assumes SPATH: \"isSimplePath s p t\"\n  assumes VNV: \"v\\<in>set (pathVertices_fwd s p)\" \"v\\<noteq>s\" \"v\\<noteq>t\"\n  obtains p1 u w p2 where \n    \"p = p1@(u,v)#(v,w)#p2\" \n    \"incoming v \\<inter> set p = {(u,v)}\" \n    \"outgoing v \\<inter> set p = {(v,w)}\"", "lemma connected_by_dist: \"connected v v' = (\\<exists>d. dist v d v')\"", "lemma isPath_distD: \"isPath u p v \\<Longrightarrow> dist u (length p) v\"", "lemma\n  shows connected_distI[intro]: \"dist v d v' \\<Longrightarrow> connected v v'\"", "lemma min_distI2: \n  \"\\<lbrakk>connected v v'; \\<And>d. \\<lbrakk>dist v d v'; \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk> \\<Longrightarrow> Q d\\<rbrakk> \n    \\<Longrightarrow> Q (min_dist v v')\"", "lemma min_distI_eq:\n  \"\\<lbrakk> dist v d v'; \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d' \\<rbrakk> \\<Longrightarrow> min_dist v v' = d\"", "lemma dist_z_iff[simp]: \"dist v 0 v' \\<longleftrightarrow> v'=v\"", "lemma dist_z[simp, intro!]: \"dist v 0 v\"", "lemma dist_suc: \"\\<lbrakk>dist v d v'; (v',v'')\\<in>E\\<rbrakk> \\<Longrightarrow> dist v (Suc d) v''\"", "lemma dist_cases[case_names dist_z dist_suc, consumes 1, cases pred]:\n  assumes \"dist v d v'\"\n  obtains \"v=v'\" \"d=0\"\n   | vh dd where \"d=Suc dd\" \"dist v dd vh\" \"(vh,v')\\<in>E\"", "lemma min_dist_z[simp]: \"min_dist v v = 0\"", "lemma min_dist_z_iff[simp]: \"connected v v' \\<Longrightarrow> min_dist v v' = 0 \\<longleftrightarrow> v'=v\"", "lemma min_dist_is_dist: \"connected v v' \\<Longrightarrow> dist v (min_dist v v') v'\"", "lemma min_dist_minD: \"dist v d v' \\<Longrightarrow> min_dist v v' \\<le> d\"", "lemma min_dist_succ: \n  \"\\<lbrakk> connected v v'; (v',v'') \\<in> E \\<rbrakk> \\<Longrightarrow> min_dist v v'' \\<le> Suc (min_dist v v') \"", "lemma min_dist_suc:\n  assumes c: \"connected v v'\" \"min_dist v v' = Suc d\"\n  shows \"\\<exists>v''. connected v v'' \\<and> (v'',v') \\<in> E \\<and> min_dist v v'' = d\"", "lemma min_dist_less:\n  assumes \"connected src v\" \"min_dist src v = d\" and \"d' < d\"\n  shows \"\\<exists>v'. connected src v' \\<and> min_dist src v' = d'\"", "lemma dist_trans[trans]: \"dist u d1 w \\<Longrightarrow> dist w d2 v \\<Longrightarrow> dist u (d1+d2) v\"", "lemma min_dist_split:\n  assumes D1: \"dist u d1 w\" and D2: \"dist w d2 v\" and MIN: \"min_dist u v = d1+d2\"\n  shows \"min_dist u w = d1\" \"min_dist w v = d2\"", "lemma \\<comment> \\<open>Manual proof\\<close>\n  assumes D1: \"dist u d1 w\" and D2: \"dist w d2 v\" and MIN: \"min_dist u v = d1+d2\"\n  shows \"min_dist u w = d1\" \"min_dist w v = d2\"", "lemma isShortestPath_min_dist_def: \n  \"isShortestPath u p v \\<longleftrightarrow> isPath u p v \\<and> length p = min_dist u v\"", "lemma obtain_shortest_path: \n  assumes CONN: \"connected u v\"  \n  obtains p where \"isShortestPath u p v\"", "lemma shortestPath_is_simple:\n  assumes \"isShortestPath s p t\"\n  shows \"isSimplePath s p t\"", "lemma isShortestPath_alt: \n  \"isShortestPath u p v \\<longleftrightarrow> isSimplePath u p v \\<and> length p = min_dist u v\"", "lemma shortestPath_is_path: \"isShortestPath u p v \\<Longrightarrow> isPath u p v\"", "lemma split_shortest_path: \"isShortestPath u (p1@p2) v \n  \\<Longrightarrow> (\\<exists>w. isShortestPath u p1 w \\<and> isShortestPath w p2 v)\"", "lemma isShortestPath_level_edge:  \n  assumes SP: \"isShortestPath s p t\" \n  assumes EIP: \"(u,v)\\<in>set p\"\n  shows \n    \"connected s u\" \"connected u v\" \"connected v t\" and\n    \"min_dist s v = min_dist s u + 1\" (is ?G1) and\n    \"min_dist u t = 1 + min_dist v t\" (is ?G2) and\n    \"min_dist s t = min_dist s u + 1 + min_dist v t\" (is ?G3)", "lemma isShortestPath_length_less_V:   \n  assumes SV: \"s\\<in>V\"\n  assumes PATH: \"isShortestPath s p t\"\n  shows \"length p < card V\""], "translations": [["", "lemma finite_Image: fixes R shows \"\\<lbrakk> finite R \\<rbrakk> \\<Longrightarrow> finite (R `` A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite R \\<Longrightarrow> finite (R `` A)", "by (meson Image_iff finite_Range Range.intros finite_subset subsetI)"], ["", "lemma map_eq_appendE: \n  assumes \"map f ls = fl@fl'\"\n  obtains l l' where \"ls=l@l'\" and \"map f l=fl\" and  \"map f l' = fl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>ls = l @ l'; map f l = fl; map f l' = fl'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using that[of \"take (length fl) ls\" \"drop (length fl) ls\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>ls = take (length fl) ls @ drop (length fl) ls;\n   map f (take (length fl) ls) = fl;\n   map f (drop (length fl) ls) = fl'\\<rbrakk>\n  \\<Longrightarrow> thesis\n  map f ls = fl @ fl'\n\ngoal (1 subgoal):\n 1. (\\<And>l l'.\n        \\<lbrakk>ls = l @ l'; map f l = fl; map f l' = fl'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: take_map[symmetric] drop_map[symmetric])"], ["", "subsection \\<open>Definitions\\<close>"], ["", "subsubsection \\<open>Basic Definitions\\<close>"], ["", "text \\<open>\n  We fix the nodes to be natural numbers.\n\\<close>"], ["", "type_synonym node = nat"], ["", "type_synonym edge = \"node \\<times> node\""], ["", "text \\<open>\n  The capacities are left polymorphic, however, they\n  are restricted to linearly ordered domains.\n\\<close>"], ["", "type_synonym 'capacity graph = \"edge \\<Rightarrow> 'capacity\""], ["", "locale Graph = fixes c :: \"'capacity::linordered_idom graph\"\nbegin"], ["", "definition E :: \"edge set\" \\<comment> \\<open>Edges of the graph\\<close>\nwhere \"E \\<equiv> {(u, v). c (u, v) \\<noteq> 0}\""], ["", "definition V :: \"node set\" \\<comment> \\<open>Nodes of the graph. Exactly the nodes \n  that have adjacent edges.\\<close>\nwhere \"V \\<equiv> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E}\""], ["", "definition incoming :: \"node \\<Rightarrow> edge set\" \\<comment> \\<open>Incoming edges into a node\\<close>\nwhere \"incoming v \\<equiv> {(u, v) | u. (u, v) \\<in> E}\""], ["", "definition outgoing :: \"node \\<Rightarrow> edge set\" \\<comment> \\<open>Outgoing edges from a node\\<close>\nwhere \"outgoing v \\<equiv> {(v, u) | u. (v, u) \\<in> E}\""], ["", "definition adjacent :: \"node \\<Rightarrow> edge set\" \\<comment> \\<open>Adjacent edges of a node\\<close>\nwhere \"adjacent v \\<equiv> incoming v \\<union> outgoing v\""], ["", "definition incoming' :: \"node set \\<Rightarrow> edge set\" \\<comment> \\<open>Incoming edges into \n  a set of nodes\\<close>\nwhere \"incoming' k \\<equiv> {(u, v) | u v. u \\<notin> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E}\""], ["", "definition outgoing' :: \"node set \\<Rightarrow> edge set\" \\<comment> \\<open>Outgoing edges from \n  a set of nodes\\<close>\nwhere \"outgoing' k \\<equiv> {(v, u) | u v. u \\<notin> k \\<and> v \\<in> k \\<and> (v, u) \\<in> E}\""], ["", "definition adjacent' :: \"node set \\<Rightarrow> edge set\" \\<comment> \\<open>Edges adjacent to a \n  set of nodes\\<close>\nwhere \"adjacent' k \\<equiv> incoming' k \\<union> outgoing' k\""], ["", "definition is_adj_map :: \"(node \\<Rightarrow> node list) \\<Rightarrow> bool\" where\n  \"is_adj_map ps \\<equiv> (\\<forall>u. distinct (ps u) \\<and> set (ps u) = E``{u} \\<union> E\\<inverse>``{u})\""], ["", "definition \"adjacent_nodes u \\<equiv> E``{u} \\<union> E\\<inverse>``{u}\""], ["", "end \\<comment> \\<open>Graph\\<close>"], ["", "subsubsection \\<open>Finite Graphs\\<close>"], ["", "locale Finite_Graph = Graph +\n  assumes finite_V[simp, intro!]: \"finite V\""], ["", "subsubsection \\<open>Paths\\<close>"], ["", "type_synonym path = \"edge list\""], ["", "context Graph\nbegin"], ["", "fun isPath :: \"node \\<Rightarrow> path \\<Rightarrow> node \\<Rightarrow> bool\" \n  where\n    \"isPath u [] v \\<longleftrightarrow> u = v\"\n  | \"isPath u ((x,y)#p) v \\<longleftrightarrow> u = x \\<and> (x, y) \\<in> E \\<and> isPath y p v\""], ["", "fun pathVertices :: \"node \\<Rightarrow> path \\<Rightarrow> node list\"\n  where\n    \"pathVertices u [] = [u]\"\n  | \"pathVertices u (e # es) = fst e # (pathVertices (snd e) es)\""], ["", "(* TODO: This characterization is probably nicer to work with! Exchange! *)"], ["", "definition (in Graph) pathVertices_fwd :: \"node \\<Rightarrow> edge list \\<Rightarrow> node list\" \n    where \"pathVertices_fwd u p = u#map snd p\""], ["", "lemma (in Graph) pathVertices_fwd: \n    assumes \"isPath u p v\"\n    shows \"pathVertices u p = pathVertices_fwd u p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices u p = pathVertices_fwd u p", "unfolding pathVertices_fwd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices u p = u # map snd p", "using assms"], ["proof (prove)\nusing this:\n  isPath u p v\n\ngoal (1 subgoal):\n 1. pathVertices u p = u # map snd p", "apply (induction p arbitrary: u)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u.\n       isPath u [] v \\<Longrightarrow> pathVertices u [] = u # map snd []\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow>\n                   pathVertices u p = u # map snd p;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> pathVertices u (a # p) = u # map snd (a # p)", "by auto"], ["", "definition connected :: \"node \\<Rightarrow> node \\<Rightarrow> bool\" \n    where \"connected u v \\<equiv> \\<exists>p. isPath u p v\""], ["", "abbreviation (input) \"isReachable \\<equiv> connected\""], ["", "(* Deprecated *)"], ["", "definition reachableNodes :: \"node \\<Rightarrow> node set\"  \n    where \"reachableNodes u \\<equiv> {v. connected u v}\""], ["", "definition isShortestPath :: \"node \\<Rightarrow> path \\<Rightarrow> node \\<Rightarrow> bool\" \n    where \"isShortestPath u p v \n    \\<equiv> isPath u p v \\<and> (\\<forall>p'. isPath u p' v \\<longrightarrow> length p \\<le> length p')\""], ["", "definition isSimplePath :: \"node \\<Rightarrow> path \\<Rightarrow> node \\<Rightarrow> bool\" \n    where \"isSimplePath u p v \\<equiv> isPath u p v \\<and> distinct (pathVertices u p)\""], ["", "definition dist :: \"node \\<Rightarrow> nat \\<Rightarrow> node \\<Rightarrow> bool\" \n    \\<comment> \\<open>There is a path of given length between the nodes\\<close>\n    where \"dist v d v' \\<equiv> \\<exists>p. isPath v p v' \\<and> length p = d\""], ["", "definition min_dist :: \"node \\<Rightarrow> node \\<Rightarrow> nat\"\n    \\<comment> \\<open>Minimum distance between two connected nodes\\<close>\n    where \"min_dist v v' = (LEAST d. dist v d v')\""], ["", "end"], ["", "subsection \\<open>Properties\\<close>"], ["", "subsubsection \\<open>Basic Properties\\<close>"], ["", "context Graph\nbegin"], ["", "lemma V_alt: \"V = fst`E \\<union> snd`E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V = fst ` E \\<union> snd ` E", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} =\n    fst ` E \\<union> snd ` E", "by force"], ["", "lemma E_ss_VxV: \"E \\<subseteq> V\\<times>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> V \\<times> V", "by (auto simp: V_def)"], ["", "lemma adjacent_nodes_ss_V: \"adjacent_nodes u \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent_nodes u \\<subseteq> V", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {u} \\<union> E\\<inverse> `` {u} \\<subseteq> V", "using E_ss_VxV"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n\ngoal (1 subgoal):\n 1. E `` {u} \\<union> E\\<inverse> `` {u} \\<subseteq> V", "by auto"], ["", "lemma Vfin_imp_Efin[simp, intro]: assumes \"finite V\" shows \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "using E_ss_VxV assms"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n  finite V\n\ngoal (1 subgoal):\n 1. finite E", "by (auto intro: finite_subset)"], ["", "lemma Efin_imp_Vfin: \"finite E \\<Longrightarrow> finite V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite V", "unfolding V_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite (fst ` E \\<union> snd ` E)", "by auto"], ["", "lemma zero_cap_simp[simp]: \"(u,v)\\<notin>E \\<Longrightarrow> c (u,v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow> c (u, v) = (0::'capacity)", "by (auto simp: E_def)"], ["", "lemma succ_ss_V: \"E``{u} \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {u} \\<subseteq> V", "by (auto simp: V_def)"], ["", "lemma pred_ss_V: \"E\\<inverse>``{u} \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E\\<inverse> `` {u} \\<subseteq> V", "by (auto simp: V_def)"], ["", "lemma \n  incoming_edges: \"incoming u \\<subseteq> E\" and\n  outgoing_edges: \"outgoing u \\<subseteq> E\" and\n  incoming'_edges: \"incoming' U \\<subseteq> E\" and\n  outgoing'_edges: \"outgoing' U \\<subseteq> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (incoming u \\<subseteq> E &&& outgoing u \\<subseteq> E) &&&\n    incoming' U \\<subseteq> E &&& outgoing' U \\<subseteq> E", "by (auto simp: incoming_def outgoing_def incoming'_def outgoing'_def)"], ["", "lemma \n  incoming_alt: \"incoming u = (\\<lambda>v. (v,u))`(E\\<inverse>``{u})\" and\n  outgoing_alt: \"outgoing u = Pair u`(E``{u})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incoming u = (\\<lambda>v. (v, u)) ` E\\<inverse> `` {u} &&&\n    outgoing u = Pair u ` E `` {u}", "by (auto simp: incoming_def outgoing_def)"], ["", "lemma \n  finite_incoming[simp, intro]: \"finite V \\<Longrightarrow> finite (incoming u)\" and\n  finite_outgoing[simp, intro]: \"finite V \\<Longrightarrow> finite (outgoing u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite V \\<Longrightarrow> finite (incoming u)) &&&\n    (finite V \\<Longrightarrow> finite (outgoing u))", "by (auto simp: incoming_alt outgoing_alt intro: finite_Image)"], ["", "lemma \n  finite_incoming'[simp, intro]: \"finite V \\<Longrightarrow> finite (incoming' U)\" and\n  finite_outgoing'[simp, intro]: \"finite V \\<Longrightarrow> finite (outgoing' U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (finite V \\<Longrightarrow> finite (incoming' U)) &&&\n    (finite V \\<Longrightarrow> finite (outgoing' U))", "by (auto \n    intro: finite_subset[OF incoming'_edges] \n    intro: finite_subset[OF outgoing'_edges])"], ["", "subsubsection \\<open>Summations over Edges and Nodes\\<close>"], ["", "text \\<open>We provide useful alternative characterizations for summation over \n    all incoming or outgoing edges.\\<close>"], ["", "lemma sum_outgoing_pointwise: \"(\\<Sum>e\\<in>outgoing u. g e) = (\\<Sum>v\\<in>E``{u}. g (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "have \"(\\<Sum>e\\<in>outgoing u. g e) = (\\<Sum>e\\<in>(\\<lambda>v. (u,v))`(E``{u}). g e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (outgoing u) = sum g (Pair u ` E `` {u})", "by (rule sum.cong) (auto simp: outgoing_def)"], ["proof (state)\nthis:\n  sum g (outgoing u) = sum g (Pair u ` E `` {u})\n\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "also"], ["proof (state)\nthis:\n  sum g (outgoing u) = sum g (Pair u ` E `` {u})\n\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "have \"\\<dots> = (\\<Sum>v\\<in>E``{u}. g (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (Pair u ` E `` {u}) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "by (subst sum.reindex)(auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  sum g (Pair u ` E `` {u}) = (\\<Sum>v\\<in>E `` {u}. g (u, v))\n\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "finally"], ["proof (chain)\npicking this:\n  sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))\n\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))", "."], ["proof (state)\nthis:\n  sum g (outgoing u) = (\\<Sum>v\\<in>E `` {u}. g (u, v))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_incoming_pointwise: \"(\\<Sum>e\\<in>incoming u. g e) = (\\<Sum>v\\<in>E\\<inverse>``{u}. g (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "have \"(\\<Sum>e\\<in>incoming u. g e) = (\\<Sum>e\\<in>(\\<lambda>v. (v,u))`(E\\<inverse>``{u}). g e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (incoming u) = sum g ((\\<lambda>v. (v, u)) ` E\\<inverse> `` {u})", "by (rule sum.cong) (auto simp: incoming_def)"], ["proof (state)\nthis:\n  sum g (incoming u) = sum g ((\\<lambda>v. (v, u)) ` E\\<inverse> `` {u})\n\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "also"], ["proof (state)\nthis:\n  sum g (incoming u) = sum g ((\\<lambda>v. (v, u)) ` E\\<inverse> `` {u})\n\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "have \"\\<dots> = (\\<Sum>v\\<in>E\\<inverse>``{u}. g (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g ((\\<lambda>v. (v, u)) ` E\\<inverse> `` {u}) =\n    (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "by (subst sum.reindex)(auto simp add: inj_on_def)"], ["proof (state)\nthis:\n  sum g ((\\<lambda>v. (v, u)) ` E\\<inverse> `` {u}) =\n  (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))\n\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "finally"], ["proof (chain)\npicking this:\n  sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "show ?thesis"], ["proof (prove)\nusing this:\n  sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))\n\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))", "."], ["proof (state)\nthis:\n  sum g (incoming u) = (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Extend summations over incoming/outgoing edges to summations over\n  all nodes, provided the summed-up function is zero for non-edges.\\<close>"], ["", "lemma (in Finite_Graph) sum_incoming_extend:  \n  assumes \"\\<And>v. \\<lbrakk> v\\<in>V; (v,u)\\<notin>E \\<rbrakk> \\<Longrightarrow> g (v,u) = 0\"\n  shows \"(\\<Sum>e\\<in>incoming u. g e) = (\\<Sum>v\\<in>V. g (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (incoming u) = (\\<Sum>v\\<in>V. g (v, u))", "apply (subst sum_incoming_pointwise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>E\\<inverse> `` {u}. g (v, u)) = (\\<Sum>v\\<in>V. g (v, u))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite V\n 2. E\\<inverse> `` {u} \\<subseteq> V\n 3. \\<forall>i\\<in>V - E\\<inverse> `` {u}. g (i, u) = (0::'b)", "using assms pred_ss_V"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; (?v, u) \\<notin> E\\<rbrakk>\n  \\<Longrightarrow> g (?v, u) = (0::'b)\n  E\\<inverse> `` {?u} \\<subseteq> V\n\ngoal (3 subgoals):\n 1. finite V\n 2. E\\<inverse> `` {u} \\<subseteq> V\n 3. \\<forall>i\\<in>V - E\\<inverse> `` {u}. g (i, u) = (0::'b)", "by auto"], ["", "lemma (in Finite_Graph) sum_outgoing_extend:  \n  assumes \"\\<And>v. \\<lbrakk> v\\<in>V; (u,v)\\<notin>E \\<rbrakk> \\<Longrightarrow> g (u,v) = 0\"\n  shows \"(\\<Sum>e\\<in>outgoing u. g e) = (\\<Sum>v\\<in>V. g (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g (outgoing u) = (\\<Sum>v\\<in>V. g (u, v))", "apply (subst sum_outgoing_pointwise)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>E `` {u}. g (u, v)) = (\\<Sum>v\\<in>V. g (u, v))", "apply (rule sum.mono_neutral_left)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite V\n 2. E `` {u} \\<subseteq> V\n 3. \\<forall>i\\<in>V - E `` {u}. g (u, i) = (0::'b)", "using assms succ_ss_V"], ["proof (prove)\nusing this:\n  \\<lbrakk>?v \\<in> V; (u, ?v) \\<notin> E\\<rbrakk>\n  \\<Longrightarrow> g (u, ?v) = (0::'b)\n  E `` {?u} \\<subseteq> V\n\ngoal (3 subgoals):\n 1. finite V\n 2. E `` {u} \\<subseteq> V\n 3. \\<forall>i\\<in>V - E `` {u}. g (u, i) = (0::'b)", "by auto"], ["", "text \\<open>When summation is done over something that satisfies the capacity \n  constraint, e.g., a flow, the summation can be extended to all \n  outgoing/incoming edges, as the additional edges must have zero capacity.\\<close>"], ["", "(* TODO: Historical lemmas. Get rid of \\<forall> quantifier. *)"], ["", "lemma (in Finite_Graph) sum_outgoing_alt: \"\\<lbrakk>\\<forall>e. 0 \\<le> g e \\<and> g e \\<le> c e\\<rbrakk> \\<Longrightarrow>\n  \\<forall>v \\<in> V. (\\<Sum>e \\<in> outgoing v. g e) = (\\<Sum>u \\<in> V. g (v, u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e \\<Longrightarrow>\n    \\<forall>v\\<in>V. sum g (outgoing v) = (\\<Sum>u\\<in>V. g (v, u))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e;\n        v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> sum g (outgoing v) = (\\<Sum>u\\<in>V. g (v, u))", "apply (rule sum_outgoing_extend)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v u.\n       \\<lbrakk>\\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e;\n        v \\<in> V; u \\<in> V; (v, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> g (v, u) = (0::'a)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v u.\n       \\<lbrakk>\\<forall>a b.\n                   (0::'a) \\<le> g (a, b) \\<and> g (a, b) \\<le> c (a, b);\n        v \\<in> V; u \\<in> V; (v, u) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> g (v, u) = (0::'a)", "by (metis antisym zero_cap_simp)"], ["", "lemma (in Finite_Graph) sum_incoming_alt: \"\\<lbrakk>\\<forall>e. 0 \\<le> g e \\<and> g e \\<le> c e\\<rbrakk> \\<Longrightarrow>\n  \\<forall>v \\<in> V. (\\<Sum>e \\<in> incoming v. g e) = (\\<Sum>u \\<in> V. g (u, v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e \\<Longrightarrow>\n    \\<forall>v\\<in>V. sum g (incoming v) = (\\<Sum>u\\<in>V. g (u, v))", "apply (rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>\\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e;\n        v \\<in> V\\<rbrakk>\n       \\<Longrightarrow> sum g (incoming v) = (\\<Sum>u\\<in>V. g (u, v))", "apply (rule sum_incoming_extend)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v u.\n       \\<lbrakk>\\<forall>e. (0::'a) \\<le> g e \\<and> g e \\<le> c e;\n        v \\<in> V; u \\<in> V; (u, v) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> g (u, v) = (0::'a)", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v u.\n       \\<lbrakk>\\<forall>a b.\n                   (0::'a) \\<le> g (a, b) \\<and> g (a, b) \\<le> c (a, b);\n        v \\<in> V; u \\<in> V; (u, v) \\<notin> E\\<rbrakk>\n       \\<Longrightarrow> g (u, v) = (0::'a)", "by (metis antisym zero_cap_simp)"], ["", "subsubsection \\<open>Finite Graphs\\<close>"], ["", "lemma (in Finite_Graph) finite_E[simp,intro!]: \"finite E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E", "by simp"], ["", "lemma (in Graph) Finite_Graph_EI: \"finite E \\<Longrightarrow> Finite_Graph c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> Finite_Graph c", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite E \\<Longrightarrow> finite V", "by (rule Efin_imp_Vfin)"], ["", "lemma (in Finite_Graph) adjacent_nodes_finite[simp, intro!]: \"finite (adjacent_nodes u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (adjacent_nodes u)", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (E `` {u} \\<union> E\\<inverse> `` {u})", "by (auto intro: finite_Image)"], ["", "subsubsection \\<open>Paths\\<close>"], ["", "named_theorems split_path_simps \\<open>Simplification lemmas to split paths\\<close>"], ["", "lemma transfer_path:\n  \\<comment> \\<open>Transfer path to another graph\\<close>\n  assumes \"set p\\<inter>E \\<subseteq> Graph.E c'\"\n  assumes \"isPath u p v\"\n  shows \"Graph.isPath c' u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Graph.isPath c' u p v", "using assms"], ["proof (prove)\nusing this:\n  set p \\<inter> E \\<subseteq> Graph.E c'\n  isPath u p v\n\ngoal (1 subgoal):\n 1. Graph.isPath c' u p v", "apply (induction u p v rule: isPath.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>u v.\n       \\<lbrakk>set [] \\<inter> E \\<subseteq> Graph.E c';\n        isPath u [] v\\<rbrakk>\n       \\<Longrightarrow> Graph.isPath c' u [] v\n 2. \\<And>u x y p v.\n       \\<lbrakk>\\<lbrakk>set p \\<inter> E \\<subseteq> Graph.E c';\n                 isPath y p v\\<rbrakk>\n                \\<Longrightarrow> Graph.isPath c' y p v;\n        set ((x, y) # p) \\<inter> E \\<subseteq> Graph.E c';\n        isPath u ((x, y) # p) v\\<rbrakk>\n       \\<Longrightarrow> Graph.isPath c' u ((x, y) # p) v", "apply (auto simp: Graph.isPath.simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isPath_append[split_path_simps]: \n  \"isPath u (p1 @ p2) v \\<longleftrightarrow> (\\<exists>w. isPath u p1 w \\<and> isPath w p2 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u (p1 @ p2) v = (\\<exists>w. isPath u p1 w \\<and> isPath w p2 v)", "by (induction p1 arbitrary: u) auto"], ["", "lemma isPath_head[split_path_simps]: \n  \"isPath u (e#p) v \\<longleftrightarrow> fst e = u \\<and> e \\<in> E \\<and> isPath (snd e) p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u (e # p) v =\n    (fst e = u \\<and> e \\<in> E \\<and> isPath (snd e) p v)", "by (cases e) auto"], ["", "lemma isPath_head2: \n  \"isPath u (e#p) v \\<Longrightarrow> (p = [] \\<or> (p \\<noteq> [] \\<and> fst (hd p) = snd e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u (e # p) v \\<Longrightarrow>\n    p = [] \\<or> p \\<noteq> [] \\<and> fst (hd p) = snd e", "by (metis Graph.isPath_head list.collapse)"], ["", "lemma isPath_tail: \n  \"isPath u (p@[e]) v \\<longleftrightarrow> isPath u p (fst e) \\<and> e \\<in> E \\<and> snd e = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u (p @ [e]) v =\n    (isPath u p (fst e) \\<and> e \\<in> E \\<and> snd e = v)", "by (induction p) (auto simp: isPath_append isPath_head)"], ["", "lemma isPath_tail2: \n  \"isPath u (p@[e]) v \\<Longrightarrow> (p = [] \\<or> (p \\<noteq> [] \\<and> snd (last p) = fst e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u (p @ [e]) v \\<Longrightarrow>\n    p = [] \\<or> p \\<noteq> [] \\<and> snd (last p) = fst e", "by (metis Graph.isPath_tail append_butlast_last_id)"], ["", "(* TODO: Really needed? *)"], ["", "lemma isPath_append_edge: \n  \"isPath v p v' \\<Longrightarrow> (v',v'')\\<in>E \\<Longrightarrow> isPath v (p@[(v',v'')]) v''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath v p v'; (v', v'') \\<in> E\\<rbrakk>\n    \\<Longrightarrow> isPath v (p @ [(v', v'')]) v''", "by (auto simp: isPath_append)"], ["", "lemma isPath_edgeset: \"\\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk> \\<Longrightarrow> e \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> e \\<in> E", "using E_def"], ["proof (prove)\nusing this:\n  E \\<equiv> {(u, v). c (u, v) \\<noteq> (0::'capacity)}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> e \\<in> E", "by (metis isPath_head isPath_append in_set_conv_decomp_first)"], ["", "lemma isPath_rtc: \"isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "proof (induction p arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u. isPath u [] v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "case Nil"], ["proof (state)\nthis:\n  isPath u [] v\n\ngoal (2 subgoals):\n 1. \\<And>u. isPath u [] v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*\n 2. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  isPath u [] v\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "case (Cons e es)"], ["proof (state)\nthis:\n  isPath ?u es v \\<Longrightarrow> (?u, v) \\<in> E\\<^sup>*\n  isPath u (e # es) v\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "obtain u1 u2 where \"e = (u1, u2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u1 u2. e = (u1, u2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply (cases e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>u1 u2. e = (u1, u2) \\<Longrightarrow> thesis;\n        e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  e = (u1, u2)\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  e = (u1, u2)", "have \"u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E\""], ["proof (prove)\nusing this:\n  e = (u1, u2)\n\ngoal (1 subgoal):\n 1. u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E", "using isPath.simps(2) Cons.prems"], ["proof (prove)\nusing this:\n  e = (u1, u2)\n  isPath ?u ((?x, ?y) # ?p) ?v =\n  (?u = ?x \\<and> (?x, ?y) \\<in> E \\<and> isPath ?y ?p ?v)\n  isPath u (e # es) v\n\ngoal (1 subgoal):\n 1. u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E", "by auto"], ["proof (state)\nthis:\n  u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "then"], ["proof (chain)\npicking this:\n  u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E", "have \"(u, u2) \\<in> E\" and \"(u2, v) \\<in> E\\<^sup>*\""], ["proof (prove)\nusing this:\n  u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E\n\ngoal (1 subgoal):\n 1. (u, u2) \\<in> E &&& (u2, v) \\<in> E\\<^sup>*", "using Cons.IH"], ["proof (prove)\nusing this:\n  u = u1 \\<and> isPath u2 es v \\<and> (u1, u2) \\<in> E\n  isPath ?u es v \\<Longrightarrow> (?u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, u2) \\<in> E &&& (u2, v) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (u, u2) \\<in> E\n  (u2, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<And>a p u.\n       \\<lbrakk>\\<And>u.\n                   isPath u p v \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*;\n        isPath u (a # p) v\\<rbrakk>\n       \\<Longrightarrow> (u, v) \\<in> E\\<^sup>*", "thus ?case"], ["proof (prove)\nusing this:\n  (u, u2) \\<in> E\n  (u2, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "by auto"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtc_isPath: \"(u, v) \\<in> E\\<^sup>* \\<Longrightarrow> (\\<exists>p. isPath u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>* \\<Longrightarrow> \\<exists>p. isPath u p v", "proof (induction rule: rtrancl.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a. \\<exists>p. isPath a p a\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "case (rtrancl_refl a)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>a. \\<exists>p. isPath a p a\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "have \"isPath a [] a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath a [] a", "by simp"], ["proof (state)\nthis:\n  isPath a [] a\n\ngoal (2 subgoals):\n 1. \\<And>a. \\<exists>p. isPath a p a\n 2. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "thus ?case"], ["proof (prove)\nusing this:\n  isPath a [] a\n\ngoal (1 subgoal):\n 1. \\<exists>p. isPath a p a", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. isPath a p a\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "case (rtrancl_into_rtrancl u u' v)"], ["proof (state)\nthis:\n  (u, u') \\<in> E\\<^sup>*\n  (u', v) \\<in> E\n  \\<exists>p. isPath u p u'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "then"], ["proof (chain)\npicking this:\n  (u, u') \\<in> E\\<^sup>*\n  (u', v) \\<in> E\n  \\<exists>p. isPath u p u'", "obtain p1 where \"isPath u p1 u'\""], ["proof (prove)\nusing this:\n  (u, u') \\<in> E\\<^sup>*\n  (u', v) \\<in> E\n  \\<exists>p. isPath u p u'\n\ngoal (1 subgoal):\n 1. (\\<And>p1. isPath u p1 u' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  isPath u p1 u'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "moreover"], ["proof (state)\nthis:\n  isPath u p1 u'\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "have \"(u', v) \\<in> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u', v) \\<in> E", "using rtrancl_into_rtrancl.hyps(2)"], ["proof (prove)\nusing this:\n  (u', v) \\<in> E\n\ngoal (1 subgoal):\n 1. (u', v) \\<in> E", "by simp"], ["proof (state)\nthis:\n  (u', v) \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "ultimately"], ["proof (chain)\npicking this:\n  isPath u p1 u'\n  (u', v) \\<in> E", "have \"isPath u (p1 @ [(u', v)]) v\""], ["proof (prove)\nusing this:\n  isPath u p1 u'\n  (u', v) \\<in> E\n\ngoal (1 subgoal):\n 1. isPath u (p1 @ [(u', v)]) v", "using isPath_tail"], ["proof (prove)\nusing this:\n  isPath u p1 u'\n  (u', v) \\<in> E\n  isPath ?u (?p @ [?e]) ?v =\n  (isPath ?u ?p (fst ?e) \\<and> ?e \\<in> E \\<and> snd ?e = ?v)\n\ngoal (1 subgoal):\n 1. isPath u (p1 @ [(u', v)]) v", "by simp"], ["proof (state)\nthis:\n  isPath u (p1 @ [(u', v)]) v\n\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>(a, b) \\<in> E\\<^sup>*; \\<exists>p. isPath a p b;\n        (b, c) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p. isPath a p c", "thus ?case"], ["proof (prove)\nusing this:\n  isPath u (p1 @ [(u', v)]) v\n\ngoal (1 subgoal):\n 1. \\<exists>p. isPath u p v", "by blast"], ["proof (state)\nthis:\n  \\<exists>p. isPath u p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rtci_isPath: \"(v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow> (\\<exists>p. isPath u p v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. isPath u p v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. isPath u p v", "assume \"(v,u)\\<in>(E\\<inverse>)\\<^sup>*\""], ["proof (state)\nthis:\n  (v, u) \\<in> (E\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. isPath u p v", "hence \"(u,v)\\<in>E\\<^sup>*\""], ["proof (prove)\nusing this:\n  (v, u) \\<in> (E\\<inverse>)\\<^sup>*\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E\\<^sup>*", "by (rule rtrancl_converseD)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> (E\\<inverse>)\\<^sup>* \\<Longrightarrow>\n    \\<exists>p. isPath u p v", "thus ?thesis"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\\<^sup>*\n\ngoal (1 subgoal):\n 1. \\<exists>p. isPath u p v", "by (rule rtc_isPath)"], ["proof (state)\nthis:\n  \\<exists>p. isPath u p v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isPath_ex_edge1: \n  assumes \"isPath u p v\"\n  assumes \"(u1, v1) \\<in> set p\"\n  assumes \"u1 \\<noteq> u\"\n  shows \"\\<exists>u2. (u2, u1) \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "obtain w1 w2 where obt1: \"p = w1 @ [(u1, v1)] @ w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        p = w1 @ [(u1, v1)] @ w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (u1, v1) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        p = w1 @ [(u1, v1)] @ w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Cons append_Nil in_set_conv_decomp_first)"], ["proof (state)\nthis:\n  p = w1 @ [(u1, v1)] @ w2\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  p = w1 @ [(u1, v1)] @ w2", "have \"isPath u w1 u1\""], ["proof (prove)\nusing this:\n  p = w1 @ [(u1, v1)] @ w2\n\ngoal (1 subgoal):\n 1. isPath u w1 u1", "using assms(1) isPath_append"], ["proof (prove)\nusing this:\n  p = w1 @ [(u1, v1)] @ w2\n  isPath u p v\n  isPath ?u (?p1.0 @ ?p2.0) ?v =\n  (\\<exists>w. isPath ?u ?p1.0 w \\<and> isPath w ?p2.0 ?v)\n\ngoal (1 subgoal):\n 1. isPath u w1 u1", "by auto"], ["proof (state)\nthis:\n  isPath u w1 u1\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "have \"w1 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w1 \\<noteq> []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w1 \\<noteq> [] \\<Longrightarrow> False", "assume \"\\<not> w1 \\<noteq> []\""], ["proof (state)\nthis:\n  \\<not> w1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> w1 \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> w1 \\<noteq> []", "have \"u = u1\""], ["proof (prove)\nusing this:\n  \\<not> w1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. u = u1", "using \\<open>isPath u w1 u1\\<close>"], ["proof (prove)\nusing this:\n  \\<not> w1 \\<noteq> []\n  isPath u w1 u1\n\ngoal (1 subgoal):\n 1. u = u1", "by (metis isPath.simps(1))"], ["proof (state)\nthis:\n  u = u1\n\ngoal (1 subgoal):\n 1. \\<not> w1 \\<noteq> [] \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  u = u1\n\ngoal (1 subgoal):\n 1. False", "using assms(3)"], ["proof (prove)\nusing this:\n  u = u1\n  u1 \\<noteq> u\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  w1 \\<noteq> []", "obtain e w1' where obt2:\"w1 = w1' @ [e]\""], ["proof (prove)\nusing this:\n  w1 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>w1' e. w1 = w1' @ [e] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_butlast_last_id)"], ["proof (state)\nthis:\n  w1 = w1' @ [e]\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  w1 = w1' @ [e]", "obtain u2 where \"e = (u2, u1)\""], ["proof (prove)\nusing this:\n  w1 = w1' @ [e]\n\ngoal (1 subgoal):\n 1. (\\<And>u2. e = (u2, u1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>isPath u w1 u1\\<close> isPath_tail"], ["proof (prove)\nusing this:\n  w1 = w1' @ [e]\n  isPath u w1 u1\n  isPath ?u (?p @ [?e]) ?v =\n  (isPath ?u ?p (fst ?e) \\<and> ?e \\<in> E \\<and> snd ?e = ?v)\n\ngoal (1 subgoal):\n 1. (\\<And>u2. e = (u2, u1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  e = (u2, u1)\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  e = (u2, u1)", "have \"p = w1' @ (u2, u1) # (u1, v1) # w2\""], ["proof (prove)\nusing this:\n  e = (u2, u1)\n\ngoal (1 subgoal):\n 1. p = w1' @ (u2, u1) # (u1, v1) # w2", "using obt1 obt2"], ["proof (prove)\nusing this:\n  e = (u2, u1)\n  p = w1 @ [(u1, v1)] @ w2\n  w1 = w1' @ [e]\n\ngoal (1 subgoal):\n 1. p = w1' @ (u2, u1) # (u1, v1) # w2", "by auto"], ["proof (state)\nthis:\n  p = w1' @ (u2, u1) # (u1, v1) # w2\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = w1' @ (u2, u1) # (u1, v1) # w2\n\ngoal (1 subgoal):\n 1. \\<exists>u2. (u2, u1) \\<in> set p", "by auto"], ["proof (state)\nthis:\n  \\<exists>u2. (u2, u1) \\<in> set p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isPath_ex_edge2: \n  assumes \"isPath u p v\"\n  assumes \"(u1, v1) \\<in> set p\"\n  assumes \"v1 \\<noteq> v\"\n  shows \"\\<exists>v2. (v1, v2) \\<in> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "obtain w1 w2 where obt1: \"p = w1 @ [(u1, v1)] @ w2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        p = w1 @ [(u1, v1)] @ w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms(2)"], ["proof (prove)\nusing this:\n  (u1, v1) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>w1 w2.\n        p = w1 @ [(u1, v1)] @ w2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis append_Cons append_Nil in_set_conv_decomp_first)"], ["proof (state)\nthis:\n  p = w1 @ [(u1, v1)] @ w2\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  p = w1 @ [(u1, v1)] @ w2", "have \"isPath v1 w2 v\""], ["proof (prove)\nusing this:\n  p = w1 @ [(u1, v1)] @ w2\n\ngoal (1 subgoal):\n 1. isPath v1 w2 v", "using assms(1) isPath_append"], ["proof (prove)\nusing this:\n  p = w1 @ [(u1, v1)] @ w2\n  isPath u p v\n  isPath ?u (?p1.0 @ ?p2.0) ?v =\n  (\\<exists>w. isPath ?u ?p1.0 w \\<and> isPath w ?p2.0 ?v)\n\ngoal (1 subgoal):\n 1. isPath v1 w2 v", "by auto"], ["proof (state)\nthis:\n  isPath v1 w2 v\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "have \"w2 \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w2 \\<noteq> []", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> w2 \\<noteq> [] \\<Longrightarrow> False", "assume \"\\<not> w2 \\<noteq> []\""], ["proof (state)\nthis:\n  \\<not> w2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> w2 \\<noteq> [] \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> w2 \\<noteq> []", "have \"v = v1\""], ["proof (prove)\nusing this:\n  \\<not> w2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. v = v1", "using \\<open>isPath v1 w2 v\\<close>"], ["proof (prove)\nusing this:\n  \\<not> w2 \\<noteq> []\n  isPath v1 w2 v\n\ngoal (1 subgoal):\n 1. v = v1", "by (metis isPath.simps(1))"], ["proof (state)\nthis:\n  v = v1\n\ngoal (1 subgoal):\n 1. \\<not> w2 \\<noteq> [] \\<Longrightarrow> False", "thus \"False\""], ["proof (prove)\nusing this:\n  v = v1\n\ngoal (1 subgoal):\n 1. False", "using assms(3)"], ["proof (prove)\nusing this:\n  v = v1\n  v1 \\<noteq> v\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  w2 \\<noteq> []", "obtain e w2' where obt2:\"w2 =  e # w2'\""], ["proof (prove)\nusing this:\n  w2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. (\\<And>e w2'. w2 = e # w2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis neq_Nil_conv)"], ["proof (state)\nthis:\n  w2 = e # w2'\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  w2 = e # w2'", "obtain v2 where \"e = (v1, v2)\""], ["proof (prove)\nusing this:\n  w2 = e # w2'\n\ngoal (1 subgoal):\n 1. (\\<And>v2. e = (v1, v2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using \\<open>isPath v1 w2 v\\<close> isPath_head"], ["proof (prove)\nusing this:\n  w2 = e # w2'\n  isPath v1 w2 v\n  isPath ?u (?e # ?p) ?v =\n  (fst ?e = ?u \\<and> ?e \\<in> E \\<and> isPath (snd ?e) ?p ?v)\n\ngoal (1 subgoal):\n 1. (\\<And>v2. e = (v1, v2) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  e = (v1, v2)\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "then"], ["proof (chain)\npicking this:\n  e = (v1, v2)", "have \"p = w1 @ (u1, v1) # (v1, v2) # w2'\""], ["proof (prove)\nusing this:\n  e = (v1, v2)\n\ngoal (1 subgoal):\n 1. p = w1 @ (u1, v1) # (v1, v2) # w2'", "using obt1 obt2"], ["proof (prove)\nusing this:\n  e = (v1, v2)\n  p = w1 @ [(u1, v1)] @ w2\n  w2 = e # w2'\n\ngoal (1 subgoal):\n 1. p = w1 @ (u1, v1) # (v1, v2) # w2'", "by auto"], ["proof (state)\nthis:\n  p = w1 @ (u1, v1) # (v1, v2) # w2'\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = w1 @ (u1, v1) # (v1, v2) # w2'\n\ngoal (1 subgoal):\n 1. \\<exists>v2. (v1, v2) \\<in> set p", "by auto"], ["proof (state)\nthis:\n  \\<exists>v2. (v1, v2) \\<in> set p\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Vertices of Paths\\<close>"], ["", "lemma (in Graph) pathVertices_fwd_simps[simp]: \n  \"pathVertices_fwd s ([]) = [s]\"  \n  \"pathVertices_fwd s (e#p) = s#pathVertices_fwd (snd e) p\"  \n  \"pathVertices_fwd s (p@[e]) = pathVertices_fwd s p@[snd e]\"\n  \"pathVertices_fwd s (p1@e#p2) \n    = pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2\"\n  \"s\\<in>set (pathVertices_fwd s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pathVertices_fwd s [] = [s] &&&\n     pathVertices_fwd s (e # p) = s # pathVertices_fwd (snd e) p) &&&\n    pathVertices_fwd s (p @ [e]) = pathVertices_fwd s p @ [snd e] &&&\n    pathVertices_fwd s (p1 @ e # p2) =\n    pathVertices_fwd s p1 @ pathVertices_fwd (snd e) p2 &&&\n    s \\<in> set (pathVertices_fwd s p)", "by (auto simp: pathVertices_fwd_def)"], ["", "lemma pathVertices_alt: \"p \\<noteq> [] \n    \\<Longrightarrow> pathVertices u p = map fst p @ [snd (last p)]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow>\n    pathVertices u p = map fst p @ [snd (last p)]", "by (induction p arbitrary: u) auto"], ["", "lemma pathVertices_singleton_iff[simp]: \"pathVertices s p = [u] \\<longleftrightarrow> (p=[] \\<and> s=u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pathVertices s p = [u]) = (p = [] \\<and> s = u)", "apply (cases p rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow>\n    (pathVertices s p = [u]) = (p = [] \\<and> s = u)\n 2. \\<And>ys y.\n       p = ys @ [y] \\<Longrightarrow>\n       (pathVertices s p = [u]) = (p = [] \\<and> s = u)", "apply (auto simp: pathVertices_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma length_pathVertices_eq[simp]: \"length (pathVertices u p) = length p + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (pathVertices u p) = length p + 1", "apply (cases \"p=[]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> length (pathVertices u p) = length p + 1\n 2. p \\<noteq> [] \\<Longrightarrow> length (pathVertices u p) = length p + 1", "apply (auto simp: pathVertices_alt)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pathVertices_edgeset: \"\\<lbrakk>u\\<in>V; isPath u p v\\<rbrakk> \\<Longrightarrow> set (pathVertices u p) \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> V; isPath u p v\\<rbrakk>\n    \\<Longrightarrow> set (pathVertices u p) \\<subseteq> V", "apply (cases p rule: rev_cases; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>u \\<in> V; isPath u (ys @ [y]) v; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> set (pathVertices u (ys @ [y])) \\<subseteq> V", "using isPath_edgeset[of u p v]"], ["proof (prove)\nusing this:\n  \\<lbrakk>isPath u p v; ?e \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> ?e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<And>ys y.\n       \\<lbrakk>u \\<in> V; isPath u (ys @ [y]) v; p = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> set (pathVertices u (ys @ [y])) \\<subseteq> V", "apply (fastforce simp: pathVertices_alt V_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma pathVertices_append: \"pathVertices u (p1 @ p2) = \nbutlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices u (p1 @ p2) =\n    butlast (pathVertices u p1) @ pathVertices (last (pathVertices u p1)) p2", "proof (induction p1 arbitrary: u)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>u.\n       pathVertices u ([] @ p2) =\n       butlast (pathVertices u []) @\n       pathVertices (last (pathVertices u [])) p2\n 2. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>u.\n       pathVertices u ([] @ p2) =\n       butlast (pathVertices u []) @\n       pathVertices (last (pathVertices u [])) p2\n 2. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices u ([] @ p2) =\n    butlast (pathVertices u []) @ pathVertices (last (pathVertices u [])) p2", "by auto"], ["proof (state)\nthis:\n  pathVertices u ([] @ p2) =\n  butlast (pathVertices u []) @ pathVertices (last (pathVertices u [])) p2\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "case (Cons e es)"], ["proof (state)\nthis:\n  pathVertices ?u (es @ p2) =\n  butlast (pathVertices ?u es) @ pathVertices (last (pathVertices ?u es)) p2\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "have \"pathVertices u ((e # es) @ p2) =  fst e # pathVertices (snd e) (es @ p2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices u ((e # es) @ p2) = fst e # pathVertices (snd e) (es @ p2)", "by (metis Graph.pathVertices.simps(2) append_Cons)"], ["proof (state)\nthis:\n  pathVertices u ((e # es) @ p2) = fst e # pathVertices (snd e) (es @ p2)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "moreover"], ["proof (state)\nthis:\n  pathVertices u ((e # es) @ p2) = fst e # pathVertices (snd e) (es @ p2)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "have \"pathVertices (snd e) (es @ p2) \n    = butlast (pathVertices (snd e) es) \n      @ pathVertices (last (pathVertices (snd e) es)) p2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pathVertices (snd e) (es @ p2) =\n    butlast (pathVertices (snd e) es) @\n    pathVertices (last (pathVertices (snd e) es)) p2", "using Cons.IH"], ["proof (prove)\nusing this:\n  pathVertices ?u (es @ p2) =\n  butlast (pathVertices ?u es) @ pathVertices (last (pathVertices ?u es)) p2\n\ngoal (1 subgoal):\n 1. pathVertices (snd e) (es @ p2) =\n    butlast (pathVertices (snd e) es) @\n    pathVertices (last (pathVertices (snd e) es)) p2", "by auto"], ["proof (state)\nthis:\n  pathVertices (snd e) (es @ p2) =\n  butlast (pathVertices (snd e) es) @\n  pathVertices (last (pathVertices (snd e) es)) p2\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "moreover"], ["proof (state)\nthis:\n  pathVertices (snd e) (es @ p2) =\n  butlast (pathVertices (snd e) es) @\n  pathVertices (last (pathVertices (snd e) es)) p2\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "have \"fst e # butlast (pathVertices (snd e) es) = \n    butlast (fst e # pathVertices (snd e) es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e # butlast (pathVertices (snd e) es) =\n    butlast (fst e # pathVertices (snd e) es)", "by (metis Graph.pathVertices.simps(1)\n        Graph.pathVertices_alt Nil_is_append_conv butlast.simps(2) \n        list.distinct(1))"], ["proof (state)\nthis:\n  fst e # butlast (pathVertices (snd e) es) =\n  butlast (fst e # pathVertices (snd e) es)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "moreover"], ["proof (state)\nthis:\n  fst e # butlast (pathVertices (snd e) es) =\n  butlast (fst e # pathVertices (snd e) es)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "have \"fst e # pathVertices (snd e) es = pathVertices u (e # es)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst e # pathVertices (snd e) es = pathVertices u (e # es)", "by (metis Graph.pathVertices.simps(2))"], ["proof (state)\nthis:\n  fst e # pathVertices (snd e) es = pathVertices u (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "moreover"], ["proof (state)\nthis:\n  fst e # pathVertices (snd e) es = pathVertices u (e # es)\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "have \"last (pathVertices (snd e) es) = last (pathVertices u (e # es))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (pathVertices (snd e) es) = last (pathVertices u (e # es))", "by (metis Graph.pathVertices.simps(1) Graph.pathVertices_alt \n    last.simps last_snoc list.distinct(1))"], ["proof (state)\nthis:\n  last (pathVertices (snd e) es) = last (pathVertices u (e # es))\n\ngoal (1 subgoal):\n 1. \\<And>a p1 u.\n       (\\<And>u.\n           pathVertices u (p1 @ p2) =\n           butlast (pathVertices u p1) @\n           pathVertices (last (pathVertices u p1)) p2) \\<Longrightarrow>\n       pathVertices u ((a # p1) @ p2) =\n       butlast (pathVertices u (a # p1)) @\n       pathVertices (last (pathVertices u (a # p1))) p2", "ultimately"], ["proof (chain)\npicking this:\n  pathVertices u ((e # es) @ p2) = fst e # pathVertices (snd e) (es @ p2)\n  pathVertices (snd e) (es @ p2) =\n  butlast (pathVertices (snd e) es) @\n  pathVertices (last (pathVertices (snd e) es)) p2\n  fst e # butlast (pathVertices (snd e) es) =\n  butlast (fst e # pathVertices (snd e) es)\n  fst e # pathVertices (snd e) es = pathVertices u (e # es)\n  last (pathVertices (snd e) es) = last (pathVertices u (e # es))", "show ?case"], ["proof (prove)\nusing this:\n  pathVertices u ((e # es) @ p2) = fst e # pathVertices (snd e) (es @ p2)\n  pathVertices (snd e) (es @ p2) =\n  butlast (pathVertices (snd e) es) @\n  pathVertices (last (pathVertices (snd e) es)) p2\n  fst e # butlast (pathVertices (snd e) es) =\n  butlast (fst e # pathVertices (snd e) es)\n  fst e # pathVertices (snd e) es = pathVertices u (e # es)\n  last (pathVertices (snd e) es) = last (pathVertices u (e # es))\n\ngoal (1 subgoal):\n 1. pathVertices u ((e # es) @ p2) =\n    butlast (pathVertices u (e # es)) @\n    pathVertices (last (pathVertices u (e # es))) p2", "by (metis append_Cons)"], ["proof (state)\nthis:\n  pathVertices u ((e # es) @ p2) =\n  butlast (pathVertices u (e # es)) @\n  pathVertices (last (pathVertices u (e # es))) p2\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_path_at_vertex: \n  assumes \"u\\<in>set (pathVertices_fwd s p)\"\n  assumes \"isPath s p t\"\n  obtains p1 p2 where \"p=p1@p2\" \"isPath s p1 u\" \"isPath u p2 t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u; isPath u p2 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  u \\<in> set (pathVertices_fwd s p)\n  isPath s p t\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u; isPath u p2 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p1 p2.\n                \\<lbrakk>p = p1 @ p2; isPath s p1 u; isPath u p2 t\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     u \\<in> set (pathVertices_fwd s p); isPath s p t\\<rbrakk>\n    \\<Longrightarrow> thesis", "(*unfolding pathVertices_fwd*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p1 p2.\n                \\<lbrakk>p = p1 @ p2; isPath s p1 u; isPath u p2 t\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     u \\<in> set (pathVertices_fwd s p); isPath s p t\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding pathVertices_fwd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p1 p2.\n                \\<lbrakk>p = p1 @ p2; isPath s p1 u; isPath u p2 t\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     u \\<in> set (s # map snd p); isPath s p t\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (auto simp: in_set_conv_decomp isPath_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>p1 p2.\n                \\<lbrakk>p = p1 @ p2; isPath s p1 s; isPath s p2 t\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     isPath s p t; u = s\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>a ys zs.\n       \\<lbrakk>\\<And>p1 p2.\n                   \\<lbrakk>ys @ (a, u) # zs = p1 @ p2; isPath s p1 u;\n                    isPath u p2 t\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = ys @ (a, u) # zs; isPath s ys a; (a, u) \\<in> E;\n        isPath u zs t\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ys zs.\n       \\<lbrakk>\\<And>p1 p2.\n                   \\<lbrakk>ys @ (a, u) # zs = p1 @ p2; isPath s p1 u;\n                    isPath u p2 t\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        p = ys @ (a, u) # zs; isPath s ys a; (a, u) \\<in> E;\n        isPath u zs t\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis Graph.isPath_append_edge append_Cons append_Nil append_assoc)"], ["", "lemma split_path_at_vertex_complete: \n  assumes \"isPath s p t\" \"pathVertices_fwd s p = pv1@u#pv2\" \n  obtains p1 p2 where \n    \"p=p1@p2\" \n    \"isPath s p1 u\" \"pathVertices_fwd s p1 = pv1@[u]\" \n    \"isPath u p2 t\" \"pathVertices_fwd u p2 = u#pv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n         pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n         pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n         pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n         pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from assms"], ["proof (chain)\npicking this:\n  isPath s p t\n  pathVertices_fwd s p = pv1 @ u # pv2", "have PV: \"pathVertices s p = pv1@u#pv2\""], ["proof (prove)\nusing this:\n  isPath s p t\n  pathVertices_fwd s p = pv1 @ u # pv2\n\ngoal (1 subgoal):\n 1. pathVertices s p = pv1 @ u # pv2", "by (simp add: pathVertices_fwd)"], ["proof (state)\nthis:\n  pathVertices s p = pv1 @ u # pv2\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n         pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n         pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  pathVertices s p = pv1 @ u # pv2", "obtain p1 p2 where \n    \"p=p1@p2\" \n    \"isPath s p1 u\" \"pathVertices s p1 = pv1@[u]\" \n    \"isPath u p2 t\" \"pathVertices u p2 = u#pv2\""], ["proof (prove)\nusing this:\n  pathVertices s p = pv1 @ u # pv2\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u; pathVertices s p1 = pv1 @ [u];\n         isPath u p2 t; pathVertices u p2 = u # pv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p1 p2.\n                \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n                 pathVertices s p1 = pv1 @ [u]; isPath u p2 t;\n                 pathVertices u p2 = u # pv2\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     pathVertices s p = pv1 @ u # pv2\\<rbrakk>\n    \\<Longrightarrow> thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using assms(1) PV"], ["proof (prove)\nusing this:\n  isPath s p t\n  pathVertices s p = pv1 @ u # pv2\n\ngoal (1 subgoal):\n 1. thesis", "apply (cases p rule: rev_cases; clarsimp simp: pathVertices_alt)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s = t; [t] = pv1 @ u # pv2; p = []\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<And>ys a b.\n       \\<lbrakk>isPath s (ys @ [(a, b)]) t;\n        map fst ys @ [a, b] = pv1 @ u # pv2; p = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule that[of \"[]\" \"[]\"]; simp add: Cons_eq_append_conv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys a b.\n       \\<lbrakk>isPath s (ys @ [(a, b)]) t;\n        map fst ys @ [a, b] = pv1 @ u # pv2; p = ys @ [(a, b)]\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (cases pv2; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys a.\n       \\<lbrakk>isPath s (ys @ [(a, u)]) t; p = ys @ [(a, u)]; pv2 = [];\n        pv1 = map fst ys @ [a]\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ys a b aa list.\n       \\<lbrakk>isPath s (ys @ [(a, b)]) t;\n        map fst ys @ [a, b] = pv1 @ u # aa # list; p = ys @ [(a, b)];\n        pv2 = aa # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (rule that[of p \"[]\"]; \n        auto simp add: isPath_append pathVertices_alt\n      )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys a b aa list.\n       \\<lbrakk>isPath s (ys @ [(a, b)]) t;\n        map fst ys @ [a, b] = pv1 @ u # aa # list; p = ys @ [(a, b)];\n        pv2 = aa # list\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (clarsimp simp: append_eq_append_conv2;\n        auto elim!: map_eq_appendE append_eq_Cons_conv[THEN iffD1, elim_format]\n            simp: isPath_append)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>l.\n       \\<lbrakk>p = l @ [(u, t)]; pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n        pv1 = map fst l\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>aa l.\n       \\<lbrakk>p = l @ [(u, aa), (aa, t)]; pv2 = [aa, t]; (aa, t) \\<in> E;\n        pv1 = map fst l; isPath s l u; (u, aa) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a l b ba zsa.\n       \\<lbrakk>p = l @ (u, b) # (b, ba) # zsa @ [(a, t)];\n        pv2 = b # map fst zsa @ [a, t]; (a, t) \\<in> E; pv1 = map fst l;\n        isPath s l u; (u, b) \\<in> E; (b, ba) \\<in> E;\n        isPath ba zsa a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 4. \\<And>ys a aa list us.\n       \\<lbrakk>p = ys @ [(a, t)]; pv2 = aa # list; isPath s ys a;\n        (a, t) \\<in> E; [a, t] = us @ u # aa # list;\n        pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for \\<dots> l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = l @ [(u, t)]; pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> isPath s l u\n 2. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = pv1 @ [u]\n 3. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> isPath u [(u, t)] t\n 4. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> pathVertices u [(u, t)] = u # pv2", "apply auto [4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = map fst l @ [u]", "apply (case_tac l rule: rev_cases; \n          auto simp add: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>aa l.\n       \\<lbrakk>p = l @ [(u, aa), (aa, t)]; pv2 = [aa, t]; (aa, t) \\<in> E;\n        pv1 = map fst l; isPath s l u; (u, aa) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>a l b ba zsa.\n       \\<lbrakk>p = l @ (u, b) # (b, ba) # zsa @ [(a, t)];\n        pv2 = b # map fst zsa @ [a, t]; (a, t) \\<in> E; pv1 = map fst l;\n        isPath s l u; (u, b) \\<in> E; (b, ba) \\<in> E;\n        isPath ba zsa a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>ys a aa list us.\n       \\<lbrakk>p = ys @ [(a, t)]; pv2 = aa # list; isPath s ys a;\n        (a, t) \\<in> E; [a, t] = us @ u # aa # list;\n        pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for \\<dots> l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = l @ [(u, aa_), (aa_, t)]; pv2 = [aa_, t]; (aa_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pv2 = [aa_, t]; (aa_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> isPath s l u\n 2. \\<lbrakk>pv2 = [aa_, t]; (aa_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = pv1 @ [u]\n 3. \\<lbrakk>pv2 = [aa_, t]; (aa_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> isPath u [(u, aa_), (aa_, t)] t\n 4. \\<lbrakk>pv2 = [aa_, t]; (aa_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> pathVertices u [(u, aa_), (aa_, t)] = u # pv2", "apply auto [4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pv2 = [aa_, t]; (aa_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, aa_) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = map fst l @ [u]", "apply (case_tac l rule: rev_cases; \n          auto simp add: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a l b ba zsa.\n       \\<lbrakk>p = l @ (u, b) # (b, ba) # zsa @ [(a, t)];\n        pv2 = b # map fst zsa @ [a, t]; (a, t) \\<in> E; pv1 = map fst l;\n        isPath s l u; (u, b) \\<in> E; (b, ba) \\<in> E;\n        isPath ba zsa a\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>ys a aa list us.\n       \\<lbrakk>p = ys @ [(a, t)]; pv2 = aa # list; isPath s ys a;\n        (a, t) \\<in> E; [a, t] = us @ u # aa # list;\n        pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for \\<dots> l u1 u2 u3"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = l @ (u, u1) # (u1, u2) # u3 @ [(a_, t)];\n     pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E; pv1 = map fst l;\n     isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> isPath s l u\n 2. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = pv1 @ [u]\n 3. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> isPath u ((u, u1) # (u1, u2) # u3 @ [(a_, t)]) t\n 4. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices u ((u, u1) # (u1, u2) # u3 @ [(a_, t)]) =\n                      u # pv2", "apply auto [4]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = map fst l @ [u]\n 2. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> isPath u2 (u3 @ [(a_, t)]) t\n 3. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices u2 (u3 @ [(a_, t)]) =\n                      map fst u3 @ [a_, t]", "apply (case_tac l rule: rev_cases; \n          auto simp add: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> isPath u2 (u3 @ [(a_, t)]) t\n 2. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices u2 (u3 @ [(a_, t)]) =\n                      map fst u3 @ [a_, t]", "apply (auto simp: isPath_append) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pv2 = u1 # map fst u3 @ [a_, t]; (a_, t) \\<in> E;\n     pv1 = map fst l; isPath s l u; (u, u1) \\<in> E; (u1, u2) \\<in> E;\n     isPath u2 u3 a_\\<rbrakk>\n    \\<Longrightarrow> pathVertices u2 (u3 @ [(a_, t)]) =\n                      map fst u3 @ [a_, t]", "apply (auto simp: pathVertices_alt) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys a aa list us.\n       \\<lbrakk>p = ys @ [(a, t)]; pv2 = aa # list; isPath s ys a;\n        (a, t) \\<in> E; [a, t] = us @ u # aa # list;\n        pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (erule that)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ys a aa list us.\n       \\<lbrakk>pv2 = aa # list; isPath s ys a; (a, t) \\<in> E;\n        [a, t] = us @ u # aa # list; pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> isPath s ys u\n 2. \\<And>ys a aa list us.\n       \\<lbrakk>pv2 = aa # list; isPath s ys a; (a, t) \\<in> E;\n        [a, t] = us @ u # aa # list; pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> pathVertices s ys = pv1 @ [u]\n 3. \\<And>ys a aa list us.\n       \\<lbrakk>pv2 = aa # list; isPath s ys a; (a, t) \\<in> E;\n        [a, t] = us @ u # aa # list; pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> isPath u [(a, t)] t\n 4. \\<And>ys a aa list us.\n       \\<lbrakk>pv2 = aa # list; isPath s ys a; (a, t) \\<in> E;\n        [a, t] = us @ u # aa # list; pv1 = map fst ys @ us\\<rbrakk>\n       \\<Longrightarrow> pathVertices u [(a, t)] = u # pv2", "apply(auto simp add: Cons_eq_append_conv) [4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>pv2 = [t]; isPath s ys u; (u, t) \\<in> E;\n        pv1 = map fst ys\\<rbrakk>\n       \\<Longrightarrow> pathVertices s ys = map fst ys @ [u]", "subgoal for \\<dots> l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pv2 = [t]; isPath s l u; (u, t) \\<in> E;\n     pv1 = map fst l\\<rbrakk>\n    \\<Longrightarrow> pathVertices s l = map fst l @ [u]", "by (case_tac l rule: rev_cases; \n            auto simp add: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p = p1 @ p2\n  isPath s p1 u\n  pathVertices s p1 = pv1 @ [u]\n  isPath u p2 t\n  pathVertices u p2 = u # pv2\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n         pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n         pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = p1 @ p2\n  isPath s p1 u\n  pathVertices s p1 = pv1 @ [u]\n  isPath u p2 t\n  pathVertices u p2 = u # pv2\n\ngoal (1 subgoal):\n 1. thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p1 @ p2; isPath s p1 u; pathVertices s p1 = pv1 @ [u];\n     isPath u p2 t; pathVertices u p2 = u # pv2\\<rbrakk>\n    \\<Longrightarrow> thesis", "unfolding pathVertices_fwd"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p1 @ p2; isPath s p1 u; pathVertices_fwd s p1 = pv1 @ [u];\n     isPath u p2 t; pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n    \\<Longrightarrow> thesis", "using that"], ["proof (prove)\nusing this:\n  \\<lbrakk>p = ?p1.0 @ ?p2.0; isPath s ?p1.0 u;\n   pathVertices_fwd s ?p1.0 = pv1 @ [u]; isPath u ?p2.0 t;\n   pathVertices_fwd u ?p2.0 = u # pv2\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p = p1 @ p2; isPath s p1 u; pathVertices_fwd s p1 = pv1 @ [u];\n     isPath u p2 t; pathVertices_fwd u p2 = u # pv2\\<rbrakk>\n    \\<Longrightarrow> thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isPath_fwd_cases: \n  assumes \"isPath s p t\"\n  obtains \"p=[]\" \"t=s\"\n    | p' u where \"p=(s,u)#p'\" \"(s,u)\\<in>E\" \"isPath u p' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>p = []; t = s\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>u p'.\n        \\<lbrakk>p = (s, u) # p'; (s, u) \\<in> E; isPath u p' t\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  isPath s p t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>p = []; t = s\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>u p'.\n        \\<lbrakk>p = (s, u) # p'; (s, u) \\<in> E; isPath u p' t\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases p) (auto)"], ["", "lemma isPath_bwd_cases: \n  assumes \"isPath s p t\"\n  obtains \"p=[]\" \"t=s\"\n    | p' u where \"p=p'@[(u,t)]\" \"isPath s p' u\" \"(u,t)\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>p = []; t = s\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>p' u.\n        \\<lbrakk>p = p' @ [(u, t)]; isPath s p' u; (u, t) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  isPath s p t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>p = []; t = s\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>p' u.\n        \\<lbrakk>p = p' @ [(u, t)]; isPath s p' u; (u, t) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases p rule: rev_cases) (auto simp: split_path_simps)"], ["", "lemma pathVertices_edge: \"isPath s p t \\<Longrightarrow> e \\<in> set p \\<Longrightarrow> \n  \\<exists>vs1 vs2. pathVertices_fwd s p = vs1 @ fst e # snd e # vs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath s p t; e \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>vs1 vs2.\n                         pathVertices_fwd s p = vs1 @ fst e # snd e # vs2", "apply (cases e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>isPath s p t; e \\<in> set p; e = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs1 vs2.\n                            pathVertices_fwd s p = vs1 @ fst e # snd e # vs2", "apply (auto simp: in_set_conv_decomp split_path_simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ys zs.\n       \\<lbrakk>e = (a, b); p = ys @ (a, b) # zs; isPath s ys a;\n        (a, b) \\<in> E; isPath b zs t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs1 vs2.\n                            pathVertices_fwd s ys @ pathVertices_fwd b zs =\n                            vs1 @ a # b # vs2", "apply (erule isPath_bwd_cases[where s=s]; auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b zs.\n       \\<lbrakk>e = (s, b); p = (s, b) # zs; (s, b) \\<in> E;\n        isPath b zs t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs1 vs2.\n                            s # pathVertices_fwd b zs = vs1 @ s # b # vs2\n 2. \\<And>a b zs p' u.\n       \\<lbrakk>e = (a, b); p = p' @ (u, a) # (a, b) # zs; (a, b) \\<in> E;\n        isPath b zs t; isPath s p' u; (u, a) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs1 vs2.\n                            pathVertices_fwd s p' @\n                            a # pathVertices_fwd b zs =\n                            vs1 @ a # b # vs2", "apply (erule isPath_fwd_cases[where t=t]; auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b zs p' u.\n       \\<lbrakk>e = (a, b); p = p' @ (u, a) # (a, b) # zs; (a, b) \\<in> E;\n        isPath b zs t; isPath s p' u; (u, a) \\<in> E\\<rbrakk>\n       \\<Longrightarrow> \\<exists>vs1 vs2.\n                            pathVertices_fwd s p' @\n                            a # pathVertices_fwd b zs =\n                            vs1 @ a # b # vs2", "apply (erule isPath_fwd_cases[where t=t]; auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* TODO: Really needed? *)"], ["", "lemma pathVertices_edge_old: \"isPath u p v \\<Longrightarrow> e \\<in> set p \\<Longrightarrow> \n  \\<exists>vs1 vs2. pathVertices u p = vs1 @ fst e # snd e # vs2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>vs1 vs2.\n                         pathVertices u p = vs1 @ fst e # snd e # vs2", "unfolding pathVertices_fwd"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isPath u p v; e \\<in> set p\\<rbrakk>\n    \\<Longrightarrow> \\<exists>vs1 vs2.\n                         pathVertices_fwd u p = vs1 @ fst e # snd e # vs2", "by (rule pathVertices_edge)"], ["", "subsubsection \\<open>Reachability\\<close>"], ["", "lemma connected_refl[simp, intro!]: \"connected v v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected v v", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. isPath v p v", "by (force intro: exI[where x=\"[]\"])"], ["", "lemma connected_append_edge: \"connected u v \\<Longrightarrow> (v,w)\\<in>E \\<Longrightarrow> connected u w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>connected u v; (v, w) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> connected u w", "unfolding connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>p. isPath u p v; (v, w) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> \\<exists>p. isPath u p w", "by (auto intro: isPath_append_edge)"], ["", "lemma connected_inV_iff: \"\\<lbrakk>connected u v\\<rbrakk> \\<Longrightarrow> v\\<in>V \\<longleftrightarrow> u\\<in>V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected u v \\<Longrightarrow> (v \\<in> V) = (u \\<in> V)", "apply (auto simp: connected_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>isPath u p v; v \\<in> V\\<rbrakk> \\<Longrightarrow> u \\<in> V\n 2. \\<And>p.\n       \\<lbrakk>isPath u p v; u \\<in> V\\<rbrakk> \\<Longrightarrow> v \\<in> V", "apply (case_tac p; auto simp: V_def) []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>isPath u p v; u \\<in> V\\<rbrakk> \\<Longrightarrow> v \\<in> V", "apply (case_tac p rule: rev_cases; auto simp: isPath_append V_def) []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma connected_edgeRtc: \"connected u v \\<longleftrightarrow> (u, v) \\<in> E\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected u v = ((u, v) \\<in> E\\<^sup>*)", "using isPath_rtc rtc_isPath"], ["proof (prove)\nusing this:\n  isPath ?u ?p ?v \\<Longrightarrow> (?u, ?v) \\<in> E\\<^sup>*\n  (?u, ?v) \\<in> E\\<^sup>* \\<Longrightarrow> \\<exists>p. isPath ?u p ?v\n\ngoal (1 subgoal):\n 1. connected u v = ((u, v) \\<in> E\\<^sup>*)", "unfolding connected_def"], ["proof (prove)\nusing this:\n  isPath ?u ?p ?v \\<Longrightarrow> (?u, ?v) \\<in> E\\<^sup>*\n  (?u, ?v) \\<in> E\\<^sup>* \\<Longrightarrow> \\<exists>p. isPath ?u p ?v\n\ngoal (1 subgoal):\n 1. (\\<exists>p. isPath u p v) = ((u, v) \\<in> E\\<^sup>*)", "by blast"], ["", "lemma reachable_ss_V: \"s \\<in> V \\<Longrightarrow> reachableNodes s \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> V \\<Longrightarrow> reachableNodes s \\<subseteq> V", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> reachableNodes s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V", "assume asm: \"s \\<in> V\""], ["proof (state)\nthis:\n  s \\<in> V\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> reachableNodes s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> reachableNodes s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V", "assume \"x \\<in> reachableNodes s\""], ["proof (state)\nthis:\n  x \\<in> reachableNodes s\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> reachableNodes s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V", "then"], ["proof (chain)\npicking this:\n  x \\<in> reachableNodes s", "obtain p where \"x \\<in> {v. isPath s p v}\""], ["proof (prove)\nusing this:\n  x \\<in> reachableNodes s\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        x \\<in> {v. isPath s p v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding reachableNodes_def connected_def"], ["proof (prove)\nusing this:\n  x \\<in> {v. \\<exists>p. isPath s p v}\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        x \\<in> {v. isPath s p v} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> {v. isPath s p v}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> reachableNodes s\\<rbrakk>\n       \\<Longrightarrow> x \\<in> V", "thus \"x \\<in> V\""], ["proof (prove)\nusing this:\n  x \\<in> {v. isPath s p v}\n\ngoal (1 subgoal):\n 1. x \\<in> V", "using asm"], ["proof (prove)\nusing this:\n  x \\<in> {v. isPath s p v}\n  s \\<in> V\n\ngoal (1 subgoal):\n 1. x \\<in> V", "by (induction p arbitrary: s) (auto simp: isPath_head V_alt)"], ["proof (state)\nthis:\n  x \\<in> V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reachableNodes_E_closed: \"E``reachableNodes s \\<subseteq> reachableNodes s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` reachableNodes s \\<subseteq> reachableNodes s", "unfolding reachableNodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. E `` {v. connected s v} \\<subseteq> {v. connected s v}", "by (auto intro: connected_append_edge)"], ["", "corollary reachableNodes_append_edge: \n  \"u\\<in>reachableNodes s \\<Longrightarrow> (u,v)\\<in>E \\<Longrightarrow> v\\<in>reachableNodes s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> reachableNodes s; (u, v) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> v \\<in> reachableNodes s", "using reachableNodes_E_closed"], ["proof (prove)\nusing this:\n  E `` reachableNodes ?s \\<subseteq> reachableNodes ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>u \\<in> reachableNodes s; (u, v) \\<in> E\\<rbrakk>\n    \\<Longrightarrow> v \\<in> reachableNodes s", "by blast"], ["", "subsubsection \\<open>Simple Paths\\<close>"], ["", "lemma isSimplePath_fwd: \"isSimplePath s p t \n  \\<longleftrightarrow> isPath s p t \\<and> distinct (pathVertices_fwd s p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s p t =\n    (isPath s p t \\<and> distinct (pathVertices_fwd s p))", "by (auto simp: isSimplePath_def pathVertices_fwd)"], ["", "lemma isSimplePath_singelton[split_path_simps]: \n  \"isSimplePath u [e] v \\<longleftrightarrow> (e=(u,v) \\<and> u\\<noteq>v \\<and> (u,v)\\<in>E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath u [e] v =\n    (e = (u, v) \\<and> u \\<noteq> v \\<and> (u, v) \\<in> E)", "by (auto simp: isSimplePath_def isPath_head)"], ["", "lemma (in Graph) isSimplePath_append[split_path_simps]: \n  \"isSimplePath s (p1@p2) t \n    \\<longleftrightarrow> (\\<exists>u. \n      isSimplePath s p1 u \n    \\<and> isSimplePath u p2 t \n    \\<and> set (pathVertices_fwd s p1) \\<inter> set (pathVertices_fwd u p2) = {u})\"  \n  (is \"_ \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s (p1 @ p2) t =\n    (\\<exists>u.\n        isSimplePath s p1 u \\<and>\n        isSimplePath u p2 t \\<and>\n        set (pathVertices_fwd s p1) \\<inter> set (pathVertices_fwd u p2) =\n        {u})", "unfolding isSimplePath_fwd"], ["proof (prove)\ngoal (1 subgoal):\n 1. (isPath s (p1 @ p2) t \\<and> distinct (pathVertices_fwd s (p1 @ p2))) =\n    (\\<exists>u.\n        (isPath s p1 u \\<and> distinct (pathVertices_fwd s p1)) \\<and>\n        (isPath u p2 t \\<and> distinct (pathVertices_fwd u p2)) \\<and>\n        set (pathVertices_fwd s p1) \\<inter> set (pathVertices_fwd u p2) =\n        {u})", "apply (cases p1 rule: rev_cases; simp; cases p2; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ys y.\n       \\<lbrakk>p1 = ys @ [y]; p2 = []\\<rbrakk>\n       \\<Longrightarrow> (isPath s (ys @ [y]) t \\<and>\n                          distinct (pathVertices_fwd s ys) \\<and>\n                          snd y \\<notin> set (pathVertices_fwd s ys)) =\n                         (isPath s (ys @ [y]) t \\<and>\n                          distinct (pathVertices_fwd s ys) \\<and>\n                          snd y \\<notin> set (pathVertices_fwd s ys) \\<and>\n                          insert (snd y)\n                           (set (pathVertices_fwd s ys)) \\<inter>\n                          {t} =\n                          {t})\n 2. \\<And>ys y a list.\n       \\<lbrakk>p1 = ys @ [y]; p2 = a # list\\<rbrakk>\n       \\<Longrightarrow> (isPath s (ys @ y # a # list) t \\<and>\n                          distinct (pathVertices_fwd s ys) \\<and>\n                          snd y\n                          \\<notin> set (pathVertices_fwd (snd a)\n   list) \\<and>\n                          distinct (pathVertices_fwd (snd a) list) \\<and>\n                          snd y \\<notin> set (pathVertices_fwd s ys) \\<and>\n                          set (pathVertices_fwd s ys) \\<inter>\n                          set (pathVertices_fwd (snd a) list) =\n                          {}) =\n                         (\\<exists>u.\n                             isPath s (ys @ [y]) u \\<and>\n                             distinct (pathVertices_fwd s ys) \\<and>\n                             snd y\n                             \\<notin> set (pathVertices_fwd s ys) \\<and>\n                             isPath u (a # list) t \\<and>\n                             u \\<notin> set\n   (pathVertices_fwd (snd a) list) \\<and>\n                             distinct (pathVertices_fwd (snd a) list) \\<and>\n                             insert (snd y)\n                              (set (pathVertices_fwd s ys)) \\<inter>\n                             insert u\n                              (set (pathVertices_fwd (snd a) list)) =\n                             {u})", "by (auto simp: split_path_simps)"], ["", "lemma (in Graph) isSimplePath_cons[split_path_simps]: \n  \"isSimplePath s (e#p) t \n  \\<longleftrightarrow> (\\<exists>u. e=(s,u) \\<and> s\\<noteq>u \\<and> (s,u)\\<in>E \n        \\<and> isSimplePath u p t \\<and> s\\<notin>set (pathVertices_fwd u p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s (e # p) t =\n    (\\<exists>u.\n        e = (s, u) \\<and>\n        s \\<noteq> u \\<and>\n        (s, u) \\<in> E \\<and>\n        isSimplePath u p t \\<and> s \\<notin> set (pathVertices_fwd u p))", "using isSimplePath_append[of s \"[e]\" p t, simplified]"], ["proof (prove)\nusing this:\n  isSimplePath s (e # p) t =\n  (\\<exists>u.\n      isSimplePath s [e] u \\<and>\n      isSimplePath u p t \\<and>\n      {s, snd e} \\<inter> set (pathVertices_fwd u p) = {u})\n\ngoal (1 subgoal):\n 1. isSimplePath s (e # p) t =\n    (\\<exists>u.\n        e = (s, u) \\<and>\n        s \\<noteq> u \\<and>\n        (s, u) \\<in> E \\<and>\n        isSimplePath u p t \\<and> s \\<notin> set (pathVertices_fwd u p))", "by (auto simp: split_path_simps)"], ["", "lemma (in Finite_Graph) simplePath_length_less_V:\n  assumes UIV: \"u\\<in>V\"\n  assumes P: \"isSimplePath u p v\" \n  shows \"length p < card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length p < card V", "from P"], ["proof (chain)\npicking this:\n  isSimplePath u p v", "have 1: \"isPath u p v\" and 2: \"distinct (pathVertices u p)\""], ["proof (prove)\nusing this:\n  isSimplePath u p v\n\ngoal (1 subgoal):\n 1. isPath u p v &&& distinct (pathVertices u p)", "by (auto simp: isSimplePath_def)"], ["proof (state)\nthis:\n  isPath u p v\n  distinct (pathVertices u p)\n\ngoal (1 subgoal):\n 1. length p < card V", "from pathVertices_edgeset[OF UIV 1]"], ["proof (chain)\npicking this:\n  set (pathVertices u p) \\<subseteq> V", "have \"set (pathVertices u p) \\<subseteq> V\""], ["proof (prove)\nusing this:\n  set (pathVertices u p) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. set (pathVertices u p) \\<subseteq> V", "."], ["proof (state)\nthis:\n  set (pathVertices u p) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. length p < card V", "with 2 finite_V"], ["proof (chain)\npicking this:\n  distinct (pathVertices u p)\n  finite V\n  set (pathVertices u p) \\<subseteq> V", "have \"length (pathVertices u p) \\<le> card V\""], ["proof (prove)\nusing this:\n  distinct (pathVertices u p)\n  finite V\n  set (pathVertices u p) \\<subseteq> V\n\ngoal (1 subgoal):\n 1. length (pathVertices u p) \\<le> card V", "using distinct_card card_mono"], ["proof (prove)\nusing this:\n  distinct (pathVertices u p)\n  finite V\n  set (pathVertices u p) \\<subseteq> V\n  distinct ?xs \\<Longrightarrow> card (set ?xs) = length ?xs\n  \\<lbrakk>finite ?B; ?A \\<subseteq> ?B\\<rbrakk>\n  \\<Longrightarrow> card ?A \\<le> card ?B\n\ngoal (1 subgoal):\n 1. length (pathVertices u p) \\<le> card V", "by metis"], ["proof (state)\nthis:\n  length (pathVertices u p) \\<le> card V\n\ngoal (1 subgoal):\n 1. length p < card V", "hence \"length p + 1 \\<le> card V\""], ["proof (prove)\nusing this:\n  length (pathVertices u p) \\<le> card V\n\ngoal (1 subgoal):\n 1. length p + 1 \\<le> card V", "by simp"], ["proof (state)\nthis:\n  length p + 1 \\<le> card V\n\ngoal (1 subgoal):\n 1. length p < card V", "thus ?thesis"], ["proof (prove)\nusing this:\n  length p + 1 \\<le> card V\n\ngoal (1 subgoal):\n 1. length p < card V", "by auto"], ["proof (state)\nthis:\n  length p < card V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma split_simple_path: \"isSimplePath u (p1@p2) v \n  \\<Longrightarrow> (\\<exists>w. isSimplePath u p1 w \\<and> isSimplePath w p2 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath u (p1 @ p2) v \\<Longrightarrow>\n    \\<exists>w. isSimplePath u p1 w \\<and> isSimplePath w p2 v", "apply (auto simp: isSimplePath_def isPath_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            isPath u p1 w \\<and>\n                            distinct (pathVertices u p1) \\<and>\n                            isPath w p2 v \\<and>\n                            distinct (pathVertices w p2)", "apply (rule exI; intro conjI; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 2. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (cases p1 rule: rev_cases) []"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = []\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 2. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 3. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 2. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (cases p2)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = []\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 2. \\<And>w ys y a list.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = a # list\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 3. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w ys y a list.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = a # list\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices u p1)\n 2. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (clarsimp simp: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (cases p1 rule: rev_cases) []"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = []\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)\n 2. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (cases p2  rule: rev_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w ys y.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = []\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)\n 2. \\<And>w ys y ysa ya.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w ys y ysa ya.\n       \\<lbrakk>distinct (pathVertices u (p1 @ p2)); isPath u p1 w;\n        isPath w p2 v; p1 = ys @ [y]; p2 = ysa @ [ya]\\<rbrakk>\n       \\<Longrightarrow> distinct (pathVertices w p2)", "apply (clarsimp simp: pathVertices_alt isPath_append)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simplePath_empty_conv[simp]: \"isSimplePath s [] t \\<longleftrightarrow> s=t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s [] t = (s = t)", "by (auto simp: isSimplePath_def)"], ["", "lemma simplePath_same_conv[simp]: \"isSimplePath s p s \\<longleftrightarrow> p=[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s p s = (p = [])", "apply rule"], ["proof (prove)\ngoal (2 subgoals):\n 1. isSimplePath s p s \\<Longrightarrow> p = []\n 2. p = [] \\<Longrightarrow> isSimplePath s p s", "apply (cases p; simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>isSimplePath s (a # list) s; p = a # list\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p = [] \\<Longrightarrow> isSimplePath s p s", "apply (rename_tac e pp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e pp.\n       \\<lbrakk>isSimplePath s (e # pp) s; p = e # pp\\<rbrakk>\n       \\<Longrightarrow> False\n 2. p = [] \\<Longrightarrow> isSimplePath s p s", "apply (case_tac pp rule: rev_cases; simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>e pp.\n       \\<lbrakk>isSimplePath s [e] s; p = [e]; pp = []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>e pp ys y.\n       \\<lbrakk>isSimplePath s (e # ys @ [y]) s; p = e # ys @ [y];\n        pp = ys @ [y]\\<rbrakk>\n       \\<Longrightarrow> False\n 3. p = [] \\<Longrightarrow> isSimplePath s p s", "apply (auto simp: isSimplePath_def pathVertices_alt isPath_append) [2]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<Longrightarrow> isSimplePath s p s", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isSPath_pathLE: \"isPath s p t \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath s p t \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t", "proof (induction p rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   isPath s ys t \\<longrightarrow>\n                   (\\<exists>p'. isSimplePath s p' t);\n        isPath s xs t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t", "case (1 p)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     isPath s ys t \\<longrightarrow> (\\<exists>p'. isSimplePath s p' t)\n  isPath s p t\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   isPath s ys t \\<longrightarrow>\n                   (\\<exists>p'. isSimplePath s p' t);\n        isPath s xs t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t", "hence IH: \"\\<And>p'. \\<lbrakk>length p' < length p; isPath s p' t\\<rbrakk> \n    \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t\"\n    and PATH: \"isPath s p t\""], ["proof (prove)\nusing this:\n  \\<forall>ys.\n     length ys < length p \\<longrightarrow>\n     isPath s ys t \\<longrightarrow> (\\<exists>p'. isSimplePath s p' t)\n  isPath s p t\n\ngoal (1 subgoal):\n 1. (\\<And>p'.\n        \\<lbrakk>length p' < length p; isPath s p' t\\<rbrakk>\n        \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t) &&&\n    isPath s p t", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>length ?p' < length p; isPath s ?p' t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t\n  isPath s p t\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>\\<forall>ys.\n                   length ys < length xs \\<longrightarrow>\n                   isPath s ys t \\<longrightarrow>\n                   (\\<exists>p'. isSimplePath s p' t);\n        isPath s xs t\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p'. isSimplePath s p' t", "show \"\\<exists>p. isSimplePath s p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p. isSimplePath s p t", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>p. isSimplePath s p t\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>p. isSimplePath s p t", "assume \"distinct (pathVertices_fwd s p)\""], ["proof (state)\nthis:\n  distinct (pathVertices_fwd s p)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow> \\<exists>p. isSimplePath s p t\n 2. \\<not> ?P \\<Longrightarrow> \\<exists>p. isSimplePath s p t", "thus ?thesis"], ["proof (prove)\nusing this:\n  distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. \\<exists>p. isSimplePath s p t", "using PATH"], ["proof (prove)\nusing this:\n  distinct (pathVertices_fwd s p)\n  isPath s p t\n\ngoal (1 subgoal):\n 1. \\<exists>p. isSimplePath s p t", "by (auto simp: isSimplePath_fwd)"], ["proof (state)\nthis:\n  \\<exists>p. isSimplePath s p t\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "assume \"\\<not>(distinct (pathVertices_fwd s p))\""], ["proof (state)\nthis:\n  \\<not> distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (pathVertices_fwd s p)", "obtain pv1 pv2 pv3 u where \"pathVertices_fwd s p = pv1@u#pv2@u#pv3\""], ["proof (prove)\nusing this:\n  \\<not> distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. (\\<And>pv1 u pv2 pv3.\n        pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: not_distinct_decomp)"], ["proof (state)\nthis:\n  pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "then"], ["proof (chain)\npicking this:\n  pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3", "obtain p1 p2 p3 where\n      \"p = p1@p2@p3\" \"p2\\<noteq>[]\" \"isPath s p1 u\" \"isPath u p3 t\""], ["proof (prove)\nusing this:\n  pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2 p3.\n        \\<lbrakk>p = p1 @ p2 @ p3; p2 \\<noteq> []; isPath s p1 u;\n         isPath u p3 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using PATH"], ["proof (prove)\nusing this:\n  pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3\n  isPath s p t\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2 p3.\n        \\<lbrakk>p = p1 @ p2 @ p3; p2 \\<noteq> []; isPath s p1 u;\n         isPath u p3 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>p1 p2 p3.\n                \\<lbrakk>p = p1 @ p2 @ p3; p2 \\<noteq> []; isPath s p1 u;\n                 isPath u p3 t\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3; isPath s p t\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (erule (1) split_path_at_vertex_complete[where s=s]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>\\<And>p1a p2a p3.\n                   \\<lbrakk>p1 @ p2 = p1a @ p2a @ p3; p2a \\<noteq> [];\n                    isPath s p1a u; isPath u p3 t\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        pathVertices_fwd s (p1 @ p2) = pv1 @ u # pv2 @ u # pv3; p = p1 @ p2;\n        isPath s p1 u; pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n        pathVertices_fwd u p2 = u # pv2 @ u # pv3\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (erule split_path_at_vertex_complete[of _ _ t \"u#pv2\" u pv3]; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2 p1a p2a.\n       \\<lbrakk>\\<And>p1b p2 p3.\n                   \\<lbrakk>p1 @ p1a @ p2a = p1b @ p2 @ p3; p2 \\<noteq> [];\n                    isPath s p1b u; isPath u p3 t\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        pathVertices_fwd s (p1 @ p1a @ p2a) = pv1 @ u # pv2 @ u # pv3;\n        p = p1 @ p1a @ p2a; isPath s p1 u;\n        pathVertices_fwd s p1 = pv1 @ [u];\n        pathVertices_fwd u (p1a @ p2a) = u # pv2 @ u # pv3; p2 = p1a @ p2a;\n        isPath u p1a u; pathVertices_fwd u p1a = u # pv2 @ [u];\n        isPath u p2a t; pathVertices_fwd u p2a = u # pv3\\<rbrakk>\n       \\<Longrightarrow> thesis", "apply (auto intro: that)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  p = p1 @ p2 @ p3\n  p2 \\<noteq> []\n  isPath s p1 u\n  isPath u p3 t\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "hence \"length (p1@p3) < length p\" \"isPath s (p1@p3) t\""], ["proof (prove)\nusing this:\n  p = p1 @ p2 @ p3\n  p2 \\<noteq> []\n  isPath s p1 u\n  isPath u p3 t\n\ngoal (1 subgoal):\n 1. length (p1 @ p3) < length p &&& isPath s (p1 @ p3) t", "by (auto simp: split_path_simps)"], ["proof (state)\nthis:\n  length (p1 @ p3) < length p\n  isPath s (p1 @ p3) t\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p) \\<Longrightarrow>\n    \\<exists>p. isSimplePath s p t", "thus ?case"], ["proof (prove)\nusing this:\n  length (p1 @ p3) < length p\n  isPath s (p1 @ p3) t\n\ngoal (1 subgoal):\n 1. \\<exists>p'. isSimplePath s p' t", "by (rule IH)"], ["proof (state)\nthis:\n  \\<exists>p'. isSimplePath s p' t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p. isSimplePath s p t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSPath_no_selfloop: \"isSimplePath u p v \\<Longrightarrow> (u1, u1) \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath u p v \\<Longrightarrow> (u1, u1) \\<notin> set p", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isSimplePath u p v; \\<not> (u1, u1) \\<notin> set p\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto simp: in_set_conv_decomp split_path_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma isSPath_sg_outgoing: \"\\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p; v1 \\<noteq> v2\\<rbrakk> \n  \\<Longrightarrow> (u1, v2) \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p;\n     v1 \\<noteq> v2\\<rbrakk>\n    \\<Longrightarrow> (u1, v2) \\<notin> set p", "by (auto simp: in_set_conv_decomp isSimplePath_def pathVertices_alt \n      append_eq_append_conv2 Cons_eq_append_conv append_eq_Cons_conv)"], ["", "lemma isSPath_sg_incoming: \n  \"\\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p; u1 \\<noteq> u2\\<rbrakk> \\<Longrightarrow> (u2, v1) \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isSimplePath u p v; (u1, v1) \\<in> set p;\n     u1 \\<noteq> u2\\<rbrakk>\n    \\<Longrightarrow> (u2, v1) \\<notin> set p", "by (auto simp: in_set_conv_decomp isSimplePath_fwd pathVertices_fwd_def\n      append_eq_append_conv2 append_eq_Cons_conv Cons_eq_append_conv)"], ["", "lemma isSPath_nt_parallel:\n  assumes SP: \"isSimplePath s p t\"\n  assumes EIP: \"e\\<in>set p\"\n  shows \"prod.swap e \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> set p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> set p", "from SP"], ["proof (chain)\npicking this:\n  isSimplePath s p t", "have P: \"isPath s p t\" and D: \"distinct (pathVertices_fwd s p)\""], ["proof (prove)\nusing this:\n  isSimplePath s p t\n\ngoal (1 subgoal):\n 1. isPath s p t &&& distinct (pathVertices_fwd s p)", "by (auto simp: isSimplePath_fwd)"], ["proof (state)\nthis:\n  isPath s p t\n  distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> set p", "show \"prod.swap e \\<notin> set p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod.swap e \\<notin> set p", "apply (cases e)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> prod.swap e \\<notin> set p", "using D EIP"], ["proof (prove)\nusing this:\n  distinct (pathVertices_fwd s p)\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. \\<And>a b. e = (a, b) \\<Longrightarrow> prod.swap e \\<notin> set p", "by(auto dest!: pathVertices_edge[OF P] simp add: append_eq_append_conv2 Cons_eq_append_conv append_eq_Cons_conv)"], ["proof (state)\nthis:\n  prod.swap e \\<notin> set p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma isSPath_nt_parallel_old: \n  \"isSimplePath u p v \\<Longrightarrow> (\\<forall>(u, v) \\<in> set p. (v, u) \\<notin> set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath u p v \\<Longrightarrow>\n    \\<forall>(u, v)\\<in>set p. (v, u) \\<notin> set p", "using isSPath_nt_parallel[of u p v]"], ["proof (prove)\nusing this:\n  \\<lbrakk>isSimplePath u p v; ?e \\<in> set p\\<rbrakk>\n  \\<Longrightarrow> prod.swap ?e \\<notin> set p\n\ngoal (1 subgoal):\n 1. isSimplePath u p v \\<Longrightarrow>\n    \\<forall>(u, v)\\<in>set p. (v, u) \\<notin> set p", "by auto"], ["", "corollary isSPath_nt_parallel_pf: \n  \"isSimplePath s p t \\<Longrightarrow> set p \\<inter> (set p)\\<inverse> = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s p t \\<Longrightarrow>\n    set p \\<inter> (set p)\\<inverse> = {}", "by (auto dest: isSPath_nt_parallel)"], ["", "lemma isSPath_distinct: \"isSimplePath u p v \\<Longrightarrow> distinct p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath u p v \\<Longrightarrow> distinct p", "apply (rule ccontr)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isSimplePath u p v; \\<not> distinct p\\<rbrakk>\n    \\<Longrightarrow> False", "apply (auto dest!: not_distinct_decomp simp: split_path_simps)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Edges adjacent to a node that does not lie on a path \n  are not contained in that path:\\<close>"], ["", "lemma adjacent_edges_not_on_path:\n  assumes PATH: \"isPath s p t\"\n  assumes VNV: \"v\\<notin>set (pathVertices_fwd s p)\"\n  shows \"adjacent v \\<inter> set p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adjacent v \\<inter> set p = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. adjacent v \\<inter> set p = {}", "from VNV"], ["proof (chain)\npicking this:\n  v \\<notin> set (pathVertices_fwd s p)", "have \"\\<forall>u. (u,v)\\<notin>set p \\<and> (v,u)\\<notin>set p\""], ["proof (prove)\nusing this:\n  v \\<notin> set (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p", "by (auto dest: pathVertices_edge[OF PATH])"], ["proof (state)\nthis:\n  \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p\n\ngoal (1 subgoal):\n 1. adjacent v \\<inter> set p = {}", "thus \"adjacent v \\<inter> set p = {}\""], ["proof (prove)\nusing this:\n  \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p\n\ngoal (1 subgoal):\n 1. adjacent v \\<inter> set p = {}", "by (auto simp: incoming_def outgoing_def adjacent_def)"], ["proof (state)\nthis:\n  adjacent v \\<inter> set p = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary \n  assumes \"isPath s p t\"\n  assumes \"v\\<notin>set (pathVertices_fwd s p)\"\n  shows incoming_edges_not_on_path: \"incoming v \\<inter> set p = {}\" \n    and outgoing_edges_not_on_path: \"outgoing v \\<inter> set p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incoming v \\<inter> set p = {} &&& outgoing v \\<inter> set p = {}", "using adjacent_edges_not_on_path[OF assms]"], ["proof (prove)\nusing this:\n  adjacent v \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. incoming v \\<inter> set p = {} &&& outgoing v \\<inter> set p = {}", "unfolding adjacent_def"], ["proof (prove)\nusing this:\n  (incoming v \\<union> outgoing v) \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. incoming v \\<inter> set p = {} &&& outgoing v \\<inter> set p = {}", "by auto"], ["", "text \\<open>A simple path over a vertex can be split at this vertex, \n  and there are exactly two edges on the path touching this vertex.\\<close>"], ["", "lemma adjacent_edges_on_simple_path:\n  assumes SPATH: \"isSimplePath s p t\"\n  assumes VNV: \"v\\<in>set (pathVertices_fwd s p)\" \"v\\<noteq>s\" \"v\\<noteq>t\"\n  obtains p1 u w p2 where \n    \"p = p1@(u,v)#(v,w)#p2\" \n    \"incoming v \\<inter> set p = {(u,v)}\" \n    \"outgoing v \\<inter> set p = {(v,w)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from SPATH"], ["proof (chain)\npicking this:\n  isSimplePath s p t", "have \n    PATH: \"isPath s p t\" and \n    DIST: \"distinct (pathVertices_fwd s p)\""], ["proof (prove)\nusing this:\n  isSimplePath s p t\n\ngoal (1 subgoal):\n 1. isPath s p t &&& distinct (pathVertices_fwd s p)", "by (auto simp: isSimplePath_def pathVertices_fwd)"], ["proof (state)\nthis:\n  isPath s p t\n  distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from split_path_at_vertex[OF VNV(1) PATH]"], ["proof (chain)\npicking this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; isPath s p1 v; isPath v p2 t\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p1 p2 where \n    [simp]: \"p=p1@p2\" and P1: \"isPath s p1 v\" and P2: \"isPath v p2 t\""], ["proof (prove)\nusing this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; isPath s p1 v; isPath v p2 t\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; isPath s p1 v; isPath v p2 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p = p1 @ p2\n  isPath s p1 v\n  isPath v p2 t\n\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>v\\<noteq>s\\<close> P1"], ["proof (chain)\npicking this:\n  v \\<noteq> s\n  isPath s p1 v", "obtain p1' u where \n    [simp]: \"p1=p1'@[(u,v)]\" and P1': \"isPath s p1' u\" and UV: \"(u,v)\\<in>E\""], ["proof (prove)\nusing this:\n  v \\<noteq> s\n  isPath s p1 v\n\ngoal (1 subgoal):\n 1. (\\<And>p1' u.\n        \\<lbrakk>p1 = p1' @ [(u, v)]; isPath s p1' u;\n         (u, v) \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p1 rule: rev_cases) (auto simp: split_path_simps)"], ["proof (state)\nthis:\n  p1 = p1' @ [(u, v)]\n  isPath s p1' u\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "from \\<open>v\\<noteq>t\\<close> P2"], ["proof (chain)\npicking this:\n  v \\<noteq> t\n  isPath v p2 t", "obtain w p2' where \n    [simp]: \"p2=(v,w)#p2'\" and VW: \"(v,w)\\<in>E\" and P2': \"isPath w p2' t\""], ["proof (prove)\nusing this:\n  v \\<noteq> t\n  isPath v p2 t\n\ngoal (1 subgoal):\n 1. (\\<And>w p2'.\n        \\<lbrakk>p2 = (v, w) # p2'; (v, w) \\<in> E; isPath w p2' t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p2) (auto)"], ["proof (state)\nthis:\n  p2 = (v, w) # p2'\n  (v, w) \\<in> E\n  isPath w p2' t\n\ngoal (1 subgoal):\n 1. (\\<And>p1 u w p2.\n        \\<lbrakk>p = p1 @ (u, v) # (v, w) # p2;\n         incoming v \\<inter> set p = {(u, v)};\n         outgoing v \\<inter> set p = {(v, w)}\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "apply (rule that[of p1' u w p2'])"], ["proof (prove)\ngoal (3 subgoals):\n 1. p = p1' @ (u, v) # (v, w) # p2'\n 2. incoming v \\<inter> set p = {(u, v)}\n 3. outgoing v \\<inter> set p = {(v, w)}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. incoming v \\<inter> set p = {(u, v)}\n 2. outgoing v \\<inter> set p = {(v, w)}", "using \n      isSPath_sg_outgoing[OF SPATH, of v w] \n      isSPath_sg_incoming[OF SPATH, of u v]\n      isPath_edgeset[OF PATH]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, w) \\<in> set p; w \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> (v, ?v2.0) \\<notin> set p\n  \\<lbrakk>(u, v) \\<in> set p; u \\<noteq> ?u2.0\\<rbrakk>\n  \\<Longrightarrow> (?u2.0, v) \\<notin> set p\n  ?e \\<in> set p \\<Longrightarrow> ?e \\<in> E\n\ngoal (2 subgoals):\n 1. incoming v \\<inter> set p = {(u, v)}\n 2. outgoing v \\<inter> set p = {(v, w)}", "apply (fastforce simp: incoming_def outgoing_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Distance\\<close>"], ["", "lemma connected_by_dist: \"connected v v' = (\\<exists>d. dist v d v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected v v' = (\\<exists>d. dist v d v')", "by (auto simp: dist_def connected_def)"], ["", "lemma isPath_distD: \"isPath u p v \\<Longrightarrow> dist u (length p) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isPath u p v \\<Longrightarrow> dist u (length p) v", "by (auto simp: dist_def)"], ["", "lemma\n  shows connected_distI[intro]: \"dist v d v' \\<Longrightarrow> connected v v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v d v' \\<Longrightarrow> connected v v'", "(*and connectedI_succ: \"connected v v' \\<Longrightarrow> (v',v'') \\<in> E \\<Longrightarrow> connected v v''\"*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v d v' \\<Longrightarrow> connected v v'", "by (auto simp: dist_def connected_def intro: isPath_append_edge)"], ["", "lemma min_distI2: \n  \"\\<lbrakk>connected v v'; \\<And>d. \\<lbrakk>dist v d v'; \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk> \\<Longrightarrow> Q d\\<rbrakk> \n    \\<Longrightarrow> Q (min_dist v v')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>connected v v';\n     \\<And>d.\n        \\<lbrakk>dist v d v';\n         \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n        \\<Longrightarrow> Q d\\<rbrakk>\n    \\<Longrightarrow> Q (min_dist v v')", "unfolding min_dist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>connected v v';\n     \\<And>d.\n        \\<lbrakk>dist v d v';\n         \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n        \\<Longrightarrow> Q d\\<rbrakk>\n    \\<Longrightarrow> Q (LEAST d. dist v d v')", "apply (rule LeastI2_wellorder[where Q=Q and a=\"SOME d. dist v d v'\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>connected v v';\n     \\<And>d.\n        \\<lbrakk>dist v d v';\n         \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n        \\<Longrightarrow> Q d\\<rbrakk>\n    \\<Longrightarrow> dist v (SOME d. dist v d v') v'\n 2. \\<And>a.\n       \\<lbrakk>connected v v';\n        \\<And>d.\n           \\<lbrakk>dist v d v';\n            \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n           \\<Longrightarrow> Q d;\n        dist v a v';\n        \\<forall>b. dist v b v' \\<longrightarrow> a \\<le> b\\<rbrakk>\n       \\<Longrightarrow> Q a", "apply (auto simp: connected_by_dist intro: someI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_distI_eq:\n  \"\\<lbrakk> dist v d v'; \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d' \\<rbrakk> \\<Longrightarrow> min_dist v v' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist v d v';\n     \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n    \\<Longrightarrow> min_dist v v' = d", "by (force intro: min_distI2 simp: connected_by_dist)"], ["", "text \\<open>Two nodes are connected by a path of length \\<open>0\\<close>, \n  iff they are equal.\\<close>"], ["", "lemma dist_z_iff[simp]: \"dist v 0 v' \\<longleftrightarrow> v'=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v 0 v' = (v' = v)", "by (auto simp: dist_def)"], ["", "lemma dist_z[simp, intro!]: \"dist v 0 v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v 0 v", "by simp"], ["", "lemma dist_suc: \"\\<lbrakk>dist v d v'; (v',v'')\\<in>E\\<rbrakk> \\<Longrightarrow> dist v (Suc d) v''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist v d v'; (v', v'') \\<in> E\\<rbrakk>\n    \\<Longrightarrow> dist v (Suc d) v''", "by (auto simp: dist_def intro: isPath_append_edge)"], ["", "lemma dist_cases[case_names dist_z dist_suc, consumes 1, cases pred]:\n  assumes \"dist v d v'\"\n  obtains \"v=v'\" \"d=0\"\n   | vh dd where \"d=Suc dd\" \"dist v dd vh\" \"(vh,v')\\<in>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v = v'; d = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>dd vh.\n        \\<lbrakk>d = Suc dd; dist v dd vh; (vh, v') \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using assms"], ["proof (prove)\nusing this:\n  dist v d v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrakk>v = v'; d = 0\\<rbrakk> \\<Longrightarrow> thesis;\n     \\<And>dd vh.\n        \\<lbrakk>d = Suc dd; dist v dd vh; (vh, v') \\<in> E\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "apply (cases d; clarsimp simp add: dist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat p.\n       \\<lbrakk>\\<And>dd vh.\n                   \\<lbrakk>nat = dd;\n                    \\<exists>p. isPath v p vh \\<and> length p = dd;\n                    (vh, v') \\<in> E\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        d = Suc nat; isPath v p v'; length p = Suc nat\\<rbrakk>\n       \\<Longrightarrow> thesis", "subgoal for \\<dots> p"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>dd vh.\n                \\<lbrakk>nat_ = dd;\n                 \\<exists>p. isPath v p vh \\<and> length p = dd;\n                 (vh, v') \\<in> E\\<rbrakk>\n                \\<Longrightarrow> thesis;\n     d = Suc nat_; isPath v p v'; length p = Suc nat_\\<rbrakk>\n    \\<Longrightarrow> thesis", "by(cases p rule: rev_cases)(fastforce simp add: isPath_append)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The same holds for \\<open>min_dist\\<close>, i.e., \n  the shortest path between two nodes has length \\<open>0\\<close>, \n  iff these nodes are equal.\\<close>"], ["", "lemma min_dist_z[simp]: \"min_dist v v = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist v v = 0", "by (rule min_distI2) auto"], ["", "lemma min_dist_z_iff[simp]: \"connected v v' \\<Longrightarrow> min_dist v v' = 0 \\<longleftrightarrow> v'=v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected v v' \\<Longrightarrow> (min_dist v v' = 0) = (v' = v)", "by (rule min_distI2) (auto)"], ["", "lemma min_dist_is_dist: \"connected v v' \\<Longrightarrow> dist v (min_dist v v') v'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. connected v v' \\<Longrightarrow> dist v (min_dist v v') v'", "by (auto intro: min_distI2)"], ["", "lemma min_dist_minD: \"dist v d v' \\<Longrightarrow> min_dist v v' \\<le> d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist v d v' \\<Longrightarrow> min_dist v v' \\<le> d", "by (auto intro: min_distI2)"], ["", "text \\<open>We also provide introduction and destruction rules for the\n  pattern \\<open>min_dist v v' = Suc d\\<close>.\n\\<close>"], ["", "lemma min_dist_succ: \n  \"\\<lbrakk> connected v v'; (v',v'') \\<in> E \\<rbrakk> \\<Longrightarrow> min_dist v v'' \\<le> Suc (min_dist v v') \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>connected v v'; (v', v'') \\<in> E\\<rbrakk>\n    \\<Longrightarrow> min_dist v v'' \\<le> Suc (min_dist v v')", "apply (rule min_distI2[where v'=v'])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>connected v v'; (v', v'') \\<in> E\\<rbrakk>\n    \\<Longrightarrow> connected v v'\n 2. \\<And>d.\n       \\<lbrakk>connected v v'; (v', v'') \\<in> E; dist v d v';\n        \\<And>d'. dist v d' v' \\<Longrightarrow> d \\<le> d'\\<rbrakk>\n       \\<Longrightarrow> min_dist v v'' \\<le> Suc d", "apply (auto intro!: min_dist_minD intro: dist_suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma min_dist_suc:\n  assumes c: \"connected v v'\" \"min_dist v v' = Suc d\"\n  shows \"\\<exists>v''. connected v v'' \\<and> (v'',v') \\<in> E \\<and> min_dist v v'' = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v''.\n       connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v''.\n       connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d", "from min_dist_is_dist[OF c(1)]"], ["proof (chain)\npicking this:\n  dist v (min_dist v v') v'", "have \"min_dist v v' = Suc d \\<longrightarrow> ?thesis\""], ["proof (prove)\nusing this:\n  dist v (min_dist v v') v'\n\ngoal (1 subgoal):\n 1. min_dist v v' = Suc d \\<longrightarrow>\n    (\\<exists>v''.\n        connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>v = v'; min_dist v v' = 0\\<rbrakk>\n    \\<Longrightarrow> min_dist v v' = Suc d \\<longrightarrow>\n                      (\\<exists>v''.\n                          connected v v'' \\<and>\n                          (v'', v') \\<in> E \\<and> min_dist v v'' = d)\n 2. \\<And>vh dd.\n       \\<lbrakk>min_dist v v' = Suc dd; dist v dd vh;\n        (vh, v') \\<in> E\\<rbrakk>\n       \\<Longrightarrow> min_dist v v' = Suc d \\<longrightarrow>\n                         (\\<exists>v''.\n                             connected v v'' \\<and>\n                             (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "case (dist_suc v'' d')"], ["proof (state)\nthis:\n  min_dist v v' = Suc d'\n  dist v d' v''\n  (v'', v') \\<in> E\n\ngoal (2 subgoals):\n 1. \\<lbrakk>v = v'; min_dist v v' = 0\\<rbrakk>\n    \\<Longrightarrow> min_dist v v' = Suc d \\<longrightarrow>\n                      (\\<exists>v''.\n                          connected v v'' \\<and>\n                          (v'', v') \\<in> E \\<and> min_dist v v'' = d)\n 2. \\<And>vh dd.\n       \\<lbrakk>min_dist v v' = Suc dd; dist v dd vh;\n        (vh, v') \\<in> E\\<rbrakk>\n       \\<Longrightarrow> min_dist v v' = Suc d \\<longrightarrow>\n                         (\\<exists>v''.\n                             connected v v'' \\<and>\n                             (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "then"], ["proof (chain)\npicking this:\n  min_dist v v' = Suc d'\n  dist v d' v''\n  (v'', v') \\<in> E", "show ?thesis"], ["proof (prove)\nusing this:\n  min_dist v v' = Suc d'\n  dist v d' v''\n  (v'', v') \\<in> E\n\ngoal (1 subgoal):\n 1. min_dist v v' = Suc d \\<longrightarrow>\n    (\\<exists>v''.\n        connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "using min_dist_succ[of v v'' v'] min_dist_minD[of v d v'']"], ["proof (prove)\nusing this:\n  min_dist v v' = Suc d'\n  dist v d' v''\n  (v'', v') \\<in> E\n  \\<lbrakk>connected v v''; (v'', v') \\<in> E\\<rbrakk>\n  \\<Longrightarrow> min_dist v v' \\<le> Suc (min_dist v v'')\n  dist v d v'' \\<Longrightarrow> min_dist v v'' \\<le> d\n\ngoal (1 subgoal):\n 1. min_dist v v' = Suc d \\<longrightarrow>\n    (\\<exists>v''.\n        connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "by (auto simp: connected_distI)"], ["proof (state)\nthis:\n  min_dist v v' = Suc d \\<longrightarrow>\n  (\\<exists>v''.\n      connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>v = v'; min_dist v v' = 0\\<rbrakk>\n    \\<Longrightarrow> min_dist v v' = Suc d \\<longrightarrow>\n                      (\\<exists>v''.\n                          connected v v'' \\<and>\n                          (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "qed simp"], ["proof (state)\nthis:\n  min_dist v v' = Suc d \\<longrightarrow>\n  (\\<exists>v''.\n      connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)\n\ngoal (1 subgoal):\n 1. \\<exists>v''.\n       connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d", "with c"], ["proof (chain)\npicking this:\n  connected v v'\n  min_dist v v' = Suc d\n  min_dist v v' = Suc d \\<longrightarrow>\n  (\\<exists>v''.\n      connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)", "show ?thesis"], ["proof (prove)\nusing this:\n  connected v v'\n  min_dist v v' = Suc d\n  min_dist v v' = Suc d \\<longrightarrow>\n  (\\<exists>v''.\n      connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d)\n\ngoal (1 subgoal):\n 1. \\<exists>v''.\n       connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d", "by simp"], ["proof (state)\nthis:\n  \\<exists>v''.\n     connected v v'' \\<and> (v'', v') \\<in> E \\<and> min_dist v v'' = d\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If there is a node with a shortest path of length \\<open>d\\<close>, \n  then, for any \\<open>d'<d\\<close>, there is also a node with a shortest path\n  of length \\<open>d'\\<close>.\n\\<close>"], ["", "lemma min_dist_less:\n  assumes \"connected src v\" \"min_dist src v = d\" and \"d' < d\"\n  shows \"\\<exists>v'. connected src v' \\<and> min_dist src v' = d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v'. connected src v' \\<and> min_dist src v' = d'", "using assms"], ["proof (prove)\nusing this:\n  connected src v\n  min_dist src v = d\n  d' < d\n\ngoal (1 subgoal):\n 1. \\<exists>v'. connected src v' \\<and> min_dist src v' = d'", "proof (induct d arbitrary: v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>connected src v; min_dist src v = 0; d' < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            connected src v' \\<and> min_dist src v' = d'\n 2. \\<And>d v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>connected src v; min_dist src v = d;\n                    d' < d\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>v'.\n  connected src v' \\<and> min_dist src v' = d';\n        connected src v; min_dist src v = Suc d; d' < Suc d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            connected src v' \\<and> min_dist src v' = d'", "case (Suc d)"], ["proof (state)\nthis:\n  \\<lbrakk>connected src ?v; min_dist src ?v = d; d' < d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       connected src v' \\<and> min_dist src v' = d'\n  connected src v\n  min_dist src v = Suc d\n  d' < Suc d\n\ngoal (2 subgoals):\n 1. \\<And>v.\n       \\<lbrakk>connected src v; min_dist src v = 0; d' < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            connected src v' \\<and> min_dist src v' = d'\n 2. \\<And>d v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>connected src v; min_dist src v = d;\n                    d' < d\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>v'.\n  connected src v' \\<and> min_dist src v' = d';\n        connected src v; min_dist src v = Suc d; d' < Suc d\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            connected src v' \\<and> min_dist src v' = d'", "with min_dist_suc[of src v]"], ["proof (chain)\npicking this:\n  \\<lbrakk>connected src v; min_dist src v = Suc ?d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v''.\n                       connected src v'' \\<and>\n                       (v'', v) \\<in> E \\<and> min_dist src v'' = ?d\n  \\<lbrakk>connected src ?v; min_dist src ?v = d; d' < d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       connected src v' \\<and> min_dist src v' = d'\n  connected src v\n  min_dist src v = Suc d\n  d' < Suc d", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>connected src v; min_dist src v = Suc ?d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v''.\n                       connected src v'' \\<and>\n                       (v'', v) \\<in> E \\<and> min_dist src v'' = ?d\n  \\<lbrakk>connected src ?v; min_dist src ?v = d; d' < d\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       connected src v' \\<and> min_dist src v' = d'\n  connected src v\n  min_dist src v = Suc d\n  d' < Suc d\n\ngoal (1 subgoal):\n 1. \\<exists>v'. connected src v' \\<and> min_dist src v' = d'", "by (cases \"d' = d\") auto"], ["proof (state)\nthis:\n  \\<exists>v'. connected src v' \\<and> min_dist src v' = d'\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>connected src v; min_dist src v = 0; d' < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>v'.\n                            connected src v' \\<and> min_dist src v' = d'", "qed auto"], ["", "text \\<open>\n  Lemma \\<open>min_dist_less\\<close> can be weakened to \\<open>d'\\<le>d\\<close>.\n\\<close>"], ["", "corollary min_dist_le:\n  assumes c: \"connected src v\" and d': \"d' \\<le> min_dist src v\"\n  shows \"\\<exists>v'. connected src v' \\<and> min_dist src v' = d'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v'. connected src v' \\<and> min_dist src v' = d'", "using min_dist_less[OF c, of \"min_dist src v\" d'] d' c"], ["proof (prove)\nusing this:\n  \\<lbrakk>min_dist src v = min_dist src v; d' < min_dist src v\\<rbrakk>\n  \\<Longrightarrow> \\<exists>v'.\n                       connected src v' \\<and> min_dist src v' = d'\n  d' \\<le> min_dist src v\n  connected src v\n\ngoal (1 subgoal):\n 1. \\<exists>v'. connected src v' \\<and> min_dist src v' = d'", "by (auto simp: le_less)"], ["", "lemma dist_trans[trans]: \"dist u d1 w \\<Longrightarrow> dist w d2 v \\<Longrightarrow> dist u (d1+d2) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dist u d1 w; dist w d2 v\\<rbrakk>\n    \\<Longrightarrow> dist u (d1 + d2) v", "apply (clarsimp simp: dist_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p pa.\n       \\<lbrakk>isPath u p w; d1 = length p; isPath w pa v;\n        d2 = length pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>pb.\n                            isPath u pb v \\<and>\n                            length pb = length p + length pa", "apply (rename_tac p1 p2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>isPath u p1 w; d1 = length p1; isPath w p2 v;\n        d2 = length p2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            isPath u p v \\<and>\n                            length p = length p1 + length p2", "apply (rule_tac x=\"p1@p2\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p1 p2.\n       \\<lbrakk>isPath u p1 w; d1 = length p1; isPath w p2 v;\n        d2 = length p2\\<rbrakk>\n       \\<Longrightarrow> isPath u (p1 @ p2) v \\<and>\n                         length (p1 @ p2) = length p1 + length p2", "by (auto simp: isPath_append)"], ["", "lemma min_dist_split:\n  assumes D1: \"dist u d1 w\" and D2: \"dist w d2 v\" and MIN: \"min_dist u v = d1+d2\"\n  shows \"min_dist u w = d1\" \"min_dist w v = d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist u w = d1 &&& min_dist w v = d2", "apply (metis assms ab_semigroup_add_class.add.commute add_le_cancel_left \n    dist_trans min_distI_eq min_dist_minD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist w v = d2", "by (metis assms add_le_cancel_left dist_trans min_distI_eq min_dist_minD)"], ["", "lemma \\<comment> \\<open>Manual proof\\<close>\n  assumes D1: \"dist u d1 w\" and D2: \"dist w d2 v\" and MIN: \"min_dist u v = d1+d2\"\n  shows \"min_dist u w = d1\" \"min_dist w v = d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist u w = d1 &&& min_dist w v = d2", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "from min_dist_minD[OF \\<open>dist u d1 w\\<close>]"], ["proof (chain)\npicking this:\n  min_dist u w \\<le> d1", "have \"min_dist u w \\<le> d1\""], ["proof (prove)\nusing this:\n  min_dist u w \\<le> d1\n\ngoal (1 subgoal):\n 1. min_dist u w \\<le> d1", "."], ["proof (state)\nthis:\n  min_dist u w \\<le> d1\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  min_dist u w \\<le> d1\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "{"], ["proof (state)\nthis:\n  min_dist u w \\<le> d1\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "have \"dist u (min_dist u w) w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist u (min_dist u w) w", "apply (rule min_dist_is_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. connected u w", "using D1"], ["proof (prove)\nusing this:\n  dist u d1 w\n\ngoal (1 subgoal):\n 1. connected u w", "by auto"], ["proof (state)\nthis:\n  dist u (min_dist u w) w\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "also"], ["proof (state)\nthis:\n  dist u (min_dist u w) w\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "note D2"], ["proof (state)\nthis:\n  dist w d2 v\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "finally"], ["proof (chain)\npicking this:\n  dist u (min_dist u w + d2) v", "have \"dist u (min_dist u w + d2) v\""], ["proof (prove)\nusing this:\n  dist u (min_dist u w + d2) v\n\ngoal (1 subgoal):\n 1. dist u (min_dist u w + d2) v", "."], ["proof (state)\nthis:\n  dist u (min_dist u w + d2) v\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  dist u (min_dist u w + d2) v\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "assume \"min_dist u w < d1\""], ["proof (state)\nthis:\n  min_dist u w < d1\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  min_dist u w < d1\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "note MIN"], ["proof (state)\nthis:\n  min_dist u v = d1 + d2\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "ultimately"], ["proof (chain)\npicking this:\n  dist u (min_dist u w + d2) v\n  min_dist u w < d1\n  min_dist u v = d1 + d2", "have False"], ["proof (prove)\nusing this:\n  dist u (min_dist u w + d2) v\n  min_dist u w < d1\n  min_dist u v = d1 + d2\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: min_dist_minD)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "}"], ["proof (state)\nthis:\n  min_dist u w < d1 \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. min_dist u w = d1\n 2. min_dist w v = d2", "ultimately"], ["proof (chain)\npicking this:\n  min_dist u w \\<le> d1\n  min_dist u w < d1 \\<Longrightarrow> False", "show \"min_dist u w = d1\""], ["proof (prove)\nusing this:\n  min_dist u w \\<le> d1\n  min_dist u w < d1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. min_dist u w = d1", "unfolding not_less[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> d1 < min_dist u w\n  min_dist u w < d1 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. min_dist u w = d1", "using nat_neq_iff"], ["proof (prove)\nusing this:\n  \\<not> d1 < min_dist u w\n  min_dist u w < d1 \\<Longrightarrow> False\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. min_dist u w = d1", "by blast"], ["proof (state)\nthis:\n  min_dist u w = d1\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "from min_dist_minD[OF \\<open>dist w d2 v\\<close>]"], ["proof (chain)\npicking this:\n  min_dist w v \\<le> d2", "have \"min_dist w v \\<le> d2\""], ["proof (prove)\nusing this:\n  min_dist w v \\<le> d2\n\ngoal (1 subgoal):\n 1. min_dist w v \\<le> d2", "."], ["proof (state)\nthis:\n  min_dist w v \\<le> d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  min_dist w v \\<le> d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "{"], ["proof (state)\nthis:\n  min_dist w v \\<le> d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "note D1"], ["proof (state)\nthis:\n  dist u d1 w\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "also"], ["proof (state)\nthis:\n  dist u d1 w\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "have \"dist w (min_dist w v) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dist w (min_dist w v) v", "apply (rule min_dist_is_dist)"], ["proof (prove)\ngoal (1 subgoal):\n 1. connected w v", "using D2"], ["proof (prove)\nusing this:\n  dist w d2 v\n\ngoal (1 subgoal):\n 1. connected w v", "by auto"], ["proof (state)\nthis:\n  dist w (min_dist w v) v\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "finally"], ["proof (chain)\npicking this:\n  dist u (d1 + min_dist w v) v", "have \"dist u (d1 + min_dist w v) v\""], ["proof (prove)\nusing this:\n  dist u (d1 + min_dist w v) v\n\ngoal (1 subgoal):\n 1. dist u (d1 + min_dist w v) v", "."], ["proof (state)\nthis:\n  dist u (d1 + min_dist w v) v\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  dist u (d1 + min_dist w v) v\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "assume \"min_dist w v < d2\""], ["proof (state)\nthis:\n  min_dist w v < d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "moreover"], ["proof (state)\nthis:\n  min_dist w v < d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "note MIN"], ["proof (state)\nthis:\n  min_dist u v = d1 + d2\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "ultimately"], ["proof (chain)\npicking this:\n  dist u (d1 + min_dist w v) v\n  min_dist w v < d2\n  min_dist u v = d1 + d2", "have False"], ["proof (prove)\nusing this:\n  dist u (d1 + min_dist w v) v\n  min_dist w v < d2\n  min_dist u v = d1 + d2\n\ngoal (1 subgoal):\n 1. False", "by (auto dest: min_dist_minD)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "}"], ["proof (state)\nthis:\n  min_dist w v < d2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "ultimately"], ["proof (chain)\npicking this:\n  min_dist w v \\<le> d2\n  min_dist w v < d2 \\<Longrightarrow> False", "show \"min_dist w v = d2\""], ["proof (prove)\nusing this:\n  min_dist w v \\<le> d2\n  min_dist w v < d2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "unfolding not_less[symmetric]"], ["proof (prove)\nusing this:\n  \\<not> d2 < min_dist w v\n  min_dist w v < d2 \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "using nat_neq_iff"], ["proof (prove)\nusing this:\n  \\<not> d2 < min_dist w v\n  min_dist w v < d2 \\<Longrightarrow> False\n  (?m \\<noteq> ?n) = (?m < ?n \\<or> ?n < ?m)\n\ngoal (1 subgoal):\n 1. min_dist w v = d2", "by blast"], ["proof (state)\nthis:\n  min_dist w v = d2\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Shortest Paths\\<close>"], ["", "text \\<open>Characterization of shortest path in terms of minimum distance\\<close>"], ["", "lemma isShortestPath_min_dist_def: \n  \"isShortestPath u p v \\<longleftrightarrow> isPath u p v \\<and> length p = min_dist u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isShortestPath u p v = (isPath u p v \\<and> length p = min_dist u v)", "unfolding isShortestPath_def min_dist_def dist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (isPath u p v \\<and>\n     (\\<forall>p'.\n         isPath u p' v \\<longrightarrow> length p \\<le> length p')) =\n    (isPath u p v \\<and>\n     length p = (LEAST d. \\<exists>p. isPath u p v \\<and> length p = d))", "apply (rule iffI; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>isPath u p v;\n     \\<forall>p'.\n        isPath u p' v \\<longrightarrow> length p \\<le> length p'\\<rbrakk>\n    \\<Longrightarrow> length p =\n                      (LEAST d.\n                          \\<exists>p. isPath u p v \\<and> length p = d)\n 2. \\<And>p'.\n       \\<lbrakk>isPath u p v;\n        length p = (LEAST d. \\<exists>p. isPath u p v \\<and> length p = d);\n        isPath u p' v\\<rbrakk>\n       \\<Longrightarrow> (LEAST d.\n                             \\<exists>p. isPath u p v \\<and> length p = d)\n                         \\<le> length p'", "apply (rule Least_equality[symmetric]; auto; fail)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p'.\n       \\<lbrakk>isPath u p v;\n        length p = (LEAST d. \\<exists>p. isPath u p v \\<and> length p = d);\n        isPath u p' v\\<rbrakk>\n       \\<Longrightarrow> (LEAST d.\n                             \\<exists>p. isPath u p v \\<and> length p = d)\n                         \\<le> length p'", "apply (rule Least_le; auto; fail)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma obtain_shortest_path: \n  assumes CONN: \"connected u v\"  \n  obtains p where \"isShortestPath u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p.\n        isShortestPath u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using min_dist_is_dist[OF CONN]"], ["proof (prove)\nusing this:\n  dist u (min_dist u v) v\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        isShortestPath u p v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding dist_def isShortestPath_min_dist_def"], ["proof (prove)\nusing this:\n  \\<exists>p. isPath u p v \\<and> length p = min_dist u v\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        isPath u p v \\<and> length p = min_dist u v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma shortestPath_is_simple:\n  assumes \"isShortestPath s p t\"\n  shows \"isSimplePath s p t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isSimplePath s p t", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "from assms"], ["proof (chain)\npicking this:\n  isShortestPath s p t", "have PATH: \"isPath s p t\" \n    and SHORTEST: \"\\<forall>p'. isPath s p' t \\<longrightarrow> length p \\<le> length p'\""], ["proof (prove)\nusing this:\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. isPath s p t &&&\n    \\<forall>p'. isPath s p' t \\<longrightarrow> length p \\<le> length p'", "by (auto simp: isShortestPath_def)"], ["proof (state)\nthis:\n  isPath s p t\n  \\<forall>p'. isPath s p' t \\<longrightarrow> length p \\<le> length p'\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "assume \"\\<not>isSimplePath s p t\""], ["proof (state)\nthis:\n  \\<not> isSimplePath s p t\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "with PATH"], ["proof (chain)\npicking this:\n  isPath s p t\n  \\<not> isSimplePath s p t", "have \"\\<not>distinct (pathVertices_fwd s p)\""], ["proof (prove)\nusing this:\n  isPath s p t\n  \\<not> isSimplePath s p t\n\ngoal (1 subgoal):\n 1. \\<not> distinct (pathVertices_fwd s p)", "by (auto simp: isSimplePath_fwd)"], ["proof (state)\nthis:\n  \\<not> distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> distinct (pathVertices_fwd s p)", "obtain pv1 u pv2 pv3 where PV: \"pathVertices_fwd s p = pv1@u#pv2@u#pv3\""], ["proof (prove)\nusing this:\n  \\<not> distinct (pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. (\\<And>pv1 u pv2 pv3.\n        pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: not_distinct_decomp)"], ["proof (state)\nthis:\n  pathVertices_fwd s p = pv1 @ u # pv2 @ u # pv3\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "from split_path_at_vertex_complete[OF PATH PV]"], ["proof (chain)\npicking this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n       pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n       pathVertices_fwd u p2 = u # pv2 @ u # pv3\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p1 p23 where\n    [simp]: \"p=p1@p23\" and \n      P1: \"isPath s p1 u\" \"pathVertices_fwd s p1 = pv1@[u]\" and\n      P23: \"isPath u p23 t\" \"pathVertices_fwd u p23 = (u#pv2)@u#pv3\""], ["proof (prove)\nusing this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; isPath s p1 u;\n       pathVertices_fwd s p1 = pv1 @ [u]; isPath u p2 t;\n       pathVertices_fwd u p2 = u # pv2 @ u # pv3\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p23.\n        \\<lbrakk>p = p1 @ p23; isPath s p1 u;\n         pathVertices_fwd s p1 = pv1 @ [u]; isPath u p23 t;\n         pathVertices_fwd u p23 = (u # pv2) @ u # pv3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = p1 @ p23\n  isPath s p1 u\n  pathVertices_fwd s p1 = pv1 @ [u]\n  isPath u p23 t\n  pathVertices_fwd u p23 = (u # pv2) @ u # pv3\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "from split_path_at_vertex_complete[OF P23]"], ["proof (chain)\npicking this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p23 = p1 @ p2; isPath u p1 u;\n       pathVertices_fwd u p1 = (u # pv2) @ [u]; isPath u p2 t;\n       pathVertices_fwd u p2 = u # pv3\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p2 p3 where\n    [simp]: \"p23 = p2@p3\" and\n    P2: \"isPath u p2 u\" \"pathVertices_fwd u p2 = u#pv2@[u]\" and\n    P3: \"isPath u p3 t\" \"pathVertices_fwd u p3 = u#pv3\""], ["proof (prove)\nusing this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p23 = p1 @ p2; isPath u p1 u;\n       pathVertices_fwd u p1 = (u # pv2) @ [u]; isPath u p2 t;\n       pathVertices_fwd u p2 = u # pv3\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p2 p3.\n        \\<lbrakk>p23 = p2 @ p3; isPath u p2 u;\n         pathVertices_fwd u p2 = u # pv2 @ [u]; isPath u p3 t;\n         pathVertices_fwd u p3 = u # pv3\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p23 = p2 @ p3\n  isPath u p2 u\n  pathVertices_fwd u p2 = u # pv2 @ [u]\n  isPath u p3 t\n  pathVertices_fwd u p3 = u # pv3\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "from P1(1) P3(1)"], ["proof (chain)\npicking this:\n  isPath s p1 u\n  isPath u p3 t", "have SHORTER_PATH: \"isPath s (p1@p3) t\""], ["proof (prove)\nusing this:\n  isPath s p1 u\n  isPath u p3 t\n\ngoal (1 subgoal):\n 1. isPath s (p1 @ p3) t", "by (auto simp: isPath_append)"], ["proof (state)\nthis:\n  isPath s (p1 @ p3) t\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "from P2"], ["proof (chain)\npicking this:\n  isPath u p2 u\n  pathVertices_fwd u p2 = u # pv2 @ [u]", "have \"p2\\<noteq>[]\""], ["proof (prove)\nusing this:\n  isPath u p2 u\n  pathVertices_fwd u p2 = u # pv2 @ [u]\n\ngoal (1 subgoal):\n 1. p2 \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  p2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "hence LESS: \"length (p1@p3) < length p\""], ["proof (prove)\nusing this:\n  p2 \\<noteq> []\n\ngoal (1 subgoal):\n 1. length (p1 @ p3) < length p", "by auto"], ["proof (state)\nthis:\n  length (p1 @ p3) < length p\n\ngoal (1 subgoal):\n 1. \\<not> isSimplePath s p t \\<Longrightarrow> False", "with SHORTER_PATH SHORTEST"], ["proof (chain)\npicking this:\n  isPath s (p1 @ p3) t\n  \\<forall>p'. isPath s p' t \\<longrightarrow> length p \\<le> length p'\n  length (p1 @ p3) < length p", "show False"], ["proof (prove)\nusing this:\n  isPath s (p1 @ p3) t\n  \\<forall>p'. isPath s p' t \\<longrightarrow> length p \\<le> length p'\n  length (p1 @ p3) < length p\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We provide yet another characterization of shortest paths:\\<close>"], ["", "lemma isShortestPath_alt: \n  \"isShortestPath u p v \\<longleftrightarrow> isSimplePath u p v \\<and> length p = min_dist u v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isShortestPath u p v =\n    (isSimplePath u p v \\<and> length p = min_dist u v)", "using shortestPath_is_simple isShortestPath_min_dist_def"], ["proof (prove)\nusing this:\n  isShortestPath ?s ?p ?t \\<Longrightarrow> isSimplePath ?s ?p ?t\n  isShortestPath ?u ?p ?v =\n  (isPath ?u ?p ?v \\<and> length ?p = min_dist ?u ?v)\n\ngoal (1 subgoal):\n 1. isShortestPath u p v =\n    (isSimplePath u p v \\<and> length p = min_dist u v)", "unfolding isSimplePath_def"], ["proof (prove)\nusing this:\n  isShortestPath ?s ?p ?t \\<Longrightarrow>\n  isPath ?s ?p ?t \\<and> distinct (pathVertices ?s ?p)\n  isShortestPath ?u ?p ?v =\n  (isPath ?u ?p ?v \\<and> length ?p = min_dist ?u ?v)\n\ngoal (1 subgoal):\n 1. isShortestPath u p v =\n    ((isPath u p v \\<and> distinct (pathVertices u p)) \\<and>\n     length p = min_dist u v)", "by auto"], ["", "lemma shortestPath_is_path: \"isShortestPath u p v \\<Longrightarrow> isPath u p v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isShortestPath u p v \\<Longrightarrow> isPath u p v", "by (auto simp: isShortestPath_def)"], ["", "lemma split_shortest_path: \"isShortestPath u (p1@p2) v \n  \\<Longrightarrow> (\\<exists>w. isShortestPath u p1 w \\<and> isShortestPath w p2 v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isShortestPath u (p1 @ p2) v \\<Longrightarrow>\n    \\<exists>w. isShortestPath u p1 w \\<and> isShortestPath w p2 v", "apply (auto simp: isShortestPath_min_dist_def isPath_append)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> \\<exists>w.\n                            isPath u p1 w \\<and>\n                            length p1 = min_dist u w \\<and>\n                            isPath w p2 v \\<and> length p2 = min_dist w v", "apply (rule exI; intro conjI; assumption?)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> length p1 = min_dist u w\n 2. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "apply (drule isPath_distD)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; dist u (length p1) w;\n        dist w (length p2) v\\<rbrakk>\n       \\<Longrightarrow> length p1 = min_dist u w\n 2. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "using min_dist_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist ?u ?d1.0 ?w; dist ?w ?d2.0 ?v;\n   min_dist ?u ?v = ?d1.0 + ?d2.0\\<rbrakk>\n  \\<Longrightarrow> min_dist ?u ?w = ?d1.0\n  \\<lbrakk>dist ?u ?d1.0 ?w; dist ?w ?d2.0 ?v;\n   min_dist ?u ?v = ?d1.0 + ?d2.0\\<rbrakk>\n  \\<Longrightarrow> min_dist ?w ?v = ?d2.0\n\ngoal (2 subgoals):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; dist u (length p1) w;\n        dist w (length p2) v\\<rbrakk>\n       \\<Longrightarrow> length p1 = min_dist u w\n 2. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "apply auto []"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; isPath u p1 w;\n        isPath w p2 v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "apply (drule isPath_distD)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; dist u (length p1) w;\n        dist w (length p2) v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "using min_dist_split"], ["proof (prove)\nusing this:\n  \\<lbrakk>dist ?u ?d1.0 ?w; dist ?w ?d2.0 ?v;\n   min_dist ?u ?v = ?d1.0 + ?d2.0\\<rbrakk>\n  \\<Longrightarrow> min_dist ?u ?w = ?d1.0\n  \\<lbrakk>dist ?u ?d1.0 ?w; dist ?w ?d2.0 ?v;\n   min_dist ?u ?v = ?d1.0 + ?d2.0\\<rbrakk>\n  \\<Longrightarrow> min_dist ?w ?v = ?d2.0\n\ngoal (1 subgoal):\n 1. \\<And>w.\n       \\<lbrakk>length p1 + length p2 = min_dist u v; dist u (length p1) w;\n        dist w (length p2) v\\<rbrakk>\n       \\<Longrightarrow> length p2 = min_dist w v", "apply auto []"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Edges in a shortest path connect nodes with increasing \n  minimum distance from the source\\<close>"], ["", "lemma isShortestPath_level_edge:  \n  assumes SP: \"isShortestPath s p t\" \n  assumes EIP: \"(u,v)\\<in>set p\"\n  shows \n    \"connected s u\" \"connected u v\" \"connected v t\" and\n    \"min_dist s v = min_dist s u + 1\" (is ?G1) and\n    \"min_dist u t = 1 + min_dist v t\" (is ?G2) and\n    \"min_dist s t = min_dist s u + 1 + min_dist v t\" (is ?G3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((connected s u &&& connected u v &&& connected v t) &&&\n     min_dist s v = min_dist s u + 1) &&&\n    min_dist u t = 1 + min_dist v t &&&\n    min_dist s t = min_dist s u + 1 + min_dist v t", "proof -  \n  \\<comment> \\<open>Split the original path at the edge\\<close>"], ["proof (state)\ngoal (6 subgoals):\n 1. connected s u\n 2. connected u v\n 3. connected v t\n 4. min_dist s v = min_dist s u + 1\n 5. min_dist u t = 1 + min_dist v t\n 6. min_dist s t = min_dist s u + 1 + min_dist v t", "from EIP"], ["proof (chain)\npicking this:\n  (u, v) \\<in> set p", "obtain p1 p2 where [simp]: \"p=p1@(u,v)#p2\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> set p\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        p = p1 @ (u, v) # p2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: in_set_conv_decomp)"], ["proof (state)\nthis:\n  p = p1 @ (u, v) # p2\n\ngoal (6 subgoals):\n 1. connected s u\n 2. connected u v\n 3. connected v t\n 4. min_dist s v = min_dist s u + 1\n 5. min_dist u t = 1 + min_dist v t\n 6. min_dist s t = min_dist s u + 1 + min_dist v t", "from \\<open>isShortestPath s p t\\<close>"], ["proof (chain)\npicking this:\n  isShortestPath s p t", "have \n    MIN: \"min_dist s t = length p\" and \n      P: \"isPath s p t\" and \n     DV: \"distinct (pathVertices s p)\""], ["proof (prove)\nusing this:\n  isShortestPath s p t\n\ngoal (1 subgoal):\n 1. min_dist s t = length p &&& isPath s p t &&& distinct (pathVertices s p)", "by (auto simp: isShortestPath_alt isSimplePath_def)"], ["proof (state)\nthis:\n  min_dist s t = length p\n  isPath s p t\n  distinct (pathVertices s p)\n\ngoal (6 subgoals):\n 1. connected s u\n 2. connected u v\n 3. connected v t\n 4. min_dist s v = min_dist s u + 1\n 5. min_dist u t = 1 + min_dist v t\n 6. min_dist s t = min_dist s u + 1 + min_dist v t", "from P"], ["proof (chain)\npicking this:\n  isPath s p t", "have DISTS: \"dist s (length p1) u\" \"dist u 1 v\" \"dist v (length p2) t\""], ["proof (prove)\nusing this:\n  isPath s p t\n\ngoal (1 subgoal):\n 1. dist s (length p1) u &&& dist u 1 v &&& dist v (length p2) t", "by (auto simp: isPath_append dist_def intro: exI[where x=\"[(u,v)]\"])"], ["proof (state)\nthis:\n  dist s (length p1) u\n  dist u 1 v\n  dist v (length p2) t\n\ngoal (6 subgoals):\n 1. connected s u\n 2. connected u v\n 3. connected v t\n 4. min_dist s v = min_dist s u + 1\n 5. min_dist u t = 1 + min_dist v t\n 6. min_dist s t = min_dist s u + 1 + min_dist v t", "from DISTS"], ["proof (chain)\npicking this:\n  dist s (length p1) u\n  dist u 1 v\n  dist v (length p2) t", "show \"connected s u\" \"connected u v\" \"connected v t\""], ["proof (prove)\nusing this:\n  dist s (length p1) u\n  dist u 1 v\n  dist v (length p2) t\n\ngoal (1 subgoal):\n 1. connected s u &&& connected u v &&& connected v t", "by auto\n\n  \\<comment> \\<open>Express the minimum distances in terms of the split original path\\<close>"], ["proof (state)\nthis:\n  connected s u\n  connected u v\n  connected v t\n\ngoal (3 subgoals):\n 1. min_dist s v = min_dist s u + 1\n 2. min_dist u t = 1 + min_dist v t\n 3. min_dist s t = min_dist s u + 1 + min_dist v t", "from MIN"], ["proof (chain)\npicking this:\n  min_dist s t = length p", "have MIN': \"min_dist s t = length p1 + 1 + length p2\""], ["proof (prove)\nusing this:\n  min_dist s t = length p\n\ngoal (1 subgoal):\n 1. min_dist s t = length p1 + 1 + length p2", "by auto"], ["proof (state)\nthis:\n  min_dist s t = length p1 + 1 + length p2\n\ngoal (3 subgoals):\n 1. min_dist s v = min_dist s u + 1\n 2. min_dist u t = 1 + min_dist v t\n 3. min_dist s t = min_dist s u + 1 + min_dist v t", "from min_dist_split[OF dist_trans[OF DISTS(1,2)] DISTS(3) MIN']"], ["proof (chain)\npicking this:\n  min_dist s v = length p1 + 1\n  min_dist v t = length p2", "have\n      MDSV: \"min_dist s v = length p1 + 1\" and \n    [simp]: \"length p2 = min_dist v t\""], ["proof (prove)\nusing this:\n  min_dist s v = length p1 + 1\n  min_dist v t = length p2\n\ngoal (1 subgoal):\n 1. min_dist s v = length p1 + 1 &&& length p2 = min_dist v t", "by simp_all"], ["proof (state)\nthis:\n  min_dist s v = length p1 + 1\n  length p2 = min_dist v t\n\ngoal (3 subgoals):\n 1. min_dist s v = min_dist s u + 1\n 2. min_dist u t = 1 + min_dist v t\n 3. min_dist s t = min_dist s u + 1 + min_dist v t", "from min_dist_split[OF DISTS(1) dist_trans[OF DISTS(2,3)]] MIN'"], ["proof (chain)\npicking this:\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist s u = length p1\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2", "have\n      MDUT: \"min_dist u t = 1 + length p2\" and \n    [simp]: \"length p1 = min_dist s u\""], ["proof (prove)\nusing this:\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist s u = length p1\n  min_dist s t = length p1 + (1 + length p2) \\<Longrightarrow>\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2\n\ngoal (1 subgoal):\n 1. min_dist u t = 1 + length p2 &&& length p1 = min_dist s u", "by simp_all"], ["proof (state)\nthis:\n  min_dist u t = 1 + length p2\n  length p1 = min_dist s u\n\ngoal (3 subgoals):\n 1. min_dist s v = min_dist s u + 1\n 2. min_dist u t = 1 + min_dist v t\n 3. min_dist s t = min_dist s u + 1 + min_dist v t", "from MDSV MDUT MIN'"], ["proof (chain)\npicking this:\n  min_dist s v = length p1 + 1\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2", "show ?G1 ?G2 ?G3"], ["proof (prove)\nusing this:\n  min_dist s v = length p1 + 1\n  min_dist u t = 1 + length p2\n  min_dist s t = length p1 + 1 + length p2\n\ngoal (1 subgoal):\n 1. min_dist s v = min_dist s u + 1 &&&\n    min_dist u t = 1 + min_dist v t &&&\n    min_dist s t = min_dist s u + 1 + min_dist v t", "by auto"], ["proof (state)\nthis:\n  min_dist s v = min_dist s u + 1\n  min_dist u t = 1 + min_dist v t\n  min_dist s t = min_dist s u + 1 + min_dist v t\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Graph\\<close>"], ["", "context Finite_Graph begin"], ["", "text \\<open>In a finite graph, the length of a shortest path is less \n  than the number of nodes\\<close>"], ["", "lemma isShortestPath_length_less_V:   \n  assumes SV: \"s\\<in>V\"\n  assumes PATH: \"isShortestPath s p t\"\n  shows \"length p < card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length p < card V", "using simplePath_length_less_V[OF SV]"], ["proof (prove)\nusing this:\n  isSimplePath s ?p ?v \\<Longrightarrow> length ?p < card V\n\ngoal (1 subgoal):\n 1. length p < card V", "using shortestPath_is_simple[OF PATH]"], ["proof (prove)\nusing this:\n  isSimplePath s ?p ?v \\<Longrightarrow> length ?p < card V\n  isSimplePath s p t\n\ngoal (1 subgoal):\n 1. length p < card V", "."], ["", "corollary min_dist_less_V:\n  assumes SV: \"s\\<in>V\"\n  assumes CONN: \"connected s t\"\n  shows \"min_dist s t < card V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_dist s t < card V", "apply (rule obtain_shortest_path[OF CONN])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p. isShortestPath s p t \\<Longrightarrow> min_dist s t < card V", "apply (frule isShortestPath_length_less_V[OF SV])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>isShortestPath s p t; length p < card V\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < card V", "unfolding isShortestPath_min_dist_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>isPath s p t \\<and> length p = min_dist s t;\n        length p < card V\\<rbrakk>\n       \\<Longrightarrow> min_dist s t < card V", "by auto"], ["", "end \\<comment> \\<open>Finite_Graph\\<close>"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}