{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Network_Impl.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma E_ss: \"E \\<subseteq> {0..<N}\\<times>{0..<N}\"", "lemma am_is_in_V_correct[THEN order_trans, refine_vcg]: \n    assumes \"(am,adjacent_nodes) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"\n    shows \"am_is_in_V am u \\<le> (spec x. x \\<longleftrightarrow> u\\<in>V)\"", "lemmas [map_type_eqs] = \n    map_type_eqI[of \"TYPE(capacity_impl flow)\" \"TYPE(capacity_impl i_mtx)\"]", "lemma nf_init_rule: \n  \"<emp> Array.new N dflt <is_nf N dflt (\\<lambda>_. dflt)>\"", "lemma nf_copy_rule[sep_heap_rules]: \n  \"<is_nf N dflt f a> array_copy a <\\<lambda>r. is_nf N dflt f a * is_nf N dflt f r>\"", "lemma nf_lookup_rule[sep_heap_rules]: \n  \"v<N \\<Longrightarrow> <is_nf N dflt f a> Array.nth a v <\\<lambda>r. is_nf N dflt f a *\\<up>(r = f v)>\"", "lemma nf_update_rule[sep_heap_rules]: \n  \"v<N \\<Longrightarrow> <is_nf N dflt f a> Array.upd v x a <is_nf N dflt (f(v:=x))>\"", "lemma mtx_nonzero_iff[simp]: \"mtx_nonzero c = E\"", "lemma mtx_nonzeroN: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<N}\"", "lemma in_mtx_nonzeroN[simp]: \"(u,v) \\<in> mtx_nonzero c \\<Longrightarrow> u<N \\<and> v<N\"", "lemma inV_less_N[simp]: \"v\\<in>V \\<Longrightarrow> v<N\"", "lemma inEIE_lessN[simp]: \"e\\<in>E \\<or> e\\<in>E\\<inverse> \\<Longrightarrow> case e of (u,v) \\<Rightarrow> u<N \\<and> v<N\"", "lemmas [simp] = nested_case_prod_simp", "lemmas [sepref_import_param] = \n  IdI[of N]\n  IdI[of s]\n  IdI[of t]", "lemma c_hnr[sepref_fr_rules]: \n  \"(uncurry0 (return c),uncurry0 (RETURN c))\n    \\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> Id)\"", "lemma [intf_of_assn]: \"intf_of_assn (cf_assn) TYPE(capacity_impl i_mtx)\"", "lemmas [sepref_fr_rules] = \n  cf_get_impl.refine[OF Network_Impl_axioms] \n  cf_set_impl.refine[OF Network_Impl_axioms] \n  cf_init_impl.refine[OF Network_Impl_axioms]", "lemma am_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST am_get)) \n  \\<in> am_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn\"", "lemma am_is_in_V_hnr[sepref_fr_rules]: \"(uncurry am_is_in_V_impl, uncurry (am_is_in_V)) \n  \\<in> [\\<lambda>(_,v). v<N]\\<^sub>a am_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow> bool_assn\"", "lemma rgraph_and_network_impl_imp_rgraph_impl:\n  assumes \"RGraph c s t cf\"\n  assumes \"Network_Impl c s t N\"\n  shows \"RGraph_Impl c s t N cf\"", "lemma (in RGraph) val_by_adj_map:  \n  assumes AM: \"is_adj_map am\"\n  shows \"f.val = (\\<Sum>v\\<in>set (am s). cf (v,s))\"", "lemma (in RGraph_Impl) compute_flow_val_aux_correct:\n  assumes \"is_adj_map am\"\n  shows \"compute_flow_val_aux am cf \\<le> (spec v. v = f.val)\"", "lemma (in RGraph_Impl) compute_flow_val_correct[THEN order_trans, refine_vcg]:\n  assumes \"is_adj_map am\"\n  shows \"compute_flow_val am cf \\<le> (spec v. v = f.val)\"", "lemmas compute_flow_val_impl_hnr[sepref_fr_rules] \n    = compute_flow_val_impl.refine[OF Network_Impl_axioms]", "lemma compute_flow_val_impl_correct[sep_heap_rules]:\n  assumes \"RGraph_Impl c s t N cf\"\n  assumes AM: \"Graph.is_adj_map c am\"  \n  shows \"<cf_assn N cf cfi * am_assn N am ami> \n          compute_flow_val_impl s N ami cfi \n        <\\<lambda>v. cf_assn N cf cfi * am_assn N am ami \n            * \\<up>( v = Flow.val c s (RPreGraph.f c cf) )>\\<^sub>t\"", "lemma am_to_adj_nodes_refine:\n  assumes AM: \"is_adj_map am\"  \n  shows \"(am u, adjacent_nodes u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\"", "lemma init_C_correct:\n  assumes AM: \"is_adj_map am\"  \n  shows \"init_C am \\<le> SPEC (\\<lambda>C. C = card V)\"", "lemmas [sepref_fr_rules] = fifo_init_C_impl.refine[OF Network_Impl_axioms]"], "translations": [["", "lemma E_ss: \"E \\<subseteq> {0..<N}\\<times>{0..<N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N}", "using E_ss_VxV V_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> V \\<times> V\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. E \\<subseteq> {0..<N} \\<times> {0..<N}", "by auto"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "subsection \\<open>Basic Operations\\<close>"], ["", "context Network_Impl\nbegin"], ["", "subsubsection \\<open>Residual Graph\\<close>"], ["", "text \\<open>Get the residual capacity of an edge.\\<close>"], ["", "definition cf_get :: \"flow_impl \\<Rightarrow> edge \\<Rightarrow> capacity_impl nres\" \n    where \"cf_get cf e \\<equiv> do {\n      assert (e\\<in>E \\<union> E\\<inverse>);\n      return (cf e)\n    }\""], ["", "text \\<open>Update the residual capacity of an edge.\\<close>"], ["", "definition cf_set :: \"flow_impl \\<Rightarrow> edge \\<Rightarrow> capacity_impl \\<Rightarrow> flow_impl nres\" \n    where \"cf_set cf e x \\<equiv> do {\n      assert (e\\<in>E \\<union> E\\<inverse>);\n      return (cf (e:=x))\n    }\""], ["", "text \\<open>Obtain the initial residual graph.\\<close>"], ["", "definition cf_init :: \"flow_impl nres\" \n    where \"cf_init \\<equiv> return (op_mtx_new c)\""], ["", "subsubsection \\<open>Adjacency Map\\<close>"], ["", "text \\<open>Obtain the list of adjacent nodes for a specified node.\\<close>"], ["", "definition am_get :: \"(node \\<Rightarrow> node list) \\<Rightarrow> node \\<Rightarrow> node list nres\"    \n    where \"am_get am u \\<equiv> do {\n      assert (u\\<in>V);\n      return (am u)\n    }\""], ["", "text \\<open>Test whether a node identifier is actually a node. \n    As not all numbers in the range @{term \\<open>{0..<N}\\<close>} must identify nodes, \n    this function uses the adjacency map to check whether there are adjacent\n    edges. Due to the network constraints, all nodes have adjacent edges.\n  \\<close>"], ["", "definition am_is_in_V :: \"(node \\<Rightarrow> node list) \\<Rightarrow> node \\<Rightarrow> bool nres\"\n    where \"am_is_in_V am u \\<equiv> do {\n      return (am u \\<noteq> [])\n    }\""], ["", "lemma am_is_in_V_correct[THEN order_trans, refine_vcg]: \n    assumes \"(am,adjacent_nodes) \\<in> nat_rel \\<rightarrow> \\<langle>nat_rel\\<rangle>list_set_rel\"\n    shows \"am_is_in_V am u \\<le> (spec x. x \\<longleftrightarrow> u\\<in>V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "have \"u\\<in>V \\<longleftrightarrow> adjacent_nodes u \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> V) = (adjacent_nodes u \\<noteq> {})", "unfolding V_def adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u \\<in> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E}) =\n    (E `` {u} \\<union> E\\<inverse> `` {u} \\<noteq> {})", "by auto"], ["proof (state)\nthis:\n  (u \\<in> V) = (adjacent_nodes u \\<noteq> {})\n\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "also"], ["proof (state)\nthis:\n  (u \\<in> V) = (adjacent_nodes u \\<noteq> {})\n\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "have \"\\<dots> \\<longleftrightarrow> am u \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (adjacent_nodes u \\<noteq> {}) = (am u \\<noteq> [])", "using fun_relD[OF assms IdI[of u]]"], ["proof (prove)\nusing this:\n  (am u, adjacent_nodes u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n\ngoal (1 subgoal):\n 1. (adjacent_nodes u \\<noteq> {}) = (am u \\<noteq> [])", "by (auto simp: list_set_rel_def in_br_conv)"], ["proof (state)\nthis:\n  (adjacent_nodes u \\<noteq> {}) = (am u \\<noteq> [])\n\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "finally"], ["proof (chain)\npicking this:\n  (u \\<in> V) = (am u \\<noteq> [])", "show ?thesis"], ["proof (prove)\nusing this:\n  (u \\<in> V) = (am u \\<noteq> [])\n\ngoal (1 subgoal):\n 1. am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))", "unfolding am_is_in_V_def"], ["proof (prove)\nusing this:\n  (u \\<in> V) = (am u \\<noteq> [])\n\ngoal (1 subgoal):\n 1. return (am u \\<noteq> []) \\<le> (spec x. x = (u \\<in> V))", "by refine_vcg auto"], ["proof (state)\nthis:\n  am_is_in_V am u \\<le> (spec x. x = (u \\<in> V))\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "subsubsection \\<open>Registration of Basic Operations to Sepref\\<close>"], ["", "text \\<open>Bundles the setup for registration of abstract operations.\\<close>"], ["", "bundle Network_Impl_Sepref_Register begin"], ["", "text \\<open>Automatically rewrite to \\<open>i_mtx\\<close> interface type\\<close>"], ["", "lemmas [map_type_eqs] = \n    map_type_eqI[of \"TYPE(capacity_impl flow)\" \"TYPE(capacity_impl i_mtx)\"]"], ["", "end \\<comment> \\<open>Bundle\\<close>"], ["", "context Network_Impl\nbegin"], ["", "subsubsection \\<open>Registration of Abstract Operations\\<close>"], ["", "context\n  includes Network_Impl_Sepref_Register\nbegin"], ["", "sepref_register N s t"], ["", "sepref_register c :: \"capacity_impl graph\""], ["", "sepref_register cf_get cf_set cf_init"], ["", "sepref_register am_get am_is_in_V"], ["", "end \\<comment> \\<open>Anonymous Context\\<close>"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "subsection \\<open>Refinement To Efficient Data Structures\\<close>"], ["", "subsubsection \\<open>Functions from Nodes by Arrays\\<close>"], ["", "(*\n  TODO: Move to own file in IICF\n \n  This has more general uses than implementing nodes!\n  It can implement functions from any objects represented by an initial\n  segment of the natural numbers, a very often recurring pattern.\n*)"], ["", "text \\<open>\n  We provide a template for implementing functions from nodes by arrays.\n  Outside the node range, the abstract functions have a default value.\n\n  This template is then used for refinement of various data structures.\n\\<close>"], ["", "definition \"is_nf N dflt f a \n  \\<equiv> \\<exists>\\<^sub>Al. a\\<mapsto>\\<^sub>al * \\<up>(length l = N \\<and> (\\<forall>i<N. l!i = f i) \\<and> (\\<forall>i\\<ge>N. f i = dflt))\""], ["", "lemma nf_init_rule: \n  \"<emp> Array.new N dflt <is_nf N dflt (\\<lambda>_. dflt)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new N dflt <is_nf N dflt (\\<lambda>_. dflt)>", "unfolding is_nf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <emp> Array.new N dflt\n    <\\<lambda>a.\n        \\<exists>\\<^sub>Al.\n           a \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N \\<and>\n             (\\<forall>i<N. l ! i = dflt) \\<and>\n             (\\<forall>i\\<ge>N. dflt = dflt))>", "by sep_auto"], ["", "lemma nf_copy_rule[sep_heap_rules]: \n  \"<is_nf N dflt f a> array_copy a <\\<lambda>r. is_nf N dflt f a * is_nf N dflt f r>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <is_nf N dflt f a> array_copy a\n    <\\<lambda>r. is_nf N dflt f a * is_nf N dflt f r>", "unfolding is_nf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. <\\<exists>\\<^sub>Al.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (length l = N \\<and>\n          (\\<forall>i<N. l ! i = f i) \\<and>\n          (\\<forall>i\\<ge>N. f i = dflt))>\n    array_copy a\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al.\n            a \\<mapsto>\\<^sub>a l *\n            \\<up>\n             (length l = N \\<and>\n              (\\<forall>i<N. l ! i = f i) \\<and>\n              (\\<forall>i\\<ge>N. f i = dflt))) *\n        (\\<exists>\\<^sub>Al.\n            r \\<mapsto>\\<^sub>a l *\n            \\<up>\n             (length l = N \\<and>\n              (\\<forall>i<N. l ! i = f i) \\<and>\n              (\\<forall>i\\<ge>N. f i = dflt)))>", "by sep_auto"], ["", "lemma nf_lookup_rule[sep_heap_rules]: \n  \"v<N \\<Longrightarrow> <is_nf N dflt f a> Array.nth a v <\\<lambda>r. is_nf N dflt f a *\\<up>(r = f v)>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < N \\<Longrightarrow>\n    <is_nf N dflt f a> Array.nth a v\n    <\\<lambda>r. is_nf N dflt f a * \\<up> (r = f v)>", "unfolding is_nf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v < N \\<Longrightarrow>\n    <\\<exists>\\<^sub>Al.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (length l = N \\<and>\n          (\\<forall>i<N. l ! i = f i) \\<and>\n          (\\<forall>i\\<ge>N. f i = dflt))>\n    Array.nth a v\n    <\\<lambda>r.\n        (\\<exists>\\<^sub>Al.\n            a \\<mapsto>\\<^sub>a l *\n            \\<up>\n             (length l = N \\<and>\n              (\\<forall>i<N. l ! i = f i) \\<and>\n              (\\<forall>i\\<ge>N. f i = dflt))) *\n        \\<up> (r = f v)>", "by sep_auto"], ["", "lemma nf_update_rule[sep_heap_rules]: \n  \"v<N \\<Longrightarrow> <is_nf N dflt f a> Array.upd v x a <is_nf N dflt (f(v:=x))>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v < N \\<Longrightarrow>\n    <is_nf N dflt f a> Array.upd v x a <is_nf N dflt (f(v := x))>", "unfolding is_nf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v < N \\<Longrightarrow>\n    <\\<exists>\\<^sub>Al.\n        a \\<mapsto>\\<^sub>a l *\n        \\<up>\n         (length l = N \\<and>\n          (\\<forall>i<N. l ! i = f i) \\<and>\n          (\\<forall>i\\<ge>N. f i = dflt))>\n    Array.upd v x a\n    <\\<lambda>a.\n        \\<exists>\\<^sub>Al.\n           a \\<mapsto>\\<^sub>a l *\n           \\<up>\n            (length l = N \\<and>\n             (\\<forall>i<N. l ! i = (f(v := x)) i) \\<and>\n             (\\<forall>i\\<ge>N. (f(v := x)) i = dflt))>", "by sep_auto"], ["", "subsubsection \\<open>Automation Setup for Side-Condition Discharging\\<close>"], ["", "context Network_Impl\nbegin"], ["", "lemma mtx_nonzero_iff[simp]: \"mtx_nonzero c = E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c = E", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c = {(u, v). c (u, v) \\<noteq> 0}", "by (auto simp: mtx_nonzero_def)"], ["", "lemma mtx_nonzeroN: \"mtx_nonzero c \\<subseteq> {0..<N}\\<times>{0..<N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<N}", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> {0..<N} \\<times> {0..<N}\n\ngoal (1 subgoal):\n 1. mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<N}", "by simp"], ["", "lemma in_mtx_nonzeroN[simp]: \"(u,v) \\<in> mtx_nonzero c \\<Longrightarrow> u<N \\<and> v<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> mtx_nonzero c \\<Longrightarrow> u < N \\<and> v < N", "using mtx_nonzeroN"], ["proof (prove)\nusing this:\n  mtx_nonzero c \\<subseteq> {0..<N} \\<times> {0..<N}\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> mtx_nonzero c \\<Longrightarrow> u < N \\<and> v < N", "by auto"], ["", "lemma inV_less_N[simp]: \"v\\<in>V \\<Longrightarrow> v<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> v < N", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (1 subgoal):\n 1. v \\<in> V \\<Longrightarrow> v < N", "by auto"], ["", "lemma inEIE_lessN[simp]: \"e\\<in>E \\<or> e\\<in>E\\<inverse> \\<Longrightarrow> case e of (u,v) \\<Rightarrow> u<N \\<and> v<N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> E \\<or> e \\<in> E\\<inverse> \\<Longrightarrow>\n    case e of (u, v) \\<Rightarrow> u < N \\<and> v < N", "using E_ss"], ["proof (prove)\nusing this:\n  E \\<subseteq> {0..<N} \\<times> {0..<N}\n\ngoal (1 subgoal):\n 1. e \\<in> E \\<or> e \\<in> E\\<inverse> \\<Longrightarrow>\n    case e of (u, v) \\<Rightarrow> u < N \\<and> v < N", "by auto"], ["", "lemmas [simp] = nested_case_prod_simp"], ["", "subsubsection \\<open>Network Parameters by Identity\\<close>"], ["", "abbreviation (in -) cap_assn :: \"capacity_impl \\<Rightarrow> _\" where \"cap_assn \\<equiv> id_assn\""], ["", "abbreviation (in -) \"edge_assn \\<equiv> nat_assn \\<times>\\<^sub>a nat_assn\""], ["", "abbreviation (in -) (input) \"node_assn \\<equiv> nat_assn\""], ["", "text \\<open>Refine number of nodes, and source and sink node by themselves\\<close>"], ["", "lemmas [sepref_import_param] = \n  IdI[of N]\n  IdI[of s]\n  IdI[of t]"], ["", "lemma c_hnr[sepref_fr_rules]: \n  \"(uncurry0 (return c),uncurry0 (RETURN c))\n    \\<in>unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 (return c), uncurry0 (return c))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n             (nat_rel \\<times>\\<^sub>r nat_rel \\<rightarrow> int_rel)", "by (sepref_to_hoare) sep_auto"], ["", "subsubsection \\<open>Residual Graph by Adjacency Matrix\\<close>"], ["", "definition (in -) \"cf_assn N \\<equiv> asmtx_assn N cap_assn\""], ["", "abbreviation cf_assn where \"cf_assn \\<equiv> Network_Impl.cf_assn N\""], ["", "lemma [intf_of_assn]: \"intf_of_assn (cf_assn) TYPE(capacity_impl i_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. intf_of_assn local.cf_assn TYPE(int i_mtx)", "by simp"], ["", "sepref_thm cf_get_impl is \"uncurry (PR_CONST cf_get)\" \n  :: \"cf_assn\\<^sup>k *\\<^sub>a edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST cf_get))\n    \\<in> local.cf_assn\\<^sup>k *\\<^sub>a\n          edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn", "unfolding cf_get_def cf_assn_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>cf e.\n          assert (e \\<in> E \\<union> E\\<inverse>) \\<bind>\n          (\\<lambda>_. return (cf e))))\n    \\<in> (asmtx_assn N cap_assn)\\<^sup>k *\\<^sub>a\n          edge_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn", "by sepref"], ["", "concrete_definition (in -) cf_get_impl \n  uses Network_Impl.cf_get_impl.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "sepref_thm cf_set_impl is \"uncurry2 (PR_CONST cf_set)\" \n  :: \"cf_assn\\<^sup>d *\\<^sub>a edge_assn\\<^sup>k *\\<^sub>a cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a cf_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3, uncurry2 (PR_CONST cf_set))\n    \\<in> local.cf_assn\\<^sup>d *\\<^sub>a edge_assn\\<^sup>k *\\<^sub>a\n          cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "unfolding cf_set_def cf_assn_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry2 ?f3,\n     uncurry2\n      (\\<lambda>cf e x.\n          assert (e \\<in> E \\<union> E\\<inverse>) \\<bind>\n          (\\<lambda>_. return (cf(e := x)))))\n    \\<in> (asmtx_assn N cap_assn)\\<^sup>d *\\<^sub>a\n          edge_assn\\<^sup>k *\\<^sub>a\n          cap_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N cap_assn", "by sepref"], ["", "concrete_definition (in -) cf_set_impl \n  uses Network_Impl.cf_set_impl.refine_raw is \"(uncurry2 ?f,_)\\<in>_\""], ["", "sepref_thm cf_init_impl is \"uncurry0 (PR_CONST cf_init)\" \n  :: \"unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a cf_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (PR_CONST cf_init))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a local.cf_assn", "unfolding PR_CONST_def cf_assn_def cf_init_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (return (op_mtx_new c)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N cap_assn", "apply (rewrite amtx_fold_custom_new[of N N])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry0 ?f2, uncurry0 (return (op_amtx_new N N c)))\n    \\<in> unit_assn\\<^sup>k \\<rightarrow>\\<^sub>a asmtx_assn N cap_assn", "by sepref"], ["", "concrete_definition (in -) cf_init_impl \n  uses Network_Impl.cf_init_impl.refine_raw is \"(uncurry0 ?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = \n  cf_get_impl.refine[OF Network_Impl_axioms] \n  cf_set_impl.refine[OF Network_Impl_axioms] \n  cf_init_impl.refine[OF Network_Impl_axioms]"], ["", "subsubsection \\<open>Adjacency Map by Array\\<close>"], ["", "definition (in -) \"am_assn N \\<equiv> is_nf N ([]::nat list)\""], ["", "abbreviation am_assn where \"am_assn \\<equiv> Network_Impl.am_assn N\""], ["", "lemma am_get_hnr[sepref_fr_rules]: \n  \"(uncurry Array.nth, uncurry (PR_CONST am_get)) \n  \\<in> am_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn id_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth, uncurry (PR_CONST am_get))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a list_assn nat_assn", "unfolding am_assn_def am_get_def list_assn_pure_conv"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry Array.nth,\n     uncurry\n      (PR_CONST\n        (\\<lambda>am u.\n            assert (u \\<in> V) \\<bind> (\\<lambda>_. return (am u)))))\n    \\<in> (is_nf N [])\\<^sup>k *\\<^sub>a\n          nat_assn\\<^sup>k \\<rightarrow>\\<^sub>a pure\n            (\\<langle>nat_rel\\<rangle>list_rel)", "by sepref_to_hoare (sep_auto simp: refine_pw_simps)"], ["", "definition (in -) \"am_is_in_V_impl am u \\<equiv> do {\n  amu \\<leftarrow> Array.nth am u;\n  return (\\<not>is_Nil amu)\n}\""], ["", "lemma am_is_in_V_hnr[sepref_fr_rules]: \"(uncurry am_is_in_V_impl, uncurry (am_is_in_V)) \n  \\<in> [\\<lambda>(_,v). v<N]\\<^sub>a am_assn\\<^sup>k *\\<^sub>a node_assn\\<^sup>k \\<rightarrow> bool_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry am_is_in_V_impl, uncurry am_is_in_V)\n    \\<in> [\\<lambda>(uu_, v).\n              v < N]\\<^sub>a local.am_assn\\<^sup>k *\\<^sub>a\n                             nat_assn\\<^sup>k \\<rightarrow> bool_assn", "unfolding am_assn_def am_is_in_V_def am_is_in_V_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry\n      (\\<lambda>am u.\n          Array.nth am u \\<bind>\n          (\\<lambda>amu. return (\\<not> is_Nil amu))),\n     uncurry (\\<lambda>am u. return (am u \\<noteq> [])))\n    \\<in> [\\<lambda>(uu_, v).\n              v < N]\\<^sub>a (is_nf N [])\\<^sup>k *\\<^sub>a\n                             nat_assn\\<^sup>k \\<rightarrow> bool_assn", "apply sepref_to_hoare"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b bi a ai.\n       \\<lbrakk>b < N; a ::\\<^sub>i TYPE(nat \\<Rightarrow> nat list);\n        b ::\\<^sub>i TYPE(nat); nofail (return (a b \\<noteq> []))\\<rbrakk>\n       \\<Longrightarrow> <\\<up> ((bi, b) \\<in> nat_rel) *\n                          is_nf N [] a\n                           ai> Array.nth ai bi \\<bind>\n                               (\\<lambda>amu.\n                                   return\n                                    (\\<not> is_Nil\n       amu)) <\\<lambda>r.\n                 \\<up> ((bi, b) \\<in> nat_rel) * is_nf N [] a ai *\n                 (\\<exists>\\<^sub>Ax.\n                     \\<up> ((r, x) \\<in> bool_rel) *\n                     \\<up>\n                      (return x \\<le> return (a b \\<noteq> [])))>\\<^sub>t", "apply (sep_auto simp: refine_pw_simps split: list.split)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "subsection \\<open>Computing the Flow Value\\<close>"], ["", "text \\<open>We define an algorithm to compute the value of a flow from \n  the residual graph\n\\<close>"], ["", "locale RGraph_Impl = RGraph c s t cf + Network_Impl c s t N\n  for c :: \"capacity_impl flow\" and s t N cf"], ["", "lemma rgraph_and_network_impl_imp_rgraph_impl:\n  assumes \"RGraph c s t cf\"\n  assumes \"Network_Impl c s t N\"\n  shows \"RGraph_Impl c s t N cf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RGraph_Impl c s t N cf", "using assms"], ["proof (prove)\nusing this:\n  RGraph c s t cf\n  Network_Impl c s t N\n\ngoal (1 subgoal):\n 1. RGraph_Impl c s t N cf", "by (rule Network_Impl.RGraph_Impl.intro)"], ["", "lemma (in RGraph) val_by_adj_map:  \n  assumes AM: \"is_adj_map am\"\n  shows \"f.val = (\\<Sum>v\\<in>set (am s). cf (v,s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "have [simp]: \"set (am s) = E``{s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (am s) = E `` {s}", "using AM"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. set (am s) = E `` {s}", "unfolding is_adj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n\ngoal (1 subgoal):\n 1. set (am s) = E `` {s}", "by auto"], ["proof (state)\nthis:\n  set (am s) = E `` {s}\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "note f.val_by_cf"], ["proof (state)\nthis:\n  f.val = (\\<Sum>(u, v)\\<in>outgoing s. f.cf (v, u))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "also"], ["proof (state)\nthis:\n  f.val = (\\<Sum>(u, v)\\<in>outgoing s. f.cf (v, u))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "note rg_is_cf"], ["proof (state)\nthis:\n  f.cf = cf\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "also"], ["proof (state)\nthis:\n  f.cf = cf\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "have \"(\\<Sum>(u, v)\\<in>outgoing s. cf (v, u)) \n          = ((\\<Sum>v\\<in>set (am s). cf (v,s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(u, v)\\<in>outgoing s. cf (v, u)) =\n    (\\<Sum>v\\<in>set (am s). cf (v, s))", "by (simp add: sum_outgoing_pointwise)"], ["proof (state)\nthis:\n  (\\<Sum>(u, v)\\<in>outgoing s. cf (v, u)) =\n  (\\<Sum>v\\<in>set (am s). cf (v, s))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "finally"], ["proof (chain)\npicking this:\n  f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "show ?thesis"], ["proof (prove)\nusing this:\n  f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))\n\ngoal (1 subgoal):\n 1. f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))", "."], ["proof (state)\nthis:\n  f.val = (\\<Sum>v\\<in>set (am s). cf (v, s))\n\ngoal:\nNo subgoals!", "qed"], ["", "context Network_Impl \nbegin"], ["", "definition \"compute_flow_val_aux am cf \\<equiv> do {\n    succs \\<leftarrow> am_get am s;\n    sum_impl (\\<lambda>v. cf_get cf (v,s)) (set succs)\n  }\""], ["", "lemma (in RGraph_Impl) compute_flow_val_aux_correct:\n  assumes \"is_adj_map am\"\n  shows \"compute_flow_val_aux am cf \\<le> (spec v. v = f.val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val_aux am cf \\<le> (spec v. v = f.val)", "unfolding val_by_adj_map[OF assms]"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val_aux am cf\n    \\<le> (spec v. v = (\\<Sum>v\\<in>set (am s). cf (v, s)))", "unfolding compute_flow_val_aux_def cf_get_def am_get_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. assert (s \\<in> V) \\<bind> (\\<lambda>_. return (am s)) \\<bind>\n    (\\<lambda>succs.\n        sum_impl\n         (\\<lambda>v.\n             assert ((v, s) \\<in> E \\<union> E\\<inverse>) \\<bind>\n             (\\<lambda>_. return (cf (v, s))))\n         (set succs))\n    \\<le> (spec v. v = (\\<Sum>v\\<in>set (am s). cf (v, s)))", "apply (refine_vcg sum_impl_correct)"], ["proof (prove)\ngoal (4 subgoals):\n 1. s \\<in> V\n 2. s \\<in> V \\<Longrightarrow> finite (set (am s))\n 3. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> set (am s)\\<rbrakk>\n       \\<Longrightarrow> (x, s) \\<in> E \\<union> E\\<inverse>\n 4. \\<And>x.\n       \\<lbrakk>s \\<in> V; x \\<in> set (am s);\n        (x, s) \\<in> E \\<union> E\\<inverse>\\<rbrakk>\n       \\<Longrightarrow> cf (x, s) = cf (x, s)", "apply (vc_solve simp: s_node)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> set (am s) \\<Longrightarrow> (s, x) \\<in> E", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. x_ \\<in> set (am s) \\<Longrightarrow> (s, x_) \\<in> E", "using assms"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. x_ \\<in> set (am s) \\<Longrightarrow> (s, x_) \\<in> E", "unfolding is_adj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n\ngoal (1 subgoal):\n 1. x_ \\<in> set (am s) \\<Longrightarrow> (s, x_) \\<in> E", "by auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>For technical reasons (poor foreach-support of Sepref tool), \n  we have to add another refinement step: \\<close>"], ["", "definition \"compute_flow_val am cf \\<equiv> (do {\n  succs \\<leftarrow> am_get am s;\n  nfoldli succs (\\<lambda>_. True) (\\<lambda>x a. do {\n     b \\<leftarrow> cf_get cf (x, s); \n     return (a + b)\n   }) 0\n})\""], ["", "lemma (in RGraph_Impl) compute_flow_val_correct[THEN order_trans, refine_vcg]:\n  assumes \"is_adj_map am\"\n  shows \"compute_flow_val am cf \\<le> (spec v. v = f.val)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> (spec v. v = f.val)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> (spec v. v = f.val)", "have [refine_dref_RELATES]: \"RELATES (\\<langle>Id\\<rangle>list_set_rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. RELATES (\\<langle>Id\\<rangle>list_set_rel)", "by (simp add: RELATES_def)"], ["proof (state)\nthis:\n  RELATES (\\<langle>Id\\<rangle>list_set_rel)\n\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> (spec v. v = f.val)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> (spec v. v = f.val)", "apply (rule order_trans[OF _ compute_flow_val_aux_correct[OF assms]])"], ["proof (prove)\ngoal (1 subgoal):\n 1. compute_flow_val am cf \\<le> compute_flow_val_aux am cf", "unfolding compute_flow_val_def compute_flow_val_aux_def sum_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. am_get am s \\<bind>\n    (\\<lambda>succs.\n        nfoldli succs (\\<lambda>_. True)\n         (\\<lambda>x a.\n             cf_get cf (x, s) \\<bind> (\\<lambda>b. return (a + b)))\n         0)\n    \\<le> am_get am s \\<bind>\n          (\\<lambda>succs.\n              foreach (set succs)\n               (\\<lambda>x a.\n                   cf_get cf (x, s) \\<bind> (\\<lambda>b. return (a + b)))\n               0)", "apply (rule refine_IdD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. am_get am s \\<bind>\n    (\\<lambda>succs.\n        nfoldli succs (\\<lambda>_. True)\n         (\\<lambda>x a.\n             cf_get cf (x, s) \\<bind> (\\<lambda>b. return (a + b)))\n         0)\n    \\<le> \\<Down> int_rel\n           (am_get am s \\<bind>\n            (\\<lambda>succs.\n                foreach (set succs)\n                 (\\<lambda>x a.\n                     cf_get cf (x, s) \\<bind> (\\<lambda>b. return (a + b)))\n                 0))", "apply (refine_rcg LFO_refine bind_refine')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>succs succsa.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (succs, set succsa)\n                         \\<in> \\<langle>?A8 succs\n   succsa\\<rangle>list_set_rel\n 2. \\<And>succs succsa x xi sa si.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s); (xi, x) \\<in> ?A8 succs succsa;\n        (si, sa) \\<in> int_rel\\<rbrakk>\n       \\<Longrightarrow> cf_get cf (xi, s)\n                         \\<le> \\<Down> (?R'9 succs succsa x xi sa si)\n                                (cf_get cf (x, s))\n 3. \\<And>succs succsa x xi sa si b ba.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s); (xi, x) \\<in> ?A8 succs succsa;\n        (si, sa) \\<in> int_rel; (b, ba) \\<in> ?R'9 succs succsa x xi sa si;\n        inres (cf_get cf (xi, s)) b; inres (cf_get cf (x, s)) ba;\n        nofail (cf_get cf (xi, s)); nofail (cf_get cf (x, s))\\<rbrakk>\n       \\<Longrightarrow> (si + b, sa + ba) \\<in> int_rel\n 4. \\<And>succs succsa.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (0, 0) \\<in> int_rel", "apply refine_dref_type"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>succs succsa.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (succs, set succsa)\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 2. \\<And>succs succsa x xi sa si.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s); (xi, x) \\<in> nat_rel;\n        (si, sa) \\<in> int_rel\\<rbrakk>\n       \\<Longrightarrow> cf_get cf (xi, s)\n                         \\<le> \\<Down> int_rel (cf_get cf (x, s))\n 3. \\<And>succs succsa x xi sa si b ba.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s); (xi, x) \\<in> nat_rel; (si, sa) \\<in> int_rel;\n        (b, ba) \\<in> int_rel; inres (cf_get cf (xi, s)) b;\n        inres (cf_get cf (x, s)) ba; nofail (cf_get cf (xi, s));\n        nofail (cf_get cf (x, s))\\<rbrakk>\n       \\<Longrightarrow> (si + b, sa + ba) \\<in> int_rel\n 4. \\<And>succs succsa.\n       \\<lbrakk>(succs, succsa) \\<in> Id; inres (am_get am s) succs;\n        inres (am_get am s) succsa; nofail (am_get am s);\n        nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (0, 0) \\<in> int_rel", "apply vc_solve"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>succs.\n       \\<lbrakk>inres (am_get am s) succs; nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (succs, set succs)\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "using assms"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. \\<And>succs.\n       \\<lbrakk>inres (am_get am s) succs; nofail (am_get am s)\\<rbrakk>\n       \\<Longrightarrow> (succs, set succs)\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "by (auto \n        simp: list_set_rel_def br_def am_get_def is_adj_map_def \n        simp: refine_pw_simps)"], ["proof (state)\nthis:\n  compute_flow_val am cf \\<le> (spec v. v = f.val)\n\ngoal:\nNo subgoals!", "qed"], ["", "context \n  includes Network_Impl_Sepref_Register\nbegin"], ["", "sepref_register compute_flow_val"], ["", "end"], ["", "sepref_thm compute_flow_val_impl\n  is \"uncurry (PR_CONST compute_flow_val)\" \n    :: \"am_assn\\<^sup>k *\\<^sub>a cf_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2, uncurry (PR_CONST compute_flow_val))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a\n          local.cf_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn", "unfolding compute_flow_val_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (uncurry ?f2,\n     uncurry\n      (\\<lambda>am cf.\n          am_get am s \\<bind>\n          (\\<lambda>succs.\n              nfoldli succs (\\<lambda>_. True)\n               (\\<lambda>x a.\n                   cf_get cf (x, s) \\<bind> (\\<lambda>b. return (a + b)))\n               0)))\n    \\<in> local.am_assn\\<^sup>k *\\<^sub>a\n          local.cf_assn\\<^sup>k \\<rightarrow>\\<^sub>a cap_assn", "by sepref"], ["", "concrete_definition (in -) compute_flow_val_impl \n  uses Network_Impl.compute_flow_val_impl.refine_raw is \"(uncurry ?f,_)\\<in>_\""], ["", "lemmas compute_flow_val_impl_hnr[sepref_fr_rules] \n    = compute_flow_val_impl.refine[OF Network_Impl_axioms]"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "text \\<open>We also export a correctness theorem on the separation logic level\\<close>"], ["", "lemma compute_flow_val_impl_correct[sep_heap_rules]:\n  assumes \"RGraph_Impl c s t N cf\"\n  assumes AM: \"Graph.is_adj_map c am\"  \n  shows \"<cf_assn N cf cfi * am_assn N am ami> \n          compute_flow_val_impl s N ami cfi \n        <\\<lambda>v. cf_assn N cf cfi * am_assn N am ami \n            * \\<up>( v = Flow.val c s (RPreGraph.f c cf) )>\\<^sub>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. <cf_assn N cf cfi *\n     am_assn N am\n      ami> compute_flow_val_impl s N ami\n            cfi <\\<lambda>r.\n                    cf_assn N cf cfi * am_assn N am ami *\n                    \\<up> (r = Flow.val c s (RPreGraph.f c cf))>\\<^sub>t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. <cf_assn N cf cfi *\n     am_assn N am\n      ami> compute_flow_val_impl s N ami\n            cfi <\\<lambda>r.\n                    cf_assn N cf cfi * am_assn N am ami *\n                    \\<up> (r = Flow.val c s (RPreGraph.f c cf))>\\<^sub>t", "interpret RGraph_Impl c s t N cf"], ["proof (prove)\ngoal (1 subgoal):\n 1. RGraph_Impl c s t N cf", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. <local.cf_assn cf cfi *\n     local.am_assn am\n      ami> compute_flow_val_impl s N ami\n            cfi <\\<lambda>r.\n                    local.cf_assn cf cfi * local.am_assn am ami *\n                    \\<up> (r = f.val)>\\<^sub>t", "from hn_refine_ref[OF \n      compute_flow_val_correct[OF AM order_refl] \n      compute_flow_val_impl_hnr[to_hnr, unfolded autoref_tag_defs]]"], ["proof (chain)\npicking this:\n  hn_refine (hn_ctxt local.cf_assn cf ?bi1 * hn_ctxt local.am_assn am ?ai1)\n   (compute_flow_val_impl s N ?ai1 ?bi1)\n   (hn_ctxt local.cf_assn cf ?bi1 * hn_ctxt local.am_assn am ?ai1) cap_assn\n   (spec v. v = f.val)", "show ?thesis"], ["proof (prove)\nusing this:\n  hn_refine (hn_ctxt local.cf_assn cf ?bi1 * hn_ctxt local.am_assn am ?ai1)\n   (compute_flow_val_impl s N ?ai1 ?bi1)\n   (hn_ctxt local.cf_assn cf ?bi1 * hn_ctxt local.am_assn am ?ai1) cap_assn\n   (spec v. v = f.val)\n\ngoal (1 subgoal):\n 1. <local.cf_assn cf cfi *\n     local.am_assn am\n      ami> compute_flow_val_impl s N ami\n            cfi <\\<lambda>r.\n                    local.cf_assn cf cfi * local.am_assn am ami *\n                    \\<up> (r = f.val)>\\<^sub>t", "apply (simp add: hn_ctxt_def pure_def hn_refine_def f_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>bi ai.\n        <local.cf_assn cf bi * local.am_assn am ai>\n        compute_flow_val_impl s N ai bi\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               local.cf_assn cf bi * local.am_assn am ai * true *\n               \\<up>\n                (r = x \\<and>\n                 x = Flow.val c s (flow_of_cf cf))>) \\<Longrightarrow>\n    <local.cf_assn cf cfi * local.am_assn am ami>\n    compute_flow_val_impl s N ami cfi\n    <\\<lambda>r.\n        local.cf_assn cf cfi * local.am_assn am ami * true *\n        \\<up> (r = Flow.val c s (flow_of_cf cf))>", "apply (rule cons_post_rule)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<And>bi ai.\n        <local.cf_assn cf bi * local.am_assn am ai>\n        compute_flow_val_impl s N ai bi\n        <\\<lambda>r.\n            \\<exists>\\<^sub>Ax.\n               local.cf_assn cf bi * local.am_assn am ai * true *\n               \\<up>\n                (r = x \\<and>\n                 x = Flow.val c s (flow_of_cf cf))>) \\<Longrightarrow>\n    <local.cf_assn cf cfi * local.am_assn am ami>\n    compute_flow_val_impl s N ami cfi <?Q5>\n 2. \\<And>x.\n       (\\<And>bi ai.\n           <local.cf_assn cf bi * local.am_assn am ai>\n           compute_flow_val_impl s N ai bi\n           <\\<lambda>r.\n               \\<exists>\\<^sub>Ax.\n                  local.cf_assn cf bi * local.am_assn am ai * true *\n                  \\<up>\n                   (r = x \\<and>\n                    x = Flow.val c s (flow_of_cf cf))>) \\<Longrightarrow>\n       ?Q5 x \\<Longrightarrow>\\<^sub>A\n       local.cf_assn cf cfi * local.am_assn am ami * true *\n       \\<up> (x = Flow.val c s (flow_of_cf cf))", "apply assumption"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<And>bi ai.\n           <local.cf_assn cf bi * local.am_assn am ai>\n           compute_flow_val_impl s N ai bi\n           <\\<lambda>r.\n               \\<exists>\\<^sub>Ax.\n                  local.cf_assn cf bi * local.am_assn am ai * true *\n                  \\<up>\n                   (r = x \\<and>\n                    x = Flow.val c s (flow_of_cf cf))>) \\<Longrightarrow>\n       \\<exists>\\<^sub>Axa.\n          local.cf_assn cf cfi * local.am_assn am ami * true *\n          \\<up>\n           (x = xa \\<and>\n            xa = Flow.val c s (flow_of_cf cf)) \\<Longrightarrow>\\<^sub>A\n       local.cf_assn cf cfi * local.am_assn am ami * true *\n       \\<up> (x = Flow.val c s (flow_of_cf cf))", "apply sep_auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  <local.cf_assn cf cfi *\n   local.am_assn am\n    ami> compute_flow_val_impl s N ami\n          cfi <\\<lambda>r.\n                  local.cf_assn cf cfi * local.am_assn am ami *\n                  \\<up> (r = f.val)>\\<^sub>t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Computing the Exact Number of Nodes\\<close>"], ["", "context Network_Impl\nbegin"], ["", "lemma am_to_adj_nodes_refine:\n  assumes AM: \"is_adj_map am\"  \n  shows \"(am u, adjacent_nodes u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (am u, adjacent_nodes u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "using AM"], ["proof (prove)\nusing this:\n  is_adj_map am\n\ngoal (1 subgoal):\n 1. (am u, adjacent_nodes u) \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "unfolding adjacent_nodes_def is_adj_map_def"], ["proof (prove)\nusing this:\n  \\<forall>u.\n     distinct (am u) \\<and>\n     set (am u) = E `` {u} \\<union> E\\<inverse> `` {u}\n\ngoal (1 subgoal):\n 1. (am u, E `` {u} \\<union> E\\<inverse> `` {u})\n    \\<in> \\<langle>nat_rel\\<rangle>list_set_rel", "by (auto simp: list_set_rel_def in_br_conv)"], ["", "definition \"init_C am \\<equiv> do {\n  let cardV=0;\n  nfoldli [0..<N] (\\<lambda>_. True) (\\<lambda>v cardV. do {\n    assert (v<N);\n    inV \\<leftarrow> am_is_in_V am v;\n    if inV then do {\n      return (cardV + 1)\n    } else\n      return cardV\n  }) cardV\n}\""], ["", "lemma init_C_correct:\n  assumes AM: \"is_adj_map am\"  \n  shows \"init_C am \\<le> SPEC (\\<lambda>C. C = card V)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init_C am \\<le> (spec C. C = card V)", "unfolding init_C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Let 0\n     (nfoldli [0..<N] (\\<lambda>_. True)\n       (\\<lambda>v cardV.\n           assert (v < N) \\<bind>\n           (\\<lambda>_.\n               am_is_in_V am v \\<bind>\n               (\\<lambda>inV.\n                   if inV then return (cardV + 1) else return cardV))))\n    \\<le> (spec C. C = card V)", "apply (refine_vcg \n      nfoldli_rule[where I=\"\\<lambda>l1 _ C. C = card (V\\<inter>set l1)\"]\n      )"], ["proof (prove)\ngoal (7 subgoals):\n 1. 0 = card (V \\<inter> set [])\n 2. \\<And>x l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; \\<sigma> = card (V \\<inter> set l1);\n        True\\<rbrakk>\n       \\<Longrightarrow> x < N\n 3. \\<And>x l1 l2 \\<sigma> a a'.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; \\<sigma> = card (V \\<inter> set l1);\n        True; x < N; (a, a') \\<in> nat_rel\\<rbrakk>\n       \\<Longrightarrow> (am a, adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 4. \\<And>x l1 l2 \\<sigma> xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; \\<sigma> = card (V \\<inter> set l1);\n        True; x < N; xa = (x \\<in> V); xa\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> + 1 = card (V \\<inter> set (l1 @ [x]))\n 5. \\<And>x l1 l2 \\<sigma> xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; \\<sigma> = card (V \\<inter> set l1);\n        True; x < N; xa = (x \\<in> V); \\<not> xa\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = card (V \\<inter> set (l1 @ [x]))\n 6. \\<And>l1 l2 \\<sigma>.\n       \\<lbrakk>[0..<N] = l1 @ l2; \\<sigma> = card (V \\<inter> set l1);\n        \\<not> True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = card V\n 7. \\<And>\\<sigma>.\n       \\<lbrakk>\\<sigma> = card (V \\<inter> set [0..<N]); True\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> = card V", "apply clarsimp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x l1 l2. [0..<N] = l1 @ x # l2 \\<Longrightarrow> x < N\n 2. \\<And>x l1 l2 a'.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x < N\\<rbrakk>\n       \\<Longrightarrow> (am a', adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 3. \\<And>x l1 l2 xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 4. card (V \\<inter> {0..<N}) = card V", "using V_ss"], ["proof (prove)\nusing this:\n  V \\<subseteq> {0..<N}\n\ngoal (4 subgoals):\n 1. \\<And>x l1 l2. [0..<N] = l1 @ x # l2 \\<Longrightarrow> x < N\n 2. \\<And>x l1 l2 a'.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x < N\\<rbrakk>\n       \\<Longrightarrow> (am a', adjacent_nodes a')\n                         \\<in> \\<langle>nat_rel\\<rangle>list_set_rel\n 3. \\<And>x l1 l2 xa.\n       \\<lbrakk>[0..<N] = l1 @ x # l2; x \\<in> V; xa\\<rbrakk>\n       \\<Longrightarrow> Suc (card (V \\<inter> set l1)) =\n                         card (insert x (V \\<inter> set l1))\n 4. card (V \\<inter> {0..<N}) = card V", "apply (auto simp: upt_eq_lel_conv Int_absorb2 am_to_adj_nodes_refine[OF AM])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context \n  includes Network_Impl_Sepref_Register\nbegin"], ["", "sepref_register init_C"], ["", "end"], ["", "sepref_thm fifo_init_C_impl is \"(PR_CONST init_C)\" \n    :: \"am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1, PR_CONST init_C)\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "unfolding init_C_def PR_CONST_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (?fi1,\n     \\<lambda>am.\n        Let 0\n         (nfoldli [0..<N] (\\<lambda>_. True)\n           (\\<lambda>v cardV.\n               assert (v < N) \\<bind>\n               (\\<lambda>_.\n                   am_is_in_V am v \\<bind>\n                   (\\<lambda>inV.\n                       if inV then return (cardV + 1) else return cardV)))))\n    \\<in> local.am_assn\\<^sup>k \\<rightarrow>\\<^sub>a nat_assn", "by sepref"], ["", "concrete_definition (in -) fifo_init_C_impl \n  uses Network_Impl.fifo_init_C_impl.refine_raw is \"(?f,_)\\<in>_\""], ["", "lemmas [sepref_fr_rules] = fifo_init_C_impl.refine[OF Network_Impl_axioms]"], ["", "end \\<comment> \\<open>Network Implementation Locale\\<close>"], ["", "end"]]}