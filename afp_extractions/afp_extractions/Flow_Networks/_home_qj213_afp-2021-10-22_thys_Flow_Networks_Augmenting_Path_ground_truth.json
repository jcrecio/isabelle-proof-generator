{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Augmenting_Path.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma resCap_alt: \"resCap p = Min (cf`set p)\"  \n  \\<comment> \\<open>Useful characterization for finiteness arguments\\<close>", "lemma resCap_gzero_aux: \"cf.isPath s p t \\<Longrightarrow> 0<resCap p\"", "lemma resCap_gzero: \"isAugmentingPath p \\<Longrightarrow> 0<resCap p\"", "lemma sum_augmenting_alt:\n  assumes \"finite A\"          \n  shows \"(\\<Sum>e \\<in> A. (augmentingFlow p) e) \n        = resCap p * of_nat (card (A\\<inter>set p))\"", "lemma augFlow_resFlow: \"isAugmentingPath p \\<Longrightarrow> Flow cf s t (augmentingFlow p)\"", "lemma augFlow_val: \n  \"isAugmentingPath p \\<Longrightarrow> Flow.val cf s (augmentingFlow p) = resCap p\""], "translations": [["", "lemma resCap_alt: \"resCap p = Min (cf`set p)\"  \n  \\<comment> \\<open>Useful characterization for finiteness arguments\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. resCap p = Min (cf ` set p)", "unfolding resCap_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {cf e |e. e \\<in> set p} = Min (cf ` set p)", "apply (rule arg_cong[where f=Min])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {cf e |e. e \\<in> set p} = cf ` set p", "by auto"], ["", "text \\<open>An augmenting path induces an \\emph{augmenting flow}, which pushes as \n  much flow as possible along the path:\\<close>"], ["", "definition augmentingFlow :: \"path \\<Rightarrow> 'capacity flow\"\nwhere \"augmentingFlow p \\<equiv> \\<lambda>(u, v).\n  if (u, v) \\<in> (set p) then\n    resCap p\n  else\n    0\""], ["", "subsection \\<open>Augmenting Flow is Valid Flow\\<close>"], ["", "text \\<open>In this section, we show that the augmenting flow induced by an \n  augmenting path is a valid flow in the residual graph.\n\n  We start with some auxiliary lemmas.\\<close>"], ["", "text \\<open>The residual capacity of an augmenting path is always positive.\\<close>"], ["", "lemma resCap_gzero_aux: \"cf.isPath s p t \\<Longrightarrow> 0<resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "assume PATH: \"cf.isPath s p t\""], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "hence \"set p\\<noteq>{}\""], ["proof (prove)\nusing this:\n  cf.isPath s p t\n\ngoal (1 subgoal):\n 1. set p \\<noteq> {}", "using s_not_t"], ["proof (prove)\nusing this:\n  cf.isPath s p t\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. set p \\<noteq> {}", "by (auto)"], ["proof (state)\nthis:\n  set p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "moreover"], ["proof (state)\nthis:\n  set p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "have \"\\<forall>e\\<in>set p. cf e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set p. (0::'capacity) < cf e", "using cf.isPath_edgeset[OF PATH] resE_positive"], ["proof (prove)\nusing this:\n  ?e \\<in> set p \\<Longrightarrow> ?e \\<in> cf.E\n  ?e \\<in> cf.E \\<Longrightarrow> (0::'capacity) < cf ?e\n\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>set p. (0::'capacity) < cf e", "by (auto)"], ["proof (state)\nthis:\n  \\<forall>e\\<in>set p. (0::'capacity) < cf e\n\ngoal (1 subgoal):\n 1. cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p", "ultimately"], ["proof (chain)\npicking this:\n  set p \\<noteq> {}\n  \\<forall>e\\<in>set p. (0::'capacity) < cf e", "show ?thesis"], ["proof (prove)\nusing this:\n  set p \\<noteq> {}\n  \\<forall>e\\<in>set p. (0::'capacity) < cf e\n\ngoal (1 subgoal):\n 1. (0::'capacity) < resCap p", "unfolding resCap_alt"], ["proof (prove)\nusing this:\n  set p \\<noteq> {}\n  \\<forall>e\\<in>set p. (0::'capacity) < cf e\n\ngoal (1 subgoal):\n 1. (0::'capacity) < Min (cf ` set p)", "by (auto)"], ["proof (state)\nthis:\n  (0::'capacity) < resCap p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resCap_gzero: \"isAugmentingPath p \\<Longrightarrow> 0<resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> (0::'capacity) < resCap p", "using resCap_gzero_aux[of p]"], ["proof (prove)\nusing this:\n  cf.isPath s p t \\<Longrightarrow> (0::'capacity) < resCap p\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> (0::'capacity) < resCap p", "by (auto simp: isAugmentingPath_def cf.isSimplePath_def)"], ["", "text \\<open>As all edges of the augmenting flow have the same value, we can factor \n  this out from a summation:\\<close>"], ["", "lemma sum_augmenting_alt:\n  assumes \"finite A\"          \n  shows \"(\\<Sum>e \\<in> A. (augmentingFlow p) e) \n        = resCap p * of_nat (card (A\\<inter>set p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) A = resCap p * of_nat (card (A \\<inter> set p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) A = resCap p * of_nat (card (A \\<inter> set p))", "have \"(\\<Sum>e \\<in> A. (augmentingFlow p) e) = sum (\\<lambda>_. resCap p) (A\\<inter>set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) A = (\\<Sum>_\\<in>A \\<inter> set p. resCap p)", "apply (subst sum.inter_restrict)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite A\n 2. sum (augmentingFlow p) A =\n    (\\<Sum>x\\<in>A. if x \\<in> set p then resCap p else (0::'capacity))", "apply (auto simp: augmentingFlow_def assms)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sum (augmentingFlow p) A = (\\<Sum>_\\<in>A \\<inter> set p. resCap p)\n\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) A = resCap p * of_nat (card (A \\<inter> set p))", "thus ?thesis"], ["proof (prove)\nusing this:\n  sum (augmentingFlow p) A = (\\<Sum>_\\<in>A \\<inter> set p. resCap p)\n\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) A = resCap p * of_nat (card (A \\<inter> set p))", "by auto"], ["proof (state)\nthis:\n  sum (augmentingFlow p) A = resCap p * of_nat (card (A \\<inter> set p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma augFlow_resFlow: \"isAugmentingPath p \\<Longrightarrow> Flow cf s t (augmentingFlow p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> Flow cf s t (augmentingFlow p)", "proof (rule cf.intro_Flow; intro allI ballI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "assume AUG: \"isAugmentingPath p\""], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "hence SPATH: \"cf.isSimplePath s p t\""], ["proof (prove)\nusing this:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t", "by (simp add: isAugmentingPath_def)"], ["proof (state)\nthis:\n  cf.isSimplePath s p t\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "hence PATH: \"cf.isPath s p t\""], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. cf.isPath s p t", "by (simp add: cf.isSimplePath_def)"], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "{"], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "text \\<open>We first show the capacity constraint\\<close>"], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       isAugmentingPath p \\<Longrightarrow>\n       (0::'capacity) \\<le> augmentingFlow p e \\<and>\n       augmentingFlow p e \\<le> cf e\n 2. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "show \"0 \\<le> (augmentingFlow p) e \\<and> (augmentingFlow p) e \\<le> cf e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "proof cases"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "assume \"e \\<in> set p\""], ["proof (state)\nthis:\n  e \\<in> set p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "hence \"resCap p \\<le> cf e\""], ["proof (prove)\nusing this:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. resCap p \\<le> cf e", "unfolding resCap_alt"], ["proof (prove)\nusing this:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. Min (cf ` set p) \\<le> cf e", "by auto"], ["proof (state)\nthis:\n  resCap p \\<le> cf e\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "moreover"], ["proof (state)\nthis:\n  resCap p \\<le> cf e\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "have \"(augmentingFlow p) e = resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. augmentingFlow p e = resCap p", "unfolding augmentingFlow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> set p then resCap p else (0::'capacity)) =\n    resCap p", "using \\<open>e \\<in> set p\\<close>"], ["proof (prove)\nusing this:\n  e \\<in> set p\n\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> set p then resCap p else (0::'capacity)) =\n    resCap p", "by auto"], ["proof (state)\nthis:\n  augmentingFlow p e = resCap p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "moreover"], ["proof (state)\nthis:\n  augmentingFlow p e = resCap p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "have \"0 < resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) < resCap p", "using resCap_gzero[OF AUG]"], ["proof (prove)\nusing this:\n  (0::'capacity) < resCap p\n\ngoal (1 subgoal):\n 1. (0::'capacity) < resCap p", "by simp"], ["proof (state)\nthis:\n  (0::'capacity) < resCap p\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e\n 2. \\<not> ?P \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "ultimately"], ["proof (chain)\npicking this:\n  resCap p \\<le> cf e\n  augmentingFlow p e = resCap p\n  (0::'capacity) < resCap p", "show ?thesis"], ["proof (prove)\nusing this:\n  resCap p \\<le> cf e\n  augmentingFlow p e = resCap p\n  (0::'capacity) < resCap p\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p e \\<and>\n  augmentingFlow p e \\<le> cf e\n\ngoal (1 subgoal):\n 1. e \\<notin> set p \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<notin> set p \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "assume \"e \\<notin> set p\""], ["proof (state)\nthis:\n  e \\<notin> set p\n\ngoal (1 subgoal):\n 1. e \\<notin> set p \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "hence \"(augmentingFlow p) e = 0\""], ["proof (prove)\nusing this:\n  e \\<notin> set p\n\ngoal (1 subgoal):\n 1. augmentingFlow p e = (0::'capacity)", "unfolding augmentingFlow_def"], ["proof (prove)\nusing this:\n  e \\<notin> set p\n\ngoal (1 subgoal):\n 1. (case e of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> set p then resCap p else (0::'capacity)) =\n    (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  augmentingFlow p e = (0::'capacity)\n\ngoal (1 subgoal):\n 1. e \\<notin> set p \\<Longrightarrow>\n    (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "thus ?thesis"], ["proof (prove)\nusing this:\n  augmentingFlow p e = (0::'capacity)\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "using resE_nonNegative"], ["proof (prove)\nusing this:\n  augmentingFlow p e = (0::'capacity)\n  (0::'capacity) \\<le> cf ?e\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> augmentingFlow p e \\<and>\n    augmentingFlow p e \\<le> cf e", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p e \\<and>\n  augmentingFlow p e \\<le> cf e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p e \\<and>\n  augmentingFlow p e \\<le> cf e\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "}"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p ?e2 \\<and>\n  augmentingFlow p ?e2 \\<le> cf ?e2\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "{"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p ?e2 \\<and>\n  augmentingFlow p ?e2 \\<le> cf ?e2\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "text \\<open>Next, we show the conservation constraint\\<close>"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> augmentingFlow p ?e2 \\<and>\n  augmentingFlow p ?e2 \\<le> cf ?e2\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "assume asm_s: \"v \\<in> Graph.V cf - {s, t}\""], ["proof (state)\nthis:\n  v \\<in> cf.V - {s, t}\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "have \"card (Graph.incoming cf v \\<inter> set p) = card (Graph.outgoing cf v \\<inter> set p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "proof (cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "assume \"v\\<in>set (cf.pathVertices_fwd s p)\""], ["proof (state)\nthis:\n  v \\<in> set (cf.pathVertices_fwd s p)\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "from cf.split_path_at_vertex[OF this PATH]"], ["proof (chain)\npicking this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; cf.isPath s p1 v; cf.isPath v p2 t\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain p1 p2 where\n        P_FMT: \"p=p1@p2\" \n        and 1: \"cf.isPath s p1 v\"\n        and 2: \"cf.isPath v p2 t\""], ["proof (prove)\nusing this:\n  (\\<And>p1 p2.\n      \\<lbrakk>p = p1 @ p2; cf.isPath s p1 v; cf.isPath v p2 t\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>p1 p2.\n        \\<lbrakk>p = p1 @ p2; cf.isPath s p1 v; cf.isPath v p2 t\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "."], ["proof (state)\nthis:\n  p = p1 @ p2\n  cf.isPath s p1 v\n  cf.isPath v p2 t\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "from 1"], ["proof (chain)\npicking this:\n  cf.isPath s p1 v", "obtain p1' u1 where [simp]: \"p1=p1'@[(u1,v)]\""], ["proof (prove)\nusing this:\n  cf.isPath s p1 v\n\ngoal (1 subgoal):\n 1. (\\<And>p1' u1.\n        p1 = p1' @ [(u1, v)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using asm_s"], ["proof (prove)\nusing this:\n  cf.isPath s p1 v\n  v \\<in> cf.V - {s, t}\n\ngoal (1 subgoal):\n 1. (\\<And>p1' u1.\n        p1 = p1' @ [(u1, v)] \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p1 rule: rev_cases) (auto simp: split_path_simps)"], ["proof (state)\nthis:\n  p1 = p1' @ [(u1, v)]\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "from 2"], ["proof (chain)\npicking this:\n  cf.isPath v p2 t", "obtain p2' u2 where [simp]: \"p2=(v,u2)#p2'\""], ["proof (prove)\nusing this:\n  cf.isPath v p2 t\n\ngoal (1 subgoal):\n 1. (\\<And>u2 p2'.\n        p2 = (v, u2) # p2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using asm_s"], ["proof (prove)\nusing this:\n  cf.isPath v p2 t\n  v \\<in> cf.V - {s, t}\n\ngoal (1 subgoal):\n 1. (\\<And>u2 p2'.\n        p2 = (v, u2) # p2' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p2) (auto)"], ["proof (state)\nthis:\n  p2 = (v, u2) # p2'\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "from \n        cf.isSPath_sg_outgoing[OF SPATH, of v u2]  \n        cf.isSPath_sg_incoming[OF SPATH, of u1 v]\n        cf.isPath_edgeset[OF PATH]"], ["proof (chain)\npicking this:\n  \\<lbrakk>(v, u2) \\<in> set p; u2 \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> (v, ?v2.0) \\<notin> set p\n  \\<lbrakk>(u1, v) \\<in> set p; u1 \\<noteq> ?u2.0\\<rbrakk>\n  \\<Longrightarrow> (?u2.0, v) \\<notin> set p\n  ?e \\<in> set p \\<Longrightarrow> ?e \\<in> cf.E", "have \"cf.outgoing v \\<inter> set p = {(v,u2)}\" \"cf.incoming v \\<inter> set p = {(u1,v)}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(v, u2) \\<in> set p; u2 \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> (v, ?v2.0) \\<notin> set p\n  \\<lbrakk>(u1, v) \\<in> set p; u1 \\<noteq> ?u2.0\\<rbrakk>\n  \\<Longrightarrow> (?u2.0, v) \\<notin> set p\n  ?e \\<in> set p \\<Longrightarrow> ?e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf.outgoing v \\<inter> set p = {(v, u2)} &&&\n    cf.incoming v \\<inter> set p = {(u1, v)}", "by (fastforce simp: P_FMT cf.outgoing_def cf.incoming_def)+"], ["proof (state)\nthis:\n  cf.outgoing v \\<inter> set p = {(v, u2)}\n  cf.incoming v \\<inter> set p = {(u1, v)}\n\ngoal (2 subgoals):\n 1. ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)\n 2. \\<not> ?P \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cf.outgoing v \\<inter> set p = {(v, u2)}\n  cf.incoming v \\<inter> set p = {(u1, v)}\n\ngoal (1 subgoal):\n 1. card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "by auto"], ["proof (state)\nthis:\n  card (cf.incoming v \\<inter> set p) = card (cf.outgoing v \\<inter> set p)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (cf.pathVertices_fwd s p) \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<notin> set (cf.pathVertices_fwd s p) \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "assume \"v\\<notin>set (cf.pathVertices_fwd s p)\""], ["proof (state)\nthis:\n  v \\<notin> set (cf.pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. v \\<notin> set (cf.pathVertices_fwd s p) \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "then"], ["proof (chain)\npicking this:\n  v \\<notin> set (cf.pathVertices_fwd s p)", "have \"\\<forall>u. (u,v)\\<notin>set p \\<and> (v,u)\\<notin>set p\""], ["proof (prove)\nusing this:\n  v \\<notin> set (cf.pathVertices_fwd s p)\n\ngoal (1 subgoal):\n 1. \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p", "by (auto dest: cf.pathVertices_edge[OF PATH])"], ["proof (state)\nthis:\n  \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p\n\ngoal (1 subgoal):\n 1. v \\<notin> set (cf.pathVertices_fwd s p) \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "hence \"cf.incoming v \\<inter> set p = {}\" \"cf.outgoing v \\<inter> set p = {}\""], ["proof (prove)\nusing this:\n  \\<forall>u. (u, v) \\<notin> set p \\<and> (v, u) \\<notin> set p\n\ngoal (1 subgoal):\n 1. cf.incoming v \\<inter> set p = {} &&& cf.outgoing v \\<inter> set p = {}", "by (auto simp: cf.incoming_def cf.outgoing_def)"], ["proof (state)\nthis:\n  cf.incoming v \\<inter> set p = {}\n  cf.outgoing v \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. v \\<notin> set (cf.pathVertices_fwd s p) \\<Longrightarrow>\n    card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  cf.incoming v \\<inter> set p = {}\n  cf.outgoing v \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. card (cf.incoming v \\<inter> set p) =\n    card (cf.outgoing v \\<inter> set p)", "by auto"], ["proof (state)\nthis:\n  card (cf.incoming v \\<inter> set p) = card (cf.outgoing v \\<inter> set p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (cf.incoming v \\<inter> set p) = card (cf.outgoing v \\<inter> set p)\n\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>isAugmentingPath p; v \\<in> cf.V - {s, t}\\<rbrakk>\n       \\<Longrightarrow> sum (augmentingFlow p) (cf.incoming v) =\n                         sum (augmentingFlow p) (cf.outgoing v)", "thus \"(\\<Sum>e \\<in> Graph.incoming cf v. (augmentingFlow p) e) =\n      (\\<Sum>e \\<in> Graph.outgoing cf v. (augmentingFlow p) e)\""], ["proof (prove)\nusing this:\n  card (cf.incoming v \\<inter> set p) = card (cf.outgoing v \\<inter> set p)\n\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) (cf.incoming v) =\n    sum (augmentingFlow p) (cf.outgoing v)", "by (auto simp: sum_augmenting_alt)"], ["proof (state)\nthis:\n  sum (augmentingFlow p) (cf.incoming v) =\n  sum (augmentingFlow p) (cf.outgoing v)\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?v2 \\<in> cf.V - {s, t} \\<Longrightarrow>\n  sum (augmentingFlow p) (cf.incoming ?v2) =\n  sum (augmentingFlow p) (cf.outgoing ?v2)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Value of Augmenting Flow is Residual Capacity\\<close>"], ["", "text \\<open>Finally, we show that the value of the augmenting flow is the residual \n  capacity of the augmenting path\\<close>"], ["", "lemma augFlow_val: \n  \"isAugmentingPath p \\<Longrightarrow> Flow.val cf s (augmentingFlow p) = resCap p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow>\n    Flow.val cf s (augmentingFlow p) = resCap p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow>\n    Flow.val cf s (augmentingFlow p) = resCap p", "assume AUG: \"isAugmentingPath p\""], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow>\n    Flow.val cf s (augmentingFlow p) = resCap p", "with augFlow_resFlow"], ["proof (chain)\npicking this:\n  isAugmentingPath ?p \\<Longrightarrow> Flow cf s t (augmentingFlow ?p)\n  isAugmentingPath p", "interpret f: Flow cf s t \"augmentingFlow p\""], ["proof (prove)\nusing this:\n  isAugmentingPath ?p \\<Longrightarrow> Flow cf s t (augmentingFlow ?p)\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. Flow cf s t (augmentingFlow p)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "note AUG"], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "hence SPATH: \"cf.isSimplePath s p t\""], ["proof (prove)\nusing this:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. cf.isSimplePath s p t", "by (simp add: isAugmentingPath_def)"], ["proof (state)\nthis:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "hence PATH: \"cf.isPath s p t\""], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. cf.isPath s p t", "by (simp add: cf.isSimplePath_def)"], ["proof (state)\nthis:\n  cf.isPath s p t\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "then"], ["proof (chain)\npicking this:\n  cf.isPath s p t", "obtain v p' where \"p=(s,v)#p'\" \"(s,v)\\<in>cf.E\""], ["proof (prove)\nusing this:\n  cf.isPath s p t\n\ngoal (1 subgoal):\n 1. (\\<And>v p'.\n        \\<lbrakk>p = (s, v) # p'; (s, v) \\<in> cf.E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using s_not_t"], ["proof (prove)\nusing this:\n  cf.isPath s p t\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. (\\<And>v p'.\n        \\<lbrakk>p = (s, v) # p'; (s, v) \\<in> cf.E\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases p) auto"], ["proof (state)\nthis:\n  p = (s, v) # p'\n  (s, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "hence \"cf.outgoing s \\<inter> set p = {(s,v)}\""], ["proof (prove)\nusing this:\n  p = (s, v) # p'\n  (s, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf.outgoing s \\<inter> set p = {(s, v)}", "using cf.isSPath_sg_outgoing[OF SPATH, of s v]"], ["proof (prove)\nusing this:\n  p = (s, v) # p'\n  (s, v) \\<in> cf.E\n  \\<lbrakk>(s, v) \\<in> set p; v \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> (s, ?v2.0) \\<notin> set p\n\ngoal (1 subgoal):\n 1. cf.outgoing s \\<inter> set p = {(s, v)}", "using cf.isPath_edgeset[OF PATH]"], ["proof (prove)\nusing this:\n  p = (s, v) # p'\n  (s, v) \\<in> cf.E\n  \\<lbrakk>(s, v) \\<in> set p; v \\<noteq> ?v2.0\\<rbrakk>\n  \\<Longrightarrow> (s, ?v2.0) \\<notin> set p\n  ?e \\<in> set p \\<Longrightarrow> ?e \\<in> cf.E\n\ngoal (1 subgoal):\n 1. cf.outgoing s \\<inter> set p = {(s, v)}", "by (fastforce simp: cf.outgoing_def)"], ["proof (state)\nthis:\n  cf.outgoing s \\<inter> set p = {(s, v)}\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "moreover"], ["proof (state)\nthis:\n  cf.outgoing s \\<inter> set p = {(s, v)}\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "have \"cf.incoming s \\<inter> set p = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.incoming s \\<inter> set p = {}", "using SPATH no_incoming_s"], ["proof (prove)\nusing this:\n  cf.isSimplePath s p t\n  \\<forall>u. (u, s) \\<notin> E\n\ngoal (1 subgoal):\n 1. cf.incoming s \\<inter> set p = {}", "by (auto \n      simp: cf.incoming_def \\<open>p=(s,v)#p'\\<close> in_set_conv_decomp[where xs=p']\n      simp: cf.isSimplePath_append cf.isSimplePath_cons)"], ["proof (state)\nthis:\n  cf.incoming s \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. isAugmentingPath p \\<Longrightarrow> f.val = resCap p", "ultimately"], ["proof (chain)\npicking this:\n  cf.outgoing s \\<inter> set p = {(s, v)}\n  cf.incoming s \\<inter> set p = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  cf.outgoing s \\<inter> set p = {(s, v)}\n  cf.incoming s \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. f.val = resCap p", "unfolding f.val_def"], ["proof (prove)\nusing this:\n  cf.outgoing s \\<inter> set p = {(s, v)}\n  cf.incoming s \\<inter> set p = {}\n\ngoal (1 subgoal):\n 1. sum (augmentingFlow p) (cf.outgoing s) -\n    sum (augmentingFlow p) (cf.incoming s) =\n    resCap p", "by (auto simp: sum_augmenting_alt)"], ["proof (state)\nthis:\n  f.val = resCap p\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Network with flow\\<close>"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}