{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Network.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma conservation_const: \n    \"\\<forall>v \\<in> V - {s, t}. (\\<Sum>e \\<in> incoming v. f e) = (\\<Sum>e \\<in> outgoing v. f e)\"", "lemma edge_cap_positive: \"(u,v)\\<in>E \\<Longrightarrow> c (u,v) > 0\"", "lemma reachable_is_V[simp]: \"reachableNodes s = V\"", "lemma no_self_loop: \"\\<forall>u. (u, u) \\<notin> E\"", "lemma adjacent_not_self[simp, intro!]: \"v \\<notin> adjacent_nodes v\"", "lemma t_not_s[simp]: \"t \\<noteq> s\"", "lemma (in Network) isMaxFlow_alt: \n  \"isMaxFlow f \\<longleftrightarrow> NFlow c s t f \\<and> \n    (\\<forall>f'. NFlow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> Flow.val c s f)\"", "lemma zero_flow_simp[simp]:\n  \"(u,v)\\<notin>E \\<Longrightarrow> f(u,v) = 0\"", "lemma f_non_negative: \"0 \\<le> f e\"", "lemma sum_f_non_negative: \"sum f X \\<ge> 0\"", "lemma conservation_const_pointwise: \n  assumes \"u\\<in>V - {s,t}\"\n  shows \"(\\<Sum>v\\<in>E``{u}. f (u,v)) = (\\<Sum>v\\<in>E\\<inverse>``{u}. f (v,u))\"", "lemma val_bounded: \n  \"-(\\<Sum>e\\<in>incoming s. c e) \\<le> val\"\n  \"val \\<le> (\\<Sum>e\\<in>outgoing s. c e)\"", "lemma (in Graph) intro_Flow:\n  assumes cap: \"\\<forall>e. 0 \\<le> f e \\<and> f e \\<le> c e\"\n  assumes cons: \"\\<forall>v \\<in> V - {s, t}. \n    (\\<Sum>e \\<in> incoming v. f e) = (\\<Sum>e \\<in> outgoing v. f e)\"\n  shows \"Flow c s t f\"", "lemma sum_outgoing_alt_flow:\n  fixes g :: \"edge \\<Rightarrow> 'capacity\"\n  assumes \"u\\<in>V\"\n  shows \"(\\<Sum>e\\<in>outgoing u. f e) = (\\<Sum>v\\<in>V. f (u,v))\"", "lemma sum_incoming_alt_flow:\n  fixes g :: \"edge \\<Rightarrow> 'capacity\"\n  assumes \"u\\<in>V\"\n  shows \"(\\<Sum>e\\<in>incoming u. f e) = (\\<Sum>v\\<in>V. f (v,u))\"", "lemmas [simp] = no_incoming_s no_outgoing_t", "lemma incoming_s_empty[simp]: \"incoming s = {}\"", "lemma outgoing_t_empty[simp]: \"outgoing t = {}\"", "lemma cap_positive: \"e \\<in> E \\<Longrightarrow> c e > 0\"", "lemma V_not_empty: \"V\\<noteq>{}\"", "lemma E_not_empty: \"E\\<noteq>{}\"", "lemma card_V_ge2: \"card V \\<ge> 2\"", "lemma zero_is_flow: \"Flow c s t (\\<lambda>_. 0)\"", "lemma max_flow_val_unique: \n  \"\\<lbrakk>is_max_flow_val fv1; is_max_flow_val fv2\\<rbrakk> \\<Longrightarrow> fv1=fv2\"", "lemma no_inflow_s: \"\\<forall>e \\<in> incoming s. f e = 0\" (is ?thesis)", "lemma no_outflow_t: \"\\<forall>e \\<in> outgoing t. f e = 0\"", "lemma zero_rev_flow_simp[simp]: \"(u,v)\\<in>E \\<Longrightarrow> f(v,u) = 0\"", "lemma excess_non_negative: \"\\<forall>v\\<in>V-{s,t}. excess f v \\<ge> 0\"", "lemma excess_nodes_only: \"excess f v > 0 \\<Longrightarrow> v \\<in> V\"", "lemma excess_non_negative': \"\\<forall>v \\<in> V - {s}. excess f v \\<ge> 0\"", "lemma excess_s_non_pos: \"excess f s \\<le> 0\""], "translations": [["", "lemma conservation_const: \n    \"\\<forall>v \\<in> V - {s, t}. (\\<Sum>e \\<in> incoming v. f e) = (\\<Sum>e \\<in> outgoing v. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s, t}. sum f (incoming v) = sum f (outgoing v)", "using no_deficient_nodes no_active_nodes"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n  \\<forall>v\\<in>V - {s, t}. sum f (incoming v) \\<le> sum f (outgoing v)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s, t}. sum f (incoming v) = sum f (outgoing v)", "by force"], ["", "text \\<open>The value of a flow is the flow that leaves $s$ and does not return.\\<close>"], ["", "definition val :: \"'capacity\"\n    where \"val \\<equiv> (\\<Sum>e \\<in> outgoing s. f e) - (\\<Sum>e \\<in> incoming s. f e)\""], ["", "end"], ["", "locale Finite_Preflow = Preflow c s t f + Finite_Graph c \n  for c :: \"'capacity::linordered_idom graph\" and s t f"], ["", "locale Finite_Flow = Flow c s t f + Finite_Preflow c s t f\n  for c :: \"'capacity::linordered_idom graph\" and s t f"], ["", "subsubsection \\<open>Cuts\\<close>"], ["", "text \\<open>A \\<^emph>\\<open>cut\\<close> is a partitioning of the nodes into two sets. \n  We define it by just specifying one of the partitions. \n  The other partition is implicitly given by the remaining nodes.\\<close>"], ["", "type_synonym cut = \"node set\""], ["", "locale Cut = Graph +  (* TODO: We probably do not need the cut-locale, \n  only NCut.*)\n  fixes k :: cut\n  assumes cut_ss_V: \"k \\<subseteq> V\""], ["", "subsubsection \\<open>Networks\\<close>"], ["", "text \\<open>A \\<^emph>\\<open>network\\<close> is a finite graph with two distinct nodes, source and sink, \n  such that all edges are labeled with positive capacities. \n  Moreover, we assume that \n  \\<^item> The source has no incoming edges, and the sink has no outgoing edges.\n  \\<^item> There are no parallel edges, i.e., for any edge, the reverse edge must not be in the network.\n  \\<^item> Every node must lay on a path from the source to the sink.\n\n  Notes on the formalization\n  \\<^item> We encode the graph by a mapping \\<open>c\\<close>, such that \\<open>c (u,v)\\<close> is \n    the capacity of edge \\<open>(u,v)\\<close>, or \\<open>0\\<close>, if there is no edge from \\<open>u\\<close> to \\<open>v\\<close>.\n    Thus, in the formalization below, we only demand \n    that \\<open>c (u,v) \\<ge> 0\\<close> for all \\<open>u\\<close> and \\<open>v\\<close>.\n  \\<^item> We only demand the set of nodes reachable from the source to be finite.\n    Together with the constraint that all nodes lay on a path from the source,\n    this implies that the graph is finite.\n\\<close>"], ["", "locale Network = Graph c for c :: \"'capacity::linordered_idom graph\" +\n  fixes s t :: node\n  assumes s_node[simp, intro!]: \"s \\<in> V\"\n  assumes t_node[simp, intro!]: \"t \\<in> V\"\n  assumes s_not_t[simp, intro!]: \"s \\<noteq> t\"\n    \n  assumes cap_non_negative: \"\\<forall>u v. c (u, v) \\<ge> 0\"\n  assumes no_incoming_s: \"\\<forall>u. (u, s) \\<notin> E\"\n  assumes no_outgoing_t: \"\\<forall>u. (t, u) \\<notin> E\"\n  assumes no_parallel_edge: \"\\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\"\n  assumes nodes_on_st_path: \"\\<forall>v \\<in> V. connected s v \\<and> connected v t\"\n  assumes finite_reachable: \"finite (reachableNodes s)\"\nbegin"], ["", "text \\<open>Edges have positive capacity\\<close>"], ["", "lemma edge_cap_positive: \"(u,v)\\<in>E \\<Longrightarrow> c (u,v) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow> (0::'capacity) < c (u, v)", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)} \\<Longrightarrow>\n    (0::'capacity) < c (u, v)", "using cap_non_negative[THEN spec2, of u v]"], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> c (u, v)\n\ngoal (1 subgoal):\n 1. (u, v)\n    \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)} \\<Longrightarrow>\n    (0::'capacity) < c (u, v)", "by simp"], ["", "text \\<open>The network constraints implies that all nodes are \n    reachable from the source node\\<close>"], ["", "lemma reachable_is_V[simp]: \"reachableNodes s = V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachableNodes s = V", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. reachableNodes s \\<subseteq> V\n 2. V \\<subseteq> reachableNodes s", "show \"V \\<subseteq> reachableNodes s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> reachableNodes s", "unfolding reachableNodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<subseteq> {v. connected s v}", "using s_node nodes_on_st_path"], ["proof (prove)\nusing this:\n  s \\<in> V\n  \\<forall>v\\<in>V. connected s v \\<and> connected v t\n\ngoal (1 subgoal):\n 1. V \\<subseteq> {v. connected s v}", "by auto"], ["proof (state)\nthis:\n  V \\<subseteq> reachableNodes s\n\ngoal (1 subgoal):\n 1. reachableNodes s \\<subseteq> V", "qed (simp add: reachable_ss_V)"], ["", "text \\<open>Thus, the network is actually a finite graph.\\<close>"], ["", "sublocale Finite_Graph"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Graph c", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite V", "using reachable_is_V finite_reachable"], ["proof (prove)\nusing this:\n  reachableNodes s = V\n  finite (reachableNodes s)\n\ngoal (1 subgoal):\n 1. finite V", "by auto"], ["", "text \\<open>Our assumptions imply that there are no self loops\\<close>"], ["", "lemma no_self_loop: \"\\<forall>u. (u, u) \\<notin> E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u. (u, u) \\<notin> E", "using no_parallel_edge"], ["proof (prove)\nusing this:\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<forall>u. (u, u) \\<notin> E", "by auto"], ["", "lemma adjacent_not_self[simp, intro!]: \"v \\<notin> adjacent_nodes v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> adjacent_nodes v", "unfolding adjacent_nodes_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> E `` {v} \\<union> E\\<inverse> `` {v}", "using no_self_loop"], ["proof (prove)\nusing this:\n  \\<forall>u. (u, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. v \\<notin> E `` {v} \\<union> E\\<inverse> `` {v}", "by auto"], ["", "text \\<open>A flow is maximal, if it has a maximal value\\<close>"], ["", "definition isMaxFlow :: \"_ flow \\<Rightarrow> bool\" \n  where \"isMaxFlow f \\<equiv> Flow c s t f \\<and> \n    (\\<forall>f'. Flow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> Flow.val c s f)\""], ["", "definition \"is_max_flow_val fv \\<equiv> \\<exists>f. isMaxFlow f \\<and> fv=Flow.val c s f\""], ["", "(* TODO: Can we prove existence of a maximum flow *easily*, i.e.,\n  without going over the min-cut-max-flow theorem or the Ford-Fulkerson method?\n  definition \"max_flow_val \\<equiv> THE fv. is_max_flow_val fv\"\n*)"], ["", "lemma t_not_s[simp]: \"t \\<noteq> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<noteq> s", "using s_not_t"], ["proof (prove)\nusing this:\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. t \\<noteq> s", "by blast"], ["", "text \\<open>The excess of a node is the difference between incoming and \n    outgoing flow.\\<close>"], ["", "(* TODO: Define in context of preflow!? *)"], ["", "definition excess :: \"'capacity flow \\<Rightarrow> node \\<Rightarrow> 'capacity\" where\n    \"excess f v \\<equiv> (\\<Sum>e\\<in>incoming v. f e) - (\\<Sum>e\\<in>outgoing v. f e)\""], ["", "end"], ["", "subsubsection \\<open>Networks with Flows and Cuts\\<close>"], ["", "text \\<open>For convenience, we define locales for a network with a fixed flow,\n  and a network with a fixed cut\\<close>"], ["", "locale NPreflow = Network c s t + Preflow c s t f \n  for c :: \"'capacity::linordered_idom graph\" and s t f\nbegin"], ["", "end"], ["", "locale NFlow = NPreflow c s t f + Flow c s t f \n  for c :: \"'capacity::linordered_idom graph\" and s t f"], ["", "lemma (in Network) isMaxFlow_alt: \n  \"isMaxFlow f \\<longleftrightarrow> NFlow c s t f \\<and> \n    (\\<forall>f'. NFlow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> Flow.val c s f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f =\n    (NFlow c s t f \\<and>\n     (\\<forall>f'.\n         NFlow c s t f' \\<longrightarrow>\n         Flow.val c s f' \\<le> Flow.val c s f))", "unfolding isMaxFlow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Flow c s t f \\<and>\n     (\\<forall>f'.\n         Flow c s t f' \\<longrightarrow>\n         Flow.val c s f' \\<le> Flow.val c s f)) =\n    (NFlow c s t f \\<and>\n     (\\<forall>f'.\n         NFlow c s t f' \\<longrightarrow>\n         Flow.val c s f' \\<le> Flow.val c s f))", "by (auto simp: NFlow_def Flow_def NPreflow_def) intro_locales"], ["", "text \\<open>A cut in a network separates the source from the sink\\<close>"], ["", "locale NCut = Network c s t + Cut c k \n  for c :: \"'capacity::linordered_idom graph\" and s t k +\n  assumes s_in_cut: \"s \\<in> k\"\n  assumes t_ni_cut: \"t \\<notin> k\"\nbegin"], ["", "text \\<open>The capacity of the cut is the capacity of all edges going from the \n    source's side to the sink's side.\\<close>"], ["", "definition cap :: \"'capacity\"\n    where \"cap \\<equiv> (\\<Sum>e \\<in> outgoing' k. c e)\""], ["", "end"], ["", "text \\<open>A minimum cut is a cut with minimum capacity.\\<close>"], ["", "(* TODO: The definitions of min-cut and max-flow are done in different contexts. \n  Align, probably both in network context! *)"], ["", "definition isMinCut :: \"_ graph \\<Rightarrow> nat \\<Rightarrow> nat \\<Rightarrow> cut \\<Rightarrow> bool\" \nwhere \"isMinCut c s t k \\<equiv> NCut c s t k \\<and>\n  (\\<forall>k'. NCut c s t k' \\<longrightarrow> NCut.cap c k \\<le> NCut.cap c k')\""], ["", "subsection \\<open>Properties\\<close>"], ["", "subsubsection \\<open>Flows\\<close>"], ["", "context Preflow \nbegin"], ["", "text \\<open>Only edges are labeled with non-zero flows\\<close>"], ["", "lemma zero_flow_simp[simp]:\n  \"(u,v)\\<notin>E \\<Longrightarrow> f(u,v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<notin> E \\<Longrightarrow> f (u, v) = (0::'capacity)", "by (metis capacity_const eq_iff zero_cap_simp)"], ["", "lemma f_non_negative: \"0 \\<le> f e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> f e", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> f e", "by (cases e) auto"], ["", "lemma sum_f_non_negative: \"sum f X \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> sum f X", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> sum f X", "by (auto simp: sum_nonneg f_non_negative)"], ["", "end \\<comment> \\<open>Preflow\\<close>"], ["", "context Flow\nbegin"], ["", "text \\<open>We provide a useful equivalent formulation of the \n  conservation constraint.\\<close>"], ["", "lemma conservation_const_pointwise: \n  assumes \"u\\<in>V - {s,t}\"\n  shows \"(\\<Sum>v\\<in>E``{u}. f (u,v)) = (\\<Sum>v\\<in>E\\<inverse>``{u}. f (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>E `` {u}. f (u, v)) =\n    (\\<Sum>v\\<in>E\\<inverse> `` {u}. f (v, u))", "using conservation_const assms"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (incoming v) = sum f (outgoing v)\n  u \\<in> V - {s, t}\n\ngoal (1 subgoal):\n 1. (\\<Sum>v\\<in>E `` {u}. f (u, v)) =\n    (\\<Sum>v\\<in>E\\<inverse> `` {u}. f (v, u))", "by (auto simp: sum_incoming_pointwise sum_outgoing_pointwise)"], ["", "text \\<open>The value of the flow is bounded by the capacity of the \n  outgoing edges of the source node\\<close>"], ["", "lemma val_bounded: \n  \"-(\\<Sum>e\\<in>incoming s. c e) \\<le> val\"\n  \"val \\<le> (\\<Sum>e\\<in>outgoing s. c e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - sum c (incoming s) \\<le> val &&& val \\<le> sum c (outgoing s)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. - sum c (incoming s) \\<le> val\n 2. val \\<le> sum c (outgoing s)", "have \n    \"sum f (outgoing s) \\<le> sum c (outgoing s)\"\n    \"sum f (incoming s) \\<le> sum c (incoming s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing s) \\<le> sum c (outgoing s) &&&\n    sum f (incoming s) \\<le> sum c (incoming s)", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. sum f (outgoing s) \\<le> sum c (outgoing s) &&&\n    sum f (incoming s) \\<le> sum c (incoming s)", "by (auto intro!: sum_mono)"], ["proof (state)\nthis:\n  sum f (outgoing s) \\<le> sum c (outgoing s)\n  sum f (incoming s) \\<le> sum c (incoming s)\n\ngoal (2 subgoals):\n 1. - sum c (incoming s) \\<le> val\n 2. val \\<le> sum c (outgoing s)", "thus \"-(\\<Sum>e\\<in>incoming s. c e) \\<le> val\" \"val \\<le> (\\<Sum>e\\<in>outgoing s. c e)\""], ["proof (prove)\nusing this:\n  sum f (outgoing s) \\<le> sum c (outgoing s)\n  sum f (incoming s) \\<le> sum c (incoming s)\n\ngoal (1 subgoal):\n 1. - sum c (incoming s) \\<le> val &&& val \\<le> sum c (outgoing s)", "using sum_f_non_negative[of \"incoming s\"]"], ["proof (prove)\nusing this:\n  sum f (outgoing s) \\<le> sum c (outgoing s)\n  sum f (incoming s) \\<le> sum c (incoming s)\n  (0::'capacity) \\<le> sum f (incoming s)\n\ngoal (1 subgoal):\n 1. - sum c (incoming s) \\<le> val &&& val \\<le> sum c (outgoing s)", "using sum_f_non_negative[of \"outgoing s\"]"], ["proof (prove)\nusing this:\n  sum f (outgoing s) \\<le> sum c (outgoing s)\n  sum f (incoming s) \\<le> sum c (incoming s)\n  (0::'capacity) \\<le> sum f (incoming s)\n  (0::'capacity) \\<le> sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. - sum c (incoming s) \\<le> val &&& val \\<le> sum c (outgoing s)", "unfolding val_def"], ["proof (prove)\nusing this:\n  sum f (outgoing s) \\<le> sum c (outgoing s)\n  sum f (incoming s) \\<le> sum c (incoming s)\n  (0::'capacity) \\<le> sum f (incoming s)\n  (0::'capacity) \\<le> sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. - sum c (incoming s) \\<le> sum f (outgoing s) - sum f (incoming s) &&&\n    sum f (outgoing s) - sum f (incoming s) \\<le> sum c (outgoing s)", "by auto"], ["proof (state)\nthis:\n  - sum c (incoming s) \\<le> val\n  val \\<le> sum c (outgoing s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Flow\\<close>"], ["", "text \\<open>Introduce a flow via the conservation constraint\\<close>"], ["", "lemma (in Graph) intro_Flow:\n  assumes cap: \"\\<forall>e. 0 \\<le> f e \\<and> f e \\<le> c e\"\n  assumes cons: \"\\<forall>v \\<in> V - {s, t}. \n    (\\<Sum>e \\<in> incoming v. f e) = (\\<Sum>e \\<in> outgoing v. f e)\"\n  shows \"Flow c s t f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Flow c s t f", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n  \\<forall>v\\<in>V - {s, t}. sum f (incoming v) = sum f (outgoing v)\n\ngoal (1 subgoal):\n 1. Flow c s t f", "by unfold_locales auto"], ["", "context Finite_Preflow \nbegin"], ["", "text \\<open>The summation of flows over incoming/outgoing edges can be \n  extended to a summation over all possible predecessor/successor nodes,\n  as the additional flows are all zero.\\<close>"], ["", "lemma sum_outgoing_alt_flow:\n  fixes g :: \"edge \\<Rightarrow> 'capacity\"\n  assumes \"u\\<in>V\"\n  shows \"(\\<Sum>e\\<in>outgoing u. f e) = (\\<Sum>v\\<in>V. f (u,v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing u) = (\\<Sum>v\\<in>V. f (u, v))", "apply (subst sum_outgoing_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n 2. u \\<in> V\n 3. (\\<Sum>ua\\<in>V. f (u, ua)) = (\\<Sum>v\\<in>V. f (u, v))", "using assms capacity_const"], ["proof (prove)\nusing this:\n  u \\<in> V\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (3 subgoals):\n 1. \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n 2. u \\<in> V\n 3. (\\<Sum>ua\\<in>V. f (u, ua)) = (\\<Sum>v\\<in>V. f (u, v))", "by auto"], ["", "lemma sum_incoming_alt_flow:\n  fixes g :: \"edge \\<Rightarrow> 'capacity\"\n  assumes \"u\\<in>V\"\n  shows \"(\\<Sum>e\\<in>incoming u. f e) = (\\<Sum>v\\<in>V. f (v,u))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming u) = (\\<Sum>v\\<in>V. f (v, u))", "apply (subst sum_incoming_alt)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n 2. u \\<in> V\n 3. (\\<Sum>ua\\<in>V. f (ua, u)) = (\\<Sum>v\\<in>V. f (v, u))", "using assms capacity_const"], ["proof (prove)\nusing this:\n  u \\<in> V\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (3 subgoals):\n 1. \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n 2. u \\<in> V\n 3. (\\<Sum>ua\\<in>V. f (ua, u)) = (\\<Sum>v\\<in>V. f (v, u))", "by auto"], ["", "end \\<comment> \\<open>Finite Preflow\\<close>"], ["", "subsubsection \\<open>Networks\\<close>"], ["", "context Network\nbegin"], ["", "lemmas [simp] = no_incoming_s no_outgoing_t"], ["", "lemma incoming_s_empty[simp]: \"incoming s = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incoming s = {}", "unfolding incoming_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(u, s) |u. (u, s) \\<in> E} = {}", "using no_incoming_s"], ["proof (prove)\nusing this:\n  \\<forall>u. (u, s) \\<notin> E\n\ngoal (1 subgoal):\n 1. {(u, s) |u. (u, s) \\<in> E} = {}", "by auto"], ["", "lemma outgoing_t_empty[simp]: \"outgoing t = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outgoing t = {}", "unfolding outgoing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(t, u) |u. (t, u) \\<in> E} = {}", "using no_outgoing_t"], ["proof (prove)\nusing this:\n  \\<forall>u. (t, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. {(t, u) |u. (t, u) \\<in> E} = {}", "by auto"], ["", "lemma cap_positive: \"e \\<in> E \\<Longrightarrow> c e > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> E \\<Longrightarrow> (0::'capacity) < c e", "unfolding E_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)} \\<Longrightarrow>\n    (0::'capacity) < c e", "using cap_non_negative le_neq_trans"], ["proof (prove)\nusing this:\n  \\<forall>u v. (0::'capacity) \\<le> c (u, v)\n  \\<lbrakk>?a \\<le> ?b; ?a \\<noteq> ?b\\<rbrakk> \\<Longrightarrow> ?a < ?b\n\ngoal (1 subgoal):\n 1. e \\<in> {(u, v). c (u, v) \\<noteq> (0::'capacity)} \\<Longrightarrow>\n    (0::'capacity) < c e", "by fastforce"], ["", "lemma V_not_empty: \"V\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V \\<noteq> {}", "using s_node"], ["proof (prove)\nusing this:\n  s \\<in> V\n\ngoal (1 subgoal):\n 1. V \\<noteq> {}", "by auto"], ["", "lemma E_not_empty: \"E\\<noteq>{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E \\<noteq> {}", "using V_not_empty"], ["proof (prove)\nusing this:\n  V \\<noteq> {}\n\ngoal (1 subgoal):\n 1. E \\<noteq> {}", "by (auto simp: V_def)"], ["", "lemma card_V_ge2: \"card V \\<ge> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "have \"2 = card {s,t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 = card {s, t}", "by auto"], ["proof (state)\nthis:\n  2 = card {s, t}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "also"], ["proof (state)\nthis:\n  2 = card {s, t}\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "have \"{s,t} \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {s, t} \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  {s, t} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "hence \"card {s,t} \\<le> card V\""], ["proof (prove)\nusing this:\n  {s, t} \\<subseteq> V\n\ngoal (1 subgoal):\n 1. card {s, t} \\<le> card V", "by (rule_tac card_mono) auto"], ["proof (state)\nthis:\n  card {s, t} \\<le> card V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "finally"], ["proof (chain)\npicking this:\n  2 \\<le> card V", "show ?thesis"], ["proof (prove)\nusing this:\n  2 \\<le> card V\n\ngoal (1 subgoal):\n 1. 2 \\<le> card V", "."], ["proof (state)\nthis:\n  2 \\<le> card V\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma zero_is_flow: \"Flow c s t (\\<lambda>_. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Flow c s t (\\<lambda>_. 0::'capacity)", "using cap_non_negative"], ["proof (prove)\nusing this:\n  \\<forall>u v. (0::'capacity) \\<le> c (u, v)\n\ngoal (1 subgoal):\n 1. Flow c s t (\\<lambda>_. 0::'capacity)", "by unfold_locales auto"], ["", "lemma max_flow_val_unique: \n  \"\\<lbrakk>is_max_flow_val fv1; is_max_flow_val fv2\\<rbrakk> \\<Longrightarrow> fv1=fv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>is_max_flow_val fv1; is_max_flow_val fv2\\<rbrakk>\n    \\<Longrightarrow> fv1 = fv2", "unfolding is_max_flow_val_def isMaxFlow_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>f.\n                (Flow c s t f \\<and>\n                 (\\<forall>f'.\n                     Flow c s t f' \\<longrightarrow>\n                     Flow.val c s f' \\<le> Flow.val c s f)) \\<and>\n                fv1 = Flow.val c s f;\n     \\<exists>f.\n        (Flow c s t f \\<and>\n         (\\<forall>f'.\n             Flow c s t f' \\<longrightarrow>\n             Flow.val c s f' \\<le> Flow.val c s f)) \\<and>\n        fv2 = Flow.val c s f\\<rbrakk>\n    \\<Longrightarrow> fv1 = fv2", "by (auto simp: antisym)"], ["", "end \\<comment> \\<open>Network\\<close>"], ["", "subsubsection \\<open>Networks with Flow\\<close>"], ["", "context NPreflow \nbegin"], ["", "sublocale Finite_Preflow"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Preflow c s t f", "by unfold_locales"], ["", "text \\<open>As there are no edges entering the source/leaving the sink, \n  also the corresponding flow values are zero:\\<close>"], ["", "lemma no_inflow_s: \"\\<forall>e \\<in> incoming s. f e = 0\" (is ?thesis)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>incoming s. f e = (0::'capacity)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>incoming s.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>e \\<in> incoming s. f e = 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>e\\<in>incoming s. f e = (0::'capacity))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>incoming s.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>e\\<in>incoming s. f e = (0::'capacity))", "obtain e where obt1: \"e \\<in> incoming s \\<and> f e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>e\\<in>incoming s. f e = (0::'capacity))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> incoming s \\<and>\n        f e \\<noteq> (0::'capacity) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> incoming s \\<and> f e \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>incoming s.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  e \\<in> incoming s \\<and> f e \\<noteq> (0::'capacity)", "have \"e \\<in> E\""], ["proof (prove)\nusing this:\n  e \\<in> incoming s \\<and> f e \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. e \\<in> E", "using incoming_def"], ["proof (prove)\nusing this:\n  e \\<in> incoming s \\<and> f e \\<noteq> (0::'capacity)\n  incoming ?v \\<equiv> {(u, ?v) |u. (u, ?v) \\<in> E}\n\ngoal (1 subgoal):\n 1. e \\<in> E", "by auto"], ["proof (state)\nthis:\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>incoming s.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. False", "using obt1 no_incoming_s incoming_def"], ["proof (prove)\nusing this:\n  e \\<in> E\n  e \\<in> incoming s \\<and> f e \\<noteq> (0::'capacity)\n  \\<forall>u. (u, s) \\<notin> E\n  incoming ?v \\<equiv> {(u, ?v) |u. (u, ?v) \\<in> E}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma no_outflow_t: \"\\<forall>e \\<in> outgoing t. f e = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>e\\<in>outgoing t. f e = (0::'capacity)", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>outgoing t.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "assume \"\\<not>(\\<forall>e \\<in> outgoing t. f e = 0)\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>e\\<in>outgoing t. f e = (0::'capacity))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>outgoing t.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>e\\<in>outgoing t. f e = (0::'capacity))", "obtain e where obt1: \"e \\<in> outgoing t \\<and> f e \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>e\\<in>outgoing t. f e = (0::'capacity))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        e \\<in> outgoing t \\<and>\n        f e \\<noteq> (0::'capacity) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e \\<in> outgoing t \\<and> f e \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>outgoing t.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  e \\<in> outgoing t \\<and> f e \\<noteq> (0::'capacity)", "have \"e \\<in> E\""], ["proof (prove)\nusing this:\n  e \\<in> outgoing t \\<and> f e \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. e \\<in> E", "using outgoing_def"], ["proof (prove)\nusing this:\n  e \\<in> outgoing t \\<and> f e \\<noteq> (0::'capacity)\n  outgoing ?v \\<equiv> {(?v, u) |u. (?v, u) \\<in> E}\n\ngoal (1 subgoal):\n 1. e \\<in> E", "by auto"], ["proof (state)\nthis:\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>e\\<in>outgoing t.\n               f e = (0::'capacity)) \\<Longrightarrow>\n    False", "thus \"False\""], ["proof (prove)\nusing this:\n  e \\<in> E\n\ngoal (1 subgoal):\n 1. False", "using obt1 no_outgoing_t outgoing_def"], ["proof (prove)\nusing this:\n  e \\<in> E\n  e \\<in> outgoing t \\<and> f e \\<noteq> (0::'capacity)\n  \\<forall>u. (t, u) \\<notin> E\n  outgoing ?v \\<equiv> {(?v, u) |u. (?v, u) \\<in> E}\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>For an edge, there is no reverse edge, and thus, \n  no flow in the reverse direction:\\<close>"], ["", "lemma zero_rev_flow_simp[simp]: \"(u,v)\\<in>E \\<Longrightarrow> f(v,u) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow> f (v, u) = (0::'capacity)", "using no_parallel_edge"], ["proof (prove)\nusing this:\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E \\<Longrightarrow> f (v, u) = (0::'capacity)", "by auto"], ["", "lemma excess_non_negative: \"\\<forall>v\\<in>V-{s,t}. excess f v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s, t}. (0::'capacity) \\<le> excess f v", "unfolding excess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s, t}.\n       (0::'capacity) \\<le> sum f (incoming v) - sum f (outgoing v)", "using no_deficient_nodes"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (outgoing v) \\<le> sum f (incoming v)\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s, t}.\n       (0::'capacity) \\<le> sum f (incoming v) - sum f (outgoing v)", "by auto"], ["", "lemma excess_nodes_only: \"excess f v > 0 \\<Longrightarrow> v \\<in> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) < excess f v \\<Longrightarrow> v \\<in> V", "unfolding excess_def incoming_def outgoing_def V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity)\n    < sum f {(u, v) |u. (u, v) \\<in> E} -\n      sum f {(v, u) |u. (v, u) \\<in> E} \\<Longrightarrow>\n    v \\<in> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E}", "using sum.not_neutral_contains_not_neutral"], ["proof (prove)\nusing this:\n  \\<lbrakk>sum ?g ?A \\<noteq> (0::?'a);\n   \\<And>a.\n      \\<lbrakk>a \\<in> ?A; ?g a \\<noteq> (0::?'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (0::'capacity)\n    < sum f {(u, v) |u. (u, v) \\<in> E} -\n      sum f {(v, u) |u. (v, u) \\<in> E} \\<Longrightarrow>\n    v \\<in> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E}", "by fastforce"], ["", "lemma excess_non_negative': \"\\<forall>v \\<in> V - {s}. excess f v \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v", "have \"excess f t \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) \\<le> excess f t", "unfolding excess_def outgoing_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity)\n    \\<le> sum f (incoming t) - sum f {(t, u) |u. (t, u) \\<in> E}", "by (auto simp: capacity_const sum_nonneg)"], ["proof (state)\nthis:\n  (0::'capacity) \\<le> excess f t\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v", "thus ?thesis"], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> excess f t\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v", "using excess_non_negative"], ["proof (prove)\nusing this:\n  (0::'capacity) \\<le> excess f t\n  \\<forall>v\\<in>V - {s, t}. (0::'capacity) \\<le> excess f v\n\ngoal (1 subgoal):\n 1. \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v", "by blast"], ["proof (state)\nthis:\n  \\<forall>v\\<in>V - {s}. (0::'capacity) \\<le> excess f v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma excess_s_non_pos: \"excess f s \\<le> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. excess f s \\<le> (0::'capacity)", "unfolding excess_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming s) - sum f (outgoing s) \\<le> (0::'capacity)", "by (simp add: capacity_const sum_nonneg)"], ["", "end \\<comment> \\<open>Network with preflow\\<close>"], ["", "context NFlow begin"], ["", "sublocale Finite_Preflow"], ["proof (prove)\ngoal (1 subgoal):\n 1. Finite_Preflow c s t f", "by unfold_locales"], ["", "text \\<open>There is no outflow from the sink in a network. \n    Thus, we can simplify the definition of the value:\\<close>"], ["", "corollary val_alt: \"val = (\\<Sum>e \\<in> outgoing s. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val = sum f (outgoing s)", "unfolding val_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing s) - sum f (incoming s) = sum f (outgoing s)", "by (auto simp: no_inflow_s)"], ["", "end"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}