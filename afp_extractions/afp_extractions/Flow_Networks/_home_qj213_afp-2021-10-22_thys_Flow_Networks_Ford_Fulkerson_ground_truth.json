{"file_name": "/home/qj213/afp-2021-10-22/thys/Flow_Networks/Ford_Fulkerson.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Flow_Networks", "problem_names": ["lemma finite_k[simp, intro!]: \"finite k\"", "lemma flow_value: \"netFlow = val\"", "lemma fofu_I_II: \"isMaxFlow f \\<Longrightarrow> \\<not> (\\<exists> p. isAugmentingPath p)\"", "lemma fofu_II_III: \n  \"\\<not> (\\<exists> p. isAugmentingPath p) \\<Longrightarrow> \\<exists>k'. NCut c s t k' \\<and> val = NCut.cap c k'\"", "lemma fofu_III_I: \n  \"\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k \\<Longrightarrow> isMaxFlow f\"", "theorem ford_fulkerson: shows\n  \"isMaxFlow f \\<longleftrightarrow> \n  \\<not> Ex isAugmentingPath\" and \"\\<not> Ex isAugmentingPath \\<longleftrightarrow> \n  (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)\""], "translations": [["", "lemma finite_k[simp, intro!]: \"finite k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite k", "using cut_ss_V finite_V finite_subset[of k V]"], ["proof (prove)\nusing this:\n  k \\<subseteq> V\n  finite V\n  \\<lbrakk>k \\<subseteq> V; finite V\\<rbrakk> \\<Longrightarrow> finite k\n\ngoal (1 subgoal):\n 1. finite k", "by blast"], ["", "subsection \\<open>Net Flow\\<close>"], ["", "text \\<open>We define the \\emph{net flow} to be the amount of flow effectively \n  passed over the cut from the source to the sink:\\<close>"], ["", "definition netFlow :: \"'capacity\"\n  where \"netFlow \\<equiv> (\\<Sum>e \\<in> outgoing' k. f e) - (\\<Sum>e \\<in> incoming' k. f e)\""], ["", "text \\<open>We can show that the net flow equals the value of the flow.\n  Note: Cormen et al.~\\cite{CLRS09} present a whole page full of \n  summation calculations for this proof, and our formal proof also \n  looks quite complicated.\n\\<close>"], ["", "lemma flow_value: \"netFlow = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netFlow = val", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?LCL = \"{(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E}\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?AOG = \"{(u, v). u \\<in> k \\<and> (u, v) \\<in> E}\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?AIN = \"{(v, u) | u v. u \\<in> k \\<and> (v, u) \\<in> E}\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?SOG = \"\\<lambda>u. (\\<Sum>e \\<in> outgoing u. f e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?SIN = \"\\<lambda>u. (\\<Sum>e \\<in> incoming u. f e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?SOG' = \"(\\<Sum>e \\<in> outgoing' k. f e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "let ?SIN' = \"(\\<Sum>e \\<in> incoming' k. f e)\""], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "text \\<open>Some setup to make finiteness reasoning implicit\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. netFlow = val", "note [[simproc finite_Collect]]"], ["proof (state)\nthis:\n  TERM _\n\ngoal (1 subgoal):\n 1. netFlow = val", "have  \n    \"netFlow = ?SOG' + (\\<Sum>e \\<in> ?LCL. f e) - (?SIN' + (\\<Sum>e \\<in> ?LCL. f e))\" \n    (is \"_   =        ?SAOG              -          ?SAIN\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. netFlow =\n    sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} -\n    (sum f (incoming' k) +\n     sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})", "using netFlow_def"], ["proof (prove)\nusing this:\n  netFlow \\<equiv> sum f (outgoing' k) - sum f (incoming' k)\n\ngoal (1 subgoal):\n 1. netFlow =\n    sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} -\n    (sum f (incoming' k) +\n     sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})", "by auto"], ["proof (state)\nthis:\n  netFlow =\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} -\n  (sum f (incoming' k) +\n   sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. netFlow = val", "also"], ["proof (state)\nthis:\n  netFlow =\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} -\n  (sum f (incoming' k) +\n   sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. netFlow = val", "have \"?SAOG = (\\<Sum>y \\<in> k - {s}. ?SOG y) + ?SOG s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "have \"?SAOG = (\\<Sum>e\\<in>(outgoing' k \\<union> ?LCL). f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    sum f\n     (outgoing' k \\<union>\n      {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})", "by (rule sum.union_disjoint[symmetric]) (auto simp: outgoing'_def)"], ["proof (state)\nthis:\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  sum f\n   (outgoing' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "also"], ["proof (state)\nthis:\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  sum f\n   (outgoing' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "have \"outgoing' k \\<union> ?LCL = (\\<Union>y\\<in>k-{s}. outgoing y) \\<union> outgoing s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outgoing' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    \\<Union> (outgoing ` (k - {s})) \\<union> outgoing s", "by (auto simp: outgoing_def outgoing'_def s_in_cut)"], ["proof (state)\nthis:\n  outgoing' k \\<union>\n  {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  \\<Union> (outgoing ` (k - {s})) \\<union> outgoing s\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "also"], ["proof (state)\nthis:\n  outgoing' k \\<union>\n  {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  \\<Union> (outgoing ` (k - {s})) \\<union> outgoing s\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "have \"(\\<Sum>e\\<in>(\\<Union>(outgoing ` (k - {s})) \\<union> outgoing s). f e) \n      = (\\<Sum>e\\<in>(\\<Union>(outgoing ` (k - {s}))). f e) + (\\<Sum>e\\<in>outgoing s. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union> (outgoing ` (k - {s})) \\<union> outgoing s) =\n    sum f (\\<Union> (outgoing ` (k - {s}))) + sum f (outgoing s)", "by (rule sum.union_disjoint) \n         (auto simp: outgoing_def intro: finite_Image)"], ["proof (state)\nthis:\n  sum f (\\<Union> (outgoing ` (k - {s})) \\<union> outgoing s) =\n  sum f (\\<Union> (outgoing ` (k - {s}))) + sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "also"], ["proof (state)\nthis:\n  sum f (\\<Union> (outgoing ` (k - {s})) \\<union> outgoing s) =\n  sum f (\\<Union> (outgoing ` (k - {s}))) + sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "have \"(\\<Sum>e\\<in>(\\<Union>(outgoing ` (k - {s}))). f e) \n      = (\\<Sum>y \\<in> k - {s}. ?SOG y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union> (outgoing ` (k - {s}))) =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y))", "by (rule sum.UNION_disjoint)\n         (auto simp: outgoing_def intro: finite_Image)"], ["proof (state)\nthis:\n  sum f (\\<Union> (outgoing ` (k - {s}))) =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y))\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "finally"], ["proof (chain)\npicking this:\n  sum f (outgoing' k) +\n  sum f\n   {a. case a of\n       (u, v) \\<Rightarrow>\n         u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f (outgoing' k) +\n  sum f\n   {a. case a of\n       (u, v) \\<Rightarrow>\n         u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)", "."], ["proof (state)\nthis:\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. netFlow = val", "also"], ["proof (state)\nthis:\n  sum f (outgoing' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. netFlow = val", "have \"?SAIN = (\\<Sum>y \\<in> k - {s}. ?SIN y) + ?SIN s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "have \"?SAIN = (\\<Sum>e\\<in>(incoming' k \\<union> ?LCL). f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    sum f\n     (incoming' k \\<union>\n      {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})", "by (rule sum.union_disjoint[symmetric]) (auto simp: incoming'_def)"], ["proof (state)\nthis:\n  sum f (incoming' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  sum f\n   (incoming' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "also"], ["proof (state)\nthis:\n  sum f (incoming' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  sum f\n   (incoming' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E})\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "have \"incoming' k \\<union> ?LCL = (\\<Union>y\\<in>k-{s}. incoming y) \\<union> incoming s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incoming' k \\<union>\n    {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    \\<Union> (incoming ` (k - {s})) \\<union> incoming s", "by (auto simp: incoming_def incoming'_def s_in_cut)"], ["proof (state)\nthis:\n  incoming' k \\<union>\n  {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  \\<Union> (incoming ` (k - {s})) \\<union> incoming s\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "also"], ["proof (state)\nthis:\n  incoming' k \\<union>\n  {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  \\<Union> (incoming ` (k - {s})) \\<union> incoming s\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "have \"(\\<Sum>e\\<in>(\\<Union>(incoming ` (k - {s})) \\<union> incoming s). f e) \n      = (\\<Sum>e\\<in>(\\<Union>(incoming ` (k - {s}))). f e) + (\\<Sum>e\\<in>incoming s. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union> (incoming ` (k - {s})) \\<union> incoming s) =\n    sum f (\\<Union> (incoming ` (k - {s}))) + sum f (incoming s)", "by (rule sum.union_disjoint) \n         (auto simp: incoming_def intro: finite_Image)"], ["proof (state)\nthis:\n  sum f (\\<Union> (incoming ` (k - {s})) \\<union> incoming s) =\n  sum f (\\<Union> (incoming ` (k - {s}))) + sum f (incoming s)\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "also"], ["proof (state)\nthis:\n  sum f (\\<Union> (incoming ` (k - {s})) \\<union> incoming s) =\n  sum f (\\<Union> (incoming ` (k - {s}))) + sum f (incoming s)\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "have \"(\\<Sum>e\\<in>(\\<Union>(incoming ` (k - {s}))). f e) \n      = (\\<Sum>y \\<in> k - {s}. ?SIN y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (\\<Union> (incoming ` (k - {s}))) =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y))", "by (rule sum.UNION_disjoint)\n         (auto simp: incoming_def intro: finite_Image)"], ["proof (state)\nthis:\n  sum f (\\<Union> (incoming ` (k - {s}))) =\n  (\\<Sum>y\\<in>k - {s}. sum f (incoming y))\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "finally"], ["proof (chain)\npicking this:\n  sum f (incoming' k) +\n  sum f\n   {a. case a of\n       (u, v) \\<Rightarrow>\n         u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f (incoming' k) +\n  sum f\n   {a. case a of\n       (u, v) \\<Rightarrow>\n         u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)\n\ngoal (1 subgoal):\n 1. sum f (incoming' k) +\n    sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n    (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)", "."], ["proof (state)\nthis:\n  sum f (incoming' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum f (incoming' k) +\n  sum f {(u, v). u \\<in> k \\<and> v \\<in> k \\<and> (u, v) \\<in> E} =\n  (\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)\n\ngoal (1 subgoal):\n 1. netFlow = val", "finally"], ["proof (chain)\npicking this:\n  netFlow =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s))", "have \"netFlow =  \n      ((\\<Sum>y \\<in> k - {s}. ?SOG y) + ?SOG s) \n    - ((\\<Sum>y \\<in> k - {s}. ?SIN y) + ?SIN s)\"\n    (is \"netFlow = ?R\")"], ["proof (prove)\nusing this:\n  netFlow =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s))\n\ngoal (1 subgoal):\n 1. netFlow =\n    (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n    ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s))", "."], ["proof (state)\nthis:\n  netFlow =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s))\n\ngoal (1 subgoal):\n 1. netFlow = val", "also"], ["proof (state)\nthis:\n  netFlow =\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s))\n\ngoal (1 subgoal):\n 1. netFlow = val", "have \"?R = ?SOG s - ?SIN s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n    ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n    sum f (outgoing s) - sum f (incoming s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n    ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n    sum f (outgoing s) - sum f (incoming s)", "have \"(\\<And>u. u \\<in> k - {s} \\<Longrightarrow> ?SOG u = ?SIN u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> k - {s} \\<Longrightarrow>\n       sum f (outgoing u) = sum f (incoming u)", "using conservation_const cut_ss_V t_ni_cut"], ["proof (prove)\nusing this:\n  \\<forall>v\\<in>V - {s, t}. sum f (incoming v) = sum f (outgoing v)\n  k \\<subseteq> V\n  t \\<notin> k\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> k - {s} \\<Longrightarrow>\n       sum f (outgoing u) = sum f (incoming u)", "by force"], ["proof (state)\nthis:\n  ?u \\<in> k - {s} \\<Longrightarrow>\n  sum f (outgoing ?u) = sum f (incoming ?u)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n    ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n    sum f (outgoing s) - sum f (incoming s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?u \\<in> k - {s} \\<Longrightarrow>\n  sum f (outgoing ?u) = sum f (incoming ?u)\n\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n    ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n    sum f (outgoing s) - sum f (incoming s)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n  sum f (outgoing s) - sum f (incoming s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>y\\<in>k - {s}. sum f (outgoing y)) + sum f (outgoing s) -\n  ((\\<Sum>y\\<in>k - {s}. sum f (incoming y)) + sum f (incoming s)) =\n  sum f (outgoing s) - sum f (incoming s)\n\ngoal (1 subgoal):\n 1. netFlow = val", "finally"], ["proof (chain)\npicking this:\n  netFlow = sum f (outgoing s) - sum f (incoming s)", "show ?thesis"], ["proof (prove)\nusing this:\n  netFlow = sum f (outgoing s) - sum f (incoming s)\n\ngoal (1 subgoal):\n 1. netFlow = val", "unfolding val_def"], ["proof (prove)\nusing this:\n  netFlow = sum f (outgoing s) - sum f (incoming s)\n\ngoal (1 subgoal):\n 1. netFlow = sum f (outgoing s) - sum f (incoming s)", "by simp"], ["proof (state)\nthis:\n  netFlow = val\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The value of any flow is bounded by the capacity of any cut.\n  This is intuitively clear, as all flow from the source to the sink has to go\n  over the cut.\\<close>"], ["", "corollary weak_duality: \"val \\<le> cap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val \\<le> cap", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. val \\<le> cap", "have \"(\\<Sum>e \\<in> outgoing' k. f e) \\<le> (\\<Sum>e \\<in> outgoing' k. c e)\" (is \"?L \\<le> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (outgoing' k) \\<le> sum c (outgoing' k)", "using capacity_const"], ["proof (prove)\nusing this:\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) \\<le> sum c (outgoing' k)", "by (metis sum_mono)"], ["proof (state)\nthis:\n  sum f (outgoing' k) \\<le> sum c (outgoing' k)\n\ngoal (1 subgoal):\n 1. val \\<le> cap", "then"], ["proof (chain)\npicking this:\n  sum f (outgoing' k) \\<le> sum c (outgoing' k)", "have \"(\\<Sum>e \\<in> outgoing' k. f e) \\<le> cap\""], ["proof (prove)\nusing this:\n  sum f (outgoing' k) \\<le> sum c (outgoing' k)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) \\<le> cap", "unfolding cap_def"], ["proof (prove)\nusing this:\n  sum f (outgoing' k) \\<le> sum c (outgoing' k)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' k) \\<le> sum c (outgoing' k)", "by simp"], ["proof (state)\nthis:\n  sum f (outgoing' k) \\<le> cap\n\ngoal (1 subgoal):\n 1. val \\<le> cap", "moreover"], ["proof (state)\nthis:\n  sum f (outgoing' k) \\<le> cap\n\ngoal (1 subgoal):\n 1. val \\<le> cap", "have \"val \\<le> (\\<Sum>e \\<in> outgoing' k. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val \\<le> sum f (outgoing' k)", "using netFlow_def"], ["proof (prove)\nusing this:\n  netFlow \\<equiv> sum f (outgoing' k) - sum f (incoming' k)\n\ngoal (1 subgoal):\n 1. val \\<le> sum f (outgoing' k)", "by (simp add: capacity_const flow_value sum_nonneg)"], ["proof (state)\nthis:\n  val \\<le> sum f (outgoing' k)\n\ngoal (1 subgoal):\n 1. val \\<le> cap", "ultimately"], ["proof (chain)\npicking this:\n  sum f (outgoing' k) \\<le> cap\n  val \\<le> sum f (outgoing' k)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f (outgoing' k) \\<le> cap\n  val \\<le> sum f (outgoing' k)\n\ngoal (1 subgoal):\n 1. val \\<le> cap", "by simp"], ["proof (state)\nthis:\n  val \\<le> cap\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Cut\\<close>"], ["", "subsection \\<open>Ford-Fulkerson Theorem\\<close>"], ["", "context NFlow begin"], ["", "text \\<open>We prove three auxiliary lemmas first, and the state the theorem as a corollary\\<close>"], ["", "lemma fofu_I_II: \"isMaxFlow f \\<Longrightarrow> \\<not> (\\<exists> p. isAugmentingPath p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f \\<Longrightarrow> \\<not> Ex isAugmentingPath", "unfolding isMaxFlow_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t f \\<and>\n    (\\<forall>f'.\n        NFlow c s t f' \\<longrightarrow>\n        Flow.val c s f' \\<le> val) \\<Longrightarrow>\n    \\<not> Ex isAugmentingPath", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "assume asm: \"NFlow c s t f \n    \\<and> (\\<forall>f'. NFlow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> Flow.val c s f)\""], ["proof (state)\nthis:\n  NFlow c s t f \\<and>\n  (\\<forall>f'. NFlow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> val)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "assume asm_c: \"\\<not> \\<not> (\\<exists> p. isAugmentingPath p)\""], ["proof (state)\nthis:\n  \\<not> \\<not> Ex isAugmentingPath\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<not> Ex isAugmentingPath", "obtain p where obt: \"isAugmentingPath p\""], ["proof (prove)\nusing this:\n  \\<not> \\<not> Ex isAugmentingPath\n\ngoal (1 subgoal):\n 1. (\\<And>p. isAugmentingPath p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  isAugmentingPath p\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "have fct1: \"Flow cf s t (augmentingFlow p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Flow cf s t (augmentingFlow p)", "using obt augFlow_resFlow"], ["proof (prove)\nusing this:\n  isAugmentingPath p\n  isAugmentingPath ?p \\<Longrightarrow> Flow cf s t (augmentingFlow ?p)\n\ngoal (1 subgoal):\n 1. Flow cf s t (augmentingFlow p)", "by auto"], ["proof (state)\nthis:\n  Flow cf s t (augmentingFlow p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "have fct2: \"Flow.val cf s (augmentingFlow p) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (0::'capacity) < Flow.val cf s (augmentingFlow p)", "using obt augFlow_val\n    resCap_gzero isAugmentingPath_def cf.isSimplePath_def"], ["proof (prove)\nusing this:\n  isAugmentingPath p\n  isAugmentingPath ?p \\<Longrightarrow>\n  Flow.val cf s (augmentingFlow ?p) = resCap ?p\n  isAugmentingPath ?p \\<Longrightarrow> (0::'capacity) < resCap ?p\n  isAugmentingPath ?p \\<equiv> cf.isSimplePath s ?p t\n  cf.isSimplePath ?u ?p ?v \\<equiv>\n  cf.isPath ?u ?p ?v \\<and> distinct (cf.pathVertices ?u ?p)\n\ngoal (1 subgoal):\n 1. (0::'capacity) < Flow.val cf s (augmentingFlow p)", "by auto"], ["proof (state)\nthis:\n  (0::'capacity) < Flow.val cf s (augmentingFlow p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "have \"NFlow c s t (augment (augmentingFlow p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "using fct1 augment_flow_presv Network_axioms"], ["proof (prove)\nusing this:\n  Flow cf s t (augmentingFlow p)\n  Flow cf s t ?f' \\<Longrightarrow> Flow c s t (augment ?f')\n  Network c s t\n\ngoal (1 subgoal):\n 1. NFlow c s t (augment (augmentingFlow p))", "unfolding Flow_def NFlow_def NPreflow_def"], ["proof (prove)\nusing this:\n  Preflow cf s t (augmentingFlow p) \\<and>\n  Flow_axioms cf s t (augmentingFlow p)\n  Preflow cf s t ?f' \\<and> Flow_axioms cf s t ?f' \\<Longrightarrow>\n  Preflow c s t (augment ?f') \\<and> Flow_axioms c s t (augment ?f')\n  Network c s t\n\ngoal (1 subgoal):\n 1. (Network c s t \\<and> Preflow c s t (augment (augmentingFlow p))) \\<and>\n    Preflow c s t (augment (augmentingFlow p)) \\<and>\n    Flow_axioms c s t (augment (augmentingFlow p))", "by auto"], ["proof (state)\nthis:\n  NFlow c s t (augment (augmentingFlow p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  NFlow c s t (augment (augmentingFlow p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "have \"Flow.val c s (augment (augmentingFlow p)) > val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val < Flow.val c s (augment (augmentingFlow p))", "using fct1 fct2 augment_flow_value"], ["proof (prove)\nusing this:\n  Flow cf s t (augmentingFlow p)\n  (0::'capacity) < Flow.val cf s (augmentingFlow p)\n  Flow cf s t ?f' \\<Longrightarrow>\n  Flow.val c s (augment ?f') = val + Flow.val cf s ?f'\n\ngoal (1 subgoal):\n 1. val < Flow.val c s (augment (augmentingFlow p))", "by auto"], ["proof (state)\nthis:\n  val < Flow.val c s (augment (augmentingFlow p))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>NFlow c s t f \\<and>\n             (\\<forall>f'.\n                 NFlow c s t f' \\<longrightarrow>\n                 Flow.val c s f' \\<le> val);\n     \\<not> \\<not> Ex isAugmentingPath\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  NFlow c s t (augment (augmentingFlow p))\n  val < Flow.val c s (augment (augmentingFlow p))", "show \"False\""], ["proof (prove)\nusing this:\n  NFlow c s t (augment (augmentingFlow p))\n  val < Flow.val c s (augment (augmentingFlow p))\n\ngoal (1 subgoal):\n 1. False", "using asm"], ["proof (prove)\nusing this:\n  NFlow c s t (augment (augmentingFlow p))\n  val < Flow.val c s (augment (augmentingFlow p))\n  NFlow c s t f \\<and>\n  (\\<forall>f'. NFlow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> val)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fofu_II_III: \n  \"\\<not> (\\<exists> p. isAugmentingPath p) \\<Longrightarrow> \\<exists>k'. NCut c s t k' \\<and> val = NCut.cap c k'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow>\n    \\<exists>k'. NCut c s t k' \\<and> val = NCut.cap c k'", "proof (intro exI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> NCut c s t ?k'\n 2. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = NCut.cap c ?k'", "let ?S = \"cf.reachableNodes s\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> NCut c s t ?k'\n 2. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = NCut.cap c ?k'", "assume asm: \"\\<not> (\\<exists> p. isAugmentingPath p)\""], ["proof (state)\nthis:\n  \\<not> Ex isAugmentingPath\n\ngoal (2 subgoals):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> NCut c s t ?k'\n 2. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = NCut.cap c ?k'", "hence \"t\\<notin>?S\""], ["proof (prove)\nusing this:\n  \\<not> Ex isAugmentingPath\n\ngoal (1 subgoal):\n 1. t \\<notin> cf.reachableNodes s", "unfolding isAugmentingPath_def cf.reachableNodes_def cf.connected_def"], ["proof (prove)\nusing this:\n  \\<nexists>p. cf.isSimplePath s p t\n\ngoal (1 subgoal):\n 1. t \\<notin> {v. \\<exists>p. cf.isPath s p v}", "by (auto dest: cf.isSPath_pathLE)"], ["proof (state)\nthis:\n  t \\<notin> cf.reachableNodes s\n\ngoal (2 subgoals):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> NCut c s t ?k'\n 2. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = NCut.cap c ?k'", "then"], ["proof (chain)\npicking this:\n  t \\<notin> cf.reachableNodes s", "show CUT: \"NCut c s t ?S\""], ["proof (prove)\nusing this:\n  t \\<notin> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. NCut c s t (cf.reachableNodes s)", "proof unfold_locales"], ["proof (state)\ngoal (3 subgoals):\n 1. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    cf.reachableNodes s \\<subseteq> V\n 2. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    s \\<in> cf.reachableNodes s\n 3. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    t \\<notin> cf.reachableNodes s", "show \"Graph.reachableNodes cf s \\<subseteq> V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cf.reachableNodes s \\<subseteq> V", "using cf.reachable_ss_V s_node resV_netV"], ["proof (prove)\nusing this:\n  ?s \\<in> cf.V \\<Longrightarrow> cf.reachableNodes ?s \\<subseteq> cf.V\n  s \\<in> V\n  cf.V = V\n\ngoal (1 subgoal):\n 1. cf.reachableNodes s \\<subseteq> V", "by auto"], ["proof (state)\nthis:\n  cf.reachableNodes s \\<subseteq> V\n\ngoal (2 subgoals):\n 1. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    s \\<in> cf.reachableNodes s\n 2. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    t \\<notin> cf.reachableNodes s", "show \"s \\<in> Graph.reachableNodes cf s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> cf.reachableNodes s", "unfolding Graph.reachableNodes_def Graph.connected_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> {v. \\<exists>p. cf.isPath s p v}", "by (metis Graph.isPath.simps(1) mem_Collect_eq)"], ["proof (state)\nthis:\n  s \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. t \\<notin> cf.reachableNodes s \\<Longrightarrow>\n    t \\<notin> cf.reachableNodes s", "qed"], ["proof (state)\nthis:\n  NCut c s t (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow>\n    val = NCut.cap c (cf.reachableNodes s)", "then"], ["proof (chain)\npicking this:\n  NCut c s t (cf.reachableNodes s)", "interpret NCut c s t ?S"], ["proof (prove)\nusing this:\n  NCut c s t (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. NCut c s t (cf.reachableNodes s)", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "interpret NFlowCut c s t f ?S"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlowCut c s t f (cf.reachableNodes s)", "by intro_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "have \"\\<forall>(u,v)\\<in>outgoing' ?S. f (u,v) = c (u,v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>outgoing' (cf.reachableNodes s). f (u, v) = c (u, v)", "proof (rule ballI, rule ccontr, clarify) \\<comment> \\<open>Proof by contradiction\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(u,v)\\<in>outgoing' ?S\""], ["proof (state)\nthis:\n  (u, v) \\<in> outgoing' (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u,v)\\<in>E\" \"u\\<in>?S\" \"v\\<notin>?S\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> outgoing' (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E &&&\n    u \\<in> cf.reachableNodes s &&& v \\<notin> cf.reachableNodes s", "by (auto simp: outgoing'_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  u \\<in> cf.reachableNodes s\n  v \\<notin> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"f (u,v) \\<noteq> c (u,v)\""], ["proof (state)\nthis:\n  f (u, v) \\<noteq> c (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"f (u,v) < c (u,v)\""], ["proof (prove)\nusing this:\n  f (u, v) \\<noteq> c (u, v)\n\ngoal (1 subgoal):\n 1. f (u, v) < c (u, v)", "using capacity_const"], ["proof (prove)\nusing this:\n  f (u, v) \\<noteq> c (u, v)\n  \\<forall>e. (0::'capacity) \\<le> f e \\<and> f e \\<le> c e\n\ngoal (1 subgoal):\n 1. f (u, v) < c (u, v)", "by (metis (no_types) eq_iff not_le)"], ["proof (state)\nthis:\n  f (u, v) < c (u, v)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"cf (u, v) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f (u, v) < c (u, v)\n\ngoal (1 subgoal):\n 1. cf (u, v) \\<noteq> (0::'capacity)", "unfolding residualGraph_def"], ["proof (prove)\nusing this:\n  f (u, v) < c (u, v)\n\ngoal (1 subgoal):\n 1. (case (u, v) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> E then c (u, v) - f (u, v)\n       else if (v, u) \\<in> E then f (v, u) else (0::'capacity)) \\<noteq>\n    (0::'capacity)", "using \\<open>(u,v)\\<in>E\\<close>"], ["proof (prove)\nusing this:\n  f (u, v) < c (u, v)\n  (u, v) \\<in> E\n\ngoal (1 subgoal):\n 1. (case (u, v) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> E then c (u, v) - f (u, v)\n       else if (v, u) \\<in> E then f (v, u) else (0::'capacity)) \\<noteq>\n    (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  cf (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u, v) \\<in> cf.E\""], ["proof (prove)\nusing this:\n  cf (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> cf.E", "unfolding cf.E_def"], ["proof (prove)\nusing this:\n  cf (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> {(u, v). cf (u, v) \\<noteq> (0::'capacity)}", "by simp"], ["proof (state)\nthis:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"v\\<in>?S\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. v \\<in> cf.reachableNodes s", "using \\<open>u\\<in>?S\\<close>"], ["proof (prove)\nusing this:\n  (u, v) \\<in> cf.E\n  u \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. v \\<in> cf.reachableNodes s", "by (auto intro: cf.reachableNodes_append_edge)"], ["proof (state)\nthis:\n  v \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> outgoing' (cf.reachableNodes s);\n        f (a, b) \\<noteq> c (a, b)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  v \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. False", "using \\<open>v\\<notin>?S\\<close>"], ["proof (prove)\nusing this:\n  v \\<in> cf.reachableNodes s\n  v \\<notin> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>outgoing' (cf.reachableNodes s). f (u, v) = c (u, v)\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "hence \"(\\<Sum>e \\<in> outgoing' ?S. f e) = cap\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>outgoing' (cf.reachableNodes s). f (u, v) = c (u, v)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' (cf.reachableNodes s)) = cap", "unfolding cap_def"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>outgoing' (cf.reachableNodes s). f (u, v) = c (u, v)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' (cf.reachableNodes s)) =\n    sum c (outgoing' (cf.reachableNodes s))", "by auto"], ["proof (state)\nthis:\n  sum f (outgoing' (cf.reachableNodes s)) = cap\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "moreover"], ["proof (state)\nthis:\n  sum f (outgoing' (cf.reachableNodes s)) = cap\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "have \"\\<forall>(u,v)\\<in>incoming' ?S. f (u,v) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(u, v)\\<in>incoming' (cf.reachableNodes s).\n       f (u, v) = (0::'capacity)", "proof (rule ballI, rule ccontr, clarify) \\<comment> \\<open>Proof by contradiction\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "fix u v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"(u,v)\\<in>incoming' ?S\""], ["proof (state)\nthis:\n  (u, v) \\<in> incoming' (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(u,v)\\<in>E\" \"u\\<notin>?S\" \"v\\<in>?S\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> incoming' (cf.reachableNodes s)\n\ngoal (1 subgoal):\n 1. (u, v) \\<in> E &&&\n    u \\<notin> cf.reachableNodes s &&& v \\<in> cf.reachableNodes s", "by (auto simp: incoming'_def)"], ["proof (state)\nthis:\n  (u, v) \\<in> E\n  u \\<notin> cf.reachableNodes s\n  v \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(v,u)\\<notin>E\""], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  u \\<notin> cf.reachableNodes s\n  v \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. (v, u) \\<notin> E", "using no_parallel_edge"], ["proof (prove)\nusing this:\n  (u, v) \\<in> E\n  u \\<notin> cf.reachableNodes s\n  v \\<in> cf.reachableNodes s\n  \\<forall>u v. (u, v) \\<in> E \\<longrightarrow> (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (v, u) \\<notin> E", "by auto"], ["proof (state)\nthis:\n  (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"f (u,v) \\<noteq> 0\""], ["proof (state)\nthis:\n  f (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"cf (v, u) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  f (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. cf (v, u) \\<noteq> (0::'capacity)", "unfolding residualGraph_def"], ["proof (prove)\nusing this:\n  f (u, v) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (case (v, u) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> E then c (u, v) - f (u, v)\n       else if (v, u) \\<in> E then f (v, u) else (0::'capacity)) \\<noteq>\n    (0::'capacity)", "using \\<open>(u,v)\\<in>E\\<close> \\<open>(v,u)\\<notin>E\\<close>"], ["proof (prove)\nusing this:\n  f (u, v) \\<noteq> (0::'capacity)\n  (u, v) \\<in> E\n  (v, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. (case (v, u) of\n     (u, v) \\<Rightarrow>\n       if (u, v) \\<in> E then c (u, v) - f (u, v)\n       else if (v, u) \\<in> E then f (v, u) else (0::'capacity)) \\<noteq>\n    (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  cf (v, u) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"(v, u) \\<in> cf.E\""], ["proof (prove)\nusing this:\n  cf (v, u) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> cf.E", "unfolding cf.E_def"], ["proof (prove)\nusing this:\n  cf (v, u) \\<noteq> (0::'capacity)\n\ngoal (1 subgoal):\n 1. (v, u) \\<in> {(u, v). cf (u, v) \\<noteq> (0::'capacity)}", "by simp"], ["proof (state)\nthis:\n  (v, u) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"u\\<in>?S\""], ["proof (prove)\nusing this:\n  (v, u) \\<in> cf.E\n\ngoal (1 subgoal):\n 1. u \\<in> cf.reachableNodes s", "using \\<open>v\\<in>?S\\<close> cf.reachableNodes_append_edge"], ["proof (prove)\nusing this:\n  (v, u) \\<in> cf.E\n  v \\<in> cf.reachableNodes s\n  \\<lbrakk>?u \\<in> cf.reachableNodes ?s; (?u, ?v) \\<in> cf.E\\<rbrakk>\n  \\<Longrightarrow> ?v \\<in> cf.reachableNodes ?s\n\ngoal (1 subgoal):\n 1. u \\<in> cf.reachableNodes s", "by auto"], ["proof (state)\nthis:\n  u \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(a, b) \\<in> incoming' (cf.reachableNodes s);\n        f (a, b) \\<noteq> (0::'capacity)\\<rbrakk>\n       \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  u \\<in> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. False", "using \\<open>u\\<notin>?S\\<close>"], ["proof (prove)\nusing this:\n  u \\<in> cf.reachableNodes s\n  u \\<notin> cf.reachableNodes s\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>(u, v)\\<in>incoming' (cf.reachableNodes s).\n     f (u, v) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "hence \"(\\<Sum>e \\<in> incoming' ?S. f e) = 0\""], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>incoming' (cf.reachableNodes s).\n     f (u, v) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)", "unfolding cap_def"], ["proof (prove)\nusing this:\n  \\<forall>(u, v)\\<in>incoming' (cf.reachableNodes s).\n     f (u, v) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)", "by auto"], ["proof (state)\nthis:\n  sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. \\<not> Ex isAugmentingPath \\<Longrightarrow> val = cap", "ultimately"], ["proof (chain)\npicking this:\n  sum f (outgoing' (cf.reachableNodes s)) = cap\n  sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)", "show \"val = cap\""], ["proof (prove)\nusing this:\n  sum f (outgoing' (cf.reachableNodes s)) = cap\n  sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. val = cap", "unfolding flow_value[symmetric] netFlow_def"], ["proof (prove)\nusing this:\n  sum f (outgoing' (cf.reachableNodes s)) = cap\n  sum f (incoming' (cf.reachableNodes s)) = (0::'capacity)\n\ngoal (1 subgoal):\n 1. sum f (outgoing' (cf.reachableNodes s)) -\n    sum f (incoming' (cf.reachableNodes s)) =\n    cap", "by simp"], ["proof (state)\nthis:\n  val = cap\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fofu_III_I: \n  \"\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k \\<Longrightarrow> isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>k. NCut c s t k \\<and> val = NCut.cap c k \\<Longrightarrow>\n    isMaxFlow f", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "fix k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "assume \"NCut c s t k\""], ["proof (state)\nthis:\n  NCut c s t k\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "then"], ["proof (chain)\npicking this:\n  NCut c s t k", "interpret NCut c s t k"], ["proof (prove)\nusing this:\n  NCut c s t k\n\ngoal (1 subgoal):\n 1. NCut c s t k", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "interpret NFlowCut c s t f k"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlowCut c s t f k", "by intro_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "assume \"val = cap\""], ["proof (state)\nthis:\n  val = cap\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "{"], ["proof (state)\nthis:\n  val = cap\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "assume \"Flow c s t f'\""], ["proof (state)\nthis:\n  Flow c s t f'\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "then"], ["proof (chain)\npicking this:\n  Flow c s t f'", "interpret fc': Flow c s t f'"], ["proof (prove)\nusing this:\n  Flow c s t f'\n\ngoal (1 subgoal):\n 1. Flow c s t f'", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "interpret fc': NFlowCut c s t f' k"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlowCut c s t f' k", "by intro_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "have \"fc'.val \\<le> cap\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fc'.val \\<le> cap", "using fc'.weak_duality"], ["proof (prove)\nusing this:\n  fc'.val \\<le> cap\n\ngoal (1 subgoal):\n 1. fc'.val \\<le> cap", "."], ["proof (state)\nthis:\n  fc'.val \\<le> cap\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "also"], ["proof (state)\nthis:\n  fc'.val \\<le> cap\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "note \\<open>val = cap\\<close>[symmetric]"], ["proof (state)\nthis:\n  cap = val\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "finally"], ["proof (chain)\npicking this:\n  fc'.val \\<le> val", "have \"fc'.val \\<le> val\""], ["proof (prove)\nusing this:\n  fc'.val \\<le> val\n\ngoal (1 subgoal):\n 1. fc'.val \\<le> val", "."], ["proof (state)\nthis:\n  fc'.val \\<le> val\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "}"], ["proof (state)\nthis:\n  Flow c s t ?f'2 \\<Longrightarrow> Flow.val c s ?f'2 \\<le> val\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       \\<lbrakk>NCut c s t k; val = NCut.cap c k\\<rbrakk>\n       \\<Longrightarrow> isMaxFlow f", "thus \"isMaxFlow f\""], ["proof (prove)\nusing this:\n  Flow c s t ?f'2 \\<Longrightarrow> Flow.val c s ?f'2 \\<le> val\n\ngoal (1 subgoal):\n 1. isMaxFlow f", "unfolding isMaxFlow_def"], ["proof (prove)\nusing this:\n  Flow c s t ?f'2 \\<Longrightarrow> Flow.val c s ?f'2 \\<le> val\n\ngoal (1 subgoal):\n 1. Flow c s t f \\<and>\n    (\\<forall>f'. Flow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> val)", "by simp unfold_locales"], ["proof (state)\nthis:\n  isMaxFlow f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally we can state the Ford-Fulkerson theorem: \\<close>"], ["", "theorem ford_fulkerson: shows\n  \"isMaxFlow f \\<longleftrightarrow> \n  \\<not> Ex isAugmentingPath\" and \"\\<not> Ex isAugmentingPath \\<longleftrightarrow> \n  (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isMaxFlow f = (\\<not> Ex isAugmentingPath) &&&\n    (\\<not> Ex isAugmentingPath) =\n    (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)", "using fofu_I_II fofu_II_III fofu_III_I"], ["proof (prove)\nusing this:\n  isMaxFlow f \\<Longrightarrow> \\<not> Ex isAugmentingPath\n  \\<not> Ex isAugmentingPath \\<Longrightarrow>\n  \\<exists>k'. NCut c s t k' \\<and> val = NCut.cap c k'\n  \\<exists>k. NCut c s t k \\<and> val = NCut.cap c k \\<Longrightarrow>\n  isMaxFlow f\n\ngoal (1 subgoal):\n 1. isMaxFlow f = (\\<not> Ex isAugmentingPath) &&&\n    (\\<not> Ex isAugmentingPath) =\n    (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)", "by auto"], ["", "subsection \\<open>Corollaries\\<close>"], ["", "text \\<open>In this subsection we present a few corollaries of the \n  flow-cut relation and the Ford-Fulkerson theorem.\n\\<close>"], ["", "text \\<open>The outgoing flow of the source is the same as the incoming flow of \n  the sink. Intuitively, this means that no flow is generated or lost in the \n  network, except at the source and sink.\\<close>"], ["", "corollary inflow_t_outflow_s: \n  \"(\\<Sum>e \\<in> incoming t. f e) = (\\<Sum>e \\<in> outgoing s. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "txt \\<open>We choose a cut between the sink and all other nodes\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "let ?K = \"V - {t}\""], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "interpret NFlowCut c s t f ?K"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlowCut c s t f (V - {t})", "using s_node s_not_t"], ["proof (prove)\nusing this:\n  s \\<in> V\n  s \\<noteq> t\n\ngoal (1 subgoal):\n 1. NFlowCut c s t f (V - {t})", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "txt \\<open>The cut is chosen such that its outgoing edges are the incoming edges\n    to the sink, and its incoming edges are the outgoing edges from the sink.\n    Note that the sink has no outgoing edges.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "have \"outgoing' ?K = incoming t\"\n   and \"incoming' ?K = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. outgoing' (V - {t}) = incoming t &&& incoming' (V - {t}) = {}", "using no_self_loop no_outgoing_t"], ["proof (prove)\nusing this:\n  \\<forall>u. (u, u) \\<notin> E\n  \\<forall>u. (t, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. outgoing' (V - {t}) = incoming t &&& incoming' (V - {t}) = {}", "unfolding outgoing'_def incoming_def incoming'_def outgoing_def V_def"], ["proof (prove)\nusing this:\n  \\<forall>u. (u, u) \\<notin> E\n  \\<forall>u. (t, u) \\<notin> E\n\ngoal (1 subgoal):\n 1. {(v, u) |u v.\n     u \\<notin> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} -\n                {t} \\<and>\n     v \\<in> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} -\n             {t} \\<and>\n     (v, u) \\<in> E} =\n    {(u, t) |u. (u, t) \\<in> E} &&&\n    {(u, v) |u v.\n     u \\<notin> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} -\n                {t} \\<and>\n     v \\<in> {u. \\<exists>v. (u, v) \\<in> E \\<or> (v, u) \\<in> E} -\n             {t} \\<and>\n     (u, v) \\<in> E} =\n    {}", "by auto"], ["proof (state)\nthis:\n  outgoing' (V - {t}) = incoming t\n  incoming' (V - {t}) = {}\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "hence \"(\\<Sum>e \\<in> incoming t. f e) = netFlow\""], ["proof (prove)\nusing this:\n  outgoing' (V - {t}) = incoming t\n  incoming' (V - {t}) = {}\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = netFlow", "unfolding netFlow_def"], ["proof (prove)\nusing this:\n  outgoing' (V - {t}) = incoming t\n  incoming' (V - {t}) = {}\n\ngoal (1 subgoal):\n 1. sum f (incoming t) =\n    sum f (outgoing' (V - {t})) - sum f (incoming' (V - {t}))", "by auto"], ["proof (state)\nthis:\n  sum f (incoming t) = netFlow\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "also"], ["proof (state)\nthis:\n  sum f (incoming t) = netFlow\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "have \"netFlow = val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. netFlow = val", "by (rule flow_value)"], ["proof (state)\nthis:\n  netFlow = val\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "also"], ["proof (state)\nthis:\n  netFlow = val\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "have \"val = (\\<Sum>e \\<in> outgoing s. f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. val = sum f (outgoing s)", "by (auto simp: val_alt)"], ["proof (state)\nthis:\n  val = sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "finally"], ["proof (chain)\npicking this:\n  sum f (incoming t) = sum f (outgoing s)", "show ?thesis"], ["proof (prove)\nusing this:\n  sum f (incoming t) = sum f (outgoing s)\n\ngoal (1 subgoal):\n 1. sum f (incoming t) = sum f (outgoing s)", "."], ["proof (state)\nthis:\n  sum f (incoming t) = sum f (outgoing s)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As an immediate consequence of the Ford-Fulkerson theorem, we get that\n  there is no augmenting path if and only if the flow is maximal.\\<close>"], ["", "corollary noAugPath_iff_maxFlow: \"(\\<nexists>p. isAugmentingPath p) \\<longleftrightarrow> isMaxFlow f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> Ex isAugmentingPath) = isMaxFlow f", "using ford_fulkerson"], ["proof (prove)\nusing this:\n  isMaxFlow f = (\\<not> Ex isAugmentingPath)\n  (\\<not> Ex isAugmentingPath) =\n  (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)\n\ngoal (1 subgoal):\n 1. (\\<not> Ex isAugmentingPath) = isMaxFlow f", "by blast"], ["", "end \\<comment> \\<open>Network with flow\\<close>"], ["", "text \\<open>The value of the maximum flow equals the capacity of the minimum cut\\<close>"], ["", "corollary (in Network) maxFlow_minCut: \"\\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk> \n  \\<Longrightarrow> Flow.val c s f = NCut.cap c k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> Flow.val c s f = NCut.cap c k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> Flow.val c s f = NCut.cap c k", "assume \"isMaxFlow f\" \"isMinCut c s t k\""], ["proof (state)\nthis:\n  isMaxFlow f\n  isMinCut c s t k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> Flow.val c s f = NCut.cap c k", "then"], ["proof (chain)\npicking this:\n  isMaxFlow f\n  isMinCut c s t k", "interpret Flow c s t f + NCut c s t k"], ["proof (prove)\nusing this:\n  isMaxFlow f\n  isMinCut c s t k\n\ngoal (1 subgoal):\n 1. Flow c s t f &&& NCut c s t k", "unfolding isMaxFlow_def isMinCut_def"], ["proof (prove)\nusing this:\n  Flow c s t f \\<and>\n  (\\<forall>f'.\n      Flow c s t f' \\<longrightarrow> Flow.val c s f' \\<le> Flow.val c s f)\n  NCut c s t k \\<and>\n  (\\<forall>k'.\n      NCut c s t k' \\<longrightarrow> NCut.cap c k \\<le> NCut.cap c k')\n\ngoal (1 subgoal):\n 1. Flow c s t f &&& NCut c s t k", "by simp_all"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> val = cap", "interpret NFlowCut c s t f k"], ["proof (prove)\ngoal (1 subgoal):\n 1. NFlowCut c s t f k", "by intro_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> val = cap", "from ford_fulkerson \\<open>isMaxFlow f\\<close>"], ["proof (chain)\npicking this:\n  isMaxFlow f = (\\<not> Ex isAugmentingPath)\n  (\\<not> Ex isAugmentingPath) =\n  (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)\n  isMaxFlow f", "obtain k' where \"NCut c s t k'\" and \"val = NCut.cap c k'\""], ["proof (prove)\nusing this:\n  isMaxFlow f = (\\<not> Ex isAugmentingPath)\n  (\\<not> Ex isAugmentingPath) =\n  (\\<exists>k. NCut c s t k \\<and> val = NCut.cap c k)\n  isMaxFlow f\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        \\<lbrakk>NCut c s t k'; val = NCut.cap c k'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  NCut c s t k'\n  val = NCut.cap c k'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>isMaxFlow f; isMinCut c s t k\\<rbrakk>\n    \\<Longrightarrow> val = cap", "thus \"val = cap\""], ["proof (prove)\nusing this:\n  NCut c s t k'\n  val = NCut.cap c k'\n\ngoal (1 subgoal):\n 1. val = cap", "using \\<open>isMinCut c s t k\\<close> weak_duality"], ["proof (prove)\nusing this:\n  NCut c s t k'\n  val = NCut.cap c k'\n  isMinCut c s t k\n  val \\<le> cap\n\ngoal (1 subgoal):\n 1. val = cap", "unfolding isMinCut_def"], ["proof (prove)\nusing this:\n  NCut c s t k'\n  val = NCut.cap c k'\n  NCut c s t k \\<and>\n  (\\<forall>k'. NCut c s t k' \\<longrightarrow> cap \\<le> NCut.cap c k')\n  val \\<le> cap\n\ngoal (1 subgoal):\n 1. val = cap", "by auto"], ["proof (state)\nthis:\n  val = cap\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}