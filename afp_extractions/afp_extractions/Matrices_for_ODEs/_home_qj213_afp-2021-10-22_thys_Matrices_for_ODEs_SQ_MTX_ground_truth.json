{"file_name": "/home/qj213/afp-2021-10-22/thys/Matrices_for_ODEs/SQ_MTX.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Matrices_for_ODEs", "problem_names": ["lemma to_vec_eq_ith: \"(to_vec A) $ i = A $$ i\"", "lemma to_mtx_ith[simp]: \n  \"(to_mtx A) $$ i1 = A $ i1\"\n  \"(to_mtx A) $$ i1 $ i2 = A $ i1 $ i2\"", "lemma to_mtx_vec_lambda_ith[simp]: \"to_mtx (\\<chi> i j. x i j) $$ i1 $ i2 = x i1 i2\"", "lemma sq_mtx_eq_iff:\n  shows \"A = B = (\\<forall>i j. A $$ i $ j = B $$ i $ j)\"\n    and \"A = B = (\\<forall>i. A $$ i = B $$ i)\"", "lemma sq_mtx_diag_simps[simp]:\n  \"i = j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = f i\"\n  \"i \\<noteq> j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = 0\"\n  \"sq_mtx_diag f $$ i = axis i (f i)\"", "lemma sq_mtx_diag_vec_mult: \"(\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V s = (\\<chi> i. f i * s$i)\"", "lemma sq_mtx_vec_mult_diag_axis: \"(\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V (axis i k) = axis i (f i * k)\"", "lemma sq_mtx_vec_mult_eq: \"m *\\<^sub>V x = (\\<chi> i. sum (\\<lambda>j. (m $$ i $ j) * (x $ j)) UNIV)\"", "lemma sq_mtx_transpose_transpose[simp]: \"(A\\<^sup>\\<dagger>)\\<^sup>\\<dagger> = A\"", "lemma transpose_mult_vec_canon_row[simp]: \"(A\\<^sup>\\<dagger>) *\\<^sub>V (\\<e> i) = \\<r>\\<o>\\<w> i A\"", "lemma row_ith[simp]: \"\\<r>\\<o>\\<w> i A = A $$ i\"", "lemma mtx_vec_mult_canon: \"A *\\<^sub>V (\\<e> i) = \\<c>\\<o>\\<l> i A\"", "lemma sq_mtx_zero_ith[simp]: \"0 $$ i = 0\"", "lemma sq_mtx_zero_nth[simp]: \"0 $$ i $ j = 0\"", "lemma sq_mtx_plus_eq: \"A + B = to_mtx (\\<chi> i j. A$$i$j + B$$i$j)\"", "lemma sq_mtx_plus_ith[simp]:\"(A + B) $$ i = A $$ i + B $$ i\"", "lemma sq_mtx_uminus_eq: \"- A = to_mtx (\\<chi> i j. - A$$i$j)\"", "lemma sq_mtx_minus_eq: \"A - B = to_mtx (\\<chi> i j. A$$i$j - B$$i$j)\"", "lemma sq_mtx_minus_ith[simp]:\"(A - B) $$ i = A $$ i - B $$ i\"", "lemma sq_mtx_times_eq: \"A * B = to_mtx (\\<chi> i j. sum (\\<lambda>k. A$$i$k * B$$k$j) UNIV)\"", "lemma sq_mtx_plus_diag_diag[simp]: \"sq_mtx_diag f + sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i + g i)\"", "lemma sq_mtx_minus_diag_diag[simp]: \"sq_mtx_diag f - sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i - g i)\"", "lemma sum_sq_mtx_diag[simp]: \"(\\<Sum>n<m. sq_mtx_diag (g n)) = (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n<m. (g n i))\" for m::nat", "lemma sq_mtx_mult_diag_diag[simp]: \"sq_mtx_diag f * sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i * g i)\"", "lemma sq_mtx_mult_diagl: \"(\\<d>\\<i>\\<a>\\<g> i. f i) * A = to_mtx (\\<chi> i j. f i * A $$ i $ j)\"", "lemma sq_mtx_mult_diagr: \"A * (\\<d>\\<i>\\<a>\\<g> i. f i) = to_mtx (\\<chi> i j. A $$ i $ j * f j)\"", "lemma mtx_vec_mult_0l[simp]: \"0 *\\<^sub>V x = 0\"", "lemma mtx_vec_mult_0r[simp]: \"A *\\<^sub>V 0 = 0\"", "lemma mtx_vec_mult_add_rdistr: \"(A + B) *\\<^sub>V x = A *\\<^sub>V x + B *\\<^sub>V x\"", "lemma mtx_vec_mult_add_rdistl: \"A *\\<^sub>V (x + y) = A *\\<^sub>V x + A *\\<^sub>V y\"", "lemma mtx_vec_mult_minus_rdistrib: \"(A - B) *\\<^sub>V x = A *\\<^sub>V x - B *\\<^sub>V x\"", "lemma mtx_vec_mult_minus_ldistrib: \"A *\\<^sub>V (x - y) =  A *\\<^sub>V x -  A *\\<^sub>V y\"", "lemma sq_mtx_times_vec_assoc: \"(A * B) *\\<^sub>V x = A *\\<^sub>V (B *\\<^sub>V x)\"", "lemma sq_mtx_vec_mult_sum_cols: \"A *\\<^sub>V x = sum (\\<lambda>i. x $ i *\\<^sub>R \\<c>\\<o>\\<l> i A) UNIV\"", "lemma sq_mtx_scaleR_eq: \"c *\\<^sub>R A = to_mtx (\\<chi> i j. c *\\<^sub>R A $$ i $ j)\"", "lemma scaleR_to_mtx_ith[simp]: \"c *\\<^sub>R (to_mtx A) $$ i1 $ i2 = c * A $ i1 $ i2\"", "lemma sq_mtx_scaleR_ith[simp]: \"(c *\\<^sub>R A) $$ i = (c  *\\<^sub>R (A $$ i))\"", "lemma scaleR_sq_mtx_diag: \"c *\\<^sub>R sq_mtx_diag f = (\\<d>\\<i>\\<a>\\<g> i. c * f i)\"", "lemma scaleR_mtx_vec_assoc: \"(c *\\<^sub>R A) *\\<^sub>V x = c *\\<^sub>R (A *\\<^sub>V x)\"", "lemma mtx_vec_scaleR_commute: \"A *\\<^sub>V (c *\\<^sub>R x) = c *\\<^sub>R (A *\\<^sub>V x)\"", "lemma mtx_times_scaleR_commute: \"A * (c *\\<^sub>R B) = c *\\<^sub>R (A * B)\" for A::\"('n::finite) sq_mtx\"", "lemma le_mtx_norm: \"m \\<in> {\\<parallel>A *\\<^sub>V x\\<parallel> |x. \\<parallel>x\\<parallel> = 1} \\<Longrightarrow> m \\<le> \\<parallel>A\\<parallel>\"", "lemma norm_vec_mult_le: \"\\<parallel>A *\\<^sub>V x\\<parallel> \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>x\\<parallel>)\"", "lemma bounded_bilinear_sq_mtx_vec_mult: \"bounded_bilinear (\\<lambda>A s. A *\\<^sub>V s)\"", "lemma norm_sq_mtx_def2: \"\\<parallel>A\\<parallel> = Sup {\\<parallel>A *\\<^sub>V x\\<parallel> |x. \\<parallel>x\\<parallel> = 1}\"", "lemma norm_sq_mtx_def3: \"\\<parallel>A\\<parallel> = (SUP x. (\\<parallel>A *\\<^sub>V x\\<parallel>) / (\\<parallel>x\\<parallel>))\"", "lemma norm_sq_mtx_diag: \"\\<parallel>sq_mtx_diag f\\<parallel> = Max {\\<bar>f i\\<bar> |i. i \\<in> UNIV}\"", "lemma sq_mtx_norm_le_sum_col: \"\\<parallel>A\\<parallel> \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i A\\<parallel>)\"", "lemma norm_le_transpose: \"\\<parallel>A\\<parallel> \\<le> \\<parallel>A\\<^sup>\\<dagger>\\<parallel>\"", "lemma norm_eq_norm_transpose[simp]: \"\\<parallel>A\\<^sup>\\<dagger>\\<parallel> = \\<parallel>A\\<parallel>\"", "lemma norm_column_le_norm: \"\\<parallel>A $$ i\\<parallel> \\<le> \\<parallel>A\\<parallel>\"", "lemma sq_mtx_one_idty: \"1 * A = A\" \"A * 1 = A\" for A :: \"'a sq_mtx\"", "lemma sq_mtx_norm_1: \"\\<parallel>(1::'a sq_mtx)\\<parallel> = 1\"", "lemma sq_mtx_norm_times: \"\\<parallel>A * B\\<parallel> \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>B\\<parallel>)\" for A :: \"'a sq_mtx\"", "lemma sq_mtx_one_ith_simps[simp]: \"1 $$ i $ i = 1\" \"i \\<noteq> j \\<Longrightarrow> 1 $$ i $ j = 0\"", "lemma of_nat_eq_sq_mtx_diag[simp]: \"of_nat m = (\\<d>\\<i>\\<a>\\<g> i. m)\"", "lemma mtx_vec_mult_1[simp]: \"1 *\\<^sub>V s = s\"", "lemma sq_mtx_diag_one[simp]: \"(\\<d>\\<i>\\<a>\\<g> i. 1) = 1\"", "lemma mtx_invertible_def: \"mtx_invertible A \\<longleftrightarrow> (\\<exists>A'. A' * A = 1 \\<and> A * A' = 1)\"", "lemma mtx_invertibleI:\n  assumes \"A * B = 1\" and \"B * A = 1\"\n  shows \"mtx_invertible A\"", "lemma mtx_invertibleD[simp]:\n  assumes \"mtx_invertible A\" \n  shows \"A\\<^sup>-\\<^sup>1 * A = 1\" and \"A * A\\<^sup>-\\<^sup>1 = 1\"", "lemma mtx_invertible_inv[simp]: \"mtx_invertible A \\<Longrightarrow> mtx_invertible (A\\<^sup>-\\<^sup>1)\"", "lemma mtx_invertible_one[simp]: \"mtx_invertible 1\"", "lemma sq_mtx_inv_unique:\n  assumes \"A * B = 1\" and \"B * A = 1\"\n  shows \"A\\<^sup>-\\<^sup>1 = B\"", "lemma sq_mtx_inv_idempotent[simp]: \"mtx_invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A\"", "lemma sq_mtx_inv_mult:\n  assumes \"mtx_invertible A\" and \"mtx_invertible B\"\n  shows \"(A * B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 * A\\<^sup>-\\<^sup>1\"", "lemma sq_mtx_inv_one[simp]: \"1\\<^sup>-\\<^sup>1 = 1\"", "lemma similar_sq_mtx_matrix: \"(A \\<sim> B) = similar_matrix (to_vec A) (to_vec B)\"", "lemma similar_sq_mtx_refl[simp]: \"A \\<sim> A\"", "lemma similar_sq_mtx_simm: \"A \\<sim> B \\<Longrightarrow> B \\<sim> A\"", "lemma similar_sq_mtx_trans: \"A \\<sim> B \\<Longrightarrow> B \\<sim> C \\<Longrightarrow> A \\<sim> C\"", "lemma power_sq_mtx_diag: \"(sq_mtx_diag f)^n = (\\<d>\\<i>\\<a>\\<g> i. f i^n)\"", "lemma power_similiar_sq_mtx_diag_eq:\n  assumes \"mtx_invertible P\"\n      and \"A = P\\<^sup>-\\<^sup>1 * (sq_mtx_diag f) * P\"\n    shows \"A^n = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i^n) * P\"", "lemma power_similar_sq_mtx_diag:\n  assumes \"A \\<sim> (sq_mtx_diag f)\"\n  shows \"A^n \\<sim> (\\<d>\\<i>\\<a>\\<g> i. f i^n)\"", "lemma Cauchy_cols:\n  fixes X :: \"nat \\<Rightarrow> ('a::finite) sq_mtx\" \n  assumes \"Cauchy X\"\n  shows \"Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))\"", "lemma col_convergence:\n  assumes \"\\<forall>i. (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\" \n  shows \"X \\<longlonglongrightarrow> to_mtx (transpose L)\"", "lemma exp_similiar_sq_mtx_diag_eq:\n  assumes \"mtx_invertible P\"\n      and \"A = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\"\n    shows \"exp A = P\\<^sup>-\\<^sup>1 * exp (\\<d>\\<i>\\<a>\\<g> i. f i) * P\"", "lemma exp_similiar_sq_mtx_diag:\n  assumes \"A \\<sim> sq_mtx_diag f\"\n  shows \"exp A \\<sim> exp (sq_mtx_diag f)\"", "lemma suminf_sq_mtx_diag:\n  assumes \"\\<forall>i. (\\<lambda>n. f n i) sums (suminf (\\<lambda>n. f n i))\"\n  shows \"(\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f n i)) = (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n. f n i)\"", "lemma exp_sq_mtx_diag: \"exp (sq_mtx_diag f) = (\\<d>\\<i>\\<a>\\<g> i. exp (f i))\"", "lemma exp_scaleR_diagonal1:\n  assumes \"mtx_invertible P\" and \"A = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\"\n    shows \"exp (t *\\<^sub>R A) = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\"", "lemma exp_scaleR_diagonal2:\n  assumes \"mtx_invertible P\" and \"A = P * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\\<^sup>-\\<^sup>1\"\n    shows \"exp (t *\\<^sub>R A) = P * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\\<^sup>-\\<^sup>1\"", "lemma vector_nth_eq: \"(vector A) $ i = foldr (\\<lambda>x f n. (f (n + 1))(n := x)) A (\\<lambda>n x. 0) 1 i\"", "lemma mtx_ith_eq[simp]: \"mtx A $$ i $ j = foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n  (map (\\<lambda>l. vec_lambda (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) l (\\<lambda>n x. 0) 1)) A) (\\<lambda>n x. 0) 1 i $ j\"", "lemma mtx2_eq_iff: \"(mtx \n  ([a1, b1] # \n   [c1, d1] # []) :: 2 sq_mtx) = mtx \n  ([a2, b2] # \n   [c2, d2] # []) \\<longleftrightarrow> a1 = a2 \\<and> b1 = b2 \\<and> c1 = c2 \\<and> d1 = d2\"", "lemma mtx2_to_mtx: \"mtx \n  ([a, b] # \n   [c, d] # []) = \n  to_mtx (\\<chi> i j::2. if i=1 \\<and> j=1 then a \n  else (if i=1 \\<and> j=2 then b \n  else (if i=2 \\<and> j=1 then c \n  else d)))\"", "lemma diag2_eq: \"diag2 (\\<iota> 1) (\\<iota> 2) = (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)\"", "lemma one_mtx2: \"(1::2 sq_mtx) = diag2 1 1\"", "lemma zero_mtx2: \"(0::2 sq_mtx) = diag2 0 0\"", "lemma scaleR_mtx2: \"k *\\<^sub>R mtx \n  ([a, b] # \n   [c, d] # []) = mtx \n  ([k*a, k*b] # \n   [k*c, k*d] # [])\"", "lemma uminus_mtx2: \"-mtx \n  ([a, b] # \n   [c, d] # []) = (mtx \n  ([-a, -b] # \n   [-c, -d] # [])::2 sq_mtx)\"", "lemma plus_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) + mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1+a2, b1+b2] # \n   [c1+c2, d1+d2] # []))::2 sq_mtx)\"", "lemma minus_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) - mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1-a2, b1-b2] # \n   [c1-c2, d1-d2] # []))::2 sq_mtx)\"", "lemma times_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) * mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1*a2+b1*c2, a1*b2+b1*d2] # \n   [c1*a2+d1*c2, c1*b2+d1*d2] # []))::2 sq_mtx)\"", "lemma mtx3_to_mtx: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) = \n  to_mtx (\\<chi> i j::3. if i=1 \\<and> j=1 then a\\<^sub>1\\<^sub>1\n  else (if i=1 \\<and> j=2 then a\\<^sub>1\\<^sub>2 \n  else (if i=1 \\<and> j=3 then a\\<^sub>1\\<^sub>3 \n  else (if i=2 \\<and> j=1 then a\\<^sub>2\\<^sub>1\n  else (if i=2 \\<and> j=2 then a\\<^sub>2\\<^sub>2 \n  else (if i=2 \\<and> j=3 then a\\<^sub>2\\<^sub>3 \n  else (if i=3 \\<and> j=1 then a\\<^sub>3\\<^sub>1 \n  else (if i=3 \\<and> j=2 then a\\<^sub>3\\<^sub>2 \n  else a\\<^sub>3\\<^sub>3))))))))\"", "lemma diag3_eq: \"diag3 (\\<iota> 1) (\\<iota> 2) (\\<iota> 3) = (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)\"", "lemma one_mtx3: \"(1::3 sq_mtx) = diag3 1 1 1\"", "lemma zero_mtx3: \"(0::3 sq_mtx) = diag3 0 0 0\"", "lemma scaleR_mtx3: \"k *\\<^sub>R mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) = mtx \n  ([k*a\\<^sub>1\\<^sub>1, k*a\\<^sub>1\\<^sub>2, k*a\\<^sub>1\\<^sub>3] # \n   [k*a\\<^sub>2\\<^sub>1, k*a\\<^sub>2\\<^sub>2, k*a\\<^sub>2\\<^sub>3] # \n   [k*a\\<^sub>3\\<^sub>1, k*a\\<^sub>3\\<^sub>2, k*a\\<^sub>3\\<^sub>3] # [])\"", "lemma plus_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) + mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1+b\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2+b\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3+b\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1+b\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2+b\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3+b\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1+b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2+b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3+b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\"", "lemma minus_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) - mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1-b\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2-b\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3-b\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1-b\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2-b\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3-b\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1-b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2-b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3-b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\"", "lemma times_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) * mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\""], "translations": [["", "lemma to_vec_eq_ith: \"(to_vec A) $ i = A $$ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_vec A $ i = A $$ i", "by transfer simp"], ["", "lemma to_mtx_ith[simp]: \n  \"(to_mtx A) $$ i1 = A $ i1\"\n  \"(to_mtx A) $$ i1 $ i2 = A $ i1 $ i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx A $$ i1 = A $ i1 &&& to_mtx A $$ i1 $ i2 = A $ i1 $ i2", "by (transfer, simp)+"], ["", "lemma to_mtx_vec_lambda_ith[simp]: \"to_mtx (\\<chi> i j. x i j) $$ i1 $ i2 = x i1 i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx (\\<chi>i j. x i j) $$ i1 $ i2 = x i1 i2", "by (simp add: sq_mtx_ith_def)"], ["", "lemma sq_mtx_eq_iff:\n  shows \"A = B = (\\<forall>i j. A $$ i $ j = B $$ i $ j)\"\n    and \"A = B = (\\<forall>i. A $$ i = B $$ i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A = B) = (\\<forall>i j. A $$ i $ j = B $$ i $ j) &&&\n    (A = B) = (\\<forall>i. A $$ i = B $$ i)", "by (transfer, simp add: vec_eq_iff)+"], ["", "lemma sq_mtx_diag_simps[simp]:\n  \"i = j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = f i\"\n  \"i \\<noteq> j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = 0\"\n  \"sq_mtx_diag f $$ i = axis i (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = f i) &&&\n    (i \\<noteq> j \\<Longrightarrow> sq_mtx_diag f $$ i $ j = 0) &&&\n    sq_mtx_diag f $$ i = axis i (f i)", "unfolding sq_mtx_diag_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<Longrightarrow>\n     map_fun id to_mtx diag_mat f $$ i $ j = f i) &&&\n    (i \\<noteq> j \\<Longrightarrow>\n     map_fun id to_mtx diag_mat f $$ i $ j = 0) &&&\n    map_fun id to_mtx diag_mat f $$ i = axis i (f i)", "by (simp_all add: axis_def vec_eq_iff)"], ["", "lemma sq_mtx_diag_vec_mult: \"(\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V s = (\\<chi> i. f i * s$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V s = (\\<chi>i. f i * s $ i)", "by (simp add: matrix_vector_mul_diag_mat sq_mtx_diag.abs_eq sq_mtx_vec_mult.abs_eq)"], ["", "lemma sq_mtx_vec_mult_diag_axis: \"(\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V (axis i k) = axis i (f i * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<d>\\<i>\\<a>\\<g> i. f i) *\\<^sub>V axis i k = axis i (f i * k)", "unfolding sq_mtx_diag_vec_mult axis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>ia. f ia * (\\<chi>ia. if ia = i then k else 0) $ ia) =\n    (\\<chi>ia. if ia = i then f i * k else 0)", "by auto"], ["", "lemma sq_mtx_vec_mult_eq: \"m *\\<^sub>V x = (\\<chi> i. sum (\\<lambda>j. (m $$ i $ j) * (x $ j)) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m *\\<^sub>V x = (\\<chi>i. \\<Sum>j\\<in>UNIV. m $$ i $ j * x $ j)", "by (transfer, simp add: matrix_vector_mult_def)"], ["", "lemma sq_mtx_transpose_transpose[simp]: \"(A\\<^sup>\\<dagger>)\\<^sup>\\<dagger> = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>\\<dagger>\\<^sup>\\<dagger> = A", "by (transfer, simp)"], ["", "lemma transpose_mult_vec_canon_row[simp]: \"(A\\<^sup>\\<dagger>) *\\<^sub>V (\\<e> i) = \\<r>\\<o>\\<w> i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>\\<dagger> *\\<^sub>V \\<e> i = \\<r>\\<o>\\<w> i A", "by transfer (simp add: row_def transpose_def axis_def matrix_vector_mult_def)"], ["", "lemma row_ith[simp]: \"\\<r>\\<o>\\<w> i A = A $$ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>\\<o>\\<w> i A = A $$ i", "by transfer (simp add: row_def)"], ["", "lemma mtx_vec_mult_canon: \"A *\\<^sub>V (\\<e> i) = \\<c>\\<o>\\<l> i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V \\<e> i = \\<c>\\<o>\\<l> i A", "by (transfer, simp add: matrix_vector_mult_basis)"], ["", "subsection \\<open> Ring of square matrices \\<close>"], ["", "instantiation sq_mtx :: (finite) ring \nbegin"], ["", "lift_definition plus_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx \\<Rightarrow> 'a sq_mtx\" is \"(+)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition zero_sq_mtx :: \"'a sq_mtx\" is \"0\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition uminus_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx\" is \"uminus\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition minus_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx \\<Rightarrow> 'a sq_mtx\" is \"(-)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition times_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx \\<Rightarrow> 'a sq_mtx\" is \"(**)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "declare plus_sq_mtx.rep_eq [simp]\n    and minus_sq_mtx.rep_eq [simp]"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sq_mtx, ring_class)", "apply intro_classes"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a\n 4. \\<And>a. - a + a = 0\n 5. \\<And>a b. a - b = a + - b\n 6. \\<And>a b c. a * b * c = a * (b * c)\n 7. \\<And>a b c. (a + b) * c = a * c + b * c\n 8. \\<And>a b c. a * (b + c) = a * b + a * c", "by(transfer, simp add: algebra_simps matrix_mul_assoc matrix_add_rdistrib matrix_add_ldistrib)+"], ["", "end"], ["", "lemma sq_mtx_zero_ith[simp]: \"0 $$ i = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 $$ i = 0", "by (transfer, simp)"], ["", "lemma sq_mtx_zero_nth[simp]: \"0 $$ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 $$ i $ j = 0", "by transfer simp"], ["", "lemma sq_mtx_plus_eq: \"A + B = to_mtx (\\<chi> i j. A$$i$j + B$$i$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A + B = to_mtx (\\<chi>i j. A $$ i $ j + B $$ i $ j)", "by transfer (simp add: vec_eq_iff)"], ["", "lemma sq_mtx_plus_ith[simp]:\"(A + B) $$ i = A $$ i + B $$ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) $$ i = A $$ i + B $$ i", "unfolding sq_mtx_plus_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx (\\<chi>i j. A $$ i $ j + B $$ i $ j) $$ i = A $$ i + B $$ i", "by (simp add: vec_eq_iff)"], ["", "lemma sq_mtx_uminus_eq: \"- A = to_mtx (\\<chi> i j. - A$$i$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - A = to_mtx (\\<chi>i j. - A $$ i $ j)", "by transfer (simp add: vec_eq_iff)"], ["", "lemma sq_mtx_minus_eq: \"A - B = to_mtx (\\<chi> i j. A$$i$j - B$$i$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - B = to_mtx (\\<chi>i j. A $$ i $ j - B $$ i $ j)", "by transfer (simp add: vec_eq_iff)"], ["", "lemma sq_mtx_minus_ith[simp]:\"(A - B) $$ i = A $$ i - B $$ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) $$ i = A $$ i - B $$ i", "unfolding sq_mtx_minus_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx (\\<chi>i j. A $$ i $ j - B $$ i $ j) $$ i = A $$ i - B $$ i", "by (simp add: vec_eq_iff)"], ["", "lemma sq_mtx_times_eq: \"A * B = to_mtx (\\<chi> i j. sum (\\<lambda>k. A$$i$k * B$$k$j) UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * B = to_mtx (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $$ i $ k * B $$ k $ j)", "by transfer (simp add: matrix_matrix_mult_def)"], ["", "lemma sq_mtx_plus_diag_diag[simp]: \"sq_mtx_diag f + sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i + g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sq_mtx_diag f + sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i + g i)", "by (subst sq_mtx_eq_iff) (simp add: axis_def)"], ["", "lemma sq_mtx_minus_diag_diag[simp]: \"sq_mtx_diag f - sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i - g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sq_mtx_diag f - sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i - g i)", "by (subst sq_mtx_eq_iff) (simp add: axis_def)"], ["", "lemma sum_sq_mtx_diag[simp]: \"(\\<Sum>n<m. sq_mtx_diag (g n)) = (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n<m. (g n i))\" for m::nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n<m. sq_mtx_diag (g n)) = (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n<m. g n i)", "by (induct m, simp, subst sq_mtx_eq_iff, simp_all)"], ["", "lemma sq_mtx_mult_diag_diag[simp]: \"sq_mtx_diag f * sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i * g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sq_mtx_diag f * sq_mtx_diag g = (\\<d>\\<i>\\<a>\\<g> i. f i * g i)", "by (simp add: matrix_mul_diag_diag sq_mtx_diag.abs_eq times_sq_mtx.abs_eq)"], ["", "lemma sq_mtx_mult_diagl: \"(\\<d>\\<i>\\<a>\\<g> i. f i) * A = to_mtx (\\<chi> i j. f i * A $$ i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<d>\\<i>\\<a>\\<g> i. f i) * A = to_mtx (\\<chi>i j. f i * A $$ i $ j)", "by transfer (simp add: matrix_mul_diag_matl)"], ["", "lemma sq_mtx_mult_diagr: \"A * (\\<d>\\<i>\\<a>\\<g> i. f i) = to_mtx (\\<chi> i j. A $$ i $ j * f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * (\\<d>\\<i>\\<a>\\<g> i. f i) = to_mtx (\\<chi>i j. A $$ i $ j * f j)", "by transfer (simp add: matrix_matrix_mul_diag_matr)"], ["", "lemma mtx_vec_mult_0l[simp]: \"0 *\\<^sub>V x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 *\\<^sub>V x = 0", "by (simp add: sq_mtx_vec_mult.abs_eq zero_sq_mtx_def)"], ["", "lemma mtx_vec_mult_0r[simp]: \"A *\\<^sub>V 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V 0 = 0", "by (transfer, simp)"], ["", "lemma mtx_vec_mult_add_rdistr: \"(A + B) *\\<^sub>V x = A *\\<^sub>V x + B *\\<^sub>V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A + B) *\\<^sub>V x = A *\\<^sub>V x + B *\\<^sub>V x", "unfolding plus_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun to_vec (map_fun to_vec to_mtx) (+) A B *\\<^sub>V x =\n    A *\\<^sub>V x + B *\\<^sub>V x", "apply(transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B x.\n       map_fun (\\<lambda>x. x) (map_fun (\\<lambda>x. x) (\\<lambda>x. x)) (+)\n        A B *v\n       x =\n       A *v x + B *v x", "by (simp add: matrix_vector_mult_add_rdistrib)"], ["", "lemma mtx_vec_mult_add_rdistl: \"A *\\<^sub>V (x + y) = A *\\<^sub>V x + A *\\<^sub>V y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V (x + y) = A *\\<^sub>V x + A *\\<^sub>V y", "unfolding plus_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V (x + y) = A *\\<^sub>V x + A *\\<^sub>V y", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A x y. A *v (x + y) = A *v x + A *v y", "by (simp add: matrix_vector_right_distrib)"], ["", "lemma mtx_vec_mult_minus_rdistrib: \"(A - B) *\\<^sub>V x = A *\\<^sub>V x - B *\\<^sub>V x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A - B) *\\<^sub>V x = A *\\<^sub>V x - B *\\<^sub>V x", "unfolding minus_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun to_vec (map_fun to_vec to_mtx) (-) A B *\\<^sub>V x =\n    A *\\<^sub>V x - B *\\<^sub>V x", "by(transfer, simp add: matrix_vector_mult_diff_rdistrib)"], ["", "lemma mtx_vec_mult_minus_ldistrib: \"A *\\<^sub>V (x - y) =  A *\\<^sub>V x -  A *\\<^sub>V y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V (x - y) = A *\\<^sub>V x - A *\\<^sub>V y", "by (metis (no_types, lifting) add_diff_cancel diff_add_cancel \n      matrix_vector_right_distrib sq_mtx_vec_mult.rep_eq)"], ["", "lemma sq_mtx_times_vec_assoc: \"(A * B) *\\<^sub>V x = A *\\<^sub>V (B *\\<^sub>V x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * B) *\\<^sub>V x = A *\\<^sub>V (B *\\<^sub>V x)", "by (transfer, simp add: matrix_vector_mul_assoc)"], ["", "lemma sq_mtx_vec_mult_sum_cols: \"A *\\<^sub>V x = sum (\\<lambda>i. x $ i *\\<^sub>R \\<c>\\<o>\\<l> i A) UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V x = (\\<Sum>i\\<in>UNIV. x $ i *\\<^sub>R \\<c>\\<o>\\<l> i A)", "by(transfer) (simp add: matrix_mult_sum scalar_mult_eq_scaleR)"], ["", "subsection \\<open> Real normed vector space of square matrices \\<close>"], ["", "instantiation sq_mtx :: (finite) real_normed_vector \nbegin"], ["", "definition norm_sq_mtx :: \"'a sq_mtx \\<Rightarrow> real\" where \"\\<parallel>A\\<parallel> = \\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p\""], ["", "lift_definition scaleR_sq_mtx :: \"real \\<Rightarrow> 'a sq_mtx \\<Rightarrow> 'a sq_mtx\" is scaleR"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition sgn_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx\" \n  where \"sgn_sq_mtx A = (inverse (\\<parallel>A\\<parallel>)) *\\<^sub>R A\""], ["", "definition dist_sq_mtx :: \"'a sq_mtx \\<Rightarrow> 'a sq_mtx \\<Rightarrow> real\" \n  where \"dist_sq_mtx A B = \\<parallel>A - B\\<parallel>\""], ["", "definition uniformity_sq_mtx :: \"('a sq_mtx \\<times> 'a sq_mtx) filter\" \n  where \"uniformity_sq_mtx = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\""], ["", "definition open_sq_mtx :: \"'a sq_mtx set \\<Rightarrow> bool\" \n  where \"open_sq_mtx U = (\\<forall>x\\<in>U. \\<forall>\\<^sub>F (x', y) in uniformity. x' = x \\<longrightarrow> y \\<in> U)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sq_mtx, real_normed_vector_class)", "apply intro_classes"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. dist x y = \\<parallel>x - y\\<parallel>\n 2. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 3. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 4. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 5. \\<And>x. 1 *\\<^sub>R x = x\n 6. \\<And>x. sgn x = inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x\n 7. uniformity = (INF e\\<in>{0<..}. principal {(x, y). dist x y < e})\n 8. \\<And>U.\n       open U =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x', y) in uniformity.\n              x' = x \\<longrightarrow> y \\<in> U)\n 9. \\<And>x. (\\<parallel>x\\<parallel> = 0) = (x = 0)\n 10. \\<And>x y.\n        \\<parallel>x + y\\<parallel>\n        \\<le> (\\<parallel>x\\<parallel>) + (\\<parallel>y\\<parallel>)\nA total of 11 subgoals...", "unfolding sgn_sq_mtx_def open_sq_mtx_def dist_sq_mtx_def uniformity_sq_mtx_def"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y. \\<parallel>x - y\\<parallel> = \\<parallel>x - y\\<parallel>\n 2. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 3. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 4. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 5. \\<And>x. 1 *\\<^sub>R x = x\n 6. \\<And>x.\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x =\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x\n 7. (INF e\\<in>{0<..}.\n        principal {(x, y). \\<parallel>x - y\\<parallel> < e}) =\n    (INF e\\<in>{0<..}. principal {(x, y). \\<parallel>x - y\\<parallel> < e})\n 8. \\<And>U.\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U) =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U)\n 9. \\<And>x. (\\<parallel>x\\<parallel> = 0) = (x = 0)\n 10. \\<And>x y.\n        \\<parallel>x + y\\<parallel>\n        \\<le> (\\<parallel>x\\<parallel>) + (\\<parallel>y\\<parallel>)\nA total of 11 subgoals...", "prefer 10"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y.\n       \\<parallel>x + y\\<parallel>\n       \\<le> (\\<parallel>x\\<parallel>) + (\\<parallel>y\\<parallel>)\n 2. \\<And>x y. \\<parallel>x - y\\<parallel> = \\<parallel>x - y\\<parallel>\n 3. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 4. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 5. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 6. \\<And>x. 1 *\\<^sub>R x = x\n 7. \\<And>x.\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x =\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x\n 8. (INF e\\<in>{0<..}.\n        principal {(x, y). \\<parallel>x - y\\<parallel> < e}) =\n    (INF e\\<in>{0<..}. principal {(x, y). \\<parallel>x - y\\<parallel> < e})\n 9. \\<And>U.\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U) =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U)\n 10. \\<And>x. (\\<parallel>x\\<parallel> = 0) = (x = 0)\nA total of 11 subgoals...", "apply(transfer, simp add: norm_sq_mtx_def op_norm_triangle)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y. \\<parallel>x - y\\<parallel> = \\<parallel>x - y\\<parallel>\n 2. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 3. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 4. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 5. \\<And>x. 1 *\\<^sub>R x = x\n 6. \\<And>x.\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x =\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x\n 7. (INF e\\<in>{0<..}.\n        principal {(x, y). \\<parallel>x - y\\<parallel> < e}) =\n    (INF e\\<in>{0<..}. principal {(x, y). \\<parallel>x - y\\<parallel> < e})\n 8. \\<And>U.\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U) =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U)\n 9. \\<And>x. (\\<parallel>x\\<parallel> = 0) = (x = 0)\n 10. \\<And>a x.\n        \\<parallel>a *\\<^sub>R x\\<parallel> =\n        \\<bar>a\\<bar> * (\\<parallel>x\\<parallel>)", "prefer 9"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x. (\\<parallel>x\\<parallel> = 0) = (x = 0)\n 2. \\<And>x y. \\<parallel>x - y\\<parallel> = \\<parallel>x - y\\<parallel>\n 3. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 4. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 5. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 6. \\<And>x. 1 *\\<^sub>R x = x\n 7. \\<And>x.\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x =\n       inverse (\\<parallel>x\\<parallel>) *\\<^sub>R x\n 8. (INF e\\<in>{0<..}.\n        principal {(x, y). \\<parallel>x - y\\<parallel> < e}) =\n    (INF e\\<in>{0<..}. principal {(x, y). \\<parallel>x - y\\<parallel> < e})\n 9. \\<And>U.\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U) =\n       (\\<forall>x\\<in>U.\n           \\<forall>\\<^sub>F (x',\n              y) in INF e\\<in>{0<..}.\n                       principal {(x, y). \\<parallel>x - y\\<parallel> < e}.\n              x' = x \\<longrightarrow> y \\<in> U)\n 10. \\<And>a x.\n        \\<parallel>a *\\<^sub>R x\\<parallel> =\n        \\<bar>a\\<bar> * (\\<parallel>x\\<parallel>)", "apply(simp_all add: norm_sq_mtx_def zero_sq_mtx_def op_norm_eq_0)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. (to_vec x = 0) = (x = to_mtx 0)\n 2. \\<And>a x y. a *\\<^sub>R (x + y) = a *\\<^sub>R x + a *\\<^sub>R y\n 3. \\<And>a b x. (a + b) *\\<^sub>R x = a *\\<^sub>R x + b *\\<^sub>R x\n 4. \\<And>a b x. a *\\<^sub>R b *\\<^sub>R x = (a * b) *\\<^sub>R x\n 5. \\<And>x. 1 *\\<^sub>R x = x\n 6. \\<And>a x.\n       \\<parallel>to_vec (a *\\<^sub>R x)\\<parallel>\\<^sub>o\\<^sub>p =\n       \\<bar>a\\<bar> * (\\<parallel>to_vec x\\<parallel>\\<^sub>o\\<^sub>p)", "by (transfer, simp add: norm_sq_mtx_def op_norm_scaleR algebra_simps)+"], ["", "end"], ["", "lemma sq_mtx_scaleR_eq: \"c *\\<^sub>R A = to_mtx (\\<chi> i j. c *\\<^sub>R A $$ i $ j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R A = to_mtx (\\<chi>i j. c *\\<^sub>R A $$ i $ j)", "by transfer (simp add: vec_eq_iff)"], ["", "lemma scaleR_to_mtx_ith[simp]: \"c *\\<^sub>R (to_mtx A) $$ i1 $ i2 = c * A $ i1 $ i2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R to_mtx A $$ i1 $ i2 = c * A $ i1 $ i2", "by transfer (simp add: scaleR_vec_def)"], ["", "lemma sq_mtx_scaleR_ith[simp]: \"(c *\\<^sub>R A) $$ i = (c  *\\<^sub>R (A $$ i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c *\\<^sub>R A) $$ i = c *\\<^sub>R A $$ i", "by (unfold scaleR_sq_mtx_def, transfer, simp)"], ["", "lemma scaleR_sq_mtx_diag: \"c *\\<^sub>R sq_mtx_diag f = (\\<d>\\<i>\\<a>\\<g> i. c * f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R sq_mtx_diag f = (\\<d>\\<i>\\<a>\\<g> i. c * f i)", "by (subst sq_mtx_eq_iff, simp add: axis_def)"], ["", "lemma scaleR_mtx_vec_assoc: \"(c *\\<^sub>R A) *\\<^sub>V x = c *\\<^sub>R (A *\\<^sub>V x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (c *\\<^sub>R A) *\\<^sub>V x = c *\\<^sub>R A *\\<^sub>V x", "unfolding scaleR_sq_mtx_def sq_mtx_vec_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun to_vec id (*v)\n     (map_fun id (map_fun to_vec to_mtx) (*\\<^sub>R) c A) x =\n    c *\\<^sub>R map_fun to_vec id (*v) A x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R to_vec A *v x = c *\\<^sub>R (to_vec A *v x)", "by (simp add: scaleR_matrix_vector_assoc)"], ["", "lemma mtx_vec_scaleR_commute: \"A *\\<^sub>V (c *\\<^sub>R x) = c *\\<^sub>R (A *\\<^sub>V x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *\\<^sub>V (c *\\<^sub>R x) = c *\\<^sub>R A *\\<^sub>V x", "unfolding scaleR_sq_mtx_def sq_mtx_vec_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_fun to_vec id (*v) A (c *\\<^sub>R x) =\n    c *\\<^sub>R map_fun to_vec id (*v) A x", "apply(simp, transfer)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A c x. A *v c *\\<^sub>R x = c *\\<^sub>R (A *v x)", "by (simp add: vector_scaleR_commute)"], ["", "lemma mtx_times_scaleR_commute: \"A * (c *\\<^sub>R B) = c *\\<^sub>R (A * B)\" for A::\"('n::finite) sq_mtx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * c *\\<^sub>R B = c *\\<^sub>R (A * B)", "unfolding sq_mtx_scaleR_eq sq_mtx_times_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx\n     (\\<chi>i j.\n         \\<Sum>k\\<in>UNIV.\n           A $$ i $ k *\n           to_mtx (\\<chi>i j. c *\\<^sub>R B $$ i $ j) $$ k $ j) =\n    to_mtx\n     (\\<chi>i j.\n         c *\\<^sub>R\n         to_mtx (\\<chi>i j. \\<Sum>k\\<in>UNIV. A $$ i $ k * B $$ k $ j) $$\n         i $\n         j)", "apply(simp add: to_mtx_inject)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. \\<chi>j. \\<Sum>k\\<in>UNIV. A $$ i $ k * (c * B $$ k $ j)) =\n    (\\<lambda>i. \\<chi>j. c * (\\<Sum>k\\<in>UNIV. A $$ i $ k * B $$ k $ j))", "apply(simp add: vec_eq_iff fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x i.\n       (\\<Sum>k\\<in>UNIV. A $$ x $ k * (c * B $$ k $ i)) =\n       c * (\\<Sum>k\\<in>UNIV. A $$ x $ k * B $$ k $ i)", "by (simp add: semiring_normalization_rules(19) vector_space_over_itself.scale_sum_right)"], ["", "lemma le_mtx_norm: \"m \\<in> {\\<parallel>A *\\<^sub>V x\\<parallel> |x. \\<parallel>x\\<parallel> = 1} \\<Longrightarrow> m \\<le> \\<parallel>A\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m \\<in> {\\<parallel>A *\\<^sub>V x\\<parallel> |x.\n             \\<parallel>x\\<parallel> = 1} \\<Longrightarrow>\n    m \\<le> \\<parallel>A\\<parallel>", "using cSup_upper[of _ \"{\\<parallel>(to_vec A) *v x\\<parallel> | x. \\<parallel>x\\<parallel> = 1}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> {\\<parallel>to_vec A *v x\\<parallel> |x.\n                     \\<parallel>x\\<parallel> = 1};\n   bdd_above\n    {\\<parallel>to_vec A *v x\\<parallel> |x.\n     \\<parallel>x\\<parallel> = 1}\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> Sup {\\<parallel>to_vec A *v x\\<parallel> |x.\n                                  \\<parallel>x\\<parallel> = 1}\n\ngoal (1 subgoal):\n 1. m \\<in> {\\<parallel>A *\\<^sub>V x\\<parallel> |x.\n             \\<parallel>x\\<parallel> = 1} \\<Longrightarrow>\n    m \\<le> \\<parallel>A\\<parallel>", "by (simp add: op_norm_set_proptys(2) op_norm_def norm_sq_mtx_def sq_mtx_vec_mult.rep_eq)"], ["", "lemma norm_vec_mult_le: \"\\<parallel>A *\\<^sub>V x\\<parallel> \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>x\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A *\\<^sub>V x\\<parallel>\n    \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>x\\<parallel>)", "by (simp add: norm_matrix_le_mult_op_norm norm_sq_mtx_def sq_mtx_vec_mult.rep_eq)"], ["", "lemma bounded_bilinear_sq_mtx_vec_mult: \"bounded_bilinear (\\<lambda>A s. A *\\<^sub>V s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_bilinear (*\\<^sub>V)", "apply (rule bounded_bilinear.intro, simp_all add: mtx_vec_mult_add_rdistr \n      mtx_vec_mult_add_rdistl scaleR_mtx_vec_assoc mtx_vec_scaleR_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>K.\n       \\<forall>a b.\n          \\<parallel>a *\\<^sub>V b\\<parallel>\n          \\<le> (\\<parallel>a\\<parallel>) * (\\<parallel>b\\<parallel>) * K", "by (rule_tac x=1 in exI, auto intro!: norm_vec_mult_le)"], ["", "lemma norm_sq_mtx_def2: \"\\<parallel>A\\<parallel> = Sup {\\<parallel>A *\\<^sub>V x\\<parallel> |x. \\<parallel>x\\<parallel> = 1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A\\<parallel> =\n    Sup {\\<parallel>A *\\<^sub>V x\\<parallel> |x.\n         \\<parallel>x\\<parallel> = 1}", "unfolding norm_sq_mtx_def op_norm_def sq_mtx_vec_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {\\<parallel>to_vec A *v x\\<parallel> |x.\n         \\<parallel>x\\<parallel> = 1} =\n    Sup {\\<parallel>map_fun to_vec id (*v) A x\\<parallel> |x.\n         \\<parallel>x\\<parallel> = 1}", "by simp"], ["", "lemma norm_sq_mtx_def3: \"\\<parallel>A\\<parallel> = (SUP x. (\\<parallel>A *\\<^sub>V x\\<parallel>) / (\\<parallel>x\\<parallel>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A\\<parallel> =\n    (SUP x.\n        (\\<parallel>A *\\<^sub>V x\\<parallel>) / (\\<parallel>x\\<parallel>))", "unfolding norm_sq_mtx_def onorm_def sq_mtx_vec_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SUP x.\n        (\\<parallel>to_vec A *v x\\<parallel>) / (\\<parallel>x\\<parallel>)) =\n    (SUP x.\n        (\\<parallel>map_fun to_vec id (*v) A x\\<parallel>) /\n        (\\<parallel>x\\<parallel>))", "by simp"], ["", "lemma norm_sq_mtx_diag: \"\\<parallel>sq_mtx_diag f\\<parallel> = Max {\\<bar>f i\\<bar> |i. i \\<in> UNIV}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>sq_mtx_diag f\\<parallel> =\n    Max {\\<bar>f i\\<bar> |i. i \\<in> UNIV}", "unfolding norm_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>to_vec (sq_mtx_diag f)\\<parallel>\\<^sub>o\\<^sub>p =\n    Max {\\<bar>f i\\<bar> |i. i \\<in> UNIV}", "apply transfer"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<parallel>diag_mat f\\<parallel>\\<^sub>o\\<^sub>p =\n       Max {\\<bar>f i\\<bar> |i. i \\<in> UNIV}", "by (rule op_norm_diag_mat_eq)"], ["", "lemma sq_mtx_norm_le_sum_col: \"\\<parallel>A\\<parallel> \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i A\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A\\<parallel>\n    \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i A\\<parallel>)", "using op_norm_le_sum_column[of \"to_vec A\"]"], ["proof (prove)\nusing this:\n  \\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p\n  \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>column i (to_vec A)\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>A\\<parallel>\n    \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i A\\<parallel>)", "apply(simp add: norm_sq_mtx_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p\n    \\<le> (\\<Sum>i\\<in>UNIV.\n             \\<parallel>column i (to_vec A)\\<parallel>) \\<Longrightarrow>\n    \\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p\n    \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i A\\<parallel>)", "by(transfer, simp add: op_norm_le_sum_column)"], ["", "lemma norm_le_transpose: \"\\<parallel>A\\<parallel> \\<le> \\<parallel>A\\<^sup>\\<dagger>\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A\\<parallel> \\<le> \\<parallel>A\\<^sup>\\<dagger>\\<parallel>", "unfolding norm_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p\n    \\<le> \\<parallel>to_vec A\\<^sup>\\<dagger>\\<parallel>\\<^sub>o\\<^sub>p", "by transfer (rule op_norm_le_transpose)"], ["", "lemma norm_eq_norm_transpose[simp]: \"\\<parallel>A\\<^sup>\\<dagger>\\<parallel> = \\<parallel>A\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A\\<^sup>\\<dagger>\\<parallel> = \\<parallel>A\\<parallel>", "using norm_le_transpose[of A] and norm_le_transpose[of \"A\\<^sup>\\<dagger>\"]"], ["proof (prove)\nusing this:\n  \\<parallel>A\\<parallel> \\<le> \\<parallel>A\\<^sup>\\<dagger>\\<parallel>\n  \\<parallel>A\\<^sup>\\<dagger>\\<parallel>\n  \\<le> \\<parallel>A\\<^sup>\\<dagger>\\<^sup>\\<dagger>\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>A\\<^sup>\\<dagger>\\<parallel> = \\<parallel>A\\<parallel>", "by simp"], ["", "lemma norm_column_le_norm: \"\\<parallel>A $$ i\\<parallel> \\<le> \\<parallel>A\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A $$ i\\<parallel> \\<le> \\<parallel>A\\<parallel>", "using norm_vec_mult_le[of \"A\\<^sup>\\<dagger>\" \"\\<e> i\"]"], ["proof (prove)\nusing this:\n  \\<parallel>A\\<^sup>\\<dagger> *\\<^sub>V \\<e> i\\<parallel>\n  \\<le> (\\<parallel>A\\<^sup>\\<dagger>\\<parallel>) *\n        (\\<parallel>\\<e> i\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>A $$ i\\<parallel> \\<le> \\<parallel>A\\<parallel>", "by simp"], ["", "subsection \\<open> Real normed algebra of square matrices \\<close>"], ["", "instantiation sq_mtx :: (finite) real_normed_algebra_1\nbegin"], ["", "lift_definition one_sq_mtx :: \"'a sq_mtx\" is \"to_mtx (mat 1)\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma sq_mtx_one_idty: \"1 * A = A\" \"A * 1 = A\" for A :: \"'a sq_mtx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * A = A &&& A * 1 = A", "by(transfer, transfer, unfold mat_def matrix_matrix_mult_def, simp add: vec_eq_iff)+"], ["", "lemma sq_mtx_norm_1: \"\\<parallel>(1::'a sq_mtx)\\<parallel> = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>1\\<parallel> = 1", "unfolding one_sq_mtx_def norm_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>to_vec (id (to_mtx (mat 1)))\\<parallel>\\<^sub>o\\<^sub>p = 1", "apply(simp add: op_norm_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup {\\<parallel>x\\<parallel> |x. \\<parallel>x\\<parallel> = 1} = 1", "apply(subst cSup_eq[of _ 1])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>{\\<parallel>x\\<parallel> |x.\n                    \\<parallel>x\\<parallel> = 1}.\n       x \\<le> 1\n 2. Bex {\\<parallel>x\\<parallel> |x. \\<parallel>x\\<parallel> = 1}\n     ((\\<le>) 1)\n 3. 1 = 1", "using ex_norm_eq_1"], ["proof (prove)\nusing this:\n  \\<exists>x. \\<parallel>x\\<parallel> = 1\n\ngoal (3 subgoals):\n 1. \\<forall>x\\<in>{\\<parallel>x\\<parallel> |x.\n                    \\<parallel>x\\<parallel> = 1}.\n       x \\<le> 1\n 2. Bex {\\<parallel>x\\<parallel> |x. \\<parallel>x\\<parallel> = 1}\n     ((\\<le>) 1)\n 3. 1 = 1", "by auto"], ["", "lemma sq_mtx_norm_times: \"\\<parallel>A * B\\<parallel> \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>B\\<parallel>)\" for A :: \"'a sq_mtx\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A * B\\<parallel>\n    \\<le> (\\<parallel>A\\<parallel>) * (\\<parallel>B\\<parallel>)", "unfolding norm_sq_mtx_def times_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>to_vec\n                (map_fun to_vec (map_fun to_vec to_mtx) (**) A\n                  B)\\<parallel>\\<^sub>o\\<^sub>p\n    \\<le> (\\<parallel>to_vec A\\<parallel>\\<^sub>o\\<^sub>p) *\n          (\\<parallel>to_vec B\\<parallel>\\<^sub>o\\<^sub>p)", "by(simp add: op_norm_matrix_matrix_mult_le)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sq_mtx, real_normed_algebra_1_class)", "apply intro_classes"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R x * y = a *\\<^sub>R (x * y)\n 2. \\<And>x a y. x * a *\\<^sub>R y = a *\\<^sub>R (x * y)\n 3. \\<And>a. 1 * a = a\n 4. \\<And>a. a * 1 = a\n 5. 0 \\<noteq> 1\n 6. \\<And>x y.\n       \\<parallel>x * y\\<parallel>\n       \\<le> (\\<parallel>x\\<parallel>) * (\\<parallel>y\\<parallel>)\n 7. \\<parallel>1\\<parallel> = 1", "apply(simp_all add: sq_mtx_one_idty sq_mtx_norm_1 sq_mtx_norm_times)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R x * y = a *\\<^sub>R (x * y)\n 2. \\<And>x a y. x * a *\\<^sub>R y = a *\\<^sub>R (x * y)\n 3. 0 \\<noteq> 1", "apply(simp_all add: to_mtx_inject vec_eq_iff one_sq_mtx_def zero_sq_mtx_def mat_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a x y. a *\\<^sub>R x * y = a *\\<^sub>R (x * y)\n 2. \\<And>x a y. x * a *\\<^sub>R y = a *\\<^sub>R (x * y)", "by(transfer, simp add: scalar_matrix_assoc matrix_scalar_ac)+"], ["", "end"], ["", "lemma sq_mtx_one_ith_simps[simp]: \"1 $$ i $ i = 1\" \"i \\<noteq> j \\<Longrightarrow> 1 $$ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 $$ i $ i = 1 &&& (i \\<noteq> j \\<Longrightarrow> 1 $$ i $ j = 0)", "unfolding one_sq_mtx_def mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. id (to_mtx (\\<chi>i j. if i = j then 1 else 0)) $$ i $ i = 1 &&&\n    (i \\<noteq> j \\<Longrightarrow>\n     id (to_mtx (\\<chi>i j. if i = j then 1 else 0)) $$ i $ j = 0)", "by simp_all"], ["", "lemma of_nat_eq_sq_mtx_diag[simp]: \"of_nat m = (\\<d>\\<i>\\<a>\\<g> i. m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat m = (\\<d>\\<i>\\<a>\\<g> x. real m)", "by (induct m) (simp, subst sq_mtx_eq_iff, simp add: axis_def)+"], ["", "lemma mtx_vec_mult_1[simp]: \"1 *\\<^sub>V s = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 *\\<^sub>V s = s", "by (auto simp: sq_mtx_vec_mult_def one_sq_mtx_def \n      mat_def vec_eq_iff matrix_vector_mult_def)"], ["", "lemma sq_mtx_diag_one[simp]: \"(\\<d>\\<i>\\<a>\\<g> i. 1) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<d>\\<i>\\<a>\\<g> i. 1) = 1", "by (subst sq_mtx_eq_iff, simp add: one_sq_mtx_def mat_def axis_def)"], ["", "abbreviation \"mtx_invertible A \\<equiv> invertible (to_vec A)\""], ["", "lemma mtx_invertible_def: \"mtx_invertible A \\<longleftrightarrow> (\\<exists>A'. A' * A = 1 \\<and> A * A' = 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_invertible A = (\\<exists>A'. A' * A = 1 \\<and> A * A' = 1)", "apply (unfold sq_mtx_inv_def times_sq_mtx_def one_sq_mtx_def invertible_def, clarsimp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A'.\n       \\<lbrakk>to_vec A ** A' = mat 1; A' ** to_vec A = mat 1\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            to_mtx (to_vec A' ** to_vec A) =\n                            to_mtx (mat 1) \\<and>\n                            to_mtx (to_vec A ** to_vec A') = to_mtx (mat 1)\n 2. \\<And>A'.\n       \\<lbrakk>to_mtx (to_vec A' ** to_vec A) = to_mtx (mat 1);\n        to_mtx (to_vec A ** to_vec A') = to_mtx (mat 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            to_vec A ** A' = mat 1 \\<and>\n                            A' ** to_vec A = mat 1", "apply(rule_tac x=\"to_mtx A'\" in exI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A'.\n       \\<lbrakk>to_mtx (to_vec A' ** to_vec A) = to_mtx (mat 1);\n        to_mtx (to_vec A ** to_vec A') = to_mtx (mat 1)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>A'.\n                            to_vec A ** A' = mat 1 \\<and>\n                            A' ** to_vec A = mat 1", "by (rule_tac x=\"to_vec A'\" in exI, simp add: to_mtx_inject)"], ["", "lemma mtx_invertibleI:\n  assumes \"A * B = 1\" and \"B * A = 1\"\n  shows \"mtx_invertible A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_invertible A", "using assms"], ["proof (prove)\nusing this:\n  A * B = 1\n  B * A = 1\n\ngoal (1 subgoal):\n 1. mtx_invertible A", "unfolding mtx_invertible_def"], ["proof (prove)\nusing this:\n  A * B = 1\n  B * A = 1\n\ngoal (1 subgoal):\n 1. \\<exists>A'. A' * A = 1 \\<and> A * A' = 1", "by auto"], ["", "lemma mtx_invertibleD[simp]:\n  assumes \"mtx_invertible A\" \n  shows \"A\\<^sup>-\\<^sup>1 * A = 1\" and \"A * A\\<^sup>-\\<^sup>1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>-\\<^sup>1 * A = 1 &&& A * A\\<^sup>-\\<^sup>1 = 1", "apply (unfold sq_mtx_inv_def times_sq_mtx_def one_sq_mtx_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. map_fun to_vec (map_fun to_vec to_mtx) (**)\n     (map_fun to_vec to_mtx matrix_inv A) A =\n    id (to_mtx (mat 1))\n 2. map_fun to_vec (map_fun to_vec to_mtx) (**) A\n     (map_fun to_vec to_mtx matrix_inv A) =\n    id (to_mtx (mat 1))", "using assms"], ["proof (prove)\nusing this:\n  mtx_invertible A\n\ngoal (2 subgoals):\n 1. map_fun to_vec (map_fun to_vec to_mtx) (**)\n     (map_fun to_vec to_mtx matrix_inv A) A =\n    id (to_mtx (mat 1))\n 2. map_fun to_vec (map_fun to_vec to_mtx) (**) A\n     (map_fun to_vec to_mtx matrix_inv A) =\n    id (to_mtx (mat 1))", "by simp_all"], ["", "lemma mtx_invertible_inv[simp]: \"mtx_invertible A \\<Longrightarrow> mtx_invertible (A\\<^sup>-\\<^sup>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_invertible A \\<Longrightarrow> mtx_invertible A\\<^sup>-\\<^sup>1", "using mtx_invertibleD mtx_invertibleI"], ["proof (prove)\nusing this:\n  mtx_invertible ?A \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 * ?A = 1\n  mtx_invertible ?A \\<Longrightarrow> ?A * ?A\\<^sup>-\\<^sup>1 = 1\n  \\<lbrakk>?A * ?B = 1; ?B * ?A = 1\\<rbrakk>\n  \\<Longrightarrow> mtx_invertible ?A\n\ngoal (1 subgoal):\n 1. mtx_invertible A \\<Longrightarrow> mtx_invertible A\\<^sup>-\\<^sup>1", "by blast"], ["", "lemma mtx_invertible_one[simp]: \"mtx_invertible 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_invertible 1", "by (simp add: one_sq_mtx.rep_eq)"], ["", "lemma sq_mtx_inv_unique:\n  assumes \"A * B = 1\" and \"B * A = 1\"\n  shows \"A\\<^sup>-\\<^sup>1 = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>-\\<^sup>1 = B", "by (metis (no_types, lifting) assms mtx_invertibleD(2) \n      mtx_invertibleI mult.assoc sq_mtx_one_idty(1))"], ["", "lemma sq_mtx_inv_idempotent[simp]: \"mtx_invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx_invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A", "using mtx_invertibleD sq_mtx_inv_unique"], ["proof (prove)\nusing this:\n  mtx_invertible ?A \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 * ?A = 1\n  mtx_invertible ?A \\<Longrightarrow> ?A * ?A\\<^sup>-\\<^sup>1 = 1\n  \\<lbrakk>?A * ?B = 1; ?B * ?A = 1\\<rbrakk>\n  \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 = ?B\n\ngoal (1 subgoal):\n 1. mtx_invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A", "by blast"], ["", "lemma sq_mtx_inv_mult:\n  assumes \"mtx_invertible A\" and \"mtx_invertible B\"\n  shows \"(A * B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 * A\\<^sup>-\\<^sup>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A * B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 * A\\<^sup>-\\<^sup>1", "by (simp add: assms matrix_inv_matrix_mul sq_mtx_inv_def times_sq_mtx_def)"], ["", "lemma sq_mtx_inv_one[simp]: \"1\\<^sup>-\\<^sup>1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1\\<^sup>-\\<^sup>1 = 1", "by (simp add: sq_mtx_inv_unique)"], ["", "definition similar_sq_mtx :: \"('n::finite) sq_mtx \\<Rightarrow> 'n sq_mtx \\<Rightarrow> bool\" (infixr \"\\<sim>\" 25)\n  where \"(A \\<sim> B) \\<longleftrightarrow> (\\<exists> P. mtx_invertible P \\<and> A = P\\<^sup>-\\<^sup>1 * B * P)\""], ["", "lemma similar_sq_mtx_matrix: \"(A \\<sim> B) = similar_matrix (to_vec A) (to_vec B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A \\<sim> B) = similar_matrix (to_vec A) (to_vec B)", "apply(unfold similar_matrix_def similar_sq_mtx_def, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P.\n       \\<lbrakk>mtx_invertible P; A = P\\<^sup>-\\<^sup>1 * B * P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            invertible Pa \\<and>\n                            to_vec (P\\<^sup>-\\<^sup>1 * B * P) =\n                            matrix_inv Pa ** to_vec B ** Pa\n 2. \\<And>P.\n       \\<lbrakk>invertible P;\n        to_vec A = matrix_inv P ** to_vec B ** P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            mtx_invertible P \\<and>\n                            A = P\\<^sup>-\\<^sup>1 * B * P", "apply (metis sq_mtx_inv.rep_eq times_sq_mtx.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>invertible P;\n        to_vec A = matrix_inv P ** to_vec B ** P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>P.\n                            mtx_invertible P \\<and>\n                            A = P\\<^sup>-\\<^sup>1 * B * P", "by (metis UNIV_I sq_mtx_inv.abs_eq times_sq_mtx.abs_eq to_mtx_inverse to_vec_inverse)"], ["", "lemma similar_sq_mtx_refl[simp]: \"A \\<sim> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sim> A", "by (unfold similar_sq_mtx_def, rule_tac x=\"1\" in exI, simp)"], ["", "lemma similar_sq_mtx_simm: \"A \\<sim> B \\<Longrightarrow> B \\<sim> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sim> B \\<Longrightarrow> B \\<sim> A", "apply(unfold similar_sq_mtx_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>mtx_invertible P; A = P\\<^sup>-\\<^sup>1 * B * P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            mtx_invertible Pa \\<and>\n                            B =\n                            Pa\\<^sup>-\\<^sup>1 *\n                            (P\\<^sup>-\\<^sup>1 * B * P) *\n                            Pa", "apply(rule_tac x=\"P\\<^sup>-\\<^sup>1\" in exI, simp add: mult.assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>mtx_invertible P; A = P\\<^sup>-\\<^sup>1 * (B * P)\\<rbrakk>\n       \\<Longrightarrow> B = P * (P\\<^sup>-\\<^sup>1 * B)", "by (metis mtx_invertibleD(2) mult.assoc mult.left_neutral)"], ["", "lemma similar_sq_mtx_trans: \"A \\<sim> B \\<Longrightarrow> B \\<sim> C \\<Longrightarrow> A \\<sim> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sim> B; B \\<sim> C\\<rbrakk> \\<Longrightarrow> A \\<sim> C", "unfolding similar_sq_mtx_matrix"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>similar_matrix (to_vec A) (to_vec B);\n     similar_matrix (to_vec B) (to_vec C)\\<rbrakk>\n    \\<Longrightarrow> similar_matrix (to_vec A) (to_vec C)", "using similar_matrix_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>similar_matrix ?A ?B; similar_matrix ?B ?C\\<rbrakk>\n  \\<Longrightarrow> similar_matrix ?A ?C\n\ngoal (1 subgoal):\n 1. \\<lbrakk>similar_matrix (to_vec A) (to_vec B);\n     similar_matrix (to_vec B) (to_vec C)\\<rbrakk>\n    \\<Longrightarrow> similar_matrix (to_vec A) (to_vec C)", "by blast"], ["", "lemma power_sq_mtx_diag: \"(sq_mtx_diag f)^n = (\\<d>\\<i>\\<a>\\<g> i. f i^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sq_mtx_diag f ^ n = (\\<d>\\<i>\\<a>\\<g> i. f i ^ n)", "by (induct n, simp_all)"], ["", "lemma power_similiar_sq_mtx_diag_eq:\n  assumes \"mtx_invertible P\"\n      and \"A = P\\<^sup>-\\<^sup>1 * (sq_mtx_diag f) * P\"\n    shows \"A^n = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i^n) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^ n = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P", "proof(induct n, simp_all add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P) ^ n =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) *\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n       (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P) ^ n =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) *\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n       (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "have \"P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P * (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) = \n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n    (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n    P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P", "by (metis (no_types, lifting) assms(1) mtx_invertibleD(2) mult.assoc mult.right_neutral)"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n  (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P) ^ n =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) *\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n       (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "also"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n  (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P) ^ n =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) *\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n       (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "have \"... = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "by (simp add: mult.assoc)"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P) ^ n =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) *\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n       (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n       P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "finally"], ["proof (chain)\npicking this:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n  (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "show \"P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P * (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) = \n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P\""], ["proof (prove)\nusing this:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n  (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P\n\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n    (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P", "."], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P *\n  (P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i * f i ^ n) * P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma power_similar_sq_mtx_diag:\n  assumes \"A \\<sim> (sq_mtx_diag f)\"\n  shows \"A^n \\<sim> (\\<d>\\<i>\\<a>\\<g> i. f i^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^ n \\<sim> (\\<d>\\<i>\\<a>\\<g> i. f i ^ n)", "using assms power_similiar_sq_mtx_diag_eq"], ["proof (prove)\nusing this:\n  A \\<sim> sq_mtx_diag f\n  \\<lbrakk>mtx_invertible ?P;\n   ?A = ?P\\<^sup>-\\<^sup>1 * sq_mtx_diag ?f * ?P\\<rbrakk>\n  \\<Longrightarrow> ?A ^ ?n =\n                    ?P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. ?f i ^ ?n) *\n                    ?P\n\ngoal (1 subgoal):\n 1. A ^ n \\<sim> (\\<d>\\<i>\\<a>\\<g> i. f i ^ n)", "unfolding similar_sq_mtx_def"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     mtx_invertible P \\<and> A = P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P\n  \\<lbrakk>mtx_invertible ?P;\n   ?A = ?P\\<^sup>-\\<^sup>1 * sq_mtx_diag ?f * ?P\\<rbrakk>\n  \\<Longrightarrow> ?A ^ ?n =\n                    ?P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. ?f i ^ ?n) *\n                    ?P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       mtx_invertible P \\<and>\n       A ^ n = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P", "by blast"], ["", "subsection \\<open> Banach space of square matrices \\<close>"], ["", "lemma Cauchy_cols:\n  fixes X :: \"nat \\<Rightarrow> ('a::finite) sq_mtx\" \n  assumes \"Cauchy X\"\n  shows \"Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))", "proof(unfold Cauchy_def dist_norm, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "fix \\<epsilon>::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "assume \"\\<epsilon> > 0\""], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "then"], ["proof (chain)\npicking this:\n  0 < \\<epsilon>", "obtain M where M_def:\"\\<forall>m\\<ge>M. \\<forall>n\\<ge>M. \\<parallel>X m - X n\\<parallel> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M.\n              \\<parallel>X m - X n\\<parallel> < \\<epsilon> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<open>Cauchy X\\<close>"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  Cauchy X\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M.\n              \\<parallel>X m - X n\\<parallel> < \\<epsilon> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding Cauchy_def"], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n  \\<forall>e>0.\n     \\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. dist (X m) (X n) < e\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>m\\<ge>M.\n           \\<forall>n\\<ge>M.\n              \\<parallel>X m - X n\\<parallel> < \\<epsilon> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add: dist_sq_mtx_def) metis"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>M.\n     \\<forall>n\\<ge>M. \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "{"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>M.\n     \\<forall>n\\<ge>M. \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "fix m n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "assume \"m \\<ge> M\" and \"n \\<ge> M\""], ["proof (state)\nthis:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "hence \"\\<epsilon> > \\<parallel>X m - X n\\<parallel>\""], ["proof (prove)\nusing this:\n  M \\<le> m\n  M \\<le> n\n\ngoal (1 subgoal):\n 1. \\<parallel>X m - X n\\<parallel> < \\<epsilon>", "using M_def"], ["proof (prove)\nusing this:\n  M \\<le> m\n  M \\<le> n\n  \\<forall>m\\<ge>M.\n     \\<forall>n\\<ge>M. \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<parallel>X m - X n\\<parallel> < \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "moreover"], ["proof (state)\nthis:\n  \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "have \"\\<parallel>X m - X n\\<parallel> \\<ge> \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\n    \\<le> \\<parallel>X m - X n\\<parallel>", "by(rule le_mtx_norm[of _ \"X m - X n\"], force)"], ["proof (state)\nthis:\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\n  \\<le> \\<parallel>X m - X n\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "moreover"], ["proof (state)\nthis:\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\n  \\<le> \\<parallel>X m - X n\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "have \"\\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> = \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> =\n    \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>", "by (simp add: mtx_vec_mult_minus_rdistrib)"], ["proof (state)\nthis:\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "moreover"], ["proof (state)\nthis:\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "have \"... = \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel> =\n    \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>", "by (simp add: mtx_vec_mult_minus_rdistrib mtx_vec_mult_canon)"], ["proof (state)\nthis:\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "ultimately"], ["proof (chain)\npicking this:\n  \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\n  \\<le> \\<parallel>X m - X n\\<parallel>\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>", "have \"\\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<parallel>X m - X n\\<parallel> < \\<epsilon>\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel>\n  \\<le> \\<parallel>X m - X n\\<parallel>\n  \\<parallel>(X m - X n) *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel>\n  \\<parallel>X m *\\<^sub>V \\<e> i - X n *\\<^sub>V \\<e> i\\<parallel> =\n  \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\n\ngoal (1 subgoal):\n 1. \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\n    < \\<epsilon>", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\n  < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "}"], ["proof (state)\nthis:\n  \\<lbrakk>M \\<le> ?m2; M \\<le> ?n2\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>\\<c>\\<o>\\<l> i (X ?m2) -\n                               \\<c>\\<o>\\<l> i (X ?n2)\\<parallel>\n                    < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>e.\n       0 < e \\<Longrightarrow>\n       \\<exists>M.\n          \\<forall>m\\<ge>M.\n             \\<forall>n\\<ge>M.\n                \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                           \\<c>\\<o>\\<l> i (X n)\\<parallel>\n                < e", "thus \"\\<exists>M. \\<forall>m\\<ge>M. \\<forall>n\\<ge>M. \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<lbrakk>M \\<le> ?m2; M \\<le> ?n2\\<rbrakk>\n  \\<Longrightarrow> \\<parallel>\\<c>\\<o>\\<l> i (X ?m2) -\n                               \\<c>\\<o>\\<l> i (X ?n2)\\<parallel>\n                    < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>M.\n       \\<forall>m\\<ge>M.\n          \\<forall>n\\<ge>M.\n             \\<parallel>\\<c>\\<o>\\<l> i (X m) -\n                        \\<c>\\<o>\\<l> i (X n)\\<parallel>\n             < \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  \\<exists>M.\n     \\<forall>m\\<ge>M.\n        \\<forall>n\\<ge>M.\n           \\<parallel>\\<c>\\<o>\\<l> i (X m) - \\<c>\\<o>\\<l> i (X n)\\<parallel>\n           < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma col_convergence:\n  assumes \"\\<forall>i. (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\" \n  shows \"X \\<longlonglongrightarrow> to_mtx (transpose L)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<longlonglongrightarrow> to_mtx\n                                 (Finite_Cartesian_Product.transpose L)", "proof(unfold LIMSEQ_def dist_norm, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "let ?L = \"to_mtx (transpose L)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "let ?a = \"CARD('a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "fix \\<epsilon>::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "assume \"\\<epsilon> > 0\""], ["proof (state)\nthis:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "hence \"\\<epsilon> / ?a > 0\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon>\n\ngoal (1 subgoal):\n 1. 0 < \\<epsilon> / real CARD('a)", "by simp"], ["proof (state)\nthis:\n  0 < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "hence \"\\<forall>i. \\<exists> N. \\<forall>n\\<ge>N. \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel> < \\<epsilon>/?a\""], ["proof (prove)\nusing this:\n  0 < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n             < \\<epsilon> / real CARD('a)", "using assms"], ["proof (prove)\nusing this:\n  0 < \\<epsilon> / real CARD('a)\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n             < \\<epsilon> / real CARD('a)", "unfolding LIMSEQ_def dist_norm convergent_def"], ["proof (prove)\nusing this:\n  0 < \\<epsilon> / real CARD('a)\n  \\<forall>i r.\n     0 < r \\<longrightarrow>\n     (\\<exists>no.\n         \\<forall>n\\<ge>no.\n            \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel> < r)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>N.\n          \\<forall>n\\<ge>N.\n             \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n             < \\<epsilon> / real CARD('a)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a)", "obtain N where \"\\<forall>i. \\<forall>n\\<ge>N. \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel> < \\<epsilon>/?a\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>i n.\n           N \\<le> n \\<longrightarrow>\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finite_nat_minimal_witness[of \"\\<lambda> i n. \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel> < \\<epsilon>/?a\"]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a)\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a) \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>i n.\n        N \\<le> n \\<longrightarrow>\n        \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n        < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>i n.\n           N \\<le> n \\<longrightarrow>\n           \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n           < \\<epsilon> / real CARD('a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "also"], ["proof (state)\nthis:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "have \"\\<And>i n. (\\<c>\\<o>\\<l> i (X n) - L $ i) = (\\<c>\\<o>\\<l> i (X n - ?L))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<c>\\<o>\\<l> i (X n) - L $ i =\n       \\<c>\\<o>\\<l> i (X n - to_mtx (Finite_Cartesian_Product.transpose L))", "unfolding minus_sq_mtx_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i n.\n       \\<c>\\<o>\\<l> i (X n) - L $ i =\n       \\<c>\\<o>\\<l> i\n        (map_fun to_vec (map_fun to_vec to_mtx) (-) (X n)\n          (to_mtx (Finite_Cartesian_Product.transpose L)))", "by(transfer, simp add: transpose_def vec_eq_iff column_def)"], ["proof (state)\nthis:\n  \\<c>\\<o>\\<l> ?i (X ?n) - L $ ?i =\n  \\<c>\\<o>\\<l> ?i (X ?n - to_mtx (Finite_Cartesian_Product.transpose L))\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n     < \\<epsilon> / real CARD('a)\n  \\<c>\\<o>\\<l> ?i (X ?n) - L $ ?i =\n  \\<c>\\<o>\\<l> ?i (X ?n - to_mtx (Finite_Cartesian_Product.transpose L))", "have N_def:\"\\<forall>i. \\<forall>n\\<ge>N. \\<parallel>\\<c>\\<o>\\<l> i (X n - ?L)\\<parallel> < \\<epsilon>/?a\""], ["proof (prove)\nusing this:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i (X n) - L $ i\\<parallel>\n     < \\<epsilon> / real CARD('a)\n  \\<c>\\<o>\\<l> ?i (X ?n) - L $ ?i =\n  \\<c>\\<o>\\<l> ?i (X ?n - to_mtx (Finite_Cartesian_Product.transpose L))\n\ngoal (1 subgoal):\n 1. \\<forall>i n.\n       N \\<le> n \\<longrightarrow>\n       \\<parallel>\\<c>\\<o>\\<l> i\n                   (X n -\n                    to_mtx\n                     (Finite_Cartesian_Product.transpose L))\\<parallel>\n       < \\<epsilon> / real CARD('a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "have \"\\<forall>n\\<ge>N. \\<parallel>X n - ?L\\<parallel> < \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n\\<ge>N.\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "proof(rule allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "assume \"N \\<le> n\""], ["proof (state)\nthis:\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "hence \"\\<forall> i. \\<parallel>\\<c>\\<o>\\<l> i (X n - ?L)\\<parallel> < \\<epsilon>/?a\""], ["proof (prove)\nusing this:\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<parallel>\\<c>\\<o>\\<l> i\n                   (X n -\n                    to_mtx\n                     (Finite_Cartesian_Product.transpose L))\\<parallel>\n       < \\<epsilon> / real CARD('a)", "using N_def"], ["proof (prove)\nusing this:\n  N \\<le> n\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<parallel>\\<c>\\<o>\\<l> i\n                   (X n -\n                    to_mtx\n                     (Finite_Cartesian_Product.transpose L))\\<parallel>\n       < \\<epsilon> / real CARD('a)", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "hence \"(\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i (X n - ?L)\\<parallel>) < (\\<Sum>(i::'a)\\<in>UNIV. \\<epsilon>/?a)\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n     < \\<epsilon> / real CARD('a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV.\n       \\<parallel>\\<c>\\<o>\\<l> i\n                   (X n -\n                    to_mtx\n                     (Finite_Cartesian_Product.transpose L))\\<parallel>)\n    < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))", "using sum_strict_mono[of _ \"\\<lambda>i. \\<parallel>\\<c>\\<o>\\<l> i (X n - ?L)\\<parallel>\"]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n     < \\<epsilon> / real CARD('a)\n  \\<lbrakk>finite ?A; ?A \\<noteq> {};\n   \\<And>x.\n      x \\<in> ?A \\<Longrightarrow>\n      \\<parallel>\\<c>\\<o>\\<l> x\n                  (X n -\n                   to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>\n      < ?g x\\<rbrakk>\n  \\<Longrightarrow> (\\<Sum>i\\<in>?A.\n                       \\<parallel>\\<c>\\<o>\\<l> i\n                                   (X n -\n                                    to_mtx\n                                     (Finite_Cartesian_Product.transpose\n L))\\<parallel>)\n                    < sum ?g ?A\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV.\n       \\<parallel>\\<c>\\<o>\\<l> i\n                   (X n -\n                    to_mtx\n                     (Finite_Cartesian_Product.transpose L))\\<parallel>)\n    < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))", "by force"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "have \"\\<parallel>X n - ?L\\<parallel> \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i (X n - ?L)\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>X n -\n               to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n    \\<le> (\\<Sum>i\\<in>UNIV.\n             \\<parallel>\\<c>\\<o>\\<l> i\n                         (X n -\n                          to_mtx\n                           (Finite_Cartesian_Product.transpose\n                             L))\\<parallel>)", "using sq_mtx_norm_le_sum_col"], ["proof (prove)\nusing this:\n  \\<parallel>?A\\<parallel>\n  \\<le> (\\<Sum>i\\<in>UNIV. \\<parallel>\\<c>\\<o>\\<l> i ?A\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<parallel>X n -\n               to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n    \\<le> (\\<Sum>i\\<in>UNIV.\n             \\<parallel>\\<c>\\<o>\\<l> i\n                         (X n -\n                          to_mtx\n                           (Finite_Cartesian_Product.transpose\n                             L))\\<parallel>)", "by blast"], ["proof (state)\nthis:\n  \\<parallel>X n - to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n  \\<le> (\\<Sum>i\\<in>UNIV.\n           \\<parallel>\\<c>\\<o>\\<l> i\n                       (X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L))\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "moreover"], ["proof (state)\nthis:\n  \\<parallel>X n - to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n  \\<le> (\\<Sum>i\\<in>UNIV.\n           \\<parallel>\\<c>\\<o>\\<l> i\n                       (X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L))\\<parallel>)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "have \"(\\<Sum>(i::'a)\\<in>UNIV. \\<epsilon>/?a) = \\<epsilon>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a)) = \\<epsilon>", "by force"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a)) = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       N \\<le> n \\<Longrightarrow>\n       \\<parallel>X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n       < \\<epsilon>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>UNIV.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))\n  \\<parallel>X n - to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n  \\<le> (\\<Sum>i\\<in>UNIV.\n           \\<parallel>\\<c>\\<o>\\<l> i\n                       (X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a)) = \\<epsilon>", "show \"\\<parallel>X n - ?L\\<parallel> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>UNIV.\n     \\<parallel>\\<c>\\<o>\\<l> i\n                 (X n -\n                  to_mtx (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  < (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a))\n  \\<parallel>X n - to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n  \\<le> (\\<Sum>i\\<in>UNIV.\n           \\<parallel>\\<c>\\<o>\\<l> i\n                       (X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L))\\<parallel>)\n  (\\<Sum>i\\<in>UNIV. \\<epsilon> / real CARD('a)) = \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<parallel>X n -\n               to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n    < \\<epsilon>", "by linarith"], ["proof (state)\nthis:\n  \\<parallel>X n - to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n  < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>N.\n     \\<parallel>X n -\n                to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n     < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<parallel>X n -\n                        to_mtx\n                         (Finite_Cartesian_Product.transpose L)\\<parallel>\n             < r", "thus \"\\<exists>no. \\<forall>n\\<ge>no. \\<parallel>X n - ?L\\<parallel> < \\<epsilon>\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>N.\n     \\<parallel>X n -\n                to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n     < \\<epsilon>\n\ngoal (1 subgoal):\n 1. \\<exists>no.\n       \\<forall>n\\<ge>no.\n          \\<parallel>X n -\n                     to_mtx\n                      (Finite_Cartesian_Product.transpose L)\\<parallel>\n          < \\<epsilon>", "by blast"], ["proof (state)\nthis:\n  \\<exists>no.\n     \\<forall>n\\<ge>no.\n        \\<parallel>X n -\n                   to_mtx (Finite_Cartesian_Product.transpose L)\\<parallel>\n        < \\<epsilon>\n\ngoal:\nNo subgoals!", "qed"], ["", "instance sq_mtx :: (finite) banach"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a sq_mtx, banach_class)", "proof(standard)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "fix X :: \"nat \\<Rightarrow> 'a sq_mtx\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "assume \"Cauchy X\""], ["proof (state)\nthis:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "hence \"\\<And>i. Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))\""], ["proof (prove)\nusing this:\n  Cauchy X\n\ngoal (1 subgoal):\n 1. \\<And>i. Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))", "using Cauchy_cols"], ["proof (prove)\nusing this:\n  Cauchy X\n  Cauchy ?X \\<Longrightarrow> Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> ?i (?X n))\n\ngoal (1 subgoal):\n 1. \\<And>i. Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> i (X n))", "by blast"], ["proof (state)\nthis:\n  Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> ?i (X n))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "hence obs: \"\\<forall>i. \\<exists>! L. (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L\""], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> ?i (X n))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>!L.\n          (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L", "using Cauchy_convergent convergent_def LIMSEQ_unique"], ["proof (prove)\nusing this:\n  Cauchy (\\<lambda>n. \\<c>\\<o>\\<l> ?i (X n))\n  Cauchy ?X \\<Longrightarrow> convergent ?X\n  convergent ?X = (\\<exists>L. ?X \\<longlonglongrightarrow> L)\n  \\<lbrakk>?X \\<longlonglongrightarrow> ?a;\n   ?X \\<longlonglongrightarrow> ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>!L.\n          (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>!L.\n        (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "define L where \"L = (\\<chi> i. lim (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)))\""], ["proof (state)\nthis:\n  L = (\\<chi>i. lim (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)))\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "hence \"\\<forall>i. (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\""], ["proof (prove)\nusing this:\n  L = (\\<chi>i. lim (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i", "using obs theI_unique[of \"\\<lambda>L. (\\<lambda>n. \\<c>\\<o>\\<l> _ (X n)) \\<longlonglongrightarrow> L\" \"L $ _\"]"], ["proof (prove)\nusing this:\n  L = (\\<chi>i. lim (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)))\n  \\<forall>i.\n     \\<exists>!L.\n        (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L\n  \\<exists>!x.\n     (\\<lambda>n. \\<c>\\<o>\\<l> ?uu3 (X n))\n     \\<longlonglongrightarrow> x \\<Longrightarrow>\n  (\\<lambda>n. \\<c>\\<o>\\<l> ?uu3 (X n))\n  \\<longlonglongrightarrow> L $ ?uua3 =\n  (L $ ?uua3 =\n   (THE L.\n       (\\<lambda>n. \\<c>\\<o>\\<l> ?uu3 (X n)) \\<longlonglongrightarrow> L))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i", "by (simp add: lim_def)"], ["proof (state)\nthis:\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\n\ngoal (1 subgoal):\n 1. \\<And>X. Cauchy X \\<Longrightarrow> convergent X", "thus \"convergent X\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\n\ngoal (1 subgoal):\n 1. convergent X", "using col_convergence"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (?X n))\n     \\<longlonglongrightarrow> ?L $ i \\<Longrightarrow>\n  ?X \\<longlonglongrightarrow> to_mtx\n                                (Finite_Cartesian_Product.transpose ?L)\n\ngoal (1 subgoal):\n 1. convergent X", "unfolding convergent_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (X n)) \\<longlonglongrightarrow> L $ i\n  \\<forall>i.\n     (\\<lambda>n. \\<c>\\<o>\\<l> i (?X n))\n     \\<longlonglongrightarrow> ?L $ i \\<Longrightarrow>\n  ?X \\<longlonglongrightarrow> to_mtx\n                                (Finite_Cartesian_Product.transpose ?L)\n\ngoal (1 subgoal):\n 1. \\<exists>L. X \\<longlonglongrightarrow> L", "by blast"], ["proof (state)\nthis:\n  convergent X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_similiar_sq_mtx_diag_eq:\n  assumes \"mtx_invertible P\"\n      and \"A = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\"\n    shows \"exp A = P\\<^sup>-\\<^sup>1 * exp (\\<d>\\<i>\\<a>\\<g> i. f i) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp A = P\\<^sup>-\\<^sup>1 * exp (\\<d>\\<i>\\<a>\\<g> i. f i) * P", "proof(unfold exp_def power_similiar_sq_mtx_diag_eq[OF assms])"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "have \"(\\<Sum>n. P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R fact n) = \n  (\\<Sum>n. P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) * P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n        P)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n      P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n      P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "have \"... = (\\<Sum>n. P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n        P) =\n    (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n    P", "apply(subst suminf_multr[OF bounded_linear.summable[OF bounded_linear_mult_right]])"], ["proof (prove)\ngoal (2 subgoals):\n 1. summable (\\<lambda>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)\n 2. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n    P =\n    (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n    P", "unfolding power_sq_mtx_diag[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. summable (\\<lambda>n. (\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n)\n 2. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n)) *\n    P =\n    (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n)) *\n    P", "by (simp_all add: summable_exp_generic)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n      P) =\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 *\n      ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n  P\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "also"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n      P) =\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 *\n      ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n  P\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "have \"... = P\\<^sup>-\\<^sup>1 * (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 *\n        ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n    P =\n    P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n    P", "apply(subst suminf_mult[of _ \"P\\<^sup>-\\<^sup>1\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. summable (\\<lambda>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)\n 2. P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n    P =\n    P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n    P", "unfolding power_sq_mtx_diag[symmetric]"], ["proof (prove)\ngoal (2 subgoals):\n 1. summable (\\<lambda>n. (\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n)\n 2. P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n) *\n    P =\n    P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i) ^ n /\\<^sub>R fact n) *\n    P", "by (simp_all add: summable_exp_generic)"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 *\n      ((\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n)) *\n  P =\n  P\\<^sup>-\\<^sup>1 *\n  (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n  P\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  P\\<^sup>-\\<^sup>1 *\n  (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n  P", "show \"(\\<Sum>n. P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R fact n) = \n  P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P\""], ["proof (prove)\nusing this:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  P\\<^sup>-\\<^sup>1 *\n  (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n  P\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P", "unfolding power_sq_mtx_diag"], ["proof (prove)\nusing this:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  P\\<^sup>-\\<^sup>1 *\n  (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n  P\n\ngoal (1 subgoal):\n 1. (\\<Sum>n.\n        P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n        fact n) =\n    P\\<^sup>-\\<^sup>1 *\n    (\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) /\\<^sub>R fact n) *\n    P", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>n.\n      P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i ^ n) * P /\\<^sub>R\n      fact n) =\n  P\\<^sup>-\\<^sup>1 * (\\<Sum>n. sq_mtx_diag f ^ n /\\<^sub>R fact n) * P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_similiar_sq_mtx_diag:\n  assumes \"A \\<sim> sq_mtx_diag f\"\n  shows \"exp A \\<sim> exp (sq_mtx_diag f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp A \\<sim> exp (sq_mtx_diag f)", "using assms exp_similiar_sq_mtx_diag_eq"], ["proof (prove)\nusing this:\n  A \\<sim> sq_mtx_diag f\n  \\<lbrakk>mtx_invertible ?P;\n   ?A = ?P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. ?f i) * ?P\\<rbrakk>\n  \\<Longrightarrow> exp ?A =\n                    ?P\\<^sup>-\\<^sup>1 * exp (\\<d>\\<i>\\<a>\\<g> i. ?f i) * ?P\n\ngoal (1 subgoal):\n 1. exp A \\<sim> exp (sq_mtx_diag f)", "unfolding similar_sq_mtx_def"], ["proof (prove)\nusing this:\n  \\<exists>P.\n     mtx_invertible P \\<and> A = P\\<^sup>-\\<^sup>1 * sq_mtx_diag f * P\n  \\<lbrakk>mtx_invertible ?P;\n   ?A = ?P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. ?f i) * ?P\\<rbrakk>\n  \\<Longrightarrow> exp ?A =\n                    ?P\\<^sup>-\\<^sup>1 * exp (\\<d>\\<i>\\<a>\\<g> i. ?f i) * ?P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       mtx_invertible P \\<and>\n       exp A = P\\<^sup>-\\<^sup>1 * exp (sq_mtx_diag f) * P", "by blast"], ["", "lemma suminf_sq_mtx_diag:\n  assumes \"\\<forall>i. (\\<lambda>n. f n i) sums (suminf (\\<lambda>n. f n i))\"\n  shows \"(\\<Sum>n. (\\<d>\\<i>\\<a>\\<g> i. f n i)) = (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n. f n i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. \\<d>\\<i>\\<a>\\<g> i. f n i) =\n    (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n. f n i)", "proof(rule suminfI, unfold sums_def LIMSEQ_iff, clarsimp simp: norm_sq_mtx_diag)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "let ?g = \"\\<lambda>n i. \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "fix r::real"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "assume \"r > 0\""], ["proof (state)\nthis:\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "have \"\\<forall>i. \\<exists>no. \\<forall>n\\<ge>no. ?g n i < r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "using assms \\<open>r > 0\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>i. (\\<lambda>n. f n i) sums (\\<Sum>n. f n i)\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "unfolding sums_def LIMSEQ_iff"], ["proof (prove)\nusing this:\n  \\<forall>i r.\n     0 < r \\<longrightarrow>\n     (\\<exists>no.\n         \\<forall>n\\<ge>no.\n            \\<parallel>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<parallel> < r)\n  0 < r\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "by clarsimp"], ["proof (state)\nthis:\n  \\<forall>i.\n     \\<exists>no.\n        \\<forall>n\\<ge>no.\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "then"], ["proof (chain)\npicking this:\n  \\<forall>i.\n     \\<exists>no.\n        \\<forall>n\\<ge>no.\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "obtain N where key: \"\\<forall>i. \\<forall>n\\<ge>N. ?g n i < r\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>no.\n        \\<forall>n\\<ge>no.\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>i n.\n           N \\<le> n \\<longrightarrow>\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n           < r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using finite_nat_minimal_witness[of \"\\<lambda>i n. ?g n i < r\"]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     \\<exists>no.\n        \\<forall>n\\<ge>no.\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n  \\<forall>i.\n     \\<exists>N.\n        \\<forall>n\\<ge>N.\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n           < r \\<Longrightarrow>\n  \\<exists>N.\n     \\<forall>i n.\n        N \\<le> n \\<longrightarrow>\n        \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        \\<forall>i n.\n           N \\<le> n \\<longrightarrow>\n           \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n           < r \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "{"], ["proof (state)\nthis:\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "assume \"n \\<ge> N\""], ["proof (state)\nthis:\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "obtain i where i_def: \"Max {x. \\<exists>i. x = ?g n i} = ?g n i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        Max {x. \\<exists>i.\n                   x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} =\n        \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using cMax_finite_ex[of \"{x. \\<exists>i. x = ?g n i}\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite\n            {x. \\<exists>i.\n                   x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>};\n   {x. \\<exists>i.\n          x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} \\<noteq>\n   {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>{x. \\<exists>i.\n    x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}.\n                       Max {x. \\<exists>i.\n                                  x =\n                                  \\<bar>(\\<Sum>n<n. f n i) -\n  (\\<Sum>n. f n i)\\<bar>} =\n                       x\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        Max {x. \\<exists>i.\n                   x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} =\n        \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Max {x. \\<exists>i.\n             x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} =\n  \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "hence \"?g n i < r\""], ["proof (prove)\nusing this:\n  Max {x. \\<exists>i.\n             x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} =\n  \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n\ngoal (1 subgoal):\n 1. \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "using key \\<open>n \\<ge> N\\<close>"], ["proof (prove)\nusing this:\n  Max {x. \\<exists>i.\n             x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>} =\n  \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>\n  \\<forall>i n.\n     N \\<le> n \\<longrightarrow>\n     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n  N \\<le> n\n\ngoal (1 subgoal):\n 1. \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r", "by blast"], ["proof (state)\nthis:\n  \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "hence \"Max {x. \\<exists>i. x = ?g n i} < r\""], ["proof (prove)\nusing this:\n  \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar> < r\n\ngoal (1 subgoal):\n 1. Max {x. \\<exists>i.\n               x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n    < r", "unfolding i_def[symmetric]"], ["proof (prove)\nusing this:\n  Max {x. \\<exists>i. x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n  < r\n\ngoal (1 subgoal):\n 1. Max {x. \\<exists>i.\n               x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n    < r", "."], ["proof (state)\nthis:\n  Max {x. \\<exists>i. x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n  < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "}"], ["proof (state)\nthis:\n  N \\<le> ?n2 \\<Longrightarrow>\n  Max {x. \\<exists>i.\n             x = \\<bar>(\\<Sum>n<?n2. f n i) - (\\<Sum>n. f n i)\\<bar>}\n  < r\n\ngoal (1 subgoal):\n 1. \\<And>r.\n       0 < r \\<Longrightarrow>\n       \\<exists>no.\n          \\<forall>n\\<ge>no.\n             Max {uu_.\n                  \\<exists>i.\n                     uu_ =\n                     \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n             < r", "thus \"\\<exists>N. \\<forall>n\\<ge>N. Max {x. \\<exists>i. x = ?g n i} < r\""], ["proof (prove)\nusing this:\n  N \\<le> ?n2 \\<Longrightarrow>\n  Max {x. \\<exists>i.\n             x = \\<bar>(\\<Sum>n<?n2. f n i) - (\\<Sum>n. f n i)\\<bar>}\n  < r\n\ngoal (1 subgoal):\n 1. \\<exists>N.\n       \\<forall>n\\<ge>N.\n          Max {x. \\<exists>i.\n                     x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n          < r", "by blast"], ["proof (state)\nthis:\n  \\<exists>N.\n     \\<forall>n\\<ge>N.\n        Max {x. \\<exists>i.\n                   x = \\<bar>(\\<Sum>n<n. f n i) - (\\<Sum>n. f n i)\\<bar>}\n        < r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_sq_mtx_diag: \"exp (sq_mtx_diag f) = (\\<d>\\<i>\\<a>\\<g> i. exp (f i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (sq_mtx_diag f) = (\\<d>\\<i>\\<a>\\<g> i. exp (f i))", "apply(unfold exp_def, simp add: power_sq_mtx_diag scaleR_sq_mtx_diag)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. \\<d>\\<i>\\<a>\\<g> i. inverse (fact n) * f i ^ n) =\n    (\\<d>\\<i>\\<a>\\<g> i. \\<Sum>n. inverse (fact n) * f i ^ n)", "apply(rule suminf_sq_mtx_diag)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<lambda>n. inverse (fact n) * f i ^ n) sums\n       (\\<Sum>n. inverse (fact n) * f i ^ n)", "using exp_converges[of \"f _\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>n. f ?uu3 ^ n /\\<^sub>R fact n) sums exp (f ?uu3)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<lambda>n. inverse (fact n) * f i ^ n) sums\n       (\\<Sum>n. inverse (fact n) * f i ^ n)", "unfolding sums_def LIMSEQ_iff exp_def"], ["proof (prove)\nusing this:\n  \\<forall>r>0.\n     \\<exists>no.\n        \\<forall>n\\<ge>no.\n           \\<parallel>(\\<Sum>n<n. f ?uu3 ^ n /\\<^sub>R fact n) -\n                      (\\<Sum>n. f ?uu3 ^ n /\\<^sub>R fact n)\\<parallel>\n           < r\n\ngoal (1 subgoal):\n 1. \\<forall>i r.\n       0 < r \\<longrightarrow>\n       (\\<exists>no.\n           \\<forall>n\\<ge>no.\n              \\<parallel>(\\<Sum>n<n. inverse (fact n) * f i ^ n) -\n                         (\\<Sum>n. inverse (fact n) * f i ^ n)\\<parallel>\n              < r)", "by force"], ["", "lemma exp_scaleR_diagonal1:\n  assumes \"mtx_invertible P\" and \"A = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\"\n    shows \"exp (t *\\<^sub>R A) = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "have \"exp (t *\\<^sub>R A) = exp (P\\<^sup>-\\<^sup>1 * (t *\\<^sub>R sq_mtx_diag f) * P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P)", "using assms"], ["proof (prove)\nusing this:\n  mtx_invertible P\n  A = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\n\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P)", "by simp"], ["proof (state)\nthis:\n  exp (t *\\<^sub>R A) =\n  exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P)\n\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "also"], ["proof (state)\nthis:\n  exp (t *\\<^sub>R A) =\n  exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P)\n\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "have \"... = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "by (metis assms(1) exp_similiar_sq_mtx_diag_eq exp_sq_mtx_diag scaleR_sq_mtx_diag)"], ["proof (state)\nthis:\n  exp (P\\<^sup>-\\<^sup>1 * t *\\<^sub>R sq_mtx_diag f * P) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\n\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "finally"], ["proof (chain)\npicking this:\n  exp (t *\\<^sub>R A) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "show \"exp (t *\\<^sub>R A) = P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\""], ["proof (prove)\nusing this:\n  exp (t *\\<^sub>R A) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\n\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P", "."], ["proof (state)\nthis:\n  exp (t *\\<^sub>R A) =\n  P\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exp_scaleR_diagonal2:\n  assumes \"mtx_invertible P\" and \"A = P * (\\<d>\\<i>\\<a>\\<g> i. f i) * P\\<^sup>-\\<^sup>1\"\n    shows \"exp (t *\\<^sub>R A) = P * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\\<^sup>-\\<^sup>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P * (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) * P\\<^sup>-\\<^sup>1", "apply(subst sq_mtx_inv_idempotent[OF assms(1), symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. exp (t *\\<^sub>R A) =\n    P\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 *\n    (\\<d>\\<i>\\<a>\\<g> i. exp (t * f i)) *\n    P\\<^sup>-\\<^sup>1", "apply(rule exp_scaleR_diagonal1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mtx_invertible P\\<^sup>-\\<^sup>1\n 2. A =\n    P\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 * (\\<d>\\<i>\\<a>\\<g> i. f i) *\n    P\\<^sup>-\\<^sup>1", "by (simp_all add: assms)"], ["", "subsection \\<open> Examples \\<close>"], ["", "definition \"mtx A = to_mtx (vector (map vector A))\""], ["", "lemma vector_nth_eq: \"(vector A) $ i = foldr (\\<lambda>x f n. (f (n + 1))(n := x)) A (\\<lambda>n x. 0) 1 i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector A $ i =\n    foldr (\\<lambda>x f n. (f (n + (1::'b)))(n := x)) A\n     (\\<lambda>n x. 0::'a) (1::'b) i", "unfolding vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vec_lambda\n     (foldr (\\<lambda>x f n. (f (n + (1::'b)))(n := x)) A\n       (\\<lambda>n x. 0::'a) (1::'b)) $\n    i =\n    foldr (\\<lambda>x f n. (f (n + (1::'b)))(n := x)) A\n     (\\<lambda>n x. 0::'a) (1::'b) i", "by simp"], ["", "lemma mtx_ith_eq[simp]: \"mtx A $$ i $ j = foldr (\\<lambda>x f n. (f (n + 1))(n := x))\n  (map (\\<lambda>l. vec_lambda (foldr (\\<lambda>x f n. (f (n + 1))(n := x)) l (\\<lambda>n x. 0) 1)) A) (\\<lambda>n x. 0) 1 i $ j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx A $$ i $ j =\n    foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x))\n     (map (\\<lambda>l.\n              vec_lambda\n               (foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x)) l\n                 (\\<lambda>n x. 0) (1::'a)))\n       A)\n     (\\<lambda>n x. 0) (1::'a) i $\n    j", "unfolding mtx_def vector_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx\n     (vec_lambda\n       (foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x))\n         (map (\\<lambda>l.\n                  vec_lambda\n                   (foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x)) l\n                     (\\<lambda>n x. 0) (1::'a)))\n           A)\n         (\\<lambda>n x. 0) (1::'a))) $$\n    i $\n    j =\n    foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x))\n     (map (\\<lambda>l.\n              vec_lambda\n               (foldr (\\<lambda>x f n. (f (n + (1::'a)))(n := x)) l\n                 (\\<lambda>n x. 0) (1::'a)))\n       A)\n     (\\<lambda>n x. 0) (1::'a) i $\n    j", "by (simp add: vector_nth_eq)"], ["", "subsubsection \\<open> 2x2 matrices \\<close>"], ["", "lemma mtx2_eq_iff: \"(mtx \n  ([a1, b1] # \n   [c1, d1] # []) :: 2 sq_mtx) = mtx \n  ([a2, b2] # \n   [c2, d2] # []) \\<longleftrightarrow> a1 = a2 \\<and> b1 = b2 \\<and> c1 = c2 \\<and> d1 = d2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtx [[a1, b1], [c1, d1]] = mtx [[a2, b2], [c2, d2]]) =\n    (a1 = a2 \\<and> b1 = b2 \\<and> c1 = c2 \\<and> d1 = d2)", "apply(simp add: sq_mtx_eq_iff, safe)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    a1 = a2\n 2. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    b1 = b2\n 3. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    c1 = c2\n 4. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    d1 = d2", "using exhaust_2"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2\n\ngoal (4 subgoals):\n 1. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    a1 = a2\n 2. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    b1 = b2\n 3. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    c1 = c2\n 4. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> d1 = d2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> c1 = c2))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        i = 1 \\<longrightarrow>\n        (\\<forall>j.\n            (j = 2 \\<longrightarrow> b1 = b2) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             j = 1 \\<longrightarrow> a1 = a2))) \\<Longrightarrow>\n    d1 = d2", "by force+"], ["", "lemma mtx2_to_mtx: \"mtx \n  ([a, b] # \n   [c, d] # []) = \n  to_mtx (\\<chi> i j::2. if i=1 \\<and> j=1 then a \n  else (if i=1 \\<and> j=2 then b \n  else (if i=2 \\<and> j=1 then c \n  else d)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a, b], [c, d]] =\n    to_mtx\n     (\\<chi>i j.\n         if i = 1 \\<and> j = 1 then a\n         else if i = 1 \\<and> j = 2 then b\n              else if i = 2 \\<and> j = 1 then c else d)", "apply(subst sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       mtx [[a, b], [c, d]] $$ i $ j =\n       to_mtx\n        (\\<chi>i j.\n            if i = 1 \\<and> j = 1 then a\n            else if i = 1 \\<and> j = 2 then b\n                 else if i = 2 \\<and> j = 1 then c else d) $$\n       i $\n       j", "using exhaust_2"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2\n\ngoal (1 subgoal):\n 1. \\<forall>i j.\n       mtx [[a, b], [c, d]] $$ i $ j =\n       to_mtx\n        (\\<chi>i j.\n            if i = 1 \\<and> j = 1 then a\n            else if i = 1 \\<and> j = 2 then b\n                 else if i = 2 \\<and> j = 1 then c else d) $$\n       i $\n       j", "by force"], ["", "abbreviation diag2 :: \"real \\<Rightarrow> real \\<Rightarrow> 2 sq_mtx\" \n  where \"diag2 \\<iota>\\<^sub>1 \\<iota>\\<^sub>2 \\<equiv> mtx \n   ([\\<iota>\\<^sub>1, 0] # \n    [0, \\<iota>\\<^sub>2] # [])\""], ["", "lemma diag2_eq: \"diag2 (\\<iota> 1) (\\<iota> 2) = (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag2 (\\<iota> 1) (\\<iota> 2) = (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)", "apply(simp add: sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 2 \\<longrightarrow>\n            (j = 1 \\<longrightarrow> axis 2 (\\<iota> 2) $ 1 = 0) \\<and>\n            (j \\<noteq> 1 \\<longrightarrow>\n             axis 2 (\\<iota> 2) $ j = 0))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        (i = 1 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 1 \\<longrightarrow>\n             axis 1 (\\<iota> 1) $ j = 0)) \\<and>\n        (i \\<noteq> 1 \\<longrightarrow>\n         (\\<forall>j. axis i (\\<iota> i) $ j = 0)))", "using exhaust_2"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 2 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 2 \\<longrightarrow>\n            (j = 1 \\<longrightarrow> axis 2 (\\<iota> 2) $ 1 = 0) \\<and>\n            (j \\<noteq> 1 \\<longrightarrow>\n             axis 2 (\\<iota> 2) $ j = 0))) \\<and>\n       (i \\<noteq> 2 \\<longrightarrow>\n        (i = 1 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 1 \\<longrightarrow>\n             axis 1 (\\<iota> 1) $ j = 0)) \\<and>\n        (i \\<noteq> 1 \\<longrightarrow>\n         (\\<forall>j. axis i (\\<iota> i) $ j = 0)))", "by (force simp: axis_def)"], ["", "lemma one_mtx2: \"(1::2 sq_mtx) = diag2 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = diag2 1 1", "apply(subst sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j. 1 $$ i $ j = diag2 1 1 $$ i $ j", "using exhaust_2"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2\n\ngoal (1 subgoal):\n 1. \\<forall>i j. 1 $$ i $ j = diag2 1 1 $$ i $ j", "by force"], ["", "lemma zero_mtx2: \"(0::2 sq_mtx) = diag2 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = diag2 0 0", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma scaleR_mtx2: \"k *\\<^sub>R mtx \n  ([a, b] # \n   [c, d] # []) = mtx \n  ([k*a, k*b] # \n   [k*c, k*d] # [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k *\\<^sub>R mtx [[a, b], [c, d]] = mtx [[k * a, k * b], [k * c, k * d]]", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma uminus_mtx2: \"-mtx \n  ([a, b] # \n   [c, d] # []) = (mtx \n  ([-a, -b] # \n   [-c, -d] # [])::2 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - mtx [[a, b], [c, d]] = mtx [[- a, - b], [- c, - d]]", "by (simp add: sq_mtx_uminus_eq sq_mtx_eq_iff)"], ["", "lemma plus_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) + mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1+a2, b1+b2] # \n   [c1+c2, d1+d2] # []))::2 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a1, b1], [c1, d1]] + mtx [[a2, b2], [c2, d2]] =\n    mtx [[a1 + a2, b1 + b2], [c1 + c2, d1 + d2]]", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma minus_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) - mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1-a2, b1-b2] # \n   [c1-c2, d1-d2] # []))::2 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a1, b1], [c1, d1]] - mtx [[a2, b2], [c2, d2]] =\n    mtx [[a1 - a2, b1 - b2], [c1 - c2, d1 - d2]]", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma times_mtx2: \"mtx \n  ([a1, b1] # \n   [c1, d1] # []) * mtx \n  ([a2, b2] # \n   [c2, d2] # []) = ((mtx \n  ([a1*a2+b1*c2, a1*b2+b1*d2] # \n   [c1*a2+d1*c2, c1*b2+d1*d2] # []))::2 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a1, b1], [c1, d1]] * mtx [[a2, b2], [c2, d2]] =\n    mtx [[a1 * a2 + b1 * c2, a1 * b2 + b1 * d2],\n         [c1 * a2 + d1 * c2, c1 * b2 + d1 * d2]]", "unfolding sq_mtx_times_eq UNIV_2"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx\n     (\\<chi>i j.\n         \\<Sum>k\\<in>{1, 2}.\n           mtx [[a1, b1], [c1, d1]] $$ i $ k *\n           mtx [[a2, b2], [c2, d2]] $$ k $ j) =\n    mtx [[a1 * a2 + b1 * c2, a1 * b2 + b1 * d2],\n         [c1 * a2 + d1 * c2, c1 * b2 + d1 * d2]]", "by (simp add: sq_mtx_eq_iff)"], ["", "subsubsection \\<open> 3x3 matrices \\<close>"], ["", "lemma mtx3_to_mtx: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) = \n  to_mtx (\\<chi> i j::3. if i=1 \\<and> j=1 then a\\<^sub>1\\<^sub>1\n  else (if i=1 \\<and> j=2 then a\\<^sub>1\\<^sub>2 \n  else (if i=1 \\<and> j=3 then a\\<^sub>1\\<^sub>3 \n  else (if i=2 \\<and> j=1 then a\\<^sub>2\\<^sub>1\n  else (if i=2 \\<and> j=2 then a\\<^sub>2\\<^sub>2 \n  else (if i=2 \\<and> j=3 then a\\<^sub>2\\<^sub>3 \n  else (if i=3 \\<and> j=1 then a\\<^sub>3\\<^sub>1 \n  else (if i=3 \\<and> j=2 then a\\<^sub>3\\<^sub>2 \n  else a\\<^sub>3\\<^sub>3))))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3]] =\n    to_mtx\n     (\\<chi>i j.\n         if i = 1 \\<and> j = 1 then a\\<^sub>1\\<^sub>1\n         else if i = 1 \\<and> j = 2 then a\\<^sub>1\\<^sub>2\n              else if i = 1 \\<and> j = 3 then a\\<^sub>1\\<^sub>3\n                   else if i = 2 \\<and> j = 1 then a\\<^sub>2\\<^sub>1\n                        else if i = 2 \\<and> j = 2 then a\\<^sub>2\\<^sub>2\n                             else if i = 2 \\<and> j = 3\n                                  then a\\<^sub>2\\<^sub>3\n                                  else if i = 3 \\<and> j = 1\n then a\\<^sub>3\\<^sub>1\n else if i = 3 \\<and> j = 2 then a\\<^sub>3\\<^sub>2 else a\\<^sub>3\\<^sub>3)", "apply(simp add: sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 3 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 3 \\<longrightarrow>\n            j \\<noteq> 2 \\<longrightarrow>\n            j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n       (i \\<noteq> 3 \\<longrightarrow>\n        (i = 2 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 3 \\<longrightarrow>\n             j \\<noteq> 2 \\<longrightarrow>\n             j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n        (i \\<noteq> 2 \\<longrightarrow>\n         (i = 1 \\<longrightarrow>\n          (\\<forall>j.\n              j \\<noteq> 3 \\<longrightarrow>\n              j \\<noteq> 2 \\<longrightarrow>\n              j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n         (i \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)))", "using exhaust_3"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 3 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 3 \\<longrightarrow>\n            j \\<noteq> 2 \\<longrightarrow>\n            j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n       (i \\<noteq> 3 \\<longrightarrow>\n        (i = 2 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 3 \\<longrightarrow>\n             j \\<noteq> 2 \\<longrightarrow>\n             j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n        (i \\<noteq> 2 \\<longrightarrow>\n         (i = 1 \\<longrightarrow>\n          (\\<forall>j.\n              j \\<noteq> 3 \\<longrightarrow>\n              j \\<noteq> 2 \\<longrightarrow>\n              j \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)) \\<and>\n         (i \\<noteq> 1 \\<longrightarrow> a\\<^sub>3\\<^sub>3 = 0)))", "by force"], ["", "abbreviation diag3 :: \"real \\<Rightarrow> real \\<Rightarrow> real \\<Rightarrow> 3 sq_mtx\" \n  where \"diag3 \\<iota>\\<^sub>1 \\<iota>\\<^sub>2 \\<iota>\\<^sub>3 \\<equiv> mtx \n  ([\\<iota>\\<^sub>1, 0, 0] # \n   [0, \\<iota>\\<^sub>2, 0] # \n   [0, 0, \\<iota>\\<^sub>3] # [])\""], ["", "lemma diag3_eq: \"diag3 (\\<iota> 1) (\\<iota> 2) (\\<iota> 3) = (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag3 (\\<iota> 1) (\\<iota> 2) (\\<iota> 3) =\n    (\\<d>\\<i>\\<a>\\<g> i. \\<iota> i)", "apply(simp add: sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 3 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 3 \\<longrightarrow>\n            (j = 2 \\<longrightarrow> axis 3 (\\<iota> 3) $ 2 = 0) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             (j = 1 \\<longrightarrow> axis 3 (\\<iota> 3) $ 1 = 0) \\<and>\n             (j \\<noteq> 1 \\<longrightarrow>\n              axis 3 (\\<iota> 3) $ j = 0)))) \\<and>\n       (i \\<noteq> 3 \\<longrightarrow>\n        (i = 2 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 2 \\<longrightarrow>\n             (j = 1 \\<longrightarrow> axis 2 (\\<iota> 2) $ 1 = 0) \\<and>\n             (j \\<noteq> 1 \\<longrightarrow>\n              axis 2 (\\<iota> 2) $ j = 0))) \\<and>\n        (i \\<noteq> 2 \\<longrightarrow>\n         (i = 1 \\<longrightarrow>\n          (\\<forall>j.\n              (j = 2 \\<longrightarrow> axis 1 (\\<iota> 1) $ 2 = 0) \\<and>\n              (j \\<noteq> 2 \\<longrightarrow>\n               j \\<noteq> 1 \\<longrightarrow>\n               axis 1 (\\<iota> 1) $ j = 0))) \\<and>\n         (i \\<noteq> 1 \\<longrightarrow>\n          (\\<forall>j. axis i (\\<iota> i) $ j = 0))))", "using exhaust_3"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (i = 3 \\<longrightarrow>\n        (\\<forall>j.\n            j \\<noteq> 3 \\<longrightarrow>\n            (j = 2 \\<longrightarrow> axis 3 (\\<iota> 3) $ 2 = 0) \\<and>\n            (j \\<noteq> 2 \\<longrightarrow>\n             (j = 1 \\<longrightarrow> axis 3 (\\<iota> 3) $ 1 = 0) \\<and>\n             (j \\<noteq> 1 \\<longrightarrow>\n              axis 3 (\\<iota> 3) $ j = 0)))) \\<and>\n       (i \\<noteq> 3 \\<longrightarrow>\n        (i = 2 \\<longrightarrow>\n         (\\<forall>j.\n             j \\<noteq> 2 \\<longrightarrow>\n             (j = 1 \\<longrightarrow> axis 2 (\\<iota> 2) $ 1 = 0) \\<and>\n             (j \\<noteq> 1 \\<longrightarrow>\n              axis 2 (\\<iota> 2) $ j = 0))) \\<and>\n        (i \\<noteq> 2 \\<longrightarrow>\n         (i = 1 \\<longrightarrow>\n          (\\<forall>j.\n              (j = 2 \\<longrightarrow> axis 1 (\\<iota> 1) $ 2 = 0) \\<and>\n              (j \\<noteq> 2 \\<longrightarrow>\n               j \\<noteq> 1 \\<longrightarrow>\n               axis 1 (\\<iota> 1) $ j = 0))) \\<and>\n         (i \\<noteq> 1 \\<longrightarrow>\n          (\\<forall>j. axis i (\\<iota> i) $ j = 0))))", "by (force simp: axis_def)"], ["", "lemma one_mtx3: \"(1::3 sq_mtx) = diag3 1 1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = diag3 1 1 1", "apply(subst sq_mtx_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i j. 1 $$ i $ j = diag3 1 1 1 $$ i $ j", "using exhaust_3"], ["proof (prove)\nusing this:\n  ?x = 1 \\<or> ?x = 2 \\<or> ?x = 3\n\ngoal (1 subgoal):\n 1. \\<forall>i j. 1 $$ i $ j = diag3 1 1 1 $$ i $ j", "by force"], ["", "lemma zero_mtx3: \"(0::3 sq_mtx) = diag3 0 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = diag3 0 0 0", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma scaleR_mtx3: \"k *\\<^sub>R mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) = mtx \n  ([k*a\\<^sub>1\\<^sub>1, k*a\\<^sub>1\\<^sub>2, k*a\\<^sub>1\\<^sub>3] # \n   [k*a\\<^sub>2\\<^sub>1, k*a\\<^sub>2\\<^sub>2, k*a\\<^sub>2\\<^sub>3] # \n   [k*a\\<^sub>3\\<^sub>1, k*a\\<^sub>3\\<^sub>2, k*a\\<^sub>3\\<^sub>3] # [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k *\\<^sub>R\n    mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3]] =\n    mtx [[k * a\\<^sub>1\\<^sub>1, k * a\\<^sub>1\\<^sub>2,\n          k * a\\<^sub>1\\<^sub>3],\n         [k * a\\<^sub>2\\<^sub>1, k * a\\<^sub>2\\<^sub>2,\n          k * a\\<^sub>2\\<^sub>3],\n         [k * a\\<^sub>3\\<^sub>1, k * a\\<^sub>3\\<^sub>2,\n          k * a\\<^sub>3\\<^sub>3]]", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma plus_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) + mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1+b\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2+b\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3+b\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1+b\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2+b\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3+b\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1+b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2+b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3+b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3]] +\n    mtx [[b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3],\n         [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3],\n         [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3]] =\n    mtx [[a\\<^sub>1\\<^sub>1 + b\\<^sub>1\\<^sub>1,\n          a\\<^sub>1\\<^sub>2 + b\\<^sub>1\\<^sub>2,\n          a\\<^sub>1\\<^sub>3 + b\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1 + b\\<^sub>2\\<^sub>1,\n          a\\<^sub>2\\<^sub>2 + b\\<^sub>2\\<^sub>2,\n          a\\<^sub>2\\<^sub>3 + b\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1 + b\\<^sub>3\\<^sub>1,\n          a\\<^sub>3\\<^sub>2 + b\\<^sub>3\\<^sub>2,\n          a\\<^sub>3\\<^sub>3 + b\\<^sub>3\\<^sub>3]]", "by (subst sq_mtx_eq_iff) simp"], ["", "lemma minus_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) - mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1-b\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2-b\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3-b\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1-b\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2-b\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3-b\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1-b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2-b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3-b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3]] -\n    mtx [[b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3],\n         [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3],\n         [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3]] =\n    mtx [[a\\<^sub>1\\<^sub>1 - b\\<^sub>1\\<^sub>1,\n          a\\<^sub>1\\<^sub>2 - b\\<^sub>1\\<^sub>2,\n          a\\<^sub>1\\<^sub>3 - b\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1 - b\\<^sub>2\\<^sub>1,\n          a\\<^sub>2\\<^sub>2 - b\\<^sub>2\\<^sub>2,\n          a\\<^sub>2\\<^sub>3 - b\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1 - b\\<^sub>3\\<^sub>1,\n          a\\<^sub>3\\<^sub>2 - b\\<^sub>3\\<^sub>2,\n          a\\<^sub>3\\<^sub>3 - b\\<^sub>3\\<^sub>3]]", "by (simp add: sq_mtx_eq_iff)"], ["", "lemma times_mtx3: \"mtx \n  ([a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3] # []) * mtx \n  ([b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3] # \n   [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3] # \n   [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3] # []) = (mtx \n  ([a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>1\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>1\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>1\\<^sub>3*b\\<^sub>3\\<^sub>3] # \n   [a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>2\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>2\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>2\\<^sub>3*b\\<^sub>3\\<^sub>3] # \n   [a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>1+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>1+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>2+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>2+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>1*b\\<^sub>1\\<^sub>3+a\\<^sub>3\\<^sub>2*b\\<^sub>2\\<^sub>3+a\\<^sub>3\\<^sub>3*b\\<^sub>3\\<^sub>3] # [])::3 sq_mtx)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2, a\\<^sub>3\\<^sub>3]] *\n    mtx [[b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3],\n         [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3],\n         [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2, b\\<^sub>3\\<^sub>3]] =\n    mtx [[a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>3]]", "unfolding sq_mtx_times_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx\n     (\\<chi>i j.\n         \\<Sum>k\\<in>UNIV.\n           mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n                [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n                [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2,\n                 a\\<^sub>3\\<^sub>3]] $$\n           i $\n           k *\n           mtx [[b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3],\n                [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3],\n                [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2,\n                 b\\<^sub>3\\<^sub>3]] $$\n           k $\n           j) =\n    mtx [[a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>3]]", "unfolding UNIV_3"], ["proof (prove)\ngoal (1 subgoal):\n 1. to_mtx\n     (\\<chi>i j.\n         \\<Sum>k\\<in>{1, 2, 3}.\n           mtx [[a\\<^sub>1\\<^sub>1, a\\<^sub>1\\<^sub>2, a\\<^sub>1\\<^sub>3],\n                [a\\<^sub>2\\<^sub>1, a\\<^sub>2\\<^sub>2, a\\<^sub>2\\<^sub>3],\n                [a\\<^sub>3\\<^sub>1, a\\<^sub>3\\<^sub>2,\n                 a\\<^sub>3\\<^sub>3]] $$\n           i $\n           k *\n           mtx [[b\\<^sub>1\\<^sub>1, b\\<^sub>1\\<^sub>2, b\\<^sub>1\\<^sub>3],\n                [b\\<^sub>2\\<^sub>1, b\\<^sub>2\\<^sub>2, b\\<^sub>2\\<^sub>3],\n                [b\\<^sub>3\\<^sub>1, b\\<^sub>3\\<^sub>2,\n                 b\\<^sub>3\\<^sub>3]] $$\n           k $\n           j) =\n    mtx [[a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>1\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>1\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>1\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>2\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>2\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>2\\<^sub>3 * b\\<^sub>3\\<^sub>3],\n         [a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>1 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>1 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>1,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>2 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>2 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>2,\n          a\\<^sub>3\\<^sub>1 * b\\<^sub>1\\<^sub>3 +\n          a\\<^sub>3\\<^sub>2 * b\\<^sub>2\\<^sub>3 +\n          a\\<^sub>3\\<^sub>3 * b\\<^sub>3\\<^sub>3]]", "by (simp add: sq_mtx_eq_iff)"], ["", "end"]]}