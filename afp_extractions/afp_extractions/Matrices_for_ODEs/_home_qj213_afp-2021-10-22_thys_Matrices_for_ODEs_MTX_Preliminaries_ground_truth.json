{"file_name": "/home/qj213/afp-2021-10-22/thys/Matrices_for_ODEs/MTX_Preliminaries.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Matrices_for_ODEs", "problem_names": ["lemmas compact_imp_bdd_above = compact_imp_bounded[THEN bounded_imp_bdd_above]", "lemma comp_cont_image_spec: \"continuous_on T f \\<Longrightarrow> compact T \\<Longrightarrow> compact {f t |t. t \\<in> T}\"", "lemmas bdd_above_cont_comp_spec = compact_imp_bdd_above[OF comp_cont_image_spec]", "lemmas bdd_above_norm_cont_comp = continuous_on_norm[THEN bdd_above_cont_comp_spec]", "lemma open_cballE: \"t\\<^sub>0 \\<in> T \\<Longrightarrow> open T \\<Longrightarrow> \\<exists>e>0. cball t\\<^sub>0 e \\<subseteq> T\"", "lemma open_ballE: \"t\\<^sub>0 \\<in> T \\<Longrightarrow> open T \\<Longrightarrow> \\<exists>e>0. ball t\\<^sub>0 e \\<subseteq> T\"", "lemma funcset_UNIV: \"f \\<in> A \\<rightarrow> UNIV\"", "lemma finite_image_of_finite[simp]:\n  fixes f::\"'a::finite \\<Rightarrow> 'b\"\n  shows \"finite {x. \\<exists>i. x = f i}\"", "lemma finite_image_of_finite2:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::finite \\<Rightarrow> 'c\"\n  shows \"finite {f x y |x y. P x y}\"", "lemma finite_sum_univ_singleton: \"(sum g UNIV) = sum g {i::'a::finite} + sum g (UNIV - {i})\"", "lemma suminfI:\n  fixes f :: \"nat \\<Rightarrow> 'a::{t2_space,comm_monoid_add}\"\n  shows \"f sums k \\<Longrightarrow> suminf f = k\"", "lemma suminf_eq_sum:\n  fixes f :: \"nat \\<Rightarrow> ('a::real_normed_vector)\"\n  assumes \"\\<And>n. n > m \\<Longrightarrow> f n = 0\"\n  shows \"(\\<Sum>n. f n) = (\\<Sum>n \\<le> m. f n)\"", "lemma suminf_multr: \"summable f \\<Longrightarrow> (\\<Sum>n. f n * c) = (\\<Sum>n. f n) * c\" for c::\"'a::real_normed_algebra\"", "lemma sum_if_then_else_simps[simp]:\n  fixes q :: \"('a::semiring_0)\" and i :: \"'n::finite\"\n  shows \"(\\<Sum>j\\<in>UNIV. f j * (if j = i then q else 0)) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. f j * (if i = j then q else 0)) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. (if i = j then q else 0) * f j) = q * f i\"\n    and \"(\\<Sum>j\\<in>UNIV. (if j = i then q else 0) * f j) = q * f i\"", "lemma le_max_image_of_finite[simp]:\n  fixes f::\"'a::finite \\<Rightarrow> 'b::linorder\"\n  shows \"(f i) \\<le> Max {x. \\<exists>i. x = f i}\"", "lemma cSup_eq:\n  fixes c::\"'a::conditionally_complete_lattice\"\n  assumes \"\\<forall>x \\<in> X. x \\<le> c\" and \"\\<exists>x \\<in> X. c \\<le> x\"\n  shows \"Sup X = c\"", "lemma cSup_mem_eq: \n  \"c \\<in> X \\<Longrightarrow> \\<forall>x \\<in> X. x \\<le> c \\<Longrightarrow> Sup X = c\" for c::\"'a::conditionally_complete_lattice\"", "lemma cSup_finite_ex:\n  \"finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> \\<exists>x\\<in>X. Sup X = x\" for X::\"'a::conditionally_complete_linorder set\"", "lemma cMax_finite_ex:\n  \"finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> \\<exists>x\\<in>X. Max X = x\" for X::\"'a::conditionally_complete_linorder set\"", "lemma finite_nat_minimal_witness:\n  fixes P :: \"('a::finite) \\<Rightarrow> nat \\<Rightarrow> bool\"\n  assumes \"\\<forall>i. \\<exists>N::nat. \\<forall>n \\<ge> N. P i n\"\n  shows \"\\<exists>N. \\<forall>i. \\<forall>n \\<ge> N. P i n\"", "lemma sq_le_cancel:\n  shows \"(a::real) \\<ge> 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a^2 \\<le> b * a \\<Longrightarrow> a \\<le> b\"\n  and \"(a::real) \\<ge> 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a^2 \\<le> a * b \\<Longrightarrow> a \\<le> b\"", "lemma frac_diff_eq1: \"a \\<noteq> b \\<Longrightarrow> a / (a - b) - b / (a - b) = 1\" for a::real", "lemma exp_add: \"x * y - y * x = 0 \\<Longrightarrow> exp (x + y) = exp x * exp y\"", "lemmas mult_exp_exp = exp_add[symmetric]", "lemma sum_axis[simp]:\n  fixes q :: \"('a::semiring_0)\"\n  shows \"(\\<Sum>j\\<in>UNIV. f j * axis i q $ j) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. axis i q $ j * f j) = q * f i\"", "lemma sum_scalar_nth_axis: \"sum (\\<lambda>i. (x $ i) *s \\<e> i) UNIV = x\" for x :: \"('a::semiring_1)^'n\"", "lemma scalar_eq_scaleR[simp]: \"c *s x = c *\\<^sub>R x\"", "lemma matrix_add_rdistrib: \"((B + C) ** A) = (B ** A) + (C ** A)\"", "lemma vec_mult_inner: \"(A *v v) \\<bullet> w = v \\<bullet> (transpose A *v w)\" for A :: \"real ^'n^'n\"", "lemma uminus_axis_eq[simp]: \"- axis i k = axis i (-k)\" for k :: \"'a::ring\"", "lemma norm_axis_eq[simp]: \"\\<parallel>axis i k\\<parallel> = \\<parallel>k\\<parallel>\"", "lemma matrix_axis_0: \n  fixes A :: \"('a::idom)^'n^'m\"\n  assumes \"k \\<noteq> 0 \" and h:\"\\<forall>i. (A *v (axis i k)) = 0\"\n  shows \"A = 0\"", "lemma scaleR_norm_sgn_eq: \"(\\<parallel>x\\<parallel>) *\\<^sub>R sgn x = x\"", "lemma vector_scaleR_commute: \"A *v c *\\<^sub>R x = c *\\<^sub>R (A *v x)\" for x :: \"('a::real_normed_algebra_1)^'n\"", "lemma scaleR_vector_assoc: \"c *\\<^sub>R (A *v x) = (c *\\<^sub>R A) *v x\" for x :: \"('a::real_normed_algebra_1)^'n\"", "lemma mult_norm_matrix_sgn_eq:\n  fixes x :: \"('a::real_normed_algebra_1)^'n\"\n  shows \"(\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) = \\<parallel>A *v x\\<parallel>\"", "lemma invertibleI: \"A ** B = mat 1 \\<Longrightarrow> B ** A = mat 1 \\<Longrightarrow> invertible A\"", "lemma invertibleD[simp]:\n  assumes \"invertible A\" \n  shows \"A\\<^sup>-\\<^sup>1 ** A = mat 1\" and \"A ** A\\<^sup>-\\<^sup>1 = mat 1\"", "lemma matrix_inv_unique:\n  assumes \"A ** B = mat 1\" and \"B ** A = mat 1\"\n  shows \"A\\<^sup>-\\<^sup>1 = B\"", "lemma invertible_matrix_inv: \"invertible A \\<Longrightarrow> invertible (A\\<^sup>-\\<^sup>1)\"", "lemma matrix_inv_idempotent[simp]: \"invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A\"", "lemma matrix_inv_matrix_mul:\n  assumes \"invertible A\" and \"invertible B\"\n  shows \"(A ** B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1\"", "lemma mat_inverse_simps[simp]:\n  fixes c :: \"'a::division_ring\"\n  assumes \"c \\<noteq> 0\"\n  shows \"mat (inverse c) ** mat c = mat 1\" \n    and \"mat c ** mat (inverse c) = mat 1\"", "lemma matrix_inv_mat[simp]: \"c \\<noteq> 0 \\<Longrightarrow> (mat c)\\<^sup>-\\<^sup>1 = mat (inverse c)\" for c :: \"'a::division_ring\"", "lemma invertible_mat[simp]: \"c \\<noteq> 0 \\<Longrightarrow> invertible (mat c)\" for c :: \"'a::division_ring\"", "lemma matrix_inv_mat_1: \"(mat (1::'a::division_ring))\\<^sup>-\\<^sup>1 = mat 1\"", "lemma invertible_mat_1: \"invertible (mat (1::'a::division_ring))\"", "lemma similar_matrix_refl[simp]: \"A \\<sim> A\" for A :: \"'a::division_ring^'n^'n\"", "lemma similar_matrix_simm: \"A \\<sim> B \\<Longrightarrow> B \\<sim> A\" for A B :: \"('a::semiring_1)^'n^'n\"", "lemma similar_matrix_trans: \"A \\<sim> B \\<Longrightarrow> B \\<sim> C \\<Longrightarrow> A \\<sim> C\" for A B C :: \"('a::semiring_1)^'n^'n\"", "lemma mat_vec_nth_simps[simp]:\n  \"i = j \\<Longrightarrow> mat c $ i $ j = c\" \n  \"i \\<noteq> j \\<Longrightarrow> mat c $ i $ j = 0\"", "lemma diag_mat_vec_nth_simps[simp]:\n  \"i = j \\<Longrightarrow> diag_mat f $ i $ j = f i\"\n  \"i \\<noteq> j \\<Longrightarrow> diag_mat f $ i $ j = 0\"", "lemma diag_mat_const_eq[simp]: \"diag_mat (\\<lambda>i. c) = mat c\"", "lemma matrix_vector_mul_diag_mat: \"diag_mat f *v s = (\\<chi> i. f i * s$i)\"", "lemma matrix_vector_mul_diag_axis[simp]: \"diag_mat f *v (axis i k) = axis i (f i * k)\"", "lemma matrix_mul_diag_matl: \"diag_mat f ** A = (\\<chi> i j. f i * A$i$j)\"", "lemma matrix_matrix_mul_diag_matr: \"A ** diag_mat f = (\\<chi> i j. A$i$j * f j)\"", "lemma matrix_mul_diag_diag: \"diag_mat f ** diag_mat g = diag_mat (\\<lambda>i. f i * g i)\"", "lemma compow_matrix_mul_diag_mat_eq: \"((**) (diag_mat f) ^^ n) (mat 1) = diag_mat (\\<lambda>i. f i^n)\"", "lemma compow_similar_diag_mat_eq:\n  assumes \"invertible P\" \n      and \"A = P\\<^sup>-\\<^sup>1 ** (diag_mat f) ** P\"\n    shows \"((**) A ^^ n) (mat 1) = P\\<^sup>-\\<^sup>1 ** (diag_mat (\\<lambda>i. f i^n)) ** P\"", "lemma compow_similar_diag_mat:\n  assumes \"A \\<sim> (diag_mat f)\"\n  shows \"((**) A ^^ n) (mat 1) \\<sim> diag_mat (\\<lambda>i. f i^n)\""], "translations": [["", "lemmas compact_imp_bdd_above = compact_imp_bounded[THEN bounded_imp_bdd_above]"], ["", "lemma comp_cont_image_spec: \"continuous_on T f \\<Longrightarrow> compact T \\<Longrightarrow> compact {f t |t. t \\<in> T}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_on T f; compact T\\<rbrakk>\n    \\<Longrightarrow> compact {f t |t. t \\<in> T}", "using compact_continuous_image"], ["proof (prove)\nusing this:\n  \\<lbrakk>continuous_on ?s ?f; compact ?s\\<rbrakk>\n  \\<Longrightarrow> compact (?f ` ?s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>continuous_on T f; compact T\\<rbrakk>\n    \\<Longrightarrow> compact {f t |t. t \\<in> T}", "by (simp add: Setcompr_eq_image)"], ["", "lemmas bdd_above_cont_comp_spec = compact_imp_bdd_above[OF comp_cont_image_spec]"], ["", "lemmas bdd_above_norm_cont_comp = continuous_on_norm[THEN bdd_above_cont_comp_spec]"], ["", "lemma open_cballE: \"t\\<^sub>0 \\<in> T \\<Longrightarrow> open T \\<Longrightarrow> \\<exists>e>0. cball t\\<^sub>0 e \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t\\<^sub>0 \\<in> T; open T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e>0. cball t\\<^sub>0 e \\<subseteq> T", "using open_contains_cball"], ["proof (prove)\nusing this:\n  open ?S = (\\<forall>x\\<in>?S. \\<exists>e>0. cball x e \\<subseteq> ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t\\<^sub>0 \\<in> T; open T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e>0. cball t\\<^sub>0 e \\<subseteq> T", "by blast"], ["", "lemma open_ballE: \"t\\<^sub>0 \\<in> T \\<Longrightarrow> open T \\<Longrightarrow> \\<exists>e>0. ball t\\<^sub>0 e \\<subseteq> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>t\\<^sub>0 \\<in> T; open T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e>0. ball t\\<^sub>0 e \\<subseteq> T", "using open_contains_ball"], ["proof (prove)\nusing this:\n  open ?S = (\\<forall>x\\<in>?S. \\<exists>e>0. ball x e \\<subseteq> ?S)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>t\\<^sub>0 \\<in> T; open T\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e>0. ball t\\<^sub>0 e \\<subseteq> T", "by blast"], ["", "lemma funcset_UNIV: \"f \\<in> A \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> A \\<rightarrow> UNIV", "by auto"], ["", "lemma finite_image_of_finite[simp]:\n  fixes f::\"'a::finite \\<Rightarrow> 'b\"\n  shows \"finite {x. \\<exists>i. x = f i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. \\<exists>i. x = f i}", "using finite_Atleast_Atmost_nat"], ["proof (prove)\nusing this:\n  finite {?f x |x. x \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. finite {x. \\<exists>i. x = f i}", "by force"], ["", "lemma finite_image_of_finite2:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::finite \\<Rightarrow> 'c\"\n  shows \"finite {f x y |x y. P x y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "have \"finite (\\<Union>x. {f x y|y. P x y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<Union>x. {f x y |y. P x y})", "by simp"], ["proof (state)\nthis:\n  finite (\\<Union>x. {f x y |y. P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "moreover"], ["proof (state)\nthis:\n  finite (\\<Union>x. {f x y |y. P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "have \"{f x y|x y. P x y} = (\\<Union>x. {f x y|y. P x y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {f x y |x y. P x y} = (\\<Union>x. {f x y |y. P x y})", "by auto"], ["proof (state)\nthis:\n  {f x y |x y. P x y} = (\\<Union>x. {f x y |y. P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "ultimately"], ["proof (chain)\npicking this:\n  finite (\\<Union>x. {f x y |y. P x y})\n  {f x y |x y. P x y} = (\\<Union>x. {f x y |y. P x y})", "show ?thesis"], ["proof (prove)\nusing this:\n  finite (\\<Union>x. {f x y |y. P x y})\n  {f x y |x y. P x y} = (\\<Union>x. {f x y |y. P x y})\n\ngoal (1 subgoal):\n 1. finite {f x y |x y. P x y}", "by simp"], ["proof (state)\nthis:\n  finite {f x y |x y. P x y}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Functions \\<close>"], ["", "lemma finite_sum_univ_singleton: \"(sum g UNIV) = sum g {i::'a::finite} + sum g (UNIV - {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum g UNIV = sum g {i} + sum g (UNIV - {i})", "by (metis add.commute finite_class.finite_UNIV sum.subset_diff top_greatest)"], ["", "lemma suminfI:\n  fixes f :: \"nat \\<Rightarrow> 'a::{t2_space,comm_monoid_add}\"\n  shows \"f sums k \\<Longrightarrow> suminf f = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f sums k \\<Longrightarrow> suminf f = k", "unfolding sums_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. summable f \\<and> suminf f = k \\<Longrightarrow> suminf f = k", "by simp"], ["", "lemma suminf_eq_sum:\n  fixes f :: \"nat \\<Rightarrow> ('a::real_normed_vector)\"\n  assumes \"\\<And>n. n > m \\<Longrightarrow> f n = 0\"\n  shows \"(\\<Sum>n. f n) = (\\<Sum>n \\<le> m. f n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n. f n) = sum f {..m}", "using assms"], ["proof (prove)\nusing this:\n  m < ?n \\<Longrightarrow> f ?n = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>n. f n) = sum f {..m}", "by (meson atMost_iff finite_atMost not_le suminf_finite)"], ["", "lemma suminf_multr: \"summable f \\<Longrightarrow> (\\<Sum>n. f n * c) = (\\<Sum>n. f n) * c\" for c::\"'a::real_normed_algebra\""], ["proof (prove)\ngoal (1 subgoal):\n 1. summable f \\<Longrightarrow> (\\<Sum>n. f n * c) = (\\<Sum>n. f n) * c", "by (rule bounded_linear.suminf [OF bounded_linear_mult_left, symmetric])"], ["", "lemma sum_if_then_else_simps[simp]:\n  fixes q :: \"('a::semiring_0)\" and i :: \"'n::finite\"\n  shows \"(\\<Sum>j\\<in>UNIV. f j * (if j = i then q else 0)) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. f j * (if i = j then q else 0)) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. (if i = j then q else 0) * f j) = q * f i\"\n    and \"(\\<Sum>j\\<in>UNIV. (if j = i then q else 0) * f j) = q * f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>j\\<in>UNIV. f j * (if j = i then q else (0::'a))) = f i * q &&&\n     (\\<Sum>j\\<in>UNIV. f j * (if i = j then q else (0::'a))) = f i * q) &&&\n    (\\<Sum>j\\<in>UNIV. (if i = j then q else (0::'a)) * f j) = q * f i &&&\n    (\\<Sum>j\\<in>UNIV. (if j = i then q else (0::'a)) * f j) = q * f i", "by (auto simp: finite_sum_univ_singleton[of _ i])"], ["", "subsection \\<open> Suprema \\<close>"], ["", "lemma le_max_image_of_finite[simp]:\n  fixes f::\"'a::finite \\<Rightarrow> 'b::linorder\"\n  shows \"(f i) \\<le> Max {x. \\<exists>i. x = f i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f i \\<le> Max {x. \\<exists>i. x = f i}", "by (rule Max.coboundedI, simp_all) (rule_tac x=i in exI, simp)"], ["", "lemma cSup_eq:\n  fixes c::\"'a::conditionally_complete_lattice\"\n  assumes \"\\<forall>x \\<in> X. x \\<le> c\" and \"\\<exists>x \\<in> X. c \\<le> x\"\n  shows \"Sup X = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sup X = c", "by (metis assms cSup_eq_maximum order_class.order.antisym)"], ["", "lemma cSup_mem_eq: \n  \"c \\<in> X \\<Longrightarrow> \\<forall>x \\<in> X. x \\<le> c \\<Longrightarrow> Sup X = c\" for c::\"'a::conditionally_complete_lattice\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<in> X; \\<forall>x\\<in>X. x \\<le> c\\<rbrakk>\n    \\<Longrightarrow> Sup X = c", "by (rule cSup_eq, auto)"], ["", "lemma cSup_finite_ex:\n  \"finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> \\<exists>x\\<in>X. Sup X = x\" for X::\"'a::conditionally_complete_linorder set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>X. Sup X = x", "by (metis (full_types) bdd_finite(1) cSup_upper finite_Sup_less_iff order_less_le)"], ["", "lemma cMax_finite_ex:\n  \"finite X \\<Longrightarrow> X \\<noteq> {} \\<Longrightarrow> \\<exists>x\\<in>X. Max X = x\" for X::\"'a::conditionally_complete_linorder set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>X. Max X = x", "apply(subst cSup_eq_Max[symmetric])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite X\n 2. \\<And>x.\n       \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> X \\<noteq> {}\n 3. \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Bex X ((=) (Sup X))", "using cSup_finite_ex"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite ?X; ?X \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x\\<in>?X. Sup ?X = x\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk> \\<Longrightarrow> finite X\n 2. \\<And>x.\n       \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> X \\<noteq> {}\n 3. \\<lbrakk>finite X; X \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Bex X ((=) (Sup X))", "by auto"], ["", "lemma finite_nat_minimal_witness:\n  fixes P :: \"('a::finite) \\<Rightarrow> nat \\<Rightarrow> bool\"\n  assumes \"\\<forall>i. \\<exists>N::nat. \\<forall>n \\<ge> N. P i n\"\n  shows \"\\<exists>N. \\<forall>i. \\<forall>n \\<ge> N. P i n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "let \"?bound i\" = \"(LEAST N. \\<forall>n \\<ge> N. P i n)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "let ?N = \"Max {?bound i |i. i \\<in> UNIV}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "fix n::nat and i::'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "assume \"n \\<ge> ?N\""], ["proof (state)\nthis:\n  Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV} \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "obtain M where \"\\<forall>n \\<ge> M. P i n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M. P i n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>i. \\<exists>N. \\<forall>n\\<ge>N. P i n\n\ngoal (1 subgoal):\n 1. (\\<And>M.\n        \\<forall>n\\<ge>M. P i n \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>n\\<ge>M. P i n\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "hence obs: \"\\<forall> m \\<ge> ?bound i. P i m\""], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. P i n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>LEAST N. \\<forall>n\\<ge>N. P i n. P i m", "using LeastI[of \"\\<lambda>N. \\<forall>n \\<ge> N. P i n\"]"], ["proof (prove)\nusing this:\n  \\<forall>n\\<ge>M. P i n\n  \\<forall>n\\<ge>?k. P i n \\<Longrightarrow>\n  \\<forall>n\\<ge>LEAST x. \\<forall>n\\<ge>x. P i n. P i n\n\ngoal (1 subgoal):\n 1. \\<forall>m\\<ge>LEAST N. \\<forall>n\\<ge>N. P i n. P i m", "by blast"], ["proof (state)\nthis:\n  \\<forall>m\\<ge>LEAST N. \\<forall>n\\<ge>N. P i n. P i m\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "have \"finite {?bound i |i. i \\<in> UNIV}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}", "by simp"], ["proof (state)\nthis:\n  finite {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "hence \"?N \\<ge> ?bound i\""], ["proof (prove)\nusing this:\n  finite {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. (LEAST N. \\<forall>n\\<ge>N. P i n)\n    \\<le> Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}", "using Max_ge"], ["proof (prove)\nusing this:\n  finite {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n  \\<lbrakk>finite ?A; ?x \\<in> ?A\\<rbrakk> \\<Longrightarrow> ?x \\<le> Max ?A\n\ngoal (1 subgoal):\n 1. (LEAST N. \\<forall>n\\<ge>N. P i n)\n    \\<le> Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}", "by blast"], ["proof (state)\nthis:\n  (LEAST N. \\<forall>n\\<ge>N. P i n)\n  \\<le> Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "hence \"n \\<ge> ?bound i\""], ["proof (prove)\nusing this:\n  (LEAST N. \\<forall>n\\<ge>N. P i n)\n  \\<le> Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n\ngoal (1 subgoal):\n 1. (LEAST N. \\<forall>n\\<ge>N. P i n) \\<le> n", "using \\<open>n \\<ge> ?N\\<close>"], ["proof (prove)\nusing this:\n  (LEAST N. \\<forall>n\\<ge>N. P i n)\n  \\<le> Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n  Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV} \\<le> n\n\ngoal (1 subgoal):\n 1. (LEAST N. \\<forall>n\\<ge>N. P i n) \\<le> n", "by linarith"], ["proof (state)\nthis:\n  (LEAST N. \\<forall>n\\<ge>N. P i n) \\<le> n\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "hence \"P i n\""], ["proof (prove)\nusing this:\n  (LEAST N. \\<forall>n\\<ge>N. P i n) \\<le> n\n\ngoal (1 subgoal):\n 1. P i n", "using obs"], ["proof (prove)\nusing this:\n  (LEAST N. \\<forall>n\\<ge>N. P i n) \\<le> n\n  \\<forall>m\\<ge>LEAST N. \\<forall>n\\<ge>N. P i n. P i m\n\ngoal (1 subgoal):\n 1. P i n", "by blast"], ["proof (state)\nthis:\n  P i n\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "}"], ["proof (state)\nthis:\n  Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n  \\<le> ?n2 \\<Longrightarrow>\n  P ?i2 ?n2\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "thus \"\\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n\""], ["proof (prove)\nusing this:\n  Max {LEAST N. \\<forall>n\\<ge>N. P i n |i. i \\<in> UNIV}\n  \\<le> ?n2 \\<Longrightarrow>\n  P ?i2 ?n2\n\ngoal (1 subgoal):\n 1. \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n", "by blast"], ["proof (state)\nthis:\n  \\<exists>N. \\<forall>i n. N \\<le> n \\<longrightarrow> P i n\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open> Real numbers \\<close>"], ["", "named_theorems field_power_simps \"simplification rules for powers to the nth\""], ["", "declare semiring_normalization_rules(18) [field_power_simps]\n    and semiring_normalization_rules(26) [field_power_simps]\n    and semiring_normalization_rules(27) [field_power_simps]\n    and semiring_normalization_rules(28) [field_power_simps]\n    and semiring_normalization_rules(29) [field_power_simps]"], ["", "text \\<open>WARNING: Adding @{thm semiring_normalization_rules(27)} to our tactic makes \nits combination with simp to loop infinitely in some proofs.\\<close>"], ["", "lemma sq_le_cancel:\n  shows \"(a::real) \\<ge> 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a^2 \\<le> b * a \\<Longrightarrow> a \\<le> b\"\n  and \"(a::real) \\<ge> 0 \\<Longrightarrow> b \\<ge> 0 \\<Longrightarrow> a^2 \\<le> a * b \\<Longrightarrow> a \\<le> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>0 \\<le> a; 0 \\<le> b; a\\<^sup>2 \\<le> b * a\\<rbrakk>\n     \\<Longrightarrow> a \\<le> b) &&&\n    (\\<lbrakk>0 \\<le> a; 0 \\<le> b; a\\<^sup>2 \\<le> a * b\\<rbrakk>\n     \\<Longrightarrow> a \\<le> b)", "apply (metis less_eq_real_def mult.commute mult_le_cancel_left semiring_normalization_rules(29))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 \\<le> a; 0 \\<le> b; a\\<^sup>2 \\<le> a * b\\<rbrakk>\n    \\<Longrightarrow> a \\<le> b", "by (metis less_eq_real_def mult_le_cancel_left semiring_normalization_rules(29))"], ["", "lemma frac_diff_eq1: \"a \\<noteq> b \\<Longrightarrow> a / (a - b) - b / (a - b) = 1\" for a::real"], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<noteq> b \\<Longrightarrow> a / (a - b) - b / (a - b) = 1", "by (metis (no_types, hide_lams) ab_left_minus add.commute add_left_cancel \n      diff_divide_distrib diff_minus_eq_add div_self)"], ["", "lemma exp_add: \"x * y - y * x = 0 \\<Longrightarrow> exp (x + y) = exp x * exp y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y - y * x = (0::'a) \\<Longrightarrow> exp (x + y) = exp x * exp y", "by (rule exp_add_commuting) (simp add: ac_simps)"], ["", "lemmas mult_exp_exp = exp_add[symmetric]"], ["", "subsection \\<open> Vectors and matrices \\<close>"], ["", "lemma sum_axis[simp]:\n  fixes q :: \"('a::semiring_0)\"\n  shows \"(\\<Sum>j\\<in>UNIV. f j * axis i q $ j) = f i * q\"\n    and \"(\\<Sum>j\\<in>UNIV. axis i q $ j * f j) = q * f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. f j * axis i q $ j) = f i * q &&&\n    (\\<Sum>j\\<in>UNIV. axis i q $ j * f j) = q * f i", "unfolding axis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       f j * (\\<chi>ia. if ia = i then q else (0::'a)) $ j) =\n    f i * q &&&\n    (\\<Sum>j\\<in>UNIV.\n       (\\<chi>ia. if ia = i then q else (0::'a)) $ j * f j) =\n    q * f i", "by(auto simp: vec_eq_iff)"], ["", "lemma sum_scalar_nth_axis: \"sum (\\<lambda>i. (x $ i) *s \\<e> i) UNIV = x\" for x :: \"('a::semiring_1)^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. x $ i *s \\<e> i) = x", "unfolding vec_eq_iff axis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (\\<Sum>i\\<in>UNIV.\n          x $ i *s (\\<chi>ia. if ia = i then 1::'a else (0::'a))) $\n       i =\n       x $ i", "by simp"], ["", "lemma scalar_eq_scaleR[simp]: \"c *s x = c *\\<^sub>R x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *s x = c *\\<^sub>R x", "unfolding vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i. (c *s x) $ i = (c *\\<^sub>R x) $ i", "by simp"], ["", "lemma matrix_add_rdistrib: \"((B + C) ** A) = (B ** A) + (C ** A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (B + C) ** A = B ** A + C ** A", "by (vector matrix_matrix_mult_def sum.distrib[symmetric] field_simps)"], ["", "lemma vec_mult_inner: \"(A *v v) \\<bullet> w = v \\<bullet> (transpose A *v w)\" for A :: \"real ^'n^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A *v v) \\<bullet> w =\n    v \\<bullet> (Finite_Cartesian_Product.transpose A *v w)", "unfolding matrix_vector_mult_def transpose_def inner_vec_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV.\n       (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * v $ j) $ i \\<bullet> w $ i) =\n    (\\<Sum>i\\<in>UNIV.\n       v $ i \\<bullet>\n       (\\<chi>i. \\<Sum>j\\<in>UNIV. (\\<chi>i j. A $ j $ i) $ i $ j * w $ j) $\n       i)", "apply(simp add: sum_distrib_right sum_distrib_left)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>UNIV. \\<Sum>n\\<in>UNIV. A $ i $ n * v $ n * w $ i) =\n    (\\<Sum>i\\<in>UNIV. \\<Sum>n\\<in>UNIV. v $ i * (A $ n $ i * w $ n))", "apply(subst sum.swap)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>UNIV. A $ i $ j * v $ j * w $ i) =\n    (\\<Sum>i\\<in>UNIV. \\<Sum>n\\<in>UNIV. v $ i * (A $ n $ i * w $ n))", "apply(subgoal_tac \"\\<forall>i j. A $ i $ j * v $ j * w $ i = v $ j * (A $ i $ j * w $ i)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>i j.\n       A $ i $ j * v $ j * w $ i =\n       v $ j * (A $ i $ j * w $ i) \\<Longrightarrow>\n    (\\<Sum>j\\<in>UNIV. \\<Sum>i\\<in>UNIV. A $ i $ j * v $ j * w $ i) =\n    (\\<Sum>i\\<in>UNIV. \\<Sum>n\\<in>UNIV. v $ i * (A $ n $ i * w $ n))\n 2. \\<forall>i j. A $ i $ j * v $ j * w $ i = v $ j * (A $ i $ j * w $ i)", "by presburger simp"], ["", "lemma uminus_axis_eq[simp]: \"- axis i k = axis i (-k)\" for k :: \"'a::ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - axis i k = axis i (- k)", "unfolding axis_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<chi>ia. if ia = i then k else (0::'a)) =\n    (\\<chi>ia. if ia = i then - k else (0::'a))", "by(simp add: vec_eq_iff)"], ["", "lemma norm_axis_eq[simp]: \"\\<parallel>axis i k\\<parallel> = \\<parallel>k\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>axis i k\\<parallel> = \\<parallel>k\\<parallel>", "proof(simp add: axis_def norm_vec_def L2_set_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>ia\\<in>UNIV.\n        (\\<parallel>(if ia = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "let \"?\\<delta>\\<^sub>K\" = \"\\<lambda>i j k. if i = j then k else 0\""], ["proof (state)\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>ia\\<in>UNIV.\n        (\\<parallel>(if ia = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "have \"(\\<Sum>j\\<in>UNIV. (\\<parallel>(?\\<delta>\\<^sub>K j i k)\\<parallel>)\\<^sup>2) = (\\<Sum>j\\<in>{i}. (\\<parallel>(?\\<delta>\\<^sub>K j i k)\\<parallel>)\\<^sup>2) + (\\<Sum>j\\<in>(UNIV-{i}). (\\<parallel>(?\\<delta>\\<^sub>K j i k)\\<parallel>)\\<^sup>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    (\\<Sum>j\\<in>{i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n    (\\<Sum>j\\<in>UNIV - {i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2)", "using finite_sum_univ_singleton"], ["proof (prove)\nusing this:\n  sum ?g UNIV = sum ?g {?i} + sum ?g (UNIV - {?i})\n\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    (\\<Sum>j\\<in>{i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n    (\\<Sum>j\\<in>UNIV - {i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2)", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  (\\<Sum>j\\<in>{i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n  (\\<Sum>j\\<in>UNIV - {i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>ia\\<in>UNIV.\n        (\\<parallel>(if ia = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "also"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  (\\<Sum>j\\<in>{i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n  (\\<Sum>j\\<in>UNIV - {i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>ia\\<in>UNIV.\n        (\\<parallel>(if ia = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "have \"... = (\\<parallel>k\\<parallel>)\\<^sup>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>{i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n    (\\<Sum>j\\<in>UNIV - {i}.\n       (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    (\\<parallel>k\\<parallel>)\\<^sup>2", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>{i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) +\n  (\\<Sum>j\\<in>UNIV - {i}.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  (\\<parallel>k\\<parallel>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>ia\\<in>UNIV.\n        (\\<parallel>(if ia = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>j\\<in>UNIV.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  (\\<parallel>k\\<parallel>)\\<^sup>2", "show \"sqrt (\\<Sum>j\\<in>UNIV. (norm (if j = i then k else 0))\\<^sup>2) = norm k\""], ["proof (prove)\nusing this:\n  (\\<Sum>j\\<in>UNIV.\n     (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  (\\<parallel>k\\<parallel>)\\<^sup>2\n\ngoal (1 subgoal):\n 1. sqrt\n     (\\<Sum>j\\<in>UNIV.\n        (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n    \\<parallel>k\\<parallel>", "by simp"], ["proof (state)\nthis:\n  sqrt\n   (\\<Sum>j\\<in>UNIV.\n      (\\<parallel>(if j = i then k else (0::'a))\\<parallel>)\\<^sup>2) =\n  \\<parallel>k\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma matrix_axis_0: \n  fixes A :: \"('a::idom)^'n^'m\"\n  assumes \"k \\<noteq> 0 \" and h:\"\\<forall>i. (A *v (axis i k)) = 0\"\n  shows \"A = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A = 0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0", "fix i::'n"], ["proof (state)\ngoal (1 subgoal):\n 1. A = 0", "have \"0 = (\\<Sum>j\\<in>UNIV. (axis i k) $ j *s column j A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A)", "using h matrix_mult_sum[of A \"axis i k\"]"], ["proof (prove)\nusing this:\n  \\<forall>i. A *v axis i k = 0\n  A *v axis i k = (\\<Sum>ia\\<in>UNIV. axis i k $ ia *s column ia A)\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A)", "by simp"], ["proof (state)\nthis:\n  0 = (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A)\n\ngoal (1 subgoal):\n 1. A = 0", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A)\n\ngoal (1 subgoal):\n 1. A = 0", "have \"... = k *s column i A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A) = k *s column i A", "by (simp add: axis_def vector_scalar_mult_def column_def vec_eq_iff mult.commute)"], ["proof (state)\nthis:\n  (\\<Sum>j\\<in>UNIV. axis i k $ j *s column j A) = k *s column i A\n\ngoal (1 subgoal):\n 1. A = 0", "finally"], ["proof (chain)\npicking this:\n  0 = k *s column i A", "have \"k *s column i A = 0\""], ["proof (prove)\nusing this:\n  0 = k *s column i A\n\ngoal (1 subgoal):\n 1. k *s column i A = 0", "unfolding axis_def"], ["proof (prove)\nusing this:\n  0 = k *s column i A\n\ngoal (1 subgoal):\n 1. k *s column i A = 0", "by simp"], ["proof (state)\nthis:\n  k *s column i A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "hence \"column i A = 0\""], ["proof (prove)\nusing this:\n  k *s column i A = 0\n\ngoal (1 subgoal):\n 1. column i A = 0", "using vector_mul_eq_0 \\<open>k \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  k *s column i A = 0\n  (?a *s ?x = 0) = (?a = (0::?'a) \\<or> ?x = 0)\n  k \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. column i A = 0", "by blast"], ["proof (state)\nthis:\n  column i A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "}"], ["proof (state)\nthis:\n  column ?i2 A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "thus \"A = 0\""], ["proof (prove)\nusing this:\n  column ?i2 A = 0\n\ngoal (1 subgoal):\n 1. A = 0", "unfolding column_def vec_eq_iff"], ["proof (prove)\nusing this:\n  \\<forall>i. (\\<chi>i. A $ i $ ?i2) $ i = 0 $ i\n\ngoal (1 subgoal):\n 1. \\<forall>i ia. A $ i $ ia = 0 $ i $ ia", "by simp"], ["proof (state)\nthis:\n  A = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleR_norm_sgn_eq: \"(\\<parallel>x\\<parallel>) *\\<^sub>R sgn x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x = x", "by (metis divideR_right norm_eq_zero scale_eq_0_iff sgn_div_norm)"], ["", "lemma vector_scaleR_commute: \"A *v c *\\<^sub>R x = c *\\<^sub>R (A *v x)\" for x :: \"('a::real_normed_algebra_1)^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A *v c *\\<^sub>R x = c *\\<^sub>R (A *v x)", "unfolding scaleR_vec_def matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        \\<Sum>j\\<in>UNIV. A $ i $ j * (\\<chi>i. c *\\<^sub>R x $ i) $ j) =\n    (\\<chi>i.\n        c *\\<^sub>R (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) $ i)", "by(auto simp: vec_eq_iff scaleR_right.sum)"], ["", "lemma scaleR_vector_assoc: \"c *\\<^sub>R (A *v x) = (c *\\<^sub>R A) *v x\" for x :: \"('a::real_normed_algebra_1)^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R (A *v x) = c *\\<^sub>R A *v x", "unfolding matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. c *\\<^sub>R (\\<chi>i. \\<Sum>j\\<in>UNIV. A $ i $ j * x $ j) =\n    (\\<chi>i. \\<Sum>j\\<in>UNIV. (c *\\<^sub>R A) $ i $ j * x $ j)", "by(auto simp: vec_eq_iff scaleR_right.sum)"], ["", "lemma mult_norm_matrix_sgn_eq:\n  fixes x :: \"('a::real_normed_algebra_1)^'n\"\n  shows \"(\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) = \\<parallel>A *v x\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", "have \"\\<parallel>A *v x\\<parallel> = \\<parallel>A *v ((\\<parallel>x\\<parallel>) *\\<^sub>R sgn x)\\<parallel>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A *v x\\<parallel> =\n    \\<parallel>A *v (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x\\<parallel>", "by(simp add: scaleR_norm_sgn_eq)"], ["proof (state)\nthis:\n  \\<parallel>A *v x\\<parallel> =\n  \\<parallel>A *v (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x\\<parallel>\n\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", "also"], ["proof (state)\nthis:\n  \\<parallel>A *v x\\<parallel> =\n  \\<parallel>A *v (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x\\<parallel>\n\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", "have \"... = (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<parallel>A *v (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x\\<parallel> =\n    (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>)", "by(simp add: vector_scaleR_commute)"], ["proof (state)\nthis:\n  \\<parallel>A *v (\\<parallel>x\\<parallel>) *\\<^sub>R sgn x\\<parallel> =\n  (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>)\n\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", "finally"], ["proof (chain)\npicking this:\n  \\<parallel>A *v x\\<parallel> =\n  (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<parallel>A *v x\\<parallel> =\n  (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>)\n\ngoal (1 subgoal):\n 1. (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n    \\<parallel>A *v x\\<parallel>", ".."], ["proof (state)\nthis:\n  (\\<parallel>A *v sgn x\\<parallel>) * (\\<parallel>x\\<parallel>) =\n  \\<parallel>A *v x\\<parallel>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open> Diagonalization \\<close>"], ["", "lemma invertibleI: \"A ** B = mat 1 \\<Longrightarrow> B ** A = mat 1 \\<Longrightarrow> invertible A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A ** B = mat (1::'a); B ** A = mat (1::'a)\\<rbrakk>\n    \\<Longrightarrow> invertible A", "unfolding invertible_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A ** B = mat (1::'a); B ** A = mat (1::'a)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>A'.\n                         A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)", "by auto"], ["", "lemma invertibleD[simp]:\n  assumes \"invertible A\" \n  shows \"A\\<^sup>-\\<^sup>1 ** A = mat 1\" and \"A ** A\\<^sup>-\\<^sup>1 = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>-\\<^sup>1 ** A = mat (1::'a) &&&\n    A ** A\\<^sup>-\\<^sup>1 = mat (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  invertible A\n\ngoal (1 subgoal):\n 1. A\\<^sup>-\\<^sup>1 ** A = mat (1::'a) &&&\n    A ** A\\<^sup>-\\<^sup>1 = mat (1::'a)", "unfolding matrix_inv_def invertible_def"], ["proof (prove)\nusing this:\n  \\<exists>A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)\n\ngoal (1 subgoal):\n 1. (SOME A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)) ** A =\n    mat (1::'a) &&&\n    A ** (SOME A'. A ** A' = mat (1::'a) \\<and> A' ** A = mat (1::'a)) =\n    mat (1::'a)", "by (simp_all add: verit_sko_ex')"], ["", "lemma matrix_inv_unique:\n  assumes \"A ** B = mat 1\" and \"B ** A = mat 1\"\n  shows \"A\\<^sup>-\\<^sup>1 = B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A\\<^sup>-\\<^sup>1 = B", "by (metis assms invertibleD(2) invertibleI matrix_mul_assoc matrix_mul_lid)"], ["", "lemma invertible_matrix_inv: \"invertible A \\<Longrightarrow> invertible (A\\<^sup>-\\<^sup>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A \\<Longrightarrow> invertible A\\<^sup>-\\<^sup>1", "using invertibleD invertibleI"], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 ** ?A = mat (1::?'a)\n  invertible ?A \\<Longrightarrow> ?A ** ?A\\<^sup>-\\<^sup>1 = mat (1::?'a)\n  \\<lbrakk>?A ** ?B = mat (1::?'a); ?B ** ?A = mat (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> invertible ?A\n\ngoal (1 subgoal):\n 1. invertible A \\<Longrightarrow> invertible A\\<^sup>-\\<^sup>1", "by blast"], ["", "lemma matrix_inv_idempotent[simp]: \"invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A", "using invertibleD matrix_inv_unique"], ["proof (prove)\nusing this:\n  invertible ?A \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 ** ?A = mat (1::?'a)\n  invertible ?A \\<Longrightarrow> ?A ** ?A\\<^sup>-\\<^sup>1 = mat (1::?'a)\n  \\<lbrakk>?A ** ?B = mat (1::?'a); ?B ** ?A = mat (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> ?A\\<^sup>-\\<^sup>1 = ?B\n\ngoal (1 subgoal):\n 1. invertible A \\<Longrightarrow> A\\<^sup>-\\<^sup>1\\<^sup>-\\<^sup>1 = A", "by blast"], ["", "lemma matrix_inv_matrix_mul:\n  assumes \"invertible A\" and \"invertible B\"\n  shows \"(A ** B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (A ** B)\\<^sup>-\\<^sup>1 = B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1", "proof(rule matrix_inv_unique)"], ["proof (state)\ngoal (2 subgoals):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n 2. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "have \"A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) =\n    A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) =\n  A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1\n\ngoal (2 subgoals):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n 2. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "also"], ["proof (state)\nthis:\n  A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) =\n  A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1\n\ngoal (2 subgoals):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n 2. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "have \"... = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1 = mat (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  invertible A\n  invertible B\n\ngoal (1 subgoal):\n 1. A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1 = mat (1::'a)", "by simp"], ["proof (state)\nthis:\n  A ** (B ** B\\<^sup>-\\<^sup>1) ** A\\<^sup>-\\<^sup>1 = mat (1::'a)\n\ngoal (2 subgoals):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n 2. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "finally"], ["proof (chain)\npicking this:\n  A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)", "show \"A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat 1\""], ["proof (prove)\nusing this:\n  A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n\ngoal (1 subgoal):\n 1. A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)", "."], ["proof (state)\nthis:\n  A ** B ** (B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1) = mat (1::'a)\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "have \"B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) =\n    B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B", "by (simp add: matrix_mul_assoc)"], ["proof (state)\nthis:\n  B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) =\n  B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "also"], ["proof (state)\nthis:\n  B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) =\n  B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "have \"... = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B = mat (1::'a)", "using assms"], ["proof (prove)\nusing this:\n  invertible A\n  invertible B\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B = mat (1::'a)", "by simp"], ["proof (state)\nthis:\n  B\\<^sup>-\\<^sup>1 ** (A\\<^sup>-\\<^sup>1 ** A) ** B = mat (1::'a)\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "finally"], ["proof (chain)\npicking this:\n  B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "show \"B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat 1\""], ["proof (prove)\nusing this:\n  B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)\n\ngoal (1 subgoal):\n 1. B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)", "."], ["proof (state)\nthis:\n  B\\<^sup>-\\<^sup>1 ** A\\<^sup>-\\<^sup>1 ** (A ** B) = mat (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_inverse_simps[simp]:\n  fixes c :: \"'a::division_ring\"\n  assumes \"c \\<noteq> 0\"\n  shows \"mat (inverse c) ** mat c = mat 1\" \n    and \"mat c ** mat (inverse c) = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (inverse c) ** mat c = mat (1::'a) &&&\n    mat c ** mat (inverse c) = mat (1::'a)", "unfolding matrix_matrix_mult_def mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          (\\<chi>i j. if i = j then inverse c else (0::'a)) $ i $ k *\n          (\\<chi>i j. if i = j then c else (0::'a)) $ k $ j) =\n    (\\<chi>i j. if i = j then 1::'a else (0::'a)) &&&\n    (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          (\\<chi>i j. if i = j then c else (0::'a)) $ i $ k *\n          (\\<chi>i j. if i = j then inverse c else (0::'a)) $ k $ j) =\n    (\\<chi>i j. if i = j then 1::'a else (0::'a))", "by (auto simp: vec_eq_iff assms)"], ["", "lemma matrix_inv_mat[simp]: \"c \\<noteq> 0 \\<Longrightarrow> (mat c)\\<^sup>-\\<^sup>1 = mat (inverse c)\" for c :: \"'a::division_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow>\n    mat c\\<^sup>-\\<^sup>1 = mat (inverse c)", "by (simp add: matrix_inv_unique)"], ["", "lemma invertible_mat[simp]: \"c \\<noteq> 0 \\<Longrightarrow> invertible (mat c)\" for c :: \"'a::division_ring\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> invertible (mat c)", "using invertibleI mat_inverse_simps(1) mat_inverse_simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A ** ?B = mat (1::?'a); ?B ** ?A = mat (1::?'a)\\<rbrakk>\n  \\<Longrightarrow> invertible ?A\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow>\n  mat (inverse ?c) ** mat ?c = mat (1::?'a)\n  ?c \\<noteq> (0::?'a) \\<Longrightarrow>\n  mat ?c ** mat (inverse ?c) = mat (1::?'a)\n\ngoal (1 subgoal):\n 1. c \\<noteq> (0::'a) \\<Longrightarrow> invertible (mat c)", "by blast"], ["", "lemma matrix_inv_mat_1: \"(mat (1::'a::division_ring))\\<^sup>-\\<^sup>1 = mat 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mat (1::'a)\\<^sup>-\\<^sup>1 = mat (1::'a)", "by simp"], ["", "lemma invertible_mat_1: \"invertible (mat (1::'a::division_ring))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (mat (1::'a))", "by simp"], ["", "definition similar_matrix :: \"('a::semiring_1)^'m^'m \\<Rightarrow> ('a::semiring_1)^'n^'n \\<Rightarrow> bool\" (infixr \"\\<sim>\" 25)\n  where \"similar_matrix A B \\<longleftrightarrow> (\\<exists> P. invertible P \\<and> A = P\\<^sup>-\\<^sup>1 ** B ** P)\""], ["", "lemma similar_matrix_refl[simp]: \"A \\<sim> A\" for A :: \"'a::division_ring^'n^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sim> A", "by (unfold similar_matrix_def, rule_tac x=\"mat 1\" in exI, simp)"], ["", "lemma similar_matrix_simm: \"A \\<sim> B \\<Longrightarrow> B \\<sim> A\" for A B :: \"('a::semiring_1)^'n^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<sim> B \\<Longrightarrow> B \\<sim> A", "apply(unfold similar_matrix_def, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>invertible P; A = P\\<^sup>-\\<^sup>1 ** B ** P\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pa.\n                            invertible Pa \\<and>\n                            B =\n                            Pa\\<^sup>-\\<^sup>1 **\n                            (P\\<^sup>-\\<^sup>1 ** B ** P) **\n                            Pa", "apply(rule_tac x=\"P\\<^sup>-\\<^sup>1\" in exI, simp add: invertible_matrix_inv)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>invertible P; A = P\\<^sup>-\\<^sup>1 ** B ** P\\<rbrakk>\n       \\<Longrightarrow> B =\n                         P ** (P\\<^sup>-\\<^sup>1 ** B ** P) **\n                         P\\<^sup>-\\<^sup>1", "by (metis invertible_def matrix_inv_unique matrix_mul_assoc matrix_mul_lid matrix_mul_rid)"], ["", "lemma similar_matrix_trans: \"A \\<sim> B \\<Longrightarrow> B \\<sim> C \\<Longrightarrow> A \\<sim> C\" for A B C :: \"('a::semiring_1)^'n^'n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A \\<sim> B; B \\<sim> C\\<rbrakk> \\<Longrightarrow> A \\<sim> C", "proof(unfold similar_matrix_def, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "fix P Q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "assume \"A = P\\<^sup>-\\<^sup>1 ** (Q\\<^sup>-\\<^sup>1 ** C ** Q) ** P\" and \"B = Q\\<^sup>-\\<^sup>1 ** C ** Q\""], ["proof (state)\nthis:\n  A = P\\<^sup>-\\<^sup>1 ** (Q\\<^sup>-\\<^sup>1 ** C ** Q) ** P\n  B = Q\\<^sup>-\\<^sup>1 ** C ** Q\n\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "let ?R = \"Q ** P\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "assume inverts: \"invertible Q\" \"invertible P\""], ["proof (state)\nthis:\n  invertible Q\n  invertible P\n\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "hence \"?R\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1\""], ["proof (prove)\nusing this:\n  invertible Q\n  invertible P\n\ngoal (1 subgoal):\n 1. (Q ** P)\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1", "by (rule matrix_inv_matrix_mul)"], ["proof (state)\nthis:\n  (Q ** P)\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1\n\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "also"], ["proof (state)\nthis:\n  (Q ** P)\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1\n\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "have \"invertible ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible (Q ** P)", "using inverts invertible_mult"], ["proof (prove)\nusing this:\n  invertible Q\n  invertible P\n  \\<lbrakk>invertible ?A; invertible ?B\\<rbrakk>\n  \\<Longrightarrow> invertible (?A ** ?B)\n\ngoal (1 subgoal):\n 1. invertible (Q ** P)", "by blast"], ["proof (state)\nthis:\n  invertible (Q ** P)\n\ngoal (1 subgoal):\n 1. \\<And>P Pa.\n       \\<lbrakk>invertible P;\n        A = P\\<^sup>-\\<^sup>1 ** (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) ** P;\n        invertible Pa; B = Pa\\<^sup>-\\<^sup>1 ** C ** Pa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>Pb.\n                            invertible Pb \\<and>\n                            P\\<^sup>-\\<^sup>1 **\n                            (Pa\\<^sup>-\\<^sup>1 ** C ** Pa) **\n                            P =\n                            Pb\\<^sup>-\\<^sup>1 ** C ** Pb", "ultimately"], ["proof (chain)\npicking this:\n  (Q ** P)\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1\n  invertible (Q ** P)", "show \"\\<exists>R. invertible R \\<and> P\\<^sup>-\\<^sup>1 ** (Q\\<^sup>-\\<^sup>1 ** C ** Q) ** P = R\\<^sup>-\\<^sup>1 ** C ** R\""], ["proof (prove)\nusing this:\n  (Q ** P)\\<^sup>-\\<^sup>1 = P\\<^sup>-\\<^sup>1 ** Q\\<^sup>-\\<^sup>1\n  invertible (Q ** P)\n\ngoal (1 subgoal):\n 1. \\<exists>R.\n       invertible R \\<and>\n       P\\<^sup>-\\<^sup>1 ** (Q\\<^sup>-\\<^sup>1 ** C ** Q) ** P =\n       R\\<^sup>-\\<^sup>1 ** C ** R", "by (metis matrix_mul_assoc)"], ["proof (state)\nthis:\n  \\<exists>R.\n     invertible R \\<and>\n     P\\<^sup>-\\<^sup>1 ** (Q\\<^sup>-\\<^sup>1 ** C ** Q) ** P =\n     R\\<^sup>-\\<^sup>1 ** C ** R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mat_vec_nth_simps[simp]:\n  \"i = j \\<Longrightarrow> mat c $ i $ j = c\" \n  \"i \\<noteq> j \\<Longrightarrow> mat c $ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<Longrightarrow> mat c $ i $ j = c) &&&\n    (i \\<noteq> j \\<Longrightarrow> mat c $ i $ j = (0::'b))", "by (simp_all add: mat_def)"], ["", "definition \"diag_mat f = (\\<chi> i j. if i = j then f i else 0)\""], ["", "lemma diag_mat_vec_nth_simps[simp]:\n  \"i = j \\<Longrightarrow> diag_mat f $ i $ j = f i\"\n  \"i \\<noteq> j \\<Longrightarrow> diag_mat f $ i $ j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<Longrightarrow> diag_mat f $ i $ j = f i) &&&\n    (i \\<noteq> j \\<Longrightarrow> diag_mat f $ i $ j = (0::'b))", "unfolding diag_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (i = j \\<Longrightarrow>\n     (\\<chi>i j. if i = j then f i else (0::'b)) $ i $ j = f i) &&&\n    (i \\<noteq> j \\<Longrightarrow>\n     (\\<chi>i j. if i = j then f i else (0::'b)) $ i $ j = (0::'b))", "by simp_all"], ["", "lemma diag_mat_const_eq[simp]: \"diag_mat (\\<lambda>i. c) = mat c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat (\\<lambda>i. c) = mat c", "unfolding mat_def diag_mat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j. if i = j then c else (0::'a)) =\n    (\\<chi>i j. if i = j then c else (0::'a))", "by simp"], ["", "lemma matrix_vector_mul_diag_mat: \"diag_mat f *v s = (\\<chi> i. f i * s$i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat f *v s = (\\<chi>i. f i * s $ i)", "unfolding diag_mat_def matrix_vector_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i.\n        \\<Sum>j\\<in>UNIV.\n          (\\<chi>i j. if i = j then f i else (0::'a)) $ i $ j * s $ j) =\n    (\\<chi>i. f i * s $ i)", "by simp"], ["", "lemma matrix_vector_mul_diag_axis[simp]: \"diag_mat f *v (axis i k) = axis i (f i * k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat f *v axis i k = axis i (f i * k)", "by (simp add: matrix_vector_mul_diag_mat axis_def fun_eq_iff)"], ["", "lemma matrix_mul_diag_matl: \"diag_mat f ** A = (\\<chi> i j. f i * A$i$j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat f ** A = (\\<chi>i j. f i * A $ i $ j)", "unfolding diag_mat_def matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          (\\<chi>i j. if i = j then f i else (0::'a)) $ i $ k * A $ k $ j) =\n    (\\<chi>i j. f i * A $ i $ j)", "by simp"], ["", "lemma matrix_matrix_mul_diag_matr: \"A ** diag_mat f = (\\<chi> i j. A$i$j * f j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ** diag_mat f = (\\<chi>i j. A $ i $ j * f j)", "unfolding diag_mat_def matrix_matrix_mult_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<chi>i j.\n        \\<Sum>k\\<in>UNIV.\n          A $ i $ k * (\\<chi>i j. if i = j then f i else (0::'a)) $ k $ j) =\n    (\\<chi>i j. A $ i $ j * f j)", "apply(clarsimp simp: fun_eq_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (\\<Sum>k\\<in>UNIV. A $ x $ k * (if k = xa then f k else (0::'a))) =\n       A $ x $ xa * f xa", "subgoal for i j"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>k\\<in>UNIV. A $ i $ k * (if k = j then f k else (0::'a))) =\n    A $ i $ j * f j", "by (auto simp: finite_sum_univ_singleton[of _ j])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma matrix_mul_diag_diag: \"diag_mat f ** diag_mat g = diag_mat (\\<lambda>i. f i * g i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. diag_mat f ** diag_mat g = diag_mat (\\<lambda>i. f i * g i)", "unfolding diag_mat_def matrix_matrix_mult_def vec_eq_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i ia.\n       (\\<chi>i j.\n           \\<Sum>k\\<in>UNIV.\n             (\\<chi>i j. if i = j then f i else (0::'a)) $ i $ k *\n             (\\<chi>i j. if i = j then g i else (0::'a)) $ k $ j) $\n       i $\n       ia =\n       (\\<chi>i j. if i = j then f i * g i else (0::'a)) $ i $ ia", "by simp"], ["", "lemma compow_matrix_mul_diag_mat_eq: \"((**) (diag_mat f) ^^ n) (mat 1) = diag_mat (\\<lambda>i. f i^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((**) (diag_mat f) ^^ n) (mat (1::'a)) = diag_mat (\\<lambda>i. f i ^ n)", "apply(induct n, simp_all add: matrix_mul_diag_matl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((\\<lambda>a. \\<chi>i j. f i * a $ i $ j) ^^ n) (mat (1::'a)) =\n       diag_mat (\\<lambda>i. f i ^ n) \\<Longrightarrow>\n       (\\<chi>i j. f i * diag_mat (\\<lambda>i. f i ^ n) $ i $ j) =\n       diag_mat (\\<lambda>i. f i * f i ^ n)", "by (auto simp: vec_eq_iff diag_mat_def)"], ["", "lemma compow_similar_diag_mat_eq:\n  assumes \"invertible P\" \n      and \"A = P\\<^sup>-\\<^sup>1 ** (diag_mat f) ** P\"\n    shows \"((**) A ^^ n) (mat 1) = P\\<^sup>-\\<^sup>1 ** (diag_mat (\\<lambda>i. f i^n)) ** P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((**) A ^^ n) (mat (1::'a)) =\n    P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P", "proof(induct n, simp_all add: assms)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((**) (P\\<^sup>-\\<^sup>1 ** diag_mat f ** P) ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) **\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n       (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "fix n::nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((**) (P\\<^sup>-\\<^sup>1 ** diag_mat f ** P) ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) **\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n       (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "have \"P\\<^sup>-\\<^sup>1 ** diag_mat f ** P ** (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) = \n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P\" (is \"?lhs = _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n    (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n    P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P", "by (metis (no_types, lifting) assms(1) invertibleD(2) matrix_mul_rid matrix_mul_assoc)"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n  (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((**) (P\\<^sup>-\\<^sup>1 ** diag_mat f ** P) ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) **\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n       (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "also"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n  (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((**) (P\\<^sup>-\\<^sup>1 ** diag_mat f ** P) ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) **\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n       (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "have \"... = P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P =\n    P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "by (metis (full_types) matrix_mul_assoc matrix_mul_diag_diag)"], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** diag_mat (\\<lambda>i. f i ^ n) ** P =\n  P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       ((**) (P\\<^sup>-\\<^sup>1 ** diag_mat f ** P) ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) **\n       P \\<Longrightarrow>\n       P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n       (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "finally"], ["proof (chain)\npicking this:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n  (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n  P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "show \"?lhs = ?rhs\""], ["proof (prove)\nusing this:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n  (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n  P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P\n\ngoal (1 subgoal):\n 1. P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n    (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n    P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P", "."], ["proof (state)\nthis:\n  P\\<^sup>-\\<^sup>1 ** diag_mat f ** P **\n  (P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P) =\n  P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i * f i ^ n) ** P\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compow_similar_diag_mat:\n  assumes \"A \\<sim> (diag_mat f)\"\n  shows \"((**) A ^^ n) (mat 1) \\<sim> diag_mat (\\<lambda>i. f i^n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((**) A ^^ n) (mat (1::'a)) \\<sim> diag_mat (\\<lambda>i. f i ^ n)", "proof(unfold similar_matrix_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       ((**) A ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P", "obtain P where \"invertible P\" and \"A = P\\<^sup>-\\<^sup>1 ** (diag_mat f) ** P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  A \\<sim> diag_mat f\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding similar_matrix_def"], ["proof (prove)\nusing this:\n  \\<exists>P. invertible P \\<and> A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\n\ngoal (1 subgoal):\n 1. (\\<And>P.\n        \\<lbrakk>invertible P;\n         A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  invertible P\n  A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       ((**) A ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P", "thus \"\\<exists>P. invertible P \\<and> ((**) A ^^ n) (mat 1) = P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P\""], ["proof (prove)\nusing this:\n  invertible P\n  A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       ((**) A ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P", "using compow_similar_diag_mat_eq"], ["proof (prove)\nusing this:\n  invertible P\n  A = P\\<^sup>-\\<^sup>1 ** diag_mat f ** P\n  \\<lbrakk>invertible ?P;\n   ?A = ?P\\<^sup>-\\<^sup>1 ** diag_mat ?f ** ?P\\<rbrakk>\n  \\<Longrightarrow> ((**) ?A ^^ ?n) (mat (1::?'a)) =\n                    ?P\\<^sup>-\\<^sup>1 **\n                    diag_mat (\\<lambda>i. ?f i ^ ?n) **\n                    ?P\n\ngoal (1 subgoal):\n 1. \\<exists>P.\n       invertible P \\<and>\n       ((**) A ^^ n) (mat (1::'a)) =\n       P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P", "by blast"], ["proof (state)\nthis:\n  \\<exists>P.\n     invertible P \\<and>\n     ((**) A ^^ n) (mat (1::'a)) =\n     P\\<^sup>-\\<^sup>1 ** diag_mat (\\<lambda>i. f i ^ n) ** P\n\ngoal:\nNo subgoals!", "qed"], ["", "no_notation matrix_inv (\"_\\<^sup>-\\<^sup>1\" [90])\n        and similar_matrix (infixr \"\\<sim>\" 25)"], ["", "end"]]}