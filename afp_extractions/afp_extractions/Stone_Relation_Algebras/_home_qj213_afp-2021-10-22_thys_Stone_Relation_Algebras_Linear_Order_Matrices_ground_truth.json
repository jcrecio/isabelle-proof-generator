{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras/Linear_Order_Matrices.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras", "problem_names": ["lemma linorder_finite_sup_selective:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::linorder_stone_algebra_expansion\"\n  shows \"\\<exists>i . (\\<Squnion>\\<^sub>k f k) = f i\"", "lemma linorder_top_finite_sup:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::linorder_stone_algebra_expansion\"\n  assumes \"\\<forall>k . f k \\<noteq> top\"\n    shows \"(\\<Squnion>\\<^sub>k f k) \\<noteq> top\"", "lemma comp_top_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"(f \\<odot> mtop) (i,j) = (\\<Squnion>\\<^sub>k f (i,k))\"", "lemma top_comp_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"(mtop \\<odot> f) (i,j) = (\\<Squnion>\\<^sub>k f (k,j))\"", "lemma univalent_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.univalent f\"\n      and \"f (i,j) \\<noteq> bot\"\n      and \"f (i,k) \\<noteq> bot\"\n    shows \"j = k\"", "lemma univalent_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j k . f (i,j) \\<noteq> bot \\<and> f (i,k) \\<noteq> bot \\<longrightarrow> j = k\"\n    shows \"matrix_stone_relation_algebra.univalent f\"", "lemma univalent_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.univalent f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) \\<noteq> bot \\<and> f (i,k) \\<noteq> bot \\<longrightarrow> j = k)\"", "lemma injective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.injective f \\<longleftrightarrow> (\\<forall>i j k . f (j,i) \\<noteq> bot \\<and> f (k,i) \\<noteq> bot \\<longrightarrow> j = k)\"", "lemma total_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.total_var f\"\n    shows \"\\<exists>j . f (i,j) = top\"", "lemma total_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . \\<exists>j . f (i,j) = top\"\n    shows \"matrix_stone_relation_algebra.total_var f\"", "lemma total_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.total f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) = top)\"", "lemma surjective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.surjective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) = top)\"", "lemma mapping_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\"", "lemma mapping_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>!j . f (i,j) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\"", "lemma bijective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma bijective_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>!i . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma pp_total_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<ominus>(f \\<odot> mtop) = mbot\"\n    shows \"\\<exists>j . f (i,j) \\<noteq> bot\"", "lemma pp_total_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot\"\n    shows \"\\<ominus>(f \\<odot> mtop) = mbot\"", "lemma pp_total_linorder_matrix_3:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"\\<ominus>(f \\<odot> mtop) = mbot \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot)\"", "lemma pp_total_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.total (\\<ominus>\\<ominus>f) \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot)\"", "lemma pp_mapping_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\"", "lemma pp_mapping_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>!j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\"", "lemma pp_surjective_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"\\<ominus>(mtop \\<odot> f) = mbot \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot)\"", "lemma pp_surjective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.surjective (\\<ominus>\\<ominus>f) \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot)\"", "lemma pp_bijective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma pp_bijective_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>!i . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma regular_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_p_algebra.regular f \\<longleftrightarrow> (\\<forall>e . f e = bot \\<or> f e = top)\"", "lemma vector_linorder_matrix_0:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.vector f\"\n    shows \"f (i,j) = (\\<Squnion>\\<^sub>k f (i,k))\"", "lemma vector_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.vector f\"\n    shows \"f (i,j) = f (i,k)\"", "lemma vector_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j k . f (i,j) = f (i,k)\"\n    shows \"matrix_bounded_idempotent_semiring.vector f\"", "lemma vector_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.vector f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) = f (i,k))\"", "lemma covector_linorder_matrix_0:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.covector f\"\n    shows \"f (i,j) = (\\<Squnion>\\<^sub>k f (k,j))\"", "lemma covector_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.covector f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) = f (k,j))\"", "lemma point_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.point f \\<longleftrightarrow> (\\<exists>i . \\<forall>j . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma point_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.point f \\<longleftrightarrow> (\\<exists>!i . \\<forall>j . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma pp_point_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_point f \\<longleftrightarrow> (\\<exists>i . \\<forall>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . f (i,j) = f (i,k)) \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma pp_point_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_point f \\<longleftrightarrow> (\\<exists>!i . \\<forall>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . f (i,j) = f (i,k)) \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\"", "lemma arc_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.arc f\"\n    shows \"\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"", "lemma pp_arc_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"\n    shows \"matrix_stone_relation_algebra.pp_arc f\"", "lemma arc_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"\n    shows \"matrix_stone_relation_algebra.arc f\"", "lemma arc_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.arc f \\<longleftrightarrow> (\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\"", "lemma arc_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.arc f \\<longleftrightarrow> (\\<exists>!e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\"", "lemma pp_arc_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.pp_arc f\"\n    shows \"\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"", "lemma pp_arc_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_arc f \\<longleftrightarrow> (\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\"", "lemma pp_arc_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_arc f \\<longleftrightarrow> (\\<exists>!e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\"", "lemma reflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.reflexive f\"\n    shows \"f (i,i) = top\"", "lemma reflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . f (i,i) = top\"\n    shows \"matrix_idempotent_semiring.reflexive f\"", "lemma reflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.reflexive f \\<longleftrightarrow> (\\<forall>i . f (i,i) = top)\"", "lemma coreflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive f\"\n      and \"i \\<noteq> j\"\n    shows \"f (i,j) = bot\"", "lemma coreflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot\"\n    shows \"matrix_idempotent_semiring.coreflexive f\"", "lemma coreflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.coreflexive f \\<longleftrightarrow> (\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot)\"", "lemma irreflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.irreflexive f\"\n    shows \"f (i,i) = bot\"", "lemma irreflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . f (i,i) = bot\"\n    shows \"matrix_stone_relation_algebra.irreflexive f\"", "lemma irreflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.irreflexive f \\<longleftrightarrow> (\\<forall>i . f (i,i) = bot)\"", "lemma symmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.symmetric f \\<longleftrightarrow> (\\<forall>i j . f (i,j) = f (j,i))\"", "lemma antisymmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.antisymmetric f \\<longleftrightarrow> (\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot \\<or> f (j,i) = bot)\"", "lemma asymmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.asymmetric f \\<longleftrightarrow> (\\<forall>i j . f (i,j) = bot \\<or> f (j,i) = bot)\"", "lemma transitive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.transitive f \\<longleftrightarrow> (\\<forall>i j k . f (i,k) \\<le> f (i,j) \\<or> f (k,j) \\<le> f (i,j))\"", "lemma coreflexive_comp_linorder_matrix:\n  fixes f g :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive f\"\n    shows \"(f \\<odot> g) (i,j) = f (i,i) \\<sqinter> g (i,j)\"", "lemma comp_coreflexive_linorder_matrix:\n  fixes f g :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive g\"\n    shows \"(f \\<odot> g) (i,j) = f (i,j) \\<sqinter> g (j,j)\""], "translations": [["", "lemma linorder_finite_sup_selective:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::linorder_stone_algebra_expansion\"\n  shows \"\\<exists>i . (\\<Squnion>\\<^sub>k f k) = f i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i. sup_monoid.sum f {k. True} = f i", "apply (induct rule: comp_inf.one_sup_induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i. \\<exists>ia. f i = f ia\n 2. \\<And>j I.\n       \\<lbrakk>j \\<notin> I; \\<exists>i. sup_monoid.sum f I = f i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. f j \\<squnion> sup_monoid.sum f I = f i", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j I.\n       \\<lbrakk>j \\<notin> I; \\<exists>i. sup_monoid.sum f I = f i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. f j \\<squnion> sup_monoid.sum f I = f i", "using sup_selective"], ["proof (prove)\nusing this:\n  ?x \\<squnion> ?y = ?x \\<or> ?x \\<squnion> ?y = ?y\n\ngoal (1 subgoal):\n 1. \\<And>j I.\n       \\<lbrakk>j \\<notin> I; \\<exists>i. sup_monoid.sum f I = f i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. f j \\<squnion> sup_monoid.sum f I = f i", "by fastforce"], ["", "lemma linorder_top_finite_sup:\n  fixes f :: \"'a::finite \\<Rightarrow> 'b::linorder_stone_algebra_expansion\"\n  assumes \"\\<forall>k . f k \\<noteq> top\"\n    shows \"(\\<Squnion>\\<^sub>k f k) \\<noteq> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum f {k. True} \\<noteq> top", "by (metis assms linorder_finite_sup_selective)"], ["", "text \\<open>\nThe following results show the effect of composition with the \\<open>top\\<close> matrix from the left and from the right.\n\\<close>"], ["", "lemma comp_top_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"(f \\<odot> mtop) (i,j) = (\\<Squnion>\\<^sub>k f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> mtop) (i, j) =\n    sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}", "apply (unfold times_matrix_def top_matrix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i, j) of\n     (i, j) \\<Rightarrow>\n       sup_monoid.sum (\\<lambda>k. f (i, k) * top) {k. True}) =\n    sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}", "by (metis (no_types, lifting) case_prod_conv comp_right_one one_def sup_monoid.sum.cong)"], ["", "lemma top_comp_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"(mtop \\<odot> f) (i,j) = (\\<Squnion>\\<^sub>k f (k,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtop \\<odot> f) (i, j) =\n    sup_monoid.sum (\\<lambda>k. f (k, j)) {k. True}", "apply (unfold times_matrix_def top_matrix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (i, j) of\n     (i, j) \\<Rightarrow>\n       sup_monoid.sum (\\<lambda>k. top * f (k, j)) {k. True}) =\n    sup_monoid.sum (\\<lambda>k. f (k, j)) {k. True}", "by (metis (no_types, lifting) case_prod_conv comp_left_one one_def sup_monoid.sum.cong)"], ["", "text \\<open>\nWe characterise univalent matrices: in each row, at most one entry may be different from \\<open>bot\\<close>.\n\\<close>"], ["", "lemma univalent_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.univalent f\"\n      and \"f (i,j) \\<noteq> bot\"\n      and \"f (i,k) \\<noteq> bot\"\n    shows \"j = k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = k", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. j = k", "have \"(f\\<^sup>t \\<odot> f) (j,k) = (\\<Squnion>\\<^sub>l (f\\<^sup>t) (j,l) * f (l,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) =\n    sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True}", "by (simp add: times_matrix_def)"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) =\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "also"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) =\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "have \"... = (\\<Squnion>\\<^sub>l (f (l,j))\\<^sup>T * f (l,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True} =\n    sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True}", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True} =\n  sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t) (j, l) * f (l, k)) {l. True} =\n  sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "have \"... = (\\<Squnion>\\<^sub>l f (l,j) * f (l,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True} =\n    sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}", "by simp"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True} =\n  sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. f (l, j)\\<^sup>T * f (l, k)) {l. True} =\n  sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "have \"... \\<ge> f (i,j) * f (i,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) * f (i, k)\n    \\<le> sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}", "using comp_inf.ub_sum"], ["proof (prove)\nusing this:\n  ?f ?i \\<le> sup_monoid.sum ?f {k. True}\n\ngoal (1 subgoal):\n 1. f (i, j) * f (i, k)\n    \\<le> sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}", "by fastforce"], ["proof (state)\nthis:\n  f (i, j) * f (i, k)\n  \\<le> sup_monoid.sum (\\<lambda>l. f (l, j) * f (l, k)) {l. True}\n\ngoal (1 subgoal):\n 1. j = k", "finally"], ["proof (chain)\npicking this:\n  f (i, j) * f (i, k) \\<le> (f\\<^sup>t \\<odot> f) (j, k)", "have \"(f\\<^sup>t \\<odot> f) (j,k) \\<noteq> bot\""], ["proof (prove)\nusing this:\n  f (i, j) * f (i, k) \\<le> (f\\<^sup>t \\<odot> f) (j, k)\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) \\<noteq> bot", "using assms(2,3) bot.extremum_uniqueI times_dense"], ["proof (prove)\nusing this:\n  f (i, j) * f (i, k) \\<le> (f\\<^sup>t \\<odot> f) (j, k)\n  f (i, j) \\<noteq> bot\n  f (i, k) \\<noteq> bot\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n  \\<lbrakk>?x \\<noteq> bot; ?y \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> ?x * ?y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) \\<noteq> bot", "by fastforce"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. j = k", "hence \"mone (j,k) \\<noteq> (bot::'b)\""], ["proof (prove)\nusing this:\n  (f\\<^sup>t \\<odot> f) (j, k) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. mone (j, k) \\<noteq> bot", "by (metis assms(1) bot.extremum_uniqueI less_eq_matrix_def)"], ["proof (state)\nthis:\n  mone (j, k) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. j = k", "thus ?thesis"], ["proof (prove)\nusing this:\n  mone (j, k) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. j = k", "by (metis (mono_tags, lifting) case_prod_conv one_matrix_def)"], ["proof (state)\nthis:\n  j = k\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma univalent_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j k . f (i,j) \\<noteq> bot \\<and> f (i,k) \\<noteq> bot \\<longrightarrow> j = k\"\n    shows \"matrix_stone_relation_algebra.univalent f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.univalent f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.univalent f", "show \"f\\<^sup>t \\<odot> f \\<preceq> mone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.univalent f", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f\\<^sup>t \\<odot> f) (a, b) \\<le> mone (a, b)", "fix j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f\\<^sup>t \\<odot> f) (a, b) \\<le> mone (a, b)", "show \"(f\\<^sup>t \\<odot> f) (j,k) \\<le> mone (j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "proof (cases \"j = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "assume \"j = k\""], ["proof (state)\nthis:\n  j = k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j = k\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)\n\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "hence \"(\\<Squnion>\\<^sub>i f (i,j) * f (i,k)) = bot\""], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>i. f (i, j) * f (i, k)) {i. True} = bot", "by (metis (no_types, lifting) assms semiring.mult_not_zero sup_monoid.sum.neutral)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>i. f (i, j) * f (i, k)) {i. True} = bot\n\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>i. f (i, j) * f (i, k)) {i. True} = bot\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)", "by (simp add: times_matrix_def conv_matrix_def)"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> f) (j, k) \\<le> mone (j, k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.univalent f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma univalent_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.univalent f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) \\<noteq> bot \\<and> f (i,k) \\<noteq> bot \\<longrightarrow> j = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.univalent f =\n    (\\<forall>i j k.\n        f (i, j) \\<noteq> bot \\<and> f (i, k) \\<noteq> bot \\<longrightarrow>\n        j = k)", "using univalent_linorder_matrix_1 univalent_linorder_matrix_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>matrix_stone_relation_algebra.univalent ?f;\n   ?f (?i, ?j) \\<noteq> bot; ?f (?i, ?k) \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> ?j = ?k\n  \\<forall>i j k.\n     ?f (i, j) \\<noteq> bot \\<and> ?f (i, k) \\<noteq> bot \\<longrightarrow>\n     j = k \\<Longrightarrow>\n  matrix_stone_relation_algebra.univalent ?f\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.univalent f =\n    (\\<forall>i j k.\n        f (i, j) \\<noteq> bot \\<and> f (i, k) \\<noteq> bot \\<longrightarrow>\n        j = k)", "by auto"], ["", "text \\<open>\nInjective matrices can then be characterised by applying converse: in each column, at most one entry may be different from \\<open>bot\\<close>.\n\\<close>"], ["", "lemma injective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.injective f \\<longleftrightarrow> (\\<forall>i j k . f (j,i) \\<noteq> bot \\<and> f (k,i) \\<noteq> bot \\<longrightarrow> j = k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.injective f =\n    (\\<forall>i j k.\n        f (j, i) \\<noteq> bot \\<and> f (k, i) \\<noteq> bot \\<longrightarrow>\n        j = k)", "by (unfold matrix_stone_relation_algebra.injective_conv_univalent univalent_linorder_matrix) (simp add: conv_matrix_def)"], ["", "text \\<open>\nNext come total matrices: each row has a \\<open>top\\<close> entry.\n\\<close>"], ["", "lemma total_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.total_var f\"\n    shows \"\\<exists>j . f (i,j) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "have \"mone (i,i) \\<le> (f \\<odot> f\\<^sup>t) (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mone (i, i) \\<le> (f \\<odot> f\\<^sup>t) (i, i)", "using assms less_eq_matrix_def"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.total_var f\n  (?f \\<preceq> ?g) = (\\<forall>e. ?f e \\<le> ?g e)\n\ngoal (1 subgoal):\n 1. mone (i, i) \\<le> (f \\<odot> f\\<^sup>t) (i, i)", "by blast"], ["proof (state)\nthis:\n  mone (i, i) \\<le> (f \\<odot> f\\<^sup>t) (i, i)\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "hence \"top = (f \\<odot> f\\<^sup>t) (i,i)\""], ["proof (prove)\nusing this:\n  mone (i, i) \\<le> (f \\<odot> f\\<^sup>t) (i, i)\n\ngoal (1 subgoal):\n 1. top = (f \\<odot> f\\<^sup>t) (i, i)", "by (simp add: one_matrix_def top.extremum_unique)"], ["proof (state)\nthis:\n  top = (f \\<odot> f\\<^sup>t) (i, i)\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "also"], ["proof (state)\nthis:\n  top = (f \\<odot> f\\<^sup>t) (i, i)\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "have \"... = (\\<Squnion>\\<^sub>j f (i,j) * (f\\<^sup>t) (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> f\\<^sup>t) (i, i) =\n    sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True}", "by (simp add: times_matrix_def)"], ["proof (state)\nthis:\n  (f \\<odot> f\\<^sup>t) (i, i) =\n  sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "also"], ["proof (state)\nthis:\n  (f \\<odot> f\\<^sup>t) (i, i) =\n  sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "have \"... = (\\<Squnion>\\<^sub>j f (i,j) * f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True} =\n    sup_monoid.sum (\\<lambda>j. f (i, j) * f (i, j)) {j. True}", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True} =\n  sup_monoid.sum (\\<lambda>j. f (i, j) * f (i, j)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>j. f (i, j) * (f\\<^sup>t) (j, i)) {j. True} =\n  sup_monoid.sum (\\<lambda>j. f (i, j) * f (i, j)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "have \"... = (\\<Squnion>\\<^sub>j f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>j. f (i, j) * f (i, j)) {j. True} =\n    sup_monoid.sum (\\<lambda>j. f (i, j)) {j. True}", "by simp"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>j. f (i, j) * f (i, j)) {j. True} =\n  sup_monoid.sum (\\<lambda>j. f (i, j)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "finally"], ["proof (chain)\npicking this:\n  top = sup_monoid.sum (\\<lambda>j. f (i, j)) {j. True}", "show ?thesis"], ["proof (prove)\nusing this:\n  top = sup_monoid.sum (\\<lambda>j. f (i, j)) {j. True}\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) = top", "by (metis linorder_top_finite_sup)"], ["proof (state)\nthis:\n  \\<exists>j. f (i, j) = top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma total_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . \\<exists>j . f (i,j) = top\"\n    shows \"matrix_stone_relation_algebra.total_var f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.total_var f", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. mone (a, b) \\<le> (f \\<odot> f\\<^sup>t) (a, b)", "fix j k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. mone (a, b) \\<le> (f \\<odot> f\\<^sup>t) (a, b)", "show \"mone (j,k) \\<le> (f \\<odot> f\\<^sup>t) (j,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "proof (cases \"j = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "assume \"j = k\""], ["proof (state)\nthis:\n  j = k\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "hence \"(\\<Squnion>\\<^sub>i f (j,i) * (f\\<^sup>t) (i,k)) = (\\<Squnion>\\<^sub>i f (j,i))\""], ["proof (prove)\nusing this:\n  j = k\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>i. f (j, i) * (f\\<^sup>t) (i, k)) {i. True} =\n    sup_monoid.sum (\\<lambda>i. f (j, i)) {i. True}", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>i. f (j, i) * (f\\<^sup>t) (i, k)) {i. True} =\n  sup_monoid.sum (\\<lambda>i. f (j, i)) {i. True}\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>i. f (j, i) * (f\\<^sup>t) (i, k)) {i. True} =\n  sup_monoid.sum (\\<lambda>i. f (j, i)) {i. True}\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "have \"... = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>i. f (j, i)) {i. True} = top", "by (metis (no_types) assms comp_inf.ub_sum sup.absorb2 sup_top_left)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>i. f (j, i)) {i. True} = top\n\ngoal (2 subgoals):\n 1. j = k \\<Longrightarrow> mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n 2. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "finally"], ["proof (chain)\npicking this:\n  sup_monoid.sum (\\<lambda>i. f (j, i) * (f\\<^sup>t) (i, k)) {i. True} = top", "show ?thesis"], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>i. f (j, i) * (f\\<^sup>t) (i, k)) {i. True} = top\n\ngoal (1 subgoal):\n 1. mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "by (simp add: times_matrix_def)"], ["proof (state)\nthis:\n  mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. j \\<noteq> k \\<Longrightarrow>\n    mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "thus ?thesis"], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mone (j, k) \\<le> (f \\<odot> f\\<^sup>t) (j, k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma total_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.total f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total f =\n    (\\<forall>i. \\<exists>j. f (i, j) = top)", "using total_linorder_matrix_1 total_linorder_matrix_2 matrix_stone_relation_algebra.total_var"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.total_var ?f \\<Longrightarrow>\n  \\<exists>j. ?f (?i, j) = top\n  \\<forall>i. \\<exists>j. ?f (i, j) = top \\<Longrightarrow>\n  matrix_stone_relation_algebra.total_var ?f\n  matrix_bounded_idempotent_semiring.total ?x =\n  matrix_stone_relation_algebra.total_var ?x\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total f =\n    (\\<forall>i. \\<exists>j. f (i, j) = top)", "by auto"], ["", "text \\<open>\nSurjective matrices are again characterised by applying converse: each column has a \\<open>top\\<close> entry.\n\\<close>"], ["", "lemma surjective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.surjective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.surjective f =\n    (\\<forall>j. \\<exists>i. f (i, j) = top)", "by (unfold matrix_stone_relation_algebra.surjective_conv_total total_linorder_matrix) (simp add: conv_matrix_def)"], ["", "text \\<open>\nA mapping therefore means that each row has exactly one \\<open>top\\<close> entry and all others are \\<open>bot\\<close>.\n\\<close>"], ["", "lemma mapping_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.mapping f =\n    (\\<forall>i.\n        \\<exists>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "by (unfold total_linorder_matrix univalent_linorder_matrix) (metis (mono_tags, hide_lams) comp_inf.mult_1_right comp_inf.mult_right_zero)"], ["", "lemma mapping_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>!j . f (i,j) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.mapping f =\n    (\\<forall>i.\n        \\<exists>!j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "apply (unfold mapping_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        \\<exists>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot)) =\n    (\\<forall>i.\n        \\<exists>!j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "using bot_not_top"], ["proof (prove)\nusing this:\n  bot \\<noteq> top\n\ngoal (1 subgoal):\n 1. (\\<forall>i.\n        \\<exists>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot)) =\n    (\\<forall>i.\n        \\<exists>!j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "by auto"], ["", "text \\<open>\nConversely, bijective means that each column has exactly one \\<open>top\\<close> entry and all others are \\<open>bot\\<close>.\n\\<close>"], ["", "lemma bijective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.bijective f =\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by (unfold matrix_stone_relation_algebra.bijective_conv_mapping mapping_linorder_matrix) (simp add: conv_matrix_def)"], ["", "lemma bijective_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>!i . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.bijective f =\n    (\\<forall>j.\n        \\<exists>!i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by (unfold matrix_stone_relation_algebra.bijective_conv_mapping mapping_linorder_matrix_unique) (simp add: conv_matrix_def)"], ["", "text \\<open>\nWe derive algebraic characterisations of matrices in which each row has an entry that is different from \\<open>bot\\<close>.\n\\<close>"], ["", "lemma pp_total_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<ominus>(f \\<odot> mtop) = mbot\"\n    shows \"\\<exists>j . f (i,j) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) \\<noteq> bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) \\<noteq> bot", "have \"\\<not>(\\<exists>j . f (i,j) \\<noteq> bot) \\<Longrightarrow> \\<ominus>(f \\<odot> mtop) \\<noteq> mbot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "assume \"\\<not>(\\<exists>j . f (i,j) \\<noteq> bot)\""], ["proof (state)\nthis:\n  \\<nexists>j. f (i, j) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "hence \"top = -(f \\<odot> mtop) (i,i)\""], ["proof (prove)\nusing this:\n  \\<nexists>j. f (i, j) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. top = - (f \\<odot> mtop) (i, i)", "by (simp add: comp_top_linorder_matrix linorder_finite_sup_selective)"], ["proof (state)\nthis:\n  top = - (f \\<odot> mtop) (i, i)\n\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "also"], ["proof (state)\nthis:\n  top = - (f \\<odot> mtop) (i, i)\n\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "have \"... = (\\<ominus>(f \\<odot> mtop)) (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (f \\<odot> mtop) (i, i) = (\\<ominus> (f \\<odot> mtop)) (i, i)", "by (simp add: uminus_matrix_def)"], ["proof (state)\nthis:\n  - (f \\<odot> mtop) (i, i) = (\\<ominus> (f \\<odot> mtop)) (i, i)\n\ngoal (1 subgoal):\n 1. \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n    \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "finally"], ["proof (chain)\npicking this:\n  top = (\\<ominus> (f \\<odot> mtop)) (i, i)", "show \"\\<ominus>(f \\<odot> mtop) \\<noteq> mbot\""], ["proof (prove)\nusing this:\n  top = (\\<ominus> (f \\<odot> mtop)) (i, i)\n\ngoal (1 subgoal):\n 1. \\<ominus> (f \\<odot> mtop) \\<noteq> mbot", "by (metis bot_matrix_def bot_not_top)"], ["proof (state)\nthis:\n  \\<ominus> (f \\<odot> mtop) \\<noteq> mbot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n  \\<ominus> (f \\<odot> mtop) \\<noteq> mbot\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) \\<noteq> bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n  \\<ominus> (f \\<odot> mtop) \\<noteq> mbot\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) \\<noteq> bot", "using assms"], ["proof (prove)\nusing this:\n  \\<nexists>j. f (i, j) \\<noteq> bot \\<Longrightarrow>\n  \\<ominus> (f \\<odot> mtop) \\<noteq> mbot\n  matrix_p_algebra.dense (f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. \\<exists>j. f (i, j) \\<noteq> bot", "by blast"], ["proof (state)\nthis:\n  \\<exists>j. f (i, j) \\<noteq> bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_total_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot\"\n    shows \"\\<ominus>(f \\<odot> mtop) = mbot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (f \\<odot> mtop)", "proof (rule ext, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (\\<ominus> (f \\<odot> mtop)) (a, b) = mbot (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (\\<ominus> (f \\<odot> mtop)) (a, b) = mbot (a, b)", "have \"(\\<ominus>(f \\<odot> mtop)) (i,j) = -(\\<Squnion>\\<^sub>k f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<ominus> (f \\<odot> mtop)) (i, j) =\n    - sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}", "by (simp add: comp_top_linorder_matrix uminus_matrix_def)"], ["proof (state)\nthis:\n  (\\<ominus> (f \\<odot> mtop)) (i, j) =\n  - sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (\\<ominus> (f \\<odot> mtop)) (a, b) = mbot (a, b)", "also"], ["proof (state)\nthis:\n  (\\<ominus> (f \\<odot> mtop)) (i, j) =\n  - sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (\\<ominus> (f \\<odot> mtop)) (a, b) = mbot (a, b)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense (sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True})", "by (metis antisym assms bot.extremum comp_inf.ub_sum uminus_def)"], ["proof (state)\nthis:\n  dense (sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True})\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (\\<ominus> (f \\<odot> mtop)) (a, b) = mbot (a, b)", "finally"], ["proof (chain)\npicking this:\n  (\\<ominus> (f \\<odot> mtop)) (i, j) = bot", "show \"(\\<ominus>(f \\<odot> mtop)) (i,j) = mbot (i,j)\""], ["proof (prove)\nusing this:\n  (\\<ominus> (f \\<odot> mtop)) (i, j) = bot\n\ngoal (1 subgoal):\n 1. (\\<ominus> (f \\<odot> mtop)) (i, j) = mbot (i, j)", "by (simp add: bot_matrix_def)"], ["proof (state)\nthis:\n  (\\<ominus> (f \\<odot> mtop)) (i, j) = mbot (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_total_linorder_matrix_3:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"\\<ominus>(f \\<odot> mtop) = mbot \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (f \\<odot> mtop) =\n    (\\<forall>i. \\<exists>j. f (i, j) \\<noteq> bot)", "using pp_total_linorder_matrix_1 pp_total_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_p_algebra.dense (?f \\<odot> mtop) \\<Longrightarrow>\n  \\<exists>j. ?f (?i, j) \\<noteq> bot\n  \\<forall>i. \\<exists>j. ?f (i, j) \\<noteq> bot \\<Longrightarrow>\n  matrix_p_algebra.dense (?f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (f \\<odot> mtop) =\n    (\\<forall>i. \\<exists>j. f (i, j) \\<noteq> bot)", "by auto"], ["", "lemma pp_total_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.total (\\<ominus>\\<ominus>f) \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total (\\<ominus> \\<ominus> f) =\n    (\\<forall>i. \\<exists>j. f (i, j) \\<noteq> bot)", "using matrix_stone_relation_algebra.pp_total pp_total_linorder_matrix_1 pp_total_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_bounded_idempotent_semiring.total (\\<ominus> \\<ominus> ?x) =\n  matrix_p_algebra.dense (?x \\<odot> mtop)\n  matrix_p_algebra.dense (?f \\<odot> mtop) \\<Longrightarrow>\n  \\<exists>j. ?f (?i, j) \\<noteq> bot\n  \\<forall>i. \\<exists>j. ?f (i, j) \\<noteq> bot \\<Longrightarrow>\n  matrix_p_algebra.dense (?f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total (\\<ominus> \\<ominus> f) =\n    (\\<forall>i. \\<exists>j. f (i, j) \\<noteq> bot)", "by auto"], ["", "lemma pp_mapping_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_mapping f =\n    (\\<forall>i.\n        \\<exists>j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "by (metis (mono_tags, hide_lams) pp_total_linorder_matrix univalent_linorder_matrix_1 univalent_linorder_matrix_2)"], ["", "lemma pp_mapping_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_mapping f \\<longleftrightarrow> (\\<forall>i . \\<exists>!j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_mapping f =\n    (\\<forall>i.\n        \\<exists>!j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_stone_relation_algebra.pp_mapping f \\<Longrightarrow>\n    \\<forall>i.\n       \\<exists>!j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot)\n 2. \\<forall>i.\n       \\<exists>!j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k.\n              j \\<noteq> k \\<longrightarrow>\n              f (i, k) = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_mapping f", "using pp_mapping_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.pp_mapping ?f =\n  (\\<forall>i.\n      \\<exists>j.\n         ?f (i, j) \\<noteq> bot \\<and>\n         (\\<forall>k. j \\<noteq> k \\<longrightarrow> ?f (i, k) = bot))\n\ngoal (2 subgoals):\n 1. matrix_stone_relation_algebra.pp_mapping f \\<Longrightarrow>\n    \\<forall>i.\n       \\<exists>!j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot)\n 2. \\<forall>i.\n       \\<exists>!j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k.\n              j \\<noteq> k \\<longrightarrow>\n              f (i, k) = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_mapping f", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       \\<exists>!j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k.\n              j \\<noteq> k \\<longrightarrow>\n              f (i, k) = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_mapping f", "by (metis pp_total_linorder_matrix univalent_linorder_matrix)"], ["", "text \\<open>\nNext follow matrices in which each column has an entry that is different from \\<open>bot\\<close>.\n\\<close>"], ["", "lemma pp_surjective_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"\\<ominus>(mtop \\<odot> f) = mbot \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "have \"\\<ominus>(mtop \\<odot> f) = mbot \\<longleftrightarrow> (\\<ominus>(mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t)", "by (metis matrix_stone_relation_algebra.conv_involutive)"], ["proof (state)\nthis:\n  matrix_p_algebra.dense (mtop \\<odot> f) =\n  ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "also"], ["proof (state)\nthis:\n  matrix_p_algebra.dense (mtop \\<odot> f) =\n  ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "have \"... \\<longleftrightarrow> \\<ominus>(f\\<^sup>t \\<odot> mtop) = mbot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t) =\n    matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop)", "by (simp add: matrix_stone_relation_algebra.conv_complement matrix_stone_relation_algebra.conv_dist_comp)"], ["proof (state)\nthis:\n  ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t) =\n  matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "also"], ["proof (state)\nthis:\n  ((\\<ominus> (mtop \\<odot> f))\\<^sup>t = mbot\\<^sup>t) =\n  matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "have \"... \\<longleftrightarrow> (\\<forall>i . \\<exists>j . (f\\<^sup>t) (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop) =\n    (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot)", "using pp_total_linorder_matrix_3"], ["proof (prove)\nusing this:\n  matrix_p_algebra.dense (?f \\<odot> mtop) =\n  (\\<forall>i. \\<exists>j. ?f (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop) =\n    (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot)", "by auto"], ["proof (state)\nthis:\n  matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop) =\n  (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "also"], ["proof (state)\nthis:\n  matrix_p_algebra.dense (f\\<^sup>t \\<odot> mtop) =\n  (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "have \"... \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  (\\<forall>i. \\<exists>j. (f\\<^sup>t) (i, j) \\<noteq> bot) =\n  (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "finally"], ["proof (chain)\npicking this:\n  matrix_p_algebra.dense (mtop \\<odot> f) =\n  (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_p_algebra.dense (mtop \\<odot> f) =\n  (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.dense (mtop \\<odot> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "."], ["proof (state)\nthis:\n  matrix_p_algebra.dense (mtop \\<odot> f) =\n  (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_surjective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.surjective (\\<ominus>\\<ominus>f) \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.surjective (\\<ominus> \\<ominus> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "using matrix_stone_relation_algebra.pp_surjective pp_surjective_linorder_matrix_1"], ["proof (prove)\nusing this:\n  matrix_bounded_idempotent_semiring.surjective (\\<ominus> \\<ominus> ?x) =\n  matrix_p_algebra.dense (mtop \\<odot> ?x)\n  matrix_p_algebra.dense (mtop \\<odot> ?f) =\n  (\\<forall>j. \\<exists>i. ?f (i, j) \\<noteq> bot)\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.surjective (\\<ominus> \\<ominus> f) =\n    (\\<forall>j. \\<exists>i. f (i, j) \\<noteq> bot)", "by auto"], ["", "lemma pp_bijective_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>i . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_bijective f =\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by (unfold matrix_stone_relation_algebra.pp_bijective_conv_mapping pp_mapping_linorder_matrix) (simp add: conv_matrix_def)"], ["", "lemma pp_bijective_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_bijective f \\<longleftrightarrow> (\\<forall>j . \\<exists>!i . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_bijective f =\n    (\\<forall>j.\n        \\<exists>!i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by (unfold matrix_stone_relation_algebra.pp_bijective_conv_mapping pp_mapping_linorder_matrix_unique) (simp add: conv_matrix_def)"], ["", "text \\<open>\nThe regular matrices are those which contain only \\<open>bot\\<close> or \\<open>top\\<close> entries.\n\\<close>"], ["", "lemma regular_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_p_algebra.regular f \\<longleftrightarrow> (\\<forall>e . f e = bot \\<or> f e = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "have \"matrix_p_algebra.regular f \\<longleftrightarrow> (\\<ominus>\\<ominus>f = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<ominus> \\<ominus> f = f)", "by auto"], ["proof (state)\nthis:\n  matrix_p_algebra.regular f = (\\<ominus> \\<ominus> f = f)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "also"], ["proof (state)\nthis:\n  matrix_p_algebra.regular f = (\\<ominus> \\<ominus> f = f)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "have \"... \\<longleftrightarrow> (\\<forall>e . --f e = f e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<ominus> \\<ominus> f = f) = (\\<forall>e. - - f e = f e)", "by (metis uminus_matrix_def ext)"], ["proof (state)\nthis:\n  (\\<ominus> \\<ominus> f = f) = (\\<forall>e. - - f e = f e)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "also"], ["proof (state)\nthis:\n  (\\<ominus> \\<ominus> f = f) = (\\<forall>e. - - f e = f e)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "have \"... \\<longleftrightarrow> (\\<forall>e . f e = bot \\<or> f e = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>e. - - f e = f e) = (\\<forall>e. f e = bot \\<or> f e = top)", "by force"], ["proof (state)\nthis:\n  (\\<forall>e. - - f e = f e) = (\\<forall>e. f e = bot \\<or> f e = top)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "finally"], ["proof (chain)\npicking this:\n  matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)\n\ngoal (1 subgoal):\n 1. matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)", "."], ["proof (state)\nthis:\n  matrix_p_algebra.regular f = (\\<forall>e. f e = bot \\<or> f e = top)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nVectors are precisely the row-constant matrices.\n\\<close>"], ["", "lemma vector_linorder_matrix_0:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.vector f\"\n    shows \"f (i,j) = (\\<Squnion>\\<^sub>k f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) = sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}", "by (metis assms comp_top_linorder_matrix)"], ["", "lemma vector_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.vector f\"\n    shows \"f (i,j) = f (i,k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) = f (i, k)", "by (metis assms vector_linorder_matrix_0)"], ["", "lemma vector_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j k . f (i,j) = f (i,k)\"\n    shows \"matrix_bounded_idempotent_semiring.vector f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.vector f", "proof (rule ext, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (f \\<odot> mtop) (a, b) = f (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (f \\<odot> mtop) (a, b) = f (a, b)", "have \"(f \\<odot> mtop) (i,j) = (\\<Squnion>\\<^sub>k f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> mtop) (i, j) =\n    sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  (f \\<odot> mtop) (i, j) = sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (f \\<odot> mtop) (a, b) = f (a, b)", "also"], ["proof (state)\nthis:\n  (f \\<odot> mtop) (i, j) = sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (f \\<odot> mtop) (a, b) = f (a, b)", "have \"... = f (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, j)", "by (metis assms linorder_finite_sup_selective)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, j)\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (f \\<odot> mtop) (a, b) = f (a, b)", "finally"], ["proof (chain)\npicking this:\n  (f \\<odot> mtop) (i, j) = f (i, j)", "show \"(f \\<odot> mtop) (i,j) = f (i,j)\""], ["proof (prove)\nusing this:\n  (f \\<odot> mtop) (i, j) = f (i, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> mtop) (i, j) = f (i, j)", "."], ["proof (state)\nthis:\n  (f \\<odot> mtop) (i, j) = f (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vector_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.vector f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) = f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.vector f =\n    (\\<forall>i j k. f (i, j) = f (i, k))", "using vector_linorder_matrix_1 vector_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_bounded_idempotent_semiring.vector ?f \\<Longrightarrow>\n  ?f (?i, ?j) = ?f (?i, ?k)\n  \\<forall>i j k. ?f (i, j) = ?f (i, k) \\<Longrightarrow>\n  matrix_bounded_idempotent_semiring.vector ?f\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.vector f =\n    (\\<forall>i j k. f (i, j) = f (i, k))", "by auto"], ["", "text \\<open>\nHence covectors are precisely the column-constant matrices.\n\\<close>"], ["", "lemma covector_linorder_matrix_0:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_bounded_idempotent_semiring.covector f\"\n    shows \"f (i,j) = (\\<Squnion>\\<^sub>k f (k,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) = sup_monoid.sum (\\<lambda>k. f (k, j)) {k. True}", "by (metis assms top_comp_linorder_matrix)"], ["", "lemma covector_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_bounded_idempotent_semiring.covector f \\<longleftrightarrow> (\\<forall>i j k . f (i,j) = f (k,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.covector f =\n    (\\<forall>i j k. f (i, j) = f (k, j))", "by (unfold matrix_stone_relation_algebra.covector_conv_vector vector_linorder_matrix) (metis (no_types, lifting) case_prod_conv conv_matrix_def conv_def)"], ["", "text \\<open>\nA point is a matrix that has exactly one row, which is constant \\<open>top\\<close>, and all other rows are constant \\<open>bot\\<close>.\n\\<close>"], ["", "lemma point_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.point f \\<longleftrightarrow> (\\<exists>i . \\<forall>j . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.point f =\n    (\\<exists>i.\n        \\<forall>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (unfold vector_linorder_matrix bijective_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n     (\\<forall>j.\n         \\<exists>i.\n            f (i, j) = top \\<and>\n            (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))) =\n    (\\<exists>i.\n        \\<forall>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               f (k, j) = bot)) \\<Longrightarrow>\n    \\<exists>i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot)\n 2. \\<exists>i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by metis"], ["", "lemma point_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.point f \\<longleftrightarrow> (\\<exists>!i . \\<forall>j . f (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.point f =\n    (\\<exists>!i.\n        \\<forall>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (unfold vector_linorder_matrix bijective_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n     (\\<forall>j.\n         \\<exists>i.\n            f (i, j) = top \\<and>\n            (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))) =\n    (\\<exists>!i.\n        \\<forall>j.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               f (k, j) = bot)) \\<Longrightarrow>\n    \\<exists>!i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot)\n 2. \\<exists>!i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (metis bot_not_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!i.\n       \\<forall>j.\n          f (i, j) = top \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) = top \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by metis"], ["", "lemma pp_point_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_point f \\<longleftrightarrow> (\\<exists>i . \\<forall>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . f (i,j) = f (i,k)) \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_point f =\n    (\\<exists>i.\n        \\<forall>j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (unfold vector_linorder_matrix pp_bijective_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n     (\\<forall>j.\n         \\<exists>i.\n            f (i, j) \\<noteq> bot \\<and>\n            (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))) =\n    (\\<exists>i.\n        \\<forall>j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               f (k, j) = bot)) \\<Longrightarrow>\n    \\<exists>i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot)\n 2. \\<exists>i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by metis"], ["", "lemma pp_point_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_point f \\<longleftrightarrow> (\\<exists>!i . \\<forall>j . f (i,j) \\<noteq> bot \\<and> (\\<forall>k . f (i,j) = f (i,k)) \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> f (k,j) = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_point f =\n    (\\<exists>!i.\n        \\<forall>j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (unfold vector_linorder_matrix pp_bijective_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n     (\\<forall>j.\n         \\<exists>i.\n            f (i, j) \\<noteq> bot \\<and>\n            (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))) =\n    (\\<exists>!i.\n        \\<forall>j.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               f (k, j) = bot)) \\<Longrightarrow>\n    \\<exists>!i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot)\n 2. \\<exists>!i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!i.\n       \\<forall>j.\n          f (i, j) \\<noteq> bot \\<and>\n          (\\<forall>k. f (i, j) = f (i, k)) \\<and>\n          (\\<forall>k.\n              i \\<noteq> k \\<longrightarrow>\n              f (k, j) = bot) \\<Longrightarrow>\n    (\\<forall>i j k. f (i, j) = f (i, k)) \\<and>\n    (\\<forall>j.\n        \\<exists>i.\n           f (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k. i \\<noteq> k \\<longrightarrow> f (k, j) = bot))", "by metis"], ["", "text \\<open>\nAn arc is a matrix that has exactly one \\<open>top\\<close> entry and all other entries are \\<open>bot\\<close>.\n\\<close>"], ["", "lemma arc_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.arc f\"\n    shows \"\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"matrix_stone_relation_algebra.point (f \\<odot> mtop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.point (f \\<odot> mtop)", "by (simp add: assms matrix_bounded_idempotent_semiring.vector_mult_closed)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.point (f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "from this"], ["proof (chain)\npicking this:\n  matrix_stone_relation_algebra.point (f \\<odot> mtop)", "obtain i where 1: \"\\<forall>j . (f \\<odot> mtop) (i,j) = top \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k,j) = bot)\""], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.point (f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>j.\n           (f \\<odot> mtop) (i, j) = top \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               (f \\<odot> mtop) (k, j) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using point_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.point (f \\<odot> mtop)\n  matrix_stone_relation_algebra.point ?f =\n  (\\<exists>i.\n      \\<forall>j.\n         ?f (i, j) = top \\<and>\n         (\\<forall>k. i \\<noteq> k \\<longrightarrow> ?f (k, j) = bot))\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>j.\n           (f \\<odot> mtop) (i, j) = top \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               (f \\<odot> mtop) (k, j) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) = top \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)", "by (simp add: assms matrix_bounded_idempotent_semiring.vector_mult_closed)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "from this"], ["proof (chain)\npicking this:\n  matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)", "obtain j where \"\\<forall>i . (f\\<^sup>t \\<odot> mtop) (j,i) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> (f\\<^sup>t \\<odot> mtop) (k,i) = bot)\""], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<forall>i.\n           (f\\<^sup>t \\<odot> mtop) (j, i) = top \\<and>\n           (\\<forall>k.\n               j \\<noteq> k \\<longrightarrow>\n               (f\\<^sup>t \\<odot> mtop) (k, i) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using point_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.point (f\\<^sup>t \\<odot> mtop)\n  matrix_stone_relation_algebra.point ?f =\n  (\\<exists>i.\n      \\<forall>j.\n         ?f (i, j) = top \\<and>\n         (\\<forall>k. i \\<noteq> k \\<longrightarrow> ?f (k, j) = bot))\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<forall>i.\n           (f\\<^sup>t \\<odot> mtop) (j, i) = top \\<and>\n           (\\<forall>k.\n               j \\<noteq> k \\<longrightarrow>\n               (f\\<^sup>t \\<odot> mtop) (k, i) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>i.\n     (f\\<^sup>t \\<odot> mtop) (j, i) = top \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow>\n         (f\\<^sup>t \\<odot> mtop) (k, i) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "hence 2: \"\\<forall>i . (mtop \\<odot> f) (i,j) = top \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i,k) = bot)\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (f\\<^sup>t \\<odot> mtop) (j, i) = top \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow>\n         (f\\<^sup>t \\<odot> mtop) (k, i) = bot)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (mtop \\<odot> f) (i, j) = top \\<and>\n       (\\<forall>k.\n           j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)", "by (metis (no_types) old.prod.case conv_matrix_def conv_def matrix_stone_relation_algebra.conv_dist_comp matrix_stone_relation_algebra.conv_top)"], ["proof (state)\nthis:\n  \\<forall>i.\n     (mtop \\<odot> f) (i, j) = top \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have 3: \"\\<forall>i k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot", "proof (intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "fix i k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "hence \"(\\<Squnion>\\<^sub>l f (l,k)) = bot\""], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot", "using 2"], ["proof (prove)\nusing this:\n  j \\<noteq> k\n  \\<forall>i.\n     (mtop \\<odot> f) (i, j) = top \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot", "by (simp add: top_comp_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot\n\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "thus \"f (i,k) = bot\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot\n\ngoal (1 subgoal):\n 1. f (i, k) = bot", "by (metis bot.extremum_uniqueI comp_inf.ub_sum)"], ["proof (state)\nthis:\n  f (i, k) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"(\\<Squnion>\\<^sub>k f (i,k)) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = top", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) = top \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = top", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = top\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "hence 4: \"f (i,j) = top\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = top\n\ngoal (1 subgoal):\n 1. f (i, j) = top", "using 3"], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = top\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. f (i, j) = top", "by (metis bot_not_top linorder_finite_sup_selective)"], ["proof (state)\nthis:\n  f (i, j) = top\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"\\<forall>k l . k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k l.\n       k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "proof (intro allI, unfold imp_disjL, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k l. k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n 2. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "fix k l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k l. k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n 2. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "show \"k \\<noteq> i \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<longrightarrow> f (k, l) = bot", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "assume \"k \\<noteq> i\""], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "hence \"(\\<Squnion>\\<^sub>m f (k,m)) = bot\""], ["proof (prove)\nusing this:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot", "using 1"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) = top \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "thus \"f (k,l) = bot\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot\n\ngoal (1 subgoal):\n 1. f (k, l) = bot", "by (metis bot.extremum_uniqueI comp_inf.ub_sum)"], ["proof (state)\nthis:\n  f (k, l) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "show \"l \\<noteq> j \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "using 3"], ["proof (prove)\nusing this:\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "by simp"], ["proof (state)\nthis:\n  l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "using 4"], ["proof (prove)\nusing this:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n  f (i, j) = top\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "by (metis old.prod.exhaust)"], ["proof (state)\nthis:\n  \\<exists>e.\n     f e = top \\<and> (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_arc_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"\n    shows \"matrix_stone_relation_algebra.pp_arc f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_arc f", "proof (unfold matrix_stone_relation_algebra.pp_arc_expanded, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f \\<odot> mtop \\<odot> f\\<^sup>t)\n 2. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 3. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "show \"f \\<odot> mtop \\<odot> f\\<^sup>t \\<preceq> mone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive\n     (f \\<odot> mtop \\<odot> f\\<^sup>t)", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f \\<odot> mtop \\<odot> f\\<^sup>t) (a, b) \\<le> mone (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f \\<odot> mtop \\<odot> f\\<^sup>t) (a, b) \\<le> mone (a, b)", "show \"(f \\<odot> mtop \\<odot> f\\<^sup>t) (i,j) \\<le> mone (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "hence 1: \"\\<forall>k l . f (i,k) * f (j,l) = bot\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<forall>k l. f (i, k) * f (j, l) = bot", "by (metis assms Pair_inject semiring.mult_not_zero)"], ["proof (state)\nthis:\n  \\<forall>k l. f (i, k) * f (j, l) = bot\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "have \"(f \\<odot> mtop \\<odot> f\\<^sup>t) (i,j) = (\\<Squnion>\\<^sub>l (f \\<odot> mtop) (i,l) * (f\\<^sup>t) (l,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) =\n    sup_monoid.sum\n     (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j)) {l. True}", "by (simp add: times_matrix_def)"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) =\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) =\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l (f \\<odot> mtop) (i,l) * f (j,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j)) {l. True} =\n    sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l))\n     {l. True}", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j))\n   {l. True} =\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l)) {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * (f\\<^sup>t) (l, j))\n   {l. True} =\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l)) {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l (\\<Squnion>\\<^sub>k f (i,k)) * f (j,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l))\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n     {l. True}", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f \\<odot> mtop) (i, l) * f (j, l))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k f (i,k) * f (j,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n     {l. True}", "by (metis comp_right_dist_sum)"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} * f (j, l))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n     {l. True} =\n    bot", "using 1 linorder_finite_sup_selective"], ["proof (prove)\nusing this:\n  \\<forall>k l. f (i, k) * f (j, l) = bot\n  \\<exists>i. sup_monoid.sum ?f {k. True} = ?f i\n\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n     {l. True} =\n    bot", "by simp"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (i, k) * f (j, l)) {k. True})\n   {l. True} =\n  bot\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "finally"], ["proof (chain)\npicking this:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) = bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) = bot\n\ngoal (1 subgoal):\n 1. (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)", "by simp"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<odot> f\\<^sup>t) (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.coreflexive (f \\<odot> mtop \\<odot> f\\<^sup>t)\n\ngoal (2 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 2. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 2. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "show \"f\\<^sup>t \\<odot> mtop \\<odot> f \\<preceq> mone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f\\<^sup>t \\<odot> mtop \\<odot> f) (a, b) \\<le> mone (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. (f\\<^sup>t \\<odot> mtop \\<odot> f) (a, b) \\<le> mone (a, b)", "show \"(f\\<^sup>t \\<odot> mtop \\<odot> f) (i,j) \\<le> mone (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "hence 2: \"\\<forall>k l . f (k,i) * f (l,j) = bot\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. \\<forall>k l. f (k, i) * f (l, j) = bot", "by (metis assms Pair_inject semiring.mult_not_zero)"], ["proof (state)\nthis:\n  \\<forall>k l. f (k, i) * f (l, j) = bot\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "have \"(f\\<^sup>t \\<odot> mtop \\<odot> f) (i,j) = (\\<Squnion>\\<^sub>l (f\\<^sup>t \\<odot> mtop) (i,l) * f (l,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) =\n    sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n     {l. True}", "by (simp add: times_matrix_def)"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) =\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) =\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l (\\<Squnion>\\<^sub>k (f\\<^sup>t) (i,k)) * f (l,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} *\n         f (l, j))\n     {l. True}", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. (f\\<^sup>t \\<odot> mtop) (i, l) * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l (\\<Squnion>\\<^sub>k f (k,i)) * f (l,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} *\n         f (l, j))\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n     {l. True}", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. (f\\<^sup>t) (i, k)) {k. True} * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "have \"... = (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k f (k,i) * f (l,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n     {l. True}", "by (metis comp_right_dist_sum)"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i)) {k. True} * f (l, j))\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n     {l. True} =\n    bot", "using 2 linorder_finite_sup_selective"], ["proof (prove)\nusing this:\n  \\<forall>k l. f (k, i) * f (l, j) = bot\n  \\<exists>i. sup_monoid.sum ?f {k. True} = ?f i\n\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n     {l. True} =\n    bot", "by simp"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, i) * f (l, j)) {k. True})\n   {l. True} =\n  bot\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow>\n    (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "finally"], ["proof (chain)\npicking this:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) = bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) = bot\n\ngoal (1 subgoal):\n 1. (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)", "by simp"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f\\<^sup>t \\<odot> mtop \\<odot> f) (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.coreflexive (f\\<^sup>t \\<odot> mtop \\<odot> f)\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "show \"mtop \\<odot> \\<ominus>\\<ominus>f \\<odot> mtop = mtop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total\n     (mtop \\<odot> \\<ominus> \\<ominus> f)", "proof (rule ext, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>e.\n     f e \\<noteq> bot \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "obtain k l where \"f (k,l) \\<noteq> bot\""], ["proof (prove)\nusing this:\n  \\<exists>e.\n     f e \\<noteq> bot \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n\ngoal (1 subgoal):\n 1. (\\<And>k l.\n        f (k, l) \\<noteq> bot \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     f e \\<noteq> bot \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>k l.\n        f (k, l) \\<noteq> bot \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f (k, l) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "hence \"top = --f (k,l)\""], ["proof (prove)\nusing this:\n  f (k, l) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. top = - - f (k, l)", "by simp"], ["proof (state)\nthis:\n  top = - - f (k, l)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "also"], ["proof (state)\nthis:\n  top = - - f (k, l)\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "have \"... \\<le> (\\<Squnion>\\<^sub>k --f (k,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - f (k, l) \\<le> sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}", "using comp_inf.ub_sum"], ["proof (prove)\nusing this:\n  ?f ?i \\<le> sup_monoid.sum ?f {k. True}\n\ngoal (1 subgoal):\n 1. - - f (k, l) \\<le> sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}", "by metis"], ["proof (state)\nthis:\n  - - f (k, l) \\<le> sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "also"], ["proof (state)\nthis:\n  - - f (k, l) \\<le> sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "have \"... \\<le> (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k --f (k,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}\n    \\<le> sup_monoid.sum\n           (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n           {l. True}", "using comp_inf.ub_sum"], ["proof (prove)\nusing this:\n  ?f ?i \\<le> sup_monoid.sum ?f {k. True}\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}\n    \\<le> sup_monoid.sum\n           (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n           {l. True}", "by simp"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True}\n  \\<le> sup_monoid.sum\n         (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n         {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "finally"], ["proof (chain)\npicking this:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True})", "have 3: \"top \\<le> (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k --f (k,l))\""], ["proof (prove)\nusing this:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True})\n\ngoal (1 subgoal):\n 1. comp_inf.reflexive\n     (sup_monoid.sum\n       (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n       {l. True})", "by simp"], ["proof (state)\nthis:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True})\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "have \"(mtop \\<odot> \\<ominus>\\<ominus>f \\<odot> mtop) (i,j) = (\\<Squnion>\\<^sub>l (\\<Squnion>\\<^sub>k top * --f (k,l)) * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n     {l. True}", "by (simp add: times_matrix_def top_matrix_def uminus_matrix_def)"], ["proof (state)\nthis:\n  (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) =\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "also"], ["proof (state)\nthis:\n  (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) =\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "have \"... = (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k --f (k,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True}", "by (metis (no_types, lifting) sup_monoid.sum.cong comp_inf.mult_1_left times_inf comp_inf.mult_1_right)"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l.\n       sup_monoid.sum (\\<lambda>k. top * - - f (k, l)) {k. True} * top)\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "have \"... = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True} =\n    top", "using 3 top.extremum_unique"], ["proof (prove)\nusing this:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True})\n  (top \\<le> ?a) = (?a = top)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n     {l. True} =\n    top", "by blast"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. - - f (k, l)) {k. True})\n   {l. True} =\n  top\n\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (a, b) =\n       mtop (a, b)", "finally"], ["proof (chain)\npicking this:\n  (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) = top", "show \"(mtop \\<odot> \\<ominus>\\<ominus>f \\<odot> mtop) (i,j) = mtop (i,j)\""], ["proof (prove)\nusing this:\n  (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) = top\n\ngoal (1 subgoal):\n 1. (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) = mtop (i, j)", "by (simp add: top_matrix_def)"], ["proof (state)\nthis:\n  (mtop \\<odot> \\<ominus> \\<ominus> f \\<odot> mtop) (i, j) = mtop (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_bounded_idempotent_semiring.total\n   (mtop \\<odot> \\<ominus> \\<ominus> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arc_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\"\n    shows \"matrix_stone_relation_algebra.arc f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.arc f", "proof (unfold matrix_stone_relation_algebra.arc_expanded, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f \\<odot> mtop \\<odot> f\\<^sup>t)\n 2. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 3. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "show \"f \\<odot> mtop \\<odot> f\\<^sup>t \\<preceq> mone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive\n     (f \\<odot> mtop \\<odot> f\\<^sup>t)", "by (metis (no_types, lifting) assms bot_not_top matrix_stone_relation_algebra.pp_arc_expanded pp_arc_linorder_matrix_2)"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.coreflexive (f \\<odot> mtop \\<odot> f\\<^sup>t)\n\ngoal (2 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 2. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)\n 2. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "show \"f\\<^sup>t \\<odot> mtop \\<odot> f \\<preceq> mone\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive\n     (f\\<^sup>t \\<odot> mtop \\<odot> f)", "by (metis (no_types, lifting) assms bot_not_top matrix_stone_relation_algebra.pp_arc_expanded pp_arc_linorder_matrix_2)"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.coreflexive (f\\<^sup>t \\<odot> mtop \\<odot> f)\n\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "show \"mtop \\<odot> f \\<odot> mtop = mtop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)", "proof (rule ext, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "from assms"], ["proof (chain)\npicking this:\n  \\<exists>e.\n     f e = top \\<and> (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "obtain k l where \"f (k,l) = top\""], ["proof (prove)\nusing this:\n  \\<exists>e.\n     f e = top \\<and> (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n\ngoal (1 subgoal):\n 1. (\\<And>k l. f (k, l) = top \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using prod.collapse"], ["proof (prove)\nusing this:\n  \\<exists>e.\n     f e = top \\<and> (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n  (fst ?prod, snd ?prod) = ?prod\n\ngoal (1 subgoal):\n 1. (\\<And>k l. f (k, l) = top \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f (k, l) = top\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "hence \"(\\<Squnion>\\<^sub>k f (k,l)) = top\""], ["proof (prove)\nusing this:\n  f (k, l) = top\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True} = top", "by (metis (mono_tags) comp_inf.ub_sum top_unique)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True} = top\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "hence 3: \"top \\<le> (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k f (k,l))\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True} = top\n\ngoal (1 subgoal):\n 1. comp_inf.reflexive\n     (sup_monoid.sum\n       (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True})\n       {l. True})", "by (metis (no_types) comp_inf.ub_sum)"], ["proof (state)\nthis:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True})\n     {l. True})\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "have \"(mtop \\<odot> f \\<odot> mtop) (i,j) = (\\<Squnion>\\<^sub>l (\\<Squnion>\\<^sub>k top * f (k,l)) * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mtop \\<odot> f \\<odot> mtop) (i, j) =\n    sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n     {l. True}", "by (simp add: times_matrix_def top_matrix_def)"], ["proof (state)\nthis:\n  (mtop \\<odot> f \\<odot> mtop) (i, j) =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "also"], ["proof (state)\nthis:\n  (mtop \\<odot> f \\<odot> mtop) (i, j) =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n   {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "have \"... = (\\<Squnion>\\<^sub>l \\<Squnion>\\<^sub>k f (k,l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l.\n         sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n     {l. True} =\n    sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True}) {l. True}", "by (metis (no_types, lifting) sup_monoid.sum.cong comp_inf.mult_1_left times_inf comp_inf.mult_1_right)"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True}) {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "also"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. top * f (k, l)) {k. True} * top)\n   {l. True} =\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True}) {l. True}\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "have \"... = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True})\n     {l. True} =\n    top", "using 3 top.extremum_unique"], ["proof (prove)\nusing this:\n  comp_inf.reflexive\n   (sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True})\n     {l. True})\n  (top \\<le> ?a) = (?a = top)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum\n     (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True})\n     {l. True} =\n    top", "by blast"], ["proof (state)\nthis:\n  sup_monoid.sum\n   (\\<lambda>l. sup_monoid.sum (\\<lambda>k. f (k, l)) {k. True}) {l. True} =\n  top\n\ngoal (1 subgoal):\n 1. \\<And>x a b. (mtop \\<odot> f \\<odot> mtop) (a, b) = mtop (a, b)", "finally"], ["proof (chain)\npicking this:\n  (mtop \\<odot> f \\<odot> mtop) (i, j) = top", "show \"(mtop \\<odot> f \\<odot> mtop) (i,j) = mtop (i,j)\""], ["proof (prove)\nusing this:\n  (mtop \\<odot> f \\<odot> mtop) (i, j) = top\n\ngoal (1 subgoal):\n 1. (mtop \\<odot> f \\<odot> mtop) (i, j) = mtop (i, j)", "by (simp add: top_matrix_def)"], ["proof (state)\nthis:\n  (mtop \\<odot> f \\<odot> mtop) (i, j) = mtop (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  matrix_bounded_idempotent_semiring.total (mtop \\<odot> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arc_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.arc f \\<longleftrightarrow> (\\<exists>e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.arc f =\n    (\\<exists>e.\n        f e = top \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "using arc_linorder_matrix_1 arc_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.arc ?f \\<Longrightarrow>\n  \\<exists>e.\n     ?f e = top \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> ?f d = bot)\n  \\<exists>e.\n     ?f e = top \\<and>\n     (\\<forall>d.\n         e \\<noteq> d \\<longrightarrow> ?f d = bot) \\<Longrightarrow>\n  matrix_stone_relation_algebra.arc ?f\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.arc f =\n    (\\<exists>e.\n        f e = top \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "by blast"], ["", "lemma arc_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.arc f \\<longleftrightarrow> (\\<exists>!e . f e = top \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.arc f =\n    (\\<exists>!e.\n        f e = top \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_stone_relation_algebra.arc f \\<Longrightarrow>\n    \\<exists>!e.\n       f e = top \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n 2. \\<exists>!e.\n       f e = top \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.arc f", "apply (metis (no_types, hide_lams) arc_linorder_matrix bot_not_top)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!e.\n       f e = top \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.arc f", "using arc_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.arc ?f =\n  (\\<exists>e.\n      ?f e = top \\<and>\n      (\\<forall>d. e \\<noteq> d \\<longrightarrow> ?f d = bot))\n\ngoal (1 subgoal):\n 1. \\<exists>!e.\n       f e = top \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.arc f", "by blast"], ["", "lemma pp_arc_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.pp_arc f\"\n    shows \"\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"matrix_stone_relation_algebra.pp_point (f \\<odot> mtop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_point (f \\<odot> mtop)", "by (simp add: assms matrix_bounded_idempotent_semiring.vector_mult_closed)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.pp_point (f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "from this"], ["proof (chain)\npicking this:\n  matrix_stone_relation_algebra.pp_point (f \\<odot> mtop)", "obtain i where 1: \"\\<forall>j . (f \\<odot> mtop) (i,j) \\<noteq> bot \\<and> (\\<forall>k . (f \\<odot> mtop) (i,j) = (f \\<odot> mtop) (i,k)) \\<and> (\\<forall>k . i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k,j) = bot)\""], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.pp_point (f \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<forall>j.\n           (f \\<odot> mtop) (i, j) \\<noteq> bot \\<and>\n           (\\<forall>k.\n               (f \\<odot> mtop) (i, j) = (f \\<odot> mtop) (i, k)) \\<and>\n           (\\<forall>k.\n               i \\<noteq> k \\<longrightarrow>\n               (f \\<odot> mtop) (k, j) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis pp_point_linorder_matrix)"], ["proof (state)\nthis:\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) \\<noteq> bot \\<and>\n     (\\<forall>k. (f \\<odot> mtop) (i, j) = (f \\<odot> mtop) (i, k)) \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"matrix_stone_relation_algebra.pp_point (f\\<^sup>t \\<odot> mtop)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_point (f\\<^sup>t \\<odot> mtop)", "by (simp add: assms matrix_bounded_idempotent_semiring.vector_mult_closed)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.pp_point (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "from this"], ["proof (chain)\npicking this:\n  matrix_stone_relation_algebra.pp_point (f\\<^sup>t \\<odot> mtop)", "obtain j where \"\\<forall>i . (f\\<^sup>t \\<odot> mtop) (j,i) \\<noteq> bot \\<and> (\\<forall>k . (f\\<^sup>t \\<odot> mtop) (j,i) = (f\\<^sup>t \\<odot> mtop) (j,k)) \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> (f\\<^sup>t \\<odot> mtop) (k,i) = bot)\""], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.pp_point (f\\<^sup>t \\<odot> mtop)\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<forall>i.\n           (f\\<^sup>t \\<odot> mtop) (j, i) \\<noteq> bot \\<and>\n           (\\<forall>k.\n               (f\\<^sup>t \\<odot> mtop) (j, i) =\n               (f\\<^sup>t \\<odot> mtop) (j, k)) \\<and>\n           (\\<forall>k.\n               j \\<noteq> k \\<longrightarrow>\n               (f\\<^sup>t \\<odot> mtop) (k, i) = bot) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis pp_point_linorder_matrix)"], ["proof (state)\nthis:\n  \\<forall>i.\n     (f\\<^sup>t \\<odot> mtop) (j, i) \\<noteq> bot \\<and>\n     (\\<forall>k.\n         (f\\<^sup>t \\<odot> mtop) (j, i) =\n         (f\\<^sup>t \\<odot> mtop) (j, k)) \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow>\n         (f\\<^sup>t \\<odot> mtop) (k, i) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "hence 2: \"\\<forall>i . (mtop \\<odot> f) (i,j) \\<noteq> bot \\<and> (\\<forall>k . (mtop \\<odot> f) (i,j) = (mtop \\<odot> f) (k,j)) \\<and> (\\<forall>k . j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i,k) = bot)\""], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (f\\<^sup>t \\<odot> mtop) (j, i) \\<noteq> bot \\<and>\n     (\\<forall>k.\n         (f\\<^sup>t \\<odot> mtop) (j, i) =\n         (f\\<^sup>t \\<odot> mtop) (j, k)) \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow>\n         (f\\<^sup>t \\<odot> mtop) (k, i) = bot)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       (mtop \\<odot> f) (i, j) \\<noteq> bot \\<and>\n       (\\<forall>k.\n           (mtop \\<odot> f) (i, j) = (mtop \\<odot> f) (k, j)) \\<and>\n       (\\<forall>k.\n           j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)", "by (metis (no_types) old.prod.case conv_matrix_def conv_def matrix_stone_relation_algebra.conv_dist_comp matrix_stone_relation_algebra.conv_top)"], ["proof (state)\nthis:\n  \\<forall>i.\n     (mtop \\<odot> f) (i, j) \\<noteq> bot \\<and>\n     (\\<forall>k. (mtop \\<odot> f) (i, j) = (mtop \\<odot> f) (k, j)) \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have 3: \"\\<forall>i k . j \\<noteq> k \\<longrightarrow> f (i,k) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot", "proof (intro allI, rule impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "fix i k"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "assume \"j \\<noteq> k\""], ["proof (state)\nthis:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "hence \"(\\<Squnion>\\<^sub>l f (l,k)) = bot\""], ["proof (prove)\nusing this:\n  j \\<noteq> k\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot", "using 2"], ["proof (prove)\nusing this:\n  j \\<noteq> k\n  \\<forall>i.\n     (mtop \\<odot> f) (i, j) \\<noteq> bot \\<and>\n     (\\<forall>k. (mtop \\<odot> f) (i, j) = (mtop \\<odot> f) (k, j)) \\<and>\n     (\\<forall>k.\n         j \\<noteq> k \\<longrightarrow> (mtop \\<odot> f) (i, k) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot", "by (simp add: top_comp_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot\n\ngoal (1 subgoal):\n 1. \\<And>i k. j \\<noteq> k \\<Longrightarrow> f (i, k) = bot", "thus \"f (i,k) = bot\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>l. f (l, k)) {l. True} = bot\n\ngoal (1 subgoal):\n 1. f (i, k) = bot", "by (metis bot.extremum_uniqueI comp_inf.ub_sum)"], ["proof (state)\nthis:\n  f (i, k) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"(\\<Squnion>\\<^sub>k f (i,k)) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<noteq> bot", "using 1"], ["proof (prove)\nusing this:\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) \\<noteq> bot \\<and>\n     (\\<forall>k. (f \\<odot> mtop) (i, j) = (f \\<odot> mtop) (i, k)) \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<noteq> bot", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "hence 4: \"f (i,j) \\<noteq> bot\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<noteq> bot\n\ngoal (1 subgoal):\n 1. f (i, j) \\<noteq> bot", "using 3"], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<noteq> bot\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. f (i, j) \\<noteq> bot", "by (metis linorder_finite_sup_selective)"], ["proof (state)\nthis:\n  f (i, j) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "have \"\\<forall>k l . k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k l.\n       k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "proof (intro allI, unfold imp_disjL, rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k l. k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n 2. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "fix k l"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>k l. k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n 2. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "show \"k \\<noteq> i \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<longrightarrow> f (k, l) = bot", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "assume \"k \\<noteq> i\""], ["proof (state)\nthis:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "hence \"(\\<Squnion>\\<^sub>m f (k,m)) = bot\""], ["proof (prove)\nusing this:\n  k \\<noteq> i\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot", "using 1"], ["proof (prove)\nusing this:\n  k \\<noteq> i\n  \\<forall>j.\n     (f \\<odot> mtop) (i, j) \\<noteq> bot \\<and>\n     (\\<forall>k. (f \\<odot> mtop) (i, j) = (f \\<odot> mtop) (i, k)) \\<and>\n     (\\<forall>k.\n         i \\<noteq> k \\<longrightarrow> (f \\<odot> mtop) (k, j) = bot)\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot", "by (simp add: comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot\n\ngoal (1 subgoal):\n 1. k \\<noteq> i \\<Longrightarrow> f (k, l) = bot", "thus \"f (k,l) = bot\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>m. f (k, m)) {m. True} = bot\n\ngoal (1 subgoal):\n 1. f (k, l) = bot", "by (metis bot.extremum_uniqueI comp_inf.ub_sum)"], ["proof (state)\nthis:\n  f (k, l) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  k \\<noteq> i \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<And>k l. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "show \"l \\<noteq> j \\<longrightarrow> f (k,l) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "using 3"], ["proof (prove)\nusing this:\n  \\<forall>i k. j \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. l \\<noteq> j \\<longrightarrow> f (k, l) = bot", "by simp"], ["proof (state)\nthis:\n  l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "using 4"], ["proof (prove)\nusing this:\n  \\<forall>k l.\n     k \\<noteq> i \\<or> l \\<noteq> j \\<longrightarrow> f (k, l) = bot\n  f (i, j) \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)", "by (metis old.prod.exhaust)"], ["proof (state)\nthis:\n  \\<exists>e.\n     f e \\<noteq> bot \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pp_arc_linorder_matrix:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_arc f \\<longleftrightarrow> (\\<exists>e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_arc f =\n    (\\<exists>e.\n        f e \\<noteq> bot \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "using pp_arc_linorder_matrix_1 pp_arc_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.pp_arc ?f \\<Longrightarrow>\n  \\<exists>e.\n     ?f e \\<noteq> bot \\<and>\n     (\\<forall>d. e \\<noteq> d \\<longrightarrow> ?f d = bot)\n  \\<exists>e.\n     ?f e \\<noteq> bot \\<and>\n     (\\<forall>d.\n         e \\<noteq> d \\<longrightarrow> ?f d = bot) \\<Longrightarrow>\n  matrix_stone_relation_algebra.pp_arc ?f\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_arc f =\n    (\\<exists>e.\n        f e \\<noteq> bot \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "by blast"], ["", "lemma pp_arc_linorder_matrix_unique:\n  fixes f :: \"('a::finite,'b::non_trivial_linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.pp_arc f \\<longleftrightarrow> (\\<exists>!e . f e \\<noteq> bot \\<and> (\\<forall>d . e \\<noteq> d \\<longrightarrow> f d = bot))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.pp_arc f =\n    (\\<exists>!e.\n        f e \\<noteq> bot \\<and>\n        (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot))", "apply (rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. matrix_stone_relation_algebra.pp_arc f \\<Longrightarrow>\n    \\<exists>!e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d. e \\<noteq> d \\<longrightarrow> f d = bot)\n 2. \\<exists>!e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_arc f", "apply (metis (no_types, hide_lams) pp_arc_linorder_matrix)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_arc f", "using pp_arc_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.pp_arc ?f =\n  (\\<exists>e.\n      ?f e \\<noteq> bot \\<and>\n      (\\<forall>d. e \\<noteq> d \\<longrightarrow> ?f d = bot))\n\ngoal (1 subgoal):\n 1. \\<exists>!e.\n       f e \\<noteq> bot \\<and>\n       (\\<forall>d.\n           e \\<noteq> d \\<longrightarrow> f d = bot) \\<Longrightarrow>\n    matrix_stone_relation_algebra.pp_arc f", "by blast"], ["", "text \\<open>\nReflexive matrices are those with a constant \\<open>top\\<close> diagonal.\n\\<close>"], ["", "lemma reflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.reflexive f\"\n    shows \"f (i,i) = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, i) = top", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (i, i) = top", "have \"(top::'b) = mone (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = mone (i, i)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  top = mone (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) = top", "also"], ["proof (state)\nthis:\n  top = mone (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) = top", "have \"... \\<le> f (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mone (i, i) \\<le> f (i, i)", "using assms less_eq_matrix_def"], ["proof (prove)\nusing this:\n  matrix_idempotent_semiring.reflexive f\n  (?f \\<preceq> ?g) = (\\<forall>e. ?f e \\<le> ?g e)\n\ngoal (1 subgoal):\n 1. mone (i, i) \\<le> f (i, i)", "by blast"], ["proof (state)\nthis:\n  mone (i, i) \\<le> f (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) = top", "finally"], ["proof (chain)\npicking this:\n  comp_inf.reflexive (f (i, i))", "show ?thesis"], ["proof (prove)\nusing this:\n  comp_inf.reflexive (f (i, i))\n\ngoal (1 subgoal):\n 1. f (i, i) = top", "by (simp add: top.extremum_unique)"], ["proof (state)\nthis:\n  f (i, i) = top\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . f (i,i) = top\"\n    shows \"matrix_idempotent_semiring.reflexive f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.reflexive f", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. mone (a, b) \\<le> f (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. mone (a, b) \\<le> f (a, b)", "show \"mone (i,j) \\<le> f (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mone (i, j) \\<le> f (i, j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. mone (i, j) \\<le> f (i, j)", "by (simp add: assms)"], ["proof (state)\nthis:\n  mone (i, j) \\<le> f (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "hence \"(bot::'b) = mone (i,j)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. bot = mone (i, j)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  bot = mone (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> mone (i, j) \\<le> f (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  bot = mone (i, j)\n\ngoal (1 subgoal):\n 1. mone (i, j) \\<le> f (i, j)", "by simp"], ["proof (state)\nthis:\n  mone (i, j) \\<le> f (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mone (i, j) \\<le> f (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.reflexive f \\<longleftrightarrow> (\\<forall>i . f (i,i) = top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.reflexive f = (\\<forall>i. f (i, i) = top)", "using reflexive_linorder_matrix_1 reflexive_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_idempotent_semiring.reflexive ?f \\<Longrightarrow>\n  ?f (?i, ?i) = top\n  \\<forall>i. ?f (i, i) = top \\<Longrightarrow>\n  matrix_idempotent_semiring.reflexive ?f\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.reflexive f = (\\<forall>i. f (i, i) = top)", "by auto"], ["", "text \\<open>\nCoreflexive matrices are those in which all non-diagonal entries are \\<open>bot\\<close>.\n\\<close>"], ["", "lemma coreflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive f\"\n      and \"i \\<noteq> j\"\n    shows \"f (i,j) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (i, j) = bot", "have \"f (i,j) \\<le> mone (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) \\<le> mone (i, j)", "using assms less_eq_matrix_def"], ["proof (prove)\nusing this:\n  matrix_idempotent_semiring.coreflexive f\n  i \\<noteq> j\n  (?f \\<preceq> ?g) = (\\<forall>e. ?f e \\<le> ?g e)\n\ngoal (1 subgoal):\n 1. f (i, j) \\<le> mone (i, j)", "by blast"], ["proof (state)\nthis:\n  f (i, j) \\<le> mone (i, j)\n\ngoal (1 subgoal):\n 1. f (i, j) = bot", "also"], ["proof (state)\nthis:\n  f (i, j) \\<le> mone (i, j)\n\ngoal (1 subgoal):\n 1. f (i, j) = bot", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mone (i, j) = bot", "by (simp add: assms one_matrix_def)"], ["proof (state)\nthis:\n  mone (i, j) = bot\n\ngoal (1 subgoal):\n 1. f (i, j) = bot", "finally"], ["proof (chain)\npicking this:\n  f (i, j) \\<le> bot", "show ?thesis"], ["proof (prove)\nusing this:\n  f (i, j) \\<le> bot\n\ngoal (1 subgoal):\n 1. f (i, j) = bot", "by (simp add: bot.extremum_unique)"], ["proof (state)\nthis:\n  f (i, j) = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coreflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot\"\n    shows \"matrix_idempotent_semiring.coreflexive f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive f", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. f (a, b) \\<le> mone (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. f (a, b) \\<le> mone (a, b)", "show \"f (i,j) \\<le> mone (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) \\<le> mone (i, j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "hence \"(top::'b) = mone (i,j)\""], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. top = mone (i, j)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  top = mone (i, j)\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  top = mone (i, j)\n\ngoal (1 subgoal):\n 1. f (i, j) \\<le> mone (i, j)", "by simp"], ["proof (state)\nthis:\n  f (i, j) \\<le> mone (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> mone (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. f (i, j) \\<le> mone (i, j)", "by (simp add: assms)"], ["proof (state)\nthis:\n  f (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (i, j) \\<le> mone (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coreflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.coreflexive f \\<longleftrightarrow> (\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive f =\n    (\\<forall>i j. i \\<noteq> j \\<longrightarrow> f (i, j) = bot)", "using coreflexive_linorder_matrix_1 coreflexive_linorder_matrix_2"], ["proof (prove)\nusing this:\n  \\<lbrakk>matrix_idempotent_semiring.coreflexive ?f;\n   ?i \\<noteq> ?j\\<rbrakk>\n  \\<Longrightarrow> ?f (?i, ?j) = bot\n  \\<forall>i j.\n     i \\<noteq> j \\<longrightarrow> ?f (i, j) = bot \\<Longrightarrow>\n  matrix_idempotent_semiring.coreflexive ?f\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.coreflexive f =\n    (\\<forall>i j. i \\<noteq> j \\<longrightarrow> f (i, j) = bot)", "by auto"], ["", "text \\<open>\nIrreflexive matrices are those with a constant \\<open>bot\\<close> diagonal.\n\\<close>"], ["", "lemma irreflexive_linorder_matrix_1:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_stone_relation_algebra.irreflexive f\"\n    shows \"f (i,i) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, i) = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f (i, i) = bot", "have \"(top::'b) = mone (i,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = mone (i, i)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  top = mone (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) = bot", "hence \"(bot::'b) = (\\<ominus>mone) (i,i)\""], ["proof (prove)\nusing this:\n  top = mone (i, i)\n\ngoal (1 subgoal):\n 1. bot = (\\<ominus> mone) (i, i)", "by (simp add: uminus_matrix_def)"], ["proof (state)\nthis:\n  bot = (\\<ominus> mone) (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) = bot", "hence \"f (i,i) \\<le> bot\""], ["proof (prove)\nusing this:\n  bot = (\\<ominus> mone) (i, i)\n\ngoal (1 subgoal):\n 1. f (i, i) \\<le> bot", "by (metis assms less_eq_matrix_def)"], ["proof (state)\nthis:\n  f (i, i) \\<le> bot\n\ngoal (1 subgoal):\n 1. f (i, i) = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (i, i) \\<le> bot\n\ngoal (1 subgoal):\n 1. f (i, i) = bot", "by (simp add: bot.extremum_unique)"], ["proof (state)\nthis:\n  f (i, i) = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreflexive_linorder_matrix_2:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"\\<forall>i . f (i,i) = bot\"\n    shows \"matrix_stone_relation_algebra.irreflexive f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.irreflexive f", "proof (unfold less_eq_matrix_def, rule allI, rule prod_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. f (a, b) \\<le> (\\<ominus> mone) (a, b)", "fix i j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>e a b. f (a, b) \\<le> (\\<ominus> mone) (a, b)", "show \"f (i,j) \\<le> (\\<ominus>mone) (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (i, j) \\<le> (\\<ominus> mone) (i, j)", "proof (cases \"i = j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "assume \"i = j\""], ["proof (state)\nthis:\n  i = j\n\ngoal (2 subgoals):\n 1. i = j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)\n 2. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = j\n\ngoal (1 subgoal):\n 1. f (i, j) \\<le> (\\<ominus> mone) (i, j)", "by (simp add: assms)"], ["proof (state)\nthis:\n  f (i, j) \\<le> (\\<ominus> mone) (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "assume \"i \\<noteq> j\""], ["proof (state)\nthis:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "hence \"(bot::'b) = mone (i,j)\""], ["proof (prove)\nusing this:\n  i \\<noteq> j\n\ngoal (1 subgoal):\n 1. bot = mone (i, j)", "by (simp add: one_matrix_def)"], ["proof (state)\nthis:\n  bot = mone (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "hence \"(top::'b) = (\\<ominus>mone) (i,j)\""], ["proof (prove)\nusing this:\n  bot = mone (i, j)\n\ngoal (1 subgoal):\n 1. top = (\\<ominus> mone) (i, j)", "by (simp add: uminus_matrix_def)"], ["proof (state)\nthis:\n  top = (\\<ominus> mone) (i, j)\n\ngoal (1 subgoal):\n 1. i \\<noteq> j \\<Longrightarrow> f (i, j) \\<le> (\\<ominus> mone) (i, j)", "thus ?thesis"], ["proof (prove)\nusing this:\n  top = (\\<ominus> mone) (i, j)\n\ngoal (1 subgoal):\n 1. f (i, j) \\<le> (\\<ominus> mone) (i, j)", "by simp"], ["proof (state)\nthis:\n  f (i, j) \\<le> (\\<ominus> mone) (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f (i, j) \\<le> (\\<ominus> mone) (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreflexive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.irreflexive f \\<longleftrightarrow> (\\<forall>i . f (i,i) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.irreflexive f =\n    (\\<forall>i. f (i, i) = bot)", "using irreflexive_linorder_matrix_1 irreflexive_linorder_matrix_2"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.irreflexive ?f \\<Longrightarrow>\n  ?f (?i, ?i) = bot\n  \\<forall>i. ?f (i, i) = bot \\<Longrightarrow>\n  matrix_stone_relation_algebra.irreflexive ?f\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.irreflexive f =\n    (\\<forall>i. f (i, i) = bot)", "by auto"], ["", "text \\<open>\nAs usual, symmetric matrices are those which do not change under transposition.\n\\<close>"], ["", "lemma symmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.symmetric f \\<longleftrightarrow> (\\<forall>i j . f (i,j) = f (j,i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.symmetric f =\n    (\\<forall>i j. f (i, j) = f (j, i))", "by (metis (mono_tags, lifting) case_prod_conv cond_case_prod_eta conv_matrix_def conv_def)"], ["", "text \\<open>\nAntisymmetric matrices are characterised as follows: each entry not on the diagonal or its mirror entry across the diagonal must be \\<open>bot\\<close>.\n\\<close>"], ["", "lemma antisymmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.antisymmetric f \\<longleftrightarrow> (\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) = bot \\<or> f (j,i) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.antisymmetric f =\n    (\\<forall>i j.\n        i \\<noteq> j \\<longrightarrow> f (i, j) = bot \\<or> f (j, i) = bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.antisymmetric f =\n    (\\<forall>i j.\n        i \\<noteq> j \\<longrightarrow> f (i, j) = bot \\<or> f (j, i) = bot)", "have \"matrix_stone_relation_algebra.antisymmetric f \\<longleftrightarrow> (\\<forall>i j . i \\<noteq> j \\<longrightarrow> f (i,j) \\<sqinter> f (j,i) \\<le> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.antisymmetric f =\n    (\\<forall>i j.\n        i \\<noteq> j \\<longrightarrow>\n        f (i, j) \\<sqinter> f (j, i) \\<le> bot)", "by (simp add: conv_matrix_def inf_matrix_def less_eq_matrix_def one_matrix_def)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.antisymmetric f =\n  (\\<forall>i j.\n      i \\<noteq> j \\<longrightarrow> f (i, j) \\<sqinter> f (j, i) \\<le> bot)\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.antisymmetric f =\n    (\\<forall>i j.\n        i \\<noteq> j \\<longrightarrow> f (i, j) = bot \\<or> f (j, i) = bot)", "thus ?thesis"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.antisymmetric f =\n  (\\<forall>i j.\n      i \\<noteq> j \\<longrightarrow> f (i, j) \\<sqinter> f (j, i) \\<le> bot)\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.antisymmetric f =\n    (\\<forall>i j.\n        i \\<noteq> j \\<longrightarrow> f (i, j) = bot \\<or> f (j, i) = bot)", "by (metis (no_types, hide_lams) inf.absorb_iff1 inf.cobounded1 inf_bot_right inf_dense)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.antisymmetric f =\n  (\\<forall>i j.\n      i \\<noteq> j \\<longrightarrow> f (i, j) = bot \\<or> f (j, i) = bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nFor asymmetric matrices the diagonal is included: each entry or its mirror entry across the diagonal must be \\<open>bot\\<close>.\n\\<close>"], ["", "lemma asymmetric_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_stone_relation_algebra.asymmetric f \\<longleftrightarrow> (\\<forall>i j . f (i,j) = bot \\<or> f (j,i) = bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.asymmetric f =\n    (\\<forall>i j. f (i, j) = bot \\<or> f (j, i) = bot)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.asymmetric f =\n    (\\<forall>i j. f (i, j) = bot \\<or> f (j, i) = bot)", "have \"matrix_stone_relation_algebra.asymmetric f \\<longleftrightarrow> (\\<forall>i j . f (i,j) \\<sqinter> f (j,i) \\<le> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.asymmetric f =\n    (\\<forall>i j. f (i, j) \\<sqinter> f (j, i) \\<le> bot)", "apply (unfold conv_matrix_def inf_matrix_def conv_def id_def bot_matrix_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>e.\n         f e \\<sqinter> (case e of (i, j) \\<Rightarrow> f (j, i))) =\n     (\\<lambda>e. bot)) =\n    (\\<forall>i j. f (i, j) \\<sqinter> f (j, i) \\<le> bot)", "by (metis (mono_tags, lifting) bot.extremum bot.extremum_uniqueI case_prod_conv old.prod.exhaust)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.asymmetric f =\n  (\\<forall>i j. f (i, j) \\<sqinter> f (j, i) \\<le> bot)\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.asymmetric f =\n    (\\<forall>i j. f (i, j) = bot \\<or> f (j, i) = bot)", "thus ?thesis"], ["proof (prove)\nusing this:\n  matrix_stone_relation_algebra.asymmetric f =\n  (\\<forall>i j. f (i, j) \\<sqinter> f (j, i) \\<le> bot)\n\ngoal (1 subgoal):\n 1. matrix_stone_relation_algebra.asymmetric f =\n    (\\<forall>i j. f (i, j) = bot \\<or> f (j, i) = bot)", "by (metis (no_types, hide_lams) inf.absorb_iff1 inf.cobounded1 inf_bot_right inf_dense)"], ["proof (state)\nthis:\n  matrix_stone_relation_algebra.asymmetric f =\n  (\\<forall>i j. f (i, j) = bot \\<or> f (j, i) = bot)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nIn a transitive matrix, the weight of one of the edges on an indirect route must be below the weight of the direct edge.\n\\<close>"], ["", "lemma transitive_linorder_matrix:\n  fixes f :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  shows \"matrix_idempotent_semiring.transitive f \\<longleftrightarrow> (\\<forall>i j k . f (i,k) \\<le> f (i,j) \\<or> f (k,j) \\<le> f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "have \"matrix_idempotent_semiring.transitive f \\<longleftrightarrow> (\\<forall>i j . (\\<Squnion>\\<^sub>k f (i,k) * f (k,j)) \\<le> f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j.\n        sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n        \\<le> f (i, j))", "by (simp add: times_matrix_def less_eq_matrix_def)"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.transitive f =\n  (\\<forall>i j.\n      sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n      \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "also"], ["proof (state)\nthis:\n  matrix_idempotent_semiring.transitive f =\n  (\\<forall>i j.\n      sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n      \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "have \"... \\<longleftrightarrow> (\\<forall>i j k . f (i,k) * f (k,j) \\<le> f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j.\n        sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n        \\<le> f (i, j)) =\n    (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j))", "by (simp add: lub_sum_iff)"], ["proof (state)\nthis:\n  (\\<forall>i j.\n      sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n      \\<le> f (i, j)) =\n  (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "also"], ["proof (state)\nthis:\n  (\\<forall>i j.\n      sup_monoid.sum (\\<lambda>k. f (i, k) * f (k, j)) {k. True}\n      \\<le> f (i, j)) =\n  (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "have \"... \\<longleftrightarrow> (\\<forall>i j k . f (i,k) \\<le> f (i,j) \\<or> f (k,j) \\<le> f (i,j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j)) =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "using inf_less_eq"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y \\<le> ?z) = (?x \\<le> ?z \\<or> ?y \\<le> ?z)\n\ngoal (1 subgoal):\n 1. (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j)) =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "by fastforce"], ["proof (state)\nthis:\n  (\\<forall>i j k. f (i, k) * f (k, j) \\<le> f (i, j)) =\n  (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "finally"], ["proof (chain)\npicking this:\n  matrix_idempotent_semiring.transitive f =\n  (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "show ?thesis"], ["proof (prove)\nusing this:\n  matrix_idempotent_semiring.transitive f =\n  (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))\n\ngoal (1 subgoal):\n 1. matrix_idempotent_semiring.transitive f =\n    (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))", "."], ["proof (state)\nthis:\n  matrix_idempotent_semiring.transitive f =\n  (\\<forall>i j k. f (i, k) \\<le> f (i, j) \\<or> f (k, j) \\<le> f (i, j))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nWe finally show the effect of composing with a coreflexive (test) from the left and from the right.\nThis amounts to a restriction of each row or column to the entry on the diagonal of the coreflexive.\nIn this case, restrictions are formed by meets.\n\\<close>"], ["", "lemma coreflexive_comp_linorder_matrix:\n  fixes f g :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive f\"\n    shows \"(f \\<odot> g) (i,j) = f (i,i) \\<sqinter> g (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "have 1: \"\\<forall>k . i \\<noteq> k \\<longrightarrow> f (i,k) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>k. i \\<noteq> k \\<longrightarrow> f (i, k) = bot", "using assms coreflexive_linorder_matrix"], ["proof (prove)\nusing this:\n  matrix_idempotent_semiring.coreflexive f\n  matrix_idempotent_semiring.coreflexive ?f =\n  (\\<forall>i j. i \\<noteq> j \\<longrightarrow> ?f (i, j) = bot)\n\ngoal (1 subgoal):\n 1. \\<forall>k. i \\<noteq> k \\<longrightarrow> f (i, k) = bot", "by auto"], ["proof (state)\nthis:\n  \\<forall>k. i \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "have \"(\\<Squnion>\\<^sub>k f (i,k)) = f (i,i) \\<squnion> (\\<Squnion>\\<^bsub>k\\<in>UNIV-{i}\\<^esub> f (i,k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} =\n    f (i, i) \\<squnion> sup_monoid.sum (\\<lambda>k. f (i, k)) (UNIV - {i})", "by (metis (no_types) UNIV_def brouwer.inf_bot_right finite_UNIV insert_def sup_monoid.sum.insert_remove)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} =\n  f (i, i) \\<squnion> sup_monoid.sum (\\<lambda>k. f (i, k)) (UNIV - {i})\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "hence 2: \"(\\<Squnion>\\<^sub>k f (i,k)) = f (i,i)\""], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} =\n  f (i, i) \\<squnion> sup_monoid.sum (\\<lambda>k. f (i, k)) (UNIV - {i})\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, i)", "using 1"], ["proof (prove)\nusing this:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} =\n  f (i, i) \\<squnion> sup_monoid.sum (\\<lambda>k. f (i, k)) (UNIV - {i})\n  \\<forall>k. i \\<noteq> k \\<longrightarrow> f (i, k) = bot\n\ngoal (1 subgoal):\n 1. sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, i)", "by (metis (no_types) linorder_finite_sup_selective sup_not_bot)"], ["proof (state)\nthis:\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "have \"(f \\<odot> g) (i,j) = (f \\<odot> mtop \\<otimes> g) (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = (f \\<odot> mtop \\<otimes> g) (i, j)", "by (metis assms matrix_stone_relation_algebra.coreflexive_comp_top_inf)"], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = (f \\<odot> mtop \\<otimes> g) (i, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "also"], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = (f \\<odot> mtop \\<otimes> g) (i, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "have \"... = (\\<Squnion>\\<^sub>k f (i,k)) \\<sqinter> g (i,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> mtop \\<otimes> g) (i, j) =\n    sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<sqinter> g (i, j)", "by (metis inf_matrix_def comp_top_linorder_matrix)"], ["proof (state)\nthis:\n  (f \\<odot> mtop \\<otimes> g) (i, j) =\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<sqinter> g (i, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "finally"], ["proof (chain)\npicking this:\n  (f \\<odot> g) (i, j) =\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<sqinter> g (i, j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<odot> g) (i, j) =\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<sqinter> g (i, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "using 2"], ["proof (prove)\nusing this:\n  (f \\<odot> g) (i, j) =\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} \\<sqinter> g (i, j)\n  sup_monoid.sum (\\<lambda>k. f (i, k)) {k. True} = f (i, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)", "by simp"], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = f (i, i) \\<sqinter> g (i, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_coreflexive_linorder_matrix:\n  fixes f g :: \"('a::finite,'b::linorder_stone_relation_algebra_expansion) square\"\n  assumes \"matrix_idempotent_semiring.coreflexive g\"\n    shows \"(f \\<odot> g) (i,j) = f (i,j) \\<sqinter> g (j,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "have \"(f \\<odot> g) (i,j) = ((f \\<odot> g)\\<^sup>t) (j,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = ((f \\<odot> g)\\<^sup>t) (j, i)", "by (simp add: conv_matrix_def)"], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = ((f \\<odot> g)\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "also"], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = ((f \\<odot> g)\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "have \"... = (g \\<odot> f\\<^sup>t) (j,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f \\<odot> g)\\<^sup>t) (j, i) = (g \\<odot> f\\<^sup>t) (j, i)", "by (simp add: assms matrix_stone_relation_algebra.conv_dist_comp matrix_stone_relation_algebra.coreflexive_symmetric)"], ["proof (state)\nthis:\n  ((f \\<odot> g)\\<^sup>t) (j, i) = (g \\<odot> f\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "also"], ["proof (state)\nthis:\n  ((f \\<odot> g)\\<^sup>t) (j, i) = (g \\<odot> f\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "have \"... = g (j,j) \\<sqinter> (f\\<^sup>t) (j,i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (g \\<odot> f\\<^sup>t) (j, i) = g (j, j) \\<sqinter> (f\\<^sup>t) (j, i)", "by (simp add: assms coreflexive_comp_linorder_matrix)"], ["proof (state)\nthis:\n  (g \\<odot> f\\<^sup>t) (j, i) = g (j, j) \\<sqinter> (f\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "also"], ["proof (state)\nthis:\n  (g \\<odot> f\\<^sup>t) (j, i) = g (j, j) \\<sqinter> (f\\<^sup>t) (j, i)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "have \"... = f (i,j) \\<sqinter> g (j,j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g (j, j) \\<sqinter> (f\\<^sup>t) (j, i) = f (i, j) \\<sqinter> g (j, j)", "by (metis (no_types, lifting) conv_def old.prod.case conv_matrix_def inf_commute)"], ["proof (state)\nthis:\n  g (j, j) \\<sqinter> (f\\<^sup>t) (j, i) = f (i, j) \\<sqinter> g (j, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "finally"], ["proof (chain)\npicking this:\n  (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)\n\ngoal (1 subgoal):\n 1. (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)", "."], ["proof (state)\nthis:\n  (f \\<odot> g) (i, j) = f (i, j) \\<sqinter> g (j, j)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}