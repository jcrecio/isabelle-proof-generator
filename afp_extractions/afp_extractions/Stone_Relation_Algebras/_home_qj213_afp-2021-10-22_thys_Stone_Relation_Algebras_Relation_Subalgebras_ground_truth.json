{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras/Relation_Subalgebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras", "problem_names": ["lemma simp_coreflexive [simp]:\n  \"\\<exists>y . Rep_coreflexive x \\<le> 1\"", "lemma simp_vector [simp]:\n  \"\\<exists>y . Rep_vector x * top = Rep_vector x\"", "lemma simp_covector [simp]:\n  \"\\<exists>y . top * Rep_covector x = Rep_covector x\""], "translations": [["", "lemma simp_coreflexive [simp]:\n  \"\\<exists>y . Rep_coreflexive x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. coreflexive (Rep_coreflexive x)", "using Rep_coreflexive"], ["proof (prove)\nusing this:\n  Rep_coreflexive ?x \\<in> \\<down>(1::?'a)\n\ngoal (1 subgoal):\n 1. \\<exists>y. coreflexive (Rep_coreflexive x)", "by simp"], ["", "setup_lifting type_definition_coreflexive"], ["", "instantiation coreflexive :: (idempotent_semiring) bounded_idempotent_semiring\nbegin"], ["", "lift_definition sup_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> 'a coreflexive\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>coreflexive a1; coreflexive a2\\<rbrakk>\n       \\<Longrightarrow> coreflexive (a1 \\<squnion> a2)", "by simp"], ["", "lift_definition times_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> 'a coreflexive\" is times"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>coreflexive a1; coreflexive a2\\<rbrakk>\n       \\<Longrightarrow> coreflexive (a1 * a2)", "by (simp add: coreflexive_mult_closed)"], ["", "lift_definition bot_coreflexive :: \"'a coreflexive\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive bot", "by simp"], ["", "lift_definition one_coreflexive :: \"'a coreflexive\" is 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lift_definition top_coreflexive :: \"'a coreflexive\" is 1"], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lift_definition less_eq_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a coreflexive, bounded_idempotent_semiring_class)", "apply intro_classes"], ["proof (prove)\ngoal (19 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<le> x \\<squnion> y\n 6. \\<And>y x. y \\<le> x \\<squnion> y\n 7. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 8. \\<And>a. bot \\<le> a\n 9. \\<And>x y z. x * y \\<squnion> x * z \\<le> x * (y \\<squnion> z)\n 10. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\nA total of 19 subgoals...", "apply (simp_all add: less_coreflexive.rep_eq less_eq_coreflexive.rep_eq less_le_not_le)[2]"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 2. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 3. \\<And>x y. x \\<le> x \\<squnion> y\n 4. \\<And>y x. y \\<le> x \\<squnion> y\n 5. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 6. \\<And>a. bot \\<le> a\n 7. \\<And>x y z. x * y \\<squnion> x * z \\<le> x * (y \\<squnion> z)\n 8. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 9. \\<And>x. bot * x = bot\n 10. \\<And>x. 1 * x = x\nA total of 17 subgoals...", "apply (meson less_eq_coreflexive.rep_eq order_trans)"], ["proof (prove)\ngoal (16 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 2. \\<And>x y. x \\<le> x \\<squnion> y\n 3. \\<And>y x. y \\<le> x \\<squnion> y\n 4. \\<And>y x z.\n       \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n       \\<Longrightarrow> y \\<squnion> z \\<le> x\n 5. \\<And>a. bot \\<le> a\n 6. \\<And>x y z. x * y \\<squnion> x * z \\<le> x * (y \\<squnion> z)\n 7. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 8. \\<And>x. bot * x = bot\n 9. \\<And>x. 1 * x = x\n 10. \\<And>x. x \\<le> x * 1\nA total of 16 subgoals...", "apply (simp_all add: Rep_coreflexive_inject bot_coreflexive.rep_eq less_eq_coreflexive.rep_eq sup_coreflexive.rep_eq)[5]"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x y z. x * y \\<squnion> x * z \\<le> x * (y \\<squnion> z)\n 2. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 3. \\<And>x. bot * x = bot\n 4. \\<And>x. 1 * x = x\n 5. \\<And>x. x \\<le> x * 1\n 6. \\<And>x. x \\<squnion> top = top\n 7. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 8. \\<And>a b c. a * b * c = a * (b * c)\n 9. \\<And>a. a * 1 = a\n 10. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\nA total of 11 subgoals...", "apply (simp add: semiring.distrib_left less_eq_coreflexive.rep_eq sup_coreflexive.rep_eq times_coreflexive.rep_eq)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 2. \\<And>x. bot * x = bot\n 3. \\<And>x. 1 * x = x\n 4. \\<And>x. x \\<le> x * 1\n 5. \\<And>x. x \\<squnion> top = top\n 6. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 7. \\<And>a b c. a * b * c = a * (b * c)\n 8. \\<And>a. a * 1 = a\n 9. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 10. \\<And>x. x * bot = bot", "apply (metis (mono_tags, lifting) sup_coreflexive.rep_eq times_coreflexive.rep_eq Rep_coreflexive_inject mult_right_dist_sup)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<And>x. bot * x = bot\n 2. \\<And>x. 1 * x = x\n 3. \\<And>x. x \\<le> x * 1\n 4. \\<And>x. x \\<squnion> top = top\n 5. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 6. \\<And>a b c. a * b * c = a * (b * c)\n 7. \\<And>a. a * 1 = a\n 8. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 9. \\<And>x. x * bot = bot", "apply (simp add: times_coreflexive.rep_eq bot_coreflexive.rep_eq Rep_coreflexive_inject[THEN sym])"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>x. 1 * x = x\n 2. \\<And>x. x \\<le> x * 1\n 3. \\<And>x. x \\<squnion> top = top\n 4. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 5. \\<And>a b c. a * b * c = a * (b * c)\n 6. \\<And>a. a * 1 = a\n 7. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 8. \\<And>x. x * bot = bot", "apply (simp add: one_coreflexive.rep_eq times_coreflexive.rep_eq Rep_coreflexive_inject[THEN sym])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x. x \\<le> x * 1\n 2. \\<And>x. x \\<squnion> top = top\n 3. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 4. \\<And>a b c. a * b * c = a * (b * c)\n 5. \\<And>a. a * 1 = a\n 6. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 7. \\<And>x. x * bot = bot", "apply (simp add: one_coreflexive.rep_eq less_eq_coreflexive.rep_eq times_coreflexive.rep_eq)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x \\<squnion> top = top\n 2. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 3. \\<And>a b c. a * b * c = a * (b * c)\n 4. \\<And>a. a * 1 = a\n 5. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 6. \\<And>x. x * bot = bot", "apply (simp only: sup_coreflexive.rep_eq top_coreflexive.rep_eq Rep_coreflexive_inject[THEN sym], metis Abs_coreflexive_cases Abs_coreflexive_inverse mem_Collect_eq sup.absorb2)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y z. x * y * z \\<le> x * (y * z)\n 2. \\<And>a b c. a * b * c = a * (b * c)\n 3. \\<And>a. a * 1 = a\n 4. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 5. \\<And>x. x * bot = bot", "apply (simp add: less_eq_coreflexive.rep_eq mult.assoc times_coreflexive.rep_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c. a * b * c = a * (b * c)\n 2. \\<And>a. a * 1 = a\n 3. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 4. \\<And>x. x * bot = bot", "apply (metis (mono_tags, lifting) times_coreflexive.rep_eq Rep_coreflexive_inject mult.assoc)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. a * 1 = a\n 2. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 3. \\<And>x. x * bot = bot", "using Rep_coreflexive_inject one_coreflexive.rep_eq times_coreflexive.rep_eq"], ["proof (prove)\nusing this:\n  (Rep_coreflexive ?x = Rep_coreflexive ?y) = (?x = ?y)\n  Rep_coreflexive 1 = (1::'a)\n  Rep_coreflexive (?x * ?xa) = Rep_coreflexive ?x * Rep_coreflexive ?xa\n\ngoal (3 subgoals):\n 1. \\<And>a. a * 1 = a\n 2. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 3. \\<And>x. x * bot = bot", "apply fastforce"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y z. x * (y \\<squnion> z) = x * y \\<squnion> x * z\n 2. \\<And>x. x * bot = bot", "apply (metis (mono_tags, lifting) sup_coreflexive.rep_eq times_coreflexive.rep_eq Rep_coreflexive_inject mult_left_dist_sup)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x * bot = bot", "by (simp add: times_coreflexive.rep_eq bot_coreflexive.rep_eq Rep_coreflexive_inject[THEN sym])"], ["", "end"], ["", "text \\<open>\nThe coreflexives (tests) in a Stone relation algebra form a Stone relation algebra where the pseudocomplement is taken relative to the identity relation and converse is the identity function.\n\\<close>"], ["", "instantiation coreflexive :: (stone_relation_algebra) stone_relation_algebra\nbegin"], ["", "lift_definition inf_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> 'a coreflexive\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>coreflexive a1; coreflexive a2\\<rbrakk>\n       \\<Longrightarrow> coreflexive (a1 \\<sqinter> a2)", "by (simp add: le_infI1)"], ["", "lift_definition minus_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive \\<Rightarrow> 'a coreflexive\" is \"\\<lambda>x y . x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>coreflexive a1; coreflexive a2\\<rbrakk>\n       \\<Longrightarrow> coreflexive (a1 \\<sqinter> - a2)", "by (simp add: le_infI1)"], ["", "lift_definition uminus_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive\" is \"\\<lambda>x . -x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. coreflexive a \\<Longrightarrow> coreflexive (a ')", "by simp"], ["", "lift_definition conv_coreflexive :: \"'a coreflexive \\<Rightarrow> 'a coreflexive\" is id"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. coreflexive a \\<Longrightarrow> coreflexive (id a)", "by simp"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a coreflexive, stone_relation_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (17 subgoals):\n 1. \\<And>x y. x \\<sqinter> y \\<le> x\n 2. \\<And>x y. x \\<sqinter> y \\<le> y\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 4. \\<And>a. a \\<le> top\n 5. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 6. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 7. \\<And>x. - x \\<squnion> - - x = top\n 8. \\<And>x y z. x * y * z = x * (y * z)\n 9. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 10. \\<And>x. bot * x = bot\nA total of 17 subgoals...", "apply (auto simp: inf_coreflexive.rep_eq less_eq_coreflexive.rep_eq)[3]"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<And>a. a \\<le> top\n 2. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 3. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 4. \\<And>x. - x \\<squnion> - - x = top\n 5. \\<And>x y z. x * y * z = x * (y * z)\n 6. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 7. \\<And>x. bot * x = bot\n 8. \\<And>x. 1 * x = x\n 9. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 10. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\nA total of 14 subgoals...", "apply simp"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top\n 4. \\<And>x y z. x * y * z = x * (y * z)\n 5. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 6. \\<And>x. bot * x = bot\n 7. \\<And>x. 1 * x = x\n 8. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 9. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 10. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\nA total of 13 subgoals...", "apply (metis (mono_tags, lifting) Rep_coreflexive_inject inf_coreflexive.rep_eq sup_coreflexive.rep_eq sup_inf_distrib1)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top\n 3. \\<And>x y z. x * y * z = x * (y * z)\n 4. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 5. \\<And>x. bot * x = bot\n 6. \\<And>x. 1 * x = x\n 7. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 8. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 9. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 10. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\nA total of 12 subgoals...", "apply (metis (mono_tags, lifting) Rep_coreflexive_inject bot_coreflexive.rep_eq top_greatest coreflexive_pseudo_complement inf_coreflexive.rep_eq less_eq_coreflexive.rep_eq one_coreflexive.rep_eq one_coreflexive_def top_coreflexive_def uminus_coreflexive.rep_eq)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<And>x. - x \\<squnion> - - x = top\n 2. \\<And>x y z. x * y * z = x * (y * z)\n 3. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 4. \\<And>x. bot * x = bot\n 5. \\<And>x. 1 * x = x\n 6. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 7. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 8. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 9. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 10. \\<And>x y. - - (x * y) = - - x * - - y\nA total of 11 subgoals...", "apply (metis (mono_tags, lifting) Rep_coreflexive_inject maddux_3_21_pp one_coreflexive.rep_eq one_coreflexive_def pp_dist_inf pp_one regular_closed_p sup_coreflexive.rep_eq sup_right_top top_coreflexive_def uminus_coreflexive.rep_eq)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z. x * y * z = x * (y * z)\n 2. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 3. \\<And>x. bot * x = bot\n 4. \\<And>x. 1 * x = x\n 5. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 6. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 7. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 8. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 9. \\<And>x y. - - (x * y) = - - x * - - y\n 10. - - 1 = 1", "apply (auto simp: mult.assoc mult_right_dist_sup)[4]"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 2. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 3. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 4. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 5. \\<And>x y. - - (x * y) = - - x * - - y\n 6. - - 1 = 1", "using Rep_coreflexive_inject conv_coreflexive.rep_eq"], ["proof (prove)\nusing this:\n  (Rep_coreflexive ?x = Rep_coreflexive ?y) = (?x = ?y)\n  Rep_coreflexive (?x\\<^sup>T) = Rep_coreflexive ?x\n\ngoal (6 subgoals):\n 1. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 2. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 3. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 4. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 5. \\<And>x y. - - (x * y) = - - x * - - y\n 6. - - 1 = 1", "apply fastforce"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 2. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 3. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 4. \\<And>x y. - - (x * y) = - - x * - - y\n 5. - - 1 = 1", "apply (metis (mono_tags) Rep_coreflexive_inject conv_coreflexive.rep_eq)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 2. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 3. \\<And>x y. - - (x * y) = - - x * - - y\n 4. - - 1 = 1", "apply (metis (mono_tags, lifting) Rep_coreflexive_inject top_greatest conv_coreflexive.rep_eq coreflexive_commutative less_eq_coreflexive.rep_eq one_coreflexive.rep_eq one_coreflexive_def times_coreflexive.rep_eq top_coreflexive_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 2. \\<And>x y. - - (x * y) = - - x * - - y\n 3. - - 1 = 1", "apply (simp only: conv_coreflexive.rep_eq less_eq_coreflexive.rep_eq one_coreflexive.rep_eq times_coreflexive.rep_eq inf_coreflexive.rep_eq Rep_coreflexive_inject[THEN sym], metis coreflexive_dedekind Rep_coreflexive mem_Collect_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. - - (x * y) = - - x * - - y\n 2. - - 1 = 1", "apply (metis (mono_tags, lifting) Rep_coreflexive Rep_coreflexive_inject coreflexive_pp_dist_comp mem_Collect_eq times_coreflexive.rep_eq uminus_coreflexive.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. - - 1 = 1", "by (metis (mono_tags, hide_lams) Rep_coreflexive_inverse inf.commute inf.idem inf_import_p one_coreflexive.rep_eq pp_one uminus_coreflexive.rep_eq)"], ["", "end"], ["", "text \\<open>\nVectors in a Stone relation algebra form a Stone subalgebra.\n\\<close>"], ["", "typedef (overloaded) 'a vector = \"vectors::'a::bounded_pre_left_semiring set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> vectors", "using surjective_top_closed"], ["proof (prove)\nusing this:\n  surjective top\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> vectors", "by blast"], ["", "lemma simp_vector [simp]:\n  \"\\<exists>y . Rep_vector x * top = Rep_vector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. vector (Rep_vector x)", "using Rep_vector"], ["proof (prove)\nusing this:\n  Rep_vector ?x \\<in> vectors\n\ngoal (1 subgoal):\n 1. \\<exists>y. vector (Rep_vector x)", "by simp"], ["", "setup_lifting type_definition_vector"], ["", "instantiation vector :: (stone_relation_algebra) stone_algebra\nbegin"], ["", "lift_definition sup_vector :: \"'a vector \\<Rightarrow> 'a vector \\<Rightarrow> 'a vector\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>vector a1; vector a2\\<rbrakk>\n       \\<Longrightarrow> vector (a1 \\<squnion> a2)", "by (simp add: vector_sup_closed)"], ["", "lift_definition inf_vector :: \"'a vector \\<Rightarrow> 'a vector \\<Rightarrow> 'a vector\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>vector a1; vector a2\\<rbrakk>\n       \\<Longrightarrow> vector (a1 \\<sqinter> a2)", "by (simp add: vector_inf_closed)"], ["", "lift_definition uminus_vector :: \"'a vector \\<Rightarrow> 'a vector\" is uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. vector a \\<Longrightarrow> vector (- a)", "by (simp add: vector_complement_closed)"], ["", "lift_definition bot_vector :: \"'a vector\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector bot", "by simp"], ["", "lift_definition top_vector :: \"'a vector\" is top"], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lift_definition less_eq_vector :: \"'a vector \\<Rightarrow> 'a vector \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_vector :: \"'a vector \\<Rightarrow> 'a vector \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a vector, stone_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 15 subgoals...", "apply (auto simp: Rep_vector_inject top_vector.rep_eq bot_vector.rep_eq less_le_not_le inf_vector.rep_eq sup_vector.rep_eq less_eq_vector.rep_eq less_vector.rep_eq)[12]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "apply (metis (mono_tags, lifting) Rep_vector_inject inf_vector.rep_eq sup_inf_distrib1 sup_vector.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "apply (metis (mono_tags, lifting) Rep_vector_inject bot_vector_def bot_vector.rep_eq pseudo_complement inf_vector.rep_eq less_eq_vector.rep_eq uminus_vector.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "by (metis (mono_tags, lifting) sup_vector.rep_eq uminus_vector.rep_eq Rep_vector_inverse stone top_vector.abs_eq)"], ["", "end"], ["", "text \\<open>\nCovectors in a Stone relation algebra form a Stone subalgebra.\n\\<close>"], ["", "typedef (overloaded) 'a covector = \"covectors::'a::bounded_pre_left_semiring set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> covectors", "using surjective_top_closed"], ["proof (prove)\nusing this:\n  surjective top\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> covectors", "by blast"], ["", "lemma simp_covector [simp]:\n  \"\\<exists>y . top * Rep_covector x = Rep_covector x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>y. covector (Rep_covector x)", "using Rep_covector"], ["proof (prove)\nusing this:\n  Rep_covector ?x \\<in> covectors\n\ngoal (1 subgoal):\n 1. \\<exists>y. covector (Rep_covector x)", "by simp"], ["", "setup_lifting type_definition_covector"], ["", "instantiation covector :: (stone_relation_algebra) stone_algebra\nbegin"], ["", "lift_definition sup_covector :: \"'a covector \\<Rightarrow> 'a covector \\<Rightarrow> 'a covector\" is sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>covector a1; covector a2\\<rbrakk>\n       \\<Longrightarrow> covector (a1 \\<squnion> a2)", "by (simp add: covector_sup_closed)"], ["", "lift_definition inf_covector :: \"'a covector \\<Rightarrow> 'a covector \\<Rightarrow> 'a covector\" is inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a1 a2.\n       \\<lbrakk>covector a1; covector a2\\<rbrakk>\n       \\<Longrightarrow> covector (a1 \\<sqinter> a2)", "by (simp add: covector_inf_closed)"], ["", "lift_definition uminus_covector :: \"'a covector \\<Rightarrow> 'a covector\" is uminus"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. covector a \\<Longrightarrow> covector (- a)", "by (simp add: covector_complement_closed)"], ["", "lift_definition bot_covector :: \"'a covector\" is bot"], ["proof (prove)\ngoal (1 subgoal):\n 1. covector bot", "by simp"], ["", "lift_definition top_covector :: \"'a covector\" is top"], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lift_definition less_eq_covector :: \"'a covector \\<Rightarrow> 'a covector \\<Rightarrow> bool\" is less_eq"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lift_definition less_covector :: \"'a covector \\<Rightarrow> 'a covector \\<Rightarrow> bool\" is less"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a covector, stone_algebra_class)", "apply intro_classes"], ["proof (prove)\ngoal (15 subgoals):\n 1. \\<And>x y. (x < y) = (x \\<le> y \\<and> \\<not> y \\<le> x)\n 2. \\<And>x. x \\<le> x\n 3. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; y \\<le> z\\<rbrakk> \\<Longrightarrow> x \\<le> z\n 4. \\<And>x y.\n       \\<lbrakk>x \\<le> y; y \\<le> x\\<rbrakk> \\<Longrightarrow> x = y\n 5. \\<And>x y. x \\<sqinter> y \\<le> x\n 6. \\<And>x y. x \\<sqinter> y \\<le> y\n 7. \\<And>x y z.\n       \\<lbrakk>x \\<le> y; x \\<le> z\\<rbrakk>\n       \\<Longrightarrow> x \\<le> y \\<sqinter> z\n 8. \\<And>x y. x \\<le> x \\<squnion> y\n 9. \\<And>y x. y \\<le> x \\<squnion> y\n 10. \\<And>y x z.\n        \\<lbrakk>y \\<le> x; z \\<le> x\\<rbrakk>\n        \\<Longrightarrow> y \\<squnion> z \\<le> x\nA total of 15 subgoals...", "apply (auto simp: Rep_covector_inject less_eq_covector.rep_eq inf_covector.rep_eq bot_covector.rep_eq top_covector.rep_eq sup_covector.rep_eq less_le_not_le less_covector.rep_eq)[12]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x y z.\n       x \\<squnion> y \\<sqinter> z =\n       (x \\<squnion> y) \\<sqinter> (x \\<squnion> z)\n 2. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 3. \\<And>x. - x \\<squnion> - - x = top", "apply (metis (mono_tags, lifting) Rep_covector_inject inf_covector.rep_eq sup_inf_distrib1 sup_covector.rep_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y. (x \\<sqinter> y = bot) = (x \\<le> - y)\n 2. \\<And>x. - x \\<squnion> - - x = top", "apply (metis (mono_tags, lifting) Rep_covector_inject bot_covector_def bot_covector.rep_eq pseudo_complement inf_covector.rep_eq less_eq_covector.rep_eq uminus_covector.rep_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. - x \\<squnion> - - x = top", "by (metis (mono_tags, lifting) sup_covector.rep_eq uminus_covector.rep_eq Rep_covector_inverse stone top_covector.abs_eq)"], ["", "end"], ["", "end"]]}