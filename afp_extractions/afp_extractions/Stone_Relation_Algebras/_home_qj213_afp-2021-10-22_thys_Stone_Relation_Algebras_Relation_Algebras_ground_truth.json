{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras/Relation_Algebras.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras", "problem_names": ["lemma conv_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>T \\<le> y\\<^sup>T\"", "lemma conv_order:\n  \"x \\<le> y \\<longleftrightarrow> x\\<^sup>T \\<le> y\\<^sup>T\"", "lemma conv_bot [simp]:\n  \"bot\\<^sup>T = bot\"", "lemma conv_top [simp]:\n  \"top\\<^sup>T = top\"", "lemma conv_dist_inf:\n  \"(x \\<sqinter> y)\\<^sup>T = x\\<^sup>T \\<sqinter> y\\<^sup>T\"", "lemma conv_inf_bot_iff:\n  \"bot = x\\<^sup>T \\<sqinter> y \\<longleftrightarrow> bot = x \\<sqinter> y\\<^sup>T\"", "lemma conv_one [simp]:\n  \"1\\<^sup>T = 1\"", "lemma comp_left_dist_sup:\n  \"(x * y) \\<squnion> (x * z) = x * (y \\<squnion> z)\"", "lemma comp_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\"", "lemma comp_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\"", "lemma comp_isotone:\n  \"x \\<le> y \\<Longrightarrow> w \\<le> z \\<Longrightarrow> x * w \\<le> y * z\"", "lemma comp_left_subdist_inf:\n  \"(x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z\"", "lemma comp_left_increasing_sup:\n  \"x * y \\<le> (x \\<squnion> z) * y\"", "lemma comp_right_subdist_inf:\n  \"x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z\"", "lemma comp_right_increasing_sup:\n  \"x * y \\<le> x * (y \\<squnion> z)\"", "lemma comp_right_zero [simp]:\n  \"x * bot = bot\"", "lemma comp_right_one [simp]:\n  \"x * 1 = x\"", "lemma comp_left_conjugate:\n  \"conjugate (\\<lambda>y . x * y) (\\<lambda>y . x\\<^sup>T * y)\"", "lemma comp_right_conjugate:\n  \"conjugate (\\<lambda>y . y * x) (\\<lambda>y . y * x\\<^sup>T)\"", "lemma schroeder_1:\n  \"x * y \\<sqinter> z = bot \\<longleftrightarrow> x\\<^sup>T * z \\<sqinter> y = bot\"", "lemma schroeder_2:\n  \"x * y \\<sqinter> z = bot \\<longleftrightarrow> z * y\\<^sup>T \\<sqinter> x = bot\"", "lemma comp_additive:\n  \"additive (\\<lambda>y . x * y) \\<and> additive (\\<lambda>y . x\\<^sup>T * y) \\<and> additive (\\<lambda>y . y * x) \\<and> additive (\\<lambda>y . y * x\\<^sup>T)\"", "lemma dedekind_2:\n  \"y * x \\<sqinter> z \\<le> (y \\<sqinter> (z * x\\<^sup>T)) * x\"", "lemma vector_inf_comp:\n  \"vector x \\<Longrightarrow> (x \\<sqinter> y) * z = x \\<sqinter> (y * z)\"", "lemma vector_inf_closed:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<sqinter> y)\"", "lemma vector_inf_one_comp:\n  \"vector x \\<Longrightarrow> (x \\<sqinter> 1) * y = x \\<sqinter> y\"", "lemma covector_inf_comp_1:\n  assumes \"vector x\"\n    shows \"(y \\<sqinter> x\\<^sup>T) * z = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\"", "lemma covector_inf_comp_2:\n  assumes \"vector x\"\n    shows \"y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\"", "lemma covector_inf_comp_3:\n  \"vector x \\<Longrightarrow> (y \\<sqinter> x\\<^sup>T) * z = y * (x \\<sqinter> z)\"", "lemma covector_inf_closed:\n  \"covector x \\<Longrightarrow> covector y \\<Longrightarrow> covector (x \\<sqinter> y)\"", "lemma vector_conv_covector:\n  \"vector v \\<longleftrightarrow> covector (v\\<^sup>T)\"", "lemma covector_conv_vector:\n  \"covector v \\<longleftrightarrow> vector (v\\<^sup>T)\"", "lemma covector_comp_inf:\n  \"covector z \\<Longrightarrow> x * (y \\<sqinter> z) = x * y \\<sqinter> z\"", "lemma vector_restrict_comp_conv:\n  \"vector x \\<Longrightarrow> x \\<sqinter> y \\<le> x\\<^sup>T * y\"", "lemma covector_restrict_comp_conv:\n  \"covector x \\<Longrightarrow> y \\<sqinter> x \\<le> y * x\\<^sup>T\"", "lemma covector_comp_inf_1:\n  \"covector x \\<Longrightarrow> (y \\<sqinter> x) * z = y * (x\\<^sup>T \\<sqinter> z)\"", "lemma surjective_var:\n  \"surjective x \\<longleftrightarrow> surjective_var x\"", "lemma total_var:\n  \"total x \\<longleftrightarrow> total_var x\"", "lemma surjective_conv_total:\n  \"surjective x \\<longleftrightarrow> total (x\\<^sup>T)\"", "lemma total_conv_surjective:\n  \"total x \\<longleftrightarrow> surjective (x\\<^sup>T)\"", "lemma injective_conv_univalent:\n  \"injective x \\<longleftrightarrow> univalent (x\\<^sup>T)\"", "lemma univalent_conv_injective:\n  \"univalent x \\<longleftrightarrow> injective (x\\<^sup>T)\"", "lemma univalent_bot_closed:\n  \"univalent bot\"", "lemma univalent_one_closed:\n  \"univalent 1\"", "lemma univalent_inf_closed:\n  \"univalent x \\<Longrightarrow> univalent (x \\<sqinter> y)\"", "lemma univalent_mult_closed:\n  assumes \"univalent x\"\n      and \"univalent y\"\n    shows \"univalent (x * y)\"", "lemma injective_bot_closed:\n  \"injective bot\"", "lemma injective_one_closed:\n  \"injective 1\"", "lemma injective_inf_closed:\n  \"injective x \\<Longrightarrow> injective (x \\<sqinter> y)\"", "lemma injective_mult_closed:\n  \"injective x \\<Longrightarrow> injective y \\<Longrightarrow> injective (x * y)\"", "lemma mapping_one_closed:\n  \"mapping 1\"", "lemma mapping_mult_closed:\n  \"mapping x \\<Longrightarrow> mapping y \\<Longrightarrow> mapping (x * y)\"", "lemma bijective_one_closed:\n  \"bijective 1\"", "lemma bijective_mult_closed:\n  \"bijective x \\<Longrightarrow> bijective y \\<Longrightarrow> bijective (x * y)\"", "lemma bijective_conv_mapping:\n  \"bijective x \\<longleftrightarrow> mapping (x\\<^sup>T)\"", "lemma mapping_conv_bijective:\n  \"mapping x \\<longleftrightarrow> bijective (x\\<^sup>T)\"", "lemma reflexive_inf_closed:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<sqinter> y)\"", "lemma reflexive_conv_closed:\n  \"reflexive x \\<Longrightarrow> reflexive (x\\<^sup>T)\"", "lemma coreflexive_inf_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive (x \\<sqinter> y)\"", "lemma coreflexive_conv_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive (x\\<^sup>T)\"", "lemma coreflexive_symmetric:\n  \"coreflexive x \\<Longrightarrow> symmetric x\"", "lemma transitive_inf_closed:\n  \"transitive x \\<Longrightarrow> transitive y \\<Longrightarrow> transitive (x \\<sqinter> y)\"", "lemma transitive_conv_closed:\n  \"transitive x \\<Longrightarrow> transitive (x\\<^sup>T)\"", "lemma dense_conv_closed:\n  \"dense_rel x \\<Longrightarrow> dense_rel (x\\<^sup>T)\"", "lemma idempotent_conv_closed:\n  \"idempotent x \\<Longrightarrow> idempotent (x\\<^sup>T)\"", "lemma preorder_inf_closed:\n  \"preorder x \\<Longrightarrow> preorder y \\<Longrightarrow> preorder (x \\<sqinter> y)\"", "lemma preorder_conv_closed:\n  \"preorder x \\<Longrightarrow> preorder (x\\<^sup>T)\"", "lemma symmetric_bot_closed:\n  \"symmetric bot\"", "lemma symmetric_one_closed:\n  \"symmetric 1\"", "lemma symmetric_top_closed:\n  \"symmetric top\"", "lemma symmetric_inf_closed:\n  \"symmetric x \\<Longrightarrow> symmetric y \\<Longrightarrow> symmetric (x \\<sqinter> y)\"", "lemma symmetric_sup_closed:\n  \"symmetric x \\<Longrightarrow> symmetric y \\<Longrightarrow> symmetric (x \\<squnion> y)\"", "lemma symmetric_conv_closed:\n  \"symmetric x \\<Longrightarrow> symmetric (x\\<^sup>T)\"", "lemma one_inf_conv:\n  \"1 \\<sqinter> x = 1 \\<sqinter> x\\<^sup>T\"", "lemma antisymmetric_bot_closed:\n  \"antisymmetric bot\"", "lemma antisymmetric_one_closed:\n  \"antisymmetric 1\"", "lemma antisymmetric_inf_closed:\n  \"antisymmetric x \\<Longrightarrow> antisymmetric (x \\<sqinter> y)\"", "lemma antisymmetric_conv_closed:\n  \"antisymmetric x \\<Longrightarrow> antisymmetric (x\\<^sup>T)\"", "lemma asymmetric_bot_closed:\n  \"asymmetric bot\"", "lemma asymmetric_inf_closed:\n  \"asymmetric x \\<Longrightarrow> asymmetric (x \\<sqinter> y)\"", "lemma asymmetric_conv_closed:\n  \"asymmetric x \\<Longrightarrow> asymmetric (x\\<^sup>T)\"", "lemma linear_top_closed:\n  \"linear top\"", "lemma linear_sup_closed:\n  \"linear x \\<Longrightarrow> linear (x \\<squnion> y)\"", "lemma linear_reflexive:\n  \"linear x \\<Longrightarrow> reflexive x\"", "lemma linear_conv_closed:\n  \"linear x \\<Longrightarrow> linear (x\\<^sup>T)\"", "lemma linear_comp_closed:\n  assumes \"linear x\"\n      and \"linear y\"\n    shows \"linear (x * y)\"", "lemma equivalence_one_closed:\n  \"equivalence 1\"", "lemma equivalence_top_closed:\n  \"equivalence top\"", "lemma equivalence_inf_closed:\n  \"equivalence x \\<Longrightarrow> equivalence y \\<Longrightarrow> equivalence (x \\<sqinter> y)\"", "lemma equivalence_conv_closed:\n  \"equivalence x \\<Longrightarrow> equivalence (x\\<^sup>T)\"", "lemma order_one_closed:\n  \"order 1\"", "lemma order_inf_closed:\n  \"order x \\<Longrightarrow> order y \\<Longrightarrow> order (x \\<sqinter> y)\"", "lemma order_conv_closed:\n  \"order x \\<Longrightarrow> order (x\\<^sup>T)\"", "lemma linear_order_conv_closed:\n  \"linear_order x \\<Longrightarrow> linear_order (x\\<^sup>T)\"", "lemma equivalence_comp_dist_inf:\n  \"equivalence x \\<Longrightarrow> x * y \\<sqinter> x * z = x * (y \\<sqinter> x * z)\"", "lemma coreflexive_comp_top_inf:\n  \"coreflexive x \\<Longrightarrow> x * top \\<sqinter> y = x * y\"", "lemma coreflexive_comp_top_inf_one:\n  \"coreflexive x \\<Longrightarrow> x * top \\<sqinter> 1 = x\"", "lemma coreflexive_comp_inf:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> x * y = x \\<sqinter> y\"", "lemma coreflexive_comp_inf_comp:\n  assumes \"coreflexive x\"\n      and \"coreflexive y\"\n    shows \"(x * z) \\<sqinter> (y * z) = (x \\<sqinter> y) * z\"", "lemma test_comp_test_inf:\n  \"(x \\<sqinter> 1) * y * (z \\<sqinter> 1) = (x \\<sqinter> 1) * y \\<sqinter> y * (z \\<sqinter> 1)\"", "lemma test_comp_test_top:\n  \"y \\<sqinter> (x \\<sqinter> 1) * top * (z \\<sqinter> 1) = (x \\<sqinter> 1) * y * (z \\<sqinter> 1)\"", "lemma coreflexive_idempotent:\n  \"coreflexive x \\<Longrightarrow> idempotent x\"", "lemma coreflexive_univalent:\n  \"coreflexive x \\<Longrightarrow> univalent x\"", "lemma coreflexive_injective:\n  \"coreflexive x \\<Longrightarrow> injective x\"", "lemma coreflexive_commutative:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> x * y = y * x\"", "lemma coreflexive_dedekind:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive z \\<Longrightarrow> x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x * z)\"", "lemma dedekind_eq:\n  \"x * y \\<sqinter> z = (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\"", "lemma dedekind:\n  \"x * y \\<sqinter> z \\<le> (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z))\"", "lemma vector_export_comp:\n  \"(x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\"", "lemma vector_export_comp_unit:\n  \"(x * top \\<sqinter> 1) * y = x * top \\<sqinter> y\"", "lemma ex231a [simp]:\n  \"(1 \\<sqinter> x * x\\<^sup>T) * x = x\"", "lemma ex231b [simp]:\n  \"x * (1 \\<sqinter> x\\<^sup>T * x) = x\"", "lemma ex231c:\n  \"x \\<le> x * x\\<^sup>T * x\"", "lemma ex231d:\n  \"x \\<le> x * top * x\"", "lemma ex231e [simp]:\n  \"x * top * x * top = x * top\"", "lemma arc_injective:\n  \"arc x \\<Longrightarrow> injective x\"", "lemma arc_conv_closed:\n  \"arc x \\<Longrightarrow> arc (x\\<^sup>T)\"", "lemma arc_univalent:\n  \"arc x \\<Longrightarrow> univalent x\"", "lemma injective_codomain:\n  assumes \"injective x\"\n  shows \"x * (x \\<sqinter> 1) = x \\<sqinter> 1\"", "lemma injective_sup:\n  assumes \"injective t\"\n      and \"e * t\\<^sup>T \\<le> 1\"\n      and \"injective e\"\n    shows \"injective (t \\<squnion> e)\"", "lemma injective_inv:\n  \"injective t \\<Longrightarrow> e * t\\<^sup>T = bot \\<Longrightarrow> arc e \\<Longrightarrow> injective (t \\<squnion> e)\"", "lemma univalent_sup:\n  \"univalent t \\<Longrightarrow> e\\<^sup>T * t \\<le> 1 \\<Longrightarrow> univalent e \\<Longrightarrow> univalent (t \\<squnion> e)\"", "lemma point_injective:\n  \"arc x \\<Longrightarrow> x\\<^sup>T * top * x \\<le> 1\"", "lemma vv_transitive:\n  \"vector v \\<Longrightarrow> (v * v\\<^sup>T) * (v * v\\<^sup>T) \\<le> v * v\\<^sup>T\"", "lemma epm_3:\n  assumes \"e \\<le> w\"\n      and \"injective w\"\n    shows \"e = w \\<sqinter> top * e\"", "lemma comp_inf_vector:\n  \"x * (y \\<sqinter> z * top) = (x \\<sqinter> top * z\\<^sup>T) * y\"", "lemma inf_vector_comp:\n  \"(x \\<sqinter> y * top) * z = y * top \\<sqinter> x * z\"", "lemma comp_inf_covector:\n  \"x * (y \\<sqinter> top * z) = x * y \\<sqinter> top * z\"", "lemma univalent_comp_left_dist_inf:\n  assumes \"univalent x\"\n    shows \"x * (y \\<sqinter> z) = x * y \\<sqinter> x * z\"", "lemma injective_comp_right_dist_inf:\n  \"injective z \\<Longrightarrow> (x \\<sqinter> y) * z = x * z \\<sqinter> y * z\"", "lemma vector_covector:\n  \"vector v \\<Longrightarrow> vector w \\<Longrightarrow> v \\<sqinter> w\\<^sup>T = v * w\\<^sup>T\"", "lemma comp_inf_vector_1:\n  \"(x \\<sqinter> top * y) * z = x * (z \\<sqinter> (top * y)\\<^sup>T)\"", "lemma shunt_bijective:\n  assumes \"bijective z\"\n    shows \"x \\<le> y * z \\<longleftrightarrow> x * z\\<^sup>T \\<le> y\"", "lemma shunt_mapping:\n  \"mapping z \\<Longrightarrow> x \\<le> z * y \\<longleftrightarrow> z\\<^sup>T * x \\<le> y\"", "lemma bijective_reverse:\n  assumes \"bijective p\"\n      and \"bijective q\"\n    shows \"p \\<le> r * q \\<longleftrightarrow> q \\<le> r\\<^sup>T * p\"", "lemma arc_expanded:\n  \"arc x \\<longleftrightarrow> x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * x * top = top\"", "lemma arc_top_arc:\n  assumes \"arc x\"\n    shows \"x * top * x = x\"", "lemma arc_top_edge:\n  assumes \"arc x\"\n    shows \"x\\<^sup>T * top * x = x\\<^sup>T * x\"", "lemma arc_eq_1:\n  assumes \"arc x\"\n    shows \"x = x * x\\<^sup>T * x\"", "lemma arc_eq_2:\n  assumes \"arc x\"\n    shows \"x\\<^sup>T = x\\<^sup>T * x * x\\<^sup>T\"", "lemma points_arc:\n  \"point x \\<Longrightarrow> point y \\<Longrightarrow> arc (x * y\\<^sup>T)\"", "lemma point_arc:\n  \"point x \\<Longrightarrow> arc (x * x\\<^sup>T)\"", "lemma conv_complement_1:\n  \"-(x\\<^sup>T) \\<squnion> (-x)\\<^sup>T = (-x)\\<^sup>T\"", "lemma conv_complement:\n  \"(-x)\\<^sup>T = -(x\\<^sup>T)\"", "lemma conv_complement_sub_inf [simp]:\n  \"x\\<^sup>T * -(x * y) \\<sqinter> y = bot\"", "lemma conv_complement_sub_leq:\n  \"x\\<^sup>T * -(x * y) \\<le> -y\"", "lemma conv_complement_sub [simp]:\n  \"x\\<^sup>T * -(x * y) \\<squnion> -y = -y\"", "lemma complement_conv_sub:\n  \"-(y * x) * x\\<^sup>T \\<le> -y\"", "lemma schroeder_3_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> x\\<^sup>T * z \\<le> -y\"", "lemma schroeder_4_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> z * y\\<^sup>T \\<le> -x\"", "lemma comp_pp_semi_commute:\n  \"x * --y \\<le> --(x * y)\"", "lemma p_comp_pp [simp]:\n  \"-(x * --y) = -(x * y)\"", "lemma pp_comp_semi_commute:\n  \"--x * y \\<le> --(x * y)\"", "lemma p_pp_comp [simp]:\n  \"-(--x * y) = -(x * y)\"", "lemma pp_comp_subdist:\n  \"--x * --y \\<le> --(x * y)\"", "lemma theorem24xxiii:\n  \"x * y \\<sqinter> -(x * z) = x * (y \\<sqinter> -z) \\<sqinter> -(x * z)\"", "lemma vector_complement_closed:\n  \"vector x \\<Longrightarrow> vector (-x)\"", "lemma covector_complement_closed:\n  \"covector x \\<Longrightarrow> covector (-x)\"", "lemma covector_vector_comp:\n  \"vector v \\<Longrightarrow> -v\\<^sup>T * v = bot\"", "lemma irreflexive_bot_closed:\n  \"irreflexive bot\"", "lemma irreflexive_inf_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive (x \\<sqinter> y)\"", "lemma irreflexive_sup_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive y \\<Longrightarrow> irreflexive (x \\<squnion> y)\"", "lemma irreflexive_conv_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive (x\\<^sup>T)\"", "lemma reflexive_complement_irreflexive:\n  \"reflexive x \\<Longrightarrow> irreflexive (-x)\"", "lemma irreflexive_complement_reflexive:\n  \"irreflexive x \\<longleftrightarrow> reflexive (-x)\"", "lemma symmetric_complement_closed:\n  \"symmetric x \\<Longrightarrow> symmetric (-x)\"", "lemma asymmetric_irreflexive:\n  \"asymmetric x \\<Longrightarrow> irreflexive x\"", "lemma linear_asymmetric:\n  \"linear x \\<Longrightarrow> asymmetric (-x)\"", "lemma strict_linear_sup_closed:\n  \"strict_linear x \\<Longrightarrow> strict_linear y \\<Longrightarrow> strict_linear (x \\<squnion> y)\"", "lemma strict_linear_irreflexive:\n  \"strict_linear x \\<Longrightarrow> irreflexive x\"", "lemma strict_linear_conv_closed:\n  \"strict_linear x \\<Longrightarrow> strict_linear (x\\<^sup>T)\"", "lemma strict_order_var:\n  \"strict_order x \\<longleftrightarrow> asymmetric x \\<and> transitive x\"", "lemma strict_order_bot_closed:\n  \"strict_order bot\"", "lemma strict_order_inf_closed:\n  \"strict_order x \\<Longrightarrow> strict_order y \\<Longrightarrow> strict_order (x \\<sqinter> y)\"", "lemma strict_order_conv_closed:\n  \"strict_order x \\<Longrightarrow> strict_order (x\\<^sup>T)\"", "lemma order_strict_order:\n  assumes \"order x\"\n  shows \"strict_order (x \\<sqinter> -1)\"", "lemma strict_order_order:\n  \"strict_order x \\<Longrightarrow> order (x \\<squnion> 1)\"", "lemma linear_strict_order_conv_closed:\n  \"linear_strict_order x \\<Longrightarrow> linear_strict_order (x\\<^sup>T)\"", "lemma linear_order_strict_order:\n  \"linear_order x \\<Longrightarrow> linear_strict_order (x \\<sqinter> -1)\"", "lemma regular_conv_closed:\n  \"regular x \\<Longrightarrow> regular (x\\<^sup>T)\"", "lemma equivalence_comp_left_complement:\n  \"equivalence x \\<Longrightarrow> x * -x = -x\"", "lemma equivalence_comp_right_complement:\n  \"equivalence x \\<Longrightarrow> -x * x = -x\"", "lemma coreflexive_comp_top_coreflexive_complement:\n  \"coreflexive x \\<Longrightarrow> (x * top)' = x '\"", "lemma coreflexive_comp_inf_complement:\n  \"coreflexive x \\<Longrightarrow> (x * y) \\<sqinter> -z = (x * y) \\<sqinter> -(x * z)\"", "lemma double_coreflexive_complement:\n  \"x '' = (-x)'\"", "lemma coreflexive_pp_dist_comp:\n  assumes \"coreflexive x\"\n      and \"coreflexive y\"\n    shows \"(x * y)'' = x '' * y ''\"", "lemma coreflexive_pseudo_complement:\n  \"coreflexive x \\<Longrightarrow> x \\<sqinter> y = bot \\<longleftrightarrow> x \\<le> y '\"", "lemma pp_bijective_conv_mapping:\n  \"pp_bijective x \\<longleftrightarrow> pp_mapping (x\\<^sup>T)\"", "lemma pp_arc_expanded:\n  \"pp_arc x \\<longleftrightarrow> x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * --x * top = top\"", "lemma N_comp:\n  \"N x * y = -(-x * top) \\<sqinter> y\"", "lemma N_comp_top [simp]:\n  \"N x * top = -(-x * top)\"", "lemma vector_N_pp:\n  \"vector x \\<Longrightarrow> N x = --x \\<sqinter> 1\"", "lemma N_vector_pp [simp]:\n  \"N (x * top) = --(x * top) \\<sqinter> 1\"", "lemma N_vector_top_pp [simp]:\n  \"N (x * top) * top = --(x * top)\"", "lemma N_below_inf_one_pp:\n  \"N x \\<le> --x \\<sqinter> 1\"", "lemma N_below_pp:\n  \"N x \\<le> --x\"", "lemma N_comp_N:\n  \"N x * N y = -(-x * top) \\<sqinter> -(-y * top) \\<sqinter> 1\"", "lemma N_bot [simp]:\n  \"N bot = bot\"", "lemma N_top [simp]:\n  \"N top = 1\"", "lemma n_split_omega_mult_pp:\n  \"xs * --xo = xo \\<Longrightarrow> vector xo \\<Longrightarrow> N top * xo = xs * N xo * top\"", "lemma ee:\n  assumes \"vector v\"\n      and \"e \\<le> v * -v\\<^sup>T\"\n    shows \"e * e = bot\"", "lemma et:\n  assumes \"vector v\"\n      and \"e \\<le> v * -v\\<^sup>T\"\n      and \"t \\<le> v * v\\<^sup>T\"\n    shows \"e * t = bot\"\n      and \"e * t\\<^sup>T = bot\"", "lemma ve_dist:\n  assumes \"e \\<le> v * -v\\<^sup>T\"\n      and \"vector v\"\n      and \"arc e\"\n    shows \"(v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T = v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion> e\\<^sup>T * v * v\\<^sup>T \\<squnion> e\\<^sup>T * e\"", "lemma ev:\n  \"vector v \\<Longrightarrow> e \\<le> v * -v\\<^sup>T \\<Longrightarrow> e * v = bot\"", "lemma vTeT:\n  \"vector v \\<Longrightarrow> e \\<le> v * -v\\<^sup>T \\<Longrightarrow> v\\<^sup>T * e\\<^sup>T = bot\"", "lemma prim_subgraph_inv:\n  assumes \"e \\<le> v * -v\\<^sup>T \\<sqinter> g\"\n      and \"t \\<le> v * v\\<^sup>T \\<sqinter> g\"\n    shows \"t \\<squnion> e \\<le> ((v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T) \\<sqinter> g\"", "lemma triple_schroeder_p:\n  \"x * y * z \\<le> -w \\<longleftrightarrow> x\\<^sup>T * w * z\\<^sup>T \\<le> -y\"", "lemma schroeder_5_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> y * z\\<^sup>T \\<le> -x\\<^sup>T\"", "lemma schroeder_6_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> z\\<^sup>T * x \\<le> -y\\<^sup>T\"", "lemma vector_conv_compl:\n  \"vector v \\<Longrightarrow> top * -v\\<^sup>T = -v\\<^sup>T\"", "lemma comp_commute_below_diversity:\n  \"x * y \\<le> -1 \\<longleftrightarrow> y * x \\<le> -1\"", "lemma comp_injective_below_complement:\n  \"injective y \\<Longrightarrow> -x * y \\<le> -(x * y)\"", "lemma comp_univalent_below_complement:\n  \"univalent x \\<Longrightarrow> x * -y \\<le> -(x * y)\"", "lemma comp_bijective_complement:\n  \"bijective y \\<Longrightarrow> -x * y = -(x * y)\"", "lemma comp_mapping_complement:\n  \"mapping x \\<Longrightarrow> x * -y = -(x * y)\"", "lemma kruskal_injective_inv:\n  assumes \"injective f\"\n      and \"covector q\"\n      and \"q * f\\<^sup>T \\<le> q\"\n      and \"e \\<le> q\"\n      and \"q * f\\<^sup>T \\<le> -e\"\n      and \"injective e\"\n      and \"q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f \\<le> 1\"\n    shows \"injective ((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)\"", "lemma kruskal_exchange_injective_inv_1:\n  assumes \"injective f\"\n      and \"covector q\"\n      and \"q * f\\<^sup>T \\<le> q\"\n      and \"q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f \\<le> 1\"\n    shows \"injective ((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T)\"", "lemma kruskal_exchange_acyclic_inv_3:\n  assumes \"injective w\"\n      and \"d \\<le> w\"\n    shows \"(w \\<sqinter> -d) * d\\<^sup>T * top = bot\"", "lemma kruskal_subgraph_inv:\n  assumes \"f \\<le> --(-h \\<sqinter> g)\"\n      and \"e \\<le> --g\"\n      and \"symmetric h\"\n      and \"symmetric g\"\n    shows \"(f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e \\<le> --(-(h \\<sqinter> -e \\<sqinter> -e\\<^sup>T) \\<sqinter> g)\"", "lemma conv_complement_0_p [simp]:\n  \"(-x)\\<^sup>T \\<squnion> (--x)\\<^sup>T = top\"", "lemma theorem24xxiv_pp:\n  \"-(x * y) \\<squnion> --(x * z) = -(x * (y \\<sqinter> -z)) \\<squnion> --(x * z)\"", "lemma asymmetric_linear:\n  \"asymmetric x \\<longleftrightarrow> linear (-x)\"", "lemma strict_linear_asymmetric:\n  \"strict_linear x \\<Longrightarrow> antisymmetric (-x)\"", "lemma regular_complement_top:\n  \"regular x \\<Longrightarrow> x \\<squnion> -x = top\"", "lemma regular_mult_closed:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x * y)\"", "lemma regular_one_closed:\n  \"regular 1\"", "lemma pp_total:\n  \"total (--x) \\<longleftrightarrow> -(x*top) = bot\"", "lemma pp_surjective:\n  \"surjective (--x) \\<longleftrightarrow> -(top*x) = bot\"", "lemma bijective_regular:\n  \"bijective x \\<Longrightarrow> regular x\"", "lemma mapping_regular:\n  \"mapping x \\<Longrightarrow> regular x\"", "lemma arc_regular:\n  assumes \"arc x\"\n    shows \"regular x\"", "lemma times_inf [simp]:\n  \"x * y = x \\<sqinter> y\"", "lemma times_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> y \\<noteq> bot \\<Longrightarrow> x * y \\<noteq> bot\"", "lemma conv_complement_0 [simp]:\n  \"x\\<^sup>T \\<squnion> (-x)\\<^sup>T = top\"", "lemma schroeder_3:\n  \"x * y \\<le> z \\<longleftrightarrow> x\\<^sup>T * -z \\<le> -y\"", "lemma schroeder_4:\n  \"x * y \\<le> z \\<longleftrightarrow> -z * y\\<^sup>T \\<le> -x\"", "lemma theorem24xxiv:\n  \"-(x * y) \\<squnion> (x * z) = -(x * (y \\<sqinter> -z)) \\<squnion> (x * z)\"", "lemma vector_N:\n  \"vector x \\<Longrightarrow> N(x) = x \\<sqinter> 1\"", "lemma N_vector [simp]:\n  \"N(x * top) = x * top \\<sqinter> 1\"", "lemma N_vector_top [simp]:\n  \"N(x * top) * top = x * top\"", "lemma N_below_inf_one:\n  \"N(x) \\<le> x \\<sqinter> 1\"", "lemma N_below:\n  \"N(x) \\<le> x\"", "lemma n_split_omega_mult:\n  \"xs * xo = xo \\<Longrightarrow> xo * top = xo \\<Longrightarrow> N(top) * xo = xs * N(xo) * top\"", "lemma complement_vector:\n  \"vector v \\<longleftrightarrow> vector (-v)\"", "lemma complement_covector:\n  \"covector v \\<longleftrightarrow> covector (-v)\"", "lemma triple_schroeder:\n  \"x * y * z \\<le> w \\<longleftrightarrow> x\\<^sup>T * -w * z\\<^sup>T \\<le> -y\"", "lemma schroeder_5:\n  \"x * y \\<le> z \\<longleftrightarrow> y * -z\\<^sup>T \\<le> -x\\<^sup>T\"", "lemma schroeder_6:\n  \"x * y \\<le> z \\<longleftrightarrow> -z\\<^sup>T * x \\<le> -y\\<^sup>T\"", "lemma arc_in_partition:\n  assumes \"arc x\"\n    shows \"x \\<le> -y \\<or> x \\<le> --y\"", "lemma non_bot_arc_in_partition_xor:\n  assumes \"arc x\"\n      and \"x \\<noteq> bot\"\n    shows \"(x \\<le> -y \\<and> \\<not> x \\<le> --y) \\<or> (\\<not> x \\<le> -y \\<and> x \\<le> --y)\"", "lemma point_in_vector_or_pseudo_complement:\n  assumes \"point p\"\n      and \"vector v\"\n    shows \"p \\<le> --v \\<or> p \\<le> -v\"", "lemma distinct_points:\n  assumes \"point x\"\n    and \"point y\"\n    and \"x \\<noteq> y\"\n  shows \"x \\<sqinter> y = bot\"", "lemma point_in_vector_or_complement:\n  assumes \"point p\"\n      and \"vector v\"\n      and \"regular v\"\n    shows \"p \\<le> v \\<or> p \\<le> -v\"", "lemma point_in_vector_sup:\n  assumes \"point p\"\n      and \"vector v\"\n      and \"regular v\"\n      and \"p \\<le> v \\<squnion> w\"\n    shows \"p \\<le> v \\<or> p \\<le> w\"", "lemma point_atomic_vector:\n  assumes \"point x\"\n    and \"vector y\"\n    and \"regular y\"\n    and \"y \\<le> x\"\n  shows \"y = x \\<or> y = bot\"", "lemma point_in_vector_or_complement_2:\n  assumes \"point x\"\n    and \"vector y\"\n    and \"regular y\"\n    and \"\\<not> y \\<le> -x\"\n  shows \"x \\<le> y\"", "lemma arc_in_arc_or_complement:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"\\<not> x \\<le> y\"\n    shows \"x \\<le> -y\"", "lemma arc_in_sup_arc:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"x \\<le> z \\<squnion> y\"\n    shows \"x \\<le> z \\<or> x \\<le> y\"", "lemma different_arc_in_sup_arc:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"x \\<le> z \\<squnion> y\"\n      and \"x \\<noteq> y\"\n    shows \"x \\<le> z\"", "lemma arc_not_bot:\n  \"arc x \\<Longrightarrow> x \\<noteq> bot\"", "lemma arc_in_partition_xor:\n  \"arc x \\<Longrightarrow> (x \\<le> -y \\<and> \\<not> x \\<le> --y) \\<or> (\\<not> x \\<le> -y \\<and> x \\<le> --y)\""], "translations": [["", "lemma conv_isotone:\n  \"x \\<le> y \\<Longrightarrow> x\\<^sup>T \\<le> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x\\<^sup>T \\<le> y\\<^sup>T", "by (metis conv_dist_sup le_iff_sup)"], ["", "lemma conv_order:\n  \"x \\<le> y \\<longleftrightarrow> x\\<^sup>T \\<le> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x\\<^sup>T \\<le> y\\<^sup>T)", "using conv_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. (x \\<le> y) = (x\\<^sup>T \\<le> y\\<^sup>T)", "by fastforce"], ["", "lemma conv_bot [simp]:\n  \"bot\\<^sup>T = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric bot", "using conv_order bot_unique"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  (?a \\<le> bot) = (?a = bot)\n\ngoal (1 subgoal):\n 1. symmetric bot", "by force"], ["", "lemma conv_top [simp]:\n  \"top\\<^sup>T = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric top", "by (metis conv_involutive conv_order eq_iff top_greatest)"], ["", "lemma conv_dist_inf:\n  \"(x \\<sqinter> y)\\<^sup>T = x\\<^sup>T \\<sqinter> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y)\\<^sup>T = x\\<^sup>T \\<sqinter> y\\<^sup>T", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. (x \\<sqinter> y)\\<^sup>T \\<le> x\\<^sup>T \\<sqinter> y\\<^sup>T\n 2. x\\<^sup>T \\<sqinter> y\\<^sup>T \\<le> (x \\<sqinter> y)\\<^sup>T", "using conv_order"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (2 subgoals):\n 1. (x \\<sqinter> y)\\<^sup>T \\<le> x\\<^sup>T \\<sqinter> y\\<^sup>T\n 2. x\\<^sup>T \\<sqinter> y\\<^sup>T \\<le> (x \\<sqinter> y)\\<^sup>T", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<sqinter> y\\<^sup>T \\<le> (x \\<sqinter> y)\\<^sup>T", "by (metis conv_order conv_involutive inf.boundedI inf.cobounded1 inf.cobounded2)"], ["", "lemma conv_inf_bot_iff:\n  \"bot = x\\<^sup>T \\<sqinter> y \\<longleftrightarrow> bot = x \\<sqinter> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (bot = x\\<^sup>T \\<sqinter> y) = (bot = x \\<sqinter> y\\<^sup>T)", "using conv_dist_inf conv_bot"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n  symmetric bot\n\ngoal (1 subgoal):\n 1. (bot = x\\<^sup>T \\<sqinter> y) = (bot = x \\<sqinter> y\\<^sup>T)", "by fastforce"], ["", "lemma conv_one [simp]:\n  \"1\\<^sup>T = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (1::'a)", "by (metis comp_left_one conv_dist_comp conv_involutive)"], ["", "lemma comp_left_dist_sup:\n  \"(x * y) \\<squnion> (x * z) = x * (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<squnion> x * z = x * (y \\<squnion> z)", "by (metis comp_right_dist_sup conv_involutive conv_dist_sup conv_dist_comp)"], ["", "lemma comp_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y", "by (simp add: comp_left_dist_sup sup.absorb_iff1)"], ["", "lemma comp_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * z \\<le> y * z", "by (metis comp_right_dist_sup le_iff_sup)"], ["", "lemma comp_isotone:\n  \"x \\<le> y \\<Longrightarrow> w \\<le> z \\<Longrightarrow> x * w \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; w \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x * w \\<le> y * z", "using comp_left_isotone comp_right_isotone order.trans"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<le> y; w \\<le> z\\<rbrakk>\n    \\<Longrightarrow> x * w \\<le> y * z", "by blast"], ["", "lemma comp_left_subdist_inf:\n  \"(x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * z \\<le> x * z \\<sqinter> y * z", "by (simp add: comp_left_isotone)"], ["", "lemma comp_left_increasing_sup:\n  \"x * y \\<le> (x \\<squnion> z) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> (x \\<squnion> z) * y", "by (simp add: comp_left_isotone)"], ["", "lemma comp_right_subdist_inf:\n  \"x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z", "by (simp add: comp_right_isotone)"], ["", "lemma comp_right_increasing_sup:\n  \"x * y \\<le> x * (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> x * (y \\<squnion> z)", "by (simp add: comp_right_isotone)"], ["", "lemma comp_right_zero [simp]:\n  \"x * bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot = bot", "by (metis comp_left_zero conv_dist_comp conv_involutive)"], ["", "lemma comp_right_one [simp]:\n  \"x * 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) = x", "by (metis comp_left_one conv_dist_comp conv_involutive)"], ["", "lemma comp_left_conjugate:\n  \"conjugate (\\<lambda>y . x * y) (\\<lambda>y . x\\<^sup>T * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate ((*) x) ((*) (x\\<^sup>T))", "apply (unfold conjugate_def, intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (x * xa \\<sqinter> y = bot) = (xa \\<sqinter> x\\<^sup>T * y = bot)", "by (metis comp_right_zero bot.extremum_unique conv_involutive dedekind_1 inf.commute)"], ["", "lemma comp_right_conjugate:\n  \"conjugate (\\<lambda>y . y * x) (\\<lambda>y . y * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. conjugate (\\<lambda>y. y * x) (\\<lambda>y. y * x\\<^sup>T)", "apply (unfold conjugate_def, intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       (xa * x \\<sqinter> y = bot) = (xa \\<sqinter> y * x\\<^sup>T = bot)", "by (metis comp_left_conjugate[unfolded conjugate_def] conv_inf_bot_iff conv_dist_comp conv_involutive)"], ["", "text \\<open>\nWe still obtain a semiring structure.\n\\<close>"], ["", "subclass bounded_idempotent_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.bounded_idempotent_semiring top (1::'a) (*) (\\<squnion>) (\\<le>)\n     (<) bot", "by (unfold_locales)\n  (auto simp: comp_right_isotone comp_right_dist_sup comp_associative comp_left_dist_sup)"], ["", "sublocale inf: semiring_0 sup bot inf"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_0 (\\<squnion>) bot (\\<sqinter>)", "by (unfold_locales, auto simp: inf_sup_distrib2 inf_sup_distrib1 inf_assoc)"], ["", "lemma schroeder_1:\n  \"x * y \\<sqinter> z = bot \\<longleftrightarrow> x\\<^sup>T * z \\<sqinter> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<sqinter> z = bot) = (x\\<^sup>T * z \\<sqinter> y = bot)", "using abel_semigroup.commute comp_left_conjugate conjugate_def inf.abel_semigroup_axioms"], ["proof (prove)\nusing this:\n  abel_semigroup ?f \\<Longrightarrow> ?f ?a ?b = ?f ?b ?a\n  conjugate ((*) ?x) ((*) (?x\\<^sup>T))\n  conjugate ?f ?g \\<equiv>\n  \\<forall>x y. (?f x \\<sqinter> y = bot) = (x \\<sqinter> ?g y = bot)\n  abel_semigroup (\\<sqinter>)\n\ngoal (1 subgoal):\n 1. (x * y \\<sqinter> z = bot) = (x\\<^sup>T * z \\<sqinter> y = bot)", "by fastforce"], ["", "lemma schroeder_2:\n  \"x * y \\<sqinter> z = bot \\<longleftrightarrow> z * y\\<^sup>T \\<sqinter> x = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<sqinter> z = bot) = (z * y\\<^sup>T \\<sqinter> x = bot)", "by (metis comp_right_conjugate conjugate_def inf_commute)"], ["", "lemma comp_additive:\n  \"additive (\\<lambda>y . x * y) \\<and> additive (\\<lambda>y . x\\<^sup>T * y) \\<and> additive (\\<lambda>y . y * x) \\<and> additive (\\<lambda>y . y * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. additive ((*) x) \\<and>\n    additive ((*) (x\\<^sup>T)) \\<and>\n    additive (\\<lambda>y. y * x) \\<and> additive (\\<lambda>y. y * x\\<^sup>T)", "by (simp add: comp_left_dist_sup additive_def comp_right_dist_sup)"], ["", "lemma dedekind_2:\n  \"y * x \\<sqinter> z \\<le> (y \\<sqinter> (z * x\\<^sup>T)) * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * x \\<sqinter> z \\<le> (y \\<sqinter> z * x\\<^sup>T) * x", "by (metis conv_dist_inf conv_order conv_dist_comp dedekind_1)"], ["", "text \\<open>\nThe intersection with a vector can still be exported from the first argument of a composition, and many other properties of vectors and covectors continue to hold.\n\\<close>"], ["", "lemma vector_inf_comp:\n  \"vector x \\<Longrightarrow> (x \\<sqinter> y) * z = x \\<sqinter> (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> (x \\<sqinter> y) * z = x \\<sqinter> y * z", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. vector x \\<Longrightarrow> (x \\<sqinter> y) * z \\<le> x \\<sqinter> y * z\n 2. vector x \\<Longrightarrow> x \\<sqinter> y * z \\<le> (x \\<sqinter> y) * z", "apply (metis comp_left_subdist_inf comp_right_isotone inf.sup_left_isotone order_lesseq_imp top_greatest)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> x \\<sqinter> y * z \\<le> (x \\<sqinter> y) * z", "by (metis comp_left_isotone comp_right_isotone dedekind_2 inf_commute inf_mono order_refl order_trans top_greatest)"], ["", "lemma vector_inf_closed:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector x; vector y\\<rbrakk>\n    \\<Longrightarrow> vector (x \\<sqinter> y)", "by (simp add: vector_inf_comp)"], ["", "lemma vector_inf_one_comp:\n  \"vector x \\<Longrightarrow> (x \\<sqinter> 1) * y = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> (x \\<sqinter> (1::'a)) * y = x \\<sqinter> y", "by (simp add: vector_inf_comp)"], ["", "lemma covector_inf_comp_1:\n  assumes \"vector x\"\n    shows \"(y \\<sqinter> x\\<^sup>T) * z = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "have \"(y \\<sqinter> x\\<^sup>T) * z \\<le> (y \\<sqinter> x\\<^sup>T) * (z \\<sqinter> ((y\\<^sup>T \\<sqinter> x) * top))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z\n    \\<le> (y \\<sqinter> x\\<^sup>T) *\n          (z \\<sqinter> (y\\<^sup>T \\<sqinter> x) * top)", "by (metis inf_top_right dedekind_1 conv_dist_inf conv_involutive)"], ["proof (state)\nthis:\n  (y \\<sqinter> x\\<^sup>T) * z\n  \\<le> (y \\<sqinter> x\\<^sup>T) *\n        (z \\<sqinter> (y\\<^sup>T \\<sqinter> x) * top)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "also"], ["proof (state)\nthis:\n  (y \\<sqinter> x\\<^sup>T) * z\n  \\<le> (y \\<sqinter> x\\<^sup>T) *\n        (z \\<sqinter> (y\\<^sup>T \\<sqinter> x) * top)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "have \"... \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * (z \\<sqinter> (y\\<^sup>T \\<sqinter> x) * top)\n    \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "by (metis assms comp_left_isotone comp_right_isotone inf_le2 inf_mono order_refl inf_commute)"], ["proof (state)\nthis:\n  (y \\<sqinter> x\\<^sup>T) * (z \\<sqinter> (y\\<^sup>T \\<sqinter> x) * top)\n  \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "finally"], ["proof (chain)\npicking this:\n  (y \\<sqinter> x\\<^sup>T) * z\n  \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "show ?thesis"], ["proof (prove)\nusing this:\n  (y \\<sqinter> x\\<^sup>T) * z\n  \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. (y \\<sqinter> x\\<^sup>T) * z =\n    (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "by (simp add: comp_right_isotone antisym)"], ["proof (state)\nthis:\n  (y \\<sqinter> x\\<^sup>T) * z = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma covector_inf_comp_2:\n  assumes \"vector x\"\n    shows \"y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "have \"y * (x \\<sqinter> z) \\<le> (y \\<sqinter> (top * (x \\<sqinter> z)\\<^sup>T)) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z)\n    \\<le> (y \\<sqinter> top * (x \\<sqinter> z)\\<^sup>T) * (x \\<sqinter> z)", "by (metis dedekind_2 inf_top_right)"], ["proof (state)\nthis:\n  y * (x \\<sqinter> z)\n  \\<le> (y \\<sqinter> top * (x \\<sqinter> z)\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "also"], ["proof (state)\nthis:\n  y * (x \\<sqinter> z)\n  \\<le> (y \\<sqinter> top * (x \\<sqinter> z)\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "have \"... \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y \\<sqinter> top * (x \\<sqinter> z)\\<^sup>T) * (x \\<sqinter> z)\n    \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "by (metis assms comp_left_isotone conv_dist_comp conv_order conv_top eq_refl inf_le1 inf_mono)"], ["proof (state)\nthis:\n  (y \\<sqinter> top * (x \\<sqinter> z)\\<^sup>T) * (x \\<sqinter> z)\n  \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "finally"], ["proof (chain)\npicking this:\n  y * (x \\<sqinter> z) \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "show ?thesis"], ["proof (prove)\nusing this:\n  y * (x \\<sqinter> z) \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "using comp_left_subdist_inf antisym"], ["proof (prove)\nusing this:\n  y * (x \\<sqinter> z) \\<le> (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n  (?x \\<sqinter> ?y) * ?z \\<le> ?x * ?z \\<sqinter> ?y * ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n\ngoal (1 subgoal):\n 1. y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)", "by auto"], ["proof (state)\nthis:\n  y * (x \\<sqinter> z) = (y \\<sqinter> x\\<^sup>T) * (x \\<sqinter> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma covector_inf_comp_3:\n  \"vector x \\<Longrightarrow> (y \\<sqinter> x\\<^sup>T) * z = y * (x \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow>\n    (y \\<sqinter> x\\<^sup>T) * z = y * (x \\<sqinter> z)", "by (metis covector_inf_comp_1 covector_inf_comp_2)"], ["", "lemma covector_inf_closed:\n  \"covector x \\<Longrightarrow> covector y \\<Longrightarrow> covector (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>covector x; covector y\\<rbrakk>\n    \\<Longrightarrow> covector (x \\<sqinter> y)", "by (metis comp_right_subdist_inf inf.antisym top_left_mult_increasing)"], ["", "lemma vector_conv_covector:\n  \"vector v \\<longleftrightarrow> covector (v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v = covector (v\\<^sup>T)", "by (metis conv_dist_comp conv_involutive conv_top)"], ["", "lemma covector_conv_vector:\n  \"covector v \\<longleftrightarrow> vector (v\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector v = vector (v\\<^sup>T)", "by (simp add: vector_conv_covector)"], ["", "lemma covector_comp_inf:\n  \"covector z \\<Longrightarrow> x * (y \\<sqinter> z) = x * y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector z \\<Longrightarrow> x * (y \\<sqinter> z) = x * y \\<sqinter> z", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. covector z \\<Longrightarrow>\n    x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> z\n 2. covector z \\<Longrightarrow>\n    x * y \\<sqinter> z \\<le> x * (y \\<sqinter> z)", "apply (metis comp_isotone comp_right_subdist_inf inf.boundedE inf.boundedI inf.cobounded2 top.extremum)"], ["proof (prove)\ngoal (1 subgoal):\n 1. covector z \\<Longrightarrow>\n    x * y \\<sqinter> z \\<le> x * (y \\<sqinter> z)", "by (metis comp_left_isotone comp_right_isotone dedekind_1 inf_commute inf_mono order_refl order_trans top_greatest)"], ["", "lemma vector_restrict_comp_conv:\n  \"vector x \\<Longrightarrow> x \\<sqinter> y \\<le> x\\<^sup>T * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> x \\<sqinter> y \\<le> x\\<^sup>T * y", "by (metis covector_inf_comp_3 eq_refl inf.sup_monoid.add_commute inf_top_right le_supE sup.orderE top_left_mult_increasing)"], ["", "lemma covector_restrict_comp_conv:\n  \"covector x \\<Longrightarrow> y \\<sqinter> x \\<le> y * x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow> y \\<sqinter> x \\<le> y * x\\<^sup>T", "by (metis conv_dist_comp conv_dist_inf conv_order conv_top inf.sup_monoid.add_commute vector_restrict_comp_conv)"], ["", "lemma covector_comp_inf_1:\n  \"covector x \\<Longrightarrow> (y \\<sqinter> x) * z = y * (x\\<^sup>T \\<sqinter> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow>\n    (y \\<sqinter> x) * z = y * (x\\<^sup>T \\<sqinter> z)", "using covector_conv_vector covector_inf_comp_3"], ["proof (prove)\nusing this:\n  covector ?v = vector (?v\\<^sup>T)\n  vector ?x \\<Longrightarrow>\n  (?y \\<sqinter> ?x\\<^sup>T) * ?z = ?y * (?x \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow>\n    (y \\<sqinter> x) * z = y * (x\\<^sup>T \\<sqinter> z)", "by fastforce"], ["", "text \\<open>\nWe still have two ways to represent surjectivity and totality.\n\\<close>"], ["", "lemma surjective_var:\n  \"surjective x \\<longleftrightarrow> surjective_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x = surjective_var x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. surjective x \\<Longrightarrow> surjective_var x\n 2. surjective_var x \\<Longrightarrow> surjective x", "assume \"surjective x\""], ["proof (state)\nthis:\n  surjective x\n\ngoal (2 subgoals):\n 1. surjective x \\<Longrightarrow> surjective_var x\n 2. surjective_var x \\<Longrightarrow> surjective x", "thus \"surjective_var x\""], ["proof (prove)\nusing this:\n  surjective x\n\ngoal (1 subgoal):\n 1. surjective_var x", "by (metis dedekind_2 comp_left_one inf_absorb2 top_greatest)"], ["proof (state)\nthis:\n  surjective_var x\n\ngoal (1 subgoal):\n 1. surjective_var x \\<Longrightarrow> surjective x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. surjective_var x \\<Longrightarrow> surjective x", "assume \"surjective_var x\""], ["proof (state)\nthis:\n  surjective_var x\n\ngoal (1 subgoal):\n 1. surjective_var x \\<Longrightarrow> surjective x", "hence \"x\\<^sup>T * (x * top) = top\""], ["proof (prove)\nusing this:\n  surjective_var x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T * (x * top) = top", "by (metis comp_left_isotone comp_associative comp_left_one top_le)"], ["proof (state)\nthis:\n  x\\<^sup>T * (x * top) = top\n\ngoal (1 subgoal):\n 1. surjective_var x \\<Longrightarrow> surjective x", "thus \"surjective x\""], ["proof (prove)\nusing this:\n  x\\<^sup>T * (x * top) = top\n\ngoal (1 subgoal):\n 1. surjective x", "by (metis comp_right_isotone conv_top conv_dist_comp conv_involutive top_greatest top_le)"], ["proof (state)\nthis:\n  surjective x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma total_var:\n  \"total x \\<longleftrightarrow> total_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total x = total_var x", "by (metis conv_top conv_dist_comp conv_involutive surjective_var)"], ["", "lemma surjective_conv_total:\n  \"surjective x \\<longleftrightarrow> total (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x = times_top_class.total (x\\<^sup>T)", "by (metis conv_top conv_dist_comp conv_involutive)"], ["", "lemma total_conv_surjective:\n  \"total x \\<longleftrightarrow> surjective (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total x = surjective (x\\<^sup>T)", "by (simp add: surjective_conv_total)"], ["", "lemma injective_conv_univalent:\n  \"injective x \\<longleftrightarrow> univalent (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective x = univalent (x\\<^sup>T)", "by simp"], ["", "lemma univalent_conv_injective:\n  \"univalent x \\<longleftrightarrow> injective (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent x = injective (x\\<^sup>T)", "by simp"], ["", "text \\<open>\nWe continue with studying further closure properties.\n\\<close>"], ["", "lemma univalent_bot_closed:\n  \"univalent bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent bot", "by simp"], ["", "lemma univalent_one_closed:\n  \"univalent 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent (1::'a)", "by simp"], ["", "lemma univalent_inf_closed:\n  \"univalent x \\<Longrightarrow> univalent (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent x \\<Longrightarrow> univalent (x \\<sqinter> y)", "by (metis comp_left_subdist_inf comp_right_subdist_inf conv_dist_inf inf.cobounded1 order_lesseq_imp)"], ["", "lemma univalent_mult_closed:\n  assumes \"univalent x\"\n      and \"univalent y\"\n    shows \"univalent (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent (x * y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. univalent (x * y)", "have \"(x * y)\\<^sup>T * x \\<le> y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y)\\<^sup>T * x \\<le> y\\<^sup>T", "by (metis assms(1) comp_left_isotone comp_right_one conv_one conv_order comp_associative conv_dist_comp conv_involutive)"], ["proof (state)\nthis:\n  (x * y)\\<^sup>T * x \\<le> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. univalent (x * y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (x * y)\\<^sup>T * x \\<le> y\\<^sup>T\n\ngoal (1 subgoal):\n 1. univalent (x * y)", "by (metis assms(2) comp_left_isotone comp_associative dual_order.trans)"], ["proof (state)\nthis:\n  univalent (x * y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injective_bot_closed:\n  \"injective bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective bot", "by simp"], ["", "lemma injective_one_closed:\n  \"injective 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (1::'a)", "by simp"], ["", "lemma injective_inf_closed:\n  \"injective x \\<Longrightarrow> injective (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective x \\<Longrightarrow> injective (x \\<sqinter> y)", "by (metis conv_dist_inf injective_conv_univalent univalent_inf_closed)"], ["", "lemma injective_mult_closed:\n  \"injective x \\<Longrightarrow> injective y \\<Longrightarrow> injective (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>injective x; injective y\\<rbrakk>\n    \\<Longrightarrow> injective (x * y)", "by (metis injective_conv_univalent conv_dist_comp univalent_mult_closed)"], ["", "lemma mapping_one_closed:\n  \"mapping 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping (1::'a)", "by simp"], ["", "lemma mapping_mult_closed:\n  \"mapping x \\<Longrightarrow> mapping y \\<Longrightarrow> mapping (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mapping x; mapping y\\<rbrakk> \\<Longrightarrow> mapping (x * y)", "by (simp add: comp_associative univalent_mult_closed)"], ["", "lemma bijective_one_closed:\n  \"bijective 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective (1::'a)", "by simp"], ["", "lemma bijective_mult_closed:\n  \"bijective x \\<Longrightarrow> bijective y \\<Longrightarrow> bijective (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>bijective x; bijective y\\<rbrakk>\n    \\<Longrightarrow> bijective (x * y)", "by (metis injective_mult_closed comp_associative)"], ["", "lemma bijective_conv_mapping:\n  \"bijective x \\<longleftrightarrow> mapping (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective x = mapping (x\\<^sup>T)", "by (simp add: surjective_conv_total)"], ["", "lemma mapping_conv_bijective:\n  \"mapping x \\<longleftrightarrow> bijective (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping x = bijective (x\\<^sup>T)", "by (simp add: total_conv_surjective)"], ["", "lemma reflexive_inf_closed:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x \\<sqinter> y)", "by simp"], ["", "lemma reflexive_conv_closed:\n  \"reflexive x \\<Longrightarrow> reflexive (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> reflexive (x\\<^sup>T)", "using conv_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> reflexive (x\\<^sup>T)", "by force"], ["", "lemma coreflexive_inf_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> coreflexive (x \\<sqinter> y)", "by (simp add: le_infI1)"], ["", "lemma coreflexive_conv_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> coreflexive (x\\<^sup>T)", "using conv_order"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> coreflexive (x\\<^sup>T)", "by force"], ["", "lemma coreflexive_symmetric:\n  \"coreflexive x \\<Longrightarrow> symmetric x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> symmetric x", "by (metis comp_right_one comp_right_subdist_inf conv_dist_inf conv_dist_comp conv_involutive dedekind_1 inf.absorb1 inf_absorb2)"], ["", "lemma transitive_inf_closed:\n  \"transitive x \\<Longrightarrow> transitive y \\<Longrightarrow> transitive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>transitive x; transitive y\\<rbrakk>\n    \\<Longrightarrow> transitive (x \\<sqinter> y)", "by (meson comp_left_subdist_inf inf.cobounded1 inf.sup_mono inf_le2 mult_right_isotone order.trans)"], ["", "lemma transitive_conv_closed:\n  \"transitive x \\<Longrightarrow> transitive (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> transitive (x\\<^sup>T)", "using conv_order conv_dist_comp"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. transitive x \\<Longrightarrow> transitive (x\\<^sup>T)", "by fastforce"], ["", "lemma dense_conv_closed:\n  \"dense_rel x \\<Longrightarrow> dense_rel (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel x \\<Longrightarrow> dense_rel (x\\<^sup>T)", "using conv_order conv_dist_comp"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. dense_rel x \\<Longrightarrow> dense_rel (x\\<^sup>T)", "by fastforce"], ["", "lemma idempotent_conv_closed:\n  \"idempotent x \\<Longrightarrow> idempotent (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent x \\<Longrightarrow> idempotent (x\\<^sup>T)", "by (metis conv_dist_comp)"], ["", "lemma preorder_inf_closed:\n  \"preorder x \\<Longrightarrow> preorder y \\<Longrightarrow> preorder (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>preorder x; preorder y\\<rbrakk>\n    \\<Longrightarrow> preorder (x \\<sqinter> y)", "using transitive_inf_closed"], ["proof (prove)\nusing this:\n  \\<lbrakk>transitive ?x; transitive ?y\\<rbrakk>\n  \\<Longrightarrow> transitive (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>preorder x; preorder y\\<rbrakk>\n    \\<Longrightarrow> preorder (x \\<sqinter> y)", "by auto"], ["", "lemma preorder_conv_closed:\n  \"preorder x \\<Longrightarrow> preorder (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder x \\<Longrightarrow> preorder (x\\<^sup>T)", "by (simp add: reflexive_conv_closed transitive_conv_closed)"], ["", "lemma symmetric_bot_closed:\n  \"symmetric bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric bot", "by simp"], ["", "lemma symmetric_one_closed:\n  \"symmetric 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (1::'a)", "by simp"], ["", "lemma symmetric_top_closed:\n  \"symmetric top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric top", "by simp"], ["", "lemma symmetric_inf_closed:\n  \"symmetric x \\<Longrightarrow> symmetric y \\<Longrightarrow> symmetric (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; symmetric y\\<rbrakk>\n    \\<Longrightarrow> symmetric (x \\<sqinter> y)", "by (simp add: conv_dist_inf)"], ["", "lemma symmetric_sup_closed:\n  \"symmetric x \\<Longrightarrow> symmetric y \\<Longrightarrow> symmetric (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>symmetric x; symmetric y\\<rbrakk>\n    \\<Longrightarrow> symmetric (x \\<squnion> y)", "by (simp add: conv_dist_sup)"], ["", "lemma symmetric_conv_closed:\n  \"symmetric x \\<Longrightarrow> symmetric (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> symmetric (x\\<^sup>T)", "by simp"], ["", "lemma one_inf_conv:\n  \"1 \\<sqinter> x = 1 \\<sqinter> x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (1::'a) \\<sqinter> x = (1::'a) \\<sqinter> x\\<^sup>T", "by (metis conv_dist_inf coreflexive_symmetric inf.cobounded1 symmetric_one_closed)"], ["", "lemma antisymmetric_bot_closed:\n  \"antisymmetric bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric bot", "by simp"], ["", "lemma antisymmetric_one_closed:\n  \"antisymmetric 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric (1::'a)", "by simp"], ["", "lemma antisymmetric_inf_closed:\n  \"antisymmetric x \\<Longrightarrow> antisymmetric (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric x \\<Longrightarrow> antisymmetric (x \\<sqinter> y)", "by (rule order_trans[where y=\"x \\<sqinter> x\\<^sup>T\"]) (simp_all add: conv_isotone inf.coboundedI2 inf.sup_assoc)"], ["", "lemma antisymmetric_conv_closed:\n  \"antisymmetric x \\<Longrightarrow> antisymmetric (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric x \\<Longrightarrow> antisymmetric (x\\<^sup>T)", "by (simp add: inf_commute)"], ["", "lemma asymmetric_bot_closed:\n  \"asymmetric bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric bot", "by simp"], ["", "lemma asymmetric_inf_closed:\n  \"asymmetric x \\<Longrightarrow> asymmetric (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<Longrightarrow> asymmetric (x \\<sqinter> y)", "by (metis conv_dist_inf inf.mult_zero_left inf.left_commute inf_assoc)"], ["", "lemma asymmetric_conv_closed:\n  \"asymmetric x \\<Longrightarrow> asymmetric (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<Longrightarrow> asymmetric (x\\<^sup>T)", "by (simp add: inf_commute)"], ["", "lemma linear_top_closed:\n  \"linear top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear top", "by simp"], ["", "lemma linear_sup_closed:\n  \"linear x \\<Longrightarrow> linear (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear x \\<Longrightarrow> linear (x \\<squnion> y)", "by (metis conv_dist_sup sup_assoc sup_commute sup_top_right)"], ["", "lemma linear_reflexive:\n  \"linear x \\<Longrightarrow> reflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear x \\<Longrightarrow> reflexive x", "by (metis one_inf_conv inf.distrib_left inf.cobounded2 inf.orderE reflexive_top_closed sup.idem)"], ["", "lemma linear_conv_closed:\n  \"linear x \\<Longrightarrow> linear (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear x \\<Longrightarrow> linear (x\\<^sup>T)", "by (simp add: sup_commute)"], ["", "lemma linear_comp_closed:\n  assumes \"linear x\"\n      and \"linear y\"\n    shows \"linear (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear (x * y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. linear (x * y)", "have \"reflexive y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive y", "by (simp add: assms(2) linear_reflexive)"], ["proof (state)\nthis:\n  reflexive y\n\ngoal (1 subgoal):\n 1. linear (x * y)", "hence \"x \\<squnion> x\\<^sup>T \\<le> x * y \\<squnion> y\\<^sup>T * x\\<^sup>T\""], ["proof (prove)\nusing this:\n  reflexive y\n\ngoal (1 subgoal):\n 1. x \\<squnion> x\\<^sup>T \\<le> x * y \\<squnion> y\\<^sup>T * x\\<^sup>T", "by (metis case_split_left case_split_right le_supI sup.cobounded1 sup.cobounded2 sup.idem reflexive_conv_closed)"], ["proof (state)\nthis:\n  x \\<squnion> x\\<^sup>T \\<le> x * y \\<squnion> y\\<^sup>T * x\\<^sup>T\n\ngoal (1 subgoal):\n 1. linear (x * y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<squnion> x\\<^sup>T \\<le> x * y \\<squnion> y\\<^sup>T * x\\<^sup>T\n\ngoal (1 subgoal):\n 1. linear (x * y)", "by (simp add: assms(1) conv_dist_comp top_le)"], ["proof (state)\nthis:\n  linear (x * y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma equivalence_one_closed:\n  \"equivalence 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coreflexive (1::'a) \\<and> transitive (1::'a)) \\<and> symmetric (1::'a)", "by simp"], ["", "lemma equivalence_top_closed:\n  \"equivalence top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence top", "by simp"], ["", "lemma equivalence_inf_closed:\n  \"equivalence x \\<Longrightarrow> equivalence y \\<Longrightarrow> equivalence (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>equivalence x; equivalence y\\<rbrakk>\n    \\<Longrightarrow> equivalence (x \\<sqinter> y)", "using conv_dist_inf preorder_inf_closed"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n  \\<lbrakk>preorder ?x; preorder ?y\\<rbrakk>\n  \\<Longrightarrow> preorder (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>equivalence x; equivalence y\\<rbrakk>\n    \\<Longrightarrow> equivalence (x \\<sqinter> y)", "by auto"], ["", "lemma equivalence_conv_closed:\n  \"equivalence x \\<Longrightarrow> equivalence (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow> equivalence (x\\<^sup>T)", "by simp"], ["", "lemma order_one_closed:\n  \"order 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (coreflexive (1::'a) \\<and> transitive (1::'a)) \\<and>\n    antisymmetric (1::'a)", "by simp"], ["", "lemma order_inf_closed:\n  \"order x \\<Longrightarrow> order y \\<Longrightarrow> order (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>order x; order y\\<rbrakk>\n    \\<Longrightarrow> order (x \\<sqinter> y)", "using antisymmetric_inf_closed transitive_inf_closed"], ["proof (prove)\nusing this:\n  antisymmetric ?x \\<Longrightarrow> antisymmetric (?x \\<sqinter> ?y)\n  \\<lbrakk>transitive ?x; transitive ?y\\<rbrakk>\n  \\<Longrightarrow> transitive (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>order x; order y\\<rbrakk>\n    \\<Longrightarrow> order (x \\<sqinter> y)", "by auto"], ["", "lemma order_conv_closed:\n  \"order x \\<Longrightarrow> order (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order x \\<Longrightarrow> order (x\\<^sup>T)", "by (simp add: inf_commute reflexive_conv_closed transitive_conv_closed)"], ["", "lemma linear_order_conv_closed:\n  \"linear_order x \\<Longrightarrow> linear_order (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    bounded_distrib_allegory_signature_class.linear_order (x\\<^sup>T)", "using equivalence_top_closed conv_dist_sup inf_commute reflexive_conv_closed transitive_conv_closed"], ["proof (prove)\nusing this:\n  equivalence top\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  reflexive ?x \\<Longrightarrow> reflexive (?x\\<^sup>T)\n  transitive ?x \\<Longrightarrow> transitive (?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    bounded_distrib_allegory_signature_class.linear_order (x\\<^sup>T)", "by force"], ["", "text \\<open>\nWe show a fact about equivalences.\n\\<close>"], ["", "lemma equivalence_comp_dist_inf:\n  \"equivalence x \\<Longrightarrow> x * y \\<sqinter> x * z = x * (y \\<sqinter> x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow>\n    x * y \\<sqinter> x * z = x * (y \\<sqinter> x * z)", "by (metis antisym comp_right_subdist_inf dedekind_1 eq_iff inf.absorb1 inf.absorb2 mult_1_right mult_assoc)"], ["", "text \\<open>\nThe following result generalises the fact that composition with a test amounts to intersection with the corresponding vector.\nBoth tests and vectors can be used to represent sets as relations.\n\\<close>"], ["", "lemma coreflexive_comp_top_inf:\n  \"coreflexive x \\<Longrightarrow> x * top \\<sqinter> y = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x * top \\<sqinter> y = x * y", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. coreflexive x \\<Longrightarrow> x * top \\<sqinter> y \\<le> x * y\n 2. coreflexive x \\<Longrightarrow> x * y \\<le> x * top \\<sqinter> y", "apply (metis comp_left_isotone comp_left_one coreflexive_symmetric dedekind_1 inf_top_left order_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x * y \\<le> x * top \\<sqinter> y", "using comp_left_isotone comp_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x * y \\<le> x * top \\<sqinter> y", "by fastforce"], ["", "lemma coreflexive_comp_top_inf_one:\n  \"coreflexive x \\<Longrightarrow> x * top \\<sqinter> 1 = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> x * top \\<sqinter> (1::'a) = x", "by (simp add: coreflexive_comp_top_inf)"], ["", "lemma coreflexive_comp_inf:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> x * y = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> x * y = x \\<sqinter> y", "by (metis (full_types) coreflexive_comp_top_inf coreflexive_comp_top_inf_one inf.mult_assoc inf.absorb2)"], ["", "lemma coreflexive_comp_inf_comp:\n  assumes \"coreflexive x\"\n      and \"coreflexive y\"\n    shows \"(x * z) \\<sqinter> (y * z) = (x \\<sqinter> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "have \"(x * z) \\<sqinter> (y * z) = x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z =\n    x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z", "using assms coreflexive_comp_top_inf inf_assoc"], ["proof (prove)\nusing this:\n  coreflexive x\n  coreflexive y\n  coreflexive ?x \\<Longrightarrow> ?x * top \\<sqinter> ?y = ?x * ?y\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z =\n    x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z", "by auto"], ["proof (state)\nthis:\n  x * z \\<sqinter> y * z =\n  x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "also"], ["proof (state)\nthis:\n  x * z \\<sqinter> y * z =\n  x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "have \"... = x * top \\<sqinter> y * top \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z =\n    x * top \\<sqinter> y * top \\<sqinter> z", "by (simp add: inf.commute inf.left_commute)"], ["proof (state)\nthis:\n  x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z =\n  x * top \\<sqinter> y * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter> z \\<sqinter> y * top \\<sqinter> z =\n  x * top \\<sqinter> y * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "have \"... = (x \\<sqinter> y) * top \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> y * top \\<sqinter> z =\n    (x \\<sqinter> y) * top \\<sqinter> z", "by (metis assms coreflexive_comp_inf coreflexive_comp_top_inf mult_assoc)"], ["proof (state)\nthis:\n  x * top \\<sqinter> y * top \\<sqinter> z =\n  (x \\<sqinter> y) * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter> y * top \\<sqinter> z =\n  (x \\<sqinter> y) * top \\<sqinter> z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "have \"... = (x \\<sqinter> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y) * top \\<sqinter> z = (x \\<sqinter> y) * z", "by (simp add: assms(1) coreflexive_comp_top_inf coreflexive_inf_closed)"], ["proof (state)\nthis:\n  (x \\<sqinter> y) * top \\<sqinter> z = (x \\<sqinter> y) * z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "finally"], ["proof (chain)\npicking this:\n  x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "show ?thesis"], ["proof (prove)\nusing this:\n  x * z \\<sqinter> y * z = (x \\<sqinter> y) * z\n\ngoal (1 subgoal):\n 1. x * z \\<sqinter> y * z = (x \\<sqinter> y) * z", "."], ["proof (state)\nthis:\n  x * z \\<sqinter> y * z = (x \\<sqinter> y) * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma test_comp_test_inf:\n  \"(x \\<sqinter> 1) * y * (z \\<sqinter> 1) = (x \\<sqinter> 1) * y \\<sqinter> y * (z \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a)) =\n    (x \\<sqinter> (1::'a)) * y \\<sqinter> y * (z \\<sqinter> (1::'a))", "by (smt comp_right_one comp_right_subdist_inf coreflexive_comp_top_inf inf.left_commute inf.orderE inf_le2 mult_assoc)"], ["", "lemma test_comp_test_top:\n  \"y \\<sqinter> (x \\<sqinter> 1) * top * (z \\<sqinter> 1) = (x \\<sqinter> 1) * y * (z \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> (1::'a)) * top * (z \\<sqinter> (1::'a)) =\n    (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> (1::'a)) * top * (z \\<sqinter> (1::'a)) =\n    (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a))", "have \"\\<forall>u v . (v \\<sqinter> u\\<^sup>T)\\<^sup>T = v\\<^sup>T \\<sqinter> u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u v. (v \\<sqinter> u\\<^sup>T)\\<^sup>T = v\\<^sup>T \\<sqinter> u", "using conv_dist_inf"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<forall>u v. (v \\<sqinter> u\\<^sup>T)\\<^sup>T = v\\<^sup>T \\<sqinter> u", "by auto"], ["proof (state)\nthis:\n  \\<forall>u v. (v \\<sqinter> u\\<^sup>T)\\<^sup>T = v\\<^sup>T \\<sqinter> u\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> (1::'a)) * top * (z \\<sqinter> (1::'a)) =\n    (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>u v. (v \\<sqinter> u\\<^sup>T)\\<^sup>T = v\\<^sup>T \\<sqinter> u\n\ngoal (1 subgoal):\n 1. y \\<sqinter> (x \\<sqinter> (1::'a)) * top * (z \\<sqinter> (1::'a)) =\n    (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a))", "by (smt conv_dist_comp conv_involutive coreflexive_comp_top_inf inf.cobounded2 inf.left_commute inf.sup_monoid.add_commute symmetric_one_closed mult_assoc symmetric_top_closed)"], ["proof (state)\nthis:\n  y \\<sqinter> (x \\<sqinter> (1::'a)) * top * (z \\<sqinter> (1::'a)) =\n  (x \\<sqinter> (1::'a)) * y * (z \\<sqinter> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coreflexive_idempotent:\n  \"coreflexive x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> idempotent x", "by (simp add: coreflexive_comp_inf)"], ["", "lemma coreflexive_univalent:\n  \"coreflexive x \\<Longrightarrow> univalent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> univalent x", "by (simp add: coreflexive_idempotent coreflexive_symmetric)"], ["", "lemma coreflexive_injective:\n  \"coreflexive x \\<Longrightarrow> injective x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> injective x", "by (simp add: coreflexive_idempotent coreflexive_symmetric)"], ["", "lemma coreflexive_commutative:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> x * y = y * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> x * y = y * x", "by (simp add: coreflexive_comp_inf inf.commute)"], ["", "lemma coreflexive_dedekind:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive z \\<Longrightarrow> x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y; coreflexive z\\<rbrakk>\n    \\<Longrightarrow> x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x * z)", "by (simp add: coreflexive_comp_inf inf.coboundedI1 inf.left_commute)"], ["", "text \\<open>\nAlso the equational version of the Dedekind rule continues to hold.\n\\<close>"], ["", "lemma dedekind_eq:\n  \"x * y \\<sqinter> z = (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> z =\n    (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "have \"x * y \\<sqinter> z \\<le> x * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z", "by (simp add: dedekind_1)"], ["proof (state)\nthis:\n  x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "also"], ["proof (state)\nthis:\n  x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "have \"... \\<le> (x \\<sqinter> (z * (y \\<sqinter> (x\\<^sup>T * z))\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> (x \\<sqinter> z * (y \\<sqinter> x\\<^sup>T * z)\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z", "by (simp add: dedekind_2)"], ["proof (state)\nthis:\n  x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n  \\<le> (x \\<sqinter> z * (y \\<sqinter> x\\<^sup>T * z)\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z\n\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "also"], ["proof (state)\nthis:\n  x * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n  \\<le> (x \\<sqinter> z * (y \\<sqinter> x\\<^sup>T * z)\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z\n\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "have \"... \\<le> (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z * (y \\<sqinter> x\\<^sup>T * z)\\<^sup>T) *\n    (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n    z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z", "by (metis comp_left_isotone comp_right_isotone inf_mono conv_order inf.cobounded1 order_refl)"], ["proof (state)\nthis:\n  (x \\<sqinter> z * (y \\<sqinter> x\\<^sup>T * z)\\<^sup>T) *\n  (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n  z\n  \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z\n\ngoal (2 subgoals):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z\n 2. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "finally"], ["proof (chain)\npicking this:\n  x * y \\<sqinter> z\n  \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z", "show \"x * y \\<sqinter> z \\<le> (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z\""], ["proof (prove)\nusing this:\n  x * y \\<sqinter> z\n  \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n          z", "."], ["proof (state)\nthis:\n  x * y \\<sqinter> z\n  \\<le> (x \\<sqinter> z * y\\<^sup>T) *\n        (y \\<sqinter> x\\<^sup>T * z) \\<sqinter>\n        z\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "show \"(x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z)) \\<sqinter> z \\<le> x * y \\<sqinter> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "using comp_isotone inf.sup_left_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n    \\<le> x * y \\<sqinter> z", "by auto"], ["proof (state)\nthis:\n  (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z) \\<sqinter> z\n  \\<le> x * y \\<sqinter> z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dedekind:\n  \"x * y \\<sqinter> z \\<le> (x \\<sqinter> (z * y\\<^sup>T)) * (y \\<sqinter> (x\\<^sup>T * z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> z\n    \\<le> (x \\<sqinter> z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * z)", "by (metis dedekind_eq inf.cobounded1)"], ["", "lemma vector_export_comp:\n  \"(x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z", "have \"vector (x * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector (x * top)", "by (simp add: comp_associative)"], ["proof (state)\nthis:\n  vector (x * top)\n\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z", "thus ?thesis"], ["proof (prove)\nusing this:\n  vector (x * top)\n\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z", "by (simp add: vector_inf_comp)"], ["proof (state)\nthis:\n  (x * top \\<sqinter> y) * z = x * top \\<sqinter> y * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma vector_export_comp_unit:\n  \"(x * top \\<sqinter> 1) * y = x * top \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * top \\<sqinter> (1::'a)) * y = x * top \\<sqinter> y", "by (simp add: vector_export_comp)"], ["", "text \\<open>\nWe solve a few exercises from \\cite{SchmidtStroehlein1993}.\n\\<close>"], ["", "lemma ex231a [simp]:\n  \"(1 \\<sqinter> x * x\\<^sup>T) * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) \\<sqinter> x * x\\<^sup>T) * x = x", "by (metis inf.cobounded1 inf.idem inf_right_idem comp_left_one conv_one coreflexive_comp_top_inf dedekind_eq)"], ["", "lemma ex231b [simp]:\n  \"x * (1 \\<sqinter> x\\<^sup>T * x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * ((1::'a) \\<sqinter> x\\<^sup>T * x) = x", "by (metis conv_dist_comp conv_dist_inf conv_involutive conv_one ex231a)"], ["", "lemma ex231c:\n  \"x \\<le> x * x\\<^sup>T * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * x\\<^sup>T * x", "by (metis comp_left_isotone ex231a inf_le2)"], ["", "lemma ex231d:\n  \"x \\<le> x * top * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * top * x", "by (metis comp_left_isotone comp_right_isotone top_greatest order_trans ex231c)"], ["", "lemma ex231e [simp]:\n  \"x * top * x * top = x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top * x * top = x * top", "by (metis ex231d antisym comp_associative mult_right_isotone top.extremum)"], ["", "lemma arc_injective:\n  \"arc x \\<Longrightarrow> injective x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> injective x", "by (metis conv_dist_inf conv_involutive inf.absorb2 top_right_mult_increasing univalent_inf_closed)"], ["", "lemma arc_conv_closed:\n  \"arc x \\<Longrightarrow> arc (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> arc (x\\<^sup>T)", "by simp"], ["", "lemma arc_univalent:\n  \"arc x \\<Longrightarrow> univalent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> univalent x", "using arc_conv_closed arc_injective univalent_conv_injective"], ["proof (prove)\nusing this:\n  arc ?x \\<Longrightarrow> arc (?x\\<^sup>T)\n  arc ?x \\<Longrightarrow> injective ?x\n  univalent ?x = injective (?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> univalent x", "by blast"], ["", "lemma injective_codomain:\n  assumes \"injective x\"\n  shows \"x * (x \\<sqinter> 1) = x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x \\<sqinter> (1::'a)) = x \\<sqinter> (1::'a)", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x * (x \\<sqinter> (1::'a)) \\<le> x \\<sqinter> (1::'a)\n 2. x \\<sqinter> (1::'a) \\<le> x * (x \\<sqinter> (1::'a))", "show \"x * (x \\<sqinter> 1) \\<le> x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (x \\<sqinter> (1::'a)) \\<le> x \\<sqinter> (1::'a)", "by (metis assms comp_right_one dual_order.trans inf.boundedI inf.cobounded1 inf.sup_monoid.add_commute mult_right_isotone one_inf_conv)"], ["proof (state)\nthis:\n  x * (x \\<sqinter> (1::'a)) \\<le> x \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<le> x * (x \\<sqinter> (1::'a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<le> x * (x \\<sqinter> (1::'a))", "show \"x \\<sqinter> 1 \\<le> x * (x \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) \\<le> x * (x \\<sqinter> (1::'a))", "by (metis coreflexive_idempotent inf.cobounded1 inf.cobounded2 mult_left_isotone)"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) \\<le> x * (x \\<sqinter> (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following result generalises \\cite[Exercise 2]{Oliveira2009}.\nIt is used to show that the while-loop preserves injectivity of the constructed tree.\n\\<close>"], ["", "lemma injective_sup:\n  assumes \"injective t\"\n      and \"e * t\\<^sup>T \\<le> 1\"\n      and \"injective e\"\n    shows \"injective (t \\<squnion> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (t \\<squnion> e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. injective (t \\<squnion> e)", "have \"(t \\<squnion> e) * (t \\<squnion> e)\\<^sup>T = t * t\\<^sup>T \\<squnion> t * e\\<^sup>T \\<squnion> e * t\\<^sup>T \\<squnion> e * e\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t \\<squnion> e) * (t \\<squnion> e)\\<^sup>T =\n    t * t\\<^sup>T \\<squnion> t * e\\<^sup>T \\<squnion>\n    e * t\\<^sup>T \\<squnion>\n    e * e\\<^sup>T", "by (simp add: comp_left_dist_sup conv_dist_sup semiring.distrib_right sup.assoc)"], ["proof (state)\nthis:\n  (t \\<squnion> e) * (t \\<squnion> e)\\<^sup>T =\n  t * t\\<^sup>T \\<squnion> t * e\\<^sup>T \\<squnion> e * t\\<^sup>T \\<squnion>\n  e * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. injective (t \\<squnion> e)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (t \\<squnion> e) * (t \\<squnion> e)\\<^sup>T =\n  t * t\\<^sup>T \\<squnion> t * e\\<^sup>T \\<squnion> e * t\\<^sup>T \\<squnion>\n  e * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. injective (t \\<squnion> e)", "using assms coreflexive_symmetric conv_dist_comp"], ["proof (prove)\nusing this:\n  (t \\<squnion> e) * (t \\<squnion> e)\\<^sup>T =\n  t * t\\<^sup>T \\<squnion> t * e\\<^sup>T \\<squnion> e * t\\<^sup>T \\<squnion>\n  e * e\\<^sup>T\n  injective t\n  coreflexive (e * t\\<^sup>T)\n  injective e\n  coreflexive ?x \\<Longrightarrow> symmetric ?x\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. injective (t \\<squnion> e)", "by fastforce"], ["proof (state)\nthis:\n  injective (t \\<squnion> e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injective_inv:\n  \"injective t \\<Longrightarrow> e * t\\<^sup>T = bot \\<Longrightarrow> arc e \\<Longrightarrow> injective (t \\<squnion> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>injective t; e * t\\<^sup>T = bot; arc e\\<rbrakk>\n    \\<Longrightarrow> injective (t \\<squnion> e)", "using arc_injective injective_sup bot_least"], ["proof (prove)\nusing this:\n  arc ?x \\<Longrightarrow> injective ?x\n  \\<lbrakk>injective ?t; coreflexive (?e * ?t\\<^sup>T);\n   injective ?e\\<rbrakk>\n  \\<Longrightarrow> injective (?t \\<squnion> ?e)\n  bot \\<le> ?a\n\ngoal (1 subgoal):\n 1. \\<lbrakk>injective t; e * t\\<^sup>T = bot; arc e\\<rbrakk>\n    \\<Longrightarrow> injective (t \\<squnion> e)", "by blast"], ["", "lemma univalent_sup:\n  \"univalent t \\<Longrightarrow> e\\<^sup>T * t \\<le> 1 \\<Longrightarrow> univalent e \\<Longrightarrow> univalent (t \\<squnion> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>univalent t; coreflexive (e\\<^sup>T * t); univalent e\\<rbrakk>\n    \\<Longrightarrow> univalent (t \\<squnion> e)", "by (metis injective_sup conv_dist_sup conv_involutive)"], ["", "lemma point_injective:\n  \"arc x \\<Longrightarrow> x\\<^sup>T * top * x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> coreflexive (x\\<^sup>T * top * x)", "by (metis conv_top comp_associative conv_dist_comp conv_involutive vector_top_closed)"], ["", "lemma vv_transitive:\n  \"vector v \\<Longrightarrow> (v * v\\<^sup>T) * (v * v\\<^sup>T) \\<le> v * v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v \\<Longrightarrow> transitive (v * v\\<^sup>T)", "by (metis comp_associative comp_left_isotone comp_right_isotone top_greatest)"], ["", "lemma epm_3:\n  assumes \"e \\<le> w\"\n      and \"injective w\"\n    shows \"e = w \\<sqinter> top * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "have \"w \\<sqinter> top * e \\<le> w * e\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<sqinter> top * e \\<le> w * e\\<^sup>T * e", "by (metis (no_types, lifting) inf.absorb2 top.extremum dedekind_2 inf.commute)"], ["proof (state)\nthis:\n  w \\<sqinter> top * e \\<le> w * e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "also"], ["proof (state)\nthis:\n  w \\<sqinter> top * e \\<le> w * e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "have \"... \\<le> w * w\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w * e\\<^sup>T * e \\<le> w * w\\<^sup>T * e", "by (simp add: assms(1) conv_isotone mult_left_isotone mult_right_isotone)"], ["proof (state)\nthis:\n  w * e\\<^sup>T * e \\<le> w * w\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "also"], ["proof (state)\nthis:\n  w * e\\<^sup>T * e \\<le> w * w\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "have \"... \\<le> e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w * w\\<^sup>T * e \\<le> e", "using assms(2) coreflexive_comp_top_inf inf.sup_right_divisibility"], ["proof (prove)\nusing this:\n  injective w\n  coreflexive ?x \\<Longrightarrow> ?x * top \\<sqinter> ?y = ?x * ?y\n  (?y \\<le> ?x) = (\\<exists>z. z \\<sqinter> ?x = ?y)\n\ngoal (1 subgoal):\n 1. w * w\\<^sup>T * e \\<le> e", "by blast"], ["proof (state)\nthis:\n  w * w\\<^sup>T * e \\<le> e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "finally"], ["proof (chain)\npicking this:\n  w \\<sqinter> top * e \\<le> e", "show ?thesis"], ["proof (prove)\nusing this:\n  w \\<sqinter> top * e \\<le> e\n\ngoal (1 subgoal):\n 1. e = w \\<sqinter> top * e", "by (simp add: assms(1) top_left_mult_increasing antisym)"], ["proof (state)\nthis:\n  e = w \\<sqinter> top * e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_inf_vector:\n  \"x * (y \\<sqinter> z * top) = (x \\<sqinter> top * z\\<^sup>T) * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z * top) = (x \\<sqinter> top * z\\<^sup>T) * y", "by (metis conv_top covector_inf_comp_3 comp_associative conv_dist_comp inf.commute vector_top_closed)"], ["", "lemma inf_vector_comp:\n  \"(x \\<sqinter> y * top) * z = y * top \\<sqinter> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> y * top) * z = y * top \\<sqinter> x * z", "using inf.commute vector_export_comp"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  (?x * top \\<sqinter> ?y) * ?z = ?x * top \\<sqinter> ?y * ?z\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> y * top) * z = y * top \\<sqinter> x * z", "by auto"], ["", "lemma comp_inf_covector:\n  \"x * (y \\<sqinter> top * z) = x * y \\<sqinter> top * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> top * z) = x * y \\<sqinter> top * z", "by (simp add: covector_comp_inf covector_mult_closed)"], ["", "text \\<open>\nWell-known distributivity properties of univalent and injective relations over meet continue to hold.\n\\<close>"], ["", "lemma univalent_comp_left_dist_inf:\n  assumes \"univalent x\"\n    shows \"x * (y \\<sqinter> z) = x * y \\<sqinter> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) = x * y \\<sqinter> x * z", "proof (rule antisym)"], ["proof (state)\ngoal (2 subgoals):\n 1. x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z\n 2. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "show \"x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z", "by (simp add: comp_right_isotone)"], ["proof (state)\nthis:\n  x * (y \\<sqinter> z) \\<le> x * y \\<sqinter> x * z\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "have \"x * y \\<sqinter> x * z \\<le> (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z\n    \\<le> (x \\<sqinter> x * z * y\\<^sup>T) *\n          (y \\<sqinter> x\\<^sup>T * x * z)", "by (metis comp_associative dedekind)"], ["proof (state)\nthis:\n  x * y \\<sqinter> x * z\n  \\<le> (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "also"], ["proof (state)\nthis:\n  x * y \\<sqinter> x * z\n  \\<le> (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "have \"... \\<le> x * (y \\<sqinter> x\\<^sup>T * x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\n    \\<le> x * (y \\<sqinter> x\\<^sup>T * x * z)", "by (simp add: comp_left_isotone)"], ["proof (state)\nthis:\n  (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\n  \\<le> x * (y \\<sqinter> x\\<^sup>T * x * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> x * z * y\\<^sup>T) * (y \\<sqinter> x\\<^sup>T * x * z)\n  \\<le> x * (y \\<sqinter> x\\<^sup>T * x * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "have \"... \\<le> x * (y \\<sqinter> 1 * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> x\\<^sup>T * x * z)\n    \\<le> x * (y \\<sqinter> (1::'a) * z)", "using assms comp_left_isotone comp_right_isotone inf.sup_right_isotone"], ["proof (prove)\nusing this:\n  univalent x\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> x\\<^sup>T * x * z)\n    \\<le> x * (y \\<sqinter> (1::'a) * z)", "by blast"], ["proof (state)\nthis:\n  x * (y \\<sqinter> x\\<^sup>T * x * z) \\<le> x * (y \\<sqinter> (1::'a) * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "finally"], ["proof (chain)\npicking this:\n  x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> (1::'a) * z)", "show \"x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)\""], ["proof (prove)\nusing this:\n  x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> (1::'a) * z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)", "by simp"], ["proof (state)\nthis:\n  x * y \\<sqinter> x * z \\<le> x * (y \\<sqinter> z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma injective_comp_right_dist_inf:\n  \"injective z \\<Longrightarrow> (x \\<sqinter> y) * z = x * z \\<sqinter> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective z \\<Longrightarrow>\n    (x \\<sqinter> y) * z = x * z \\<sqinter> y * z", "by (metis univalent_comp_left_dist_inf conv_dist_comp conv_involutive conv_dist_inf)"], ["", "lemma vector_covector:\n  \"vector v \\<Longrightarrow> vector w \\<Longrightarrow> v \\<sqinter> w\\<^sup>T = v * w\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector v; vector w\\<rbrakk>\n    \\<Longrightarrow> v \\<sqinter> w\\<^sup>T = v * w\\<^sup>T", "by (metis covector_comp_inf inf_top_left vector_conv_covector)"], ["", "lemma comp_inf_vector_1:\n  \"(x \\<sqinter> top * y) * z = x * (z \\<sqinter> (top * y)\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> top * y) * z = x * (z \\<sqinter> (top * y)\\<^sup>T)", "by (simp add: comp_inf_vector conv_dist_comp)"], ["", "text \\<open>\nThe shunting properties for bijective relations and mappings continue to hold.\n\\<close>"], ["", "lemma shunt_bijective:\n  assumes \"bijective z\"\n    shows \"x \\<le> y * z \\<longleftrightarrow> x * z\\<^sup>T \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<le> y * z) = (x * z\\<^sup>T \\<le> y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y * z \\<Longrightarrow> x * z\\<^sup>T \\<le> y\n 2. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "assume \"x \\<le> y * z\""], ["proof (state)\nthis:\n  x \\<le> y * z\n\ngoal (2 subgoals):\n 1. x \\<le> y * z \\<Longrightarrow> x * z\\<^sup>T \\<le> y\n 2. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "hence \"x * z\\<^sup>T \\<le> y * z * z\\<^sup>T\""], ["proof (prove)\nusing this:\n  x \\<le> y * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y * z * z\\<^sup>T", "by (simp add: mult_left_isotone)"], ["proof (state)\nthis:\n  x * z\\<^sup>T \\<le> y * z * z\\<^sup>T\n\ngoal (2 subgoals):\n 1. x \\<le> y * z \\<Longrightarrow> x * z\\<^sup>T \\<le> y\n 2. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "also"], ["proof (state)\nthis:\n  x * z\\<^sup>T \\<le> y * z * z\\<^sup>T\n\ngoal (2 subgoals):\n 1. x \\<le> y * z \\<Longrightarrow> x * z\\<^sup>T \\<le> y\n 2. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "have \"... \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * z * z\\<^sup>T \\<le> y", "using assms comp_associative mult_right_isotone"], ["proof (prove)\nusing this:\n  bijective z\n  ?x * ?y * ?z = ?x * (?y * ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. y * z * z\\<^sup>T \\<le> y", "by fastforce"], ["proof (state)\nthis:\n  y * z * z\\<^sup>T \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y * z \\<Longrightarrow> x * z\\<^sup>T \\<le> y\n 2. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "finally"], ["proof (chain)\npicking this:\n  x * z\\<^sup>T \\<le> y", "show \"x * z\\<^sup>T \\<le> y\""], ["proof (prove)\nusing this:\n  x * z\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y", "."], ["proof (state)\nthis:\n  x * z\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "assume 1: \"x * z\\<^sup>T \\<le> y\""], ["proof (state)\nthis:\n  x * z\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "have \"x = x \\<sqinter> top * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x \\<sqinter> top * z", "by (simp add: assms)"], ["proof (state)\nthis:\n  x = x \\<sqinter> top * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "also"], ["proof (state)\nthis:\n  x = x \\<sqinter> top * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "have \"... \\<le> x * z\\<^sup>T * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> top * z \\<le> x * z\\<^sup>T * z", "by (metis dedekind_2 inf_commute inf_top.right_neutral)"], ["proof (state)\nthis:\n  x \\<sqinter> top * z \\<le> x * z\\<^sup>T * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "also"], ["proof (state)\nthis:\n  x \\<sqinter> top * z \\<le> x * z\\<^sup>T * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "have \"... \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z\\<^sup>T * z \\<le> y * z", "using 1"], ["proof (prove)\nusing this:\n  x * z\\<^sup>T \\<le> y\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T * z \\<le> y * z", "by (simp add: mult_left_isotone)"], ["proof (state)\nthis:\n  x * z\\<^sup>T * z \\<le> y * z\n\ngoal (1 subgoal):\n 1. x * z\\<^sup>T \\<le> y \\<Longrightarrow> x \\<le> y * z", "finally"], ["proof (chain)\npicking this:\n  x \\<le> y * z", "show \"x \\<le> y * z\""], ["proof (prove)\nusing this:\n  x \\<le> y * z\n\ngoal (1 subgoal):\n 1. x \\<le> y * z", "."], ["proof (state)\nthis:\n  x \\<le> y * z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma shunt_mapping:\n  \"mapping z \\<Longrightarrow> x \\<le> z * y \\<longleftrightarrow> z\\<^sup>T * x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping z \\<Longrightarrow> (x \\<le> z * y) = (z\\<^sup>T * x \\<le> y)", "by (metis shunt_bijective mapping_conv_bijective conv_order conv_dist_comp conv_involutive)"], ["", "lemma bijective_reverse:\n  assumes \"bijective p\"\n      and \"bijective q\"\n    shows \"p \\<le> r * q \\<longleftrightarrow> q \\<le> r\\<^sup>T * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "have \"p \\<le> r * q \\<longleftrightarrow> p * q\\<^sup>T \\<le> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (p * q\\<^sup>T \\<le> r)", "by (simp add: assms(2) shunt_bijective)"], ["proof (state)\nthis:\n  (p \\<le> r * q) = (p * q\\<^sup>T \\<le> r)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "also"], ["proof (state)\nthis:\n  (p \\<le> r * q) = (p * q\\<^sup>T \\<le> r)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "have \"... \\<longleftrightarrow> q\\<^sup>T \\<le> p\\<^sup>T * r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * q\\<^sup>T \\<le> r) = (q\\<^sup>T \\<le> p\\<^sup>T * r)", "by (metis assms(1) conv_dist_comp conv_involutive conv_order shunt_bijective)"], ["proof (state)\nthis:\n  (p * q\\<^sup>T \\<le> r) = (q\\<^sup>T \\<le> p\\<^sup>T * r)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "also"], ["proof (state)\nthis:\n  (p * q\\<^sup>T \\<le> r) = (q\\<^sup>T \\<le> p\\<^sup>T * r)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "have \"... \\<longleftrightarrow> q \\<le> r\\<^sup>T * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (q\\<^sup>T \\<le> p\\<^sup>T * r) = (q \\<le> r\\<^sup>T * p)", "using conv_dist_comp conv_isotone"], ["proof (prove)\nusing this:\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. (q\\<^sup>T \\<le> p\\<^sup>T * r) = (q \\<le> r\\<^sup>T * p)", "by fastforce"], ["proof (state)\nthis:\n  (q\\<^sup>T \\<le> p\\<^sup>T * r) = (q \\<le> r\\<^sup>T * p)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "finally"], ["proof (chain)\npicking this:\n  (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "show ?thesis"], ["proof (prove)\nusing this:\n  (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)\n\ngoal (1 subgoal):\n 1. (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)", "by simp"], ["proof (state)\nthis:\n  (p \\<le> r * q) = (q \\<le> r\\<^sup>T * p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arc_expanded:\n  \"arc x \\<longleftrightarrow> x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * x * top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x =\n    (coreflexive (x * top * x\\<^sup>T) \\<and>\n     coreflexive (x\\<^sup>T * top * x) \\<and>\n     times_top_class.total (top * x))", "by (metis conv_top comp_associative conv_dist_comp conv_involutive vector_top_closed)"], ["", "lemma arc_top_arc:\n  assumes \"arc x\"\n    shows \"x * top * x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top * x = x", "by (metis assms epm_3 top_right_mult_increasing vector_inf_comp vector_mult_closed vector_top_closed)"], ["", "lemma arc_top_edge:\n  assumes \"arc x\"\n    shows \"x\\<^sup>T * top * x = x\\<^sup>T * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T * top * x = x\\<^sup>T * x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x\\<^sup>T * top * x = x\\<^sup>T * x", "have \"x\\<^sup>T = x\\<^sup>T * top \\<sqinter> top * x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T = x\\<^sup>T * top \\<sqinter> top * x\\<^sup>T", "using assms epm_3 top_right_mult_increasing"], ["proof (prove)\nusing this:\n  arc x\n  \\<lbrakk>?e \\<le> ?w; injective ?w\\<rbrakk>\n  \\<Longrightarrow> ?e = ?w \\<sqinter> top * ?e\n  ?x \\<le> ?x * top\n\ngoal (1 subgoal):\n 1. x\\<^sup>T = x\\<^sup>T * top \\<sqinter> top * x\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  x\\<^sup>T = x\\<^sup>T * top \\<sqinter> top * x\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T * top * x = x\\<^sup>T * x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x\\<^sup>T = x\\<^sup>T * top \\<sqinter> top * x\\<^sup>T\n\ngoal (1 subgoal):\n 1. x\\<^sup>T * top * x = x\\<^sup>T * x", "by (metis comp_inf_vector_1 conv_dist_comp conv_involutive conv_top inf.absorb1 top_right_mult_increasing)"], ["proof (state)\nthis:\n  x\\<^sup>T * top * x = x\\<^sup>T * x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Lemmas \\<open>arc_eq_1\\<close> and \\<open>arc_eq_2\\<close> were contributed by Nicolas Robinson-O'Brien.\\<close>"], ["", "lemma arc_eq_1:\n  assumes \"arc x\"\n    shows \"x = x * x\\<^sup>T * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "have \"x * x\\<^sup>T * x \\<le> x * top * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>T * x \\<le> x * top * x", "by (simp add: mult_left_isotone mult_right_isotone)"], ["proof (state)\nthis:\n  x * x\\<^sup>T * x \\<le> x * top * x\n\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "also"], ["proof (state)\nthis:\n  x * x\\<^sup>T * x \\<le> x * top * x\n\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top * x \\<le> x", "by (simp add: assms arc_top_arc)"], ["proof (state)\nthis:\n  x * top * x \\<le> x\n\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "finally"], ["proof (chain)\npicking this:\n  x * x\\<^sup>T * x \\<le> x", "have \"x * x\\<^sup>T * x \\<le> x\""], ["proof (prove)\nusing this:\n  x * x\\<^sup>T * x \\<le> x\n\ngoal (1 subgoal):\n 1. x * x\\<^sup>T * x \\<le> x", "by simp"], ["proof (state)\nthis:\n  x * x\\<^sup>T * x \\<le> x\n\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * x\\<^sup>T * x \\<le> x\n\ngoal (1 subgoal):\n 1. x = x * x\\<^sup>T * x", "by (simp add: antisym ex231c)"], ["proof (state)\nthis:\n  x = x * x\\<^sup>T * x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arc_eq_2:\n  assumes \"arc x\"\n    shows \"x\\<^sup>T = x\\<^sup>T * x * x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T = x\\<^sup>T * x * x\\<^sup>T", "using arc_eq_1 assms conv_involutive"], ["proof (prove)\nusing this:\n  arc ?x \\<Longrightarrow> ?x = ?x * ?x\\<^sup>T * ?x\n  arc x\n  ?x\\<^sup>T\\<^sup>T = ?x\n\ngoal (1 subgoal):\n 1. x\\<^sup>T = x\\<^sup>T * x * x\\<^sup>T", "by fastforce"], ["", "lemma points_arc:\n  \"point x \\<Longrightarrow> point y \\<Longrightarrow> arc (x * y\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>point x; point y\\<rbrakk> \\<Longrightarrow> arc (x * y\\<^sup>T)", "by (metis comp_associative conv_dist_comp conv_involutive equivalence_top_closed)"], ["", "lemma point_arc:\n  \"point x \\<Longrightarrow> arc (x * x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. point x \\<Longrightarrow> arc (x * x\\<^sup>T)", "by (simp add: points_arc)"], ["", "end"], ["", "subsection \\<open>Single-Object Pseudocomplemented Distributive Allegories\\<close>"], ["", "text \\<open>\nWe extend single-object bounded distributive allegories by a pseudocomplement operation.\nThe following definitions concern properties of relations that require a pseudocomplement.\n\\<close>"], ["", "class relation_algebra_signature = bounded_distrib_allegory_signature + uminus\nbegin"], ["", "abbreviation irreflexive         :: \"'a \\<Rightarrow> bool\" where \"irreflexive x         \\<equiv> x \\<le> -1\""], ["", "abbreviation strict_linear       :: \"'a \\<Rightarrow> bool\" where \"strict_linear x       \\<equiv> x \\<squnion> x\\<^sup>T = -1\""], ["", "abbreviation strict_order        :: \"'a \\<Rightarrow> bool\" where \"strict_order x        \\<equiv> irreflexive x \\<and> transitive x\""], ["", "abbreviation linear_strict_order :: \"'a \\<Rightarrow> bool\" where \"linear_strict_order x \\<equiv> strict_order x \\<and> strict_linear x\""], ["", "text \\<open>\nThe following variants are useful for the graph model.\n\\<close>"], ["", "abbreviation pp_mapping          :: \"'a \\<Rightarrow> bool\" where \"pp_mapping x          \\<equiv> univalent x \\<and> total (--x)\""], ["", "abbreviation pp_bijective        :: \"'a \\<Rightarrow> bool\" where \"pp_bijective x        \\<equiv> injective x \\<and> surjective (--x)\""], ["", "abbreviation pp_point            :: \"'a \\<Rightarrow> bool\" where \"pp_point x            \\<equiv> vector x \\<and> pp_bijective x\""], ["", "abbreviation pp_arc              :: \"'a \\<Rightarrow> bool\" where \"pp_arc x              \\<equiv> pp_bijective (x * top) \\<and> pp_bijective (x\\<^sup>T * top)\""], ["", "end"], ["", "class pd_allegory = bounded_distrib_allegory + p_algebra\nbegin"], ["", "subclass relation_algebra_signature"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "subclass pd_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pd_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot top uminus", ".."], ["", "lemma conv_complement_1:\n  \"-(x\\<^sup>T) \\<squnion> (-x)\\<^sup>T = (-x)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x\\<^sup>T \\<squnion> (- x)\\<^sup>T = (- x)\\<^sup>T", "by (metis conv_dist_inf conv_order bot_least conv_involutive pseudo_complement sup.absorb2 sup.cobounded2)"], ["", "lemma conv_complement:\n  \"(-x)\\<^sup>T = -(x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x)\\<^sup>T = - x\\<^sup>T", "by (metis conv_complement_1 conv_dist_sup conv_involutive sup_commute)"], ["", "lemma conv_complement_sub_inf [simp]:\n  \"x\\<^sup>T * -(x * y) \\<sqinter> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T * - (x * y) \\<sqinter> y = bot", "by (metis comp_left_zero conv_dist_comp conv_involutive dedekind_1 inf_import_p inf_p inf_right_idem ppp pseudo_complement regular_closed_bot)"], ["", "lemma conv_complement_sub_leq:\n  \"x\\<^sup>T * -(x * y) \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T * - (x * y) \\<le> - y", "using pseudo_complement conv_complement_sub_inf"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  ?x\\<^sup>T * - (?x * ?y) \\<sqinter> ?y = bot\n\ngoal (1 subgoal):\n 1. x\\<^sup>T * - (x * y) \\<le> - y", "by blast"], ["", "lemma conv_complement_sub [simp]:\n  \"x\\<^sup>T * -(x * y) \\<squnion> -y = -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T * - (x * y) \\<squnion> - y = - y", "by (simp add: conv_complement_sub_leq sup.absorb2)"], ["", "lemma complement_conv_sub:\n  \"-(y * x) * x\\<^sup>T \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (y * x) * x\\<^sup>T \\<le> - y", "by (metis conv_complement conv_complement_sub_leq conv_order conv_dist_comp)"], ["", "text \\<open>\nThe following so-called Schr\\\"oder equivalences, or De Morgan's Theorem K, hold only with a pseudocomplemented element on both right-hand sides.\n\\<close>"], ["", "lemma schroeder_3_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> x\\<^sup>T * z \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (x\\<^sup>T * z \\<le> - y)", "using pseudo_complement schroeder_1"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  (?x * ?y \\<sqinter> ?z = bot) = (?x\\<^sup>T * ?z \\<sqinter> ?y = bot)\n\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (x\\<^sup>T * z \\<le> - y)", "by auto"], ["", "lemma schroeder_4_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> z * y\\<^sup>T \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (z * y\\<^sup>T \\<le> - x)", "using pseudo_complement schroeder_2"], ["proof (prove)\nusing this:\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n  (?x * ?y \\<sqinter> ?z = bot) = (?z * ?y\\<^sup>T \\<sqinter> ?x = bot)\n\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (z * y\\<^sup>T \\<le> - x)", "by auto"], ["", "lemma comp_pp_semi_commute:\n  \"x * --y \\<le> --(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * - - y \\<le> - - (x * y)", "using conv_complement_sub_leq schroeder_3_p"], ["proof (prove)\nusing this:\n  ?x\\<^sup>T * - (?x * ?y) \\<le> - ?y\n  (?x * ?y \\<le> - ?z) = (?x\\<^sup>T * ?z \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x * - - y \\<le> - - (x * y)", "by fastforce"], ["", "text \\<open>\nThe following result looks similar to a property of (anti)domain.\n\\<close>"], ["", "lemma p_comp_pp [simp]:\n  \"-(x * --y) = -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * - - y) = - (x * y)", "using comp_pp_semi_commute comp_right_isotone inf.eq_iff p_antitone pp_increasing"], ["proof (prove)\nusing this:\n  ?x * - - ?y \\<le> - - (?x * ?y)\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  (?x = ?y) = (?y \\<le> ?x \\<and> ?x \\<le> ?y)\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. - (x * - - y) = - (x * y)", "by fastforce"], ["", "lemma pp_comp_semi_commute:\n  \"--x * y \\<le> --(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x * y \\<le> - - (x * y)", "using complement_conv_sub schroeder_4_p"], ["proof (prove)\nusing this:\n  - (?y * ?x) * ?x\\<^sup>T \\<le> - ?y\n  (?x * ?y \\<le> - ?z) = (?z * ?y\\<^sup>T \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. - - x * y \\<le> - - (x * y)", "by fastforce"], ["", "lemma p_pp_comp [simp]:\n  \"-(--x * y) = -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (- - x * y) = - (x * y)", "using pp_comp_semi_commute comp_left_isotone inf.eq_iff p_antitone pp_increasing"], ["proof (prove)\nusing this:\n  - - ?x * ?y \\<le> - - (?x * ?y)\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  (?x = ?y) = (?y \\<le> ?x \\<and> ?x \\<le> ?y)\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. - (- - x * y) = - (x * y)", "by fastforce"], ["", "lemma pp_comp_subdist:\n  \"--x * --y \\<le> --(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x * - - y \\<le> - - (x * y)", "by (simp add: p_antitone_iff)"], ["", "lemma theorem24xxiii:\n  \"x * y \\<sqinter> -(x * z) = x * (y \\<sqinter> -z) \\<sqinter> -(x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "have \"x * y \\<sqinter> -(x * z) \\<le> x * (y \\<sqinter> (x\\<^sup>T * -(x * z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z)\n    \\<le> x * (y \\<sqinter> x\\<^sup>T * - (x * z))", "by (simp add: dedekind_1)"], ["proof (state)\nthis:\n  x * y \\<sqinter> - (x * z) \\<le> x * (y \\<sqinter> x\\<^sup>T * - (x * z))\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "also"], ["proof (state)\nthis:\n  x * y \\<sqinter> - (x * z) \\<le> x * (y \\<sqinter> x\\<^sup>T * - (x * z))\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "have \"... \\<le> x * (y \\<sqinter> -z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> x\\<^sup>T * - (x * z)) \\<le> x * (y \\<sqinter> - z)", "using comp_right_isotone conv_complement_sub_leq inf.sup_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x\\<^sup>T * - (?x * ?y) \\<le> - ?y\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n\ngoal (1 subgoal):\n 1. x * (y \\<sqinter> x\\<^sup>T * - (x * z)) \\<le> x * (y \\<sqinter> - z)", "by auto"], ["proof (state)\nthis:\n  x * (y \\<sqinter> x\\<^sup>T * - (x * z)) \\<le> x * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "finally"], ["proof (chain)\npicking this:\n  x * y \\<sqinter> - (x * z) \\<le> x * (y \\<sqinter> - z)", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y \\<sqinter> - (x * z) \\<le> x * (y \\<sqinter> - z)\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "using comp_right_subdist_inf antisym inf.coboundedI2 inf.commute"], ["proof (prove)\nusing this:\n  x * y \\<sqinter> - (x * z) \\<le> x * (y \\<sqinter> - z)\n  ?x * (?y \\<sqinter> ?z) \\<le> ?x * ?y \\<sqinter> ?x * ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?b \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n\ngoal (1 subgoal):\n 1. x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)", "by auto"], ["proof (state)\nthis:\n  x * y \\<sqinter> - (x * z) = x * (y \\<sqinter> - z) \\<sqinter> - (x * z)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nEven in Stone relation algebras, we do not obtain the backward implication in the following result.\n\\<close>"], ["", "lemma vector_complement_closed:\n  \"vector x \\<Longrightarrow> vector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> vector (- x)", "by (metis complement_conv_sub conv_top eq_iff top_right_mult_increasing)"], ["", "lemma covector_complement_closed:\n  \"covector x \\<Longrightarrow> covector (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow> covector (- x)", "by (metis conv_complement_sub_leq conv_top eq_iff top_left_mult_increasing)"], ["", "lemma covector_vector_comp:\n  \"vector v \\<Longrightarrow> -v\\<^sup>T * v = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v \\<Longrightarrow> - v\\<^sup>T * v = bot", "by (metis conv_bot conv_complement conv_complement_sub_inf conv_dist_comp conv_involutive inf_top.right_neutral)"], ["", "lemma irreflexive_bot_closed:\n  \"irreflexive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive bot", "by simp"], ["", "lemma irreflexive_inf_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive x \\<Longrightarrow> irreflexive (x \\<sqinter> y)", "by (simp add: le_infI1)"], ["", "lemma irreflexive_sup_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive y \\<Longrightarrow> irreflexive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>irreflexive x; irreflexive y\\<rbrakk>\n    \\<Longrightarrow> irreflexive (x \\<squnion> y)", "by simp"], ["", "lemma irreflexive_conv_closed:\n  \"irreflexive x \\<Longrightarrow> irreflexive (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive x \\<Longrightarrow> irreflexive (x\\<^sup>T)", "using conv_complement conv_isotone"], ["proof (prove)\nusing this:\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. irreflexive x \\<Longrightarrow> irreflexive (x\\<^sup>T)", "by fastforce"], ["", "lemma reflexive_complement_irreflexive:\n  \"reflexive x \\<Longrightarrow> irreflexive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> irreflexive (- x)", "by (simp add: p_antitone)"], ["", "lemma irreflexive_complement_reflexive:\n  \"irreflexive x \\<longleftrightarrow> reflexive (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive x = reflexive (- x)", "by (simp add: p_antitone_iff)"], ["", "lemma symmetric_complement_closed:\n  \"symmetric x \\<Longrightarrow> symmetric (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric x \\<Longrightarrow> symmetric (- x)", "by (simp add: conv_complement)"], ["", "lemma asymmetric_irreflexive:\n  \"asymmetric x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<Longrightarrow> irreflexive x", "by (metis inf.mult_not_zero inf.left_commute inf.right_idem inf.sup_monoid.add_commute pseudo_complement one_inf_conv)"], ["", "lemma linear_asymmetric:\n  \"linear x \\<Longrightarrow> asymmetric (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear x \\<Longrightarrow> asymmetric (- x)", "using conv_complement p_top"], ["proof (prove)\nusing this:\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  dense top\n\ngoal (1 subgoal):\n 1. linear x \\<Longrightarrow> asymmetric (- x)", "by force"], ["", "lemma strict_linear_sup_closed:\n  \"strict_linear x \\<Longrightarrow> strict_linear y \\<Longrightarrow> strict_linear (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_linear x; strict_linear y\\<rbrakk>\n    \\<Longrightarrow> strict_linear (x \\<squnion> y)", "by (metis (mono_tags, hide_lams) conv_dist_sup sup.right_idem sup_assoc sup_commute)"], ["", "lemma strict_linear_irreflexive:\n  \"strict_linear x \\<Longrightarrow> irreflexive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear x \\<Longrightarrow> irreflexive x", "using sup_left_divisibility"], ["proof (prove)\nusing this:\n  (?x \\<le> ?y) = (\\<exists>z. ?x \\<squnion> z = ?y)\n\ngoal (1 subgoal):\n 1. strict_linear x \\<Longrightarrow> irreflexive x", "by blast"], ["", "lemma strict_linear_conv_closed:\n  \"strict_linear x \\<Longrightarrow> strict_linear (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear x \\<Longrightarrow> strict_linear (x\\<^sup>T)", "by (simp add: sup_commute)"], ["", "lemma strict_order_var:\n  \"strict_order x \\<longleftrightarrow> asymmetric x \\<and> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order x = (asymmetric x \\<and> transitive x)", "by (metis asymmetric_irreflexive comp_right_one irreflexive_conv_closed conv_dist_comp dual_order.trans pseudo_complement schroeder_3_p)"], ["", "lemma strict_order_bot_closed:\n  \"strict_order bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order bot", "by simp"], ["", "lemma strict_order_inf_closed:\n  \"strict_order x \\<Longrightarrow> strict_order y \\<Longrightarrow> strict_order (x \\<sqinter> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_order x; strict_order y\\<rbrakk>\n    \\<Longrightarrow> strict_order (x \\<sqinter> y)", "using inf.coboundedI1 transitive_inf_closed"], ["proof (prove)\nusing this:\n  ?a \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n  \\<lbrakk>transitive ?x; transitive ?y\\<rbrakk>\n  \\<Longrightarrow> transitive (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_order x; strict_order y\\<rbrakk>\n    \\<Longrightarrow> strict_order (x \\<sqinter> y)", "by auto"], ["", "lemma strict_order_conv_closed:\n  \"strict_order x \\<Longrightarrow> strict_order (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order x \\<Longrightarrow> strict_order (x\\<^sup>T)", "using irreflexive_conv_closed transitive_conv_closed"], ["proof (prove)\nusing this:\n  irreflexive ?x \\<Longrightarrow> irreflexive (?x\\<^sup>T)\n  transitive ?x \\<Longrightarrow> transitive (?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. strict_order x \\<Longrightarrow> strict_order (x\\<^sup>T)", "by blast"], ["", "lemma order_strict_order:\n  assumes \"order x\"\n  shows \"strict_order (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order (x \\<sqinter> - (1::'a))", "proof (rule conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. irreflexive (x \\<sqinter> - (1::'a))\n 2. transitive (x \\<sqinter> - (1::'a))", "show 1: \"irreflexive (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive (x \\<sqinter> - (1::'a))", "by simp"], ["proof (state)\nthis:\n  irreflexive (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "have \"antisymmetric (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antisymmetric (x \\<sqinter> - (1::'a))", "using antisymmetric_inf_closed assms"], ["proof (prove)\nusing this:\n  antisymmetric ?x \\<Longrightarrow> antisymmetric (?x \\<sqinter> ?y)\n  order x\n\ngoal (1 subgoal):\n 1. antisymmetric (x \\<sqinter> - (1::'a))", "by blast"], ["proof (state)\nthis:\n  antisymmetric (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "hence \"(x \\<sqinter> -1) * (x \\<sqinter> -1) \\<sqinter> 1 \\<le> (x \\<sqinter> -1 \\<sqinter> (x \\<sqinter> -1)\\<^sup>T) * (x \\<sqinter> -1 \\<sqinter> (x \\<sqinter> -1)\\<^sup>T)\""], ["proof (prove)\nusing this:\n  antisymmetric (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n    \\<le> (x \\<sqinter> - (1::'a) \\<sqinter>\n           (x \\<sqinter> - (1::'a))\\<^sup>T) *\n          (x \\<sqinter> - (1::'a) \\<sqinter>\n           (x \\<sqinter> - (1::'a))\\<^sup>T)", "using 1"], ["proof (prove)\nusing this:\n  antisymmetric (x \\<sqinter> - (1::'a))\n  irreflexive (x \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n    \\<le> (x \\<sqinter> - (1::'a) \\<sqinter>\n           (x \\<sqinter> - (1::'a))\\<^sup>T) *\n          (x \\<sqinter> - (1::'a) \\<sqinter>\n           (x \\<sqinter> - (1::'a))\\<^sup>T)", "by (metis (no_types) coreflexive_symmetric irreflexive_inf_closed coreflexive_transitive dedekind_1 inf_idem mult_1_right semiring.mult_not_zero strict_order_var)"], ["proof (state)\nthis:\n  (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n  \\<le> (x \\<sqinter> - (1::'a) \\<sqinter>\n         (x \\<sqinter> - (1::'a))\\<^sup>T) *\n        (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n  \\<le> (x \\<sqinter> - (1::'a) \\<sqinter>\n         (x \\<sqinter> - (1::'a))\\<^sup>T) *\n        (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T)\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "have \"... = (x \\<sqinter> x\\<^sup>T \\<sqinter> -1) * (x \\<sqinter> x\\<^sup>T \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) *\n    (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) =\n    (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n    (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))", "by (simp add: conv_complement conv_dist_inf inf.absorb2 inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) *\n  (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) =\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) *\n  (x \\<sqinter> - (1::'a) \\<sqinter> (x \\<sqinter> - (1::'a))\\<^sup>T) =\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n    (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) =\n    bot", "using assms inf.antisym reflexive_conv_closed"], ["proof (prove)\nusing this:\n  order x\n  \\<lbrakk>?y \\<le> ?x; ?x \\<le> ?y\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  reflexive ?x \\<Longrightarrow> reflexive (?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n    (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) =\n    bot", "by fastforce"], ["proof (state)\nthis:\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) *\n  (x \\<sqinter> x\\<^sup>T \\<sqinter> - (1::'a)) =\n  bot\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "finally"], ["proof (chain)\npicking this:\n  (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n  \\<le> bot", "have \"(x \\<sqinter> -1) * (x \\<sqinter> -1) \\<le> -1\""], ["proof (prove)\nusing this:\n  (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n  \\<le> bot\n\ngoal (1 subgoal):\n 1. irreflexive ((x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)))", "using le_bot pseudo_complement"], ["proof (prove)\nusing this:\n  (x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)) \\<sqinter> (1::'a)\n  \\<le> bot\n  ?a \\<le> bot \\<Longrightarrow> ?a = bot\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. irreflexive ((x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)))", "by blast"], ["proof (state)\nthis:\n  irreflexive ((x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "thus \"transitive (x \\<sqinter> -1)\""], ["proof (prove)\nusing this:\n  irreflexive ((x \\<sqinter> - (1::'a)) * (x \\<sqinter> - (1::'a)))\n\ngoal (1 subgoal):\n 1. transitive (x \\<sqinter> - (1::'a))", "by (meson assms comp_isotone inf.boundedI inf.cobounded1 inf.order_lesseq_imp)"], ["proof (state)\nthis:\n  transitive (x \\<sqinter> - (1::'a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma strict_order_order:\n  \"strict_order x \\<Longrightarrow> order (x \\<squnion> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_order x \\<Longrightarrow> order (x \\<squnion> (1::'a))", "apply (unfold strict_order_var, intro conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    reflexive (x \\<squnion> (1::'a))\n 2. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    transitive (x \\<squnion> (1::'a))\n 3. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    antisymmetric (x \\<squnion> (1::'a))", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    transitive (x \\<squnion> (1::'a))\n 2. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    antisymmetric (x \\<squnion> (1::'a))", "apply (simp add: mult_left_dist_sup mult_right_dist_sup sup.absorb2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    antisymmetric (x \\<squnion> (1::'a))", "using conv_dist_sup coreflexive_bot_closed sup.absorb2 sup_inf_distrib2"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  coreflexive bot\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?b = ?b\n  ?y \\<sqinter> ?z \\<squnion> ?x =\n  (?y \\<squnion> ?x) \\<sqinter> (?z \\<squnion> ?x)\n\ngoal (1 subgoal):\n 1. asymmetric x \\<and> transitive x \\<Longrightarrow>\n    antisymmetric (x \\<squnion> (1::'a))", "by fastforce"], ["", "lemma linear_strict_order_conv_closed:\n  \"linear_strict_order x \\<Longrightarrow> linear_strict_order (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. linear_strict_order x \\<Longrightarrow> linear_strict_order (x\\<^sup>T)", "by (simp add: irreflexive_conv_closed sup_monoid.add_commute transitive_conv_closed)"], ["", "lemma linear_order_strict_order:\n  \"linear_order x \\<Longrightarrow> linear_strict_order (x \\<sqinter> -1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    linear_strict_order (x \\<sqinter> - (1::'a))", "apply (rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    strict_order (x \\<sqinter> - (1::'a))\n 2. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    strict_linear (x \\<sqinter> - (1::'a))", "using order_strict_order"], ["proof (prove)\nusing this:\n  order ?x \\<Longrightarrow> strict_order (?x \\<sqinter> - (1::'a))\n\ngoal (2 subgoals):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    strict_order (x \\<sqinter> - (1::'a))\n 2. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    strict_linear (x \\<sqinter> - (1::'a))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. bounded_distrib_allegory_signature_class.linear_order\n     x \\<Longrightarrow>\n    strict_linear (x \\<sqinter> - (1::'a))", "by (metis conv_complement conv_dist_inf coreflexive_symmetric eq_iff inf.absorb2 inf.distrib_left inf.sup_monoid.add_commute top.extremum)"], ["", "lemma regular_conv_closed:\n  \"regular x \\<Longrightarrow> regular (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x \\<Longrightarrow> regular (x\\<^sup>T)", "by (metis conv_complement)"], ["", "text \\<open>\nWe show a number of facts about equivalences.\n\\<close>"], ["", "lemma equivalence_comp_left_complement:\n  \"equivalence x \\<Longrightarrow> x * -x = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow> x * - x = - x", "apply (rule antisym)"], ["proof (prove)\ngoal (2 subgoals):\n 1. equivalence x \\<Longrightarrow> x * - x \\<le> - x\n 2. equivalence x \\<Longrightarrow> - x \\<le> x * - x", "apply (metis conv_complement_sub_leq preorder_idempotent)"], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow> - x \\<le> x * - x", "using mult_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow> - x \\<le> x * - x", "by fastforce"], ["", "lemma equivalence_comp_right_complement:\n  \"equivalence x \\<Longrightarrow> -x * x = -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equivalence x \\<Longrightarrow> - x * x = - x", "by (metis equivalence_comp_left_complement conv_complement conv_dist_comp)"], ["", "text \\<open>\nThe pseudocomplement of tests is given by the following operation.\n\\<close>"], ["", "abbreviation coreflexive_complement :: \"'a \\<Rightarrow> 'a\" (\"_ ''\" [80] 80)\n  where \"x ' \\<equiv> -x \\<sqinter> 1\""], ["", "lemma coreflexive_comp_top_coreflexive_complement:\n  \"coreflexive x \\<Longrightarrow> (x * top)' = x '\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> (x * top) ' = x '", "by (metis coreflexive_comp_top_inf_one inf.commute inf_import_p)"], ["", "lemma coreflexive_comp_inf_complement:\n  \"coreflexive x \\<Longrightarrow> (x * y) \\<sqinter> -z = (x * y) \\<sqinter> -(x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow>\n    x * y \\<sqinter> - z = x * y \\<sqinter> - (x * z)", "by (metis coreflexive_comp_top_inf inf.sup_relative_same_increasing inf_import_p inf_le1)"], ["", "lemma double_coreflexive_complement:\n  \"x '' = (-x)'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x ' ' = - x '", "using inf.sup_monoid.add_commute inf_import_p"], ["proof (prove)\nusing this:\n  ?a \\<sqinter> ?b = ?b \\<sqinter> ?a\n  ?x \\<sqinter> - (?x \\<sqinter> ?y) = ?x \\<sqinter> - ?y\n\ngoal (1 subgoal):\n 1. x ' ' = - x '", "by auto"], ["", "lemma coreflexive_pp_dist_comp:\n  assumes \"coreflexive x\"\n      and \"coreflexive y\"\n    shows \"(x * y)'' = x '' * y ''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "have \"(x * y)'' = --(x * y) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y) ' ' = - (x * y) '", "by (simp add: double_coreflexive_complement)"], ["proof (state)\nthis:\n  (x * y) ' ' = - (x * y) '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "also"], ["proof (state)\nthis:\n  (x * y) ' ' = - (x * y) '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "have \"... = --x \\<sqinter> --y \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * y) ' = - - x \\<sqinter> - - y \\<sqinter> (1::'a)", "by (simp add: assms coreflexive_comp_inf)"], ["proof (state)\nthis:\n  - (x * y) ' = - - x \\<sqinter> - - y \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "also"], ["proof (state)\nthis:\n  - (x * y) ' = - - x \\<sqinter> - - y \\<sqinter> (1::'a)\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "have \"... = (--x \\<sqinter> 1) * (--y \\<sqinter> 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<sqinter> - - y \\<sqinter> (1::'a) = - x ' * - y '", "by (simp add: coreflexive_comp_inf inf.left_commute inf.sup_monoid.add_assoc)"], ["proof (state)\nthis:\n  - - x \\<sqinter> - - y \\<sqinter> (1::'a) = - x ' * - y '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "also"], ["proof (state)\nthis:\n  - - x \\<sqinter> - - y \\<sqinter> (1::'a) = - x ' * - y '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "have \"... = x '' * y ''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - x ' * - y ' = x ' ' * y ' '", "by (simp add: double_coreflexive_complement)"], ["proof (state)\nthis:\n  - x ' * - y ' = x ' ' * y ' '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "finally"], ["proof (chain)\npicking this:\n  (x * y) ' ' = x ' ' * y ' '", "show ?thesis"], ["proof (prove)\nusing this:\n  (x * y) ' ' = x ' ' * y ' '\n\ngoal (1 subgoal):\n 1. (x * y) ' ' = x ' ' * y ' '", "."], ["proof (state)\nthis:\n  (x * y) ' ' = x ' ' * y ' '\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coreflexive_pseudo_complement:\n  \"coreflexive x \\<Longrightarrow> x \\<sqinter> y = bot \\<longleftrightarrow> x \\<le> y '\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> (x \\<sqinter> y = bot) = (x \\<le> y ')", "by (simp add: pseudo_complement)"], ["", "lemma pp_bijective_conv_mapping:\n  \"pp_bijective x \\<longleftrightarrow> pp_mapping (x\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_bijective x = pp_mapping (x\\<^sup>T)", "by (simp add: conv_complement surjective_conv_total)"], ["", "lemma pp_arc_expanded:\n  \"pp_arc x \\<longleftrightarrow> x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * --x * top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pp_arc x =\n    (coreflexive (x * top * x\\<^sup>T) \\<and>\n     coreflexive (x\\<^sup>T * top * x) \\<and>\n     times_top_class.total (top * - - x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "assume 1: \"pp_arc x\""], ["proof (state)\nthis:\n  pp_arc x\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have 2: \"x * top * x\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T)", "using 1"], ["proof (prove)\nusing this:\n  pp_arc x\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T)", "by (metis comp_associative conv_dist_comp equivalence_top_closed vector_top_closed)"], ["proof (state)\nthis:\n  coreflexive (x * top * x\\<^sup>T)\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have 3: \"x\\<^sup>T * top * x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x\\<^sup>T * top * x)", "using 1"], ["proof (prove)\nusing this:\n  pp_arc x\n\ngoal (1 subgoal):\n 1. coreflexive (x\\<^sup>T * top * x)", "by (metis conv_dist_comp conv_involutive equivalence_top_closed vector_top_closed mult_assoc)"], ["proof (state)\nthis:\n  coreflexive (x\\<^sup>T * top * x)\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have 4: \"x\\<^sup>T \\<le> x\\<^sup>T * x * x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<le> x\\<^sup>T * x * x\\<^sup>T", "by (metis conv_involutive ex231c)"], ["proof (state)\nthis:\n  x\\<^sup>T \\<le> x\\<^sup>T * x * x\\<^sup>T\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"top = --(top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top = - - (top * x) * top", "using 1"], ["proof (prove)\nusing this:\n  pp_arc x\n\ngoal (1 subgoal):\n 1. top = - - (top * x) * top", "by (metis conv_complement conv_dist_comp conv_involutive equivalence_top_closed)"], ["proof (state)\nthis:\n  top = - - (top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  top = - - (top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... \\<le> --(top * x\\<^sup>T * top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (top * x) * top \\<le> - - (top * x\\<^sup>T * top * x) * top", "using 1"], ["proof (prove)\nusing this:\n  pp_arc x\n\ngoal (1 subgoal):\n 1. - - (top * x) * top \\<le> - - (top * x\\<^sup>T * top * x) * top", "by (metis eq_refl mult_assoc p_comp_pp p_pp_comp)"], ["proof (state)\nthis:\n  - - (top * x) * top \\<le> - - (top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  - - (top * x) * top \\<le> - - (top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... = (top * --(x * top) \\<sqinter> --(top * x\\<^sup>T * top * x)) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (top * x\\<^sup>T * top * x) * top =\n    (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top", "using 1"], ["proof (prove)\nusing this:\n  pp_arc x\n\ngoal (1 subgoal):\n 1. - - (top * x\\<^sup>T * top * x) * top =\n    (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top", "by simp"], ["proof (state)\nthis:\n  - - (top * x\\<^sup>T * top * x) * top =\n  (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  - - (top * x\\<^sup>T * top * x) * top =\n  (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... = top * (--(x * top) \\<sqinter> --(top * x\\<^sup>T * top * x)) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n    top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top", "by (simp add: covector_complement_closed covector_comp_inf covector_mult_closed)"], ["proof (state)\nthis:\n  (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n  top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  (top * - - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n  top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... = top * --(x * top \\<sqinter> top * x\\<^sup>T * top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n    top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top", "by simp"], ["proof (state)\nthis:\n  top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n  top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  top * (- - (x * top) \\<sqinter> - - (top * x\\<^sup>T * top * x)) * top =\n  top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... = top * --(x * top * x\\<^sup>T * top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top =\n    top * - - (x * top * x\\<^sup>T * top * x) * top", "by (metis comp_associative comp_inf_covector inf_top.left_neutral)"], ["proof (state)\nthis:\n  top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top =\n  top * - - (x * top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  top * - - (x * top \\<sqinter> top * x\\<^sup>T * top * x) * top =\n  top * - - (x * top * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... \\<le> top * --(x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * - - (x * top * x\\<^sup>T * top * x) * top\n    \\<le> top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top", "using 4"], ["proof (prove)\nusing this:\n  x\\<^sup>T \\<le> x\\<^sup>T * x * x\\<^sup>T\n\ngoal (1 subgoal):\n 1. top * - - (x * top * x\\<^sup>T * top * x) * top\n    \\<le> top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top", "by (metis comp_associative comp_left_isotone comp_right_isotone pp_isotone)"], ["proof (state)\nthis:\n  top * - - (x * top * x\\<^sup>T * top * x) * top\n  \\<le> top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  top * - - (x * top * x\\<^sup>T * top * x) * top\n  \\<le> top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... \\<le> top * --(x * x\\<^sup>T * top * x) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n    \\<le> top * - - (x * x\\<^sup>T * top * x) * top", "using 2"], ["proof (prove)\nusing this:\n  coreflexive (x * top * x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n    \\<le> top * - - (x * x\\<^sup>T * top * x) * top", "by (metis comp_associative comp_left_isotone comp_right_isotone pp_isotone comp_left_one)"], ["proof (state)\nthis:\n  top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n  \\<le> top * - - (x * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "also"], ["proof (state)\nthis:\n  top * - - (x * top * x\\<^sup>T * x * x\\<^sup>T * top * x) * top\n  \\<le> top * - - (x * x\\<^sup>T * top * x) * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "have \"... \\<le> top * --x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top * - - (x * x\\<^sup>T * top * x) * top \\<le> top * - - x * top", "using 3"], ["proof (prove)\nusing this:\n  coreflexive (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. top * - - (x * x\\<^sup>T * top * x) * top \\<le> top * - - x * top", "by (metis comp_associative comp_left_isotone comp_right_isotone pp_isotone comp_right_one)"], ["proof (state)\nthis:\n  top * - - (x * x\\<^sup>T * top * x) * top \\<le> top * - - x * top\n\ngoal (2 subgoals):\n 1. pp_arc x \\<Longrightarrow>\n    coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "finally"], ["proof (chain)\npicking this:\n  top \\<le> top * - - x * top", "show \"x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * --x * top = top\""], ["proof (prove)\nusing this:\n  top \\<le> top * - - x * top\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)", "using 2 3 top_le"], ["proof (prove)\nusing this:\n  top \\<le> top * - - x * top\n  coreflexive (x * top * x\\<^sup>T)\n  coreflexive (x\\<^sup>T * top * x)\n  top \\<le> ?a \\<Longrightarrow> ?a = top\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x)", "by blast"], ["proof (state)\nthis:\n  coreflexive (x * top * x\\<^sup>T) \\<and>\n  coreflexive (x\\<^sup>T * top * x) \\<and>\n  times_top_class.total (top * - - x)\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "assume \"x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1 \\<and> top * --x * top = top\""], ["proof (state)\nthis:\n  coreflexive (x * top * x\\<^sup>T) \\<and>\n  coreflexive (x\\<^sup>T * top * x) \\<and>\n  times_top_class.total (top * - - x)\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    pp_arc x", "thus \"pp_arc x\""], ["proof (prove)\nusing this:\n  coreflexive (x * top * x\\<^sup>T) \\<and>\n  coreflexive (x\\<^sup>T * top * x) \\<and>\n  times_top_class.total (top * - - x)\n\ngoal (1 subgoal):\n 1. pp_arc x", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    injective (x * top)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x * top))\n 3. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    injective (x\\<^sup>T * top)\n 4. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x\\<^sup>T * top))", "apply (metis comp_associative conv_dist_comp equivalence_top_closed vector_top_closed)"], ["proof (prove)\ngoal (3 subgoals):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x * top))\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    injective (x\\<^sup>T * top)\n 3. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x\\<^sup>T * top))", "apply (metis comp_associative mult_right_isotone top_le pp_comp_semi_commute)"], ["proof (prove)\ngoal (2 subgoals):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    injective (x\\<^sup>T * top)\n 2. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x\\<^sup>T * top))", "apply (metis conv_dist_comp coreflexive_symmetric vector_conv_covector vector_top_closed mult_assoc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x) \\<and>\n    times_top_class.total (top * - - x) \\<Longrightarrow>\n    surjective (- - (x\\<^sup>T * top))", "by (metis conv_complement conv_dist_comp equivalence_top_closed inf.orderE inf_top.left_neutral mult_right_isotone pp_comp_semi_commute)"], ["proof (state)\nthis:\n  pp_arc x\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following operation represents states with infinite executions of non-strict computations.\n\\<close>"], ["", "abbreviation N :: \"'a \\<Rightarrow> 'a\"\n  where \"N x \\<equiv> -(-x * top) \\<sqinter> 1\""], ["", "lemma N_comp:\n  \"N x * y = -(-x * top) \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x * y = - (- x * top) \\<sqinter> y", "by (simp add: vector_mult_closed vector_complement_closed vector_inf_one_comp)"], ["", "lemma N_comp_top [simp]:\n  \"N x * top = -(-x * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x * top = - (- x * top)", "by (simp add: N_comp)"], ["", "lemma vector_N_pp:\n  \"vector x \\<Longrightarrow> N x = --x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> N x = - x '", "by (simp add: vector_complement_closed)"], ["", "lemma N_vector_pp [simp]:\n  \"N (x * top) = --(x * top) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x * top) = - (x * top) '", "by (simp add: comp_associative vector_complement_closed)"], ["", "lemma N_vector_top_pp [simp]:\n  \"N (x * top) * top = --(x * top)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x * top) * top = - - (x * top)", "by (metis N_comp_top comp_associative vector_top_closed vector_complement_closed)"], ["", "lemma N_below_inf_one_pp:\n  \"N x \\<le> --x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x \\<le> - x '", "using inf.sup_left_isotone p_antitone top_right_mult_increasing"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n  ?x \\<le> ?y \\<Longrightarrow> - ?y \\<le> - ?x\n  ?x \\<le> ?x * top\n\ngoal (1 subgoal):\n 1. N x \\<le> - x '", "by auto"], ["", "lemma N_below_pp:\n  \"N x \\<le> --x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x \\<le> - - x", "using N_below_inf_one_pp"], ["proof (prove)\nusing this:\n  N ?x \\<le> - ?x '\n\ngoal (1 subgoal):\n 1. N x \\<le> - - x", "by auto"], ["", "lemma N_comp_N:\n  \"N x * N y = -(-x * top) \\<sqinter> -(-y * top) \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x * N y = - (- x * top) \\<sqinter> - (- y * top) \\<sqinter> (1::'a)", "by (simp add: N_comp inf.mult_assoc)"], ["", "lemma N_bot [simp]:\n  \"N bot = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N bot = bot", "by simp"], ["", "lemma N_top [simp]:\n  \"N top = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N top = (1::'a)", "by simp"], ["", "lemma n_split_omega_mult_pp:\n  \"xs * --xo = xo \\<Longrightarrow> vector xo \\<Longrightarrow> N top * xo = xs * N xo * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs * - - xo = xo; vector xo\\<rbrakk>\n    \\<Longrightarrow> N top * xo = xs * N xo * top", "by (metis N_top N_vector_top_pp comp_associative comp_left_one)"], ["", "text \\<open>\nMany of the following results have been derived for verifying Prim's minimum spanning tree algorithm.\n\\<close>"], ["", "lemma ee:\n  assumes \"vector v\"\n      and \"e \\<le> v * -v\\<^sup>T\"\n    shows \"e * e = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * e = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e * e = bot", "have \"e * v \\<le> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * v \\<le> bot", "by (metis assms covector_vector_comp comp_associative mult_left_isotone mult_right_zero)"], ["proof (state)\nthis:\n  e * v \\<le> bot\n\ngoal (1 subgoal):\n 1. e * e = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  e * v \\<le> bot\n\ngoal (1 subgoal):\n 1. e * e = bot", "by (metis assms(2) bot_unique comp_associative mult_right_isotone semiring.mult_not_zero)"], ["proof (state)\nthis:\n  e * e = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma et:\n  assumes \"vector v\"\n      and \"e \\<le> v * -v\\<^sup>T\"\n      and \"t \\<le> v * v\\<^sup>T\"\n    shows \"e * t = bot\"\n      and \"e * t\\<^sup>T = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * t = bot &&& e * t\\<^sup>T = bot", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. e * t = bot\n 2. e * t\\<^sup>T = bot", "have \"e * t \\<le> v * -v\\<^sup>T * v * v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * t \\<le> v * - v\\<^sup>T * v * v\\<^sup>T", "using assms(2-3) comp_isotone mult_assoc"], ["proof (prove)\nusing this:\n  e \\<le> v * - v\\<^sup>T\n  t \\<le> v * v\\<^sup>T\n  \\<lbrakk>?x \\<le> ?y; ?w \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?x * ?w \\<le> ?y * ?z\n  ?a * ?b * ?c = ?a * (?b * ?c)\n\ngoal (1 subgoal):\n 1. e * t \\<le> v * - v\\<^sup>T * v * v\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  e * t \\<le> v * - v\\<^sup>T * v * v\\<^sup>T\n\ngoal (2 subgoals):\n 1. e * t = bot\n 2. e * t\\<^sup>T = bot", "thus \"e * t = bot\""], ["proof (prove)\nusing this:\n  e * t \\<le> v * - v\\<^sup>T * v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e * t = bot", "by (simp add: assms(1) covector_vector_comp le_bot mult_assoc)"], ["proof (state)\nthis:\n  e * t = bot\n\ngoal (1 subgoal):\n 1. e * t\\<^sup>T = bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e * t\\<^sup>T = bot", "have \"t\\<^sup>T \\<le> v * v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t\\<^sup>T \\<le> v * v\\<^sup>T", "using assms(3) conv_order conv_dist_comp"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T\n  (?x \\<le> ?y) = (?x\\<^sup>T \\<le> ?y\\<^sup>T)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. t\\<^sup>T \\<le> v * v\\<^sup>T", "by fastforce"], ["proof (state)\nthis:\n  t\\<^sup>T \\<le> v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e * t\\<^sup>T = bot", "hence \"e * t\\<^sup>T \\<le> v * -v\\<^sup>T * v * v\\<^sup>T\""], ["proof (prove)\nusing this:\n  t\\<^sup>T \\<le> v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e * t\\<^sup>T \\<le> v * - v\\<^sup>T * v * v\\<^sup>T", "by (metis assms(2) comp_associative comp_isotone)"], ["proof (state)\nthis:\n  e * t\\<^sup>T \\<le> v * - v\\<^sup>T * v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e * t\\<^sup>T = bot", "thus \"e * t\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  e * t\\<^sup>T \\<le> v * - v\\<^sup>T * v * v\\<^sup>T\n\ngoal (1 subgoal):\n 1. e * t\\<^sup>T = bot", "by (simp add: assms(1) covector_vector_comp le_bot mult_assoc)"], ["proof (state)\nthis:\n  e * t\\<^sup>T = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ve_dist:\n  assumes \"e \\<le> v * -v\\<^sup>T\"\n      and \"vector v\"\n      and \"arc e\"\n    shows \"(v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T = v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion> e\\<^sup>T * v * v\\<^sup>T \\<squnion> e\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"e \\<le> v * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> v * top", "using assms(1) comp_right_isotone dual_order.trans top_greatest"], ["proof (prove)\nusing this:\n  e \\<le> v * - v\\<^sup>T\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  ?x \\<le> top\n\ngoal (1 subgoal):\n 1. e \\<le> v * top", "by blast"], ["proof (state)\nthis:\n  e \\<le> v * top\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "hence \"v * top * e = v * top * (v * top \\<sqinter> e)\""], ["proof (prove)\nusing this:\n  e \\<le> v * top\n\ngoal (1 subgoal):\n 1. v * top * e = v * top * (v * top \\<sqinter> e)", "by (simp add: inf.absorb2)"], ["proof (state)\nthis:\n  v * top * e = v * top * (v * top \\<sqinter> e)\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  v * top * e = v * top * (v * top \\<sqinter> e)\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = (v * top \\<sqinter> top * v\\<^sup>T) * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * top * (v * top \\<sqinter> e) =\n    (v * top \\<sqinter> top * v\\<^sup>T) * e", "using assms(2) covector_inf_comp_3 vector_conv_covector"], ["proof (prove)\nusing this:\n  vector v\n  vector ?x \\<Longrightarrow>\n  (?y \\<sqinter> ?x\\<^sup>T) * ?z = ?y * (?x \\<sqinter> ?z)\n  vector ?v = covector (?v\\<^sup>T)\n\ngoal (1 subgoal):\n 1. v * top * (v * top \\<sqinter> e) =\n    (v * top \\<sqinter> top * v\\<^sup>T) * e", "by force"], ["proof (state)\nthis:\n  v * top * (v * top \\<sqinter> e) =\n  (v * top \\<sqinter> top * v\\<^sup>T) * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  v * top * (v * top \\<sqinter> e) =\n  (v * top \\<sqinter> top * v\\<^sup>T) * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = v * top * v\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v * top \\<sqinter> top * v\\<^sup>T) * e = v * top * v\\<^sup>T * e", "by (metis assms(2) inf_top_right vector_inf_comp)"], ["proof (state)\nthis:\n  (v * top \\<sqinter> top * v\\<^sup>T) * e = v * top * v\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  (v * top \\<sqinter> top * v\\<^sup>T) * e = v * top * v\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = v * v\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * top * v\\<^sup>T * e = v * v\\<^sup>T * e", "by (simp add: assms(2))"], ["proof (state)\nthis:\n  v * top * v\\<^sup>T * e = v * v\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "finally"], ["proof (chain)\npicking this:\n  v * top * e = v * v\\<^sup>T * e", "have 1: \"v * top * e = v * v\\<^sup>T * e\""], ["proof (prove)\nusing this:\n  v * top * e = v * v\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. v * top * e = v * v\\<^sup>T * e", "."], ["proof (state)\nthis:\n  v * top * e = v * v\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"e\\<^sup>T * top * e \\<le> e\\<^sup>T * top * e * e\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sup>T * top * e \\<le> e\\<^sup>T * top * e * e\\<^sup>T * e", "using ex231c comp_associative mult_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x * ?x\\<^sup>T * ?x\n  ?x * ?y * ?z = ?x * (?y * ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. e\\<^sup>T * top * e \\<le> e\\<^sup>T * top * e * e\\<^sup>T * e", "by auto"], ["proof (state)\nthis:\n  e\\<^sup>T * top * e \\<le> e\\<^sup>T * top * e * e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  e\\<^sup>T * top * e \\<le> e\\<^sup>T * top * e * e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... \\<le> e\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e\\<^sup>T * top * e * e\\<^sup>T * e \\<le> e\\<^sup>T * e", "by (metis assms(3) coreflexive_comp_top_inf le_infE mult_semi_associative point_injective)"], ["proof (state)\nthis:\n  e\\<^sup>T * top * e * e\\<^sup>T * e \\<le> e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "finally"], ["proof (chain)\npicking this:\n  e\\<^sup>T * top * e \\<le> e\\<^sup>T * e", "have 2: \"e\\<^sup>T * top * e = e\\<^sup>T * e\""], ["proof (prove)\nusing this:\n  e\\<^sup>T * top * e \\<le> e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. e\\<^sup>T * top * e = e\\<^sup>T * e", "by (simp add: inf.antisym mult_left_isotone top_right_mult_increasing)"], ["proof (state)\nthis:\n  e\\<^sup>T * top * e = e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"(v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T = (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e)", "by (simp add: conv_dist_comp conv_dist_sup)"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n  (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e)\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n  (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e)\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = v * v\\<^sup>T \\<squnion> v * top * e \\<squnion> e\\<^sup>T * top * v\\<^sup>T \\<squnion> e\\<^sup>T * top * top * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e) =\n    v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n    e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * top * top * e", "by (metis semiring.distrib_left semiring.distrib_right sup_assoc mult_assoc)"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e) =\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * top * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * (v\\<^sup>T \\<squnion> top * e) =\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * top * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = v * v\\<^sup>T \\<squnion> v * top * e \\<squnion> (v * top * e)\\<^sup>T \\<squnion> e\\<^sup>T * top * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n    e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * top * top * e =\n    v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n    (v * top * e)\\<^sup>T \\<squnion>\n    e\\<^sup>T * top * e", "by (simp add: comp_associative conv_dist_comp)"], ["proof (state)\nthis:\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * top * e =\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  (v * top * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "also"], ["proof (state)\nthis:\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  e\\<^sup>T * top * v\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * top * e =\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  (v * top * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "have \"... = v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion> (v * v\\<^sup>T * e)\\<^sup>T \\<squnion> e\\<^sup>T * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n    (v * top * e)\\<^sup>T \\<squnion>\n    e\\<^sup>T * top * e =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    (v * v\\<^sup>T * e)\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "using 1 2"], ["proof (prove)\nusing this:\n  v * top * e = v * v\\<^sup>T * e\n  e\\<^sup>T * top * e = e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n    (v * top * e)\\<^sup>T \\<squnion>\n    e\\<^sup>T * top * e =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    (v * v\\<^sup>T * e)\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "by simp"], ["proof (state)\nthis:\n  v * v\\<^sup>T \\<squnion> v * top * e \\<squnion>\n  (v * top * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * top * e =\n  v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n  (v * v\\<^sup>T * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "finally"], ["proof (chain)\npicking this:\n  (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n  v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n  (v * v\\<^sup>T * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * e", "show ?thesis"], ["proof (prove)\nusing this:\n  (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n  v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n  (v * v\\<^sup>T * e)\\<^sup>T \\<squnion>\n  e\\<^sup>T * e\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) *\n    (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n    v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n    e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n    e\\<^sup>T * e", "by (simp add: comp_associative conv_dist_comp)"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T =\n  v * v\\<^sup>T \\<squnion> v * v\\<^sup>T * e \\<squnion>\n  e\\<^sup>T * v * v\\<^sup>T \\<squnion>\n  e\\<^sup>T * e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ev:\n  \"vector v \\<Longrightarrow> e \\<le> v * -v\\<^sup>T \\<Longrightarrow> e * v = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector v; e \\<le> v * - v\\<^sup>T\\<rbrakk>\n    \\<Longrightarrow> e * v = bot", "by (metis covector_vector_comp antisym bot_least comp_associative mult_left_isotone mult_right_zero)"], ["", "lemma vTeT:\n  \"vector v \\<Longrightarrow> e \\<le> v * -v\\<^sup>T \\<Longrightarrow> v\\<^sup>T * e\\<^sup>T = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector v; e \\<le> v * - v\\<^sup>T\\<rbrakk>\n    \\<Longrightarrow> v\\<^sup>T * e\\<^sup>T = bot", "using conv_bot ev conv_dist_comp"], ["proof (prove)\nusing this:\n  symmetric bot\n  \\<lbrakk>vector ?v; ?e \\<le> ?v * - ?v\\<^sup>T\\<rbrakk>\n  \\<Longrightarrow> ?e * ?v = bot\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>vector v; e \\<le> v * - v\\<^sup>T\\<rbrakk>\n    \\<Longrightarrow> v\\<^sup>T * e\\<^sup>T = bot", "by fastforce"], ["", "text \\<open>\nThe following result is used to show that the while-loop of Prim's algorithm preserves that the constructed tree is a subgraph of g.\n\\<close>"], ["", "lemma prim_subgraph_inv:\n  assumes \"e \\<le> v * -v\\<^sup>T \\<sqinter> g\"\n      and \"t \\<le> v * v\\<^sup>T \\<sqinter> g\"\n    shows \"t \\<squnion> e \\<le> ((v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T) \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<squnion> e\n    \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "proof (rule sup_least)"], ["proof (state)\ngoal (2 subgoals):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g\n 2. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"t \\<le> ((v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T) \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g", "using assms(2) le_supI1 mult_right_dist_sup"], ["proof (prove)\nusing this:\n  t \\<le> v * v\\<^sup>T \\<sqinter> g\n  ?x \\<le> ?a \\<Longrightarrow> ?x \\<le> ?a \\<squnion> ?b\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n\ngoal (1 subgoal):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g", "by auto"], ["proof (state)\nthis:\n  t \\<le> (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g\n\ngoal (2 subgoals):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g\n 2. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "also"], ["proof (state)\nthis:\n  t \\<le> (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g\n\ngoal (2 subgoals):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g\n 2. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"... \\<le> ((v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T) \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g\n    \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "using comp_right_isotone conv_dist_sup inf.sup_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n\ngoal (1 subgoal):\n 1. (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g\n    \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "by auto"], ["proof (state)\nthis:\n  (v \\<squnion> e\\<^sup>T * top) * v\\<^sup>T \\<sqinter> g\n  \\<le> (v \\<squnion> e\\<^sup>T * top) *\n        (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n        g\n\ngoal (2 subgoals):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g\n 2. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "finally"], ["proof (chain)\npicking this:\n  t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "show \"t \\<le> ((v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T) \\<sqinter> g\""], ["proof (prove)\nusing this:\n  t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g\n\ngoal (1 subgoal):\n 1. t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "."], ["proof (state)\nthis:\n  t \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"e \\<le> v * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<le> v * top", "by (meson assms(1) inf.boundedE mult_right_isotone order.trans top.extremum)"], ["proof (state)\nthis:\n  e \\<le> v * top\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "hence \"e \\<le> v * top \\<sqinter> top * e\""], ["proof (prove)\nusing this:\n  e \\<le> v * top\n\ngoal (1 subgoal):\n 1. e \\<le> v * top \\<sqinter> top * e", "by (simp add: top_left_mult_increasing)"], ["proof (state)\nthis:\n  e \\<le> v * top \\<sqinter> top * e\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "also"], ["proof (state)\nthis:\n  e \\<le> v * top \\<sqinter> top * e\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"... = v * top * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * top \\<sqinter> top * e = v * top * e", "by (metis inf_top_right vector_export_comp)"], ["proof (state)\nthis:\n  v * top \\<sqinter> top * e = v * top * e\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "finally"], ["proof (chain)\npicking this:\n  e \\<le> v * top * e", "have \"e \\<le> v * top * e \\<sqinter> g\""], ["proof (prove)\nusing this:\n  e \\<le> v * top * e\n\ngoal (1 subgoal):\n 1. e \\<le> v * top * e \\<sqinter> g", "using assms(1)"], ["proof (prove)\nusing this:\n  e \\<le> v * top * e\n  e \\<le> v * - v\\<^sup>T \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> v * top * e \\<sqinter> g", "by auto"], ["proof (state)\nthis:\n  e \\<le> v * top * e \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "also"], ["proof (state)\nthis:\n  e \\<le> v * top * e \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"... = v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * top * e \\<sqinter> g = v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g", "by (simp add: comp_associative conv_dist_comp)"], ["proof (state)\nthis:\n  v * top * e \\<sqinter> g = v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "also"], ["proof (state)\nthis:\n  v * top * e \\<sqinter> g = v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"... \\<le> v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n    \\<le> v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g", "by (simp add: conv_dist_sup mult_left_dist_sup sup.assoc sup.orderI)"], ["proof (state)\nthis:\n  v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n  \\<le> v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "also"], ["proof (state)\nthis:\n  v * (e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n  \\<le> v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "have \"... \\<le> (v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n    \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "using inf.sup_left_isotone mult_right_sub_dist_sup_left"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n  ?x * ?z \\<le> (?x \\<squnion> ?y) * ?z\n\ngoal (1 subgoal):\n 1. v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n    \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "by auto"], ["proof (state)\nthis:\n  v * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter> g\n  \\<le> (v \\<squnion> e\\<^sup>T * top) *\n        (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n        g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "finally"], ["proof (chain)\npicking this:\n  e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g", "show \"e \\<le> ((v \\<squnion> e\\<^sup>T * top) * (v \\<squnion> e\\<^sup>T * top)\\<^sup>T) \\<sqinter> g\""], ["proof (prove)\nusing this:\n  e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g\n\ngoal (1 subgoal):\n 1. e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n            (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n            g", "."], ["proof (state)\nthis:\n  e \\<le> (v \\<squnion> e\\<^sup>T * top) *\n          (v \\<squnion> e\\<^sup>T * top)\\<^sup>T \\<sqinter>\n          g\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nThe following result shows how to apply the Schr\\\"oder equivalence to the middle factor in a composition of three relations.\nAgain the elements on the right-hand side need to be pseudocomplemented.\n\\<close>"], ["", "lemma triple_schroeder_p:\n  \"x * y * z \\<le> -w \\<longleftrightarrow> x\\<^sup>T * w * z\\<^sup>T \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y * z \\<le> - w) = (x\\<^sup>T * w * z\\<^sup>T \\<le> - y)", "using mult_assoc p_antitone_iff schroeder_3_p schroeder_4_p"], ["proof (prove)\nusing this:\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n  (?x * ?y \\<le> - ?z) = (?x\\<^sup>T * ?z \\<le> - ?y)\n  (?x * ?y \\<le> - ?z) = (?z * ?y\\<^sup>T \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. (x * y * z \\<le> - w) = (x\\<^sup>T * w * z\\<^sup>T \\<le> - y)", "by auto"], ["", "text \\<open>\nThe rotation versions of the Schr\\\"oder equivalences continue to hold, again with pseudocomplemented elements on the right-hand side.\n\\<close>"], ["", "lemma schroeder_5_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> y * z\\<^sup>T \\<le> -x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (y * z\\<^sup>T \\<le> - x\\<^sup>T)", "using schroeder_3_p schroeder_4_p"], ["proof (prove)\nusing this:\n  (?x * ?y \\<le> - ?z) = (?x\\<^sup>T * ?z \\<le> - ?y)\n  (?x * ?y \\<le> - ?z) = (?z * ?y\\<^sup>T \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (y * z\\<^sup>T \\<le> - x\\<^sup>T)", "by auto"], ["", "lemma schroeder_6_p:\n  \"x * y \\<le> -z \\<longleftrightarrow> z\\<^sup>T * x \\<le> -y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (z\\<^sup>T * x \\<le> - y\\<^sup>T)", "using schroeder_3_p schroeder_4_p"], ["proof (prove)\nusing this:\n  (?x * ?y \\<le> - ?z) = (?x\\<^sup>T * ?z \\<le> - ?y)\n  (?x * ?y \\<le> - ?z) = (?z * ?y\\<^sup>T \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. (x * y \\<le> - z) = (z\\<^sup>T * x \\<le> - y\\<^sup>T)", "by auto"], ["", "lemma vector_conv_compl:\n  \"vector v \\<Longrightarrow> top * -v\\<^sup>T = -v\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v \\<Longrightarrow> covector (- v\\<^sup>T)", "by (simp add: covector_complement_closed vector_conv_covector)"], ["", "text \\<open>\nComposition commutes, relative to the diversity relation.\n\\<close>"], ["", "lemma comp_commute_below_diversity:\n  \"x * y \\<le> -1 \\<longleftrightarrow> y * x \\<le> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreflexive (x * y) = irreflexive (y * x)", "by (metis comp_right_one conv_dist_comp conv_one schroeder_3_p schroeder_4_p)"], ["", "lemma comp_injective_below_complement:\n  \"injective y \\<Longrightarrow> -x * y \\<le> -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective y \\<Longrightarrow> - x * y \\<le> - (x * y)", "by (metis p_antitone_iff comp_associative comp_right_isotone comp_right_one schroeder_4_p)"], ["", "lemma comp_univalent_below_complement:\n  \"univalent x \\<Longrightarrow> x * -y \\<le> -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent x \\<Longrightarrow> x * - y \\<le> - (x * y)", "by (metis p_inf pseudo_complement semiring.mult_zero_right univalent_comp_left_dist_inf)"], ["", "text \\<open>\nBijective relations and mappings can be exported from a pseudocomplement.\n\\<close>"], ["", "lemma comp_bijective_complement:\n  \"bijective y \\<Longrightarrow> -x * y = -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective y \\<Longrightarrow> - x * y = - (x * y)", "using comp_injective_below_complement complement_conv_sub antisym shunt_bijective"], ["proof (prove)\nusing this:\n  injective ?y \\<Longrightarrow> - ?x * ?y \\<le> - (?x * ?y)\n  - (?y * ?x) * ?x\\<^sup>T \\<le> - ?y\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  bijective ?z \\<Longrightarrow>\n  (?x \\<le> ?y * ?z) = (?x * ?z\\<^sup>T \\<le> ?y)\n\ngoal (1 subgoal):\n 1. bijective y \\<Longrightarrow> - x * y = - (x * y)", "by blast"], ["", "lemma comp_mapping_complement:\n  \"mapping x \\<Longrightarrow> x * -y = -(x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping x \\<Longrightarrow> x * - y = - (x * y)", "by (metis (full_types) comp_bijective_complement conv_complement conv_dist_comp conv_involutive total_conv_surjective)"], ["", "text \\<open>\nThe following facts are used in the correctness proof of Kruskal's minimum spanning tree algorithm.\n\\<close>"], ["", "lemma kruskal_injective_inv:\n  assumes \"injective f\"\n      and \"covector q\"\n      and \"q * f\\<^sup>T \\<le> q\"\n      and \"e \\<le> q\"\n      and \"q * f\\<^sup>T \\<le> -e\"\n      and \"injective e\"\n      and \"q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f \\<le> 1\"\n    shows \"injective ((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 1: \"(f \\<sqinter> -q) * (f \\<sqinter> -q)\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (f \\<sqinter> - q)", "by (simp add: assms(1) injective_inf_closed)"], ["proof (state)\nthis:\n  injective (f \\<sqinter> - q)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 2: \"(f \\<sqinter> -q) * (f \\<sqinter> q) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "have 21: \"bot = q * f\\<^sup>T \\<sqinter> - q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bot = q * f\\<^sup>T \\<sqinter> - q", "by (metis assms(3) inf.sup_monoid.add_assoc inf.sup_right_divisibility inf_import_p inf_p)"], ["proof (state)\nthis:\n  bot = q * f\\<^sup>T \\<sqinter> - q\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "have \"(f \\<sqinter> -q) * (f \\<sqinter> q) \\<le> -q * f \\<sqinter> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<sqinter> - q) * (f \\<sqinter> q) \\<le> - q * f \\<sqinter> q", "by (metis assms(2) comp_inf_covector comp_isotone inf.cobounded2 inf.left_idem)"], ["proof (state)\nthis:\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<le> - q * f \\<sqinter> q\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "also"], ["proof (state)\nthis:\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<le> - q * f \\<sqinter> q\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - q * f \\<sqinter> q = bot", "using 21 schroeder_2"], ["proof (prove)\nusing this:\n  bot = q * f\\<^sup>T \\<sqinter> - q\n  (?x * ?y \\<sqinter> ?z = bot) = (?z * ?y\\<^sup>T \\<sqinter> ?x = bot)\n\ngoal (1 subgoal):\n 1. - q * f \\<sqinter> q = bot", "by auto"], ["proof (state)\nthis:\n  - q * f \\<sqinter> q = bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "finally"], ["proof (chain)\npicking this:\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<le> bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<le> bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))", "by (simp add: bot_unique)"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 3: \"(f \\<sqinter> -q) * e\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "have \"(f \\<sqinter> -q) * e\\<^sup>T \\<le> -q * e\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<sqinter> - q) * e\\<^sup>T \\<le> - q * e\\<^sup>T", "by (simp add: mult_left_isotone)"], ["proof (state)\nthis:\n  (f \\<sqinter> - q) * e\\<^sup>T \\<le> - q * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "also"], ["proof (state)\nthis:\n  (f \\<sqinter> - q) * e\\<^sup>T \\<le> - q * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "have \"... = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - q * e\\<^sup>T = bot", "by (metis assms(2,4) bot_unique conv_bot conv_complement covector_complement_closed p_antitone p_bot regular_closed_bot schroeder_5_p)"], ["proof (state)\nthis:\n  - q * e\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "finally"], ["proof (chain)\npicking this:\n  (f \\<sqinter> - q) * e\\<^sup>T \\<le> bot", "show ?thesis"], ["proof (prove)\nusing this:\n  (f \\<sqinter> - q) * e\\<^sup>T \\<le> bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)", "by (simp add: bot_unique)"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 4: \"(f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> -q)\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T)", "using 2 conv_dist_comp conv_isotone"], ["proof (prove)\nusing this:\n  coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T)", "by force"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 5: \"(f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "have \"(f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<le> q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q)\n    \\<le> q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f", "by (simp add: conv_isotone mult_isotone)"], ["proof (state)\nthis:\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q)\n  \\<le> q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f\n\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "also"], ["proof (state)\nthis:\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q)\n  \\<le> q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f\n\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "have \"... \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f)", "by (simp add: assms(7))"], ["proof (state)\nthis:\n  coreflexive (q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f)\n\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "finally"], ["proof (chain)\npicking this:\n  univalent (f \\<sqinter> q)", "show ?thesis"], ["proof (prove)\nusing this:\n  univalent (f \\<sqinter> q)\n\ngoal (1 subgoal):\n 1. univalent (f \\<sqinter> q)", "by simp"], ["proof (state)\nthis:\n  univalent (f \\<sqinter> q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  univalent (f \\<sqinter> q)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 6: \"(f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)", "have \"f\\<^sup>T * e\\<^sup>T \\<le> -q\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<^sup>T * e\\<^sup>T \\<le> - q\\<^sup>T", "using assms(5) schroeder_5_p"], ["proof (prove)\nusing this:\n  q * f\\<^sup>T \\<le> - e\n  (?x * ?y \\<le> - ?z) = (?y * ?z\\<^sup>T \\<le> - ?x\\<^sup>T)\n\ngoal (1 subgoal):\n 1. f\\<^sup>T * e\\<^sup>T \\<le> - q\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  f\\<^sup>T * e\\<^sup>T \\<le> - q\\<^sup>T\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)", "hence \"(f \\<sqinter> q)\\<^sup>T * e\\<^sup>T = bot\""], ["proof (prove)\nusing this:\n  f\\<^sup>T * e\\<^sup>T \\<le> - q\\<^sup>T\n\ngoal (1 subgoal):\n 1. (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T = bot", "by (metis assms(2,5) conv_bot conv_dist_comp covector_comp_inf inf.absorb1 inf.cobounded2 inf.sup_monoid.add_commute inf_left_commute inf_p schroeder_4_p)"], ["proof (state)\nthis:\n  (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T = bot\n\ngoal (1 subgoal):\n 1. coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)", "by (simp add: bot_unique)"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 7: \"e * (f \\<sqinter> -q)\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (e * (f \\<sqinter> - q)\\<^sup>T)", "using 3 conv_dist_comp coreflexive_symmetric"], ["proof (prove)\nusing this:\n  coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n  coreflexive ?x \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. coreflexive (e * (f \\<sqinter> - q)\\<^sup>T)", "by fastforce"], ["proof (state)\nthis:\n  coreflexive (e * (f \\<sqinter> - q)\\<^sup>T)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 8: \"e * (f \\<sqinter> q) \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (e * (f \\<sqinter> q))", "using 6 conv_dist_comp coreflexive_symmetric"], ["proof (prove)\nusing this:\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)\n  (?x * ?y)\\<^sup>T = ?y\\<^sup>T * ?x\\<^sup>T\n  coreflexive ?x \\<Longrightarrow> symmetric ?x\n\ngoal (1 subgoal):\n 1. coreflexive (e * (f \\<sqinter> q))", "by fastforce"], ["proof (state)\nthis:\n  coreflexive (e * (f \\<sqinter> q))\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have 9: \"e * e\\<^sup>T \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective e", "by (simp add: assms(6))"], ["proof (state)\nthis:\n  injective e\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have \"((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e) * ((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)\\<^sup>T = (f \\<sqinter> -q) * (f \\<sqinter> -q)\\<^sup>T \\<squnion> (f \\<sqinter> -q) * (f \\<sqinter> q) \\<squnion> (f \\<sqinter> -q) * e\\<^sup>T \\<squnion> (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> -q)\\<^sup>T \\<squnion> (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion> (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion> e * (f \\<sqinter> -q)\\<^sup>T \\<squnion> e * (f \\<sqinter> q) \\<squnion> e * e\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e) *\n    (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion>\n     e)\\<^sup>T =\n    (f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> q) \\<squnion>\n    e * e\\<^sup>T", "using comp_left_dist_sup comp_right_dist_sup conv_dist_sup sup.assoc"], ["proof (prove)\nusing this:\n  ?x * ?y \\<squnion> ?x * ?z = ?x * (?y \\<squnion> ?z)\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  (?x \\<squnion> ?y)\\<^sup>T = ?x\\<^sup>T \\<squnion> ?y\\<^sup>T\n  ?a \\<squnion> ?b \\<squnion> ?c = ?a \\<squnion> (?b \\<squnion> ?c)\n\ngoal (1 subgoal):\n 1. (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e) *\n    (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion>\n     e)\\<^sup>T =\n    (f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> q) \\<squnion>\n    e * e\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e) *\n  (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion>\n   e)\\<^sup>T =\n  (f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n  (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n  e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  e * (f \\<sqinter> q) \\<squnion>\n  e * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "also"], ["proof (state)\nthis:\n  (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e) *\n  (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion>\n   e)\\<^sup>T =\n  (f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n  (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n  (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n  e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n  e * (f \\<sqinter> q) \\<squnion>\n  e * e\\<^sup>T\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "have \"... \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive\n     ((f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n      (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n      e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      e * (f \\<sqinter> q) \\<squnion>\n      e * e\\<^sup>T)", "using 1 2 3 4 5 6 7 8 9"], ["proof (prove)\nusing this:\n  injective (f \\<sqinter> - q)\n  coreflexive ((f \\<sqinter> - q) * (f \\<sqinter> q))\n  coreflexive ((f \\<sqinter> - q) * e\\<^sup>T)\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T)\n  univalent (f \\<sqinter> q)\n  coreflexive ((f \\<sqinter> q)\\<^sup>T * e\\<^sup>T)\n  coreflexive (e * (f \\<sqinter> - q)\\<^sup>T)\n  coreflexive (e * (f \\<sqinter> q))\n  injective e\n\ngoal (1 subgoal):\n 1. coreflexive\n     ((f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n      (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n      (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n      e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n      e * (f \\<sqinter> q) \\<squnion>\n      e * e\\<^sup>T)", "by simp"], ["proof (state)\nthis:\n  coreflexive\n   ((f \\<sqinter> - q) * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> - q) * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> - q) * e\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * (f \\<sqinter> q) \\<squnion>\n    (f \\<sqinter> q)\\<^sup>T * e\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> - q)\\<^sup>T \\<squnion>\n    e * (f \\<sqinter> q) \\<squnion>\n    e * e\\<^sup>T)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "finally"], ["proof (chain)\npicking this:\n  injective\n   (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "show ?thesis"], ["proof (prove)\nusing this:\n  injective\n   (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)\n\ngoal (1 subgoal):\n 1. injective\n     (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)", "by simp"], ["proof (state)\nthis:\n  injective\n   (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kruskal_exchange_injective_inv_1:\n  assumes \"injective f\"\n      and \"covector q\"\n      and \"q * f\\<^sup>T \\<le> q\"\n      and \"q\\<^sup>T * q \\<sqinter> f\\<^sup>T * f \\<le> 1\"\n    shows \"injective ((f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. injective (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T)", "using kruskal_injective_inv[where e=bot]"], ["proof (prove)\nusing this:\n  \\<lbrakk>injective ?f; covector ?q; ?q * ?f\\<^sup>T \\<le> ?q;\n   bot \\<le> ?q; ?q * ?f\\<^sup>T \\<le> - bot; injective bot;\n   coreflexive (?q\\<^sup>T * ?q \\<sqinter> ?f\\<^sup>T * ?f)\\<rbrakk>\n  \\<Longrightarrow> injective\n                     (?f \\<sqinter> - ?q \\<squnion>\n                      (?f \\<sqinter> ?q)\\<^sup>T \\<squnion>\n                      bot)\n\ngoal (1 subgoal):\n 1. injective (f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T)", "by (simp add: assms)"], ["", "lemma kruskal_exchange_acyclic_inv_3:\n  assumes \"injective w\"\n      and \"d \\<le> w\"\n    shows \"(w \\<sqinter> -d) * d\\<^sup>T * top = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "have \"(w \\<sqinter> -d) * d\\<^sup>T * top = (w \\<sqinter> -d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top =\n    (w \\<sqinter> - d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top", "by (simp add: comp_associative comp_inf_vector_1 conv_dist_comp)"], ["proof (state)\nthis:\n  (w \\<sqinter> - d) * d\\<^sup>T * top =\n  (w \\<sqinter> - d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top\n\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "also"], ["proof (state)\nthis:\n  (w \\<sqinter> - d) * d\\<^sup>T * top =\n  (w \\<sqinter> - d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top\n\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "have \"... = (w \\<sqinter> top * d \\<sqinter> -d) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top =\n    (w \\<sqinter> top * d \\<sqinter> - d) * top", "by (simp add: conv_dist_comp inf_commute inf_left_commute)"], ["proof (state)\nthis:\n  (w \\<sqinter> - d \\<sqinter> (d\\<^sup>T * top)\\<^sup>T) * top =\n  (w \\<sqinter> top * d \\<sqinter> - d) * top\n\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "finally"], ["proof (chain)\npicking this:\n  (w \\<sqinter> - d) * d\\<^sup>T * top =\n  (w \\<sqinter> top * d \\<sqinter> - d) * top", "show ?thesis"], ["proof (prove)\nusing this:\n  (w \\<sqinter> - d) * d\\<^sup>T * top =\n  (w \\<sqinter> top * d \\<sqinter> - d) * top\n\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "using assms epm_3"], ["proof (prove)\nusing this:\n  (w \\<sqinter> - d) * d\\<^sup>T * top =\n  (w \\<sqinter> top * d \\<sqinter> - d) * top\n  injective w\n  d \\<le> w\n  \\<lbrakk>?e \\<le> ?w; injective ?w\\<rbrakk>\n  \\<Longrightarrow> ?e = ?w \\<sqinter> top * ?e\n\ngoal (1 subgoal):\n 1. (w \\<sqinter> - d) * d\\<^sup>T * top = bot", "by simp"], ["proof (state)\nthis:\n  (w \\<sqinter> - d) * d\\<^sup>T * top = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma kruskal_subgraph_inv:\n  assumes \"f \\<le> --(-h \\<sqinter> g)\"\n      and \"e \\<le> --g\"\n      and \"symmetric h\"\n      and \"symmetric g\"\n    shows \"(f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e \\<le> --(-(h \\<sqinter> -e \\<sqinter> -e\\<^sup>T) \\<sqinter> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "let ?f = \"(f \\<sqinter> -q) \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "let ?h = \"h \\<sqinter> -e \\<sqinter> -e\\<^sup>T\""], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "have 1: \"f \\<sqinter> -q \\<le> -h \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<le> - h \\<sqinter> - - g", "using assms(1) inf.coboundedI1"], ["proof (prove)\nusing this:\n  f \\<le> - - (- h \\<sqinter> g)\n  ?a \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<le> - h \\<sqinter> - - g", "by simp"], ["proof (state)\nthis:\n  f \\<sqinter> - q \\<le> - h \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "have \"(f \\<sqinter> q)\\<^sup>T \\<le> (-h \\<sqinter> --g)\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<sqinter> q)\\<^sup>T \\<le> (- h \\<sqinter> - - g)\\<^sup>T", "using assms(1) inf.coboundedI1 conv_isotone"], ["proof (prove)\nusing this:\n  f \\<le> - - (- h \\<sqinter> g)\n  ?a \\<le> ?c \\<Longrightarrow> ?a \\<sqinter> ?b \\<le> ?c\n  ?x \\<le> ?y \\<Longrightarrow> ?x\\<^sup>T \\<le> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. (f \\<sqinter> q)\\<^sup>T \\<le> (- h \\<sqinter> - - g)\\<^sup>T", "by simp"], ["proof (state)\nthis:\n  (f \\<sqinter> q)\\<^sup>T \\<le> (- h \\<sqinter> - - g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  (f \\<sqinter> q)\\<^sup>T \\<le> (- h \\<sqinter> - - g)\\<^sup>T\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "have \"... = -h \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric (- h \\<sqinter> - - g)", "using assms(3,4) conv_complement conv_dist_inf"], ["proof (prove)\nusing this:\n  symmetric h\n  symmetric g\n  (- ?x)\\<^sup>T = - ?x\\<^sup>T\n  (?x \\<sqinter> ?y)\\<^sup>T = ?x\\<^sup>T \\<sqinter> ?y\\<^sup>T\n\ngoal (1 subgoal):\n 1. symmetric (- h \\<sqinter> - - g)", "by simp"], ["proof (state)\nthis:\n  symmetric (- h \\<sqinter> - - g)\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "finally"], ["proof (chain)\npicking this:\n  (f \\<sqinter> q)\\<^sup>T \\<le> - h \\<sqinter> - - g", "have \"?f \\<le> (-h \\<sqinter> --g) \\<squnion> (e \\<sqinter> --g)\""], ["proof (prove)\nusing this:\n  (f \\<sqinter> q)\\<^sup>T \\<le> - h \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g", "using 1 assms(2) inf.absorb1 semiring.add_right_mono"], ["proof (prove)\nusing this:\n  (f \\<sqinter> q)\\<^sup>T \\<le> - h \\<sqinter> - - g\n  f \\<sqinter> - q \\<le> - h \\<sqinter> - - g\n  e \\<le> - - g\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<sqinter> ?b = ?a\n  ?a \\<le> ?b \\<Longrightarrow> ?a \\<squnion> ?c \\<le> ?b \\<squnion> ?c\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g", "by simp"], ["proof (state)\nthis:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "have \"... \\<le> (-h \\<squnion> --e) \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g\n    \\<le> (- h \\<squnion> - - e) \\<sqinter> - - g", "by (simp add: inf.coboundedI1 le_supI2 pp_increasing)"], ["proof (state)\nthis:\n  - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g\n  \\<le> (- h \\<squnion> - - e) \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "also"], ["proof (state)\nthis:\n  - h \\<sqinter> - - g \\<squnion> e \\<sqinter> - - g\n  \\<le> (- h \\<squnion> - - e) \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "have \"... \\<le> -?h \\<sqinter> --g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- h \\<squnion> - - e) \\<sqinter> - - g\n    \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g", "using inf.sup_left_isotone order_trans p_antitone_inf p_supdist_inf"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?y \\<sqinter> ?z \\<le> ?x \\<sqinter> ?z\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  - ?x \\<le> - (?x \\<sqinter> ?y)\n  - ?x \\<squnion> - ?y \\<le> - (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. (- h \\<squnion> - - e) \\<sqinter> - - g\n    \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g", "by blast"], ["proof (state)\nthis:\n  (- h \\<squnion> - - e) \\<sqinter> - - g\n  \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "finally"], ["proof (chain)\npicking this:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g", "show \"?f \\<le> --(-?h \\<sqinter> g)\""], ["proof (prove)\nusing this:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "using inf_pp_semi_commute order_lesseq_imp"], ["proof (prove)\nusing this:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> - - g\n  ?x \\<sqinter> - - ?y \\<le> - - (?x \\<sqinter> ?y)\n  (\\<forall>z\\<ge>?x. ?y \\<le> z) = (?y \\<le> ?x)\n\ngoal (1 subgoal):\n 1. f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n    \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)", "by blast"], ["proof (state)\nthis:\n  f \\<sqinter> - q \\<squnion> (f \\<sqinter> q)\\<^sup>T \\<squnion> e\n  \\<le> - - (- (h \\<sqinter> - e \\<sqinter> - e\\<^sup>T) \\<sqinter> g)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \\<open>Stone Relation Algebras\\<close>"], ["", "text \\<open>\nWe add \\<open>pp_dist_comp\\<close> and \\<open>pp_one\\<close>, which follow in relation algebras but not in the present setting.\nThe main change is that only a Stone algebra is required, not a Boolean algebra.\n\\<close>"], ["", "class stone_relation_algebra = pd_allegory + stone_algebra +\n  assumes pp_dist_comp : \"--(x * y) = --x * --y\"\n  assumes pp_one [simp]: \"--1 = 1\"\nbegin"], ["", "text \\<open>\nThe following property is a simple consequence of the Stone axiom.\nWe cannot hope to remove the double complement in it.\n\\<close>"], ["", "lemma conv_complement_0_p [simp]:\n  \"(-x)\\<^sup>T \\<squnion> (--x)\\<^sup>T = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x)\\<^sup>T \\<squnion> (- - x)\\<^sup>T = top", "by (metis conv_top conv_dist_sup stone)"], ["", "lemma theorem24xxiv_pp:\n  \"-(x * y) \\<squnion> --(x * z) = -(x * (y \\<sqinter> -z)) \\<squnion> --(x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * y) \\<squnion> - - (x * z) =\n    - (x * (y \\<sqinter> - z)) \\<squnion> - - (x * z)", "by (metis p_dist_inf theorem24xxiii)"], ["", "lemma asymmetric_linear:\n  \"asymmetric x \\<longleftrightarrow> linear (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. asymmetric x = linear (- x)", "by (metis conv_complement inf.distrib_left inf_p maddux_3_11_pp p_bot p_dist_inf)"], ["", "lemma strict_linear_asymmetric:\n  \"strict_linear x \\<Longrightarrow> antisymmetric (-x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear x \\<Longrightarrow> antisymmetric (- x)", "by (metis conv_complement eq_refl p_dist_sup pp_one)"], ["", "lemma regular_complement_top:\n  \"regular x \\<Longrightarrow> x \\<squnion> -x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x \\<Longrightarrow> x \\<squnion> - x = top", "by (metis stone)"], ["", "lemma regular_mult_closed:\n  \"regular x \\<Longrightarrow> regular y \\<Longrightarrow> regular (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>regular x; regular y\\<rbrakk> \\<Longrightarrow> regular (x * y)", "by (simp add: pp_dist_comp)"], ["", "lemma regular_one_closed:\n  \"regular 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular (1::'a)", "by simp"], ["", "text \\<open>\nThe following variants of total and surjective are useful for graphs.\n\\<close>"], ["", "lemma pp_total:\n  \"total (--x) \\<longleftrightarrow> -(x*top) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total (- - x) = dense (x * top)", "by (simp add: dense_pp pp_dist_comp)"], ["", "lemma pp_surjective:\n  \"surjective (--x) \\<longleftrightarrow> -(top*x) = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective (- - x) = dense (top * x)", "by (metis p_bot p_comp_pp p_top pp_dist_comp)"], ["", "text \\<open>\nBijective elements and mappings are necessarily regular, that is, invariant under double-complement.\nThis implies that points are regular.\nMoreover, also arcs are regular.\n\\<close>"], ["", "lemma bijective_regular:\n  \"bijective x \\<Longrightarrow> regular x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bijective x \\<Longrightarrow> regular x", "by (metis comp_bijective_complement mult_left_one regular_one_closed)"], ["", "lemma mapping_regular:\n  \"mapping x \\<Longrightarrow> regular x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping x \\<Longrightarrow> regular x", "by (metis bijective_regular conv_complement conv_involutive total_conv_surjective)"], ["", "lemma arc_regular:\n  assumes \"arc x\"\n    shows \"regular x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. regular x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. regular x", "have \"--x \\<le> --(x * top \\<sqinter> top * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - x \\<le> - - (x * top \\<sqinter> top * x)", "by (simp add: pp_isotone top_left_mult_increasing top_right_mult_increasing)"], ["proof (state)\nthis:\n  - - x \\<le> - - (x * top \\<sqinter> top * x)\n\ngoal (1 subgoal):\n 1. regular x", "also"], ["proof (state)\nthis:\n  - - x \\<le> - - (x * top \\<sqinter> top * x)\n\ngoal (1 subgoal):\n 1. regular x", "have \"... = --(x * top) \\<sqinter> --(top * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x * top \\<sqinter> top * x) =\n    - - (x * top) \\<sqinter> - - (top * x)", "by simp"], ["proof (state)\nthis:\n  - - (x * top \\<sqinter> top * x) = - - (x * top) \\<sqinter> - - (top * x)\n\ngoal (1 subgoal):\n 1. regular x", "also"], ["proof (state)\nthis:\n  - - (x * top \\<sqinter> top * x) = - - (x * top) \\<sqinter> - - (top * x)\n\ngoal (1 subgoal):\n 1. regular x", "have \"... = x * top \\<sqinter> top * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - - (x * top) \\<sqinter> - - (top * x) = x * top \\<sqinter> top * x", "by (metis assms bijective_regular conv_top conv_dist_comp conv_involutive mapping_regular)"], ["proof (state)\nthis:\n  - - (x * top) \\<sqinter> - - (top * x) = x * top \\<sqinter> top * x\n\ngoal (1 subgoal):\n 1. regular x", "also"], ["proof (state)\nthis:\n  - - (x * top) \\<sqinter> - - (top * x) = x * top \\<sqinter> top * x\n\ngoal (1 subgoal):\n 1. regular x", "have \"... \\<le> x * x\\<^sup>T * top * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * top \\<sqinter> top * x \\<le> x * x\\<^sup>T * top * x", "by (metis comp_associative dedekind_1 inf.commute inf_top.right_neutral)"], ["proof (state)\nthis:\n  x * top \\<sqinter> top * x \\<le> x * x\\<^sup>T * top * x\n\ngoal (1 subgoal):\n 1. regular x", "also"], ["proof (state)\nthis:\n  x * top \\<sqinter> top * x \\<le> x * x\\<^sup>T * top * x\n\ngoal (1 subgoal):\n 1. regular x", "have \"... \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * x\\<^sup>T * top * x \\<le> x", "by (metis assms comp_right_one conv_top comp_associative conv_dist_comp conv_involutive mult_right_isotone vector_top_closed)"], ["proof (state)\nthis:\n  x * x\\<^sup>T * top * x \\<le> x\n\ngoal (1 subgoal):\n 1. regular x", "finally"], ["proof (chain)\npicking this:\n  - - x \\<le> x", "show ?thesis"], ["proof (prove)\nusing this:\n  - - x \\<le> x\n\ngoal (1 subgoal):\n 1. regular x", "by (simp add: antisym pp_increasing)"], ["proof (state)\nthis:\n  regular x\n\ngoal:\nNo subgoals!", "qed"], ["", "(*\nlemma conv_complement_0 [simp]: \"x\\<^sup>T \\<squnion> (-x)\\<^sup>T = top\" nitpick [expect=genuine] oops\nlemma schroeder_3: \"x * y \\<le> z \\<longleftrightarrow> x\\<^sup>T * -z \\<le> -y\" nitpick [expect=genuine] oops\nlemma schroeder_4: \"x * y \\<le> z \\<longleftrightarrow> -z * y\\<^sup>T \\<le> -x\" nitpick [expect=genuine] oops\nlemma theorem24xxiv: \"-(x * y) \\<squnion> (x * z) = -(x * (y \\<sqinter> -z)) \\<squnion> (x * z)\" nitpick [expect=genuine] oops\nlemma vector_N: \"x = x * top \\<longrightarrow> N(x) = x \\<sqinter> 1\" nitpick [expect=genuine] oops\nlemma N_vector [simp]: \"N(x * top) = x * top \\<sqinter> 1\" nitpick [expect=genuine] oops\nlemma N_vector_top [simp]: \"N(x * top) * top = x * top\" nitpick [expect=genuine] oops\nlemma N_below_inf_one: \"N(x) \\<le> x \\<sqinter> 1\" nitpick [expect=genuine] oops\nlemma N_below: \"N(x) \\<le> x\" nitpick [expect=genuine] oops\nlemma n_split_omega_mult: \"xs * xo = xo \\<and> xo * top = xo \\<longrightarrow> N(top) * xo = xs * N(xo) * top\" nitpick [expect=genuine] oops\nlemma complement_vector: \"vector v \\<longleftrightarrow> vector (-v)\" nitpick [expect=genuine] oops\nlemma complement_covector: \"covector v \\<longleftrightarrow> covector (-v)\" nitpick [expect=genuine] oops\nlemma triple_schroeder: \"x * y * z \\<le> w \\<longleftrightarrow> x\\<^sup>T * -w * z\\<^sup>T \\<le> -y\" nitpick [expect=genuine] oops\nlemma schroeder_5: \"x * y \\<le> z \\<longleftrightarrow> y * -z\\<^sup>T \\<le> -x\\<^sup>T\" nitpick [expect=genuine] oops\nlemma schroeder_6: \"x * y \\<le> z \\<longleftrightarrow> -z\\<^sup>T * x \\<le> -y\\<^sup>T\" nitpick [expect=genuine] oops\n*)"], ["", "end"], ["", "text \\<open>\nEvery Stone algebra can be expanded to a Stone relation algebra by identifying the semiring and lattice structures and taking identity as converse.\n\\<close>"], ["", "sublocale stone_algebra < comp_inf: stone_relation_algebra where one = top and times = inf and conv = id"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_relation_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top uminus top (\\<sqinter>) id", "proof (unfold_locales, goal_cases)"], ["proof (state)\ngoal (10 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)\n 2. \\<And>x y z.\n       (x \\<squnion> y) \\<sqinter> z =\n       x \\<sqinter> z \\<squnion> y \\<sqinter> z\n 3. \\<And>x. bot \\<sqinter> x = bot\n 4. \\<And>x. top \\<sqinter> x = x\n 5. \\<And>x. id (id x) = x\n 6. \\<And>x y. id (x \\<squnion> y) = id x \\<squnion> id y\n 7. \\<And>x y. id (x \\<sqinter> y) = id y \\<sqinter> id x\n 8. \\<And>x y z.\n       x \\<sqinter> y \\<sqinter> z\n       \\<le> x \\<sqinter> (y \\<sqinter> (id x \\<sqinter> z))\n 9. \\<And>x y. - - (x \\<sqinter> y) = - - x \\<sqinter> - - y\n 10. - - top = top", "case 7"], ["proof (state)\nthis:\n  \n\ngoal (10 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)\n 2. \\<And>x y z.\n       (x \\<squnion> y) \\<sqinter> z =\n       x \\<sqinter> z \\<squnion> y \\<sqinter> z\n 3. \\<And>x. bot \\<sqinter> x = bot\n 4. \\<And>x. top \\<sqinter> x = x\n 5. \\<And>x. id (id x) = x\n 6. \\<And>x y. id (x \\<squnion> y) = id x \\<squnion> id y\n 7. \\<And>x y. id (x \\<sqinter> y) = id y \\<sqinter> id x\n 8. \\<And>x y z.\n       x \\<sqinter> y \\<sqinter> z\n       \\<le> x \\<sqinter> (y \\<sqinter> (id x \\<sqinter> z))\n 9. \\<And>x y. - - (x \\<sqinter> y) = - - x \\<sqinter> - - y\n 10. - - top = top", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. id (x_ \\<sqinter> y_) = id y_ \\<sqinter> id x_", "by (simp add: inf_commute)"], ["proof (state)\nthis:\n  id (x_ \\<sqinter> y_) = id y_ \\<sqinter> id x_\n\ngoal (9 subgoals):\n 1. \\<And>x y z. x \\<sqinter> y \\<sqinter> z = x \\<sqinter> (y \\<sqinter> z)\n 2. \\<And>x y z.\n       (x \\<squnion> y) \\<sqinter> z =\n       x \\<sqinter> z \\<squnion> y \\<sqinter> z\n 3. \\<And>x. bot \\<sqinter> x = bot\n 4. \\<And>x. top \\<sqinter> x = x\n 5. \\<And>x. id (id x) = x\n 6. \\<And>x y. id (x \\<squnion> y) = id x \\<squnion> id y\n 7. \\<And>x y z.\n       x \\<sqinter> y \\<sqinter> z\n       \\<le> x \\<sqinter> (y \\<sqinter> (id x \\<sqinter> z))\n 8. \\<And>x y. - - (x \\<sqinter> y) = - - x \\<sqinter> - - y\n 9. - - top = top", "qed (auto simp: inf.assoc inf_sup_distrib2 inf_left_commute)"], ["", "text \\<open>\nEvery bounded linear order can be expanded to a Stone algebra, which can be expanded to a Stone relation algebra by reusing some of the operations.\nIn particular, composition is meet, its identity is \\<open>top\\<close> and converse is the identity function.\n\\<close>"], ["", "class linorder_stone_relation_algebra_expansion = linorder_stone_algebra_expansion + times + conv + one +\n  assumes times_def [simp]: \"x * y = min x y\"\n  assumes conv_def [simp]: \"x\\<^sup>T = x\"\n  assumes one_def [simp]: \"1 = top\"\nbegin"], ["", "lemma times_inf [simp]:\n  \"x * y = x \\<sqinter> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y = x \\<sqinter> y", "by simp"], ["", "subclass stone_relation_algebra"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.stone_relation_algebra (\\<sqinter>) (\\<le>) (<) (\\<squnion>) bot\n     top uminus (1::'a) (*) conv", "apply unfold_locales"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>x y z. x * y * z = x * (y * z)\n 2. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 3. \\<And>x. bot * x = bot\n 4. \\<And>x. (1::'a) * x = x\n 5. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 6. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 7. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 8. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 9. \\<And>x y. - - (x * y) = - - x * - - y\n 10. - - (1::'a) = (1::'a)", "using comp_inf.mult_right_dist_sup inf_commute inf_assoc inf_left_commute pp_dist_inf min_def"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y) \\<sqinter> ?z =\n  ?x \\<sqinter> ?z \\<squnion> ?y \\<sqinter> ?z\n  ?x \\<sqinter> ?y = ?y \\<sqinter> ?x\n  ?x \\<sqinter> ?y \\<sqinter> ?z = ?x \\<sqinter> (?y \\<sqinter> ?z)\n  ?x \\<sqinter> (?y \\<sqinter> ?z) = ?y \\<sqinter> (?x \\<sqinter> ?z)\n  - - (?x \\<sqinter> ?y) = - - ?x \\<sqinter> - - ?y\n  min ?a ?b = (if ?a \\<le> ?b then ?a else ?b)\n\ngoal (10 subgoals):\n 1. \\<And>x y z. x * y * z = x * (y * z)\n 2. \\<And>x y z. (x \\<squnion> y) * z = x * z \\<squnion> y * z\n 3. \\<And>x. bot * x = bot\n 4. \\<And>x. (1::'a) * x = x\n 5. \\<And>x. x\\<^sup>T\\<^sup>T = x\n 6. \\<And>x y. (x \\<squnion> y)\\<^sup>T = x\\<^sup>T \\<squnion> y\\<^sup>T\n 7. \\<And>x y. (x * y)\\<^sup>T = y\\<^sup>T * x\\<^sup>T\n 8. \\<And>x y z. x * y \\<sqinter> z \\<le> x * (y \\<sqinter> x\\<^sup>T * z)\n 9. \\<And>x y. - - (x * y) = - - x * - - y\n 10. - - (1::'a) = (1::'a)", "by simp_all"], ["", "lemma times_dense:\n  \"x \\<noteq> bot \\<Longrightarrow> y \\<noteq> bot \\<Longrightarrow> x * y \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> bot; y \\<noteq> bot\\<rbrakk>\n    \\<Longrightarrow> x * y \\<noteq> bot", "using inf_dense min_inf times_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> bot; ?y \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> ?x \\<sqinter> ?y \\<noteq> bot\n  min ?x ?y = ?x \\<sqinter> ?y\n  ?x * ?y = min ?x ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> bot; y \\<noteq> bot\\<rbrakk>\n    \\<Longrightarrow> x * y \\<noteq> bot", "by presburger"], ["", "end"], ["", "subsection \\<open>Relation Algebras\\<close>"], ["", "text \\<open>\nFor a relation algebra, we only require that the underlying lattice is a Boolean algebra.\nIn fact, the only missing axiom is that double-complement is the identity.\n\\<close>"], ["", "class relation_algebra = boolean_algebra + stone_relation_algebra\nbegin"], ["", "lemma conv_complement_0 [simp]:\n  \"x\\<^sup>T \\<squnion> (-x)\\<^sup>T = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sup>T \\<squnion> (- x)\\<^sup>T = top", "by (simp add: conv_complement)"], ["", "text \\<open>\nWe now obtain the original formulations of the Schr\\\"oder equivalences.\n\\<close>"], ["", "lemma schroeder_3:\n  \"x * y \\<le> z \\<longleftrightarrow> x\\<^sup>T * -z \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> z) = (x\\<^sup>T * - z \\<le> - y)", "by (simp add: schroeder_3_p)"], ["", "lemma schroeder_4:\n  \"x * y \\<le> z \\<longleftrightarrow> -z * y\\<^sup>T \\<le> -x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> z) = (- z * y\\<^sup>T \\<le> - x)", "by (simp add: schroeder_4_p)"], ["", "lemma theorem24xxiv:\n  \"-(x * y) \\<squnion> (x * z) = -(x * (y \\<sqinter> -z)) \\<squnion> (x * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (x * y) \\<squnion> x * z = - (x * (y \\<sqinter> - z)) \\<squnion> x * z", "using theorem24xxiv_pp"], ["proof (prove)\nusing this:\n  - (?x * ?y) \\<squnion> - - (?x * ?z) =\n  - (?x * (?y \\<sqinter> - ?z)) \\<squnion> - - (?x * ?z)\n\ngoal (1 subgoal):\n 1. - (x * y) \\<squnion> x * z = - (x * (y \\<sqinter> - z)) \\<squnion> x * z", "by auto"], ["", "lemma vector_N:\n  \"vector x \\<Longrightarrow> N(x) = x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector x \\<Longrightarrow> N x = x \\<sqinter> (1::'a)", "by (simp add: vector_N_pp)"], ["", "lemma N_vector [simp]:\n  \"N(x * top) = x * top \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x * top) = x * top \\<sqinter> (1::'a)", "by simp"], ["", "lemma N_vector_top [simp]:\n  \"N(x * top) * top = x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N (x * top) * top = x * top", "using N_vector_top_pp"], ["proof (prove)\nusing this:\n  N (?x * top) * top = - - (?x * top)\n\ngoal (1 subgoal):\n 1. N (x * top) * top = x * top", "by simp"], ["", "lemma N_below_inf_one:\n  \"N(x) \\<le> x \\<sqinter> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x \\<le> x \\<sqinter> (1::'a)", "using N_below_inf_one_pp"], ["proof (prove)\nusing this:\n  N ?x \\<le> - ?x '\n\ngoal (1 subgoal):\n 1. N x \\<le> x \\<sqinter> (1::'a)", "by simp"], ["", "lemma N_below:\n  \"N(x) \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N x \\<le> x", "using N_below_pp"], ["proof (prove)\nusing this:\n  N ?x \\<le> - - ?x\n\ngoal (1 subgoal):\n 1. N x \\<le> x", "by simp"], ["", "lemma n_split_omega_mult:\n  \"xs * xo = xo \\<Longrightarrow> xo * top = xo \\<Longrightarrow> N(top) * xo = xs * N(xo) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs * xo = xo; vector xo\\<rbrakk>\n    \\<Longrightarrow> N top * xo = xs * N xo * top", "using n_split_omega_mult_pp"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xs * - - ?xo = ?xo; vector ?xo\\<rbrakk>\n  \\<Longrightarrow> N top * ?xo = ?xs * N ?xo * top\n\ngoal (1 subgoal):\n 1. \\<lbrakk>xs * xo = xo; vector xo\\<rbrakk>\n    \\<Longrightarrow> N top * xo = xs * N xo * top", "by simp"], ["", "lemma complement_vector:\n  \"vector v \\<longleftrightarrow> vector (-v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector v = vector (- v)", "using vector_complement_closed"], ["proof (prove)\nusing this:\n  vector ?x \\<Longrightarrow> vector (- ?x)\n\ngoal (1 subgoal):\n 1. vector v = vector (- v)", "by fastforce"], ["", "lemma complement_covector:\n  \"covector v \\<longleftrightarrow> covector (-v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector v = covector (- v)", "using covector_complement_closed"], ["proof (prove)\nusing this:\n  covector ?x \\<Longrightarrow> covector (- ?x)\n\ngoal (1 subgoal):\n 1. covector v = covector (- v)", "by force"], ["", "lemma triple_schroeder:\n  \"x * y * z \\<le> w \\<longleftrightarrow> x\\<^sup>T * -w * z\\<^sup>T \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y * z \\<le> w) = (x\\<^sup>T * - w * z\\<^sup>T \\<le> - y)", "by (simp add: triple_schroeder_p)"], ["", "lemma schroeder_5:\n  \"x * y \\<le> z \\<longleftrightarrow> y * -z\\<^sup>T \\<le> -x\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> z) = (y * - z\\<^sup>T \\<le> - x\\<^sup>T)", "by (simp add: conv_complement schroeder_5_p)"], ["", "lemma schroeder_6:\n  \"x * y \\<le> z \\<longleftrightarrow> -z\\<^sup>T * x \\<le> -y\\<^sup>T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * y \\<le> z) = (- z\\<^sup>T * x \\<le> - y\\<^sup>T)", "by (simp add: conv_complement schroeder_5_p)"], ["", "end"], ["", "text \\<open>\nWe briefly look at the so-called Tarski rule.\nIn some models of Stone relation algebras it only holds for regular elements, so we add this as an assumption.\n\\<close>"], ["", "class stone_relation_algebra_tarski = stone_relation_algebra +\n  assumes tarski: \"regular x \\<Longrightarrow> x \\<noteq> bot \\<Longrightarrow> top * x * top = top\"\nbegin"], ["", "text \\<open>\nWe can then show, for example, that every arc is contained in a pseudocomplemented relation or its pseudocomplement.\n\\<close>"], ["", "lemma arc_in_partition:\n  assumes \"arc x\"\n    shows \"x \\<le> -y \\<or> x \\<le> --y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<or> x \\<le> - - y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<or> x \\<le> - - y", "have 1: \"x * top * x\\<^sup>T \\<le> 1 \\<and> x\\<^sup>T * top * x \\<le> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x)", "using assms arc_expanded"], ["proof (prove)\nusing this:\n  arc x\n  arc ?x =\n  (coreflexive (?x * top * ?x\\<^sup>T) \\<and>\n   coreflexive (?x\\<^sup>T * top * ?x) \\<and>\n   times_top_class.total (top * ?x))\n\ngoal (1 subgoal):\n 1. coreflexive (x * top * x\\<^sup>T) \\<and>\n    coreflexive (x\\<^sup>T * top * x)", "by auto"], ["proof (state)\nthis:\n  coreflexive (x * top * x\\<^sup>T) \\<and> coreflexive (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<or> x \\<le> - - y", "have \"\\<not> x \\<le> --y \\<longrightarrow> x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<longrightarrow> x \\<le> - y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "assume \"\\<not> x \\<le> --y\""], ["proof (state)\nthis:\n  \\<not> x \\<le> - - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "hence \"x \\<sqinter> -y \\<noteq> bot\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> - - y\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<noteq> bot", "using pseudo_complement"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> - - y\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> - y \\<noteq> bot", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> - y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "hence \"top * (x \\<sqinter> -y) * top = top\""], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<noteq> bot\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * (x \\<sqinter> - y))", "using assms arc_regular tarski"], ["proof (prove)\nusing this:\n  x \\<sqinter> - y \\<noteq> bot\n  arc x\n  arc ?x \\<Longrightarrow> regular ?x\n  \\<lbrakk>regular ?x; ?x \\<noteq> bot\\<rbrakk>\n  \\<Longrightarrow> times_top_class.total (top * ?x)\n\ngoal (1 subgoal):\n 1. times_top_class.total (top * (x \\<sqinter> - y))", "by auto"], ["proof (state)\nthis:\n  times_top_class.total (top * (x \\<sqinter> - y))\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "hence \"x = x \\<sqinter> top * (x \\<sqinter> -y) * top\""], ["proof (prove)\nusing this:\n  times_top_class.total (top * (x \\<sqinter> - y))\n\ngoal (1 subgoal):\n 1. x = x \\<sqinter> top * (x \\<sqinter> - y) * top", "by simp"], ["proof (state)\nthis:\n  x = x \\<sqinter> top * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x = x \\<sqinter> top * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> x \\<sqinter> x * ((x \\<sqinter> -y) * top)\\<^sup>T * (x \\<sqinter> -y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> top * (x \\<sqinter> - y) * top\n    \\<le> x \\<sqinter>\n          x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top", "by (metis dedekind_2 inf.cobounded1 inf.boundedI inf_commute mult_assoc inf.absorb2 top.extremum)"], ["proof (state)\nthis:\n  x \\<sqinter> top * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter>\n        x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> top * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter>\n        x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... = x \\<sqinter> x * top * (x\\<^sup>T \\<sqinter> -y\\<^sup>T) * (x \\<sqinter> -y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter>\n    x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top =\n    x \\<sqinter>\n    x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top", "by (simp add: comp_associative conv_complement conv_dist_comp conv_dist_inf)"], ["proof (state)\nthis:\n  x \\<sqinter>\n  x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top =\n  x \\<sqinter>\n  x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter>\n  x * ((x \\<sqinter> - y) * top)\\<^sup>T * (x \\<sqinter> - y) * top =\n  x \\<sqinter>\n  x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> -y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter>\n    x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n    \\<le> x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top", "using inf.sup_right_isotone mult_left_isotone mult_right_isotone"], ["proof (prove)\nusing this:\n  ?y \\<le> ?x \\<Longrightarrow> ?z \\<sqinter> ?y \\<le> ?z \\<sqinter> ?x\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. x \\<sqinter>\n    x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n    \\<le> x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top", "by auto"], ["proof (state)\nthis:\n  x \\<sqinter>\n  x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter>\n  x * top * (x\\<^sup>T \\<sqinter> - y\\<^sup>T) * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> x \\<sqinter> 1 * (x \\<sqinter> -y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n    \\<le> x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top", "using 1"], ["proof (prove)\nusing this:\n  coreflexive (x * top * x\\<^sup>T) \\<and> coreflexive (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n    \\<le> x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top", "by (metis comp_associative comp_isotone inf.sup_right_isotone mult_1_left mult_semi_associative)"], ["proof (state)\nthis:\n  x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> x * top * x\\<^sup>T * (x \\<sqinter> - y) * top\n  \\<le> x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... = x \\<sqinter> (x \\<sqinter> -y) * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top =\n    x \\<sqinter> (x \\<sqinter> - y) * top", "by simp"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top =\n  x \\<sqinter> (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> (1::'a) * (x \\<sqinter> - y) * top =\n  x \\<sqinter> (x \\<sqinter> - y) * top\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> (x \\<sqinter> -y) * ((x \\<sqinter> -y)\\<^sup>T * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> (x \\<sqinter> - y) * top\n    \\<le> (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)", "by (metis dedekind_1 inf_commute inf_top_right)"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<sqinter> - y) * top\n  \\<le> (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  x \\<sqinter> (x \\<sqinter> - y) * top\n  \\<le> (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> (x \\<sqinter> -y) * (x\\<^sup>T * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)\n    \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * x)", "by (simp add: conv_dist_inf mult_left_isotone mult_right_isotone)"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)\n  \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * ((x \\<sqinter> - y)\\<^sup>T * x)\n  \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> (x \\<sqinter> -y) * (x\\<^sup>T * top * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y) * (x\\<^sup>T * x)\n    \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * top * x)", "by (simp add: mult_assoc mult_right_isotone top_left_mult_increasing)"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * (x\\<^sup>T * x)\n  \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "also"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * (x\\<^sup>T * x)\n  \\<le> (x \\<sqinter> - y) * (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "have \"... \\<le> x \\<sqinter> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y) * (x\\<^sup>T * top * x) \\<le> x \\<sqinter> - y", "using 1"], ["proof (prove)\nusing this:\n  coreflexive (x * top * x\\<^sup>T) \\<and> coreflexive (x\\<^sup>T * top * x)\n\ngoal (1 subgoal):\n 1. (x \\<sqinter> - y) * (x\\<^sup>T * top * x) \\<le> x \\<sqinter> - y", "by (metis mult_right_isotone mult_1_right)"], ["proof (state)\nthis:\n  (x \\<sqinter> - y) * (x\\<^sup>T * top * x) \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - - y \\<Longrightarrow> x \\<le> - y", "finally"], ["proof (chain)\npicking this:\n  x \\<le> x \\<sqinter> - y", "show \"x \\<le> -y\""], ["proof (prove)\nusing this:\n  x \\<le> x \\<sqinter> - y\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "by simp"], ["proof (state)\nthis:\n  x \\<le> - y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> x \\<le> - - y \\<longrightarrow> x \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<or> x \\<le> - - y", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> - - y \\<longrightarrow> x \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<or> x \\<le> - - y", "by auto"], ["proof (state)\nthis:\n  x \\<le> - y \\<or> x \\<le> - - y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma non_bot_arc_in_partition_xor:\n  assumes \"arc x\"\n      and \"x \\<noteq> bot\"\n    shows \"(x \\<le> -y \\<and> \\<not> x \\<le> --y) \\<or> (\\<not> x \\<le> -y \\<and> x \\<le> --y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "have \"x \\<le> -y \\<and> x \\<le> --y \\<longrightarrow> False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> x \\<le> - - y \\<longrightarrow> False", "by (simp add: assms(2) inf_absorb1 shunting_1_pp)"], ["proof (state)\nthis:\n  x \\<le> - y \\<and> x \\<le> - - y \\<longrightarrow> False\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> - y \\<and> x \\<le> - - y \\<longrightarrow> False\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "using assms(1) arc_in_partition"], ["proof (prove)\nusing this:\n  x \\<le> - y \\<and> x \\<le> - - y \\<longrightarrow> False\n  arc x\n  arc ?x \\<Longrightarrow> ?x \\<le> - ?y \\<or> ?x \\<le> - - ?y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "by auto"], ["proof (state)\nthis:\n  x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n  \\<not> x \\<le> - y \\<and> x \\<le> - - y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_in_vector_or_pseudo_complement:\n  assumes \"point p\"\n      and \"vector v\"\n    shows \"p \\<le> --v \\<or> p \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> - - v \\<or> p \\<le> - v", "proof (rule disjCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> - - v", "assume \"\\<not>(p \\<le> -v)\""], ["proof (state)\nthis:\n  \\<not> p \\<le> - v\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> - - v", "hence \"top * (p \\<sqinter> --v) = top\""], ["proof (prove)\nusing this:\n  \\<not> p \\<le> - v\n\ngoal (1 subgoal):\n 1. surjective (p \\<sqinter> - - v)", "by (smt assms bijective_regular regular_closed_inf regular_closed_p shunting_1_pp tarski vector_complement_closed vector_inf_closed vector_mult_closed)"], ["proof (state)\nthis:\n  surjective (p \\<sqinter> - - v)\n\ngoal (1 subgoal):\n 1. \\<not> p \\<le> - v \\<Longrightarrow> p \\<le> - - v", "thus \"p \\<le> --v\""], ["proof (prove)\nusing this:\n  surjective (p \\<sqinter> - - v)\n\ngoal (1 subgoal):\n 1. p \\<le> - - v", "by (metis assms(1) epm_3 inf.absorb_iff1 inf.cobounded1 inf_top.right_neutral)"], ["proof (state)\nthis:\n  p \\<le> - - v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma distinct_points:\n  assumes \"point x\"\n    and \"point y\"\n    and \"x \\<noteq> y\"\n  shows \"x \\<sqinter> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<sqinter> y = bot", "by (metis assms antisym comp_bijective_complement inf.sup_monoid.add_commute mult_left_one pseudo_complement regular_one_closed point_in_vector_or_pseudo_complement)"], ["", "lemma point_in_vector_or_complement:\n  assumes \"point p\"\n      and \"vector v\"\n      and \"regular v\"\n    shows \"p \\<le> v \\<or> p \\<le> -v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> - v", "using assms point_in_vector_or_pseudo_complement"], ["proof (prove)\nusing this:\n  point p\n  vector v\n  regular v\n  \\<lbrakk>point ?p; vector ?v\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> - - ?v \\<or> ?p \\<le> - ?v\n\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> - v", "by fastforce"], ["", "lemma point_in_vector_sup:\n  assumes \"point p\"\n      and \"vector v\"\n      and \"regular v\"\n      and \"p \\<le> v \\<squnion> w\"\n    shows \"p \\<le> v \\<or> p \\<le> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> v \\<or> p \\<le> w", "by (metis assms inf.absorb1 shunting_var_p sup_commute point_in_vector_or_complement)"], ["", "lemma point_atomic_vector:\n  assumes \"point x\"\n    and \"vector y\"\n    and \"regular y\"\n    and \"y \\<le> x\"\n  shows \"y = x \\<or> y = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = x \\<or> y = bot", "proof (cases \"x \\<le> -y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot\n 2. \\<not> x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot", "case True"], ["proof (state)\nthis:\n  x \\<le> - y\n\ngoal (2 subgoals):\n 1. x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot\n 2. \\<not> x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> - y\n\ngoal (1 subgoal):\n 1. y = x \\<or> y = bot", "using assms(4) inf.absorb2 pseudo_complement"], ["proof (prove)\nusing this:\n  x \\<le> - y\n  y \\<le> x\n  ?b \\<le> ?a \\<Longrightarrow> ?a \\<sqinter> ?b = ?b\n  (?x \\<sqinter> ?y = bot) = (?x \\<le> - ?y)\n\ngoal (1 subgoal):\n 1. y = x \\<or> y = bot", "by force"], ["proof (state)\nthis:\n  y = x \\<or> y = bot\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> - y \\<Longrightarrow> y = x \\<or> y = bot", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> - y\n\ngoal (1 subgoal):\n 1. y = x \\<or> y = bot", "using assms point_in_vector_or_pseudo_complement"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> - y\n  point x\n  vector y\n  regular y\n  y \\<le> x\n  \\<lbrakk>point ?p; vector ?v\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> - - ?v \\<or> ?p \\<le> - ?v\n\ngoal (1 subgoal):\n 1. y = x \\<or> y = bot", "by fastforce"], ["proof (state)\nthis:\n  y = x \\<or> y = bot\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma point_in_vector_or_complement_2:\n  assumes \"point x\"\n    and \"vector y\"\n    and \"regular y\"\n    and \"\\<not> y \\<le> -x\"\n  shows \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "using assms point_in_vector_or_pseudo_complement p_antitone_iff"], ["proof (prove)\nusing this:\n  point x\n  vector y\n  regular y\n  \\<not> y \\<le> - x\n  \\<lbrakk>point ?p; vector ?v\\<rbrakk>\n  \\<Longrightarrow> ?p \\<le> - - ?v \\<or> ?p \\<le> - ?v\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by fastforce"], ["", "text \\<open>The next three lemmas \\<open>arc_in_arc_or_complement\\<close>, \\<open>arc_in_sup_arc\\<close> and \\<open>different_arc_in_sup_arc\\<close> were contributed by Nicolas Robinson-O'Brien.\\<close>"], ["", "lemma arc_in_arc_or_complement:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"\\<not> x \\<le> y\"\n    shows \"x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y", "using assms arc_in_partition arc_regular"], ["proof (prove)\nusing this:\n  arc x\n  arc y\n  \\<not> x \\<le> y\n  arc ?x \\<Longrightarrow> ?x \\<le> - ?y \\<or> ?x \\<le> - - ?y\n  arc ?x \\<Longrightarrow> regular ?x\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "by force"], ["", "lemma arc_in_sup_arc:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"x \\<le> z \\<squnion> y\"\n    shows \"x \\<le> z \\<or> x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z \\<or> x \\<le> y", "proof (cases \"x \\<le> y\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "case True"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<or> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  x \\<le> z \\<or> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "hence \"x \\<le> -y\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "using assms(1,2) arc_in_arc_or_complement"], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y\n  arc x\n  arc y\n  \\<lbrakk>arc ?x; arc ?y; \\<not> ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> - ?y\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "by blast"], ["proof (state)\nthis:\n  x \\<le> - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "hence \"x \\<le> -y \\<sqinter> (z \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<sqinter> (z \\<squnion> y)", "using assms(3)"], ["proof (prove)\nusing this:\n  x \\<le> - y\n  x \\<le> z \\<squnion> y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<sqinter> (z \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  x \\<le> - y \\<sqinter> (z \\<squnion> y)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "hence \"x \\<le> z\""], ["proof (prove)\nusing this:\n  x \\<le> - y \\<sqinter> (z \\<squnion> y)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (metis inf.boundedE inf.sup_monoid.add_commute maddux_3_13 sup_commute)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x \\<le> z \\<or> x \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> z\n\ngoal (1 subgoal):\n 1. x \\<le> z \\<or> x \\<le> y", "by simp"], ["proof (state)\nthis:\n  x \\<le> z \\<or> x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma different_arc_in_sup_arc:\n  assumes \"arc x\"\n      and \"arc y\"\n      and \"x \\<le> z \\<squnion> y\"\n      and \"x \\<noteq> y\"\n    shows \"x \\<le> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> z", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> z", "have \"x \\<le> -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> - y", "using arc_in_arc_or_complement assms(1,2,4) eq_iff p_antitone_iff"], ["proof (prove)\nusing this:\n  \\<lbrakk>arc ?x; arc ?y; \\<not> ?x \\<le> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> - ?y\n  arc x\n  arc y\n  x \\<noteq> y\n  (?x = ?y) = (?x \\<le> ?y \\<and> ?y \\<le> ?x)\n  (?x \\<le> - ?y) = (?y \\<le> - ?x)\n\ngoal (1 subgoal):\n 1. x \\<le> - y", "by blast"], ["proof (state)\nthis:\n  x \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<le> z", "hence \"x \\<le> -y \\<sqinter> (z \\<squnion> y)\""], ["proof (prove)\nusing this:\n  x \\<le> - y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<sqinter> (z \\<squnion> y)", "using assms arc_in_sup_arc"], ["proof (prove)\nusing this:\n  x \\<le> - y\n  arc x\n  arc y\n  x \\<le> z \\<squnion> y\n  x \\<noteq> y\n  \\<lbrakk>arc ?x; arc ?y; ?x \\<le> ?z \\<squnion> ?y\\<rbrakk>\n  \\<Longrightarrow> ?x \\<le> ?z \\<or> ?x \\<le> ?y\n\ngoal (1 subgoal):\n 1. x \\<le> - y \\<sqinter> (z \\<squnion> y)", "by simp"], ["proof (state)\nthis:\n  x \\<le> - y \\<sqinter> (z \\<squnion> y)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<le> - y \\<sqinter> (z \\<squnion> y)\n\ngoal (1 subgoal):\n 1. x \\<le> z", "by (metis order_lesseq_imp p_inf_sup_below sup_commute)"], ["proof (state)\nthis:\n  x \\<le> z\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "class relation_algebra_tarski = relation_algebra + stone_relation_algebra_tarski"], ["", "text \\<open>\nFinally, the above axioms of relation algebras do not imply that they contain at least two elements.\nThis is necessary, for example, to show that arcs are not empty.\n\\<close>"], ["", "class stone_relation_algebra_consistent = stone_relation_algebra +\n  assumes consistent: \"bot \\<noteq> top\"\nbegin"], ["", "lemma arc_not_bot:\n  \"arc x \\<Longrightarrow> x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> x \\<noteq> bot", "using consistent mult_right_zero"], ["proof (prove)\nusing this:\n  bot \\<noteq> top\n  ?x * bot = bot\n\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow> x \\<noteq> bot", "by auto"], ["", "end"], ["", "class relation_algebra_consistent = relation_algebra + stone_relation_algebra_consistent"], ["", "class stone_relation_algebra_tarski_consistent = stone_relation_algebra_tarski + stone_relation_algebra_consistent\nbegin"], ["", "lemma arc_in_partition_xor:\n  \"arc x \\<Longrightarrow> (x \\<le> -y \\<and> \\<not> x \\<le> --y) \\<or> (\\<not> x \\<le> -y \\<and> x \\<le> --y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arc x \\<Longrightarrow>\n    x \\<le> - y \\<and> \\<not> x \\<le> - - y \\<or>\n    \\<not> x \\<le> - y \\<and> x \\<le> - - y", "by (simp add: non_bot_arc_in_partition_xor arc_not_bot)"], ["", "end"], ["", "end"]]}