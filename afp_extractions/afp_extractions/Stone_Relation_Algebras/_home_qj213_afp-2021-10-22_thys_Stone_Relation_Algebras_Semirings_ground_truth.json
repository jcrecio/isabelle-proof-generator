{"file_name": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras/Semirings.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Stone_Relation_Algebras", "problem_names": ["lemma mult_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\"", "lemma mult_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\"", "lemma mult_isotone:\n  \"w \\<le> y \\<Longrightarrow> x \\<le> z \\<Longrightarrow> w * x \\<le> y * z\"", "lemma affine_isotone:\n  \"isotone (\\<lambda>x . y * x \\<squnion> z)\"", "lemma mult_left_sub_dist_sup_left:\n  \"x * y \\<le> x * (y \\<squnion> z)\"", "lemma mult_left_sub_dist_sup_right:\n  \"x * z \\<le> x * (y \\<squnion> z)\"", "lemma mult_right_sub_dist_sup_left:\n  \"x * z \\<le> (x \\<squnion> y) * z\"", "lemma mult_right_sub_dist_sup_right:\n  \"y * z \\<le> (x \\<squnion> y) * z\"", "lemma case_split_left:\n  assumes \"1 \\<le> w \\<squnion> z\"\n      and \"w * x \\<le> y\"\n      and \"z * x \\<le> y\"\n    shows \"x \\<le> y\"", "lemma case_split_left_equal:\n  \"w \\<squnion> z = 1 \\<Longrightarrow> w * x = w * y \\<Longrightarrow> z * x = z * y \\<Longrightarrow> x = y\"", "lemma reflexive_one_closed:\n  \"reflexive 1\"", "lemma reflexive_sup_closed:\n  \"reflexive x \\<Longrightarrow> reflexive (x \\<squnion> y)\"", "lemma reflexive_mult_closed:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x * y)\"", "lemma coreflexive_bot_closed:\n  \"coreflexive bot\"", "lemma coreflexive_one_closed:\n  \"coreflexive 1\"", "lemma coreflexive_sup_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<squnion> y)\"", "lemma coreflexive_mult_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x * y)\"", "lemma transitive_bot_closed:\n  \"transitive bot\"", "lemma transitive_one_closed:\n  \"transitive 1\"", "lemma dense_bot_closed:\n  \"dense_rel bot\"", "lemma dense_one_closed:\n  \"dense_rel 1\"", "lemma dense_sup_closed:\n  \"dense_rel x \\<Longrightarrow> dense_rel y \\<Longrightarrow> dense_rel (x \\<squnion> y)\"", "lemma idempotent_bot_closed:\n  \"idempotent bot\"", "lemma idempotent_one_closed:\n  \"idempotent 1\"", "lemma preorder_one_closed:\n  \"preorder 1\"", "lemma coreflexive_transitive:\n  \"coreflexive x \\<Longrightarrow> transitive x\"", "lemma preorder_idempotent:\n  \"preorder x \\<Longrightarrow> idempotent x\"", "lemma lstar_rec_isotone:\n  \"isotone (Lf y)\"", "lemma rstar_rec_isotone:\n  \"isotone (Rf y)\"", "lemma sstar_rec_isotone:\n  \"isotone (Sf y)\"", "lemma lstar_fixpoint:\n  \"has_least_prefixpoint (Lf y) \\<Longrightarrow> lstar y = \\<mu> (Lf y)\"", "lemma rstar_fixpoint:\n  \"has_least_prefixpoint (Rf y) \\<Longrightarrow> rstar y = \\<mu> (Rf y)\"", "lemma sstar_fixpoint:\n  \"has_least_prefixpoint (Sf y) \\<Longrightarrow> sstar y = \\<mu> (Sf y)\"", "lemma sstar_increasing:\n  \"has_least_prefixpoint (Sf y) \\<Longrightarrow> y \\<le> sstar y\"", "lemma rstar_below_sstar:\n  assumes \"has_least_prefixpoint (Rf y)\"\n      and \"has_least_prefixpoint (Sf y)\"\n    shows \"rstar y \\<le> sstar y\"", "lemma mult_one_associative [simp]:\n  \"x * 1 * y = x * y\"", "lemma mult_sup_associative_one:\n  \"(x * (y * 1)) * z \\<le> x * (y * z)\"", "lemma rstar_increasing:\n  assumes \"has_least_prefixpoint (Rf y)\"\n    shows \"y \\<le> rstar y\"", "lemma lres_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x / z \\<le> y / z\"", "lemma lres_right_antitone:\n  \"x \\<le> y \\<Longrightarrow> z / y \\<le> z / x\"", "lemma lres_inverse:\n  \"(x / y) * y \\<le> x\"", "lemma lres_one:\n  \"x / 1 \\<le> x\"", "lemma lres_mult_sub_lres_lres:\n  \"x / (z * y) \\<le> (x / y) / z\"", "lemma mult_lres_sub_assoc:\n  \"x * (y / z) \\<le> (x * y) / z\"", "lemma lstar_below_rstar:\n  assumes \"has_least_prefixpoint (Lf y)\"\n      and \"has_least_prefixpoint (Rf y)\"\n    shows \"lstar y \\<le> rstar y\"", "lemma rstar_sstar:\n  assumes \"has_least_prefixpoint (Rf y)\"\n      and \"has_least_prefixpoint (Sf y)\"\n    shows \"rstar y = sstar y\"", "lemma zero_right_mult_decreasing:\n  \"x * bot \\<le> x\"", "lemma test_preserves_equation:\n  assumes \"dense_rel p\"\n      and \"coreflexive p\"\n    shows \"p * x \\<le> x * p \\<longleftrightarrow> p * x = p * x * p\"", "lemma case_split_right:\n  assumes \"1 \\<le> w \\<squnion> z\"\n      and \"x * w \\<le> y\"\n      and \"x * z \\<le> y\"\n    shows \"x \\<le> y\"", "lemma case_split_right_equal:\n  \"w \\<squnion> z = 1 \\<Longrightarrow> x * w = y * w \\<Longrightarrow> x * z = y * z \\<Longrightarrow> x = y\"", "lemma sup_left_top [simp]:\n  \"top \\<squnion> x = top\"", "lemma top_greatest [simp]:\n  \"x \\<le> top\"", "lemma top_left_mult_increasing:\n  \"x \\<le> top * x\"", "lemma top_right_mult_increasing:\n  \"x \\<le> x * top\"", "lemma top_mult_top [simp]:\n  \"top * top = top\"", "lemma vector_bot_closed:\n  \"vector bot\"", "lemma vector_top_closed:\n  \"vector top\"", "lemma vector_sup_closed:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<squnion> y)\"", "lemma covector_top_closed:\n  \"covector top\"", "lemma total_one_closed:\n  \"total 1\"", "lemma total_top_closed:\n  \"total top\"", "lemma total_sup_closed:\n  \"total x \\<Longrightarrow> total (x \\<squnion> y)\"", "lemma surjective_one_closed:\n  \"surjective 1\"", "lemma surjective_top_closed:\n  \"surjective top\"", "lemma surjective_sup_closed:\n  \"surjective x \\<Longrightarrow> surjective (x \\<squnion> y)\"", "lemma reflexive_top_closed:\n  \"reflexive top\"", "lemma transitive_top_closed:\n  \"transitive top\"", "lemma dense_top_closed:\n  \"dense_rel top\"", "lemma idempotent_top_closed:\n  \"idempotent top\"", "lemma preorder_top_closed:\n  \"preorder top\"", "lemma vector_mult_closed:\n  \"vector y \\<Longrightarrow> vector (x * y)\"", "lemma surjective_mult_closed:\n  \"surjective x \\<Longrightarrow> surjective y \\<Longrightarrow> surjective (x * y)\"", "lemma lres_top_decreasing:\n  \"x / top \\<le> x\"", "lemma top_lres_absorb [simp]:\n  \"top / x = top\"", "lemma covector_lres_closed:\n  \"covector x \\<Longrightarrow> covector (x / y)\"", "lemma covector_mult_closed:\n  \"covector x \\<Longrightarrow> covector (x * y)\"", "lemma total_mult_closed:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x * y)\"", "lemma covector_sup_closed:\n  \"covector x \\<Longrightarrow> covector y \\<Longrightarrow> covector (x \\<squnion> y)\"", "lemma covector_bot_closed:\n  \"covector bot\""], "translations": [["", "lemma mult_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x * z \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * z \\<le> y * z", "using mult_right_dist_sup sup_right_divisibility"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x * z \\<le> y * z", "by auto"], ["", "lemma mult_right_isotone:\n  \"x \\<le> y \\<Longrightarrow> z * x \\<le> z * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y", "using mult_left_sub_dist_sup sup.bounded_iff sup_right_divisibility"], ["proof (prove)\nusing this:\n  ?x * ?y \\<squnion> ?x * ?z \\<le> ?x * (?y \\<squnion> ?z)\n  (?b \\<squnion> ?c \\<le> ?a) = (?b \\<le> ?a \\<and> ?c \\<le> ?a)\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z * x \\<le> z * y", "by auto"], ["", "lemma mult_isotone:\n  \"w \\<le> y \\<Longrightarrow> x \\<le> z \\<Longrightarrow> w * x \\<le> y * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<le> y; x \\<le> z\\<rbrakk>\n    \\<Longrightarrow> w * x \\<le> y * z", "using order_trans mult_left_isotone mult_right_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<le> y; x \\<le> z\\<rbrakk>\n    \\<Longrightarrow> w * x \\<le> y * z", "by blast"], ["", "lemma affine_isotone:\n  \"isotone (\\<lambda>x . y * x \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (\\<lambda>x. y * x \\<squnion> z)", "using isotone_def mult_right_isotone sup_left_isotone"], ["proof (prove)\nusing this:\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?x \\<squnion> ?z \\<le> ?y \\<squnion> ?z\n\ngoal (1 subgoal):\n 1. isotone (\\<lambda>x. y * x \\<squnion> z)", "by auto"], ["", "lemma mult_left_sub_dist_sup_left:\n  \"x * y \\<le> x * (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y \\<le> x * (y \\<squnion> z)", "by (simp add: mult_right_isotone)"], ["", "lemma mult_left_sub_dist_sup_right:\n  \"x * z \\<le> x * (y \\<squnion> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> x * (y \\<squnion> z)", "by (simp add: mult_right_isotone)"], ["", "lemma mult_right_sub_dist_sup_left:\n  \"x * z \\<le> (x \\<squnion> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * z \\<le> (x \\<squnion> y) * z", "by (simp add: mult_left_isotone)"], ["", "lemma mult_right_sub_dist_sup_right:\n  \"y * z \\<le> (x \\<squnion> y) * z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * z \\<le> (x \\<squnion> y) * z", "by (simp add: mult_left_isotone)"], ["", "lemma case_split_left:\n  assumes \"1 \\<le> w \\<squnion> z\"\n      and \"w * x \\<le> y\"\n      and \"z * x \\<le> y\"\n    shows \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y", "have \"(w \\<squnion> z) * x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (w \\<squnion> z) * x \\<le> y", "by (simp add: assms(2-3) mult_right_dist_sup)"], ["proof (state)\nthis:\n  (w \\<squnion> z) * x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  (w \\<squnion> z) * x \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (metis assms(1) dual_order.trans mult_left_one mult_left_isotone)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_split_left_equal:\n  \"w \\<squnion> z = 1 \\<Longrightarrow> w * x = w * y \\<Longrightarrow> z * x = z * y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<squnion> z = (1::'a); w * x = w * y; z * x = z * y\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis mult_left_one mult_right_dist_sup)"], ["", "text \\<open>\nNext we consider under which semiring operations the above properties are closed.\n\\<close>"], ["", "lemma reflexive_one_closed:\n  \"reflexive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lemma reflexive_sup_closed:\n  \"reflexive x \\<Longrightarrow> reflexive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive x \\<Longrightarrow> reflexive (x \\<squnion> y)", "by (simp add: le_supI1)"], ["", "lemma reflexive_mult_closed:\n  \"reflexive x \\<Longrightarrow> reflexive y \\<Longrightarrow> reflexive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x * y)", "using mult_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reflexive x; reflexive y\\<rbrakk>\n    \\<Longrightarrow> reflexive (x * y)", "by fastforce"], ["", "lemma coreflexive_bot_closed:\n  \"coreflexive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive bot", "by simp"], ["", "lemma coreflexive_one_closed:\n  \"coreflexive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a)", "by simp"], ["", "lemma coreflexive_sup_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x \\<squnion> y)", "by simp"], ["", "lemma coreflexive_mult_closed:\n  \"coreflexive x \\<Longrightarrow> coreflexive y \\<Longrightarrow> coreflexive (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x * y)", "using mult_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. \\<lbrakk>coreflexive x; coreflexive y\\<rbrakk>\n    \\<Longrightarrow> coreflexive (x * y)", "by fastforce"], ["", "lemma transitive_bot_closed:\n  \"transitive bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive bot", "by simp"], ["", "lemma transitive_one_closed:\n  \"transitive 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive (1::'a)", "by simp"], ["", "lemma dense_bot_closed:\n  \"dense_rel bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel bot", "by simp"], ["", "lemma dense_one_closed:\n  \"dense_rel 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel (1::'a)", "by simp"], ["", "lemma dense_sup_closed:\n  \"dense_rel x \\<Longrightarrow> dense_rel y \\<Longrightarrow> dense_rel (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dense_rel x; dense_rel y\\<rbrakk>\n    \\<Longrightarrow> dense_rel (x \\<squnion> y)", "by (metis mult_right_dist_sup order_lesseq_imp sup.mono mult_left_sub_dist_sup_left mult_left_sub_dist_sup_right)"], ["", "lemma idempotent_bot_closed:\n  \"idempotent bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent bot", "by simp"], ["", "lemma idempotent_one_closed:\n  \"idempotent 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idempotent (1::'a)", "by simp"], ["", "lemma preorder_one_closed:\n  \"preorder 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive (1::'a) \\<and> transitive (1::'a)", "by simp"], ["", "lemma coreflexive_transitive:\n  \"coreflexive x \\<Longrightarrow> transitive x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> transitive x", "using mult_left_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?x * ?z \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. coreflexive x \\<Longrightarrow> transitive x", "by fastforce"], ["", "lemma preorder_idempotent:\n  \"preorder x \\<Longrightarrow> idempotent x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder x \\<Longrightarrow> idempotent x", "using antisym mult_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. preorder x \\<Longrightarrow> idempotent x", "by fastforce"], ["", "text \\<open>\nWe study the following three ways of defining reflexive-transitive closures.\nEach of them is given as a least prefixpoint, but the underlying functions are different.\nThey implement left recursion, right recursion and symmetric recursion, respectively.\n\\<close>"], ["", "abbreviation Lf :: \"'a \\<Rightarrow> ('a \\<Rightarrow> 'a)\" where \"Lf y \\<equiv> (\\<lambda>x . 1 \\<squnion> x * y)\""], ["", "abbreviation Rf :: \"'a \\<Rightarrow> ('a \\<Rightarrow> 'a)\" where \"Rf y \\<equiv> (\\<lambda>x . 1 \\<squnion> y * x)\""], ["", "abbreviation Sf :: \"'a \\<Rightarrow> ('a \\<Rightarrow> 'a)\" where \"Sf y \\<equiv> (\\<lambda>x . 1 \\<squnion> y \\<squnion> x * x)\""], ["", "abbreviation lstar :: \"'a \\<Rightarrow> 'a\" where \"lstar y \\<equiv> p\\<mu> (Lf y)\""], ["", "abbreviation rstar :: \"'a \\<Rightarrow> 'a\" where \"rstar y \\<equiv> p\\<mu> (Rf y)\""], ["", "abbreviation sstar :: \"'a \\<Rightarrow> 'a\" where \"sstar y \\<equiv> p\\<mu> (Sf y)\""], ["", "text \\<open>\nAll functions are isotone and, therefore, if the prefixpoints exist they are also fixpoints.\n\\<close>"], ["", "lemma lstar_rec_isotone:\n  \"isotone (Lf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (\\<lambda>x. Rf x y)", "using isotone_def sup_right_divisibility sup_right_isotone mult_right_sub_dist_sup_right"], ["proof (prove)\nusing this:\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n  ?y * ?z \\<le> (?x \\<squnion> ?y) * ?z\n\ngoal (1 subgoal):\n 1. isotone (\\<lambda>x. Rf x y)", "by auto"], ["", "lemma rstar_rec_isotone:\n  \"isotone (Rf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (Rf y)", "using isotone_def sup_right_divisibility sup_right_isotone mult_left_sub_dist_sup_right"], ["proof (prove)\nusing this:\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n  (?x \\<le> ?y) = (\\<exists>z. z \\<squnion> ?x = ?y)\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n  ?x * ?z \\<le> ?x * (?y \\<squnion> ?z)\n\ngoal (1 subgoal):\n 1. isotone (Rf y)", "by auto"], ["", "lemma sstar_rec_isotone:\n  \"isotone (Sf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isotone (Sf y)", "using isotone_def sup_right_isotone mult_isotone"], ["proof (prove)\nusing this:\n  isotone ?f \\<equiv>\n  \\<forall>x y. x \\<le> y \\<longrightarrow> ?f x \\<le> ?f y\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n  \\<lbrakk>?w \\<le> ?y; ?x \\<le> ?z\\<rbrakk>\n  \\<Longrightarrow> ?w * ?x \\<le> ?y * ?z\n\ngoal (1 subgoal):\n 1. isotone (Sf y)", "by auto"], ["", "lemma lstar_fixpoint:\n  \"has_least_prefixpoint (Lf y) \\<Longrightarrow> lstar y = \\<mu> (Lf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_least_prefixpoint (\\<lambda>x. Rf x y) \\<Longrightarrow>\n    p\\<mu> (\\<lambda>x. Rf x y) = \\<mu> (\\<lambda>x. Rf x y)", "by (simp add: pmu_mu lstar_rec_isotone)"], ["", "lemma rstar_fixpoint:\n  \"has_least_prefixpoint (Rf y) \\<Longrightarrow> rstar y = \\<mu> (Rf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_least_prefixpoint (Rf y) \\<Longrightarrow> rstar y = \\<mu> Rf y", "by (simp add: pmu_mu rstar_rec_isotone)"], ["", "lemma sstar_fixpoint:\n  \"has_least_prefixpoint (Sf y) \\<Longrightarrow> sstar y = \\<mu> (Sf y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_least_prefixpoint (Sf y) \\<Longrightarrow> sstar y = \\<mu> Sf y", "by (simp add: pmu_mu sstar_rec_isotone)"], ["", "lemma sstar_increasing:\n  \"has_least_prefixpoint (Sf y) \\<Longrightarrow> y \\<le> sstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_least_prefixpoint (Sf y) \\<Longrightarrow> y \\<le> sstar y", "using order_trans pmu_unfold sup_ge1 sup_ge2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n  ?x \\<le> ?x \\<squnion> ?y\n  ?y \\<le> ?x \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. has_least_prefixpoint (Sf y) \\<Longrightarrow> y \\<le> sstar y", "by blast"], ["", "text \\<open>\nThe fixpoint given by right recursion is always below the one given by symmetric recursion.\n\\<close>"], ["", "lemma rstar_below_sstar:\n  assumes \"has_least_prefixpoint (Rf y)\"\n      and \"has_least_prefixpoint (Sf y)\"\n    shows \"rstar y \\<le> sstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "have \"y \\<le> sstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> sstar y", "using assms(2) pmu_unfold"], ["proof (prove)\nusing this:\n  has_least_prefixpoint (Sf y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. y \\<le> sstar y", "by force"], ["proof (state)\nthis:\n  y \\<le> sstar y\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "hence \"Rf y (sstar y) \\<le> Sf y (sstar y)\""], ["proof (prove)\nusing this:\n  y \\<le> sstar y\n\ngoal (1 subgoal):\n 1. Rf y (sstar y) \\<le> Sf y (sstar y)", "by (meson sup.cobounded1 sup.mono mult_left_isotone)"], ["proof (state)\nthis:\n  Rf y (sstar y) \\<le> Sf y (sstar y)\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "also"], ["proof (state)\nthis:\n  Rf y (sstar y) \\<le> Sf y (sstar y)\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "have \"... \\<le> sstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sf y (sstar y) \\<le> sstar y", "using assms(2) pmu_unfold"], ["proof (prove)\nusing this:\n  has_least_prefixpoint (Sf y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. Sf y (sstar y) \\<le> sstar y", "by blast"], ["proof (state)\nthis:\n  Sf y (sstar y) \\<le> sstar y\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "finally"], ["proof (chain)\npicking this:\n  Rf y (sstar y) \\<le> sstar y", "show ?thesis"], ["proof (prove)\nusing this:\n  Rf y (sstar y) \\<le> sstar y\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "using assms(1) is_least_prefixpoint_def least_prefixpoint"], ["proof (prove)\nusing this:\n  Rf y (sstar y) \\<le> sstar y\n  has_least_prefixpoint (Rf y)\n  is_least_prefixpoint ?f ?x \\<equiv>\n  ?f ?x \\<le> ?x \\<and>\n  (\\<forall>y. ?f y \\<le> y \\<longrightarrow> ?x \\<le> y)\n  has_least_prefixpoint ?f \\<Longrightarrow>\n  is_least_prefixpoint ?f (p\\<mu> ?f)\n\ngoal (1 subgoal):\n 1. rstar y \\<le> sstar y", "by auto"], ["proof (state)\nthis:\n  rstar y \\<le> sstar y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nOur next structure adds one half of the associativity property.\nThis inequality holds, for example, for multirelations under the compositions defined by Parikh and Peleg \\cite{Parikh1983,Peleg1987}.\nThe converse inequality requires up-closed multirelations for Parikh's composition.\n\\<close>"], ["", "class pre_left_semiring = non_associative_left_semiring +\n  assumes mult_semi_associative: \"(x * y) * z \\<le> x * (y * z)\"\nbegin"], ["", "lemma mult_one_associative [simp]:\n  \"x * 1 * y = x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (1::'a) * y = x * y", "by (metis dual_order.antisym mult_left_isotone mult_left_one mult_semi_associative mult_sub_right_one)"], ["", "lemma mult_sup_associative_one:\n  \"(x * (y * 1)) * z \\<le> x * (y * z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y * (1::'a)) * z \\<le> x * (y * z)", "by (metis mult_semi_associative mult_one_associative)"], ["", "lemma rstar_increasing:\n  assumes \"has_least_prefixpoint (Rf y)\"\n    shows \"y \\<le> rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<le> rstar y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<le> rstar y", "have \"Rf y (rstar y) \\<le> rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf y (rstar y) \\<le> rstar y", "using assms pmu_unfold"], ["proof (prove)\nusing this:\n  has_least_prefixpoint (Rf y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. Rf y (rstar y) \\<le> rstar y", "by blast"], ["proof (state)\nthis:\n  Rf y (rstar y) \\<le> rstar y\n\ngoal (1 subgoal):\n 1. y \\<le> rstar y", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rf y (rstar y) \\<le> rstar y\n\ngoal (1 subgoal):\n 1. y \\<le> rstar y", "by (metis le_supE mult_right_isotone mult_sub_right_one sup.absorb_iff2)"], ["proof (state)\nthis:\n  y \\<le> rstar y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nFor the next structure we add a left residual operation.\nSuch a residual is available, for example, for multirelations.\n\nThe operator notation for binary division is introduced in a class that requires a unary inverse.\nThis is appropriate for fields, but too strong in the present context of semirings.\nWe therefore reintroduce it without requiring a unary inverse.\n\\<close>"], ["", "no_notation\n  inverse_divide (infixl \"'/\" 70)"], ["", "notation\n  divide (infixl \"'/\" 70)"], ["", "class residuated_pre_left_semiring = pre_left_semiring + divide +\n  assumes lres_galois: \"x * y \\<le> z \\<longleftrightarrow> x \\<le> z / y\"\nbegin"], ["", "text \\<open>\nWe first derive basic properties of left residuals from the Galois connection.\n\\<close>"], ["", "lemma lres_left_isotone:\n  \"x \\<le> y \\<Longrightarrow> x / z \\<le> y / z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x / z \\<le> y / z", "using dual_order.trans lres_galois"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> x / z \\<le> y / z", "by blast"], ["", "lemma lres_right_antitone:\n  \"x \\<le> y \\<Longrightarrow> z / y \\<le> z / x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z / y \\<le> z / x", "using dual_order.trans lres_galois mult_right_isotone"], ["proof (prove)\nusing this:\n  \\<lbrakk>?b \\<le> ?a; ?c \\<le> ?b\\<rbrakk> \\<Longrightarrow> ?c \\<le> ?a\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. x \\<le> y \\<Longrightarrow> z / y \\<le> z / x", "by blast"], ["", "lemma lres_inverse:\n  \"(x / y) * y \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / y * y \\<le> x", "by (simp add: lres_galois)"], ["", "lemma lres_one:\n  \"x / 1 \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / (1::'a) \\<le> x", "using mult_sub_right_one order_trans lres_inverse"], ["proof (prove)\nusing this:\n  ?x \\<le> ?x * (1::'a)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x / ?y * ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. x / (1::'a) \\<le> x", "by blast"], ["", "lemma lres_mult_sub_lres_lres:\n  \"x / (z * y) \\<le> (x / y) / z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / (z * y) \\<le> x / y / z", "using lres_galois mult_semi_associative order.trans"], ["proof (prove)\nusing this:\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  ?x * ?y * ?z \\<le> ?x * (?y * ?z)\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n\ngoal (1 subgoal):\n 1. x / (z * y) \\<le> x / y / z", "by blast"], ["", "lemma mult_lres_sub_assoc:\n  \"x * (y / z) \\<le> (x * y) / z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (y / z) \\<le> x * y / z", "by (meson dual_order.trans lres_galois mult_right_isotone lres_inverse lres_mult_sub_lres_lres)"], ["", "text \\<open>\nWith the help of a left residual, it follows that left recursion is below right recursion.\n\\<close>"], ["", "lemma lstar_below_rstar:\n  assumes \"has_least_prefixpoint (Lf y)\"\n      and \"has_least_prefixpoint (Rf y)\"\n    shows \"lstar y \\<le> rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "have \"y * (rstar y / y) * y \\<le> y * rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * (rstar y / y) * y \\<le> y * rstar y", "using lres_galois mult_lres_sub_assoc"], ["proof (prove)\nusing this:\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  ?x * (?y / ?z) \\<le> ?x * ?y / ?z\n\ngoal (1 subgoal):\n 1. y * (rstar y / y) * y \\<le> y * rstar y", "by auto"], ["proof (state)\nthis:\n  y * (rstar y / y) * y \\<le> y * rstar y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "also"], ["proof (state)\nthis:\n  y * (rstar y / y) * y \\<le> y * rstar y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "have \"... \\<le> rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y * rstar y \\<le> rstar y", "using assms(2) le_supE pmu_unfold"], ["proof (prove)\nusing this:\n  has_least_prefixpoint (Rf y)\n  \\<lbrakk>?a \\<squnion> ?b \\<le> ?x;\n   \\<lbrakk>?a \\<le> ?x; ?b \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. y * rstar y \\<le> rstar y", "by blast"], ["proof (state)\nthis:\n  y * rstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "finally"], ["proof (chain)\npicking this:\n  y * (rstar y / y) * y \\<le> rstar y", "have \"y * (rstar y / y) \\<le> rstar y / y\""], ["proof (prove)\nusing this:\n  y * (rstar y / y) * y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. y * (rstar y / y) \\<le> rstar y / y", "by (simp add: lres_galois)"], ["proof (state)\nthis:\n  y * (rstar y / y) \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "hence \"Rf y (rstar y / y) \\<le> rstar y / y\""], ["proof (prove)\nusing this:\n  y * (rstar y / y) \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. Rf y (rstar y / y) \\<le> rstar y / y", "using assms(2) lres_galois rstar_increasing"], ["proof (prove)\nusing this:\n  y * (rstar y / y) \\<le> rstar y / y\n  has_least_prefixpoint (Rf y)\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  has_least_prefixpoint (Rf ?y) \\<Longrightarrow> ?y \\<le> rstar ?y\n\ngoal (1 subgoal):\n 1. Rf y (rstar y / y) \\<le> rstar y / y", "by fastforce"], ["proof (state)\nthis:\n  Rf y (rstar y / y) \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "hence \"rstar y \\<le> rstar y / y\""], ["proof (prove)\nusing this:\n  Rf y (rstar y / y) \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. rstar y \\<le> rstar y / y", "using assms(2) is_least_prefixpoint_def least_prefixpoint"], ["proof (prove)\nusing this:\n  Rf y (rstar y / y) \\<le> rstar y / y\n  has_least_prefixpoint (Rf y)\n  is_least_prefixpoint ?f ?x \\<equiv>\n  ?f ?x \\<le> ?x \\<and>\n  (\\<forall>y. ?f y \\<le> y \\<longrightarrow> ?x \\<le> y)\n  has_least_prefixpoint ?f \\<Longrightarrow>\n  is_least_prefixpoint ?f (p\\<mu> ?f)\n\ngoal (1 subgoal):\n 1. rstar y \\<le> rstar y / y", "by auto"], ["proof (state)\nthis:\n  rstar y \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "hence \"Lf y (rstar y) \\<le> rstar y\""], ["proof (prove)\nusing this:\n  rstar y \\<le> rstar y / y\n\ngoal (1 subgoal):\n 1. Rf (rstar y) y \\<le> rstar y", "using assms(2) lres_galois pmu_unfold"], ["proof (prove)\nusing this:\n  rstar y \\<le> rstar y / y\n  has_least_prefixpoint (Rf y)\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. Rf (rstar y) y \\<le> rstar y", "by fastforce"], ["proof (state)\nthis:\n  Rf (rstar y) y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "thus ?thesis"], ["proof (prove)\nusing this:\n  Rf (rstar y) y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "using assms(1) is_least_prefixpoint_def least_prefixpoint"], ["proof (prove)\nusing this:\n  Rf (rstar y) y \\<le> rstar y\n  has_least_prefixpoint (\\<lambda>x. Rf x y)\n  is_least_prefixpoint ?f ?x \\<equiv>\n  ?f ?x \\<le> ?x \\<and>\n  (\\<forall>y. ?f y \\<le> y \\<longrightarrow> ?x \\<le> y)\n  has_least_prefixpoint ?f \\<Longrightarrow>\n  is_least_prefixpoint ?f (p\\<mu> ?f)\n\ngoal (1 subgoal):\n 1. p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y", "by auto"], ["proof (state)\nthis:\n  p\\<mu> (\\<lambda>x. Rf x y) \\<le> rstar y\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\nMoreover, right recursion gives the same result as symmetric recursion.\nThe next proof follows an argument of \\cite[Satz 10.1.5]{Berghammer2012}.\n\\<close>"], ["", "lemma rstar_sstar:\n  assumes \"has_least_prefixpoint (Rf y)\"\n      and \"has_least_prefixpoint (Sf y)\"\n    shows \"rstar y = sstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rstar y = sstar y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rstar y = sstar y", "have \"Rf y (rstar y / rstar y) * rstar y \\<le> rstar y \\<squnion> y * ((rstar y / rstar y) * rstar y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rf y (rstar y / rstar y) * rstar y\n    \\<le> rstar y \\<squnion> y * (rstar y / rstar y * rstar y)", "using mult_right_dist_sup mult_semi_associative sup_right_isotone"], ["proof (prove)\nusing this:\n  (?x \\<squnion> ?y) * ?z = ?x * ?z \\<squnion> ?y * ?z\n  ?x * ?y * ?z \\<le> ?x * (?y * ?z)\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (1 subgoal):\n 1. Rf y (rstar y / rstar y) * rstar y\n    \\<le> rstar y \\<squnion> y * (rstar y / rstar y * rstar y)", "by auto"], ["proof (state)\nthis:\n  Rf y (rstar y / rstar y) * rstar y\n  \\<le> rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "also"], ["proof (state)\nthis:\n  Rf y (rstar y / rstar y) * rstar y\n  \\<le> rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "have \"... \\<le> rstar y \\<squnion> y * rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n    \\<le> rstar y \\<squnion> y * rstar y", "using mult_right_isotone sup_right_isotone lres_inverse"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n  ?x / ?y * ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n    \\<le> rstar y \\<squnion> y * rstar y", "by blast"], ["proof (state)\nthis:\n  rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n  \\<le> rstar y \\<squnion> y * rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "also"], ["proof (state)\nthis:\n  rstar y \\<squnion> y * (rstar y / rstar y * rstar y)\n  \\<le> rstar y \\<squnion> y * rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "have \"... \\<le> rstar y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rstar y \\<squnion> y * rstar y \\<le> rstar y", "using assms(1) pmu_unfold"], ["proof (prove)\nusing this:\n  has_least_prefixpoint (Rf y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. rstar y \\<squnion> y * rstar y \\<le> rstar y", "by fastforce"], ["proof (state)\nthis:\n  rstar y \\<squnion> y * rstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "finally"], ["proof (chain)\npicking this:\n  Rf y (rstar y / rstar y) * rstar y \\<le> rstar y", "have \"Rf y (rstar y / rstar y) \\<le> rstar y / rstar y\""], ["proof (prove)\nusing this:\n  Rf y (rstar y / rstar y) * rstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. Rf y (rstar y / rstar y) \\<le> rstar y / rstar y", "by (simp add: lres_galois)"], ["proof (state)\nthis:\n  Rf y (rstar y / rstar y) \\<le> rstar y / rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "hence \"rstar y * rstar y \\<le> rstar y\""], ["proof (prove)\nusing this:\n  Rf y (rstar y / rstar y) \\<le> rstar y / rstar y\n\ngoal (1 subgoal):\n 1. transitive (rstar y)", "using assms(1) is_least_prefixpoint_def least_prefixpoint lres_galois"], ["proof (prove)\nusing this:\n  Rf y (rstar y / rstar y) \\<le> rstar y / rstar y\n  has_least_prefixpoint (Rf y)\n  is_least_prefixpoint ?f ?x \\<equiv>\n  ?f ?x \\<le> ?x \\<and>\n  (\\<forall>y. ?f y \\<le> y \\<longrightarrow> ?x \\<le> y)\n  has_least_prefixpoint ?f \\<Longrightarrow>\n  is_least_prefixpoint ?f (p\\<mu> ?f)\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n\ngoal (1 subgoal):\n 1. transitive (rstar y)", "by auto"], ["proof (state)\nthis:\n  transitive (rstar y)\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "hence \"y \\<squnion> rstar y * rstar y \\<le> rstar y\""], ["proof (prove)\nusing this:\n  transitive (rstar y)\n\ngoal (1 subgoal):\n 1. y \\<squnion> rstar y * rstar y \\<le> rstar y", "by (simp add: assms(1) rstar_increasing)"], ["proof (state)\nthis:\n  y \\<squnion> rstar y * rstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "hence \"Sf y (rstar y) \\<le> rstar y\""], ["proof (prove)\nusing this:\n  y \\<squnion> rstar y * rstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. Sf y (rstar y) \\<le> rstar y", "using assms(1) pmu_unfold"], ["proof (prove)\nusing this:\n  y \\<squnion> rstar y * rstar y \\<le> rstar y\n  has_least_prefixpoint (Rf y)\n  has_least_prefixpoint ?f \\<Longrightarrow> ?f (p\\<mu> ?f) \\<le> p\\<mu> ?f\n\ngoal (1 subgoal):\n 1. Sf y (rstar y) \\<le> rstar y", "by force"], ["proof (state)\nthis:\n  Sf y (rstar y) \\<le> rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "hence \"sstar y \\<le> rstar y\""], ["proof (prove)\nusing this:\n  Sf y (rstar y) \\<le> rstar y\n\ngoal (1 subgoal):\n 1. sstar y \\<le> rstar y", "using assms(2) is_least_prefixpoint_def least_prefixpoint"], ["proof (prove)\nusing this:\n  Sf y (rstar y) \\<le> rstar y\n  has_least_prefixpoint (Sf y)\n  is_least_prefixpoint ?f ?x \\<equiv>\n  ?f ?x \\<le> ?x \\<and>\n  (\\<forall>y. ?f y \\<le> y \\<longrightarrow> ?x \\<le> y)\n  has_least_prefixpoint ?f \\<Longrightarrow>\n  is_least_prefixpoint ?f (p\\<mu> ?f)\n\ngoal (1 subgoal):\n 1. sstar y \\<le> rstar y", "by auto"], ["proof (state)\nthis:\n  sstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "thus ?thesis"], ["proof (prove)\nusing this:\n  sstar y \\<le> rstar y\n\ngoal (1 subgoal):\n 1. rstar y = sstar y", "by (simp add: assms antisym rstar_below_sstar)"], ["proof (state)\nthis:\n  rstar y = sstar y\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nIn the next structure we add full associativity of multiplication, as well as a right unit.\nStill, multiplication does not need to have a right zero and does not need to distribute over addition from the left.\n\\<close>"], ["", "class idempotent_left_semiring = non_associative_left_semiring + monoid_mult\nbegin"], ["", "subclass pre_left_semiring"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.pre_left_semiring (1::'a) (*) (\\<squnion>) (\\<le>) (<) bot", "by unfold_locales (simp add: mult_assoc)"], ["", "lemma zero_right_mult_decreasing:\n  \"x * bot \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * bot \\<le> x", "by (metis bot_least mult_1_right mult_right_isotone)"], ["", "text \\<open>\nThe following result shows that for dense coreflexives there are two equivalent ways to express that a property is preserved.\nIn the setting of Kleene algebras, this is well known for tests, which form a Boolean subalgebra.\nThe point here is that only very few properties of tests are needed to show the equivalence.\n\\<close>"], ["", "lemma test_preserves_equation:\n  assumes \"dense_rel p\"\n      and \"coreflexive p\"\n    shows \"p * x \\<le> x * p \\<longleftrightarrow> p * x = p * x * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (p * x \\<le> x * p) = (p * x = p * x * p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p * x \\<le> x * p \\<Longrightarrow> p * x = p * x * p\n 2. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "assume 1: \"p * x \\<le> x * p\""], ["proof (state)\nthis:\n  p * x \\<le> x * p\n\ngoal (2 subgoals):\n 1. p * x \\<le> x * p \\<Longrightarrow> p * x = p * x * p\n 2. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "have \"p * x \\<le> p * p * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * x \\<le> p * p * x", "by (simp add: assms(1) mult_left_isotone)"], ["proof (state)\nthis:\n  p * x \\<le> p * p * x\n\ngoal (2 subgoals):\n 1. p * x \\<le> x * p \\<Longrightarrow> p * x = p * x * p\n 2. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "also"], ["proof (state)\nthis:\n  p * x \\<le> p * p * x\n\ngoal (2 subgoals):\n 1. p * x \\<le> x * p \\<Longrightarrow> p * x = p * x * p\n 2. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "have \"... \\<le> p * x * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p * p * x \\<le> p * x * p", "using 1"], ["proof (prove)\nusing this:\n  p * x \\<le> x * p\n\ngoal (1 subgoal):\n 1. p * p * x \\<le> p * x * p", "by (simp add: mult_right_isotone mult_assoc)"], ["proof (state)\nthis:\n  p * p * x \\<le> p * x * p\n\ngoal (2 subgoals):\n 1. p * x \\<le> x * p \\<Longrightarrow> p * x = p * x * p\n 2. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "finally"], ["proof (chain)\npicking this:\n  p * x \\<le> p * x * p", "show \"p * x = p * x * p\""], ["proof (prove)\nusing this:\n  p * x \\<le> p * x * p\n\ngoal (1 subgoal):\n 1. p * x = p * x * p", "using assms(2) antisym mult_right_isotone"], ["proof (prove)\nusing this:\n  p * x \\<le> p * x * p\n  coreflexive p\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n\ngoal (1 subgoal):\n 1. p * x = p * x * p", "by fastforce"], ["proof (state)\nthis:\n  p * x = p * x * p\n\ngoal (1 subgoal):\n 1. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "assume \"p * x = p * x * p\""], ["proof (state)\nthis:\n  p * x = p * x * p\n\ngoal (1 subgoal):\n 1. p * x = p * x * p \\<Longrightarrow> p * x \\<le> x * p", "thus \"p * x \\<le> x * p\""], ["proof (prove)\nusing this:\n  p * x = p * x * p\n\ngoal (1 subgoal):\n 1. p * x \\<le> x * p", "by (metis assms(2) mult_left_isotone mult_left_one)"], ["proof (state)\nthis:\n  p * x \\<le> x * p\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\nThe next structure has both distributivity properties of multiplication.\nOnly a right zero is missing from full semirings.\nThis is important as many computation models do not have a right zero of sequential composition.\n\\<close>"], ["", "class idempotent_left_zero_semiring = idempotent_left_semiring +\n  assumes mult_left_dist_sup: \"x * (y \\<squnion> z) = x * y \\<squnion> x * z\"\nbegin"], ["", "lemma case_split_right:\n  assumes \"1 \\<le> w \\<squnion> z\"\n      and \"x * w \\<le> y\"\n      and \"x * z \\<le> y\"\n    shows \"x \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<le> y", "have \"x * (w \\<squnion> z) \\<le> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * (w \\<squnion> z) \\<le> y", "by (simp add: assms(2-3) mult_left_dist_sup)"], ["proof (state)\nthis:\n  x * (w \\<squnion> z) \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x * (w \\<squnion> z) \\<le> y\n\ngoal (1 subgoal):\n 1. x \\<le> y", "by (metis assms(1) dual_order.trans mult_1_right mult_right_isotone)"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma case_split_right_equal:\n  \"w \\<squnion> z = 1 \\<Longrightarrow> x * w = y * w \\<Longrightarrow> x * z = y * z \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w \\<squnion> z = (1::'a); x * w = y * w; x * z = y * z\\<rbrakk>\n    \\<Longrightarrow> x = y", "by (metis mult_1_right mult_left_dist_sup)"], ["", "text \\<open>\nThis is the first structure we can connect to the semirings provided by Isabelle/HOL.\n\\<close>"], ["", "sublocale semiring: ordered_semiring sup bot less_eq less times"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.ordered_semiring (\\<squnion>) bot (\\<le>) (<) (*)", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>a b c.\n       a \\<le> b \\<Longrightarrow> c \\<squnion> a \\<le> c \\<squnion> b\n 2. \\<And>a b c. (a \\<squnion> b) * c = a * c \\<squnion> b * c\n 3. \\<And>a b c. a * (b \\<squnion> c) = a * b \\<squnion> a * c\n 4. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * a \\<le> c * b\n 5. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "using sup_right_isotone"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z \\<squnion> ?x \\<le> ?z \\<squnion> ?y\n\ngoal (5 subgoals):\n 1. \\<And>a b c.\n       a \\<le> b \\<Longrightarrow> c \\<squnion> a \\<le> c \\<squnion> b\n 2. \\<And>a b c. (a \\<squnion> b) * c = a * c \\<squnion> b * c\n 3. \\<And>a b c. a * (b \\<squnion> c) = a * b \\<squnion> a * c\n 4. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * a \\<le> c * b\n 5. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b c. (a \\<squnion> b) * c = a * c \\<squnion> b * c\n 2. \\<And>a b c. a * (b \\<squnion> c) = a * b \\<squnion> a * c\n 3. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * a \\<le> c * b\n 4. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "apply (simp add: mult_right_dist_sup)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c. a * (b \\<squnion> c) = a * b \\<squnion> a * c\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * a \\<le> c * b\n 3. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "apply (simp add: mult_left_dist_sup)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> c * a \\<le> c * b\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "apply (simp add: mult_right_isotone)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<le> b; bot \\<le> c\\<rbrakk>\n       \\<Longrightarrow> a * c \\<le> b * c", "by (simp add: mult_left_isotone)"], ["", "sublocale semiring: semiring_numeral 1 times sup"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_numeral (1::'a) (*) (\\<squnion>)", ".."], ["", "end"], ["", "text \\<open>\nCompleting this part of the hierarchy, we obtain idempotent semirings by adding a right zero of multiplication.\n\\<close>"], ["", "class idempotent_semiring = idempotent_left_zero_semiring +\n  assumes mult_right_zero [simp]: \"x * bot = bot\"\nbegin"], ["", "sublocale semiring: semiring_0 sup bot times"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.semiring_0 (\\<squnion>) bot (*)", "by unfold_locales simp_all"], ["", "end"], ["", "subsection \\<open>Bounded Idempotent Semirings\\<close>"], ["", "text \\<open>\nAll of the following semirings have a greatest element in the underlying semilattice order.\nWith this element, we can express further standard properties of relations.\nWe extend each class in the above hierarchy in turn.\n\\<close>"], ["", "class times_top = times + top\nbegin"], ["", "abbreviation vector     :: \"'a \\<Rightarrow> bool\" where \"vector x     \\<equiv> x * top = x\""], ["", "abbreviation covector   :: \"'a \\<Rightarrow> bool\" where \"covector x   \\<equiv> top * x = x\""], ["", "abbreviation total      :: \"'a \\<Rightarrow> bool\" where \"total x      \\<equiv> x * top = top\""], ["", "abbreviation surjective :: \"'a \\<Rightarrow> bool\" where \"surjective x \\<equiv> top * x = top\""], ["", "abbreviation \"vectors   \\<equiv> { x . vector x }\""], ["", "abbreviation \"covectors \\<equiv> { x . covector x }\""], ["", "end"], ["", "class bounded_non_associative_left_semiring = non_associative_left_semiring + top +\n  assumes sup_right_top [simp]: \"x \\<squnion> top = top\"\nbegin"], ["", "subclass times_top"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text \\<open>\nWe first give basic properties of the greatest element.\n\\<close>"], ["", "lemma sup_left_top [simp]:\n  \"top \\<squnion> x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top \\<squnion> x = top", "using sup_right_top sup.commute"], ["proof (prove)\nusing this:\n  ?x \\<squnion> top = top\n  ?a \\<squnion> ?b = ?b \\<squnion> ?a\n\ngoal (1 subgoal):\n 1. top \\<squnion> x = top", "by fastforce"], ["", "lemma top_greatest [simp]:\n  \"x \\<le> top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> top", "by (simp add: le_iff_sup)"], ["", "lemma top_left_mult_increasing:\n  \"x \\<le> top * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> top * x", "by (metis mult_left_isotone mult_left_one top_greatest)"], ["", "lemma top_right_mult_increasing:\n  \"x \\<le> x * top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<le> x * top", "using mult_right_isotone mult_sub_right_one order_trans top_greatest"], ["proof (prove)\nusing this:\n  ?x \\<le> ?y \\<Longrightarrow> ?z * ?x \\<le> ?z * ?y\n  ?x \\<le> ?x * (1::'a)\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n  ?x \\<le> top\n\ngoal (1 subgoal):\n 1. x \\<le> x * top", "by blast"], ["", "lemma top_mult_top [simp]:\n  \"top * top = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by (simp add: antisym top_left_mult_increasing)"], ["", "text \\<open>\nClosure of the above properties under the semiring operations is considered next.\n\\<close>"], ["", "lemma vector_bot_closed:\n  \"vector bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector bot", "by simp"], ["", "lemma vector_top_closed:\n  \"vector top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma vector_sup_closed:\n  \"vector x \\<Longrightarrow> vector y \\<Longrightarrow> vector (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>vector x; vector y\\<rbrakk>\n    \\<Longrightarrow> vector (x \\<squnion> y)", "by (simp add: mult_right_dist_sup)"], ["", "lemma covector_top_closed:\n  \"covector top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma total_one_closed:\n  \"total 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total (1::'a)", "by simp"], ["", "lemma total_top_closed:\n  \"total top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma total_sup_closed:\n  \"total x \\<Longrightarrow> total (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. times_top_class.total x \\<Longrightarrow>\n    times_top_class.total (x \\<squnion> y)", "by (simp add: mult_right_dist_sup)"], ["", "lemma surjective_one_closed:\n  \"surjective 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective (1::'a)", "by (simp add: antisym mult_sub_right_one)"], ["", "lemma surjective_top_closed:\n  \"surjective top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma surjective_sup_closed:\n  \"surjective x \\<Longrightarrow> surjective (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective x \\<Longrightarrow> surjective (x \\<squnion> y)", "by (metis le_iff_sup mult_left_sub_dist_sup_left sup_left_top)"], ["", "lemma reflexive_top_closed:\n  \"reflexive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reflexive top", "by simp"], ["", "lemma transitive_top_closed:\n  \"transitive top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transitive top", "by simp"], ["", "lemma dense_top_closed:\n  \"dense_rel top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dense_rel top", "by simp"], ["", "lemma idempotent_top_closed:\n  \"idempotent top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. surjective top", "by simp"], ["", "lemma preorder_top_closed:\n  \"preorder top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. preorder top", "by simp"], ["", "end"], ["", "text \\<open>\nSome closure properties require at least half of associativity.\n\\<close>"], ["", "class bounded_pre_left_semiring = pre_left_semiring + bounded_non_associative_left_semiring\nbegin"], ["", "lemma vector_mult_closed:\n  \"vector y \\<Longrightarrow> vector (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vector y \\<Longrightarrow> vector (x * y)", "by (metis antisym mult_semi_associative top_right_mult_increasing)"], ["", "lemma surjective_mult_closed:\n  \"surjective x \\<Longrightarrow> surjective y \\<Longrightarrow> surjective (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>surjective x; surjective y\\<rbrakk>\n    \\<Longrightarrow> surjective (x * y)", "by (metis antisym mult_semi_associative top_greatest)"], ["", "end"], ["", "text \\<open>\nWe next consider residuals with the greatest element.\n\\<close>"], ["", "class bounded_residuated_pre_left_semiring = residuated_pre_left_semiring + bounded_pre_left_semiring\nbegin"], ["", "lemma lres_top_decreasing:\n  \"x / top \\<le> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x / top \\<le> x", "using lres_inverse order.trans top_right_mult_increasing"], ["proof (prove)\nusing this:\n  ?x / ?y * ?y \\<le> ?x\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n  ?x \\<le> ?x * top\n\ngoal (1 subgoal):\n 1. x / top \\<le> x", "by blast"], ["", "lemma top_lres_absorb [simp]:\n  \"top / x = top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. top / x = top", "using antisym lres_galois top_greatest"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?x\\<rbrakk> \\<Longrightarrow> ?x = ?y\n  (?x * ?y \\<le> ?z) = (?x \\<le> ?z / ?y)\n  ?x \\<le> top\n\ngoal (1 subgoal):\n 1. top / x = top", "by blast"], ["", "lemma covector_lres_closed:\n  \"covector x \\<Longrightarrow> covector (x / y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow> covector (x / y)", "by (metis antisym mult_lres_sub_assoc top_left_mult_increasing)"], ["", "end"], ["", "text \\<open>\nSome closure properties require full associativity.\n\\<close>"], ["", "class bounded_idempotent_left_semiring = bounded_pre_left_semiring + idempotent_left_semiring\nbegin"], ["", "lemma covector_mult_closed:\n  \"covector x \\<Longrightarrow> covector (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector x \\<Longrightarrow> covector (x * y)", "by (metis mult_assoc)"], ["", "lemma total_mult_closed:\n  \"total x \\<Longrightarrow> total y \\<Longrightarrow> total (x * y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>times_top_class.total x; times_top_class.total y\\<rbrakk>\n    \\<Longrightarrow> times_top_class.total (x * y)", "by (simp add: mult_assoc)"], ["", "end"], ["", "text \\<open>\nSome closure properties require distributivity from the left.\n\\<close>"], ["", "class bounded_idempotent_left_zero_semiring = bounded_idempotent_left_semiring + idempotent_left_zero_semiring\nbegin"], ["", "lemma covector_sup_closed:\n  \"covector x \\<Longrightarrow> covector y \\<Longrightarrow> covector (x \\<squnion> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>covector x; covector y\\<rbrakk>\n    \\<Longrightarrow> covector (x \\<squnion> y)", "by (simp add: mult_left_dist_sup)"], ["", "end"], ["", "text \\<open>\nOur final structure is an idempotent semiring with a greatest element.\n\\<close>"], ["", "class bounded_idempotent_semiring = bounded_idempotent_left_zero_semiring + idempotent_semiring\nbegin"], ["", "lemma covector_bot_closed:\n  \"covector bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. covector bot", "by simp"], ["", "end"], ["", "end"]]}