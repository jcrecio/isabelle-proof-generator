{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/basic_types/UML_Integer.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma  \"\\<delta>(null::('\\<AA>)Integer) = false\"", "lemma  \"\\<upsilon>(null::('\\<AA>)Integer) = true\"", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<one> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<one> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<two> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<two> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<six> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<six> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<eight> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<eight> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<nine> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<nine> = true\"", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_commute: \"(X +\\<^sub>i\\<^sub>n\\<^sub>t Y) = (Y +\\<^sub>i\\<^sub>n\\<^sub>t X)\"", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_zero1[simp,code_unfold] :\n\"(x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\"", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_zero2[simp,code_unfold] :\n\"(\\<zero> +\\<^sub>i\\<^sub>n\\<^sub>t x) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\"", "lemma integer_non_null [simp]: \"((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> (null::('\\<AA>)Integer)) = false\"", "lemma null_non_integer [simp]: \"((null::('\\<AA>)Integer) \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) = false\"", "lemma OclInt0_non_null [simp,code_unfold]: \"(\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclInt0 [simp,code_unfold]: \"(null \\<doteq> \\<zero>) = false\"", "lemma OclInt1_non_null [simp,code_unfold]: \"(\\<one> \\<doteq> null) = false\"", "lemma null_non_OclInt1 [simp,code_unfold]: \"(null \\<doteq> \\<one>) = false\"", "lemma OclInt2_non_null [simp,code_unfold]: \"(\\<two> \\<doteq> null) = false\"", "lemma null_non_OclInt2 [simp,code_unfold]: \"(null \\<doteq> \\<two>) = false\"", "lemma OclInt6_non_null [simp,code_unfold]: \"(\\<six> \\<doteq> null) = false\"", "lemma null_non_OclInt6 [simp,code_unfold]: \"(null \\<doteq> \\<six>) = false\"", "lemma OclInt8_non_null [simp,code_unfold]: \"(\\<eight> \\<doteq> null) = false\"", "lemma null_non_OclInt8 [simp,code_unfold]: \"(null \\<doteq> \\<eight>) = false\"", "lemma OclInt9_non_null [simp,code_unfold]: \"(\\<nine> \\<doteq> null) = false\"", "lemma null_non_OclInt9 [simp,code_unfold]: \"(null \\<doteq> \\<nine>) = false\""], "translations": [["", "lemma  \"\\<delta>(null::('\\<AA>)Integer) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> null = false", "by simp"], ["", "lemma  \"\\<upsilon>(null::('\\<AA>)Integer) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> null = true", "by simp"], ["", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:defined_def true_def\n               bot_fun_def bot_option_def null_fun_def null_option_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:valid_def true_def\n               bot_fun_def bot_option_def)"], ["", "(* ecclectic proofs to make examples executable *)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<zero> = true", "by(simp add:OclInt0_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<zero> = true", "by(simp add:OclInt0_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<one> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<one> = true", "by(simp add:OclInt1_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<one> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<one> = true", "by(simp add:OclInt1_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<two> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<two> = true", "by(simp add:OclInt2_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<two> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<two> = true", "by(simp add:OclInt2_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<six> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<six> = true", "by(simp add:OclInt6_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<six> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<six> = true", "by(simp add:OclInt6_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<eight> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<eight> = true", "by(simp add:OclInt8_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<eight> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<eight> = true", "by(simp add:OclInt8_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<nine> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<nine> = true", "by(simp add:OclInt9_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<nine> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<nine> = true", "by(simp add:OclInt9_def)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Arithmetical Operations\\<close>"], ["", "subsubsection\\<open>Definition\\<close>"], ["", "text\\<open>Here is a common case of a built-in operation on built-in types.\nNote that the arguments must be both defined (non-null, non-bot).\\<close>"], ["", "text\\<open>Note that we can not follow the lexis of the OCL Standard for Isabelle\ntechnical reasons; these operators are heavily overloaded in the HOL library\nthat a further overloading would lead to heavy technical buzz in this\ndocument.\n\\<close>"], ["", "definition OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer\" (infix \"+\\<^sub>i\\<^sub>n\\<^sub>t\" 40)\nwhere \"x +\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> + \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r : profile_bin\\<^sub>d_\\<^sub>d \"(+\\<^sub>i\\<^sub>n\\<^sub>t)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> + \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (+\\<^sub>i\\<^sub>n\\<^sub>t)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> +\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by unfold_locales (auto simp:OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def bot_option_def null_option_def)"], ["", "definition OclMinus\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer\" (infix \"-\\<^sub>i\\<^sub>n\\<^sub>t\" 41)\nwhere \"x -\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> - \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclMinus\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r : profile_bin\\<^sub>d_\\<^sub>d \"(-\\<^sub>i\\<^sub>n\\<^sub>t)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> - \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (-\\<^sub>i\\<^sub>n\\<^sub>t)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> -\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclMinus\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def bot_option_def null_option_def)"], ["", "definition OclMult\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer\" (infix \"*\\<^sub>i\\<^sub>n\\<^sub>t\" 45)\nwhere \"x *\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> * \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau>\""], ["", "interpretation OclMult\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r : profile_bin\\<^sub>d_\\<^sub>d \"OclMult\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> * \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (*\\<^sub>i\\<^sub>n\\<^sub>t)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> *\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclMult\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def bot_option_def null_option_def)"], ["", "text\\<open>Here is the special case of division, which is defined as invalid for division\nby zero.\\<close>"], ["", "definition OclDivision\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer\" (infix \"div\\<^sub>i\\<^sub>n\\<^sub>t\" 45)\nwhere \"x div\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then if y \\<tau> \\<noteq> OclInt0 \\<tau> then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> div \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> else invalid \\<tau> \n                       else invalid \\<tau> \""], ["", "(* TODO: special locale setup.*)"], ["", "definition OclModulus\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer\" (infix \"mod\\<^sub>i\\<^sub>n\\<^sub>t\" 45)\nwhere \"x mod\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then if y \\<tau> \\<noteq> OclInt0 \\<tau> then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> mod \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> else invalid \\<tau> \n                       else invalid \\<tau> \""], ["", "(* TODO: special locale setup.*)"], ["", "definition OclLess\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Boolean\" (infix \"<\\<^sub>i\\<^sub>n\\<^sub>t\" 35)\nwhere \"x <\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> < \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclLess\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r : profile_bin\\<^sub>d_\\<^sub>d \"(<\\<^sub>i\\<^sub>n\\<^sub>t)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> < \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (<\\<^sub>i\\<^sub>n\\<^sub>t)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil>\n                           < \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclLess\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def bot_option_def null_option_def)"], ["", "definition OclLe\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r ::\"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Boolean\" (infix \"\\<le>\\<^sub>i\\<^sub>n\\<^sub>t\" 35)\nwhere \"x \\<le>\\<^sub>i\\<^sub>n\\<^sub>t y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> \\<le> \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclLe\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r : profile_bin\\<^sub>d_\\<^sub>d \"(\\<le>\\<^sub>i\\<^sub>n\\<^sub>t)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> \\<le> \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (\\<le>\\<^sub>i\\<^sub>n\\<^sub>t)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil>\n                           \\<le> \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclLe\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def bot_option_def null_option_def)"], ["", "subsubsection\\<open>Basic Properties\\<close>"], ["", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_commute: \"(X +\\<^sub>i\\<^sub>n\\<^sub>t Y) = (Y +\\<^sub>i\\<^sub>n\\<^sub>t X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X +\\<^sub>i\\<^sub>n\\<^sub>t Y) = (Y +\\<^sub>i\\<^sub>n\\<^sub>t X)", "by(rule ext,auto simp:true_def false_def OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def invalid_def\n                   split: option.split option.split_asm\n                          bool.split bool.split_asm)"], ["", "subsubsection\\<open>Execution with Invalid or Null or Zero as Argument\\<close>"], ["", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_zero1[simp,code_unfold] :\n\"(x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)", "proof (rule ext, rename_tac \\<tau>, case_tac \"(\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>\n 2. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "fix \\<tau>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>\n 2. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "show \"(\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau> \\<Longrightarrow>\n              (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n    true \\<tau> \\<Longrightarrow>\n    (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>", "apply(subst OclIf_true', simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n    true \\<tau> \\<Longrightarrow>\n    (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> = invalid \\<tau>", "by (metis OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def OclNot_defargs OclValid_def foundation5 foundation9)"], ["proof (state)\nthis:\n  (\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau> \\<Longrightarrow>\n  (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n  (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "fix \\<tau>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "have A: \"\\<And>\\<tau>. (\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) = (x \\<tau> = invalid \\<tau> \\<or> \\<tau> \\<Turnstile> \\<delta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) =\n       (x \\<tau> = invalid \\<tau> \\<or> \\<tau> \\<Turnstile> \\<delta> x)", "by (metis OclNot_not OclOr_def defined5 defined6 defined_not_I foundation11 foundation18'\n            foundation6 foundation7 foundation9 invalid_def)"], ["proof (state)\nthis:\n  (?\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) =\n  (x ?\\<tau> = invalid ?\\<tau> \\<or> ?\\<tau> \\<Turnstile> \\<delta> x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "have B: \"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> = x \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    x \\<tau>", "apply(cases \"x \\<tau>\", metis bot_option_def foundation16)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n        x \\<tau> = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                      \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         x \\<tau>", "apply(rename_tac x', case_tac x', metis bot_option_def foundation16 null_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x' a.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n        x \\<tau> = \\<lfloor>x'\\<rfloor>; x' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                      \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         x \\<tau>", "by(simp)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n  \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n  x \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "show \"(x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\"\n    when \"\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>", "apply(insert that, subst OclIf_false', simp, simp add: A, auto simp: OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_def OclInt0_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<tau> = invalid \\<tau>;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>invalid\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      invalid \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 3. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "(* *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<tau> = invalid \\<tau>;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>invalid\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      invalid \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 3. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "apply(simp add: foundation16'[simplified OclValid_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "apply(simp add: B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "by(simp add: OclValid_def)"], ["proof (state)\nthis:\n  \\<tau>\n   \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x)) \\<Longrightarrow>\n  (x +\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>) \\<tau> =\n  (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       \\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))", "qed(metis OclValid_def defined5 defined6 defined_and_I defined_not_I foundation9)"], ["", "lemma OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_zero2[simp,code_unfold] :\n\"(\\<zero> +\\<^sub>i\\<^sub>n\\<^sub>t x) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<zero> +\\<^sub>i\\<^sub>n\\<^sub>t x) =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)", "by(subst OclAdd\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r_commute, simp)"], ["", "(* TODO Basic proproperties for multiplication, division, modulus. *)"], ["", "subsection\\<open>Test Statements\\<close>"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> ( \\<nine> \\<le>\\<^sub>i\\<^sub>n\\<^sub>t \\<one>\\<zero> )\""], ["", "Assert \"\\<tau> \\<Turnstile> (( \\<four> +\\<^sub>i\\<^sub>n\\<^sub>t \\<four> ) \\<le>\\<^sub>i\\<^sub>n\\<^sub>t \\<one>\\<zero> )\""], ["", "Assert \"\\<tau> |\\<noteq> (( \\<four> +\\<^sub>i\\<^sub>n\\<^sub>t ( \\<four> +\\<^sub>i\\<^sub>n\\<^sub>t \\<four> )) <\\<^sub>i\\<^sub>n\\<^sub>t \\<one>\\<zero> )\""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<upsilon> (null +\\<^sub>i\\<^sub>n\\<^sub>t \\<one>)) \""], ["", "Assert \"\\<tau> \\<Turnstile> (((\\<nine> *\\<^sub>i\\<^sub>n\\<^sub>t \\<four>) div\\<^sub>i\\<^sub>n\\<^sub>t \\<one>\\<zero>) \\<le>\\<^sub>i\\<^sub>n\\<^sub>t  \\<four>) \""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<delta> (\\<one> div\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>)) \""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<upsilon> (\\<one> div\\<^sub>i\\<^sub>n\\<^sub>t \\<zero>)) \""], ["", "lemma integer_non_null [simp]: \"((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> (null::('\\<AA>)Integer)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> null) =\n    false", "by(rule ext,auto simp: StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r valid_def\n                         bot_fun_def bot_option_def null_fun_def null_option_def StrongEq_def)"], ["", "lemma null_non_integer [simp]: \"((null::('\\<AA>)Integer) \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) =\n    false", "by(rule ext,auto simp: StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r valid_def\n                         bot_fun_def bot_option_def null_fun_def null_option_def StrongEq_def)"], ["", "lemma OclInt0_non_null [simp,code_unfold]: \"(\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<zero> \\<doteq> null) = false", "by(simp add: OclInt0_def)"], ["", "lemma null_non_OclInt0 [simp,code_unfold]: \"(null \\<doteq> \\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<zero>) = false", "by(simp add: OclInt0_def)"], ["", "lemma OclInt1_non_null [simp,code_unfold]: \"(\\<one> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<one> \\<doteq> null) = false", "by(simp add: OclInt1_def)"], ["", "lemma null_non_OclInt1 [simp,code_unfold]: \"(null \\<doteq> \\<one>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<one>) = false", "by(simp add: OclInt1_def)"], ["", "lemma OclInt2_non_null [simp,code_unfold]: \"(\\<two> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<two> \\<doteq> null) = false", "by(simp add: OclInt2_def)"], ["", "lemma null_non_OclInt2 [simp,code_unfold]: \"(null \\<doteq> \\<two>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<two>) = false", "by(simp add: OclInt2_def)"], ["", "lemma OclInt6_non_null [simp,code_unfold]: \"(\\<six> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<six> \\<doteq> null) = false", "by(simp add: OclInt6_def)"], ["", "lemma null_non_OclInt6 [simp,code_unfold]: \"(null \\<doteq> \\<six>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<six>) = false", "by(simp add: OclInt6_def)"], ["", "lemma OclInt8_non_null [simp,code_unfold]: \"(\\<eight> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<eight> \\<doteq> null) = false", "by(simp add: OclInt8_def)"], ["", "lemma null_non_OclInt8 [simp,code_unfold]: \"(null \\<doteq> \\<eight>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<eight>) = false", "by(simp add: OclInt8_def)"], ["", "lemma OclInt9_non_null [simp,code_unfold]: \"(\\<nine> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nine> \\<doteq> null) = false", "by(simp add: OclInt9_def)"], ["", "lemma null_non_OclInt9 [simp,code_unfold]: \"(null \\<doteq> \\<nine>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<nine>) = false", "by(simp add: OclInt9_def)"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "text\\<open>Elementary computations on Integer\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> ((\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t \\<two>) and (\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t \\<one>))\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<one> <> \\<two>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<two> <> \\<one>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<two> \\<doteq> \\<two>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> \\<four>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<delta> \\<four>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> (null::('\\<AA>)Integer)\""], ["", "Assert \"\\<tau> \\<Turnstile> (invalid \\<triangleq> invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<triangleq> null)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four> \\<triangleq> \\<four>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<nine> \\<triangleq> \\<one>\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<triangleq> \\<one>\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (null \\<triangleq> \\<one>\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<doteq> (invalid::('\\<AA>)Integer))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid \\<doteq> (invalid::('\\<AA>)Integer))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> (invalid <> (invalid::('\\<AA>)Integer))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid <> (invalid::('\\<AA>)Integer))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)Integer) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)Integer) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four> \\<doteq> \\<four>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<four> <> \\<four>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<four> \\<doteq> \\<one>\\<zero>)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four> <> \\<one>\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t null)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<delta> (\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t null))\""], ["", "end"]]}