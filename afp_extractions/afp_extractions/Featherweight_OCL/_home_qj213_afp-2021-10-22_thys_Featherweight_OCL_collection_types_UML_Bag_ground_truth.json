{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/collection_types/UML_Bag.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma Integer_defined : \"\\<delta> Integer = true\"", "lemma Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\"", "lemma Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\"", "lemma Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y_defined : \"\\<delta> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y = true\"", "lemma assumes \"\\<tau> \\<Turnstile> \\<delta> (V :: ('\\<AA>,Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag)\"\n      shows   \"\\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\"", "lemma Boolean_defined : \"\\<delta> Boolean = true\"", "lemma Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\"", "lemma String_defined : \"\\<delta> String = true\"", "lemma String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\"", "lemma Real_defined : \"\\<delta> Real = true\"", "lemma Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\"", "lemma Bag_inv_lemma: \"\\<tau> \\<Turnstile> (\\<delta> X) \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> bot = 0\"", "lemma Bag_inv_lemma' :\n assumes x_def : \"\\<tau> \\<Turnstile> \\<delta> X\"\n     and e_mem : \"\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> e \\<ge> 1\"\n   shows \"\\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. e)\"", "lemma abs_rep_simp' :\n assumes S_all_def : \"\\<tau> \\<Turnstile> \\<delta> S\"\n   shows \"Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> = S \\<tau>\"", "lemma invalid_bag_OclNot_defined [simp,code_unfold]:\"\\<delta>(invalid::('\\<AA>,'\\<alpha>::null) Bag) = false\"", "lemma null_bag_OclNot_defined [simp,code_unfold]:\"\\<delta>(null::('\\<AA>,'\\<alpha>::null) Bag) = false\"", "lemma invalid_bag_valid [simp,code_unfold]:\"\\<upsilon>(invalid::('\\<AA>,'\\<alpha>::null) Bag) = false\"", "lemma null_bag_valid [simp,code_unfold]:\"\\<upsilon>(null::('\\<AA>,'\\<alpha>::null) Bag) = true\"", "lemma mtBag_defined[simp,code_unfold]:\"\\<delta>(Bag{}) = true\"", "lemma mtBag_valid[simp,code_unfold]:\"\\<upsilon>(Bag{}) = true\"", "lemma mtBag_rep_bag: \"\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Bag{} \\<tau>)\\<rceil>\\<rceil> = (\\<lambda> _. 0)\"", "lemma [simp,code_unfold]: \"const Bag{}\"", "lemma OclIncluding_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->including\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\"", "lemma OclIncluding_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->including\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\"", "lemma OclExcluding_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\"", "lemma OclExcluding_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\"", "lemma OclIncludes_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\"", "lemma OclIncludes_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\"", "lemma OclExcludes_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\"", "lemma OclExcludes_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\"", "lemma OclSize_defined_args_valid: \"\\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> X\"", "lemma OclSize_infinite:\nassumes non_finite:\"\\<tau> \\<Turnstile> not(\\<delta>(S->size\\<^sub>B\\<^sub>a\\<^sub>g()))\"\nshows   \"(\\<tau> \\<Turnstile> not(\\<delta>(S))) \\<or> \\<not> finite (Rep_Bag_base S \\<tau>)\"", "lemma \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma size_defined:\n assumes X_finite: \"\\<And>\\<tau>. finite (Rep_Bag_base X \\<tau>)\"\n shows \"\\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g()) = \\<delta> X\"", "lemma size_defined':\n assumes X_finite: \"finite (Rep_Bag_base X \\<tau>)\"\n shows \"(\\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g())) = (\\<tau> \\<Turnstile> \\<delta> X)\"", "lemma OclIsEmpty_defined_args_valid:\"\\<tau> \\<Turnstile> \\<delta> (X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\"", "lemma \"\\<tau> \\<Turnstile> \\<delta> (null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma OclIsEmpty_infinite: \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma OclNotEmpty_defined_args_valid:\"\\<tau> \\<Turnstile> \\<delta> (X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\"", "lemma \"\\<tau> \\<Turnstile> \\<delta> (null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma OclNotEmpty_infinite: \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma OclNotEmpty_has_elt : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n                          \\<exists>e. e \\<in> (Rep_Bag_base X \\<tau>)\"", "lemma OclNotEmpty_has_elt' : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n                          \\<exists>e. e \\<in> (Rep_Set_base X \\<tau>)\"", "lemma OclANY_defined_args_valid: \"\\<tau> \\<Turnstile> \\<delta> (X->any\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> X\"", "lemma \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<tau> \\<Turnstile> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->any\\<^sub>B\\<^sub>a\\<^sub>g())\"", "lemma OclANY_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g())) = (\\<tau> \\<Turnstile> \\<upsilon> X)\"", "lemma OclANY_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g()) = (\\<upsilon> X)\"", "lemma OclSize_invalid[simp,code_unfold]:\"(invalid->size\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\"", "lemma OclSize_null[simp,code_unfold]:\"(null->size\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\"", "lemma OclIsEmpty_invalid[simp,code_unfold]:\"(invalid->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\"", "lemma OclIsEmpty_null[simp,code_unfold]:\"(null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = true\"", "lemma OclNotEmpty_invalid[simp,code_unfold]:\"(invalid->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\"", "lemma OclNotEmpty_null[simp,code_unfold]:\"(null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = false\"", "lemma OclANY_invalid[simp,code_unfold]:\"(invalid->any\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\"", "lemma OclANY_null[simp,code_unfold]:\"(null->any\\<^sub>B\\<^sub>a\\<^sub>g()) = null\"", "lemma OclForall_invalid[simp,code_unfold]:\"invalid->forAll\\<^sub>B\\<^sub>a\\<^sub>g(a| P a) = invalid\"", "lemma OclForall_null[simp,code_unfold]:\"null->forAll\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma OclExists_invalid[simp,code_unfold]:\"invalid->exists\\<^sub>B\\<^sub>a\\<^sub>g(a| P a) = invalid\"", "lemma OclExists_null[simp,code_unfold]:\"null->exists\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma OclIterate_invalid[simp,code_unfold]:\"invalid->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x) = invalid\"", "lemma OclIterate_null[simp,code_unfold]:\"null->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x) = invalid\"", "lemma OclIterate_invalid_args[simp,code_unfold]:\"S->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = invalid | P a x) = invalid\"", "lemma (*OclIterate_null_args[simp,code_unfold]:*) \"S->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = null | P a x) = invalid\"", "lemma OclIterate_infinite:\nassumes non_finite: \"\\<tau> \\<Turnstile> not(\\<delta>(S->size\\<^sub>B\\<^sub>a\\<^sub>g()))\"\nshows \"(OclIterate S A F) \\<tau> = invalid \\<tau>\"", "lemma OclSelect_invalid[simp,code_unfold]:\"invalid->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma OclSelect_null[simp,code_unfold]:\"null->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma OclReject_invalid[simp,code_unfold]:\"invalid->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma OclReject_null[simp,code_unfold]:\"null->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\"", "lemma cp_OclIncludes1:\n\"(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x)) \\<tau> = (X->includes\\<^sub>B\\<^sub>a\\<^sub>g(\\<lambda> _. x \\<tau>)) \\<tau>\"", "lemma cp_OclSize: \"X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\"", "lemma cp_OclIsEmpty: \"X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\"", "lemma cp_OclNotEmpty: \"X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\"", "lemma cp_OclANY: \"X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->any\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\"", "lemma cp_OclForall:\n\"(S->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)) \\<tau> = ((\\<lambda> _. S \\<tau>)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P (\\<lambda> _. x \\<tau>))) \\<tau>\"", "lemma cp_OclForall1 [simp,intro!]:\n\"cp S \\<Longrightarrow> cp (\\<lambda>X. ((S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)))\"", "lemma (*cp_OclForall2 [simp,intro!]:*)\n\"cp (\\<lambda>X St x. P (\\<lambda>\\<tau>. x) X St) \\<Longrightarrow> cp S \\<Longrightarrow> cp (\\<lambda>X. (S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P x X)) \"", "lemma (*cp_OclForall:*)\n\"cp S \\<Longrightarrow>\n (\\<And> x. cp(P x)) \\<Longrightarrow>\n cp(\\<lambda>X. ((S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x X)))\"", "lemma cp_OclExists:\n\"(S->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)) \\<tau> = ((\\<lambda> _. S \\<tau>)->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P (\\<lambda> _. x \\<tau>))) \\<tau>\"", "lemma cp_OclExists1 [simp,intro!]:\n\"cp S \\<Longrightarrow> cp (\\<lambda>X. ((S X)->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)))\"", "lemma cp_OclIterate: \n     \"(X->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x)) \\<tau> =\n                ((\\<lambda> _. X \\<tau>)->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x)) \\<tau>\"", "lemma cp_OclSelect: \"(X->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau> =\n                ((\\<lambda> _. X \\<tau>)->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau>\"", "lemma cp_OclReject: \"(X->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau> = ((\\<lambda> _. X \\<tau>)->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau>\"", "lemmas cp_intro''\\<^sub>B\\<^sub>a\\<^sub>g[intro!,simp,code_unfold] =\n       cp_OclSize      [THEN allI[THEN allI[THEN cpI1], of \"OclSize\"]]\n       cp_OclIsEmpty   [THEN allI[THEN allI[THEN cpI1], of \"OclIsEmpty\"]]\n       cp_OclNotEmpty  [THEN allI[THEN allI[THEN cpI1], of \"OclNotEmpty\"]]\n       cp_OclANY       [THEN allI[THEN allI[THEN cpI1], of \"OclANY\"]]", "lemma const_OclIncluding[simp,code_unfold] :\n assumes const_x : \"const x\"\n     and const_S : \"const S\"\n   shows  \"const (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x))\"", "lemma equal_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_code [code]:\n  \"HOL.equal k (l::('a::{equal,null})Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<longleftrightarrow> Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e k = Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e l\""], "translations": [["", "lemma Integer_defined : \"\\<delta> Integer = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Integer = true", "apply(rule ext, auto simp: Integer_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "lemma Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true", "apply(rule ext, auto simp: Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "text\\<open>This allows the theorems:\n\n      \\<open>\\<tau> \\<Turnstile> \\<delta> x  \\<Longrightarrow> \\<tau> \\<Turnstile> (Integer->includes\\<^sub>B\\<^sub>a\\<^sub>g(x))\\<close>\n      \\<open>\\<tau> \\<Turnstile> \\<delta> x  \\<Longrightarrow> \\<tau> \\<Turnstile> Integer  \\<triangleq> (Integer->including\\<^sub>B\\<^sub>a\\<^sub>g(x))\\<close>\n\nand\n\n      \\<open>\\<tau> \\<Turnstile> \\<upsilon> x  \\<Longrightarrow> \\<tau> \\<Turnstile> (Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l->includes\\<^sub>B\\<^sub>a\\<^sub>g(x))\\<close>\n      \\<open>\\<tau> \\<Turnstile> \\<upsilon> x  \\<Longrightarrow> \\<tau> \\<Turnstile> Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l  \\<triangleq> (Integer\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l->including\\<^sub>B\\<^sub>a\\<^sub>g(x))\\<close>\n\nwhich characterize the infiniteness of these bags by a recursive property on these bags.\n\\<close>"], ["", "text\\<open>In the same spirit, we proceed similarly for the remaining base types:\\<close>"], ["", "definition Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l :: \"('\\<AA>,Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some) (\\<lambda> x. if x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Some None) then 1 else 0))\""], ["", "definition Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y :: \"('\\<AA>,Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some) (\\<lambda>_. 0))\""], ["", "lemma Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true", "apply(rule ext, auto simp: Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def\n                           bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>x.\n                          if x =\n                             Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              \\<lfloor>None\\<rfloor>\n                          then 1 else 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>x.\n                          if x =\n                             Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              \\<lfloor>None\\<rfloor>\n                          then 1 else 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>None\\<rfloor> \\<Longrightarrow>\n    False", "by((subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, auto simp add: bot_option_def null_option_def bot_Void_def),\n   (subst (asm) Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, auto simp add: bot_option_def null_option_def))+"], ["", "lemma Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y_defined : \"\\<delta> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y = true", "apply(rule ext, auto simp: Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def\n                           bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>None\\<rfloor> \\<Longrightarrow>\n    False", "by((subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, auto simp add: bot_option_def null_option_def bot_Void_def))+"], ["", "lemma assumes \"\\<tau> \\<Turnstile> \\<delta> (V :: ('\\<AA>,Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag)\"\n      shows   \"\\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n    \\<tau>\n     \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n    \\<tau>\n     \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "have A:\"\\<And>x y. x \\<noteq> {} \\<Longrightarrow> \\<exists>y. y\\<in> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<noteq> {} \\<Longrightarrow> \\<exists>y. y \\<in> x", "by (metis all_not_in_conv)"], ["proof (state)\nthis:\n  ?x \\<noteq> {} \\<Longrightarrow> \\<exists>y. y \\<in> ?x\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n    \\<tau>\n     \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "show \"?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n    \\<tau>\n     \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(case_tac \"V \\<tau>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n        y \\<in> {X. X = \\<bottom> \\<or>\n                    X = null \\<or>\n                    \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> =\n                    0}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n        y \\<in> {X. X = \\<bottom> \\<or>\n                    X = null \\<or>\n                    \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> =\n                    0}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n        y \\<in> {X. X = \\<bottom> \\<or>\n                    X = null \\<or>\n                    \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> =\n                    0}\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "show \"V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y \\<Longrightarrow>\n                      y \\<in> {X. X = \\<bottom> \\<or> X = null \\<or> \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> = 0} \\<Longrightarrow>\n                      \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n     y \\<in> {X. X = \\<bottom> \\<or>\n                 X = null \\<or>\n                 \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> = 0}\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(insert assms, case_tac y, simp add: bot_option_def, simp add: bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def foundation16)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n        y \\<in> {X. X = \\<bottom> \\<or>\n                    X = null \\<or>\n                    \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> = 0};\n        \\<tau> \\<Turnstile> \\<delta> V; y = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(simp add: bot_option_def null_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n        a = None \\<or> \\<lceil>a\\<rceil> \\<bottom> = 0;\n        \\<tau> \\<Turnstile> \\<delta> V; y = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(erule disjE, metis OclValid_def defined_def foundation2 null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_fun_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V; y = \\<lfloor>a\\<rfloor>;\n        \\<lceil>a\\<rceil> \\<bottom> = 0\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V; y = \\<lfloor>a\\<rfloor>;\n        \\<lceil>a\\<rceil> \\<bottom> = 0\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V; y = \\<lfloor>a\\<rfloor>;\n        \\<lceil>a\\<rceil> \\<bottom> = 0\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "show \"V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor> \\<Longrightarrow> \\<lceil>a\\<rceil> \\<bottom> = 0 \\<Longrightarrow> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n     \\<lceil>a\\<rceil> \\<bottom> = 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(case_tac a, simp, insert assms, metis OclValid_def foundation16 null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n        \\<lceil>a\\<rceil> \\<bottom> = 0; a = \\<lfloor>aa\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0; a = \\<lfloor>aa\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0; a = \\<lfloor>aa\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "fix aa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0; a = \\<lfloor>aa\\<rfloor>;\n        \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                         \\<tau>\n                          \\<Turnstile> V \\<cong>\n Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "show \" V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor> \\<Longrightarrow> aa \\<bottom> = 0 \\<Longrightarrow> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(case_tac \"aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) = 0\",\n        rule disjI2,\n        insert assms,\n        simp add: Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y_def OclValid_def ApproxEq_def Rep_Set_base_def true_def Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) =\n     0;\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x b. \\<not> b < aa x\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply(intro allI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>None\\<rfloor>) =\n        0;\n        (\\<delta> V) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<not> b < aa x\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>None\\<rfloor>) =\n        0;\n        (\\<delta> V) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<not> b < aa x\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>None\\<rfloor>) =\n        0;\n        (\\<delta> V) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<not> b < aa x\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>None\\<rfloor>) =\n        0;\n        (\\<delta> V) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<not> b < aa x\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "show \" V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor> \\<Longrightarrow> aa \\<bottom> = 0 \\<Longrightarrow> aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) = 0 \\<Longrightarrow> (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Longrightarrow> \\<not> b < aa x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) =\n     0;\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<not> b < aa x", "apply (case_tac x, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) =\n     0;\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<bottom>;\n     b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) =\n     0;\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null;\n     b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: bot_Void_def bot_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) =\n     0;\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null;\n     b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null)\\<rbrakk>\n    \\<Longrightarrow> False", "apply (simp add: bot_option_def null_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n   aa \\<bottom> = 0;\n   aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) = 0;\n   (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<not> b < aa x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>None\\<rfloor>) \\<noteq>\n     0;\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                      \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y", "apply_end(simp+, rule disjI1)"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n   aa \\<bottom> = 0;\n   aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) = 0;\n   (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n  \\<Longrightarrow> \\<not> b < aa x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l", "show \"V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor> \\<Longrightarrow> aa \\<bottom> = 0 \\<Longrightarrow> 0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> V \\<Longrightarrow> \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> V \\<cong>\n                                    Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l", "apply(simp add: Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def OclValid_def ApproxEq_def Rep_Set_base_def true_def Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse image_def,\n        subst Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>None\\<rfloor> \\<longrightarrow>\n                      \\<lfloor>\\<lfloor>\\<lambda>x.\n     if x = \\<bottom> then 1 else 0\\<rfloor>\\<rfloor> =\n                      \\<bottom> \\<or>\n                      \\<lfloor>\\<lfloor>\\<lambda>x.\n     if x = \\<bottom> then 1 else 0\\<rfloor>\\<rfloor> =\n                      null\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {y. \\<exists>b. b < aa y} =\n                      {y. \\<exists>b.\n                             b < \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lambda>x.\n                                if x =\n                                   Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    \\<lfloor>None\\<rfloor>\n                                then 1\n                                else 0\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>\n                                  y}", "using bot_Void_def"], ["proof (prove)\nusing this:\n  \\<bottom> \\<equiv> Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> \\<bottom> =\n                      Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>None\\<rfloor> \\<longrightarrow>\n                      \\<lfloor>\\<lfloor>\\<lambda>x.\n     if x = \\<bottom> then 1 else 0\\<rfloor>\\<rfloor> =\n                      \\<bottom> \\<or>\n                      \\<lfloor>\\<lfloor>\\<lambda>x.\n     if x = \\<bottom> then 1 else 0\\<rfloor>\\<rfloor> =\n                      null\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {y. \\<exists>b. b < aa y} =\n                      {y. \\<exists>b.\n                             b < \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lambda>x.\n                                if x =\n                                   Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    \\<lfloor>None\\<rfloor>\n                                then 1\n                                else 0\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>\n                                  y}", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {y. \\<exists>b. b < aa y} =\n                      {y. \\<exists>b.\n                             b < \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lambda>x.\n                                if x =\n                                   Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    \\<lfloor>None\\<rfloor>\n                                then 1\n                                else 0\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>\n                                  y}", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {y. \\<exists>b. b < aa y} =\n                      {Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        \\<lfloor>None\\<rfloor>}", "apply(rule equalityI, rule subsetI, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<exists>b. b < aa x\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        \\<lfloor>None\\<rfloor>}\n                      \\<subseteq> {y. \\<exists>b. b < aa y}", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<exists>b. b < aa x\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        \\<lfloor>None\\<rfloor>}\n                      \\<subseteq> {y. \\<exists>b. b < aa y}", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<exists>b. b < aa x\\<rbrakk>\n       \\<Longrightarrow> x =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>\n 2. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        \\<lfloor>None\\<rfloor>}\n                      \\<subseteq> {y. \\<exists>b. b < aa y}", "show \"V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor> \\<Longrightarrow>\n            aa \\<bottom> = 0 \\<Longrightarrow> 0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>) \\<Longrightarrow> (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Longrightarrow> \\<exists>b. b < aa x \\<Longrightarrow> x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     \\<exists>b. b < aa x\\<rbrakk>\n    \\<Longrightarrow> x =\n                      Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>None\\<rfloor>", "apply( case_tac x, auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<bottom>;\n        b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<bottom> =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>\n 2. \\<And>b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null;\n        b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null)\\<rbrakk>\n       \\<Longrightarrow> Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>", "apply (simp add: bot_Void_def bot_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       \\<lbrakk>V \\<tau> =\n                Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        aa \\<bottom> = 0;\n        0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 \\<lfloor>None\\<rfloor>);\n        (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        x = Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null;\n        b < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null)\\<rbrakk>\n       \\<Longrightarrow> Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null =\n                         Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>None\\<rfloor>", "by (simp add: bot_option_def null_option_def)"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n   aa \\<bottom> = 0;\n   0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>);\n   (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n   \\<exists>b. b < aa x\\<rbrakk>\n  \\<Longrightarrow> x =\n                    Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     \\<lfloor>None\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>V \\<tau> =\n             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n     aa \\<bottom> = 0;\n     0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              \\<lfloor>None\\<rfloor>);\n     (\\<delta> V) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> {Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        \\<lfloor>None\\<rfloor>}\n                      \\<subseteq> {y. \\<exists>b. b < aa y}", "qed ((simp add: bot_Void_def bot_option_def)+, blast)"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n   aa \\<bottom> = 0;\n   0 < aa (Abs_Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>);\n   \\<tau> \\<Turnstile> \\<delta> V\\<rbrakk>\n  \\<Longrightarrow> \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n   aa \\<bottom> = 0\\<rbrakk>\n  \\<Longrightarrow> \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                    \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>a\\<rfloor>;\n   \\<lceil>a\\<rceil> \\<bottom> = 0\\<rbrakk>\n  \\<Longrightarrow> \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                    \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>V \\<tau> = Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y;\n   y \\<in> {X. X = \\<bottom> \\<or>\n               X = null \\<or>\n               \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> = 0}\\<rbrakk>\n  \\<Longrightarrow> \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n                    \\<tau>\n                     \\<Turnstile> V \\<cong>\n                                  Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<or>\n  \\<tau> \\<Turnstile> V \\<cong> Void\\<^sub>e\\<^sub>m\\<^sub>p\\<^sub>t\\<^sub>y\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Boolean :: \"('\\<AA>,Boolean\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Boolean \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | Some None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "definition Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l :: \"('\\<AA>,Boolean\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "lemma Boolean_defined : \"\\<delta> Boolean = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Boolean = true", "apply(rule ext, auto simp: Boolean_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "lemma Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true", "apply(rule ext, auto simp: Boolean\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "definition String :: \"('\\<AA>,String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"String \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | Some None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "definition String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l :: \"('\\<AA>,String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "lemma String_defined : \"\\<delta> String = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> String = true", "apply(rule ext, auto simp: String_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "lemma String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true", "apply(rule ext, auto simp: String\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "definition Real :: \"('\\<AA>,Real\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Real \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | Some None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "definition Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l :: \"('\\<AA>,Real\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) Bag\"\nwhere     \"Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l \\<equiv> (\\<lambda> \\<tau>. (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e o Some o Some)  (\\<lambda> None \\<Rightarrow> 0 | _ \\<Rightarrow> 1))\""], ["", "lemma Real_defined : \"\\<delta> Real = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Real = true", "apply(rule ext, auto simp: Real_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0\n                        (case_option 0\n                          (\\<lambda>aa. Suc 0))\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "lemma Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_defined : \"\\<delta> Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l = true", "apply(rule ext, auto simp: Real\\<^sub>n\\<^sub>u\\<^sub>l\\<^sub>l_def defined_def false_def true_def\n                           bot_fun_def null_fun_def null_option_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    \\<bottom> \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>case_option 0 (\\<lambda>a. Suc 0)\\<rfloor>\\<rfloor> =\n    null \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_option_def)"], ["", "subsection\\<open>Basic Properties of the Bag Type\\<close>"], ["", "text\\<open>Every element in a defined bag is valid.\\<close>"], ["", "lemma Bag_inv_lemma: \"\\<tau> \\<Turnstile> (\\<delta> X) \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> bot = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n    \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (X \\<tau>)\\<rceil>\\<rceil>\n     \\<bottom> =\n    0", "apply(insert Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e [of \"X \\<tau>\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = \\<bottom> \\<or>\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null \\<or>\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n (X \\<tau>)\\<rceil>\\<rceil>\n                       \\<bottom> =\n                      0", "apply(auto simp: OclValid_def defined_def false_def true_def cp_def\n                 bot_fun_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_fun_def\n           split:if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>\\<bottom>\\<rceil>\\<rceil> \\<bottom> =\n                      0\n 2. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> = 0", "apply(erule contrapos_pp [of \"Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = bot\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     \\<lceil>\\<lceil>\\<bottom>\\<rceil>\\<rceil> \\<bottom> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (X \\<tau>) \\<noteq>\n                      \\<bottom>\n 2. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> = 0", "apply(subst Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject[symmetric], rule Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     \\<lceil>\\<lceil>\\<bottom>\\<rceil>\\<rceil> \\<bottom> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (X \\<tau>)) \\<noteq>\n                      Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<bottom>\n 2. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> = 0", "apply(simp add: Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null\\<rbrakk>\n    \\<Longrightarrow> \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> = 0", "apply(erule contrapos_pp [of \"Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>) = null\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (X \\<tau>) \\<noteq>\n                      null", "apply(subst Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject[symmetric], rule Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     \\<lceil>\\<lceil>null\\<rceil>\\<rceil> \\<bottom> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (X \\<tau>)) \\<noteq>\n                      Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e null", "apply(simp add: Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse  null_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n     X \\<tau> \\<noteq>\n     Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n     0 < \\<lceil>\\<bottom>\\<rceil> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> X \\<tau> \\<noteq>\n                      Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>\\<bottom>\\<rfloor>", "by (simp add: bot_option_def)"], ["", "lemma Bag_inv_lemma' :\n assumes x_def : \"\\<tau> \\<Turnstile> \\<delta> X\"\n     and e_mem : \"\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> e \\<ge> 1\"\n   shows \"\\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. e)", "apply(case_tac \"e = bot\", insert assms, drule Bag_inv_lemma, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>e \\<noteq> \\<bottom>; \\<tau> \\<Turnstile> \\<delta> X;\n     1 \\<le> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (X \\<tau>)\\<rceil>\\<rceil>\n              e\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. e)", "by (simp add: foundation18')"], ["", "lemma abs_rep_simp' :\n assumes S_all_def : \"\\<tau> \\<Turnstile> \\<delta> S\"\n   shows \"Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> = S \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    S \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    S \\<tau>", "have discr_eq_false_true : \"\\<And>\\<tau>. (false \\<tau> = true \\<tau>) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>. (false \\<tau> = true \\<tau>) = False", "by(simp add: false_def true_def)"], ["proof (state)\nthis:\n  (false ?\\<tau> = true ?\\<tau>) = False\n\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    S \\<tau>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    S \\<tau>", "apply(insert S_all_def, simp add: OclValid_def defined_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    S \\<tau>", "apply(rule mp[OF Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_induct[where P = \"\\<lambda>S. (if S = \\<bottom> \\<tau> \\<or> S = null \\<tau>\n                                                    then false \\<tau> else true \\<tau>) = true \\<tau> \\<longrightarrow>\n                                                   Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> = S\"]],\n        rename_tac S')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S'.\n       \\<lbrakk>(if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        S' \\<in> {X. X = \\<bottom> \\<or>\n                     X = null \\<or>\n                     \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> =\n                     0}\\<rbrakk>\n       \\<Longrightarrow> (if Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' =\n                             \\<bottom> \\<tau> \\<or>\n                             Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' =\n                             null \\<tau>\n                          then false \\<tau> else true \\<tau>) =\n                         true \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         S')\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S'\n 2. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau>", "apply(simp add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse discr_eq_false_true)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S'.\n       \\<lbrakk>(if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        S' = \\<bottom> \\<or>\n        S' = null \\<or>\n        \\<lceil>\\<lceil>S'\\<rceil>\\<rceil> \\<bottom> = 0\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         \\<bottom> \\<tau> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>S'\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S'\n 2. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau>", "apply(case_tac S')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S'.\n       \\<lbrakk>(if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        S' = \\<bottom> \\<or>\n        S' = null \\<or> \\<lceil>\\<lceil>S'\\<rceil>\\<rceil> \\<bottom> = 0;\n        S' = None\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         \\<bottom> \\<tau> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>S'\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S'\n 2. \\<And>S' a.\n       \\<lbrakk>(if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        S' = \\<bottom> \\<or>\n        S' = null \\<or> \\<lceil>\\<lceil>S'\\<rceil>\\<rceil> \\<bottom> = 0;\n        S' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         \\<bottom> \\<tau> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S' \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>S'\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e S'\n 3. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau>", "apply(simp add: bot_fun_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>S' a.\n       \\<lbrakk>(if S \\<tau> =\n                    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<or>\n                    S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        \\<lfloor>a\\<rfloor> = \\<bottom> \\<or>\n        \\<lfloor>a\\<rfloor> = null \\<or> \\<lceil>a\\<rceil> \\<bottom> = 0;\n        S' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>a\\<rfloor> \\<noteq>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>a\\<rfloor> \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>a\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>a\\<rfloor>\n 2. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau>", "apply(rename_tac S'', case_tac S'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>S' S''.\n       \\<lbrakk>(if S \\<tau> =\n                    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<or>\n                    S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        \\<lfloor>S''\\<rfloor> = \\<bottom> \\<or>\n        \\<lfloor>S''\\<rfloor> = null \\<or>\n        \\<lceil>S''\\<rceil> \\<bottom> = 0;\n        S' = \\<lfloor>S''\\<rfloor>; S'' = None\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor> \\<noteq>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor> \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>S''\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor>\n 2. \\<And>S' S'' a.\n       \\<lbrakk>(if S \\<tau> =\n                    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<or>\n                    S \\<tau> = null \\<tau>\n                 then false \\<tau> else true \\<tau>) =\n                true \\<tau>;\n        \\<lfloor>S''\\<rfloor> = \\<bottom> \\<or>\n        \\<lfloor>S''\\<rfloor> = null \\<or>\n        \\<lceil>S''\\<rceil> \\<bottom> = 0;\n        S' = \\<lfloor>S''\\<rfloor>; S'' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor> \\<noteq>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor> \\<noteq>\n                         null \\<tau> \\<longrightarrow>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>S''\\<rceil>\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>S''\\<rfloor>\n 3. (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau> \\<Longrightarrow>\n    (if S \\<tau> = \\<bottom> \\<tau> \\<or> S \\<tau> = null \\<tau>\n     then false \\<tau> else true \\<tau>) =\n    true \\<tau>", "apply(simp add: null_fun_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n(S \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n  S \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma invalid_bag_OclNot_defined [simp,code_unfold]:\"\\<delta>(invalid::('\\<AA>,'\\<alpha>::null) Bag) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> invalid = false", "by simp"], ["", "lemma null_bag_OclNot_defined [simp,code_unfold]:\"\\<delta>(null::('\\<AA>,'\\<alpha>::null) Bag) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> null = false", "by(simp add: defined_def null_fun_def)"], ["", "lemma invalid_bag_valid [simp,code_unfold]:\"\\<upsilon>(invalid::('\\<AA>,'\\<alpha>::null) Bag) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> invalid = false", "by simp"], ["", "lemma null_bag_valid [simp,code_unfold]:\"\\<upsilon>(null::('\\<AA>,'\\<alpha>::null) Bag) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> null = true", "apply(simp add: valid_def null_fun_def bot_fun_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<tau>.\n        if Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor> =\n           Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\n        then false \\<tau> else true \\<tau>) =\n    true", "apply(subst Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject,simp_all add: null_option_def bot_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>... which means that we can have a type \\<open>('\\<AA>,('\\<AA>,('\\<AA>) Integer) Bag) Bag\\<close>\ncorresponding exactly to Bag(Bag(Integer)) in OCL notation. Note that the parameter\n\\<open>'\\<AA>\\<close> still refers to the object universe; making the OCL semantics entirely parametric\nin the object universe makes it possible to study (and prove) its properties\nindependently from a concrete class diagram.\\<close>"], ["", "subsection\\<open>Definition: Strict Equality \\label{sec:bag-strict-equality}\\<close>"], ["", "text\\<open>After the part of foundational operations on bags, we detail here equality on bags.\nStrong equality is inherited from the OCL core, but we have to consider\nthe case of the strict equality. We decide to overload strict equality in the\nsame way we do for other value's in OCL:\\<close>"], ["", "overloading StrictRefEq \\<equiv> \"StrictRefEq :: [('\\<AA>,'\\<alpha>::null)Bag,('\\<AA>,'\\<alpha>::null)Bag] \\<Rightarrow> ('\\<AA>)Boolean\"\nbegin"], ["", "definition StrictRefEq\\<^sub>B\\<^sub>a\\<^sub>g :\n    \"(x::('\\<AA>,'\\<alpha>::null)Bag) \\<doteq> y \\<equiv> \\<lambda> \\<tau>. if (\\<upsilon> x) \\<tau> = true \\<tau> \\<and> (\\<upsilon> y) \\<tau> = true \\<tau>\n                                       then (x \\<triangleq> y)\\<tau>\n                                       else invalid \\<tau>\""], ["", "end"], ["", "text\\<open>One might object here that for the case of objects, this is an empty definition.\nThe answer is no, we will restrain later on states and objects such that any object\nhas its oid stored inside the object (so the ref, under which an object can be referenced\nin the store will represented in the object itself). For such well-formed stores that satisfy\nthis invariant (the WFF-invariant), the referential equality and the\nstrong equality---and therefore the strict equality on bags in the sense above---coincides.\\<close>"], ["", "text\\<open>Property proof in terms of @{term \"profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v\"}\\<close>"], ["", "interpretation  StrictRefEq\\<^sub>B\\<^sub>a\\<^sub>g : profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v \"\\<lambda> x y. (x::('\\<AA>,'\\<alpha>::null)Bag) \\<doteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v\n     (\\<doteq>)", "by unfold_locales (auto simp:  StrictRefEq\\<^sub>B\\<^sub>a\\<^sub>g)"], ["", "subsection\\<open>Constants: mtBag\\<close>"], ["", "definition mtBag::\"('\\<AA>,'\\<alpha>::null) Bag\"  (\"Bag{}\")\nwhere     \"Bag{} \\<equiv> (\\<lambda> \\<tau>.  Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lambda>_. 0::nat\\<rfloor>\\<rfloor> )\""], ["", "lemma mtBag_defined[simp,code_unfold]:\"\\<delta>(Bag{}) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> Bag{} = true", "apply(rule ext, auto simp: mtBag_def defined_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def\n                           bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_fun_def null_fun_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<Longrightarrow>\n    False\n 2. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>None\\<rfloor> \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def null_option_def)"], ["", "lemma mtBag_valid[simp,code_unfold]:\"\\<upsilon>(Bag{}) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> Bag{} = true", "apply(rule ext,auto simp: mtBag_def valid_def\n                          bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_fun_def null_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor> =\n    Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<Longrightarrow>\n    False", "by(simp_all add: Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject bot_option_def null_option_def)"], ["", "lemma mtBag_rep_bag: \"\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Bag{} \\<tau>)\\<rceil>\\<rceil> = (\\<lambda> _. 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (Bag{} \\<tau>)\\<rceil>\\<rceil> =\n    (\\<lambda>_. 0)", "apply(simp add: mtBag_def, subst Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lfloor>\\<lfloor>\\<lambda>_. 0\\<rfloor>\\<rfloor>\n    \\<in> {X. X = \\<bottom> \\<or>\n              X = null \\<or>\n              \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<bottom> = 0}\n 2. \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lambda>_.\n   0\\<rfloor>\\<rfloor>\\<rceil>\\<rceil> =\n    (\\<lambda>_. 0)", "by(simp add: bot_option_def)+"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemma [simp,code_unfold]: \"const Bag{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const Bag{}", "by(simp add: const_def mtBag_def)"], ["", "text\\<open>Note that the collection types in OCL allow for null to be included;\n  however, there is the null-collection into which inclusion yields invalid.\\<close>"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Definition: Including\\<close>"], ["", "definition OclIncluding   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) val] \\<Rightarrow> ('\\<AA>,'\\<alpha>) Bag\"\nwhere     \"OclIncluding x y = (\\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<upsilon> y) \\<tau> = true \\<tau>\n                                    then Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(x \\<tau>)\\<rceil>\\<rceil> \n                                                      ((y \\<tau>):=\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(x \\<tau>)\\<rceil>\\<rceil>(y \\<tau>)+1) \n                                                    \\<rfloor>\\<rfloor>\n                                    else invalid \\<tau> )\""], ["", "notation   OclIncluding   (\"_->including\\<^sub>B\\<^sub>a\\<^sub>g'(_')\")"], ["", "interpretation OclIncluding : profile_bin\\<^sub>d_\\<^sub>v OclIncluding \"\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> \n                                                      (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> y + 1)\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclIncluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   y +\n                                  1)\\<rfloor>\\<rfloor>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclIncluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   y +\n                                  1)\\<rfloor>\\<rfloor>)", "let ?X = \"\\<lambda>x y. \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(x)\\<rceil>\\<rceil> ((y):=\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(x)\\<rceil>\\<rceil>( y )+1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclIncluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   y +\n                                  1)\\<rfloor>\\<rfloor>)", "show \"profile_bin\\<^sub>d_\\<^sub>v OclIncluding (\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> ?X x y \\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclIncluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   y +\n                                  1)\\<rfloor>\\<rfloor>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y.\n       bin OclIncluding\n        (\\<lambda>x y.\n            Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                               (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                x\\<rceil>\\<rceil>\ny +\n                                     1)\\<rfloor>\\<rfloor>)\n        defined valid X Y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        y \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       x\\<rceil>\\<rceil>\n      (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             x\\<rceil>\\<rceil>\n             y +\n            1)\\<rfloor>\\<rfloor> \\<noteq>\n                         \\<bottom> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       x\\<rceil>\\<rceil>\n      (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             x\\<rceil>\\<rceil>\n             y +\n            1)\\<rfloor>\\<rfloor> \\<noteq>\n                         null", "apply(auto simp:OclIncluding_def bot_option_def null_option_def \n                                           bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> \\<bottom>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      x\\<rceil>\\<rceil>\n                           (y := Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 x\\<rceil>\\<rceil>\n y))\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> \\<bottom>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      x\\<rceil>\\<rceil>\n                           (y := Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                 x\\<rceil>\\<rceil>\n y))\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>None\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by(subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, simp_all,\n             metis (mono_tags, lifting) Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse bot_option_def mem_Collect_eq null_option_def,\n             simp add: bot_option_def null_option_def)+"], ["proof (state)\nthis:\n  profile_bin\\<^sub>d_\\<^sub>v OclIncluding\n   (\\<lambda>x y.\n       Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     x\\<rceil>\\<rceil>\n                          (y := \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n           x\\<rceil>\\<rceil>\n                                 y +\n                                1)\\<rfloor>\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["", "syntax\n  \"_OclFinbag\" :: \"args => ('\\<AA>,'a::null) Bag\"    (\"Bag{(_)}\")"], ["", "translations\n  \"Bag{x, xs}\" == \"CONST OclIncluding (Bag{xs}) x\"\n  \"Bag{x}\"     == \"CONST OclIncluding (Bag{}) x \""], ["", "subsection\\<open>Definition: Excluding\\<close>"], ["", "definition OclExcluding   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) val] \\<Rightarrow> ('\\<AA>,'\\<alpha>) Bag\"\nwhere     \"OclExcluding x y = (\\<lambda> \\<tau>.  if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<upsilon> y) \\<tau> = true \\<tau>\n                                     then Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (x \\<tau>)\\<rceil>\\<rceil> ((y \\<tau>):=0::nat) \\<rfloor>\\<rfloor>\n                                     else invalid \\<tau> )\""], ["", "notation   OclExcluding   (\"_->excluding\\<^sub>B\\<^sub>a\\<^sub>g'(_')\")"], ["", "interpretation OclExcluding: profile_bin\\<^sub>d_\\<^sub>v OclExcluding  \n                            \"\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(x)\\<rceil>\\<rceil>(y:=0::nat)\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclExcluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := 0)\\<rfloor>\\<rfloor>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclExcluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := 0)\\<rfloor>\\<rfloor>)", "show \"profile_bin\\<^sub>d_\\<^sub>v OclExcluding (\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil>(y := 0)\\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclExcluding\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       x\\<rceil>\\<rceil>\n                            (y := 0)\\<rfloor>\\<rfloor>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y.\n       bin OclExcluding\n        (\\<lambda>x y.\n            Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                               (y := 0)\\<rfloor>\\<rfloor>)\n        defined valid X Y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        y \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       x\\<rceil>\\<rceil>\n      (y := 0)\\<rfloor>\\<rfloor> \\<noteq>\n                         \\<bottom> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       x\\<rceil>\\<rceil>\n      (y := 0)\\<rfloor>\\<rfloor> \\<noteq>\n                         null", "apply(auto simp:OclExcluding_def bot_option_def null_option_def  \n                         null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> \\<bottom>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      x\\<rceil>\\<rceil>\n                           (y := 0)\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> \\<bottom>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      x\\<rceil>\\<rceil>\n                           (y := 0)\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>None\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by(subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject,\n               simp_all add: bot_option_def null_option_def,\n               metis (mono_tags, lifting) Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse bot_option_def\n                                          mem_Collect_eq null_option_def)+"], ["proof (state)\nthis:\n  profile_bin\\<^sub>d_\\<^sub>v OclExcluding\n   (\\<lambda>x y.\n       Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     x\\<rceil>\\<rceil>\n                          (y := 0)\\<rfloor>\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Definition: Includes\\<close>"], ["", "definition OclIncludes   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) val] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclIncludes x y = (\\<lambda> \\<tau>.   if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<upsilon> y) \\<tau> = true \\<tau>\n                                     then \\<lfloor>\\<lfloor> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (x \\<tau>)\\<rceil>\\<rceil> (y \\<tau>) > 0 \\<rfloor>\\<rfloor>\n                                     else \\<bottom>  )\""], ["", "notation   OclIncludes    (\"_->includes\\<^sub>B\\<^sub>a\\<^sub>g'(_')\" (*[66,65]65*))"], ["", "interpretation OclIncludes : profile_bin\\<^sub>d_\\<^sub>v OclIncludes \"\\<lambda>x y. \\<lfloor>\\<lfloor> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> y > 0 \\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclIncludes\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>0 < \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                                y\\<rfloor>\\<rfloor>)", "by(unfold_locales, auto simp:OclIncludes_def bot_option_def null_option_def invalid_def)"], ["", "subsection\\<open>Definition: Excludes\\<close>"], ["", "definition OclExcludes   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) val] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclExcludes x y = (not(OclIncludes x y))\""], ["", "notation   OclExcludes    (\"_->excludes\\<^sub>B\\<^sub>a\\<^sub>g'(_')\" (*[66,65]65*))"], ["", "text\\<open>The case of the size definition is somewhat special, we admit\nexplicitly in Featherweight OCL the possibility of infinite bags. For\nthe size definition, this requires an extra condition that assures\nthat the cardinality of the bag is actually a defined integer.\\<close>"], ["", "interpretation OclExcludes : profile_bin\\<^sub>d_\\<^sub>v OclExcludes \"\\<lambda>x y. \\<lfloor>\\<lfloor> \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> y \\<le> 0 \\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>v OclExcludes\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      x\\<rceil>\\<rceil>\n                            y\n                           \\<le> 0\\<rfloor>\\<rfloor>)", "by(unfold_locales, auto simp:OclExcludes_def OclIncludes_def OclNot_def bot_option_def null_option_def invalid_def)"], ["", "subsection\\<open>Definition: Size\\<close>"], ["", "definition OclSize     :: \"('\\<AA>,'\\<alpha>::null)Bag \\<Rightarrow> '\\<AA> Integer\"\nwhere     \"OclSize x = (\\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> finite (Rep_Bag_base x \\<tau>)\n                             then \\<lfloor>\\<lfloor> int (card (Rep_Bag_base x \\<tau>)) \\<rfloor>\\<rfloor>\n                             else \\<bottom> )\""], ["", "notation  (* standard ascii syntax *)\n           OclSize        (\"_->size\\<^sub>B\\<^sub>a\\<^sub>g'(')\" (*[66]*))"], ["", "text\\<open>The following definition follows the requirement of the\nstandard to treat null as neutral element of bags. It is\na well-documented exception from the general strictness\nrule and the rule that the distinguished argument self should\nbe non-null.\\<close>"], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: IsEmpty\\<close>"], ["", "definition OclIsEmpty   :: \"('\\<AA>,'\\<alpha>::null) Bag \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclIsEmpty x =  ((\\<upsilon> x and not (\\<delta> x)) or ((OclSize x) \\<doteq> \\<zero>))\""], ["", "notation   OclIsEmpty     (\"_->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g'(')\" (*[66]*))"], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: NotEmpty\\<close>"], ["", "definition OclNotEmpty   :: \"('\\<AA>,'\\<alpha>::null) Bag \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclNotEmpty x =  not(OclIsEmpty x)\""], ["", "notation   OclNotEmpty    (\"_->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g'(')\" (*[66]*))"], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: Any\\<close>"], ["", "(* Slight breach of naming convention in order to avoid naming conflict on constant.*)"], ["", "definition OclANY   :: \"[('\\<AA>,'\\<alpha>::null) Bag] \\<Rightarrow> ('\\<AA>,'\\<alpha>) val\"\nwhere     \"OclANY x = (\\<lambda> \\<tau>. if (\\<upsilon> x) \\<tau> = true \\<tau>\n                            then if (\\<delta> x and OclNotEmpty x) \\<tau> = true \\<tau>\n                                 then SOME y. y \\<in> (Rep_Set_base x \\<tau>)\n                                 else null \\<tau>\n                            else \\<bottom> )\""], ["", "notation   OclANY   (\"_->any\\<^sub>B\\<^sub>a\\<^sub>g'(')\")"], ["", "(*TODO Locale - Equivalent*)  \n\n(* actually, this definition covers only: X->any\\<^sub>B\\<^sub>a\\<^sub>g(true) of the standard, which foresees\na (totally correct) high-level definition\nsource->any\\<^sub>B\\<^sub>a\\<^sub>g(iterator | body) =\nsource->select(iterator | body)->asSequence()->first(). Since we don't have sequences,\nwe have to go for a direct---restricted---definition. *)"], ["", "subsection\\<open>Definition: Forall\\<close>"], ["", "text\\<open>The definition of OclForall mimics the one of @{term \"OclAnd\"}:\nOclForall is not a strict operation.\\<close>"], ["", "definition OclForall     :: \"[('\\<AA>,'\\<alpha>::null)Bag,('\\<AA>,'\\<alpha>)val\\<Rightarrow>('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclForall S P = (\\<lambda> \\<tau>. if (\\<delta> S) \\<tau> = true \\<tau>\n                                 then if (\\<exists>x\\<in>Rep_Set_base S \\<tau>. P (\\<lambda>_. x) \\<tau> = false \\<tau>)\n                                      then false \\<tau>\n                                      else if (\\<exists>x\\<in>Rep_Set_base S \\<tau>. P (\\<lambda>_. x) \\<tau> = invalid \\<tau>)\n                                           then invalid \\<tau>\n                                           else if (\\<exists>x\\<in>Rep_Set_base S \\<tau>. P (\\<lambda>_. x) \\<tau> = null \\<tau>)\n                                                then null \\<tau>\n                                                else true \\<tau>\n                                 else \\<bottom>)\""], ["", "syntax\n  \"_OclForallBag\" :: \"[('\\<AA>,'\\<alpha>::null) Bag,id,('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"    (\"(_)->forAll\\<^sub>B\\<^sub>a\\<^sub>g'(_|_')\")"], ["", "translations\n  \"X->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P)\" == \"CONST UML_Bag.OclForall X (%x. P)\""], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: Exists\\<close>"], ["", "text\\<open>Like OclForall, OclExists is also not strict.\\<close>"], ["", "definition OclExists     :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>)val\\<Rightarrow>('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclExists S P = not(UML_Bag.OclForall S (\\<lambda> X. not (P X)))\""], ["", "syntax\n  \"_OclExistBag\" :: \"[('\\<AA>,'\\<alpha>::null) Bag,id,('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"    (\"(_)->exists\\<^sub>B\\<^sub>a\\<^sub>g'(_|_')\")"], ["", "translations\n  \"X->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P)\" == \"CONST UML_Bag.OclExists X (%x. P)\""], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: Iterate\\<close>"], ["", "definition OclIterate :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<beta>::null)val,\n                           ('\\<AA>,'\\<alpha>)val\\<Rightarrow>('\\<AA>,'\\<beta>)val\\<Rightarrow>('\\<AA>,'\\<beta>)val] \\<Rightarrow> ('\\<AA>,'\\<beta>)val\"\nwhere     \"OclIterate S A F = (\\<lambda> \\<tau>. if (\\<delta> S) \\<tau> = true \\<tau> \\<and> (\\<upsilon> A) \\<tau> = true \\<tau> \\<and> finite (Rep_Bag_base S \\<tau>)\n                                    then Finite_Set.fold (F o (\\<lambda>a \\<tau>. a) o fst) A (Rep_Bag_base S \\<tau>) \\<tau>\n                                    else \\<bottom>)\""], ["", "syntax\n  \"_OclIterateBag\"  :: \"[('\\<AA>,'\\<alpha>::null) Bag, idt, idt, '\\<alpha>, '\\<beta>] => ('\\<AA>,'\\<gamma>)val\"\n                        (\"_ ->iterate\\<^sub>B\\<^sub>a\\<^sub>g'(_;_=_ | _')\" (*[71,100,70]50*))"], ["", "translations\n  \"X->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P)\" == \"CONST OclIterate X A (%a. (% x. P))\""], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: Select\\<close>"], ["", "definition OclSelect :: \"[('\\<AA>,'\\<alpha>::null)Bag,('\\<AA>,'\\<alpha>)val\\<Rightarrow>('\\<AA>)Boolean] \\<Rightarrow> ('\\<AA>,'\\<alpha>)Bag\"\nwhere \"OclSelect S P = (\\<lambda>\\<tau>. if (\\<delta> S) \\<tau> = true \\<tau>\n                              then if (\\<exists>x\\<in>Rep_Set_base S \\<tau>. P(\\<lambda> _. x) \\<tau> = invalid \\<tau>)\n                                   then invalid \\<tau>\n                                   else Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lambda>x. \n                                          let n = \\<lceil>\\<lceil> Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S \\<tau>) \\<rceil>\\<rceil> x in\n                                          if n = 0 | P (\\<lambda>_. x) \\<tau> = false \\<tau> then\n                                            0\n                                          else\n                                            n\\<rfloor>\\<rfloor>\n                              else invalid \\<tau>)\""], ["", "syntax\n  \"_OclSelectBag\" :: \"[('\\<AA>,'\\<alpha>::null) Bag,id,('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"    (\"(_)->select\\<^sub>B\\<^sub>a\\<^sub>g'(_|_')\")"], ["", "translations\n  \"X->select\\<^sub>B\\<^sub>a\\<^sub>g(x | P)\" == \"CONST OclSelect X (% x. P)\""], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: Reject\\<close>"], ["", "definition OclReject :: \"[('\\<AA>,'\\<alpha>::null)Bag,('\\<AA>,'\\<alpha>)val\\<Rightarrow>('\\<AA>)Boolean] \\<Rightarrow> ('\\<AA>,'\\<alpha>::null)Bag\"\nwhere \"OclReject S P = OclSelect S (not o P)\""], ["", "syntax\n  \"_OclRejectBag\" :: \"[('\\<AA>,'\\<alpha>::null) Bag,id,('\\<AA>)Boolean] \\<Rightarrow> '\\<AA> Boolean\"    (\"(_)->reject\\<^sub>B\\<^sub>a\\<^sub>g'(_|_')\")"], ["", "translations\n  \"X->reject\\<^sub>B\\<^sub>a\\<^sub>g(x | P)\" == \"CONST OclReject X (% x. P)\""], ["", "(*TODO Locale - Equivalent*)"], ["", "subsection\\<open>Definition: IncludesAll\\<close>"], ["", "definition OclIncludesAll   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) Bag] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclIncludesAll x y = (\\<lambda> \\<tau>.   if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                                        then \\<lfloor>\\<lfloor>Rep_Bag_base y \\<tau> \\<subseteq> Rep_Bag_base x \\<tau> \\<rfloor>\\<rfloor>\n                                        else \\<bottom>  )\""], ["", "notation   OclIncludesAll (\"_->includesAll\\<^sub>B\\<^sub>a\\<^sub>g'(_')\" (*[66,65]65*))"], ["", "interpretation OclIncludesAll : profile_bin\\<^sub>d_\\<^sub>d OclIncludesAll \"\\<lambda>x y. \\<lfloor>\\<lfloor>Rep_Bag_base' y \\<subseteq> Rep_Bag_base' x \\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclIncludesAll\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>Rep_Bag_base' y\n                           \\<subseteq> Rep_Bag_base' x\\<rfloor>\\<rfloor>)", "by(unfold_locales, auto simp:OclIncludesAll_def bot_option_def null_option_def invalid_def\n                             Rep_Bag_base_def Rep_Bag_base'_def)"], ["", "subsection\\<open>Definition: ExcludesAll\\<close>"], ["", "definition OclExcludesAll   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) Bag] \\<Rightarrow> '\\<AA> Boolean\"\nwhere     \"OclExcludesAll x y = (\\<lambda> \\<tau>.   if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                                        then \\<lfloor>\\<lfloor>Rep_Bag_base y \\<tau> \\<inter> Rep_Bag_base x \\<tau> = {} \\<rfloor>\\<rfloor>\n                                        else \\<bottom>  )\""], ["", "notation  OclExcludesAll (\"_->excludesAll\\<^sub>B\\<^sub>a\\<^sub>g'(_')\" (*[66,65]65*))"], ["", "interpretation OclExcludesAll : profile_bin\\<^sub>d_\\<^sub>d OclExcludesAll \"\\<lambda>x y. \\<lfloor>\\<lfloor>Rep_Bag_base' y \\<inter> Rep_Bag_base' x = {} \\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclExcludesAll\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>Rep_Bag_base' y \\<inter> Rep_Bag_base' x =\n                           {}\\<rfloor>\\<rfloor>)", "by(unfold_locales, auto simp:OclExcludesAll_def bot_option_def null_option_def invalid_def\n                             Rep_Bag_base_def Rep_Bag_base'_def)"], ["", "subsection\\<open>Definition: Union\\<close>"], ["", "definition OclUnion   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) Bag] \\<Rightarrow> ('\\<AA>,'\\<alpha>) Bag\"\nwhere     \"OclUnion x y = (\\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                                then Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lambda> X. \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (x \\<tau>)\\<rceil>\\<rceil> X + \n                                                       \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (y \\<tau>)\\<rceil>\\<rceil> X\\<rfloor>\\<rfloor>\n                                else invalid \\<tau> )\""], ["", "notation   OclUnion       (\"_->union\\<^sub>B\\<^sub>a\\<^sub>g'(_')\"          (*[66,65]65*))"], ["", "interpretation OclUnion : \n               profile_bin\\<^sub>d_\\<^sub>d OclUnion \"\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lambda> X. \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> X + \n                                                                \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y\\<rceil>\\<rceil> X\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclUnion\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                                X +\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          y\\<rceil>\\<rceil>\n                                X\\<rfloor>\\<rfloor>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclUnion\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                                X +\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          y\\<rceil>\\<rceil>\n                                X\\<rfloor>\\<rfloor>)", "show \"profile_bin\\<^sub>d_\\<^sub>d OclUnion (\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lambda> X. \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> X + \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y\\<rceil>\\<rceil> X\\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclUnion\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          x\\<rceil>\\<rceil>\n                                X +\n                               \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          y\\<rceil>\\<rceil>\n                                X\\<rfloor>\\<rfloor>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y.\n       bin OclUnion\n        (\\<lambda>x y.\n            Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>\\<lfloor>\\<lambda>X.\n                                  \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   X +\n                                  \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             y\\<rceil>\\<rceil>\n                                   X\\<rfloor>\\<rfloor>)\n        defined defined X Y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null; y \\<noteq> \\<bottom>;\n        y \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lambda>X.\n         \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          x\\<rceil>\\<rceil>\n          X +\n         \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          y\\<rceil>\\<rceil>\n          X\\<rfloor>\\<rfloor> \\<noteq>\n                         \\<bottom> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lambda>X.\n         \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          x\\<rceil>\\<rceil>\n          X +\n         \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          y\\<rceil>\\<rceil>\n          X\\<rfloor>\\<rfloor> \\<noteq>\n                         null", "apply(auto simp:OclUnion_def bot_option_def null_option_def \n                   null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        y \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lambda>X.\n                              \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         x\\<rceil>\\<rceil>\n                               X +\n                              \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         y\\<rceil>\\<rceil>\n                               X\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        y \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lambda>X.\n                              \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         x\\<rceil>\\<rceil>\n                               X +\n                              \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         y\\<rceil>\\<rceil>\n                               X\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>None\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by(subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject,\n      simp_all add: bot_option_def null_option_def, \n      metis (mono_tags, lifting) Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse bot_option_def mem_Collect_eq\n                                 null_option_def)+"], ["proof (state)\nthis:\n  profile_bin\\<^sub>d_\\<^sub>d OclUnion\n   (\\<lambda>x y.\n       Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>\\<lambda>X.\n                             \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        x\\<rceil>\\<rceil>\n                              X +\n                             \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        y\\<rceil>\\<rceil>\n                              X\\<rfloor>\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Definition: Intersection\\<close>"], ["", "definition OclIntersection   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) Bag] \\<Rightarrow> ('\\<AA>,'\\<alpha>) Bag\"\nwhere     \"OclIntersection x y = (\\<lambda> \\<tau>.  if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                                        then Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<lfloor>\\<lfloor> \\<lambda> X. min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (x \\<tau>)\\<rceil>\\<rceil> X) \n                                                       (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (y \\<tau>)\\<rceil>\\<rceil> X)\\<rfloor>\\<rfloor>\n                                        else \\<bottom>  )\""], ["", "notation   OclIntersection(\"_->intersection\\<^sub>B\\<^sub>a\\<^sub>g'(_')\"   (*[71,70]70*))"], ["", "interpretation OclIntersection : \n               profile_bin\\<^sub>d_\\<^sub>d OclIntersection \"\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lambda> X. min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> X) \n                                                                (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y\\<rceil>\\<rceil> X)\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclIntersection\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n               x\\<rceil>\\<rceil>\n                                     X)\n                                (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            y\\<rceil>\\<rceil>\n                                  X)\\<rfloor>\\<rfloor>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclIntersection\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n               x\\<rceil>\\<rceil>\n                                     X)\n                                (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            y\\<rceil>\\<rceil>\n                                  X)\\<rfloor>\\<rfloor>)", "show \"profile_bin\\<^sub>d_\\<^sub>d OclIntersection (\\<lambda>x y. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> \\<lambda> X. min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> X) \n                                                                (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e y\\<rceil>\\<rceil> X)\\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclIntersection\n     (\\<lambda>x y.\n         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<lfloor>\\<lfloor>\\<lambda>X.\n                               min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n               x\\<rceil>\\<rceil>\n                                     X)\n                                (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            y\\<rceil>\\<rceil>\n                                  X)\\<rfloor>\\<rfloor>)", "apply unfold_locales"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y.\n       bin OclIntersection\n        (\\<lambda>x y.\n            Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             \\<lfloor>\\<lfloor>\\<lambda>X.\n                                  min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                  x\\<rceil>\\<rceil>\n  X)\n                                   (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n               y\\<rceil>\\<rceil>\n                                     X)\\<rfloor>\\<rfloor>)\n        defined defined X Y\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null; y \\<noteq> \\<bottom>;\n        y \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lambda>X.\n         min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               x\\<rceil>\\<rceil>\n               X)\n          (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            y\\<rceil>\\<rceil>\n            X)\\<rfloor>\\<rfloor> \\<noteq>\n                         \\<bottom> \\<and>\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lambda>X.\n         min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               x\\<rceil>\\<rceil>\n               X)\n          (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            y\\<rceil>\\<rceil>\n            X)\\<rfloor>\\<rfloor> \\<noteq>\n                         null", "apply(auto simp:OclIntersection_def bot_option_def null_option_def \n                   null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def invalid_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        y \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lambda>X.\n                              min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              x\\<rceil>\\<rceil>\n                                    X)\n                               (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n           y\\<rceil>\\<rceil>\n                                 X)\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>x y.\n       \\<lbrakk>x \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        x \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        y \\<noteq> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None;\n        y \\<noteq>\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>;\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lambda>X.\n                              min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              x\\<rceil>\\<rceil>\n                                    X)\n                               (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n           y\\<rceil>\\<rceil>\n                                 X)\\<rfloor>\\<rfloor> =\n        Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>None\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by(subst (asm) Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject,\n      simp_all add: bot_option_def null_option_def, \n      metis (mono_tags, lifting) Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse bot_option_def mem_Collect_eq min_0R\n                                 null_option_def)+"], ["proof (state)\nthis:\n  profile_bin\\<^sub>d_\\<^sub>d OclIntersection\n   (\\<lambda>x y.\n       Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>\\<lambda>X.\n                             min (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             x\\<rceil>\\<rceil>\n                                   X)\n                              (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          y\\<rceil>\\<rceil>\n                                X)\\<rfloor>\\<rfloor>)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Definition: Count\\<close>"], ["", "definition OclCount   :: \"[('\\<AA>,'\\<alpha>::null) Bag,('\\<AA>,'\\<alpha>) val] \\<Rightarrow> ('\\<AA>) Integer\"\nwhere     \"OclCount x y = (\\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                             then  \\<lfloor>\\<lfloor>int(\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (x \\<tau>)\\<rceil>\\<rceil> (y \\<tau>))\\<rfloor>\\<rfloor> \n                             else invalid \\<tau> )\""], ["", "notation   OclCount (\"_->count\\<^sub>B\\<^sub>a\\<^sub>g'(_')\"  (*[66,65]65*))"], ["", "interpretation OclCount : profile_bin\\<^sub>d_\\<^sub>d OclCount \"\\<lambda>x y. \\<lfloor>\\<lfloor>int(\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e x\\<rceil>\\<rceil> y)\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d OclCount\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>int (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n           x\\<rceil>\\<rceil>\n                                 y)\\<rfloor>\\<rfloor>)", "by(unfold_locales, auto simp:OclCount_def bot_option_def null_option_def)"], ["", "subsection\\<open>Definition (future operators)\\<close>"], ["", "consts (* abstract bag collection operations *)\n    OclSum         :: \" ('\\<AA>,'\\<alpha>::null) Bag \\<Rightarrow> '\\<AA> Integer\""], ["", "notation  OclSum         (\"_->sum\\<^sub>B\\<^sub>a\\<^sub>g'(')\" (*[66]*))"], ["", "subsection\\<open>Logical Properties\\<close>"], ["", "text\\<open>OclIncluding\\<close>"], ["", "lemma OclIncluding_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->including\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> \\<upsilon> X->including\\<^sub>B\\<^sub>a\\<^sub>g(x)) =\n    (\\<tau> \\<Turnstile> \\<delta> X \\<and> \\<tau> \\<Turnstile> \\<upsilon> x)", "by (metis (hide_lams, no_types) OclIncluding.def_valid_then_def OclIncluding.defined_args_valid)"], ["", "lemma OclIncluding_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->including\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> X->including\\<^sub>B\\<^sub>a\\<^sub>g(x) =\n    (\\<delta> X and \\<upsilon> x)", "by (simp add: OclIncluding.def_valid_then_def)"], ["", "text\\<open>etc. etc.\\<close>"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "text\\<open>OclExcluding\\<close>"], ["", "lemma OclExcluding_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> \\<upsilon> X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x)) =\n    (\\<tau> \\<Turnstile> \\<delta> X \\<and> \\<tau> \\<Turnstile> \\<upsilon> x)", "by (metis OclExcluding.def_valid_then_def OclExcluding.defined_args_valid)"], ["", "lemma OclExcluding_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> X->excluding\\<^sub>B\\<^sub>a\\<^sub>g(x) =\n    (\\<delta> X and \\<upsilon> x)", "by (simp add: OclExcluding.def_valid_then_def)"], ["", "text\\<open>OclIncludes\\<close>"], ["", "lemma OclIncludes_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> \\<upsilon> X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x)) =\n    (\\<tau> \\<Turnstile> \\<delta> X \\<and> \\<tau> \\<Turnstile> \\<upsilon> x)", "by (simp add: OclIncludes.def_valid_then_def foundation10')"], ["", "lemma OclIncludes_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x) =\n    (\\<delta> X and \\<upsilon> x)", "by (simp add: OclIncludes.def_valid_then_def)"], ["", "text\\<open>OclExcludes\\<close>"], ["", "lemma OclExcludes_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x))) = ((\\<tau> \\<Turnstile>(\\<delta> X)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> \\<upsilon> X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x)) =\n    (\\<tau> \\<Turnstile> \\<delta> X \\<and> \\<tau> \\<Turnstile> \\<upsilon> x)", "by (simp add: OclExcludes.def_valid_then_def foundation10')"], ["", "lemma OclExcludes_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x)) = ((\\<delta> X) and (\\<upsilon> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> X->excludes\\<^sub>B\\<^sub>a\\<^sub>g(x) =\n    (\\<delta> X and \\<upsilon> x)", "by (simp add: OclExcludes.def_valid_then_def)"], ["", "text\\<open>OclSize\\<close>"], ["", "lemma OclSize_defined_args_valid: \"\\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<delta> X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> X", "by(auto simp: OclSize_def OclValid_def true_def valid_def false_def StrongEq_def\n              defined_def invalid_def bot_fun_def null_fun_def\n        split: bool.split_asm HOL.if_split_asm option.split)"], ["", "lemma OclSize_infinite:\nassumes non_finite:\"\\<tau> \\<Turnstile> not(\\<delta>(S->size\\<^sub>B\\<^sub>a\\<^sub>g()))\"\nshows   \"(\\<tau> \\<Turnstile> not(\\<delta>(S))) \\<or> \\<not> finite (Rep_Bag_base S \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (\\<delta> S) \\<or>\n    infinite (Rep_Bag_base S \\<tau>)", "apply(insert non_finite, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     |\\<noteq> \\<delta> S->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> S \\<longrightarrow>\n    infinite (Rep_Bag_base S \\<tau>)", "apply(rule impI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> |\\<noteq> \\<delta> S->size\\<^sub>B\\<^sub>a\\<^sub>g();\n     \\<tau> \\<Turnstile> \\<delta> S\\<rbrakk>\n    \\<Longrightarrow> infinite (Rep_Bag_base S \\<tau>)", "apply(simp add: OclSize_def OclValid_def defined_def bot_fun_def null_fun_def bot_option_def null_option_def\n           split: if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     infinite (Rep_Bag_base X \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> X->size\\<^sub>B\\<^sub>a\\<^sub>g()", "by(simp add: OclSize_def OclValid_def defined_def bot_fun_def false_def true_def)"], ["", "lemma size_defined:\n assumes X_finite: \"\\<And>\\<tau>. finite (Rep_Bag_base X \\<tau>)\"\n shows \"\\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g()) = \\<delta> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> X->size\\<^sub>B\\<^sub>a\\<^sub>g() = \\<delta> X", "apply(rule ext, simp add: cp_defined[of \"X->size\\<^sub>B\\<^sub>a\\<^sub>g()\"] OclSize_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<delta> (\\<lambda>\\<tau>.\n                     if (\\<delta> X) \\<tau> = true \\<tau> \\<and>\n                        finite (Rep_Bag_base X \\<tau>)\n                     then \\<lfloor>\\<lfloor>int\n       (card (Rep_Bag_base X \\<tau>))\\<rfloor>\\<rfloor>\n                     else \\<bottom>))\n        x =\n       (\\<delta> X) x", "apply(simp add: defined_def bot_option_def bot_fun_def null_option_def null_fun_def X_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma size_defined':\n assumes X_finite: \"finite (Rep_Bag_base X \\<tau>)\"\n shows \"(\\<tau> \\<Turnstile> \\<delta> (X->size\\<^sub>B\\<^sub>a\\<^sub>g())) = (\\<tau> \\<Turnstile> \\<delta> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<delta> X)", "apply(simp add: cp_defined[of \"X->size\\<^sub>B\\<^sub>a\\<^sub>g()\"] OclSize_def OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<delta> (\\<lambda>\\<tau>.\n                   if (\\<delta> X) \\<tau> = true \\<tau> \\<and>\n                      finite (Rep_Bag_base X \\<tau>)\n                   then \\<lfloor>\\<lfloor>int\n     (card (Rep_Bag_base X \\<tau>))\\<rfloor>\\<rfloor>\n                   else \\<bottom>))\n      \\<tau> =\n     true \\<tau>) =\n    ((\\<delta> X) \\<tau> = true \\<tau>)", "apply(simp add: defined_def bot_option_def bot_fun_def null_option_def null_fun_def X_finite)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>OclIsEmpty\\<close>"], ["", "lemma OclIsEmpty_defined_args_valid:\"\\<tau> \\<Turnstile> \\<delta> (X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<delta> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> X", "apply(auto simp: OclIsEmpty_def OclValid_def defined_def valid_def false_def true_def\n                   bot_fun_def null_fun_def OclAnd_def OclOr_def OclNot_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> = \\<bottom>;\n     (case case (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n                 \\<tau> of\n           None \\<Rightarrow> None\n           | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n           | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n               \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n      None \\<Rightarrow> None\n      | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n     \\<bottom>;\n     (case case (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n                 \\<tau> of\n           None \\<Rightarrow> None\n           | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n           | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n               \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n      None \\<Rightarrow> None\n      | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n     null\\<rbrakk>\n    \\<Longrightarrow> False", "apply(case_tac \"(X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau>\", simp add: bot_option_def, simp, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>X \\<tau> = \\<bottom>;\n        (case case x of None \\<Rightarrow> \\<lfloor>None\\<rfloor>\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor> of\n         None \\<Rightarrow> None\n         | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n         | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n        \\<bottom>;\n        (case case x of None \\<Rightarrow> \\<lfloor>None\\<rfloor>\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor> of\n         None \\<Rightarrow> None\n         | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n         | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n        null;\n        (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau> =\n        \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(case_tac x, simp add: null_option_def bot_option_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>X \\<tau> = \\<bottom>;\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> \\<noteq> \\<bottom>;\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> \\<noteq> null;\n        (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau> =\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor>;\n        x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: OclSize_def StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r valid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>X \\<tau> = \\<bottom>;\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> \\<noteq> \\<bottom>;\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> \\<noteq> null;\n        (if (if (if (\\<delta> X) \\<tau> = true \\<tau> \\<and>\n                    finite (Rep_Bag_base X \\<tau>)\n                 then \\<lfloor>\\<lfloor>int\n   (card (Rep_Bag_base X \\<tau>))\\<rfloor>\\<rfloor>\n                 else \\<bottom>) =\n                \\<bottom> \\<tau>\n             then false \\<tau> else true \\<tau>) =\n            true \\<tau> \\<and>\n            (if \\<zero> \\<tau> = \\<bottom> \\<tau> then false \\<tau>\n             else true \\<tau>) =\n            true \\<tau>\n         then ((\\<lambda>\\<tau>.\n                   if (\\<delta> X) \\<tau> = true \\<tau> \\<and>\n                      finite (Rep_Bag_base X \\<tau>)\n                   then \\<lfloor>\\<lfloor>int\n     (card (Rep_Bag_base X \\<tau>))\\<rfloor>\\<rfloor>\n                   else \\<bottom>) \\<triangleq>\n               \\<zero>)\n               \\<tau>\n         else invalid \\<tau>) =\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor>;\n        x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by (metis (hide_lams, no_types)\n           bot_fun_def OclValid_def defined_def foundation2 invalid_def)"], ["", "lemma \"\\<tau> \\<Turnstile> \\<delta> (null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "by(auto simp: OclIsEmpty_def OclValid_def defined_def valid_def false_def true_def\n              bot_fun_def null_fun_def OclAnd_def OclOr_def OclNot_def null_is_valid\n        split: if_split_asm)"], ["", "lemma OclIsEmpty_infinite: \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     infinite (Rep_Bag_base X \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "apply(auto simp: OclIsEmpty_def OclValid_def defined_def valid_def false_def true_def\n                   bot_fun_def null_fun_def OclAnd_def OclOr_def OclNot_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite (Rep_Bag_base X \\<tau>); X \\<tau> \\<noteq> \\<bottom>;\n     X \\<tau> \\<noteq> null;\n     (case case (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n                 \\<tau> of\n           None \\<Rightarrow> None\n           | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n           | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n               \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n      None \\<Rightarrow> None\n      | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n     null\\<rbrakk>\n    \\<Longrightarrow> (case case (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq>\n                                  \\<zero>)\n                                  \\<tau> of\n                            None \\<Rightarrow> None\n                            | \\<lfloor>None\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>None\\<rfloor>\n                            | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n                       None \\<Rightarrow> None\n                       | \\<lfloor>None\\<rfloor> \\<Rightarrow>\n                           \\<lfloor>None\\<rfloor>\n                       | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                           \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n                      \\<bottom>", "apply(case_tac \"(X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau>\", simp add: bot_option_def, simp, rename_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>infinite (Rep_Bag_base X \\<tau>);\n        X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n        (case case x of None \\<Rightarrow> \\<lfloor>None\\<rfloor>\n              | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor> of\n         None \\<Rightarrow> None\n         | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n         | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) \\<noteq>\n        null;\n        (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau> =\n        \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (case case x of\n                               None \\<Rightarrow> \\<lfloor>None\\<rfloor>\n                               | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                                   \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor> of\n                          None \\<Rightarrow> None\n                          | \\<lfloor>None\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>None\\<rfloor>\n                          | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n                         \\<bottom>", "apply(case_tac x, simp add: null_option_def bot_option_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       \\<lbrakk>infinite (Rep_Bag_base X \\<tau>);\n        X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> \\<noteq> null;\n        (X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>) \\<tau> =\n        \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor>;\n        x = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>a\\<rfloor>\\<rfloor> = \\<bottom>", "by(simp add: OclSize_def StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r valid_def bot_fun_def false_def true_def invalid_def)"], ["", "text\\<open>OclNotEmpty\\<close>"], ["", "lemma OclNotEmpty_defined_args_valid:\"\\<tau> \\<Turnstile> \\<delta> (X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<delta> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> X", "by (metis (hide_lams, no_types) OclNotEmpty_def OclNot_defargs OclNot_not foundation6 foundation9\n                                OclIsEmpty_defined_args_valid)"], ["", "lemma \"\\<tau> \\<Turnstile> \\<delta> (null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "by (metis (hide_lams, no_types) OclNotEmpty_def OclAnd_false1 OclAnd_idem OclIsEmpty_def\n                                OclNot3 OclNot4 OclOr_def defined2 defined4 transform1 valid2)"], ["", "lemma OclNotEmpty_infinite: \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<not> finite (Rep_Bag_base X \\<tau>) \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     infinite (Rep_Bag_base X \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "apply(simp add: OclNotEmpty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     infinite (Rep_Bag_base X \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> not\n     X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "apply(drule OclIsEmpty_infinite, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>infinite (Rep_Bag_base X \\<tau>);\n     \\<tau> |\\<noteq> \\<delta> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> not\n     X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()", "by (metis OclNot_defargs OclNot_not foundation6 foundation9)"], ["", "lemma OclNotEmpty_has_elt : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n                          \\<exists>e. e \\<in> (Rep_Bag_base X \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>", "have s_non_empty: \"\\<And>S. S \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>S. S \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> S", "by blast"], ["proof (state)\nthis:\n  ?S \\<noteq> {} \\<Longrightarrow> \\<exists>x. x \\<in> ?S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>", "show \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n      \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n      ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>", "apply(simp add: OclNotEmpty_def OclIsEmpty_def deMorgan1 deMorgan2, drule foundation5)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> not (\\<upsilon> X) or \\<delta> X \\<and>\n     \\<tau>\n      \\<Turnstile> X->size\\<^sub>B\\<^sub>a\\<^sub>g() <> \\<zero>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "apply(subst (asm) (2) OclNot_def,\n       simp add: OclValid_def StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r StrongEq_def\n            split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     (\\<upsilon> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> = true \\<tau>;\n     (not (\\<upsilon> X) or \\<delta> X) \\<tau> = true \\<tau> \\<and>\n     \\<lfloor>\\<lfloor>X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> \\<noteq>\n                       \\<zero> \\<tau>\\<rfloor>\\<rfloor> =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>\n 2. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     (\\<upsilon> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> \\<noteq>\n     true \\<tau>;\n     (not (\\<upsilon> X) or \\<delta> X) \\<tau> = true \\<tau> \\<and>\n     (case invalid \\<tau> of None \\<Rightarrow> None\n      | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     (\\<upsilon> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> \\<noteq>\n     true \\<tau>;\n     (not (\\<upsilon> X) or \\<delta> X) \\<tau> = true \\<tau> \\<and>\n     (case invalid \\<tau> of None \\<Rightarrow> None\n      | \\<lfloor>None\\<rfloor> \\<Rightarrow> \\<lfloor>None\\<rfloor>\n      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>\n 2. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     (\\<upsilon> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> = true \\<tau>;\n     (not (\\<upsilon> X) or \\<delta> X) \\<tau> = true \\<tau> \\<and>\n     \\<lfloor>\\<lfloor>X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> \\<noteq>\n                       \\<zero> \\<tau>\\<rfloor>\\<rfloor> =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "apply(simp add: invalid_def bot_option_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     (\\<upsilon> X->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> = true \\<tau>;\n     (not (\\<upsilon> X) or \\<delta> X) \\<tau> = true \\<tau> \\<and>\n     \\<lfloor>\\<lfloor>X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> \\<noteq>\n                       \\<zero> \\<tau>\\<rfloor>\\<rfloor> =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "apply(simp add: OclSize_def valid_def split: if_split_asm,\n       simp_all add: false_def true_def bot_option_def bot_fun_def OclInt0_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(not (\\<lambda>\\<tau>.\n                      if X \\<tau> = \\<bottom> then false \\<tau>\n                      else true \\<tau>) or\n              \\<delta> X)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     Rep_Bag_base X \\<tau> \\<noteq> {};\n     (\\<delta> X) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite (Rep_Bag_base X \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "apply(drule s_non_empty[of \"Rep_Bag_base X \\<tau>\"], erule exE, case_tac x)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>(not (\\<lambda>\\<tau>.\n                         if X \\<tau> = \\<bottom> then false \\<tau>\n                         else true \\<tau>) or\n                 \\<delta> X)\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        finite (Rep_Bag_base X \\<tau>); x \\<in> Rep_Bag_base X \\<tau>;\n        x = (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b. (a, b) \\<in> Rep_Bag_base X \\<tau>", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n   \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OclNotEmpty_has_elt' : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n                          \\<exists>e. e \\<in> (Rep_Set_base X \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Set_base X \\<tau>", "apply(drule OclNotEmpty_has_elt, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g();\n     \\<exists>e. e \\<in> Rep_Bag_base X \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. e \\<in> Rep_Set_base X \\<tau>", "by(simp add: Rep_Bag_base_def Rep_Set_base_def image_def)"], ["", "text\\<open>OclANY\\<close>"], ["", "lemma OclANY_defined_args_valid: \"\\<tau> \\<Turnstile> \\<delta> (X->any\\<^sub>B\\<^sub>a\\<^sub>g()) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<delta> X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> X", "by(auto simp: OclANY_def OclValid_def true_def valid_def false_def StrongEq_def\n              defined_def invalid_def bot_fun_def null_fun_def OclAnd_def\n        split: bool.split_asm HOL.if_split_asm option.split)"], ["", "lemma \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow> \\<tau> \\<Turnstile> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow> \\<not> \\<tau> \\<Turnstile> \\<delta> (X->any\\<^sub>B\\<^sub>a\\<^sub>g())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n     \\<tau> \\<Turnstile> X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       |\\<noteq> \\<delta> X->any\\<^sub>B\\<^sub>a\\<^sub>g()", "apply(simp add: OclANY_def OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> = true \\<tau>;\n     X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (\\<delta> (\\<lambda>\\<tau>.\n                                    if (\\<upsilon> X) \\<tau> = true \\<tau>\n                                    then if (\\<delta> X and\n       X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\n       \\<tau> =\n      true \\<tau>\n   then SOME y. y \\<in> Rep_Set_base X \\<tau> else null \\<tau>\n                                    else \\<bottom>))\n                       \\<tau> \\<noteq>\n                      true \\<tau>", "apply(subst cp_defined, subst cp_OclAnd, simp add: OclNotEmpty_def, subst (1 2) cp_OclNot,\n       simp add: cp_OclNot[symmetric] cp_OclAnd[symmetric] cp_defined[symmetric],\n       simp add: false_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n    \\<Longrightarrow> (\\<upsilon> X) \\<tau> \\<noteq>\n                      \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n                      (\\<delta> (\\<lambda>_. \\<bottom>)) \\<tau> \\<noteq>\n                      \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>", "by(drule foundation20[simplified OclValid_def true_def], simp)"], ["", "lemma OclANY_valid_args_valid:\n\"(\\<tau> \\<Turnstile> \\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g())) = (\\<tau> \\<Turnstile> \\<upsilon> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<upsilon> X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<upsilon> X)", "have A: \"(\\<tau> \\<Turnstile> \\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g())) \\<Longrightarrow> ((\\<tau> \\<Turnstile>(\\<upsilon> X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> X", "by(auto simp: OclANY_def OclValid_def true_def valid_def false_def StrongEq_def\n                        defined_def invalid_def bot_fun_def null_fun_def\n                  split: bool.split_asm HOL.if_split_asm option.split)"], ["proof (state)\nthis:\n  \\<tau>\n   \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<Longrightarrow>\n  \\<tau> \\<Turnstile> \\<upsilon> X\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<upsilon> X)", "have B: \"(\\<tau> \\<Turnstile>(\\<upsilon> X)) \\<Longrightarrow> (\\<tau> \\<Turnstile> \\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> X \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()", "apply(auto simp: OclANY_def OclValid_def true_def false_def StrongEq_def\n                            defined_def invalid_def valid_def bot_fun_def null_fun_def\n                            bot_option_def null_option_def null_is_valid\n                            OclAnd_def\n                      split: bool.split_asm HOL.if_split_asm option.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> False", "apply(frule Bag_inv_lemma[OF foundation16[THEN iffD2], OF conjI], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0\\<rbrakk>\n    \\<Longrightarrow> False", "apply(subgoal_tac \"(\\<delta> X) \\<tau> = true \\<tau>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0;\n     (\\<delta> X) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0\\<rbrakk>\n    \\<Longrightarrow> (\\<delta> X) \\<tau> = true \\<tau>", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0\\<rbrakk>\n    \\<Longrightarrow> (\\<delta> X) \\<tau> = true \\<tau>\n 2. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0;\n     (\\<delta> X) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "apply (metis (hide_lams, no_types) OclValid_def foundation16)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0;\n     (\\<delta> X) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "apply(simp add: true_def,\n                 drule OclNotEmpty_has_elt'[simplified OclValid_def true_def], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n     X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n     \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X \\<tau>)\\<rceil>\\<rceil>\n      \\<bottom> =\n     0;\n     \\<exists>e. e \\<in> Rep_Set_base X \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "apply(erule exE,\n                 rule someI2[where Q = \"\\<lambda>x. x \\<noteq> \\<bottom>\" and P = \"\\<lambda>y. y \\<in> (Rep_Set_base X \\<tau>)\",\n                             simplified not_def, THEN mp], simp, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>e.\n       \\<lbrakk>X \\<tau> \\<noteq> \\<bottom>; X \\<tau> \\<noteq> null;\n        X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (SOME y. y \\<in> Rep_Set_base X \\<tau>) = \\<bottom>;\n        \\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (X \\<tau>)\\<rceil>\\<rceil>\n         \\<bottom> =\n        0;\n        e \\<in> Rep_Set_base X \\<tau>;\n        \\<bottom> \\<in> Rep_Set_base X \\<tau>\\<rbrakk>\n       \\<Longrightarrow> False", "by(simp add: Rep_Set_base_def image_def)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<upsilon> X \\<Longrightarrow>\n  \\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<upsilon> X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n    (\\<tau> \\<Turnstile> \\<upsilon> X)", "by(auto dest:A intro:B)"], ["proof (state)\nthis:\n  (\\<tau> \\<Turnstile> \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g()) =\n  (\\<tau> \\<Turnstile> \\<upsilon> X)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OclANY_valid_args_valid''[simp,code_unfold]:\n\"\\<upsilon>(X->any\\<^sub>B\\<^sub>a\\<^sub>g()) = (\\<upsilon> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> X->any\\<^sub>B\\<^sub>a\\<^sub>g() = \\<upsilon> X", "by(auto intro!: OclANY_valid_args_valid transform2_rev)"], ["", "(* and higher order ones : forall, exists, iterate, select, reject... *)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Execution Laws with Invalid or Null or Infinite Set as Argument\\<close>"], ["", "text\\<open>OclIncluding\\<close>"], ["", "(* properties already generated by the corresponding locale *)"], ["", "text\\<open>OclExcluding\\<close>"], ["", "(* properties already generated by the corresponding locale *)"], ["", "text\\<open>OclIncludes\\<close>"], ["", "(* properties already generated by the corresponding locale *)"], ["", "text\\<open>OclExcludes\\<close>"], ["", "(* properties already generated by the corresponding locale *)"], ["", "text\\<open>OclSize\\<close>"], ["", "lemma OclSize_invalid[simp,code_unfold]:\"(invalid->size\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid->size\\<^sub>B\\<^sub>a\\<^sub>g() = invalid", "by(simp add: bot_fun_def OclSize_def invalid_def defined_def valid_def false_def true_def)"], ["", "lemma OclSize_null[simp,code_unfold]:\"(null->size\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null->size\\<^sub>B\\<^sub>a\\<^sub>g() = invalid", "by(rule ext,\n   simp add: bot_fun_def null_fun_def null_is_valid OclSize_def\n             invalid_def defined_def valid_def false_def true_def)"], ["", "text\\<open>OclIsEmpty\\<close>"], ["", "lemma OclIsEmpty_invalid[simp,code_unfold]:\"(invalid->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() = invalid", "by(simp add: OclIsEmpty_def)"], ["", "lemma OclIsEmpty_null[simp,code_unfold]:\"(null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() = true", "by(simp add: OclIsEmpty_def)"], ["", "text\\<open>OclNotEmpty\\<close>"], ["", "lemma OclNotEmpty_invalid[simp,code_unfold]:\"(invalid->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() = invalid", "by(simp add: OclNotEmpty_def)"], ["", "lemma OclNotEmpty_null[simp,code_unfold]:\"(null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() = false", "by(simp add: OclNotEmpty_def)"], ["", "text\\<open>OclANY\\<close>"], ["", "lemma OclANY_invalid[simp,code_unfold]:\"(invalid->any\\<^sub>B\\<^sub>a\\<^sub>g()) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid->any\\<^sub>B\\<^sub>a\\<^sub>g() = invalid", "by(simp add: bot_fun_def OclANY_def invalid_def defined_def valid_def false_def true_def)"], ["", "lemma OclANY_null[simp,code_unfold]:\"(null->any\\<^sub>B\\<^sub>a\\<^sub>g()) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null->any\\<^sub>B\\<^sub>a\\<^sub>g() = null", "by(simp add: OclANY_def false_def true_def)"], ["", "text\\<open>OclForall\\<close>"], ["", "lemma OclForall_invalid[simp,code_unfold]:\"invalid->forAll\\<^sub>B\\<^sub>a\\<^sub>g(a| P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclForall invalid P = invalid", "by(simp add: bot_fun_def invalid_def OclForall_def defined_def valid_def false_def true_def)"], ["", "lemma OclForall_null[simp,code_unfold]:\"null->forAll\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclForall null P = invalid", "by(simp add: bot_fun_def invalid_def OclForall_def defined_def valid_def false_def true_def)"], ["", "text\\<open>OclExists\\<close>"], ["", "lemma OclExists_invalid[simp,code_unfold]:\"invalid->exists\\<^sub>B\\<^sub>a\\<^sub>g(a| P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclExists invalid P = invalid", "by(simp add: OclExists_def)"], ["", "lemma OclExists_null[simp,code_unfold]:\"null->exists\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclExists null P = invalid", "by(simp add: OclExists_def)"], ["", "text\\<open>OclIterate\\<close>"], ["", "lemma OclIterate_invalid[simp,code_unfold]:\"invalid->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate invalid A P = invalid", "by(simp add: bot_fun_def invalid_def OclIterate_def defined_def valid_def false_def true_def)"], ["", "lemma OclIterate_null[simp,code_unfold]:\"null->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate null A P = invalid", "by(simp add: bot_fun_def invalid_def OclIterate_def defined_def valid_def false_def true_def)"], ["", "lemma OclIterate_invalid_args[simp,code_unfold]:\"S->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = invalid | P a x) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate S invalid P = invalid", "by(simp add: bot_fun_def invalid_def OclIterate_def defined_def valid_def false_def true_def)"], ["", "text\\<open>An open question is this ...\\<close>"], ["", "lemma (*OclIterate_null_args[simp,code_unfold]:*) \"S->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = null | P a x) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate S null P = invalid", "oops"], ["", "(* In the definition above, this does not hold in general.\n       And I believe, this is how it should be ... *)"], ["", "lemma OclIterate_infinite:\nassumes non_finite: \"\\<tau> \\<Turnstile> not(\\<delta>(S->size\\<^sub>B\\<^sub>a\\<^sub>g()))\"\nshows \"(OclIterate S A F) \\<tau> = invalid \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate S A F \\<tau> = invalid \\<tau>", "apply(insert non_finite [THEN OclSize_infinite])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (\\<delta> S) \\<or>\n    infinite (Rep_Bag_base S \\<tau>) \\<Longrightarrow>\n    OclIterate S A F \\<tau> = invalid \\<tau>", "apply(subst (asm) foundation9, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> \\<delta> S \\<or>\n    infinite (Rep_Bag_base S \\<tau>) \\<Longrightarrow>\n    OclIterate S A F \\<tau> = invalid \\<tau>", "by(metis OclIterate_def OclValid_def invalid_def)"], ["", "text\\<open>OclSelect\\<close>"], ["", "lemma OclSelect_invalid[simp,code_unfold]:\"invalid->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclSelect invalid P = invalid", "by(simp add: bot_fun_def invalid_def OclSelect_def defined_def valid_def false_def true_def)"], ["", "lemma OclSelect_null[simp,code_unfold]:\"null->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclSelect null P = invalid", "by(simp add: bot_fun_def invalid_def OclSelect_def defined_def valid_def false_def true_def)"], ["", "text\\<open>OclReject\\<close>"], ["", "lemma OclReject_invalid[simp,code_unfold]:\"invalid->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclReject invalid P = invalid", "by(simp add: OclReject_def)"], ["", "lemma OclReject_null[simp,code_unfold]:\"null->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclReject null P = invalid", "by(simp add: OclReject_def)"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "subsubsection\\<open>Context Passing\\<close>"], ["", "lemma cp_OclIncludes1:\n\"(X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x)) \\<tau> = (X->includes\\<^sub>B\\<^sub>a\\<^sub>g(\\<lambda> _. x \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->includes\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n    X->includes\\<^sub>B\\<^sub>a\\<^sub>g(\\<lambda>_. x \\<tau>) \\<tau>", "by(auto simp: OclIncludes_def StrongEq_def invalid_def\n                 cp_defined[symmetric] cp_valid[symmetric])"], ["", "lemma cp_OclSize: \"X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->size\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    \\<lambda>_. X \\<tau>->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>", "by(simp add: OclSize_def cp_defined[symmetric] Rep_Bag_base_def)"], ["", "lemma cp_OclIsEmpty: \"X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    \\<lambda>_. X \\<tau>->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>", "apply(simp only: OclIsEmpty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> X and not (\\<delta> X) or\n     X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n     \\<tau> =\n    (\\<upsilon> (\\<lambda>_. X \\<tau>) and\n     not (\\<delta> (\\<lambda>_. X \\<tau>)) or\n     \\<lambda>_. X \\<tau>->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n     \\<tau>", "apply(subst (2) cp_OclOr,\n       subst cp_OclAnd,\n       subst cp_OclNot,\n       subst StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r.cp0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> X and not (\\<delta> X) or\n     X->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<zero>)\n     \\<tau> =\n    ((\\<lambda>_.\n         ((\\<lambda>_. (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>) and\n          (\\<lambda>_.\n              not (\\<lambda>_. (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>)\n               \\<tau>))\n          \\<tau>) or\n     (\\<lambda>_.\n         ((\\<lambda>_.\n              \\<lambda>_. X \\<tau>->size\\<^sub>B\\<^sub>a\\<^sub>g()\n               \\<tau>) \\<doteq>\n          (\\<lambda>_. \\<zero> \\<tau>))\n          \\<tau>))\n     \\<tau>", "by(simp add: cp_defined[symmetric] cp_valid[symmetric] StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r.cp0[symmetric]\n             cp_OclSize[symmetric] cp_OclNot[symmetric] cp_OclAnd[symmetric] cp_OclOr[symmetric])"], ["", "lemma cp_OclNotEmpty: \"X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    \\<lambda>_. X \\<tau>->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>", "apply(simp only: OclNotEmpty_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. not X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    not \\<lambda>_. X \\<tau>->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>", "apply(subst (2) cp_OclNot)"], ["proof (prove)\ngoal (1 subgoal):\n 1. not X->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    not (\\<lambda>_.\n            \\<lambda>_. X \\<tau>->isEmpty\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>)\n     \\<tau>", "by(simp add: cp_OclNot[symmetric] cp_OclIsEmpty[symmetric])"], ["", "lemma cp_OclANY: \"X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> = ((\\<lambda>_. X \\<tau>)->any\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau> =\n    \\<lambda>_. X \\<tau>->any\\<^sub>B\\<^sub>a\\<^sub>g() \\<tau>", "apply(simp only: OclANY_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<upsilon> X) \\<tau> = true \\<tau>\n     then if (\\<delta> X and X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> =\n             true \\<tau>\n          then SOME y. y \\<in> Rep_Set_base X \\<tau> else null \\<tau>\n     else \\<bottom>) =\n    (if (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau> = true \\<tau>\n     then if (\\<delta> (\\<lambda>_. X \\<tau>) and\n              \\<lambda>_. X \\<tau>->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g())\n              \\<tau> =\n             true \\<tau>\n          then SOME y. y \\<in> Rep_Set_base (\\<lambda>_. X \\<tau>) \\<tau>\n          else null \\<tau>\n     else \\<bottom>)", "apply(subst (2) cp_OclAnd)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<upsilon> X) \\<tau> = true \\<tau>\n     then if (\\<delta> X and X->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()) \\<tau> =\n             true \\<tau>\n          then SOME y. y \\<in> Rep_Set_base X \\<tau> else null \\<tau>\n     else \\<bottom>) =\n    (if (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau> = true \\<tau>\n     then if ((\\<lambda>_. (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>) and\n              (\\<lambda>_.\n                  \\<lambda>_. X \\<tau>->notEmpty\\<^sub>B\\<^sub>a\\<^sub>g()\n                   \\<tau>))\n              \\<tau> =\n             true \\<tau>\n          then SOME y. y \\<in> Rep_Set_base (\\<lambda>_. X \\<tau>) \\<tau>\n          else null \\<tau>\n     else \\<bottom>)", "by(simp only: cp_OclAnd[symmetric] cp_defined[symmetric] cp_valid[symmetric]\n              cp_OclNotEmpty[symmetric] Rep_Set_base_def)"], ["", "lemma cp_OclForall:\n\"(S->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)) \\<tau> = ((\\<lambda> _. S \\<tau>)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P (\\<lambda> _. x \\<tau>))) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclForall S P \\<tau> =\n    \\<lambda>_.\n       S \\<tau>->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P (\\<lambda>_. x \\<tau>))\n     \\<tau>", "by(auto simp add: OclForall_def cp_defined[symmetric] Rep_Set_base_def)"], ["", "(* first-order version !*)"], ["", "lemma cp_OclForall1 [simp,intro!]:\n\"cp S \\<Longrightarrow> cp (\\<lambda>X. ((S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp S \\<Longrightarrow> cp (\\<lambda>X. OclForall (S X) P)", "apply(simp add: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>X a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>X a b. OclForall (S X) P (a, b) = f (X (a, b)) (a, b)", "apply(erule exE, rule exI, intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f X a b.\n       \\<forall>X a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n       OclForall (S X) P (a, b) = ?f2 f (X (a, b)) (a, b)", "apply(erule_tac x=X in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f X a b.\n       \\<forall>a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n       OclForall (S X) P (a, b) = ?f2 f (X (a, b)) (a, b)", "by(subst cp_OclForall, simp)"], ["", "lemma (*cp_OclForall2 [simp,intro!]:*)\n\"cp (\\<lambda>X St x. P (\\<lambda>\\<tau>. x) X St) \\<Longrightarrow> cp S \\<Longrightarrow> cp (\\<lambda>X. (S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P x X)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp (\\<lambda>X St x. P (\\<lambda>\\<tau>. x) X St);\n     cp S\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X.\n                             S X->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P x X))", "apply(simp only: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<exists>f.\n                \\<forall>X \\<tau>.\n                   (\\<lambda>x. P (\\<lambda>\\<tau>. x) X \\<tau>) =\n                   f (X \\<tau>) \\<tau>;\n     \\<exists>f.\n        \\<forall>X \\<tau>. S X \\<tau> = f (X \\<tau>) \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>f.\n                         \\<forall>X \\<tau>.\n                            S X->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P x X)\n                             \\<tau> =\n                            f (X \\<tau>) \\<tau>", "oops"], ["", "lemma (*cp_OclForall:*)\n\"cp S \\<Longrightarrow>\n (\\<And> x. cp(P x)) \\<Longrightarrow>\n cp(\\<lambda>X. ((S X)->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x | P x X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp S; \\<And>x. cp (P x)\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X.\n                             S X->forAll\\<^sub>B\\<^sub>a\\<^sub>g(x|P x X))", "oops"], ["", "lemma cp_OclExists:\n\"(S->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)) \\<tau> = ((\\<lambda> _. S \\<tau>)->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P (\\<lambda> _. x \\<tau>))) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclExists S P \\<tau> =\n    \\<lambda>_.\n       S \\<tau>->exists\\<^sub>B\\<^sub>a\\<^sub>g(x|P (\\<lambda>_. x \\<tau>))\n     \\<tau>", "by(simp add: OclExists_def OclNot_def, subst cp_OclForall, simp)"], ["", "(* first-order version !*)"], ["", "lemma cp_OclExists1 [simp,intro!]:\n\"cp S \\<Longrightarrow> cp (\\<lambda>X. ((S X)->exists\\<^sub>B\\<^sub>a\\<^sub>g(x | P x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp S \\<Longrightarrow> cp (\\<lambda>X. OclExists (S X) P)", "apply(simp add: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<forall>X a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n    \\<exists>f.\n       \\<forall>X a b. OclExists (S X) P (a, b) = f (X (a, b)) (a, b)", "apply(erule exE, rule exI, intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f X a b.\n       \\<forall>X a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n       OclExists (S X) P (a, b) = ?f2 f (X (a, b)) (a, b)", "apply(erule_tac x=X in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f X a b.\n       \\<forall>a b. S X (a, b) = f (X (a, b)) (a, b) \\<Longrightarrow>\n       OclExists (S X) P (a, b) = ?f2 f (X (a, b)) (a, b)", "by(subst cp_OclExists,simp)"], ["", "lemma cp_OclIterate: \n     \"(X->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x)) \\<tau> =\n                ((\\<lambda> _. X \\<tau>)->iterate\\<^sub>B\\<^sub>a\\<^sub>g(a; x = A | P a x)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclIterate X A P \\<tau> = OclIterate (\\<lambda>_. X \\<tau>) A P \\<tau>", "by(simp add: OclIterate_def cp_defined[symmetric] Rep_Bag_base_def)"], ["", "lemma cp_OclSelect: \"(X->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau> =\n                ((\\<lambda> _. X \\<tau>)->select\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclSelect X P \\<tau> = OclSelect (\\<lambda>_. X \\<tau>) P \\<tau>", "by(simp add: OclSelect_def cp_defined[symmetric] Rep_Set_base_def)"], ["", "lemma cp_OclReject: \"(X->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau> = ((\\<lambda> _. X \\<tau>)->reject\\<^sub>B\\<^sub>a\\<^sub>g(a | P a)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclReject X P \\<tau> = OclReject (\\<lambda>_. X \\<tau>) P \\<tau>", "by(simp add: OclReject_def, subst cp_OclSelect, simp)"], ["", "lemmas cp_intro''\\<^sub>B\\<^sub>a\\<^sub>g[intro!,simp,code_unfold] =\n       cp_OclSize      [THEN allI[THEN allI[THEN cpI1], of \"OclSize\"]]\n       cp_OclIsEmpty   [THEN allI[THEN allI[THEN cpI1], of \"OclIsEmpty\"]]\n       cp_OclNotEmpty  [THEN allI[THEN allI[THEN cpI1], of \"OclNotEmpty\"]]\n       cp_OclANY       [THEN allI[THEN allI[THEN cpI1], of \"OclANY\"]]"], ["", "subsubsection\\<open>Const\\<close>"], ["", "lemma const_OclIncluding[simp,code_unfold] :\n assumes const_x : \"const x\"\n     and const_S : \"const S\"\n   shows  \"const (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)", "have A:\"\\<And>\\<tau> \\<tau>'. \\<not> (\\<tau> \\<Turnstile> \\<upsilon> x) \\<Longrightarrow> (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>) = (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<tau> |\\<noteq> \\<upsilon> x \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(simp add: foundation18)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       x \\<tau> = invalid \\<tau> \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(erule const_subst[OF const_x const_invalid],simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'. invalid \\<tau> = invalid \\<tau>'", "by(rule const_charn[OF const_invalid])"], ["proof (state)\nthis:\n  ?\\<tau> |\\<noteq> \\<upsilon> x \\<Longrightarrow>\n  S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) ?\\<tau> =\n  S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) ?\\<tau>'\n\ngoal (1 subgoal):\n 1. const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)", "have B: \"\\<And> \\<tau> \\<tau>'. \\<not> (\\<tau> \\<Turnstile> \\<delta> S) \\<Longrightarrow> (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>) = (S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<tau> |\\<noteq> \\<delta> S \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(simp add: foundation16', elim disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       S \\<tau> = invalid \\<tau> \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       S \\<tau> = null \\<tau> \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(erule const_subst[OF const_S const_invalid],simp_all)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'. invalid \\<tau> = invalid \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       S \\<tau> = null \\<tau> \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(rule const_charn[OF const_invalid])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       S \\<tau> = null \\<tau> \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(erule const_subst[OF const_S const_null],simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'. invalid \\<tau> = invalid \\<tau>'", "by(rule const_charn[OF const_invalid])"], ["proof (state)\nthis:\n  ?\\<tau> |\\<noteq> \\<delta> S \\<Longrightarrow>\n  S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) ?\\<tau> =\n  S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) ?\\<tau>'\n\ngoal (1 subgoal):\n 1. const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)", "apply(simp only: const_def,intro allI, rename_tac \\<tau> \\<tau>')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(case_tac \"\\<not> (\\<tau> \\<Turnstile> \\<upsilon> x)\", simp add: A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<not> \\<tau> |\\<noteq> \\<upsilon> x \\<Longrightarrow>\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n       S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(case_tac \"\\<not> (\\<tau> \\<Turnstile> \\<delta> S)\", simp_all add: B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        \\<tau> \\<Turnstile> \\<delta> S\\<rbrakk>\n       \\<Longrightarrow> S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n                         S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(frule_tac \\<tau>'1= \\<tau>' in  const_OclValid2[OF const_x, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        \\<tau> \\<Turnstile> \\<delta> S;\n        \\<tau>' \\<Turnstile> \\<upsilon> x\\<rbrakk>\n       \\<Longrightarrow> S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n                         S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(frule_tac \\<tau>'1= \\<tau>' in  const_OclValid1[OF const_S, THEN iffD1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        \\<tau> \\<Turnstile> \\<delta> S; \\<tau>' \\<Turnstile> \\<upsilon> x;\n        \\<tau>' \\<Turnstile> \\<delta> S\\<rbrakk>\n       \\<Longrightarrow> S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau> =\n                         S->including\\<^sub>B\\<^sub>a\\<^sub>g(x) \\<tau>'", "apply(simp add: OclIncluding_def OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<delta> S) \\<tau> = true \\<tau>;\n        (\\<upsilon> x) \\<tau>' = true \\<tau>';\n        (\\<delta> S) \\<tau>' = true \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S \\<tau>)\\<rceil>\\<rceil>\n      (x \\<tau> :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S \\<tau>)\\<rceil>\\<rceil>\n               (x \\<tau>)))\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S \\<tau>')\\<rceil>\\<rceil>\n      (x \\<tau>' :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S \\<tau>')\\<rceil>\\<rceil>\n               (x \\<tau>')))\\<rfloor>\\<rfloor>", "apply(subst (1 2) const_charn[OF const_x])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<delta> S) \\<tau> = true \\<tau>;\n        (\\<upsilon> x) \\<tau>' = true \\<tau>';\n        (\\<delta> S) \\<tau>' = true \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S \\<tau>)\\<rceil>\\<rceil>\n      (x (?\\<tau>'11 \\<tau> \\<tau>') :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S \\<tau>)\\<rceil>\\<rceil>\n               (x (?\\<tau>''12 \\<tau> \\<tau> \\<tau>'\n                    \\<tau>'))))\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S \\<tau>')\\<rceil>\\<rceil>\n      (x \\<tau>' :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S \\<tau>')\\<rceil>\\<rceil>\n               (x \\<tau>')))\\<rfloor>\\<rfloor>", "apply(subst (1 2) const_charn[OF const_S])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<delta> S) \\<tau> = true \\<tau>;\n        (\\<upsilon> x) \\<tau>' = true \\<tau>';\n        (\\<delta> S) \\<tau>' = true \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S (?\\<tau>'16 \\<tau> \\<tau>'))\\<rceil>\\<rceil>\n      (x (?\\<tau>'''17 \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>' \\<tau>') :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S (?\\<tau>''18 \\<tau> \\<tau> \\<tau>'\n                                    \\<tau>'))\\<rceil>\\<rceil>\n               (x (?\\<tau>''''19 \\<tau> \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>'\n                    \\<tau>' \\<tau>'))))\\<rfloor>\\<rfloor> =\n                         Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                          \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (S \\<tau>')\\<rceil>\\<rceil>\n      (x \\<tau>' :=\n         Suc (\\<lceil>\\<lceil>Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (S \\<tau>')\\<rceil>\\<rceil>\n               (x \\<tau>')))\\<rfloor>\\<rfloor>\nflex-flex pairs:\n  \\<lambda>\\<tau> \\<tau>'.\n     ?\\<tau>''''19 \\<tau> \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>' \\<tau>'\n      \\<tau>' \\<equiv>\\<^sup>?\n    \\<lambda>\\<tau> \\<tau>'.\n       ?\\<tau>'''15 \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>' \\<tau>'\n  \\<lambda>\\<tau> \\<tau>'.\n     ?\\<tau>'''17 \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>'\n      \\<tau>' \\<equiv>\\<^sup>?\n    \\<lambda>\\<tau> \\<tau>'. ?\\<tau>''14 \\<tau> \\<tau> \\<tau>' \\<tau>'\n  \\<lambda>\\<tau> \\<tau>'.\n     ?\\<tau>'''15 \\<tau> \\<tau> \\<tau> \\<tau>' \\<tau>'\n      \\<tau>' \\<equiv>\\<^sup>?\n    \\<lambda>\\<tau> \\<tau>'. ?\\<tau>''12 \\<tau> \\<tau> \\<tau>' \\<tau>'", "by simp"], ["proof (state)\nthis:\n  const S->including\\<^sub>B\\<^sub>a\\<^sub>g(x)\n\ngoal:\nNo subgoals!", "qed"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Test Statements\\<close>"], ["", "(*Assert   \"(\\<tau> \\<Turnstile> (Bag{\\<lambda>_. \\<lfloor>\\<lfloor>x\\<rfloor>\\<rfloor>} \\<doteq> Bag{\\<lambda>_. \\<lfloor>\\<lfloor>x\\<rfloor>\\<rfloor>}))\"\nAssert   \"(\\<tau> \\<Turnstile> (Bag{\\<lambda>_. \\<lfloor>x\\<rfloor>} \\<doteq> Bag{\\<lambda>_. \\<lfloor>x\\<rfloor>}))\"*)"], ["", "instantiation Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (equal)equal\nbegin"], ["", "definition \"HOL.equal k l \\<longleftrightarrow>  (k::('a::equal)Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) =  l\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Bag('a), equal_class)", "by standard (rule equal_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["", "end"], ["", "lemma equal_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_code [code]:\n  \"HOL.equal k (l::('a::{equal,null})Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<longleftrightarrow> Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e k = Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. equal_class.equal k l =\n    (Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e k =\n     Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e l)", "by (auto simp add: equal Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.Rep_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject)"], ["", "Assert   \"\\<tau> \\<Turnstile> (Bag{} \\<doteq> Bag{})\""], ["", "(*\nAssert   \"\\<tau> \\<Turnstile> not(Bag{\\<one>,\\<one>}      \\<triangleq> Bag{\\<one>})\" \nAssert   \"\\<tau> \\<Turnstile> (Bag{\\<one>,\\<two>}         \\<triangleq> Bag{\\<two>,\\<one>}\" \nAssert   \"\\<tau> \\<Turnstile> (Bag{\\<one>,null}      \\<triangleq> Bag{null,\\<one>}\" \nAssert   \"\\<tau> \\<Turnstile> (Bag{\\<one>,invalid,\\<two>} \\<triangleq> invalid)\"\nAssert   \"\\<tau> \\<Turnstile> (Bag{\\<one>,\\<two>}->including\\<^sub>B\\<^sub>a\\<^sub>g(null) \\<triangleq> Bag{\\<one>,\\<two>,null})\"\n*)\n\n(* > *)"], ["", "end"]]}