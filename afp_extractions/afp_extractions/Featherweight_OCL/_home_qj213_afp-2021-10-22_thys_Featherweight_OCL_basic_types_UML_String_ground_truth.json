{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/basic_types/UML_String.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma  \"\\<delta>(null::('\\<AA>)String) = false\"", "lemma  \"\\<upsilon>(null::('\\<AA>)String) = true\"", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<a> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<a> = true\"", "lemma OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g_not_commute: \"\\<exists>X Y. (X +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g Y) \\<noteq> (Y +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g X)\""], "translations": [["", "lemma  \"\\<delta>(null::('\\<AA>)String) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> null = false", "by simp"], ["", "lemma  \"\\<upsilon>(null::('\\<AA>)String) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> null = true", "by simp"], ["", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:defined_def true_def\n               bot_fun_def bot_option_def null_fun_def null_option_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:valid_def true_def\n               bot_fun_def bot_option_def)"], ["", "(* ecclectic proofs to make examples executable *)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<a> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<a> = true", "by(simp add:OclStringa_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<a> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<a> = true", "by(simp add:OclStringa_def)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>String Operations\\<close>"], ["", "subsubsection\\<open>Definition\\<close>"], ["", "text\\<open>Here is a common case of a built-in operation on built-in types.\nNote that the arguments must be both defined (non-null, non-bot).\\<close>"], ["", "text\\<open>Note that we can not follow the lexis of the OCL Standard for Isabelle\ntechnical reasons; these operators are heavily overloaded in the HOL library\nthat a further overloading would lead to heavy technical buzz in this\ndocument.\n\\<close>"], ["", "definition OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g ::\"('\\<AA>)String \\<Rightarrow> ('\\<AA>)String \\<Rightarrow> ('\\<AA>)String\" (infix \"+\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g\" 40)\nwhere \"x +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>concat [\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil>, \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>]\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g : profile_bin\\<^sub>d_\\<^sub>d \"(+\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>concat [\\<lceil>\\<lceil>x\\<rceil>\\<rceil>, \\<lceil>\\<lceil>y\\<rceil>\\<rceil>]\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d\n     (+\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>concat\n                            [\\<lceil>\\<lceil>x\\<rceil>\\<rceil>,\n                             \\<lceil>\\<lceil>y\\<rceil>\\<rceil>]\\<rfloor>\\<rfloor>)", "by unfold_locales (auto simp:OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g_def bot_option_def null_option_def)"], ["", "(* TODO : size(), concat, substring(s:string) toInteger, toReal, at(i:Integer), characters() etc. *)"], ["", "subsubsection\\<open>Basic Properties\\<close>"], ["", "lemma OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g_not_commute: \"\\<exists>X Y. (X +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g Y) \\<noteq> (Y +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>X Y.\n       (X +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g Y) \\<noteq>\n       (Y +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g X)", "apply(rule_tac x = \"\\<lambda>_. \\<lfloor>\\<lfloor>''b''\\<rfloor>\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Y.\n       ((\\<lambda>_.\n            \\<lfloor>\\<lfloor>''b''\\<rfloor>\\<rfloor>) +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g\n        Y) \\<noteq>\n       (Y +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g\n        (\\<lambda>_. \\<lfloor>\\<lfloor>''b''\\<rfloor>\\<rfloor>))", "apply(rule_tac x = \"\\<lambda>_. \\<lfloor>\\<lfloor>''a''\\<rfloor>\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_.\n         \\<lfloor>\\<lfloor>''b''\\<rfloor>\\<rfloor>) +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g\n     (\\<lambda>_. \\<lfloor>\\<lfloor>''a''\\<rfloor>\\<rfloor>)) \\<noteq>\n    ((\\<lambda>_.\n         \\<lfloor>\\<lfloor>''a''\\<rfloor>\\<rfloor>) +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g\n     (\\<lambda>_. \\<lfloor>\\<lfloor>''b''\\<rfloor>\\<rfloor>))", "apply(simp_all add:OclAdd\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<tau>. \\<lfloor>\\<lfloor>''ba''\\<rfloor>\\<rfloor>) \\<noteq>\n    (\\<lambda>\\<tau>. \\<lfloor>\\<lfloor>''ab''\\<rfloor>\\<rfloor>)", "by(auto, drule fun_cong, auto)"], ["", "subsection\\<open>Test Statements\\<close>"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "(*\nAssert \"\\<tau> \\<Turnstile> ( \\<nine> \\<le>\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<one>\\<zero> )\"\nAssert \"\\<tau> \\<Turnstile> (( \\<four> +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<four> ) \\<le>\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<one>\\<zero> )\"\nAssert \"\\<tau> |\\<noteq> (( \\<four> +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g ( \\<four> +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<four> )) <\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<one>\\<zero> )\"\nAssert \"\\<tau> \\<Turnstile> not (\\<upsilon> (null +\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g \\<one>)) \"\n*)"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "text\\<open>Elementary computations on String\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> \\<a> <> \\<b>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<b> <> \\<a>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<b> \\<doteq> \\<b>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> \\<a>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<delta> \\<a>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> (null::('\\<AA>)String)\""], ["", "Assert \"\\<tau> \\<Turnstile> (invalid \\<triangleq> invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<triangleq> null)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<a> \\<triangleq> \\<a>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<a> \\<triangleq> \\<b>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<triangleq> \\<b>)\""], ["", "Assert \"\\<tau> |\\<noteq> (null \\<triangleq> \\<b>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<doteq> (invalid::('\\<AA>)String))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid \\<doteq> (invalid::('\\<AA>)String))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> (invalid <> (invalid::('\\<AA>)String))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid <> (invalid::('\\<AA>)String))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)String) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)String) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (\\<b> \\<doteq> \\<b>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<b> <> \\<b>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<b> \\<doteq> \\<c>)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<b> <> \\<c>)\""], ["", "(*Assert \"\\<tau> |\\<noteq> (\\<zero> <\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g null)\"\nAssert \"\\<tau> |\\<noteq> (\\<delta> (\\<zero> <\\<^sub>s\\<^sub>t\\<^sub>r\\<^sub>i\\<^sub>n\\<^sub>g null))\"\n*)"], ["", "end"]]}