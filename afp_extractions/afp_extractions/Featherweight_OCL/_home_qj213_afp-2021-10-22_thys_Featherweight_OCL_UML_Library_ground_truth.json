{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_Library.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma Integer_subtype_of_Real: \n  assumes \"\\<tau> \\<Turnstile> \\<delta> X\"\n  shows   \"\\<tau> \\<Turnstile> X ->oclAsType\\<^sub>I\\<^sub>n\\<^sub>t(Real) ->oclAsType\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l(Integer) \\<triangleq> X\"", "lemma assumes \"\\<tau> \\<Turnstile> \\<delta> (S ->size\\<^sub>S\\<^sub>e\\<^sub>t())\" (* S is finite *)\n      shows \"OclAsBag\\<^sub>S\\<^sub>e\\<^sub>t S = (S->iterate\\<^sub>S\\<^sub>e\\<^sub>t(b; x = Bag{} | x ->including\\<^sub>B\\<^sub>a\\<^sub>g(b)))\"", "lemmas cp_intro'' [intro!,simp,code_unfold] =\n       cp_intro'\n     (*  cp_intro''\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r *)\n       cp_intro''\\<^sub>S\\<^sub>e\\<^sub>t\n       cp_intro''\\<^sub>S\\<^sub>e\\<^sub>q", "lemma syntax_test: \"Set{\\<two>,\\<one>} = (Set{}->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<one>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<two>))\"", "lemma semantic_test2:\nassumes H:\"(Set{\\<two>} \\<doteq> null) = (false::('\\<AA>)Boolean)\"\nshows   \"(\\<tau>::('\\<AA>)st) \\<Turnstile> (Set{Set{\\<two>},null}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null))\"", "lemma short_cut'[simp,code_unfold]: \"(\\<eight> \\<doteq> \\<six>) = false\"", "lemma short_cut''[simp,code_unfold]: \"(\\<two> \\<doteq> \\<one>) = false\"", "lemma short_cut'''[simp,code_unfold]: \"(\\<one> \\<doteq> \\<two>) = false\"", "lemma     \"const (Set{Set{\\<two>,null}, invalid})\"", "lemma     \"const (Sequence{Sequence{\\<two>,null}, invalid})\""], "translations": [["", "lemma Integer_subtype_of_Real: \n  assumes \"\\<tau> \\<Turnstile> \\<delta> X\"\n  shows   \"\\<tau> \\<Turnstile> X ->oclAsType\\<^sub>I\\<^sub>n\\<^sub>t(Real) ->oclAsType\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l(Integer) \\<triangleq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> X->oclAsType\\<^sub>I\\<^sub>n\\<^sub>t(Real)->oclAsType\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l(Integer) \\<triangleq>\n                  X", "apply(insert assms,  simp add: OclAsInteger\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def OclAsReal\\<^sub>I\\<^sub>n\\<^sub>t_def OclValid_def StrongEq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> X) \\<tau> = true \\<tau> \\<Longrightarrow>\n    ((\\<delta> (\\<lambda>\\<tau>.\n                   if (\\<delta> X) \\<tau> = true \\<tau>\n                   then \\<lfloor>\\<lfloor>real_of_int\n     \\<lceil>\\<lceil>X \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                   else invalid \\<tau>))\n      \\<tau> =\n     true \\<tau> \\<longrightarrow>\n     \\<lfloor>\\<lfloor>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>X\n                    \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                       X \\<tau>\\<rfloor>\\<rfloor> =\n     true \\<tau>) \\<and>\n    ((\\<delta> (\\<lambda>\\<tau>.\n                   if (\\<delta> X) \\<tau> = true \\<tau>\n                   then \\<lfloor>\\<lfloor>real_of_int\n     \\<lceil>\\<lceil>X \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                   else invalid \\<tau>))\n      \\<tau> \\<noteq>\n     true \\<tau> \\<longrightarrow>\n     \\<lfloor>\\<lfloor>invalid \\<tau> = X \\<tau>\\<rfloor>\\<rfloor> =\n     true \\<tau>)", "apply(subst (2 4) cp_defined, simp add: true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> X) \\<tau> =\n    \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Longrightarrow>\n    \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>X\n \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    X \\<tau>", "by (metis assms bot_option_def drop.elims foundation16 null_option_def)"], ["", "subsection\\<open>Definition: asPair\\<close>"], ["", "definition OclAsPair\\<^sub>S\\<^sub>e\\<^sub>q   :: \"[('\\<AA>,'\\<alpha>::null)Sequence]\\<Rightarrow>('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair\" (\"(_)->asPair\\<^sub>S\\<^sub>e\\<^sub>q'(')\")\nwhere     \"OclAsPair\\<^sub>S\\<^sub>e\\<^sub>q S = (if S->size\\<^sub>S\\<^sub>e\\<^sub>q() \\<doteq> \\<two>\n                            then Pair{S->at\\<^sub>S\\<^sub>e\\<^sub>q(\\<zero>),S->at\\<^sub>S\\<^sub>e\\<^sub>q(\\<one>)}\n                            else invalid\n                            endif)\""], ["", "definition OclAsPair\\<^sub>S\\<^sub>e\\<^sub>t   :: \"[('\\<AA>,'\\<alpha>::null)Set]\\<Rightarrow>('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair\" (\"(_)->asPair\\<^sub>S\\<^sub>e\\<^sub>t'(')\")\nwhere     \"OclAsPair\\<^sub>S\\<^sub>e\\<^sub>t S = (if S->size\\<^sub>S\\<^sub>e\\<^sub>t() \\<doteq> \\<two>\n                            then let v = S->any\\<^sub>S\\<^sub>e\\<^sub>t() in\n                                 Pair{v,S->excluding\\<^sub>S\\<^sub>e\\<^sub>t(v)->any\\<^sub>S\\<^sub>e\\<^sub>t()}\n                            else invalid\n                            endif)\""], ["", "definition OclAsPair\\<^sub>B\\<^sub>a\\<^sub>g   :: \"[('\\<AA>,'\\<alpha>::null)Bag]\\<Rightarrow>('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair\" (\"(_)->asPair\\<^sub>B\\<^sub>a\\<^sub>g'(')\")\nwhere     \"OclAsPair\\<^sub>B\\<^sub>a\\<^sub>g S = (if S->size\\<^sub>B\\<^sub>a\\<^sub>g() \\<doteq> \\<two>\n                            then let v = S->any\\<^sub>B\\<^sub>a\\<^sub>g() in\n                                 Pair{v,S->excluding\\<^sub>B\\<^sub>a\\<^sub>g(v)->any\\<^sub>B\\<^sub>a\\<^sub>g()}\n                            else invalid\n                            endif)\""], ["", "subsection\\<open>Definition: asSet\\<close>"], ["", "definition OclAsSet\\<^sub>S\\<^sub>e\\<^sub>q   :: \"[('\\<AA>,'\\<alpha>::null)Sequence]\\<Rightarrow>('\\<AA>,'\\<alpha>)Set\" (\"(_)->asSet\\<^sub>S\\<^sub>e\\<^sub>q'(')\")\nwhere     \"OclAsSet\\<^sub>S\\<^sub>e\\<^sub>q S = (S->iterate\\<^sub>S\\<^sub>e\\<^sub>q(b; x = Set{} | x ->including\\<^sub>S\\<^sub>e\\<^sub>t(b)))\""], ["", "definition OclAsSet\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r   :: \"[('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair]\\<Rightarrow>('\\<AA>,'\\<alpha>)Set\" (\"(_)->asSet\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r'(')\")\nwhere     \"OclAsSet\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r S = Set{S .First(), S .Second()}\""], ["", "definition OclAsSet\\<^sub>B\\<^sub>a\\<^sub>g   :: \"('\\<AA>,'\\<alpha>::null) Bag\\<Rightarrow>('\\<AA>,'\\<alpha>)Set\" (\"(_)->asSet\\<^sub>B\\<^sub>a\\<^sub>g'(')\")\nwhere     \"OclAsSet\\<^sub>B\\<^sub>a\\<^sub>g S =  (\\<lambda> \\<tau>. if (\\<delta> S) \\<tau> = true \\<tau> \n                                 then Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<lfloor>\\<lfloor> Rep_Set_base S \\<tau> \\<rfloor>\\<rfloor> \n                                 else if (\\<upsilon> S) \\<tau> = true \\<tau> then null \\<tau> \n                                                          else invalid \\<tau>)\""], ["", "subsection\\<open>Definition: asSequence\\<close>"], ["", "definition OclAsSeq\\<^sub>S\\<^sub>e\\<^sub>t   :: \"[('\\<AA>,'\\<alpha>::null)Set]\\<Rightarrow>('\\<AA>,'\\<alpha>)Sequence\" (\"(_)->asSequence\\<^sub>S\\<^sub>e\\<^sub>t'(')\")\nwhere     \"OclAsSeq\\<^sub>S\\<^sub>e\\<^sub>t S = (S->iterate\\<^sub>S\\<^sub>e\\<^sub>t(b; x = Sequence{} | x ->including\\<^sub>S\\<^sub>e\\<^sub>q(b)))\""], ["", "definition OclAsSeq\\<^sub>B\\<^sub>a\\<^sub>g   :: \"[('\\<AA>,'\\<alpha>::null)Bag]\\<Rightarrow>('\\<AA>,'\\<alpha>)Sequence\" (\"(_)->asSequence\\<^sub>B\\<^sub>a\\<^sub>g'(')\")\nwhere     \"OclAsSeq\\<^sub>B\\<^sub>a\\<^sub>g S = (S->iterate\\<^sub>B\\<^sub>a\\<^sub>g(b; x = Sequence{} | x ->including\\<^sub>S\\<^sub>e\\<^sub>q(b)))\""], ["", "definition OclAsSeq\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r   :: \"[('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair]\\<Rightarrow>('\\<AA>,'\\<alpha>)Sequence\" (\"(_)->asSequence\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r'(')\")\nwhere     \"OclAsSeq\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r S = Sequence{S .First(), S .Second()}\""], ["", "subsection\\<open>Definition: asBag\\<close>"], ["", "definition OclAsBag\\<^sub>S\\<^sub>e\\<^sub>q   :: \"[('\\<AA>,'\\<alpha>::null)Sequence]\\<Rightarrow>('\\<AA>,'\\<alpha>)Bag\" (\"(_)->asBag\\<^sub>S\\<^sub>e\\<^sub>q'(')\")\nwhere     \"OclAsBag\\<^sub>S\\<^sub>e\\<^sub>q S = (\\<lambda>\\<tau>. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lambda>s. if list_ex ((=) s) \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S \\<tau>)\\<rceil>\\<rceil> then 1 else 0\\<rfloor>\\<rfloor>)\""], ["", "definition OclAsBag\\<^sub>S\\<^sub>e\\<^sub>t   :: \"[('\\<AA>,'\\<alpha>::null)Set]\\<Rightarrow>('\\<AA>,'\\<alpha>)Bag\" (\"(_)->asBag\\<^sub>S\\<^sub>e\\<^sub>t'(')\")\nwhere     \"OclAsBag\\<^sub>S\\<^sub>e\\<^sub>t S = (\\<lambda>\\<tau>. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>\\<lambda>s. if s \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (S \\<tau>)\\<rceil>\\<rceil> then 1 else 0\\<rfloor>\\<rfloor>)\""], ["", "lemma assumes \"\\<tau> \\<Turnstile> \\<delta> (S ->size\\<^sub>S\\<^sub>e\\<^sub>t())\" (* S is finite *)\n      shows \"OclAsBag\\<^sub>S\\<^sub>e\\<^sub>t S = (S->iterate\\<^sub>S\\<^sub>e\\<^sub>t(b; x = Bag{} | x ->including\\<^sub>B\\<^sub>a\\<^sub>g(b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S->asBag\\<^sub>S\\<^sub>e\\<^sub>t() =\n    S ->iterate\\<^sub>S\\<^sub>e\\<^sub>t(b;x=Bag{} | x->including\\<^sub>B\\<^sub>a\\<^sub>g(b))", "oops"], ["", "definition OclAsBag\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r   :: \"[('\\<AA>,'\\<alpha>::null,'\\<alpha>::null) Pair]\\<Rightarrow>('\\<AA>,'\\<alpha>)Bag\" (\"(_)->asBag\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r'(')\")\nwhere     \"OclAsBag\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r S = Bag{S .First(), S .Second()}\""], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "subsection\\<open>Collection Types\\<close>"], ["", "lemmas cp_intro'' [intro!,simp,code_unfold] =\n       cp_intro'\n     (*  cp_intro''\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r *)\n       cp_intro''\\<^sub>S\\<^sub>e\\<^sub>t\n       cp_intro''\\<^sub>S\\<^sub>e\\<^sub>q"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Test Statements\\<close>"], ["", "lemma syntax_test: \"Set{\\<two>,\\<one>} = (Set{}->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<one>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<two>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Set{\\<two>, \\<one>} = Set{\\<two>, \\<one>}", "by (rule refl)"], ["", "text\\<open>Here is an example of a nested collection.\\<close>"], ["", "lemma semantic_test2:\nassumes H:\"(Set{\\<two>} \\<doteq> null) = (false::('\\<AA>)Boolean)\"\nshows   \"(\\<tau>::('\\<AA>)st) \\<Turnstile> (Set{Set{\\<two>},null}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> Set{Set{\\<two>},\n                      null}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null)", "by(simp add: OclIncludes_execute\\<^sub>S\\<^sub>e\\<^sub>t H)"], ["", "lemma short_cut'[simp,code_unfold]: \"(\\<eight> \\<doteq> \\<six>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<eight> \\<doteq> \\<six>) = false", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<eight> \\<doteq> \\<six>) x = false x", "apply(simp add: StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r StrongEq_def OclInt8_def OclInt6_def\n                 true_def false_def invalid_def bot_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma short_cut''[simp,code_unfold]: \"(\\<two> \\<doteq> \\<one>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<two> \\<doteq> \\<one>) = false", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<two> \\<doteq> \\<one>) x = false x", "apply(simp add: StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r StrongEq_def OclInt2_def OclInt1_def\n                 true_def false_def invalid_def bot_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma short_cut'''[simp,code_unfold]: \"(\\<one> \\<doteq> \\<two>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<one> \\<doteq> \\<two>) = false", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (\\<one> \\<doteq> \\<two>) x = false x", "apply(simp add: StrictRefEq\\<^sub>I\\<^sub>n\\<^sub>t\\<^sub>e\\<^sub>g\\<^sub>e\\<^sub>r StrongEq_def OclInt2_def OclInt1_def\n                 true_def false_def invalid_def bot_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "Assert   \"\\<tau> \\<Turnstile> (\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t \\<two>) and (\\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t \\<one>) \""], ["", "text\\<open>Elementary computations on Sets.\\<close>"], ["", "declare OclSelect_body_def [simp]"], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> \\<upsilon>(invalid::('\\<AA>,'\\<alpha>::null) Set))\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<upsilon>(null::('\\<AA>,'\\<alpha>::null) Set)\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> \\<delta>(null::('\\<AA>,'\\<alpha>::null) Set))\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<upsilon>(Set{})\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<upsilon>(Set{Set{\\<two>},null})\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<delta>(Set{Set{\\<two>},null})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{\\<two>,\\<one>}->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<one>))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{\\<two>}->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<one>)))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{\\<two>,\\<one>}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null)))\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{\\<two>,null}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null))\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{null,\\<two>}->includes\\<^sub>S\\<^sub>e\\<^sub>t(null))\""], ["", "Assert    \"\\<tau> \\<Turnstile> ((Set{})->forAll\\<^sub>S\\<^sub>e\\<^sub>t(z | \\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t z))\""], ["", "Assert    \"\\<tau> \\<Turnstile> ((Set{\\<two>,\\<one>})->forAll\\<^sub>S\\<^sub>e\\<^sub>t(z | \\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t z))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> ((Set{\\<two>,\\<one>})->exists\\<^sub>S\\<^sub>e\\<^sub>t(z | z <\\<^sub>i\\<^sub>n\\<^sub>t \\<zero> )))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (\\<delta>(Set{\\<two>,null})->forAll\\<^sub>S\\<^sub>e\\<^sub>t(z | \\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t z)))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> ((Set{\\<two>,null})->forAll\\<^sub>S\\<^sub>e\\<^sub>t(z | \\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t z)))\""], ["", "Assert    \"\\<tau> \\<Turnstile> ((Set{\\<two>,null})->exists\\<^sub>S\\<^sub>e\\<^sub>t(z | \\<zero> <\\<^sub>i\\<^sub>n\\<^sub>t z))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{null::'a Boolean} \\<doteq> Set{}))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{null::'a Integer} \\<doteq> Set{}))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{true} \\<doteq> Set{false}))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{true,true} \\<doteq> Set{false}))\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> (Set{\\<two>} \\<doteq> Set{\\<one>}))\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{\\<two>,null,\\<two>} \\<doteq> Set{null,\\<two>})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{\\<one>,null,\\<two>} <> Set{null,\\<two>})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{Set{\\<two>,null}} \\<doteq> Set{Set{null,\\<two>}})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{Set{\\<two>,null}} <> Set{Set{null,\\<two>},null})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{null}->select\\<^sub>S\\<^sub>e\\<^sub>t(x | not x) \\<doteq> Set{null})\""], ["", "Assert    \"\\<tau> \\<Turnstile> (Set{null}->reject\\<^sub>S\\<^sub>e\\<^sub>t(x | not x) \\<doteq> Set{null})\""], ["", "lemma     \"const (Set{Set{\\<two>,null}, invalid})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const Set{Set{\\<two>, null}, invalid}", "by(simp add: const_ss)"], ["", "text\\<open>Elementary computations on Sequences.\\<close>"], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> \\<upsilon>(invalid::('\\<AA>,'\\<alpha>::null) Sequence))\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<upsilon>(null::('\\<AA>,'\\<alpha>::null) Sequence)\""], ["", "Assert \"\\<not> (\\<tau> \\<Turnstile> \\<delta>(null::('\\<AA>,'\\<alpha>::null) Sequence))\""], ["", "Assert    \"\\<tau> \\<Turnstile> \\<upsilon>(Sequence{})\""], ["", "lemma     \"const (Sequence{Sequence{\\<two>,null}, invalid})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const Sequence{Sequence{\\<two>, null}, invalid}", "by(simp add: const_ss)"], ["", "end"]]}