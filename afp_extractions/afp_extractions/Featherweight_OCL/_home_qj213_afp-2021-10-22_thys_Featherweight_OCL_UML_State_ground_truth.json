{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_State.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_strict1[simp,code_unfold] :\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x invalid) = invalid\"", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_strict2[simp,code_unfold] :\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t invalid x) = invalid\"", "lemma cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y \\<tau>) = (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (\\<lambda>_. x \\<tau>) (\\<lambda>_. y \\<tau>)) \\<tau>\"", "lemmas cp0_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t= cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n             of \"StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\"]]", "lemmas cp_intro''[intro!,simp,code_unfold] =\n       cp_intro''\n       cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n             of \"StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\"]]", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_defargs:\n\"\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x (y::('\\<AA>,'a::{null,object})val))\\<Longrightarrow> (\\<tau> \\<Turnstile>(\\<upsilon> x)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> y))\"", "lemma defined_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_I:\n assumes val_x : \"\\<tau> \\<Turnstile> \\<upsilon> x\"\n assumes val_x : \"\\<tau> \\<Turnstile> \\<upsilon> y\"\n shows \"\\<tau> \\<Turnstile> \\<delta> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)\"", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def_homo :\n\"\\<delta>(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x (y::('\\<AA>,'a::{null,object})val)) = ((\\<upsilon> x) and (\\<upsilon> y))\"", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_sym :\nassumes x_val : \"\\<tau> \\<Turnstile> \\<upsilon> x\"\nshows \"\\<tau> \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x x\"", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq:\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> x)\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand x_present_pre: \"x \\<tau> \\<in> ran (heap(fst \\<tau>))\"\nand y_present_pre: \"y \\<tau> \\<in> ran (heap(fst \\<tau>))\"\nand x_present_post:\"x \\<tau> \\<in> ran (heap(snd \\<tau>))\"\nand y_present_post:\"y \\<tau> \\<in> ran (heap(snd \\<tau>))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\"", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq':\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> (x :: ('\\<AA>::object,'\\<alpha>::{null,object})val))\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                        H x \\<noteq> \\<bottom> \\<Longrightarrow> oid_of (H x) = oid_of x\"\nand xy_together: \"x \\<tau> \\<in> H ` ran (heap(fst \\<tau>)) \\<and> y \\<tau> \\<in> H ` ran (heap(fst \\<tau>)) \\<or>\n                  x \\<tau> \\<in> H ` ran (heap(snd \\<tau>)) \\<and> y \\<tau> \\<in> H ` ran (heap(snd \\<tau>))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\"", "lemma OclAllInstances_generic_defined: \"\\<tau> \\<Turnstile> \\<delta> (OclAllInstances_generic pre_post H)\"", "lemma OclAllInstances_generic_init_empty:\n assumes [simp]: \"\\<And>x. pre_post (x, x) = x\"\n shows \"\\<tau>\\<^sub>0 \\<Turnstile> OclAllInstances_generic pre_post H \\<triangleq> Set{}\"", "lemma represented_generic_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> ((OclAllInstances_generic pre_post (H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>))) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\"", "lemma represented_generic_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> ((OclAllInstances_generic pre_post (H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>))) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (OclAllInstances_generic pre_post H) \\<and> \\<tau> \\<Turnstile> \\<delta> x\"", "lemma represented_generic_objects_in_state:\nassumes A: \"\\<tau> \\<Turnstile> (OclAllInstances_generic pre_post H)->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state pre_post x H \\<tau>\"", "lemma state_update_vs_allInstances_generic_empty:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nshows   \"(mk \\<lparr>heap=Map.empty, assocs=A\\<rparr>) \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}\"", "lemma state_update_vs_allInstances_generic_including':\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((OclAllInstances_generic pre_post Type)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (mk \\<lparr>heap=\\<sigma>',assocs=A\\<rparr>)\"", "lemma state_update_vs_allInstances_generic_including:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((\\<lambda>_. (OclAllInstances_generic pre_post Type)\n                 (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\"", "lemma state_update_vs_allInstances_generic_noincluding':\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         (OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)\"", "theorem state_update_vs_allInstances_generic_ntc:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows \"(mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr> \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n       (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>            \\<Turnstile> P (OclAllInstances_generic pre_post Type))\"\n      (is \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> P ?\\<phi>)\")", "theorem state_update_vs_allInstances_generic_tc:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows \"(mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr> \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n       (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>            \\<Turnstile> P ((OclAllInstances_generic pre_post Type)\n                                                                ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>)))\"\n       (is \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> P ?\\<phi>')\")", "lemma OclAllInstances_at_post_defined: \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances())\"", "lemma \"\\<tau>\\<^sub>0 \\<Turnstile> H .allInstances() \\<triangleq> Set{}\"", "lemma represented_at_post_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\"", "lemma represented_at_post_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances()) \\<and> \\<tau> \\<Turnstile> \\<delta> x\"", "lemma\nassumes A: \"\\<tau> \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state snd x H \\<tau>\"", "lemma state_update_vs_allInstances_at_post_empty:\nshows   \"(\\<sigma>, \\<lparr>heap=Map.empty, assocs=A\\<rparr>) \\<Turnstile> Type .allInstances() \\<doteq> Set{}\"", "lemma state_update_vs_allInstances_at_post_including':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((Type .allInstances())->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<sigma>, \\<lparr>heap=\\<sigma>',assocs=A\\<rparr>)\"", "lemma state_update_vs_allInstances_at_post_including:\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((\\<lambda>_. (Type .allInstances())\n                 (\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\"", "lemma state_update_vs_allInstances_at_post_noincluding':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         (Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)\"", "theorem state_update_vs_allInstances_at_post_ntc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>) \\<Turnstile> (P(Type .allInstances()))) =\n         ((\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)            \\<Turnstile> (P(Type .allInstances())))\"", "theorem state_update_vs_allInstances_at_post_tc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>) \\<Turnstile> (P(Type .allInstances()))) =\n         ((\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)            \\<Turnstile> (P((Type .allInstances())\n                                                               ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>))))\"", "lemma OclAllInstances_at_pre_defined: \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances@pre())\"", "lemma \"\\<tau>\\<^sub>0 \\<Turnstile> H .allInstances@pre() \\<triangleq> Set{}\"", "lemma represented_at_pre_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances@pre()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\"", "lemma represented_at_pre_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances@pre()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances@pre()) \\<and> \\<tau> \\<Turnstile> \\<delta> x\"", "lemma\nassumes A: \"\\<tau> \\<Turnstile> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state fst x H \\<tau>\"", "lemma state_update_vs_allInstances_at_pre_empty:\nshows   \"(\\<lparr>heap=Map.empty, assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> Type .allInstances@pre() \\<doteq> Set{}\"", "lemma state_update_vs_allInstances_at_pre_including':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         ((Type .allInstances@pre())->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<lparr>heap=\\<sigma>',assocs=A\\<rparr>, \\<sigma>)\"", "lemma state_update_vs_allInstances_at_pre_including:\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         ((\\<lambda>_. (Type .allInstances@pre())\n                 (\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\"", "lemma state_update_vs_allInstances_at_pre_noincluding':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         (Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)\"", "theorem state_update_vs_allInstances_at_pre_ntc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> (P(Type .allInstances@pre()))) =\n         ((\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)            \\<Turnstile> (P(Type .allInstances@pre())))\"", "theorem state_update_vs_allInstances_at_pre_tc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> (P(Type .allInstances@pre()))) =\n         ((\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)            \\<Turnstile> (P((Type .allInstances@pre())\n                                                               ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>))))\"", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq'':\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> (x :: ('\\<AA>::object,'\\<alpha>::object option option)val))\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                        oid_of (H x) = oid_of x\"\nand xy_together: \"\\<tau> \\<Turnstile> ((H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)) or\n                       (H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\"", "lemma state_split : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                     \\<tau> \\<Turnstile> (X .oclIsNew()) \\<or> \\<tau> \\<Turnstile> (X .oclIsDeleted()) \\<or>\n                     \\<tau> \\<Turnstile> (X .oclIsMaintained()) \\<or> \\<tau> \\<Turnstile> (X .oclIsAbsent())\"", "lemma notNew_vs_others : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                         (\\<not> \\<tau> \\<Turnstile> (X .oclIsNew())) = (\\<tau> \\<Turnstile> (X .oclIsDeleted()) \\<or>\n                          \\<tau> \\<Turnstile> (X .oclIsMaintained()) \\<or> \\<tau> \\<Turnstile> (X .oclIsAbsent()))\"", "lemma \"invalid->oclIsModifiedOnly() = invalid\"", "lemma \"null->oclIsModifiedOnly() = invalid\"", "lemma\n assumes X_null : \"\\<tau> \\<Turnstile> X->includes\\<^sub>S\\<^sub>e\\<^sub>t(null)\"\n shows \"\\<tau> \\<Turnstile> X->oclIsModifiedOnly() \\<triangleq> invalid\"", "lemma cp_OclIsModifiedOnly : \"X->oclIsModifiedOnly() \\<tau> = (\\<lambda>_. X \\<tau>)->oclIsModifiedOnly() \\<tau>\"", "lemma all_oid_diff:\n assumes def_x : \"\\<tau> \\<Turnstile> \\<delta> x\"\n assumes def_X : \"\\<tau> \\<Turnstile> \\<delta> X\"\n assumes def_X' : \"\\<And>x. x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow> x \\<noteq> null\"\n\n defines \"P \\<equiv> (\\<lambda>a. not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x a))\"\n shows \"(\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| P a)) = (oid_of (x \\<tau>) \\<notin> oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>)\"", "theorem framing:\n      assumes modifiesclause:\"\\<tau> \\<Turnstile> (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))->oclIsModifiedOnly()\"\n      and oid_is_typerepr : \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x a))\"\n      shows \"\\<tau> \\<Turnstile> (x @pre P  \\<triangleq>  (x @post P))\"", "theorem framing':\n  assumes wff : \"WFF \\<tau>\"\n  assumes modifiesclause:\"\\<tau> \\<Turnstile> (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))->oclIsModifiedOnly()\"\n  and oid_is_typerepr : \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| not (x \\<triangleq> a))\"\n  and oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                          oid_of (H x) = oid_of x\"\n  and xy_together:\n  \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(y | (H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)) or\n                     (H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)))\"\n  shows \"\\<tau> \\<Turnstile> (x @pre P  \\<triangleq>  (x @post P))\"", "lemma pre_post_new: \"\\<tau> \\<Turnstile> (x .oclIsNew()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\"", "lemma pre_post_old: \"\\<tau> \\<Turnstile> (x .oclIsDeleted()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\"", "lemma pre_post_absent: \"\\<tau> \\<Turnstile> (x .oclIsAbsent()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\"", "lemma pre_post_maintained: \"(\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1) \\<or> \\<tau> \\<Turnstile> \\<upsilon>(x @post H2)) \\<Longrightarrow> \\<tau> \\<Turnstile> (x .oclIsMaintained())\"", "lemma pre_post_maintained':\n\"\\<tau> \\<Turnstile> (x .oclIsMaintained()) \\<Longrightarrow> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre (Some o H1)) \\<and> \\<tau> \\<Turnstile> \\<upsilon>(x @post (Some o H2)))\"", "lemma framing_same_state: \"(\\<sigma>, \\<sigma>) \\<Turnstile> (x @pre H  \\<triangleq>  (x @post H))\"", "lemma select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes \"list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l\"\n shows \"\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Sequence.OclIncluding Sequence{} l \\<tau>)\\<rceil>\\<rceil> = List.map (\\<lambda>f. f \\<tau>) l\"", "lemma select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes \"list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l\"\n shows \"\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Set.OclIncluding Set{} l \\<tau>)\\<rceil>\\<rceil> = set (List.map (\\<lambda>f. f \\<tau>) l)\"", "lemma fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes \"\\<tau> \\<Turnstile> \\<upsilon> (foldl UML_Sequence.OclIncluding Sequence{} (List.map (f p) s_set))\"\n shows \"list_all (\\<lambda>x. (\\<tau> \\<Turnstile> \\<upsilon> (f p x))) s_set\"", "lemma fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes \"\\<tau> \\<Turnstile> \\<upsilon> (foldl UML_Set.OclIncluding Set{} (List.map (f p) s_set))\"\n shows \"list_all (\\<lambda>x. (\\<tau> \\<Turnstile> \\<upsilon> (f p x))) s_set\"", "lemma select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"s_set \\<noteq> []\"", "lemma (*select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>t:*)\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"s_set \\<noteq> []\"", "lemma select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"s_set \\<noteq> []\"", "lemma select_object_any_exec0\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<triangleq> f (hd s_set))\"", "lemma select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"\\<exists>e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<triangleq> f e))\"", "lemma (*select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>t:*)\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"\\<exists> e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<triangleq> f e))\"", "lemma select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"\\<exists> e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<triangleq> f e))\""], "translations": [["", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_strict1[simp,code_unfold] :\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x invalid =\n    invalid", "by(rule ext, simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def true_def false_def)"], ["", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_strict2[simp,code_unfold] :\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t invalid x) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t invalid x =\n    invalid", "by(rule ext, simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def true_def false_def)"], ["", "lemma cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t:\n\"(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y \\<tau>) = (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t (\\<lambda>_. x \\<tau>) (\\<lambda>_. y \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y \\<tau> =\n    StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n     (\\<lambda>_. x \\<tau>) (\\<lambda>_. y \\<tau>) \\<tau>", "by(auto simp: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def cp_valid[symmetric])"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemmas cp0_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t= cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n             of \"StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\"]]"], ["", "lemmas cp_intro''[intro!,simp,code_unfold] =\n       cp_intro''\n       cp_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n             of \"StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\"]]"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Logic and Algebraic Layer on Object\\<close>"], ["", "subsubsection\\<open>Validity and Definedness Properties\\<close>"], ["", "text\\<open>We derive the usual laws on definedness for (generic) object equality:\\<close>"], ["", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_defargs:\n\"\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x (y::('\\<AA>,'a::{null,object})val))\\<Longrightarrow> (\\<tau> \\<Turnstile>(\\<upsilon> x)) \\<and> (\\<tau> \\<Turnstile>(\\<upsilon> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                   x y \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> x \\<and> \\<tau> \\<Turnstile> \\<upsilon> y", "by(simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def OclValid_def true_def invalid_def bot_option_def\n        split: bool.split_asm HOL.if_split_asm)"], ["", "lemma defined_StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_I:\n assumes val_x : \"\\<tau> \\<Turnstile> \\<upsilon> x\"\n assumes val_x : \"\\<tau> \\<Turnstile> \\<upsilon> y\"\n shows \"\\<tau> \\<Turnstile> \\<delta> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<delta> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                            x y", "apply(insert assms, simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (\\<delta> (\\<lambda>\\<tau>.\n                                    if (\\<upsilon> x) \\<tau> =\n true \\<tau> \\<and>\n (\\<upsilon> y) \\<tau> = true \\<tau>\n                                    then if x \\<tau> = null \\<or>\n      y \\<tau> = null\n   then \\<lfloor>\\<lfloor>x \\<tau> = null \\<and>\n                          y \\<tau> = null\\<rfloor>\\<rfloor>\n   else \\<lfloor>\\<lfloor>oid_of (x \\<tau>) =\n                          oid_of (y \\<tau>)\\<rfloor>\\<rfloor>\n                                    else invalid \\<tau>))\n                       \\<tau> =\n                      true \\<tau>", "by(subst cp_defined, simp add: true_def)"], ["", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def_homo :\n\"\\<delta>(StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x (y::('\\<AA>,'a::{null,object})val)) = ((\\<upsilon> x) and (\\<upsilon> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n              y =\n    (\\<upsilon> x and \\<upsilon> y)", "oops"], ["", "(* sorry *)"], ["", "subsubsection\\<open>Symmetry\\<close>"], ["", "lemma StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_sym :\nassumes x_val : \"\\<tau> \\<Turnstile> \\<upsilon> x\"\nshows \"\\<tau> \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                   x x", "by(simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def true_def OclValid_def\n             x_val[simplified OclValid_def])"], ["", "subsubsection\\<open>Behavior vs StrongEq\\<close>"], ["", "text\\<open>It remains to clarify the role of the state invariant\n$\\inv_\\sigma(\\sigma)$ mentioned above that states the condition that\nthere is a ``one-to-one'' correspondence between object\nrepresentations and $\\oid$'s: $\\forall \\mathit{oid} \\in \\dom\\ap\n\\sigma\\spot oid = \\HolOclOidOf\\ap \\drop{\\sigma(\\mathit{oid})}$.  This\ncondition is also mentioned in~\\cite[Annex A]{omg:ocl:2012} and goes\nback to \\citet{richters:precise:2002}; however, we state this\ncondition as an invariant on states rather than a global axiom. It\ncan, therefore, not be taken for granted that an $\\oid$ makes sense\nboth in pre- and post-states of OCL expressions.\n\\<close>"], ["", "text\\<open>We capture this invariant in the predicate WFF :\\<close>"], ["", "definition WFF :: \"('\\<AA>::object)st \\<Rightarrow> bool\"\nwhere \"WFF \\<tau> = ((\\<forall> x \\<in> ran(heap(fst \\<tau>)). \\<lceil>heap(fst \\<tau>) (oid_of x)\\<rceil> = x) \\<and>\n                (\\<forall> x \\<in> ran(heap(snd \\<tau>)). \\<lceil>heap(snd \\<tau>) (oid_of x)\\<rceil> = x))\""], ["", "text\\<open>It turns out that WFF is a key-concept for linking strict referential equality to\nlogical equality: in well-formed states (i.e. those states where the self (oid-of) field contains\nthe pointer to which the object is associated to in the state), referential equality coincides\nwith logical equality.\\<close>"], ["", "text\\<open>We turn now to the generic definition of referential equality on objects:\nEquality on objects in a state is reduced to equality on the\nreferences to these objects. As in HOL-OCL~\\cite{brucker.ea:hol-ocl:2008,brucker.ea:hol-ocl-book:2006},\nwe will store the reference of an object inside the object in a (ghost) field.\nBy establishing certain invariants (``consistent state''), it can\nbe assured that there is a ``one-to-one-correspondence'' of objects\nto their references---and therefore the definition below\nbehaves as we expect.\\<close>"], ["", "text\\<open>Generic Referential Equality enjoys the usual properties:\n(quasi) reflexivity, symmetry, transitivity, substitutivity for\ndefined values. For type-technical reasons, for each concrete\nobject type, the equality \\<open>\\<doteq>\\<close> is defined by generic referential\nequality.\\<close>"], ["", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq:\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> x)\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand x_present_pre: \"x \\<tau> \\<in> ran (heap(fst \\<tau>))\"\nand y_present_pre: \"y \\<tau> \\<in> ran (heap(fst \\<tau>))\"\nand x_present_post:\"x \\<tau> \\<in> ran (heap(snd \\<tau>))\"\nand y_present_post:\"y \\<tau> \\<in> ran (heap(snd \\<tau>))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(insert WFF valid_x valid_y x_present_pre y_present_pre x_present_post y_present_post)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>WFF \\<tau>; \\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y;\n     x \\<tau> \\<in> ran (heap (fst \\<tau>));\n     y \\<tau> \\<in> ran (heap (fst \\<tau>));\n     x \\<tau> \\<in> ran (heap (snd \\<tau>));\n     y \\<tau> \\<in> ran (heap (snd \\<tau>))\\<rbrakk>\n    \\<Longrightarrow> (\\<tau>\n                        \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nx y) =\n                      (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(auto simp: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def OclValid_def WFF_def StrongEq_def true_def Ball_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<upsilon> x) \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (\\<upsilon> y) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     x \\<tau> \\<in> ran (heap (fst \\<tau>));\n     y \\<tau> \\<in> ran (heap (fst \\<tau>));\n     x \\<tau> \\<in> ran (heap (snd \\<tau>));\n     y \\<tau> \\<in> ran (heap (snd \\<tau>));\n     \\<forall>x.\n        x \\<in> ran (heap (fst \\<tau>)) \\<longrightarrow>\n        \\<lceil>heap (fst \\<tau>) (oid_of x)\\<rceil> = x;\n     \\<forall>x.\n        x \\<in> ran (heap (snd \\<tau>)) \\<longrightarrow>\n        \\<lceil>heap (snd \\<tau>) (oid_of x)\\<rceil> = x;\n     x \\<tau> \\<noteq> null; y \\<tau> \\<noteq> null;\n     oid_of (x \\<tau>) = oid_of (y \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> x \\<tau> = y \\<tau>", "apply(erule_tac x=\"x \\<tau>\" in allE', simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq':\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> (x :: ('\\<AA>::object,'\\<alpha>::{null,object})val))\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                        H x \\<noteq> \\<bottom> \\<Longrightarrow> oid_of (H x) = oid_of x\"\nand xy_together: \"x \\<tau> \\<in> H ` ran (heap(fst \\<tau>)) \\<and> y \\<tau> \\<in> H ` ran (heap(fst \\<tau>)) \\<or>\n                  x \\<tau> \\<in> H ` ran (heap(snd \\<tau>)) \\<and> y \\<tau> \\<in> H ` ran (heap(snd \\<tau>))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(insert WFF valid_x valid_y xy_together)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>WFF \\<tau>; \\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y;\n     x \\<tau> \\<in> H ` ran (heap (fst \\<tau>)) \\<and>\n     y \\<tau> \\<in> H ` ran (heap (fst \\<tau>)) \\<or>\n     x \\<tau> \\<in> H ` ran (heap (snd \\<tau>)) \\<and>\n     y \\<tau> \\<in> H ` ran (heap (snd \\<tau>))\\<rbrakk>\n    \\<Longrightarrow> (\\<tau>\n                        \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nx y) =\n                      (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(simp add: WFF_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>x\\<in>ran (heap (fst \\<tau>)).\n                 \\<lceil>heap (fst \\<tau>) (oid_of x)\\<rceil> = x) \\<and>\n             (\\<forall>x\\<in>ran (heap (snd \\<tau>)).\n                 \\<lceil>heap (snd \\<tau>) (oid_of x)\\<rceil> = x);\n     \\<tau> \\<Turnstile> \\<upsilon> x; \\<tau> \\<Turnstile> \\<upsilon> y;\n     x \\<tau> \\<in> H ` ran (heap (fst \\<tau>)) \\<and>\n     y \\<tau> \\<in> H ` ran (heap (fst \\<tau>)) \\<or>\n     x \\<tau> \\<in> H ` ran (heap (snd \\<tau>)) \\<and>\n     y \\<tau> \\<in> H ` ran (heap (snd \\<tau>))\\<rbrakk>\n    \\<Longrightarrow> (\\<tau>\n                        \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\nx y) =\n                      (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(auto simp: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def OclValid_def WFF_def StrongEq_def true_def Ball_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa xaa.\n       \\<lbrakk>(\\<upsilon> x) \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> y) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x.\n           x \\<in> ran (heap (fst \\<tau>)) \\<longrightarrow>\n           \\<lceil>heap (fst \\<tau>) (oid_of x)\\<rceil> = x;\n        \\<forall>x.\n           x \\<in> ran (heap (snd \\<tau>)) \\<longrightarrow>\n           \\<lceil>heap (snd \\<tau>) (oid_of x)\\<rceil> = x;\n        x \\<tau> = H xa; xa \\<in> ran (heap (fst \\<tau>)); y \\<tau> = H xaa;\n        xaa \\<in> ran (heap (fst \\<tau>)); H xa \\<noteq> null;\n        H xaa \\<noteq> null; oid_of (H xa) = oid_of (H xaa)\\<rbrakk>\n       \\<Longrightarrow> H xa = H xaa\n 2. \\<And>xa xaa.\n       \\<lbrakk>(\\<upsilon> x) \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> y) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x.\n           x \\<in> ran (heap (fst \\<tau>)) \\<longrightarrow>\n           \\<lceil>heap (fst \\<tau>) (oid_of x)\\<rceil> = x;\n        \\<forall>x.\n           x \\<in> ran (heap (snd \\<tau>)) \\<longrightarrow>\n           \\<lceil>heap (snd \\<tau>) (oid_of x)\\<rceil> = x;\n        x \\<tau> = H xa; xa \\<in> ran (heap (snd \\<tau>)); y \\<tau> = H xaa;\n        xaa \\<in> ran (heap (snd \\<tau>)); H xa \\<noteq> null;\n        H xaa \\<noteq> null; oid_of (H xa) = oid_of (H xaa)\\<rbrakk>\n       \\<Longrightarrow> H xa = H xaa", "by (metis foundation18' oid_preserve valid_x valid_y)+"], ["", "text\\<open>So, if two object descriptions live in the same state (both pre or post), the referential\nequality on objects implies in a WFF state the logical equality.\\<close>"], ["", "section\\<open>Operations on Object\\<close>"], ["", "subsection\\<open>Initial States (for testing and code generation)\\<close>"], ["", "definition \\<tau>\\<^sub>0 :: \"('\\<AA>)st\"\nwhere     \"\\<tau>\\<^sub>0 \\<equiv> (\\<lparr>heap=Map.empty, assocs = Map.empty\\<rparr>,\n                 \\<lparr>heap=Map.empty, assocs = Map.empty\\<rparr>)\""], ["", "subsection\\<open>OclAllInstances\\<close>"], ["", "text\\<open>To denote OCL types occurring in OCL expressions syntactically---as, for example,\nas ``argument'' of \\inlineocl{oclAllInstances()}---we use the inverses of the injection functions into the object\nuniverses; we show that this is a sufficient ``characterization.''\\<close>"], ["", "definition OclAllInstances_generic :: \"(('\\<AA>::object) st \\<Rightarrow> '\\<AA> state) \\<Rightarrow> ('\\<AA>::object \\<rightharpoonup> '\\<alpha>) \\<Rightarrow>\n                                       ('\\<AA>, '\\<alpha> option option) Set\"\nwhere \"OclAllInstances_generic fst_snd H =\n                    (\\<lambda>\\<tau>. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor> Some ` ((H ` ran (heap (fst_snd \\<tau>))) - { None }) \\<rfloor>\\<rfloor>)\""], ["", "lemma OclAllInstances_generic_defined: \"\\<tau> \\<Turnstile> \\<delta> (OclAllInstances_generic pre_post H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic pre_post H", "apply(simp add: defined_def OclValid_def OclAllInstances_generic_def false_def true_def\n                 bot_fun_def bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_fun_def null_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (pre_post \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor> \\<noteq>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<and>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (pre_post \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor> \\<noteq>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (pre_post \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor> \\<noteq>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\n 2. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (pre_post \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor> \\<noteq>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>", "apply(rule notI, subst (asm) Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, simp,\n       (rule disjI2)+,\n       metis bot_option_def option.distinct(1),\n       (simp add: bot_option_def null_option_def)+)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAllInstances_generic_init_empty:\n assumes [simp]: \"\\<And>x. pre_post (x, x) = x\"\n shows \"\\<tau>\\<^sub>0 \\<Turnstile> OclAllInstances_generic pre_post H \\<triangleq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>0\n     \\<Turnstile> OclAllInstances_generic pre_post H \\<triangleq> Set{}", "by(simp add: StrongEq_def OclAllInstances_generic_def OclValid_def \\<tau>\\<^sub>0_def mtSet_def)"], ["", "lemma represented_generic_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> ((OclAllInstances_generic pre_post (H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>))) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "have B: \"\\<tau> \\<Turnstile> \\<delta> (OclAllInstances_generic pre_post H)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic pre_post H", "by (simp add: OclAllInstances_generic_defined)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic pre_post H\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "have C: \"\\<tau> \\<Turnstile> \\<upsilon> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> x", "by (metis OclIncludes.def_valid_then_def\n                   OclIncludes_valid_args_valid A foundation6)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<upsilon> x\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "apply(insert A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> OclAllInstances_generic pre_post\n                   H->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) \\<Longrightarrow>\n    \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "apply(simp add: StrongEq_def  OclValid_def\n                    OclNot_def null_def true_def OclIncludes_def B[simplified OclValid_def]\n                                                                 C[simplified OclValid_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (OclAllInstances_generic pre_post H\n                             \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow>\n    x \\<tau> \\<noteq> null \\<tau>", "apply(simp add:OclAllInstances_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             \\<lfloor>\\<lfloor>Some `\n         (H ` ran (heap (pre_post \\<tau>)) -\n          {None})\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> \\<Longrightarrow>\n    x \\<tau> \\<noteq> null \\<tau>", "apply(erule contrapos_pn)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau> = null \\<tau> \\<Longrightarrow>\n    x \\<tau>\n    \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                \\<lfloor>\\<lfloor>Some `\n            (H ` ran (heap (pre_post \\<tau>)) -\n             {None})\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>", "apply(subst Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse,\n          auto simp: null_fun_def null_option_def bot_option_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> not (x \\<triangleq> null)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma represented_generic_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> ((OclAllInstances_generic pre_post (H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>))) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (OclAllInstances_generic pre_post H) \\<and> \\<tau> \\<Turnstile> \\<delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic pre_post H \\<and>\n    \\<tau> \\<Turnstile> \\<delta> x", "by (metis OclAllInstances_generic_defined\n          A[THEN represented_generic_objects_nonnull] OclIncludes.defined_args_valid\n          A foundation16' foundation18 foundation24 foundation6)"], ["", "text\\<open>One way to establish the actual presence of an object representation in a state is:\\<close>"], ["", "definition \"is_represented_in_state fst_snd x H \\<tau> = (x \\<tau> \\<in> (Some o H) ` ran (heap (fst_snd \\<tau>)))\""], ["", "lemma represented_generic_objects_in_state:\nassumes A: \"\\<tau> \\<Turnstile> (OclAllInstances_generic pre_post H)->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state pre_post x H \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "have B: \"(\\<delta> (OclAllInstances_generic pre_post H)) \\<tau> = true \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> OclAllInstances_generic pre_post H) \\<tau> = true \\<tau>", "by(simp add: OclValid_def[symmetric] OclAllInstances_generic_defined)"], ["proof (state)\nthis:\n  (\\<delta> OclAllInstances_generic pre_post H) \\<tau> = true \\<tau>\n\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "have C: \"(\\<upsilon> x) \\<tau> = true \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> x) \\<tau> = true \\<tau>", "by (metis OclValid_def UML_Set.OclIncludes_def assms bot_option_def option.distinct(1) true_def)"], ["proof (state)\nthis:\n  (\\<upsilon> x) \\<tau> = true \\<tau>\n\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "have F: \"Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (pre_post \\<tau>)) - {None})\\<rfloor>\\<rfloor>) =\n            \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (pre_post \\<tau>)) - {None})\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       \\<lfloor>\\<lfloor>Some `\n                         (H ` ran (heap (pre_post \\<tau>)) -\n                          {None})\\<rfloor>\\<rfloor>) =\n    \\<lfloor>\\<lfloor>Some `\n                      (H ` ran (heap (pre_post \\<tau>)) -\n                       {None})\\<rfloor>\\<rfloor>", "by(subst Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse,simp_all add: bot_option_def)"], ["proof (state)\nthis:\n  Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (pre_post \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor>) =\n  \\<lfloor>\\<lfloor>Some `\n                    (H ` ran (heap (pre_post \\<tau>)) -\n                     {None})\\<rfloor>\\<rfloor>\n\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_represented_in_state pre_post x H \\<tau>", "apply(insert A)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> OclAllInstances_generic pre_post\n                   H->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) \\<Longrightarrow>\n    is_represented_in_state pre_post x H \\<tau>", "apply(simp add: is_represented_in_state_def OclIncludes_def OclValid_def ran_def B C image_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (OclAllInstances_generic pre_post H\n                             \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>a. heap (pre_post \\<tau>) a = \\<lfloor>xa\\<rfloor>) \\<and>\n       x \\<tau> = \\<lfloor>H xa\\<rfloor>", "apply(simp add: OclAllInstances_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             \\<lfloor>\\<lfloor>Some `\n         (H ` ran (heap (pre_post \\<tau>)) -\n          {None})\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>a. heap (pre_post \\<tau>) a = \\<lfloor>xa\\<rfloor>) \\<and>\n       x \\<tau> = \\<lfloor>H xa\\<rfloor>", "apply(simp add: F)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> Some `\n          (H ` ran (heap (pre_post \\<tau>)) - {None}) \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>a. heap (pre_post \\<tau>) a = \\<lfloor>xa\\<rfloor>) \\<and>\n       x \\<tau> = \\<lfloor>H xa\\<rfloor>", "apply(simp add: ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau>\n    \\<in> Some `\n          (H `\n           {b. \\<exists>a. heap (pre_post \\<tau>) a = \\<lfloor>b\\<rfloor>} -\n           {None}) \\<Longrightarrow>\n    \\<exists>xa.\n       (\\<exists>a. heap (pre_post \\<tau>) a = \\<lfloor>xa\\<rfloor>) \\<and>\n       x \\<tau> = \\<lfloor>H xa\\<rfloor>", "by(fastforce)"], ["proof (state)\nthis:\n  is_represented_in_state pre_post x H \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_update_vs_allInstances_generic_empty:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nshows   \"(mk \\<lparr>heap=Map.empty, assocs=A\\<rparr>) \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>\n     \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>\n     \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}", "have state_update_vs_allInstances_empty:\n  \"(OclAllInstances_generic pre_post Type) (mk \\<lparr>heap=Map.empty, assocs=A\\<rparr>) =\n   Set{} (mk \\<lparr>heap=Map.empty, assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n    Set{} (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>)", "by(simp add: OclAllInstances_generic_def mtSet_def)"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n  Set{} (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>\n     \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>\n     \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}", "apply(simp only: OclValid_def, subst StrictRefEq\\<^sub>S\\<^sub>e\\<^sub>t.cp0,\n        simp only: state_update_vs_allInstances_empty StrictRefEq\\<^sub>S\\<^sub>e\\<^sub>t.refl_ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<upsilon> (\\<lambda>_.\n                       Set{}\n                        (mk \\<lparr>heap = Map.empty,\n                               assocs =\n                                 A\\<rparr>)) then true else invalid endif)\n     (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n    true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>)", "apply(simp add: OclIf_def valid_def mtSet_def defined_def\n                  bot_fun_def null_fun_def null_option_def bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n     \\<bottom> \\<longrightarrow>\n     false (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<noteq>\n     \\<bottom> \\<longrightarrow>\n     invalid (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n     \\<bottom>) \\<and>\n    (true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n     \\<lfloor>\\<bottom>\\<rfloor> \\<longrightarrow>\n     false (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<noteq>\n     \\<lfloor>\\<bottom>\\<rfloor> \\<longrightarrow>\n     invalid (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n     \\<lfloor>\\<bottom>\\<rfloor>) \\<and>\n    (true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<noteq>\n     \\<bottom> \\<and>\n     true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<noteq>\n     \\<lfloor>\\<bottom>\\<rfloor> \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>{}\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<longrightarrow>\n     false (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) \\<longrightarrow>\n     invalid (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>) =\n     true (mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>))", "by(subst Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject, (simp add: bot_option_def true_def)+)"], ["proof (state)\nthis:\n  mk \\<lparr>heap = Map.empty, assocs = A\\<rparr>\n   \\<Turnstile> OclAllInstances_generic pre_post Type \\<doteq> Set{}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Here comes a couple of operational rules that allow to infer the value\nof \\inlineisar+oclAllInstances+ from the context $\\tau$. These rules are a special-case\nin the sense that they are the only rules that relate statements with \\emph{different}\n$\\tau$'s. For that reason, new concepts like ``constant contexts P'' are necessary\n(for which we do not elaborate an own theory for reasons of space limitations;\n in examples, we will prove resulting constraints straight forward by hand).\\<close>"], ["", "lemma state_update_vs_allInstances_generic_including':\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((OclAllInstances_generic pre_post Type)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (mk \\<lparr>heap=\\<sigma>',assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "have drop_none : \"\\<And>x. x \\<noteq> None \\<Longrightarrow> \\<lfloor>\\<lceil>x\\<rceil>\\<rfloor> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> None \\<Longrightarrow>\n       \\<lfloor>\\<lceil>x\\<rceil>\\<rfloor> = x", "by(case_tac x, simp+)"], ["proof (state)\nthis:\n  ?x \\<noteq> None \\<Longrightarrow>\n  \\<lfloor>\\<lceil>?x\\<rceil>\\<rfloor> = ?x\n\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "have insert_diff : \"\\<And>x S. insert \\<lfloor>x\\<rfloor> (S - {None}) = (insert \\<lfloor>x\\<rfloor> S) - {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S.\n       insert \\<lfloor>x\\<rfloor> (S - {None}) =\n       insert \\<lfloor>x\\<rfloor> S - {None}", "by (metis insert_Diff_if option.distinct(1) singletonE)"], ["proof (state)\nthis:\n  insert \\<lfloor>?x1\\<rfloor> (?S1 - {None}) =\n  insert \\<lfloor>?x1\\<rfloor> ?S1 - {None}\n\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "apply(simp add: UML_Set.OclIncluding_def OclAllInstances_generic_defined[simplified OclValid_def],\n        simp add: OclAllInstances_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (Type ` ran (\\<sigma>'(oid \\<mapsto> Object)) -\n                        {None})\\<rfloor>\\<rfloor> =\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>insert\n                        \\<lfloor>\\<lfloor>\\<lceil>Type\n             Object\\<rceil>\\<rfloor>\\<rfloor>\n                        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (Type ` ran \\<sigma>' -\n                        {None})\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>", "apply(subst Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp add: bot_option_def, simp add: comp_def,\n        subst image_insert[symmetric],\n        subst drop_none, simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (Type ` ran (\\<sigma>'(oid \\<mapsto> Object)) -\n                        {None})\\<rfloor>\\<rfloor> =\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       insert (Type Object)\n                        (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor>", "apply(case_tac \"Type Object\", simp add: assms, simp only:,\n        subst insert_diff, drule sym, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lfloor>a\\<rfloor> = Type Object \\<Longrightarrow>\n       Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>Some `\n                          (Type ` ran (\\<sigma>'(oid \\<mapsto> Object)) -\n                           {None})\\<rfloor>\\<rfloor> =\n       Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        \\<lfloor>\\<lfloor>Some `\n                          (insert (Type Object) (Type ` ran \\<sigma>') -\n                           {None})\\<rfloor>\\<rfloor>", "apply(subgoal_tac \"ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lfloor>a\\<rfloor> = Type Object \\<Longrightarrow>\n       ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')", "apply(case_tac \"\\<not> (\\<exists>x. \\<sigma>' oid = Some x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<nexists>x. \\<sigma>' oid = \\<lfloor>x\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')\n 2. \\<And>a.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<not> (\\<nexists>x. \\<sigma>' oid = \\<lfloor>x\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(rule ran_map_upd, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<not> (\\<nexists>x. \\<sigma>' oid = \\<lfloor>x\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(simp, erule exE, frule assms, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(subgoal_tac \"Object \\<in> ran \\<sigma>'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')\n 2. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object\\<rbrakk>\n       \\<Longrightarrow> Object \\<in> ran \\<sigma>'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object\\<rbrakk>\n       \\<Longrightarrow> Object \\<in> ran \\<sigma>'\n 2. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(rule ranI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a y.\n       \\<lbrakk>\\<lfloor>a\\<rfloor> = Type Object;\n        \\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "by(subst insert_absorb, simp, metis fun_upd_apply)"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post\n   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma state_update_vs_allInstances_generic_including:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((\\<lambda>_. (OclAllInstances_generic pre_post Type)\n                 (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    \\<lambda>_.\n       OclAllInstances_generic pre_post Type\n        (mk \\<lparr>heap = \\<sigma>',\n               assocs =\n                 A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                            \\<lfloor>\\<lfloor>\\<lceil>Type\n                 Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)", "apply(subst state_update_vs_allInstances_generic_including', (simp add: assms)+,\n       subst UML_Set.OclIncluding.cp0,\n       simp add: UML_Set.OclIncluding_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<delta> (\\<lambda>_.\n                   OclAllInstances_generic pre_post Type\n                    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n     true\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) \\<longrightarrow>\n     (\\<delta> (\\<lambda>_.\n                   OclAllInstances_generic pre_post Type\n                    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>\n                         \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs = A\\<rparr>))\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n     invalid\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>)) \\<and>\n    ((\\<delta> (\\<lambda>_.\n                   OclAllInstances_generic pre_post Type\n                    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) \\<longrightarrow>\n     ((\\<delta> (\\<lambda>_.\n                    OclAllInstances_generic pre_post Type\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n              assocs = A\\<rparr>) =\n      true\n       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n              assocs = A\\<rparr>) \\<longrightarrow>\n      invalid (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n      Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       \\<lfloor>\\<lfloor>insert\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>\n                          \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (OclAllInstances_generic pre_post Type\n       (mk \\<lparr>heap = \\<sigma>',\n              assocs = A\\<rparr>))\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>) \\<and>\n     ((\\<delta> (\\<lambda>_.\n                    OclAllInstances_generic pre_post Type\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n              assocs = A\\<rparr>) \\<noteq>\n      true\n       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n              assocs = A\\<rparr>) \\<longrightarrow>\n      invalid (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n      invalid\n       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n              assocs = A\\<rparr>)))", "apply(subst (1 3) cp_defined[symmetric],\n       simp add: OclAllInstances_generic_defined[simplified OclValid_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> (\\<lambda>_.\n                  OclAllInstances_generic pre_post Type\n                   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)))\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) \\<noteq>\n    true\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) \\<longrightarrow>\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>insert\n                        \\<lfloor>\\<lfloor>\\<lceil>Type\n             Object\\<rceil>\\<rfloor>\\<rfloor>\n                        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>',\n            assocs = A\\<rparr>))\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    invalid\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)", "apply(simp add: defined_def OclValid_def OclAllInstances_generic_def invalid_def\n                 bot_fun_def null_fun_def bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>Some `\n                        (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None \\<longrightarrow>\n     false\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>\n                         \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      None)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None) \\<and>\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>Some `\n                        (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>None\\<rfloor> \\<longrightarrow>\n     false\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>\n                         \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>None\\<rfloor>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None)", "apply(subst (1 3) Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lfloor>\\<lfloor>Some `\n                      (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor>\n    \\<in> {X. X = \\<bottom> \\<or>\n              X = null \\<or>\n              (\\<forall>x\\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n                  x \\<noteq> \\<bottom>)}\n 2. \\<lfloor>None\\<rfloor>\n    \\<in> {X. X = \\<bottom> \\<or>\n              X = null \\<or>\n              (\\<forall>x\\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n                  x \\<noteq> \\<bottom>)}\n 3. None\n    \\<in> {X. X = \\<bottom> \\<or>\n              X = null \\<or>\n              (\\<forall>x\\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n                  x \\<noteq> \\<bottom>)}\n 4. (\\<lfloor>\\<lfloor>Some `\n                       (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor> =\n     None \\<longrightarrow>\n     false\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>\n                         \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      None)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None) \\<and>\n    (\\<lfloor>\\<lfloor>Some `\n                       (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor> =\n     \\<lfloor>None\\<rfloor> \\<longrightarrow>\n     false\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<noteq>\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) \\<longrightarrow>\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>\n                         \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>None\\<rfloor>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n     Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None)", "by(simp add: bot_option_def null_option_def)+"], ["", "lemma state_update_vs_allInstances_generic_noincluding':\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         (OclAllInstances_generic pre_post Type)\n         (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "have drop_none : \"\\<And>x. x \\<noteq> None \\<Longrightarrow> \\<lfloor>\\<lceil>x\\<rceil>\\<rfloor> = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<noteq> None \\<Longrightarrow>\n       \\<lfloor>\\<lceil>x\\<rceil>\\<rfloor> = x", "by(case_tac x, simp+)"], ["proof (state)\nthis:\n  ?x \\<noteq> None \\<Longrightarrow>\n  \\<lfloor>\\<lceil>?x\\<rceil>\\<rfloor> = ?x\n\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "have insert_diff : \"\\<And>x S. insert \\<lfloor>x\\<rfloor> (S - {None}) = (insert \\<lfloor>x\\<rfloor> S) - {None}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x S.\n       insert \\<lfloor>x\\<rfloor> (S - {None}) =\n       insert \\<lfloor>x\\<rfloor> S - {None}", "by (metis insert_Diff_if option.distinct(1) singletonE)"], ["proof (state)\nthis:\n  insert \\<lfloor>?x1\\<rfloor> (?S1 - {None}) =\n  insert \\<lfloor>?x1\\<rfloor> ?S1 - {None}\n\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "apply(simp add: OclIncluding_def OclAllInstances_generic_defined[simplified OclValid_def]\n                  OclAllInstances_generic_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (Type ` ran (\\<sigma>'(oid \\<mapsto> Object)) -\n                        {None})\\<rfloor>\\<rfloor> =\n    Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (Type ` ran \\<sigma>' - {None})\\<rfloor>\\<rfloor>", "apply(subgoal_tac \"ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')\", simp add: assms)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')", "apply(case_tac \"\\<not> (\\<exists>x. \\<sigma>' oid = Some x)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<nexists>x. \\<sigma>' oid = \\<lfloor>x\\<rfloor> \\<Longrightarrow>\n    ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')\n 2. \\<not> (\\<nexists>x.\n               \\<sigma>' oid = \\<lfloor>x\\<rfloor>) \\<Longrightarrow>\n    ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')", "apply(rule ran_map_upd, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>x.\n               \\<sigma>' oid = \\<lfloor>x\\<rfloor>) \\<Longrightarrow>\n    ran (\\<sigma>'(oid \\<mapsto> Object)) = insert Object (ran \\<sigma>')", "apply(simp, erule exE, frule assms, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>;\n        y = Object\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(subgoal_tac \"Object \\<in> ran \\<sigma>'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')\n 2. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>;\n        y = Object\\<rbrakk>\n       \\<Longrightarrow> Object \\<in> ran \\<sigma>'", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>;\n        y = Object\\<rbrakk>\n       \\<Longrightarrow> Object \\<in> ran \\<sigma>'\n 2. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(rule ranI, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         insert Object (ran \\<sigma>')", "apply(subst insert_absorb, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       \\<lbrakk>\\<sigma>' oid = \\<lfloor>Object\\<rfloor>; y = Object;\n        Object \\<in> ran \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> ran (\\<sigma>'(oid \\<mapsto> Object)) =\n                         ran \\<sigma>'", "by (metis fun_upd_apply)"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem state_update_vs_allInstances_generic_ntc:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows \"(mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr> \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n       (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>            \\<Turnstile> P (OclAllInstances_generic pre_post Type))\"\n      (is \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> P ?\\<phi>)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "have P_cp  : \"\\<And>x \\<tau>. P x \\<tau> = P (\\<lambda>_. x \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<tau>. P x \\<tau> = P (\\<lambda>_. x \\<tau>) \\<tau>", "by (metis (full_types) cp_ctxt cp_def)"], ["proof (state)\nthis:\n  P ?x ?\\<tau> = P (\\<lambda>_. ?x ?\\<tau>) ?\\<tau>\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "have A     : \"const (P (\\<lambda>_. ?\\<phi> ?\\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const\n     (P (\\<lambda>_.\n            OclAllInstances_generic pre_post Type\n             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                    assocs = A\\<rparr>)))", "by(simp add: const_ctxt const_ss)"], ["proof (state)\nthis:\n  const\n   (P (\\<lambda>_.\n          OclAllInstances_generic pre_post Type\n           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                  assocs = A\\<rparr>)))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "have       \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau> \\<Turnstile> \\<lambda>_. P ?\\<phi> ?\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (OclAllInstances_generic pre_post Type)\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>))", "by(subst foundation23, rule refl)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "also"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "have  \"... = (?\\<tau> \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (OclAllInstances_generic pre_post Type)\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>))", "by(subst P_cp, rule refl)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "also"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "have  \"... = (?\\<tau>' \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P (\\<lambda>_.\n           OclAllInstances_generic pre_post Type\n            (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                   assocs = A\\<rparr>))\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) =\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>)) =\n    (P (\\<lambda>_.\n           OclAllInstances_generic pre_post Type\n            (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                   assocs = A\\<rparr>))\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n     true (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "by(subst A[simplified const_def], subst const_true[simplified const_def], simp)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "finally"], ["proof (chain)\npicking this:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "have X: \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>')\""], ["proof (prove)\nusing this:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "apply(subst X)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "apply(subst foundation23[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (\\<lambda>_.\n                         OclAllInstances_generic pre_post Type\n                          (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n  Object),\n                                 assocs = A\\<rparr>))) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type))", "apply(rule StrongEq_L_subst3[OF cp_ctxt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n     \\<Turnstile> (\\<lambda>_.\n                      OclAllInstances_generic pre_post Type\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) \\<triangleq>\n                  OclAllInstances_generic pre_post Type", "apply(simp add: OclValid_def StrongEq_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "apply(rule state_update_vs_allInstances_generic_noincluding')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. pre_post (mk a) = a\n 2. \\<And>x.\n       \\<sigma>' oid = \\<lfloor>x\\<rfloor> \\<Longrightarrow> x = Object\n 3. Type Object = None", "by(insert oid_def, auto simp: non_type_conform)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem state_update_vs_allInstances_generic_tc:\nassumes [simp]: \"\\<And>a. pre_post (mk a) = a\"\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows \"(mk \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr> \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n       (mk \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>            \\<Turnstile> P ((OclAllInstances_generic pre_post Type)\n                                                                ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>)))\"\n       (is \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> P ?\\<phi>')\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have P_cp  : \"\\<And>x \\<tau>. P x \\<tau> = P (\\<lambda>_. x \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x \\<tau>. P x \\<tau> = P (\\<lambda>_. x \\<tau>) \\<tau>", "by (metis (full_types) cp_ctxt cp_def)"], ["proof (state)\nthis:\n  P ?x ?\\<tau> = P (\\<lambda>_. ?x ?\\<tau>) ?\\<tau>\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have A     : \"const (P (\\<lambda>_. ?\\<phi> ?\\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const\n     (P (\\<lambda>_.\n            OclAllInstances_generic pre_post Type\n             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                    assocs = A\\<rparr>)))", "by(simp add: const_ctxt const_ss)"], ["proof (state)\nthis:\n  const\n   (P (\\<lambda>_.\n          OclAllInstances_generic pre_post Type\n           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                  assocs = A\\<rparr>)))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have       \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau> \\<Turnstile> \\<lambda>_. P ?\\<phi> ?\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (OclAllInstances_generic pre_post Type)\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>))", "by(subst foundation23, rule refl)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "also"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have  \"... = (?\\<tau> \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (OclAllInstances_generic pre_post Type)\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>))", "by(subst P_cp, rule refl)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "also"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (OclAllInstances_generic pre_post Type)\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have  \"... = (?\\<tau>' \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (P (\\<lambda>_.\n           OclAllInstances_generic pre_post Type\n            (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                   assocs = A\\<rparr>))\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>) =\n     true\n      (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n             assocs = A\\<rparr>)) =\n    (P (\\<lambda>_.\n           OclAllInstances_generic pre_post Type\n            (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                   assocs = A\\<rparr>))\n      (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n     true (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "by(subst A[simplified const_def], subst const_true[simplified const_def], simp)"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                            assocs = A\\<rparr>)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "finally"], ["proof (chain)\npicking this:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "have X: \"(?\\<tau> \\<Turnstile> P ?\\<phi>) = (?\\<tau>' \\<Turnstile> \\<lambda>_. P (\\<lambda>_. ?\\<phi> ?\\<tau>)  ?\\<tau>')\""], ["proof (prove)\nusing this:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))", "by simp"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> \\<lambda>_.\n                    P (\\<lambda>_.\n                          OclAllInstances_generic pre_post Type\n                           (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n   Object),\n                                  assocs = A\\<rparr>))\n                     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>))\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "let         ?allInstances = \"OclAllInstances_generic pre_post Type\""], ["proof (state)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have        \"?allInstances ?\\<tau> = \\<lambda>_. ?allInstances ?\\<tau>'->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>) ?\\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    \\<lambda>_.\n       OclAllInstances_generic pre_post Type\n        (mk \\<lparr>heap = \\<sigma>',\n               assocs =\n                 A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                            \\<lfloor>\\<lfloor>\\<lceil>Type\n                 Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)", "apply(rule state_update_vs_allInstances_generic_including)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a. pre_post (mk a) = a\n 2. \\<And>x.\n       \\<sigma>' oid = \\<lfloor>x\\<rfloor> \\<Longrightarrow> x = Object\n 3. Type Object \\<noteq> None", "by(insert oid_def, auto simp: type_conform)"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "also"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have   \"... = ((\\<lambda>_. ?allInstances ?\\<tau>')->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_. (\\<lambda>_.\\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>) ?\\<tau>') ?\\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>_.\n       OclAllInstances_generic pre_post Type\n        (mk \\<lparr>heap = \\<sigma>',\n               assocs =\n                 A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                            \\<lfloor>\\<lfloor>\\<lceil>Type\n                 Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    \\<lambda>_.\n       OclAllInstances_generic pre_post Type\n        (mk \\<lparr>heap = \\<sigma>',\n               assocs =\n                 A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                            \\<lfloor>\\<lfloor>\\<lceil>Type\n                 Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "by(subst const_OclIncluding[simplified const_def], simp+)"], ["proof (state)\nthis:\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "also"], ["proof (state)\nthis:\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "have   \"... = (?allInstances->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>Type Object\\<rfloor>) ?\\<tau>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lambda>_.\n       OclAllInstances_generic pre_post Type\n        (mk \\<lparr>heap = \\<sigma>',\n               assocs =\n                 A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                            \\<lfloor>\\<lfloor>\\<lceil>Type\n                 Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>Type Object\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "apply(subst UML_Set.OclIncluding.cp0[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>a.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>Type Object\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "by(insert type_conform, auto)"], ["proof (state)\nthis:\n  \\<lambda>_.\n     OclAllInstances_generic pre_post Type\n      (mk \\<lparr>heap = \\<sigma>',\n             assocs =\n               A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                          \\<lfloor>\\<lfloor>\\<lceil>Type\n               Object\\<rceil>\\<rfloor>\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post\n   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>Type Object\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "finally"], ["proof (chain)\npicking this:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post\n   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>Type Object\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "have Y : \"?allInstances ?\\<tau> = (?allInstances->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>Type Object\\<rfloor>) ?\\<tau>')\""], ["proof (prove)\nusing this:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post\n   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>Type Object\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. OclAllInstances_generic pre_post Type\n     (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n            assocs = A\\<rparr>) =\n    OclAllInstances_generic pre_post\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>Type Object\\<rfloor>)\n     (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  OclAllInstances_generic pre_post Type\n   (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n  OclAllInstances_generic pre_post\n   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>Type Object\\<rfloor>)\n   (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n      \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "apply(subst X)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> \\<lambda>_.\n                      P (\\<lambda>_.\n                            OclAllInstances_generic pre_post Type\n                             (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n     Object),\n                                    assocs = A\\<rparr>))\n                       (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "apply(subst foundation23[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P (\\<lambda>_.\n                         OclAllInstances_generic pre_post Type\n                          (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto>\n  Object),\n                                 assocs = A\\<rparr>))) =\n    (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n      \\<Turnstile> P OclAllInstances_generic pre_post\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "apply(rule StrongEq_L_subst3[OF cp_ctxt])"], ["proof (prove)\ngoal (1 subgoal):\n 1. mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n     \\<Turnstile> (\\<lambda>_.\n                      OclAllInstances_generic pre_post Type\n                       (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object),\n                              assocs = A\\<rparr>)) \\<triangleq>\n                  OclAllInstances_generic pre_post\n                   Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                        \\<lfloor>Type Object\\<rfloor>)", "apply(simp add: OclValid_def StrongEq_def Y true_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (mk \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>\n    \\<Turnstile> P (OclAllInstances_generic pre_post Type)) =\n  (mk \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>\n    \\<Turnstile> P OclAllInstances_generic pre_post\n                    Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                         \\<lfloor>Type Object\\<rfloor>))\n\ngoal:\nNo subgoals!", "qed"], ["", "declare OclAllInstances_generic_def [simp]"], ["", "subsubsection\\<open>OclAllInstances (@post)\\<close>"], ["", "definition OclAllInstances_at_post :: \"('\\<AA> :: object \\<rightharpoonup> '\\<alpha>) \\<Rightarrow> ('\\<AA>, '\\<alpha> option option) Set\"\n                           (\"_ .allInstances'(')\")\nwhere  \"OclAllInstances_at_post =  OclAllInstances_generic snd\""], ["", "lemma OclAllInstances_at_post_defined: \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> H .allInstances()", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic snd H", "by(rule OclAllInstances_generic_defined)"], ["", "lemma \"\\<tau>\\<^sub>0 \\<Turnstile> H .allInstances() \\<triangleq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>0 \\<Turnstile> H .allInstances() \\<triangleq> Set{}", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>0\n     \\<Turnstile> OclAllInstances_generic snd H \\<triangleq> Set{}", "by(rule OclAllInstances_generic_init_empty, simp)"], ["", "lemma represented_at_post_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "by(rule represented_generic_objects_nonnull[OF A[simplified OclAllInstances_at_post_def]])"], ["", "lemma represented_at_post_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances()) \\<and> \\<tau> \\<Turnstile> \\<delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> H .allInstances() \\<and>\n    \\<tau> \\<Turnstile> \\<delta> x", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic snd H \\<and>\n    \\<tau> \\<Turnstile> \\<delta> x", "by(rule represented_generic_objects_defined[OF A[simplified OclAllInstances_at_post_def]])"], ["", "text\\<open>One way to establish the actual presence of an object representation in a state is:\\<close>"], ["", "lemma\nassumes A: \"\\<tau> \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state snd x H \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_represented_in_state snd x H \\<tau>", "by(rule represented_generic_objects_in_state[OF A[simplified OclAllInstances_at_post_def]])"], ["", "lemma state_update_vs_allInstances_at_post_empty:\nshows   \"(\\<sigma>, \\<lparr>heap=Map.empty, assocs=A\\<rparr>) \\<Turnstile> Type .allInstances() \\<doteq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<lparr>heap = Map.empty, assocs = A\\<rparr>)\n     \\<Turnstile> Type .allInstances() \\<doteq> Set{}", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<lparr>heap = Map.empty, assocs = A\\<rparr>)\n     \\<Turnstile> OclAllInstances_generic snd Type \\<doteq> Set{}", "by(rule state_update_vs_allInstances_generic_empty[OF snd_conv])"], ["", "text\\<open>Here comes a couple of operational rules that allow to infer the value\nof \\inlineisar+oclAllInstances+ from the context $\\tau$. These rules are a special-case\nin the sense that they are the only rules that relate statements with \\emph{different}\n$\\tau$'s. For that reason, new concepts like ``constant contexts P'' are necessary\n(for which we do not elaborate an own theory for reasons of space limitations;\n in examples, we will prove resulting constraints straight forward by hand).\\<close>"], ["", "lemma state_update_vs_allInstances_at_post_including':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((Type .allInstances())->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<sigma>, \\<lparr>heap=\\<sigma>',assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances()\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    Type .allInstances()->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic snd Type\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    OclAllInstances_generic snd\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "by(rule state_update_vs_allInstances_generic_including'[OF snd_conv], insert assms)"], ["", "lemma state_update_vs_allInstances_at_post_including:\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         ((\\<lambda>_. (Type .allInstances())\n                 (\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances()\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    \\<lambda>_.\n       Type .allInstances()\n        (\\<sigma>,\n         \\<lparr>heap = \\<sigma>',\n            assocs =\n              A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic snd Type\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    \\<lambda>_.\n       OclAllInstances_generic snd Type\n        (\\<sigma>,\n         \\<lparr>heap = \\<sigma>',\n            assocs =\n              A\\<rparr>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                         \\<lfloor>\\<lfloor>\\<lceil>Type\n              Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)", "by(rule state_update_vs_allInstances_generic_including[OF snd_conv], insert assms)"], ["", "lemma state_update_vs_allInstances_at_post_noincluding':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>)\n         =\n         (Type .allInstances())\n         (\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances()\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    Type .allInstances()\n     (\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic snd Type\n     (\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>) =\n    OclAllInstances_generic snd Type\n     (\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)", "by(rule state_update_vs_allInstances_generic_noincluding'[OF snd_conv], insert assms)"], ["", "theorem state_update_vs_allInstances_at_post_ntc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>) \\<Turnstile> (P(Type .allInstances()))) =\n         ((\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)            \\<Turnstile> (P(Type .allInstances())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n      \\<Turnstile> P Type .allInstances()) =\n    ((\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n      \\<Turnstile> P Type .allInstances())", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n      \\<Turnstile> P (OclAllInstances_generic snd Type)) =\n    ((\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n      \\<Turnstile> P (OclAllInstances_generic snd Type))", "by(rule state_update_vs_allInstances_generic_ntc[OF snd_conv], insert assms)"], ["", "theorem state_update_vs_allInstances_at_post_tc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<sigma>, \\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>) \\<Turnstile> (P(Type .allInstances()))) =\n         ((\\<sigma>, \\<lparr>heap=\\<sigma>', assocs=A\\<rparr>)            \\<Turnstile> (P((Type .allInstances())\n                                                               ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n      \\<Turnstile> P Type .allInstances()) =\n    ((\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n      \\<Turnstile> P Type .allInstances()->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n    \\<lfloor>Type Object\\<rfloor>))", "unfolding OclAllInstances_at_post_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<sigma>,\n      \\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>)\n      \\<Turnstile> P (OclAllInstances_generic snd Type)) =\n    ((\\<sigma>, \\<lparr>heap = \\<sigma>', assocs = A\\<rparr>)\n      \\<Turnstile> P OclAllInstances_generic snd\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "by(rule state_update_vs_allInstances_generic_tc[OF snd_conv], insert assms)"], ["", "subsubsection\\<open>OclAllInstances (@pre)\\<close>"], ["", "definition OclAllInstances_at_pre :: \"('\\<AA> :: object \\<rightharpoonup> '\\<alpha>) \\<Rightarrow> ('\\<AA>, '\\<alpha> option option) Set\"\n                           (\"_ .allInstances@pre'(')\")\nwhere  \"OclAllInstances_at_pre = OclAllInstances_generic fst\""], ["", "lemma OclAllInstances_at_pre_defined: \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances@pre())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> H .allInstances@pre()", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic fst H", "by(rule OclAllInstances_generic_defined)"], ["", "lemma \"\\<tau>\\<^sub>0 \\<Turnstile> H .allInstances@pre() \\<triangleq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>0 \\<Turnstile> H .allInstances@pre() \\<triangleq> Set{}", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\\<^sub>0\n     \\<Turnstile> OclAllInstances_generic fst H \\<triangleq> Set{}", "by(rule OclAllInstances_generic_init_empty, simp)"], ["", "lemma represented_at_pre_objects_nonnull:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances@pre()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> not(x \\<triangleq> null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not (x \\<triangleq> null)", "by(rule represented_generic_objects_nonnull[OF A[simplified OclAllInstances_at_pre_def]])"], ["", "lemma represented_at_pre_objects_defined:\nassumes A: \"\\<tau> \\<Turnstile> (((H::('\\<AA>::object \\<rightharpoonup> '\\<alpha>)).allInstances@pre()) ->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\"\nshows      \"\\<tau> \\<Turnstile> \\<delta> (H .allInstances@pre()) \\<and> \\<tau> \\<Turnstile> \\<delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> H .allInstances@pre() \\<and>\n    \\<tau> \\<Turnstile> \\<delta> x", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> OclAllInstances_generic fst H \\<and>\n    \\<tau> \\<Turnstile> \\<delta> x", "by(rule represented_generic_objects_defined[OF A[simplified OclAllInstances_at_pre_def]])"], ["", "text\\<open>One way to establish the actual presence of an object representation in a state is:\\<close>"], ["", "lemma\nassumes A: \"\\<tau> \\<Turnstile> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)\"\nshows      \"is_represented_in_state fst x H \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_represented_in_state fst x H \\<tau>", "by(rule represented_generic_objects_in_state[OF A[simplified OclAllInstances_at_pre_def]])"], ["", "lemma state_update_vs_allInstances_at_pre_empty:\nshows   \"(\\<lparr>heap=Map.empty, assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> Type .allInstances@pre() \\<doteq> Set{}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>heap = Map.empty, assocs = A\\<rparr>, \\<sigma>)\n     \\<Turnstile> Type .allInstances@pre() \\<doteq> Set{}", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>heap = Map.empty, assocs = A\\<rparr>, \\<sigma>)\n     \\<Turnstile> OclAllInstances_generic fst Type \\<doteq> Set{}", "by(rule state_update_vs_allInstances_generic_empty[OF fst_conv])"], ["", "text\\<open>Here comes a couple of operational rules that allow to infer the value\nof \\inlineisar+oclAllInstances@pre+ from the context $\\tau$. These rules are a special-case\nin the sense that they are the only rules that relate statements with \\emph{different}\n$\\tau$'s. For that reason, new concepts like ``constant contexts P'' are necessary\n(for which we do not elaborate an own theory for reasons of space limitations;\n in examples, we will prove resulting constraints straight forward by hand).\\<close>"], ["", "lemma state_update_vs_allInstances_at_pre_including':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\n  shows \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         ((Type .allInstances@pre())->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<lparr>heap=\\<sigma>',assocs=A\\<rparr>, \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances@pre()\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    Type .allInstances@pre()->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                             \\<lfloor>\\<lfloor>\\<lceil>Type\n                  Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic fst Type\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    OclAllInstances_generic fst\n     Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n          \\<lfloor>\\<lfloor>\\<lceil>Type Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)", "by(rule state_update_vs_allInstances_generic_including'[OF fst_conv], insert assms)"], ["", "lemma state_update_vs_allInstances_at_pre_including:\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object \\<noteq> None\"\nshows   \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         ((\\<lambda>_. (Type .allInstances@pre())\n                 (\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>))->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>\\<lfloor> drop (Type Object) \\<rfloor>\\<rfloor>))\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances@pre()\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    \\<lambda>_.\n       Type .allInstances@pre()\n        (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>,\n         \\<sigma>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                   \\<lfloor>\\<lfloor>\\<lceil>Type\n        Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic fst Type\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    \\<lambda>_.\n       OclAllInstances_generic fst Type\n        (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>,\n         \\<sigma>)->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                   \\<lfloor>\\<lfloor>\\<lceil>Type\n        Object\\<rceil>\\<rfloor>\\<rfloor>)\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)", "by(rule state_update_vs_allInstances_generic_including[OF fst_conv], insert assms)"], ["", "lemma state_update_vs_allInstances_at_pre_noincluding':\nassumes \"\\<And>x. \\<sigma>' oid = Some x \\<Longrightarrow> x = Object\"\n    and \"Type Object = None\"\n  shows \"(Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object), assocs=A\\<rparr>, \\<sigma>)\n         =\n         (Type .allInstances@pre())\n         (\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Type .allInstances@pre()\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    Type .allInstances@pre()\n     (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OclAllInstances_generic fst Type\n     (\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>) =\n    OclAllInstances_generic fst Type\n     (\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)", "by(rule state_update_vs_allInstances_generic_noincluding'[OF fst_conv], insert assms)"], ["", "theorem state_update_vs_allInstances_at_pre_ntc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  non_type_conform: \"Type Object = None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> (P(Type .allInstances@pre()))) =\n         ((\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)            \\<Turnstile> (P(Type .allInstances@pre())))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)\n      \\<Turnstile> P Type .allInstances@pre()) =\n    ((\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)\n      \\<Turnstile> P Type .allInstances@pre())", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)\n      \\<Turnstile> P (OclAllInstances_generic fst Type)) =\n    ((\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)\n      \\<Turnstile> P (OclAllInstances_generic fst Type))", "by(rule state_update_vs_allInstances_generic_ntc[OF fst_conv], insert assms)"], ["", "theorem state_update_vs_allInstances_at_pre_tc:\nassumes oid_def:   \"oid\\<notin>dom \\<sigma>'\"\nand  type_conform: \"Type Object \\<noteq> None \"\nand  cp_ctxt:      \"cp P\"\nand  const_ctxt:   \"\\<And>X. const X \\<Longrightarrow> const (P X)\"\nshows   \"((\\<lparr>heap=\\<sigma>'(oid\\<mapsto>Object),assocs=A\\<rparr>, \\<sigma>) \\<Turnstile> (P(Type .allInstances@pre()))) =\n         ((\\<lparr>heap=\\<sigma>', assocs=A\\<rparr>, \\<sigma>)            \\<Turnstile> (P((Type .allInstances@pre())\n                                                               ->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda> _. \\<lfloor>(Type Object)\\<rfloor>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)\n      \\<Turnstile> P Type .allInstances@pre()) =\n    ((\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)\n      \\<Turnstile> P Type .allInstances@pre()->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n        \\<lfloor>Type Object\\<rfloor>))", "unfolding OclAllInstances_at_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lparr>heap = \\<sigma>'(oid \\<mapsto> Object), assocs = A\\<rparr>,\n      \\<sigma>)\n      \\<Turnstile> P (OclAllInstances_generic fst Type)) =\n    ((\\<lparr>heap = \\<sigma>', assocs = A\\<rparr>, \\<sigma>)\n      \\<Turnstile> P OclAllInstances_generic fst\n                      Type->including\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>_.\n                           \\<lfloor>Type Object\\<rfloor>))", "by(rule state_update_vs_allInstances_generic_tc[OF fst_conv], insert assms)"], ["", "subsubsection\\<open>@post or @pre\\<close>"], ["", "theorem StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq'':\nassumes WFF: \"WFF \\<tau>\"\nand valid_x: \"\\<tau> \\<Turnstile>(\\<upsilon> (x :: ('\\<AA>::object,'\\<alpha>::object option option)val))\"\nand valid_y: \"\\<tau> \\<Turnstile>(\\<upsilon> y)\"\nand oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                        oid_of (H x) = oid_of x\"\nand xy_together: \"\\<tau> \\<Turnstile> ((H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)) or\n                       (H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)))\"\n (* x and y must be object representations that exist in either the pre or post state *)\nshows \"(\\<tau> \\<Turnstile> (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x y)) = (\\<tau> \\<Turnstile> (x \\<triangleq> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "have at_post_def : \"\\<And>x. \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<delta> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)", "apply(simp add: OclIncludes_def OclValid_def\n                    OclAllInstances_at_post_defined[simplified OclValid_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<upsilon> x) \\<tau> = true \\<tau> \\<Longrightarrow>\n       (\\<delta> (\\<lambda>\\<tau>.\n                     if (\\<upsilon> x) \\<tau> = true \\<tau>\n                     then \\<lfloor>\\<lfloor>x \\<tau>\n      \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             (H .allInstances()\n                               \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                     else \\<bottom>))\n        \\<tau> =\n       true \\<tau>", "by(subst cp_defined, simp)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<upsilon> ?x \\<Longrightarrow>\n  \\<tau>\n   \\<Turnstile> \\<delta> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(?x)\n\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "have at_pre_def : \"\\<And>x. \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<delta> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x)", "apply(simp add: OclIncludes_def OclValid_def\n                    OclAllInstances_at_pre_defined[simplified OclValid_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<upsilon> x) \\<tau> = true \\<tau> \\<Longrightarrow>\n       (\\<delta> (\\<lambda>\\<tau>.\n                     if (\\<upsilon> x) \\<tau> = true \\<tau>\n                     then \\<lfloor>\\<lfloor>x \\<tau>\n      \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             (H .allInstances@pre()\n                               \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                     else \\<bottom>))\n        \\<tau> =\n       true \\<tau>", "by(subst cp_defined, simp)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<upsilon> ?x \\<Longrightarrow>\n  \\<tau>\n   \\<Turnstile> \\<delta> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(?x)\n\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "have F: \"Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (fst \\<tau>)) - {None})\\<rfloor>\\<rfloor>) =\n            \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (fst \\<tau>)) - {None})\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       \\<lfloor>\\<lfloor>Some `\n                         (H ` ran (heap (fst \\<tau>)) -\n                          {None})\\<rfloor>\\<rfloor>) =\n    \\<lfloor>\\<lfloor>Some `\n                      (H ` ran (heap (fst \\<tau>)) -\n                       {None})\\<rfloor>\\<rfloor>", "by(subst Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse,simp_all add: bot_option_def)"], ["proof (state)\nthis:\n  Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (fst \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor>) =\n  \\<lfloor>\\<lfloor>Some `\n                    (H ` ran (heap (fst \\<tau>)) - {None})\\<rfloor>\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "have F': \"Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (snd \\<tau>)) - {None})\\<rfloor>\\<rfloor>) =\n            \\<lfloor>\\<lfloor>Some ` (H ` ran (heap (snd \\<tau>)) - {None})\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       \\<lfloor>\\<lfloor>Some `\n                         (H ` ran (heap (snd \\<tau>)) -\n                          {None})\\<rfloor>\\<rfloor>) =\n    \\<lfloor>\\<lfloor>Some `\n                      (H ` ran (heap (snd \\<tau>)) -\n                       {None})\\<rfloor>\\<rfloor>", "by(subst Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e.Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse,simp_all add: bot_option_def)"], ["proof (state)\nthis:\n  Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<lfloor>Some `\n                       (H ` ran (heap (snd \\<tau>)) -\n                        {None})\\<rfloor>\\<rfloor>) =\n  \\<lfloor>\\<lfloor>Some `\n                    (H ` ran (heap (snd \\<tau>)) - {None})\\<rfloor>\\<rfloor>\n\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                    x y) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> y)", "apply(rule StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq'[OF WFF valid_x valid_y, where H = \"Some o H\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> ran (heap (fst \\<tau>)) \\<or>\n                x \\<in> ran (heap (snd \\<tau>));\n        (Some \\<circ> H) x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> oid_of ((Some \\<circ> H) x) = oid_of x\n 2. x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<or>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>))", "apply(subst oid_preserve[symmetric], simp, simp add: oid_of_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<or>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>))", "apply(insert xy_together,\n        subst (asm) foundation11,\n        metis at_post_def defined_and_I valid_x valid_y,\n        metis at_pre_def defined_and_I valid_x valid_y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                  H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y) \\<or>\n    \\<tau>\n     \\<Turnstile> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                  H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y) \\<Longrightarrow>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<or>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>))", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau>\n     \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                  H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y) \\<Longrightarrow>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<or>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>))\n 2. \\<tau>\n     \\<Turnstile> H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                  H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y) \\<Longrightarrow>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (fst \\<tau>)) \\<or>\n    x \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>)) \\<and>\n    y \\<tau> \\<in> (Some \\<circ> H) ` ran (heap (snd \\<tau>))", "by(drule foundation5,\n    simp add: OclAllInstances_at_pre_def OclAllInstances_at_post_def\n              OclValid_def OclIncludes_def true_def F F'\n              valid_x[simplified OclValid_def] valid_y[simplified OclValid_def] bot_option_def\n         split: if_split_asm,\n    simp add: comp_def image_def, fastforce)+"], ["proof (state)\nthis:\n  (\\<tau>\n    \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                  x y) =\n  (\\<tau> \\<Turnstile> x \\<triangleq> y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>OclIsNew, OclIsDeleted, OclIsMaintained, OclIsAbsent\\<close>"], ["", "definition OclIsNew:: \"('\\<AA>, '\\<alpha>::{null,object})val \\<Rightarrow> ('\\<AA>)Boolean\"   (\"(_).oclIsNew'(')\")\nwhere \"X .oclIsNew() \\<equiv> (\\<lambda>\\<tau> . if (\\<delta> X) \\<tau> = true \\<tau>\n                              then \\<lfloor>\\<lfloor>oid_of (X \\<tau>) \\<notin> dom(heap(fst \\<tau>)) \\<and>\n                                     oid_of (X \\<tau>) \\<in> dom(heap(snd \\<tau>))\\<rfloor>\\<rfloor>\n                              else invalid \\<tau>)\""], ["", "text\\<open>The following predicates --- which are not part of the OCL standard descriptions ---\ncomplete the goal of \\inlineisar+oclIsNew+ by describing where an object belongs.\n\\<close>"], ["", "definition OclIsDeleted:: \"('\\<AA>, '\\<alpha>::{null,object})val \\<Rightarrow> ('\\<AA>)Boolean\"   (\"(_).oclIsDeleted'(')\")\nwhere \"X .oclIsDeleted() \\<equiv> (\\<lambda>\\<tau> . if (\\<delta> X) \\<tau> = true \\<tau>\n                              then \\<lfloor>\\<lfloor>oid_of (X \\<tau>) \\<in> dom(heap(fst \\<tau>)) \\<and>\n                                     oid_of (X \\<tau>) \\<notin> dom(heap(snd \\<tau>))\\<rfloor>\\<rfloor>\n                              else invalid \\<tau>)\""], ["", "definition OclIsMaintained:: \"('\\<AA>, '\\<alpha>::{null,object})val \\<Rightarrow> ('\\<AA>)Boolean\"(\"(_).oclIsMaintained'(')\")\nwhere \"X .oclIsMaintained() \\<equiv> (\\<lambda>\\<tau> . if (\\<delta> X) \\<tau> = true \\<tau>\n                              then \\<lfloor>\\<lfloor>oid_of (X \\<tau>) \\<in> dom(heap(fst \\<tau>)) \\<and>\n                                     oid_of (X \\<tau>) \\<in> dom(heap(snd \\<tau>))\\<rfloor>\\<rfloor>\n                              else invalid \\<tau>)\""], ["", "definition OclIsAbsent:: \"('\\<AA>, '\\<alpha>::{null,object})val \\<Rightarrow> ('\\<AA>)Boolean\"   (\"(_).oclIsAbsent'(')\")\nwhere \"X .oclIsAbsent() \\<equiv> (\\<lambda>\\<tau> . if (\\<delta> X) \\<tau> = true \\<tau>\n                              then \\<lfloor>\\<lfloor>oid_of (X \\<tau>) \\<notin> dom(heap(fst \\<tau>)) \\<and>\n                                     oid_of (X \\<tau>) \\<notin> dom(heap(snd \\<tau>))\\<rfloor>\\<rfloor>\n                              else invalid \\<tau>)\""], ["", "lemma state_split : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                     \\<tau> \\<Turnstile> (X .oclIsNew()) \\<or> \\<tau> \\<Turnstile> (X .oclIsDeleted()) \\<or>\n                     \\<tau> \\<Turnstile> (X .oclIsMaintained()) \\<or> \\<tau> \\<Turnstile> (X .oclIsAbsent())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n    \\<tau> \\<Turnstile> X.oclIsNew() \\<or>\n    \\<tau> \\<Turnstile> X.oclIsDeleted() \\<or>\n    \\<tau> \\<Turnstile> X.oclIsMaintained() \\<or>\n    \\<tau> \\<Turnstile> X.oclIsAbsent()", "by(simp add: OclIsDeleted_def OclIsNew_def OclIsMaintained_def OclIsAbsent_def\n             OclValid_def true_def, blast)"], ["", "lemma notNew_vs_others : \"\\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n                         (\\<not> \\<tau> \\<Turnstile> (X .oclIsNew())) = (\\<tau> \\<Turnstile> (X .oclIsDeleted()) \\<or>\n                          \\<tau> \\<Turnstile> (X .oclIsMaintained()) \\<or> \\<tau> \\<Turnstile> (X .oclIsAbsent()))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n    (\\<tau> |\\<noteq> X.oclIsNew()) =\n    (\\<tau> \\<Turnstile> X.oclIsDeleted() \\<or>\n     \\<tau> \\<Turnstile> X.oclIsMaintained() \\<or>\n     \\<tau> \\<Turnstile> X.oclIsAbsent())", "by(simp add: OclIsDeleted_def OclIsNew_def OclIsMaintained_def OclIsAbsent_def\n                OclNot_def OclValid_def true_def, blast)"], ["", "subsection\\<open>OclIsModifiedOnly\\<close>"], ["", "subsubsection\\<open>Definition\\<close>"], ["", "text\\<open>The following predicate---which is not part of the OCL\nstandard---provides a simple, but powerful means to describe framing\nconditions. For any formal approach, be it animation of OCL contracts,\ntest-case generation or die-hard theorem proving, the specification of\nthe part of a system transition that \\emph{does not change} is of\nprimordial importance. The following operator establishes the equality\nbetween old and new objects in the state (provided that they exist in\nboth states), with the exception of those objects.\\<close>"], ["", "definition OclIsModifiedOnly ::\"('\\<AA>::object,'\\<alpha>::{null,object})Set \\<Rightarrow> '\\<AA> Boolean\"\n                        (\"_->oclIsModifiedOnly'(')\")\nwhere \"X->oclIsModifiedOnly() \\<equiv> (\\<lambda>(\\<sigma>,\\<sigma>').\n                           let X' = (oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(X(\\<sigma>,\\<sigma>'))\\<rceil>\\<rceil>);\n                               S = ((dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>')) - X')\n                           in if (\\<delta> X) (\\<sigma>,\\<sigma>') = true (\\<sigma>,\\<sigma>') \\<and> (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e(X(\\<sigma>,\\<sigma>'))\\<rceil>\\<rceil>. x \\<noteq> null)\n                              then \\<lfloor>\\<lfloor>\\<forall> x \\<in> S. (heap \\<sigma>) x = (heap \\<sigma>') x\\<rfloor>\\<rfloor>\n                              else invalid (\\<sigma>,\\<sigma>'))\""], ["", "subsubsection\\<open>Execution with Invalid or Null or Null Element as Argument\\<close>"], ["", "lemma \"invalid->oclIsModifiedOnly() = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invalid->oclIsModifiedOnly() = invalid", "by(simp add: OclIsModifiedOnly_def)"], ["", "lemma \"null->oclIsModifiedOnly() = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null->oclIsModifiedOnly() = invalid", "by(simp add: OclIsModifiedOnly_def)"], ["", "lemma\n assumes X_null : \"\\<tau> \\<Turnstile> X->includes\\<^sub>S\\<^sub>e\\<^sub>t(null)\"\n shows \"\\<tau> \\<Turnstile> X->oclIsModifiedOnly() \\<triangleq> invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> X->oclIsModifiedOnly() \\<triangleq> invalid", "apply(insert X_null,\n       simp add : OclIncludes_def OclIsModifiedOnly_def StrongEq_def OclValid_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if (\\<delta> X) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\n     then \\<lfloor>\\<lfloor>null \\<tau>\n                            \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n             (X \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n     else \\<bottom>) =\n    \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Longrightarrow>\n    (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       if (\\<delta> X) (\\<sigma>, \\<sigma>') =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n              x \\<noteq> null)\n       then \\<lfloor>\\<lfloor>\\<forall>x\n \\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n      oid_of `\n      \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                                 heap \\<sigma> x =\n                                 heap \\<sigma>' x\\<rfloor>\\<rfloor>\n       else invalid (\\<sigma>, \\<sigma>')) =\n    invalid \\<tau>", "apply(case_tac \\<tau>, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>(if (\\<delta> X) (a, b) =\n                    \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\n                 then \\<lfloor>\\<lfloor>null \\<tau>\n  \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (X \\<tau>)\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                 else \\<bottom>) =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<tau> = (a, b)\\<rbrakk>\n       \\<Longrightarrow> (\\<delta> X) (a, b) =\n                         \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n                         (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                    (X (a, b))\\<rceil>\\<rceil>.\n                             x \\<noteq> null) \\<longrightarrow>\n                         \\<lfloor>\\<lfloor>\\<forall>x\n              \\<in>dom (heap a) \\<inter> dom (heap b) -\n                   oid_of `\n                   \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X (a, b))\\<rceil>\\<rceil>.\n        heap a x = heap b x\\<rfloor>\\<rfloor> =\n                         invalid (a, b)", "apply(simp split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        null (a, b)\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X (a, b))\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                    (X (a, b))\\<rceil>\\<rceil>.\n                             x \\<noteq> null) \\<longrightarrow>\n                         \\<lfloor>\\<lfloor>\\<forall>x\n              \\<in>dom (heap a) \\<inter> dom (heap b) -\n                   oid_of `\n                   \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X (a, b))\\<rceil>\\<rceil>.\n        heap a x = heap b x\\<rfloor>\\<rfloor> =\n                         invalid (a, b)", "by(simp add: null_fun_def, blast)"], ["", "subsubsection\\<open>Context Passing\\<close>"], ["", "lemma cp_OclIsModifiedOnly : \"X->oclIsModifiedOnly() \\<tau> = (\\<lambda>_. X \\<tau>)->oclIsModifiedOnly() \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X->oclIsModifiedOnly() \\<tau> =\n    \\<lambda>_. X \\<tau>->oclIsModifiedOnly() \\<tau>", "by(simp only: OclIsModifiedOnly_def, case_tac \\<tau>, simp only:, subst cp_defined, simp)"], ["", "subsection\\<open>OclSelf\\<close>"], ["", "text\\<open>The following predicate---which is not part of the OCL\nstandard---explicitly retrieves in the pre or post state the original OCL expression\ngiven as argument.\\<close>"], ["", "definition [simp]: \"OclSelf x H fst_snd = (\\<lambda>\\<tau> . if (\\<delta> x) \\<tau> = true \\<tau>\n                        then if oid_of (x \\<tau>) \\<in> dom(heap(fst \\<tau>)) \\<and> oid_of (x \\<tau>) \\<in> dom(heap (snd \\<tau>))\n                             then  H \\<lceil>(heap(fst_snd \\<tau>))(oid_of (x \\<tau>))\\<rceil>\n                             else invalid \\<tau>\n                        else invalid \\<tau>)\""], ["", "definition OclSelf_at_pre :: \"('\\<AA>::object,'\\<alpha>::{null,object})val \\<Rightarrow>\n                      ('\\<AA> \\<Rightarrow> '\\<alpha>) \\<Rightarrow>\n                      ('\\<AA>::object,'\\<alpha>::{null,object})val\" (\"(_)@pre(_)\")\nwhere \"x @pre H = OclSelf x H fst\""], ["", "definition OclSelf_at_post :: \"('\\<AA>::object,'\\<alpha>::{null,object})val \\<Rightarrow>\n                      ('\\<AA> \\<Rightarrow> '\\<alpha>) \\<Rightarrow>\n                      ('\\<AA>::object,'\\<alpha>::{null,object})val\" (\"(_)@post(_)\")\nwhere \"x @post H = OclSelf x H snd\""], ["", "subsection\\<open>Framing Theorem\\<close>"], ["", "lemma all_oid_diff:\n assumes def_x : \"\\<tau> \\<Turnstile> \\<delta> x\"\n assumes def_X : \"\\<tau> \\<Turnstile> \\<delta> X\"\n assumes def_X' : \"\\<And>x. x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow> x \\<noteq> null\"\n\n defines \"P \\<equiv> (\\<lambda>a. not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x a))\"\n shows \"(\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| P a)) = (oid_of (x \\<tau>) \\<notin> oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "have P_null_bot: \"\\<And>b. b = null \\<or> b = \\<bottom> \\<Longrightarrow>\n                        \\<not> (\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>(_:: 'a state \\<times> 'a state). x) \\<tau> = b \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       b = null \\<or> b = \\<bottom> \\<Longrightarrow>\n       \\<not> (\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X \\<tau>)\\<rceil>\\<rceil>.\n                  P (\\<lambda>_. x) \\<tau> = b \\<tau>)", "apply(erule disjE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>b.\n       b = null \\<Longrightarrow>\n       \\<not> (\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X \\<tau>)\\<rceil>\\<rceil>.\n                  P (\\<lambda>_. x) \\<tau> = b \\<tau>)\n 2. \\<And>b.\n       b = \\<bottom> \\<Longrightarrow>\n       \\<not> (\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X \\<tau>)\\<rceil>\\<rceil>.\n                  P (\\<lambda>_. x) \\<tau> = b \\<tau>)", "apply(simp, rule ballI,\n         simp add: P_def StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def, rename_tac x',\n         subst cp_OclNot, simp,\n         subgoal_tac \"x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null\", simp,\n         simp add: OclNot_def null_fun_def null_option_def bot_option_def bot_fun_def invalid_def,\n         ( metis def_X' def_x foundation16[THEN iffD1]\n         | (metis bot_fun_def OclValid_def Set_inv_lemma def_X def_x defined_def valid_def,\n            metis def_X' def_x foundation16[THEN iffD1])))+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?b = null \\<or> ?b = \\<bottom> \\<Longrightarrow>\n  \\<not> (\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>.\n             P (\\<lambda>_. x) \\<tau> = ?b \\<tau>)\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "have not_inj : \"\\<And>x y. ((not x) \\<tau> = (not y) \\<tau>) = (x \\<tau> = y \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. (not x \\<tau> = not y \\<tau>) = (x \\<tau> = y \\<tau>)", "by (metis foundation21 foundation22)"], ["proof (state)\nthis:\n  (not ?x \\<tau> = not ?y \\<tau>) = (?x \\<tau> = ?y \\<tau>)\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "have P_false : \"\\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> = false \\<tau> \\<Longrightarrow>\n                 oid_of (x \\<tau>) \\<in> oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>.\n       P (\\<lambda>_. x) \\<tau> = false \\<tau> \\<Longrightarrow>\n    oid_of (x \\<tau>)\n    \\<in> oid_of `\n          \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (X \\<tau>)\\<rceil>\\<rceil>", "apply(erule bexE, rename_tac x')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x') \\<tau> = false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "apply(simp add: P_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n              (\\<lambda>_. x'))\n         \\<tau> =\n        false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "apply(simp only: OclNot3[symmetric], simp only: not_inj)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n         (\\<lambda>_. x') \\<tau> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "apply(simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> = null \\<or> x' = null;\n        \\<lfloor>\\<lfloor>x \\<tau> = null \\<and>\n                          x' = null\\<rfloor>\\<rfloor> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null;\n        \\<lfloor>\\<lfloor>oid_of (x \\<tau>) = oid_of x'\\<rfloor>\\<rfloor> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "apply(subgoal_tac \"x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> = null \\<or> x' = null;\n        \\<lfloor>\\<lfloor>x \\<tau> = null \\<and>\n                          x' = null\\<rfloor>\\<rfloor> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null;\n        \\<lfloor>\\<lfloor>oid_of (x \\<tau>) = oid_of x'\\<rfloor>\\<rfloor> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "apply (metis (mono_tags) drop.simps def_x foundation16[THEN iffD1] true_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null;\n        \\<lfloor>\\<lfloor>oid_of (x \\<tau>) = oid_of x'\\<rfloor>\\<rfloor> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of (x \\<tau>)\n                         \\<in> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>", "by(simp add: invalid_def bot_option_def true_def)+"], ["proof (state)\nthis:\n  \\<exists>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X \\<tau>)\\<rceil>\\<rceil>.\n     P (\\<lambda>_. x) \\<tau> = false \\<tau> \\<Longrightarrow>\n  oid_of (x \\<tau>)\n  \\<in> oid_of `\n        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (X \\<tau>)\\<rceil>\\<rceil>\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "have P_true : \"\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> = true \\<tau> \\<Longrightarrow>\n                oid_of (x \\<tau>) \\<notin> oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>.\n       P (\\<lambda>_. x) \\<tau> = true \\<tau> \\<Longrightarrow>\n    oid_of (x \\<tau>)\n    \\<notin> oid_of `\n             \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (X \\<tau>)\\<rceil>\\<rceil>", "apply(subgoal_tac \"\\<forall>x'\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. oid_of x' \\<noteq> oid_of (x \\<tau>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       (X \\<tau>)\\<rceil>\\<rceil>.\n                P (\\<lambda>_. x) \\<tau> = true \\<tau>;\n     \\<forall>x'\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n(X \\<tau>)\\<rceil>\\<rceil>.\n        oid_of x' \\<noteq> oid_of (x \\<tau>)\\<rbrakk>\n    \\<Longrightarrow> oid_of (x \\<tau>)\n                      \\<notin> oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 2. \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>.\n       P (\\<lambda>_. x) \\<tau> = true \\<tau> \\<Longrightarrow>\n    \\<forall>x'\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>.\n       oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply (metis imageE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>.\n       P (\\<lambda>_. x) \\<tau> = true \\<tau> \\<Longrightarrow>\n    \\<forall>x'\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>.\n       oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply(rule ballI, drule_tac x = \"x'\" in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x') \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q7 x'\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q7 x'\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        ?Q7 x'\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        ?Q7 x'\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x') \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q7 x'\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q7 x'", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x') \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply(simp add: P_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n              (\\<lambda>_. x'))\n         \\<tau> =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply(simp only: OclNot4[symmetric], simp only: not_inj)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n         (\\<lambda>_. x') \\<tau> =\n        false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply(simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def false_def split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> = null \\<or> x' = null;\n        x \\<tau> = null \\<longrightarrow> x' \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply(subgoal_tac \"x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null\", simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau>;\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> = true \\<tau>;\n        x \\<tau> = null \\<or> x' = null;\n        x \\<tau> = null \\<longrightarrow> x' \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> x \\<tau> \\<noteq> null \\<and> x' \\<noteq> null\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 3. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "apply (metis def_X' def_x  foundation16[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (\\<upsilon> x) \\<tau> = true \\<tau> \\<longrightarrow>\n        (\\<upsilon> (\\<lambda>_. x')) \\<tau> \\<noteq> true \\<tau>;\n        invalid \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)\n 2. \\<And>x'.\n       \\<lbrakk>x' \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        x' \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> oid_of x' \\<noteq> oid_of (x \\<tau>)", "by(simp add: invalid_def bot_option_def false_def)+"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X \\<tau>)\\<rceil>\\<rceil>.\n     P (\\<lambda>_. x) \\<tau> = true \\<tau> \\<Longrightarrow>\n  oid_of (x \\<tau>)\n  \\<notin> oid_of `\n           \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (X \\<tau>)\\<rceil>\\<rceil>\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "have bool_split : \"\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau> \\<Longrightarrow>\n                    \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau> \\<Longrightarrow>\n                    \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow>\n                    \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>. P (\\<lambda>_. x) \\<tau> = true \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       (X \\<tau>)\\<rceil>\\<rceil>.\n                P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n     \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>.\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n     \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>.\n        P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                (X \\<tau>)\\<rceil>\\<rceil>.\n                         P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply(rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply(drule_tac x = x in ballE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q2 x\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q2 x\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        ?Q2 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "prefer 3"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        ?Q2 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q2 x\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q2 x", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply(drule_tac x = x in ballE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q4 x\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q4 x\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>; ?Q4 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "prefer 3"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>; ?Q4 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q4 x\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q4 x\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply assumption"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply(drule_tac x = x in ballE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q6 x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q6 x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>; ?Q6 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "prefer 3"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>; ?Q6 x\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> ?Q6 x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> ?Q6 x\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 5. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply assumption"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "apply (metis (full_types) bot_fun_def OclNot4 OclValid_def foundation16\n                               foundation9 not_inj null_fun_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>.\n                   P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X \\<tau>)\\<rceil>\\<rceil>.\n           P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>;\n        x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        x \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> P (\\<lambda>_. x) \\<tau> = true \\<tau>", "by(fast+)"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (X \\<tau>)\\<rceil>\\<rceil>.\n              P (\\<lambda>_. x) \\<tau> \\<noteq> null \\<tau>;\n   \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                   (X \\<tau>)\\<rceil>\\<rceil>.\n      P (\\<lambda>_. x) \\<tau> \\<noteq> \\<bottom> \\<tau>;\n   \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                   (X \\<tau>)\\<rceil>\\<rceil>.\n      P (\\<lambda>_. x) \\<tau> \\<noteq> false \\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n              (X \\<tau>)\\<rceil>\\<rceil>.\n                       P (\\<lambda>_. x) \\<tau> = true \\<tau>\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "apply(subst OclForall_rep_set_true[OF def_X], simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X \\<tau>)\\<rceil>\\<rceil>.\n        P (\\<lambda>\\<tau>. x) \\<tau> = true \\<tau>) =\n    (oid_of (x \\<tau>)\n     \\<notin> oid_of `\n              \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X \\<tau>)\\<rceil>\\<rceil>)", "apply(rule iffI, simp add: P_true)"], ["proof (prove)\ngoal (1 subgoal):\n 1. oid_of (x \\<tau>)\n    \\<notin> oid_of `\n             \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow>\n    \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X \\<tau>)\\<rceil>\\<rceil>.\n       P (\\<lambda>\\<tau>. x) \\<tau> = true \\<tau>", "by (metis P_false P_null_bot bool_split)"], ["proof (state)\nthis:\n  (\\<tau> \\<Turnstile> UML_Set.OclForall X P) =\n  (oid_of (x \\<tau>)\n   \\<notin> oid_of `\n            \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                             (X \\<tau>)\\<rceil>\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem framing:\n      assumes modifiesclause:\"\\<tau> \\<Turnstile> (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))->oclIsModifiedOnly()\"\n      and oid_is_typerepr : \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| not (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x a))\"\n      shows \"\\<tau> \\<Turnstile> (x @pre P  \\<triangleq>  (x @post P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(case_tac \"\\<tau> \\<Turnstile> \\<delta> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "show \"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "assume def_x : \"\\<tau> \\<Turnstile> \\<delta> x\""], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "have def_X : \"\\<tau> \\<Turnstile> \\<delta> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X", "apply(insert oid_is_typerepr, simp add: UML_Set.OclForall_def OclValid_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> \\<noteq> \\<bottom>;\n     \\<bottom> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "by(simp add: bot_option_def true_def)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> X\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "have def_X' : \"\\<And>x. x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow> x \\<noteq> null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow>\n       x \\<noteq> null", "apply(insert modifiesclause, simp add: OclIsModifiedOnly_def OclValid_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (X \\<tau>)\\<rceil>\\<rceil>;\n        (case \\<tau> of\n         (\\<sigma>, \\<sigma>') \\<Rightarrow>\n           if (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n              \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n              (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n           (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                  x \\<noteq> null)\n           then \\<lfloor>\\<lfloor>\\<forall>x\n     \\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n          oid_of `\n          \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                           (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                             (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                                     heap \\<sigma> x =\n                                     heap \\<sigma>' x\\<rfloor>\\<rfloor>\n           else invalid (\\<sigma>, \\<sigma>')) =\n        true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(case_tac \\<tau>, simp split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x) (a, b))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                       oid_of `\n                       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x) (a, b))\\<rceil>\\<rceil>.\n           heap a x = heap b x\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(simp add: UML_Set.OclExcluding_def split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n (X (a, b))\\<rceil>\\<rceil> -\n                      {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(subst (asm) (2) Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X (a, b))\\<rceil>\\<rceil> -\n     {x (a, b)}\\<rfloor>\\<rfloor>\n                         \\<in> {X. X = \\<bottom> \\<or>\n                                   X = null \\<or>\n                                   (\\<forall>x\n       \\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n x \\<noteq> \\<bottom>)}\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X (a, b))\\<rceil>\\<rceil> -\n                   {x (a, b)}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 4. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(simp, (rule disjI2)+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                   (X (a, b))\\<rceil>\\<rceil> -\n  {x (a, b)}.\n                            x \\<noteq> \\<bottom>\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X (a, b))\\<rceil>\\<rceil> -\n                   {x (a, b)}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 4. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply (metis (hide_lams, mono_tags) Diff_iff Set_inv_lemma def_X)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X (a, b))\\<rceil>\\<rceil> -\n                   {x (a, b)}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X (a, b))\\<rceil>\\<rceil> -\n                       {x (a, b)}.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(erule ballE[where P = \"\\<lambda>x. x \\<noteq> null\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        ?x39 xa a b \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        ?x39 xa a b\n        \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil> -\n                 {x (a, b)}\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 4. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(assumption)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        xa \\<notin> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                     (X (a, b))\\<rceil>\\<rceil> -\n                    {x (a, b)}\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n            \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X (a, b))\\<rceil>\\<rceil> -\n                              {x (a, b)}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        x (a, b)\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> x) (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        xa = x (a, b)\\<rbrakk>\n       \\<Longrightarrow> x (a, b) \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 3. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply (metis (hide_lams, no_types) def_x  foundation16[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<forall>x\\<in>dom (heap a) \\<inter> dom (heap b) -\n                               oid_of `\n                               \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          \\<bottom>\\<rceil>\\<rceil>.\n                   heap a x = heap b x;\n        \\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<delta> X) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        (\\<upsilon> x) (a, b) \\<noteq>\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  \\<bottom>\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null\n 2. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "apply (metis (hide_lams, no_types) OclValid_def def_X def_x foundation20\n                                      OclExcluding_valid_args_valid OclExcluding_valid_args_valid'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa a b.\n       \\<lbrakk>\\<tau> = (a, b);\n        xa \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X (a, b))\\<rceil>\\<rceil>;\n        (\\<delta> X and \\<upsilon> x) (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (a, b))\\<rceil>\\<rceil>;\n        invalid (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> xa \\<noteq> null", "by(simp add: invalid_def bot_option_def)"], ["proof (state)\nthis:\n  ?x \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (X \\<tau>)\\<rceil>\\<rceil> \\<Longrightarrow>\n  ?x \\<noteq> null\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "have oid_is_typerepr : \"oid_of (x \\<tau>) \\<notin> oid_of ` \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (X \\<tau>)\\<rceil>\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oid_of (x \\<tau>)\n    \\<notin> oid_of `\n             \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (X \\<tau>)\\<rceil>\\<rceil>", "by(rule all_oid_diff[THEN iffD1, OF def_x def_X def_X' oid_is_typerepr])"], ["proof (state)\nthis:\n  oid_of (x \\<tau>)\n  \\<notin> oid_of `\n           \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (X \\<tau>)\\<rceil>\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(simp add: StrongEq_def OclValid_def true_def OclSelf_at_pre_def OclSelf_at_post_def\n                  def_x[simplified OclValid_def])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n     oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n     P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n     P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>) \\<and>\n    ((oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n      oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n     oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n     P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n     P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>)", "apply(rule conjI, rule impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<Longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>\n 2. (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(rule_tac f = \"\\<lambda>x. P \\<lceil>x\\<rceil>\" in arg_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<Longrightarrow>\n    heap (fst \\<tau>) (oid_of (x \\<tau>)) =\n    heap (snd \\<tau>) (oid_of (x \\<tau>))\n 2. (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(insert modifiesclause[simplified OclIsModifiedOnly_def OclValid_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n             oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>));\n     (case \\<tau> of\n      (\\<sigma>, \\<sigma>') \\<Rightarrow>\n        let X' = oid_of `\n                 \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n            S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n        in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n               (\\<sigma>, \\<sigma>') =\n              true (\\<sigma>, \\<sigma>') \\<and>\n              (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n           (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                  x \\<noteq> null)\n           then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                     heap \\<sigma> x =\n                                     heap \\<sigma>' x\\<rfloor>\\<rfloor>\n           else invalid (\\<sigma>, \\<sigma>')) =\n     true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> heap (fst \\<tau>) (oid_of (x \\<tau>)) =\n                      heap (snd \\<tau>) (oid_of (x \\<tau>))\n 2. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(case_tac \\<tau>, rename_tac \\<sigma> \\<sigma>', simp split: if_split_asm)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(subst (asm) (2) UML_Set.OclExcluding_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (if (\\<delta> X) (\\<sigma>, \\<sigma>') = true (\\<sigma>, \\<sigma>') \\<and>\n      (\\<upsilon> x) (\\<sigma>, \\<sigma>') = true (\\<sigma>, \\<sigma>')\n   then Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                           {x (\\<sigma>, \\<sigma>')}\\<rfloor>\\<rfloor>\n   else \\<bottom>)\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(drule foundation5[simplified OclValid_def true_def], simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                      {x (\\<sigma>,\n                          \\<sigma>')}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(subst (asm) Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>(\\<delta> X) (\\<sigma>, \\<sigma>') =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n                (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n     {x (\\<sigma>, \\<sigma>')}\\<rfloor>\\<rfloor> =\n                         \\<bottom> \\<or>\n                         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n     {x (\\<sigma>, \\<sigma>')}\\<rfloor>\\<rfloor> =\n                         null \\<or>\n                         (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                    (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n   {x (\\<sigma>, \\<sigma>')}.\n                             x \\<noteq> \\<bottom>)\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X\n(\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                   {x (\\<sigma>,\n                       \\<sigma>')}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 4. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(rule disjI2)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>(\\<delta> X) (\\<sigma>, \\<sigma>') =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n                (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                   (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n  {x (\\<sigma>, \\<sigma>')}.\n                            x \\<noteq> \\<bottom>\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X\n(\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                   {x (\\<sigma>,\n                       \\<sigma>')}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 4. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply (metis (hide_lams, no_types) DiffD1 OclValid_def Set_inv_lemma def_x\n                                        foundation16 foundation18')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                    (X\n(\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                   {x (\\<sigma>,\n                       \\<sigma>')}\\<rfloor>\\<rfloor>\\<rceil>\\<rceil>.\n           heap \\<sigma> x = heap \\<sigma>' x;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        \\<forall>x\\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                       oid_of `\n                       (\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n   (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n                        {x (\\<sigma>, \\<sigma>')}).\n           heap \\<sigma> x = heap \\<sigma>' x;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(erule_tac x = \"oid_of (x (\\<sigma>, \\<sigma>'))\" in ballE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n        heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        oid_of (x (\\<sigma>, \\<sigma>'))\n        \\<notin> dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n                 oid_of `\n                 (\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                   (X (\\<sigma>,\n \\<sigma>'))\\<rceil>\\<rceil> -\n                  {x (\\<sigma>, \\<sigma>')})\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 4. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply simp+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        \\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n  (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n    (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n           x \\<noteq> null;\n        (\\<delta> X) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n        (\\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        oid_of (x (\\<sigma>, \\<sigma>'))\n        \\<in> oid_of `\n              (\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                (X (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil> -\n               {x (\\<sigma>, \\<sigma>')})\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 3. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply (metis (hide_lams, no_types)\n                 DiffD1 image_iff image_insert insert_Diff_single insert_absorb oid_is_typerepr)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma> \\<sigma>'.\n       \\<lbrakk>\\<tau> = (\\<sigma>, \\<sigma>');\n        (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n        null\n        \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                               (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                 (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>);\n        oid_of (x (\\<sigma>, \\<sigma>')) \\<in> dom (heap \\<sigma>');\n        invalid (\\<sigma>, \\<sigma>') =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> heap \\<sigma> (oid_of (x (\\<sigma>, \\<sigma>'))) =\n                         heap \\<sigma>' (oid_of (x (\\<sigma>, \\<sigma>')))\n 2. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       let X' = oid_of `\n                \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                                   (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>;\n           S = dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') - X'\n       in if (\\<delta> X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))\n              (\\<sigma>, \\<sigma>') =\n             true (\\<sigma>, \\<sigma>') \\<and>\n             (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n        (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n          (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                 x \\<noteq> null)\n          then \\<lfloor>\\<lfloor>\\<forall>x\\<in>S.\n                                    heap \\<sigma> x =\n                                    heap \\<sigma>' x\\<rfloor>\\<rfloor>\n          else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "apply(simp add: invalid_def bot_option_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<tau> of\n     (\\<sigma>, \\<sigma>') \\<Rightarrow>\n       if (\\<delta> X and \\<upsilon> x) (\\<sigma>, \\<sigma>') =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (\\<forall>x\\<in>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n       (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n              x \\<noteq> null)\n       then \\<lfloor>\\<lfloor>\\<forall>x\n \\<in>dom (heap \\<sigma>) \\<inter> dom (heap \\<sigma>') -\n      oid_of `\n      \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x)\n                         (\\<sigma>, \\<sigma>'))\\<rceil>\\<rceil>.\n                                 heap \\<sigma> x =\n                                 heap \\<sigma>' x\\<rfloor>\\<rfloor>\n       else invalid (\\<sigma>, \\<sigma>')) =\n    true \\<tau> \\<Longrightarrow>\n    (oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<longrightarrow>\n     oid_of (x \\<tau>) \\<notin> dom (heap (snd \\<tau>))) \\<longrightarrow>\n    oid_of (x \\<tau>) \\<in> dom (heap (fst \\<tau>)) \\<and>\n    oid_of (x \\<tau>) \\<in> dom (heap (snd \\<tau>)) \\<longrightarrow>\n    P \\<lceil>heap (fst \\<tau>) (oid_of (x \\<tau>))\\<rceil> =\n    P \\<lceil>heap (snd \\<tau>) (oid_of (x \\<tau>))\\<rceil>", "by blast"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n  \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "qed(simp add: OclSelf_at_post_def OclSelf_at_pre_def OclValid_def StrongEq_def true_def)+"], ["", "text\\<open>As corollary, the framing property can be expressed with only the strong equality\nas comparison operator.\\<close>"], ["", "theorem framing':\n  assumes wff : \"WFF \\<tau>\"\n  assumes modifiesclause:\"\\<tau> \\<Turnstile> (X->excluding\\<^sub>S\\<^sub>e\\<^sub>t(x))->oclIsModifiedOnly()\"\n  and oid_is_typerepr : \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a| not (x \\<triangleq> a))\"\n  and oid_preserve: \"\\<And>x. x \\<in> ran (heap(fst \\<tau>)) \\<or> x \\<in> ran (heap(snd \\<tau>)) \\<Longrightarrow>\n                          oid_of (H x) = oid_of x\"\n  and xy_together:\n  \"\\<tau> \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(y | (H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)) or\n                     (H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(y)))\"\n  shows \"\\<tau> \\<Turnstile> (x @pre P  \\<triangleq>  (x @post P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "have def_X : \"\\<tau> \\<Turnstile> \\<delta> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X", "apply(insert oid_is_typerepr, simp add: UML_Set.OclForall_def OclValid_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> X) \\<tau> \\<noteq> \\<bottom>;\n     \\<bottom> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False", "by(simp add: bot_option_def true_def)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> X\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(case_tac \"\\<tau> \\<Turnstile> \\<delta> x\", drule foundation20)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(rule framing[OF modifiesclause])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow>\n    \\<tau>\n     \\<Turnstile> X->forAll\\<^sub>S\\<^sub>e\\<^sub>t(a|not\n                 (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                   x a))\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(rule OclForall_cong'[OF _ oid_is_typerepr xy_together], rename_tac y)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> not\n  (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n    (\\<lambda>\\<tau>. y))\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(cut_tac Set_inv_lemma'[OF def_X])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. ?e9 y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> not\n  (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n    (\\<lambda>\\<tau>. y))\n 2. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y)\\<rbrakk>\n       \\<Longrightarrow> ?e9 y\n                         \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 3. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "prefer 2"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y)\\<rbrakk>\n       \\<Longrightarrow> ?e9 y\n                         \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n          (X \\<tau>)\\<rceil>\\<rceil>\n 2. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. ?e9 y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> not\n  (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n    (\\<lambda>\\<tau>. y))\n 3. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply assumption"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> not\n  (StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t x\n    (\\<lambda>\\<tau>. y))\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(rule OclNot_contrapos_nn, simp add: StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_def)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> (\\<lambda>\\<tau>.\n              if (\\<upsilon> x) \\<tau> = true \\<tau> \\<and>\n                 (\\<upsilon> (\\<lambda>\\<tau>. y)) \\<tau> = true \\<tau>\n              then if x \\<tau> = null \\<or> y = null\n                   then \\<lfloor>\\<lfloor>x \\<tau> = null \\<and>\n    y = null\\<rfloor>\\<rfloor>\n                   else \\<lfloor>\\<lfloor>oid_of (x \\<tau>) =\n    oid_of y\\<rfloor>\\<rfloor>\n              else invalid \\<tau>)\n 2. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> not (?B10 y)\n 3. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. y);\n        \\<tau>\n         \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                       x (\\<lambda>\\<tau>. y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> ?B10 y\n 4. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(simp add: OclValid_def, subst cp_defined, simp,\n           assumption)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n        y \\<in> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (X \\<tau>)\\<rceil>\\<rceil>;\n        \\<tau> \\<Turnstile> not (x \\<triangleq> (\\<lambda>\\<tau>. y));\n        \\<tau>\n         \\<Turnstile> H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n y) or\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(x) and\n                      H .allInstances@pre()->includes\\<^sub>S\\<^sub>e\\<^sub>t(\\<lambda>\\<tau>.\n     y);\n        \\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. y);\n        \\<tau>\n         \\<Turnstile> StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t\n                       x (\\<lambda>\\<tau>. y)\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> x \\<triangleq> (\\<lambda>\\<tau>. y)\n 2. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "apply(rule StrictRefEq\\<^sub>O\\<^sub>b\\<^sub>j\\<^sub>e\\<^sub>c\\<^sub>t_vs_StrongEq''[THEN iffD1, OF wff _ _ oid_preserve], assumption+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP", "by(simp add: OclSelf_at_post_def OclSelf_at_pre_def OclValid_def StrongEq_def true_def)+"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> x@preP \\<triangleq> x@postP\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>Miscellaneous\\<close>"], ["", "lemma pre_post_new: \"\\<tau> \\<Turnstile> (x .oclIsNew()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x.oclIsNew() \\<Longrightarrow>\n    \\<tau> |\\<noteq> \\<upsilon> x@preH1 \\<and>\n    \\<tau> |\\<noteq> \\<upsilon> x@postH2", "by(simp add: OclIsNew_def OclSelf_at_pre_def OclSelf_at_post_def\n             OclValid_def StrongEq_def true_def false_def\n             bot_option_def invalid_def bot_fun_def valid_def\n      split: if_split_asm)"], ["", "lemma pre_post_old: \"\\<tau> \\<Turnstile> (x .oclIsDeleted()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x.oclIsDeleted() \\<Longrightarrow>\n    \\<tau> |\\<noteq> \\<upsilon> x@preH1 \\<and>\n    \\<tau> |\\<noteq> \\<upsilon> x@postH2", "by(simp add: OclIsDeleted_def OclSelf_at_pre_def OclSelf_at_post_def\n             OclValid_def StrongEq_def true_def false_def\n             bot_option_def invalid_def bot_fun_def valid_def\n      split: if_split_asm)"], ["", "lemma pre_post_absent: \"\\<tau> \\<Turnstile> (x .oclIsAbsent()) \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1)) \\<and> \\<not> (\\<tau> \\<Turnstile> \\<upsilon>(x @post H2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x.oclIsAbsent() \\<Longrightarrow>\n    \\<tau> |\\<noteq> \\<upsilon> x@preH1 \\<and>\n    \\<tau> |\\<noteq> \\<upsilon> x@postH2", "by(simp add: OclIsAbsent_def OclSelf_at_pre_def OclSelf_at_post_def\n             OclValid_def StrongEq_def true_def false_def\n             bot_option_def invalid_def bot_fun_def valid_def\n      split: if_split_asm)"], ["", "lemma pre_post_maintained: \"(\\<tau> \\<Turnstile> \\<upsilon>(x @pre H1) \\<or> \\<tau> \\<Turnstile> \\<upsilon>(x @post H2)) \\<Longrightarrow> \\<tau> \\<Turnstile> (x .oclIsMaintained())\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> x@preH1 \\<or>\n    \\<tau> \\<Turnstile> \\<upsilon> x@postH2 \\<Longrightarrow>\n    \\<tau> \\<Turnstile> x.oclIsMaintained()", "by(simp add: OclIsMaintained_def OclSelf_at_pre_def OclSelf_at_post_def\n             OclValid_def StrongEq_def true_def false_def\n             bot_option_def invalid_def bot_fun_def valid_def\n      split: if_split_asm)"], ["", "lemma pre_post_maintained':\n\"\\<tau> \\<Turnstile> (x .oclIsMaintained()) \\<Longrightarrow> (\\<tau> \\<Turnstile> \\<upsilon>(x @pre (Some o H1)) \\<and> \\<tau> \\<Turnstile> \\<upsilon>(x @post (Some o H2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x.oclIsMaintained() \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> x@preSome \\<circ> H1 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> x@postSome \\<circ> H2", "by(simp add: OclIsMaintained_def OclSelf_at_pre_def OclSelf_at_post_def\n             OclValid_def StrongEq_def true_def false_def\n             bot_option_def invalid_def bot_fun_def valid_def\n      split: if_split_asm)"], ["", "lemma framing_same_state: \"(\\<sigma>, \\<sigma>) \\<Turnstile> (x @pre H  \\<triangleq>  (x @post H))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma>, \\<sigma>) \\<Turnstile> x@preH \\<triangleq> x@postH", "by(simp add: OclSelf_at_pre_def OclSelf_at_post_def OclValid_def StrongEq_def)"], ["", "section\\<open>Accessors on Object\\<close>"], ["", "subsection\\<open>Definition\\<close>"], ["", "definition \"select_object mt incl smash deref l = smash (foldl incl mt (map deref l))\n \\<comment> \\<open>smash returns null with \\<open>mt\\<close> in input (in this case, object contains null pointer)\\<close>\""], ["", "text\\<open>The continuation \\<open>f\\<close> is usually instantiated with a smashing\nfunction which is either the identity @{term id} or, for \\inlineocl{0..1} cardinalities\nof associations, the @{term OclANY}-selector which also handles the\n@{term null}-cases appropriately. A standard use-case for this combinator\nis for example:\\<close>"], ["", "term \"(select_object mtSet UML_Set.OclIncluding UML_Set.OclANY f  l oid )::('\\<AA>, 'a::null)val\""], ["", "definition \"select_object\\<^sub>S\\<^sub>e\\<^sub>t = select_object mtSet UML_Set.OclIncluding id\""], ["", "definition \"select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set = UML_Set.OclANY (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\""], ["", "definition \"select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set = \n (let s = select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set in\n  if s->size\\<^sub>S\\<^sub>e\\<^sub>t() \\<triangleq> \\<one> then\n    s->any\\<^sub>S\\<^sub>e\\<^sub>t()\n  else\n    \\<bottom>\n  endif)\""], ["", "definition \"select_object\\<^sub>S\\<^sub>e\\<^sub>q = select_object mtSequence UML_Sequence.OclIncluding id\""], ["", "definition \"select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set = UML_Sequence.OclANY (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\""], ["", "definition \"select_object\\<^sub>P\\<^sub>a\\<^sub>i\\<^sub>r f1 f2 = (\\<lambda>(a,b). OclPair (f1 a) (f2 b))\""], ["", "subsection\\<open>Validity and Definedness Properties\\<close>"], ["", "lemma select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes \"list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l\"\n shows \"\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Sequence.OclIncluding Sequence{} l \\<tau>)\\<rceil>\\<rceil> = List.map (\\<lambda>f. f \\<tau>) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Sequence.OclIncluding Sequence{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    map (\\<lambda>f. f \\<tau>) l", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Sequence.OclIncluding Sequence{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    map (\\<lambda>f. f \\<tau>) l", "have def_fold: \"\\<And>l. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l \\<Longrightarrow>\n            \\<tau> \\<Turnstile> (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        l \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<delta> foldl UML_Sequence.OclIncluding Sequence{} l", "apply(rule rev_induct[where P = \"\\<lambda>l. list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l \\<longrightarrow> \\<tau> \\<Turnstile> (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} l)\", THEN mp], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x xs.\n       \\<lbrakk>list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n         xs \\<longrightarrow>\n        \\<tau>\n         \\<Turnstile> \\<delta> foldl UML_Sequence.OclIncluding Sequence{}\n                                xs\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n                          (xs @ [x]) \\<longrightarrow>\n                         \\<tau>\n                          \\<Turnstile> \\<delta> foldl\n           UML_Sequence.OclIncluding Sequence{} (xs @ [x])\n 2. \\<And>l.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        l \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "by(simp add: foundation10')"], ["proof (state)\nthis:\n  list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n   ?l \\<Longrightarrow>\n  \\<tau> \\<Turnstile> \\<delta> foldl UML_Sequence.OclIncluding Sequence{} ?l\n\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Sequence.OclIncluding Sequence{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    map (\\<lambda>f. f \\<tau>) l", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Sequence.OclIncluding Sequence{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    map (\\<lambda>f. f \\<tau>) l", "apply(rule rev_induct[where P = \"\\<lambda>l. list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l \\<longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Sequence.OclIncluding Sequence{} l \\<tau>)\\<rceil>\\<rceil> = List.map (\\<lambda>f. f \\<tau>) l\", THEN mp], simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (Sequence{} \\<tau>)\\<rceil>\\<rceil> =\n    []\n 2. \\<And>x xs.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        xs \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Sequence.OclIncluding Sequence{} xs\n                          \\<tau>)\\<rceil>\\<rceil> =\n       map (\\<lambda>f. f \\<tau>) xs \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        (xs @ [x]) \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Sequence.OclIncluding Sequence{}\n                          (xs @ [x]) \\<tau>)\\<rceil>\\<rceil> =\n       map (\\<lambda>f. f \\<tau>) (xs @ [x])\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: mtSequence_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>\\<lfloor>[]\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> =\n    []\n 2. \\<And>x xs.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        xs \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Sequence.OclIncluding Sequence{} xs\n                          \\<tau>)\\<rceil>\\<rceil> =\n       map (\\<lambda>f. f \\<tau>) xs \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        (xs @ [x]) \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Sequence.OclIncluding Sequence{}\n                          (xs @ [x]) \\<tau>)\\<rceil>\\<rceil> =\n       map (\\<lambda>f. f \\<tau>) (xs @ [x])\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, (simp | intro impI)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (foldl UML_Sequence.OclIncluding Sequence{}\n      xs->including\\<^sub>S\\<^sub>e\\<^sub>q(x)\n      \\<tau>)\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 2. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: UML_Sequence.OclIncluding_def, intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>map (\\<lambda>f. f \\<tau>) xs @\n                        [x \\<tau>]\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp, (rule disjI2)+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> x \\<tau> \\<noteq> \\<bottom> \\<and>\n                         (\\<forall>x\\<in>set xs.\n                             x \\<tau> \\<noteq> \\<bottom>)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>map\n                      (\\<lambda>f. f \\<tau>) xs @\n                     [x \\<tau>]\\<rfloor>\\<rfloor>\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 3. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 4. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: list_all_iff foundation18', simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Sequence.OclIncluding Sequence{}\n                                   xs \\<tau>)\\<rceil>\\<rceil> =\n                map (\\<lambda>f. f \\<tau>) xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Sequence.OclIncluding Sequence{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         map (\\<lambda>f. f \\<tau>) xs @ [x \\<tau>]\n 2. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst (asm) def_fold[simplified (no_asm) OclValid_def], simp, simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "by (rule assms)"], ["proof (state)\nthis:\n  \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                   (foldl UML_Sequence.OclIncluding Sequence{} l\n                     \\<tau>)\\<rceil>\\<rceil> =\n  map (\\<lambda>f. f \\<tau>) l\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes \"list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l\"\n shows \"\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Set.OclIncluding Set{} l \\<tau>)\\<rceil>\\<rceil> = set (List.map (\\<lambda>f. f \\<tau>) l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Set.OclIncluding Set{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    set (map (\\<lambda>f. f \\<tau>) l)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Set.OclIncluding Set{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    set (map (\\<lambda>f. f \\<tau>) l)", "have def_fold: \"\\<And>l. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l \\<Longrightarrow>\n            \\<tau> \\<Turnstile> (\\<delta> foldl UML_Set.OclIncluding Set{} l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        l \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{} l", "apply(rule rev_induct[where P = \"\\<lambda>l. list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l \\<longrightarrow> \\<tau> \\<Turnstile> (\\<delta> foldl UML_Set.OclIncluding Set{} l)\", THEN mp], simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>l x xs.\n       \\<lbrakk>list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n         xs \\<longrightarrow>\n        \\<tau>\n         \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{} xs\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n                          (xs @ [x]) \\<longrightarrow>\n                         \\<tau>\n                          \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding\n           Set{} (xs @ [x])\n 2. \\<And>l.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        l \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "by(simp add: foundation10')"], ["proof (state)\nthis:\n  list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n   ?l \\<Longrightarrow>\n  \\<tau> \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{} ?l\n\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Set.OclIncluding Set{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    set (map (\\<lambda>f. f \\<tau>) l)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (foldl UML_Set.OclIncluding Set{} l\n                       \\<tau>)\\<rceil>\\<rceil> =\n    set (map (\\<lambda>f. f \\<tau>) l)", "apply(rule rev_induct[where P = \"\\<lambda>l. list_all (\\<lambda>f. (\\<tau> \\<Turnstile> \\<upsilon> f)) l \\<longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (foldl UML_Set.OclIncluding Set{} l \\<tau>)\\<rceil>\\<rceil> = set (List.map (\\<lambda>f. f \\<tau>) l)\", THEN mp], simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (Set{} \\<tau>)\\<rceil>\\<rceil> =\n    {}\n 2. \\<And>x xs.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        xs \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Set.OclIncluding Set{} xs\n                          \\<tau>)\\<rceil>\\<rceil> =\n       set (map (\\<lambda>f. f \\<tau>) xs) \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        (xs @ [x]) \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Set.OclIncluding Set{} (xs @ [x])\n                          \\<tau>)\\<rceil>\\<rceil> =\n       set (map (\\<lambda>f. f \\<tau>) (xs @ [x]))\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: mtSet_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                       \\<lfloor>\\<lfloor>{}\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> =\n    {}\n 2. \\<And>x xs.\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        xs \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Set.OclIncluding Set{} xs\n                          \\<tau>)\\<rceil>\\<rceil> =\n       set (map (\\<lambda>f. f \\<tau>) xs) \\<Longrightarrow>\n       list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n        (xs @ [x]) \\<longrightarrow>\n       \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                        (foldl UML_Set.OclIncluding Set{} (xs @ [x])\n                          \\<tau>)\\<rceil>\\<rceil> =\n       set (map (\\<lambda>f. f \\<tau>) (xs @ [x]))\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, (simp | intro impI)+)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (foldl UML_Set.OclIncluding Set{}\n      xs->including\\<^sub>S\\<^sub>e\\<^sub>t(x)\n      \\<tau>)\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 2. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: UML_Set.OclIncluding_def, intro conjI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n      \\<lfloor>\\<lfloor>insert (x \\<tau>)\n                         ((\\<lambda>f. f \\<tau>) `\n                          set xs)\\<rfloor>\\<rfloor>)\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 3. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp, (rule disjI2)+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> x \\<tau> \\<noteq> \\<bottom> \\<and>\n                         (\\<forall>x\\<in>set xs.\n                             x \\<tau> \\<noteq> \\<bottom>)\n 2. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<and>\n        (\\<upsilon> x) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>\\<lfloor>\\<lfloor>insert (x \\<tau>)\n                      ((\\<lambda>f. f \\<tau>) `\n                       set xs)\\<rfloor>\\<rfloor>\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 3. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 4. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(simp add: list_all_iff foundation18', simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                                 (foldl UML_Set.OclIncluding Set{} xs\n                                   \\<tau>)\\<rceil>\\<rceil> =\n                (\\<lambda>f. f \\<tau>) ` set xs;\n        list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) xs \\<and>\n        \\<tau> \\<Turnstile> \\<upsilon> x;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} xs) \\<tau> =\n        true \\<tau> \\<longrightarrow>\n        (\\<upsilon> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n    (invalid \\<tau>)\\<rceil>\\<rceil> =\n                         insert (x \\<tau>) ((\\<lambda>f. f \\<tau>) ` set xs)\n 2. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "apply(subst (asm) def_fold[simplified (no_asm) OclValid_def], simp, simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f) l", "by (rule assms)"], ["proof (state)\nthis:\n  \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                   (foldl UML_Set.OclIncluding Set{} l\n                     \\<tau>)\\<rceil>\\<rceil> =\n  set (map (\\<lambda>f. f \\<tau>) l)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes \"\\<tau> \\<Turnstile> \\<upsilon> (foldl UML_Sequence.OclIncluding Sequence{} (List.map (f p) s_set))\"\n shows \"list_all (\\<lambda>x. (\\<tau> \\<Turnstile> \\<upsilon> (f p x))) s_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) s_set", "apply(rule rev_induct[where P = \"\\<lambda>s_set. \\<tau> \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{} (List.map (f p) s_set) \\<longrightarrow> list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) s_set\", THEN mp])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                              (map (f p) []) \\<longrightarrow>\n    list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) []\n 2. \\<And>x xs.\n       \\<tau>\n        \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                                 (map (f p) xs) \\<longrightarrow>\n       list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n        xs \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                                 (map (f p) (xs @ [x])) \\<longrightarrow>\n       list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n        (xs @ [x])\n 3. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                              (map (f p) s_set)", "apply(simp, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding\n    Sequence{} (map (f p) xs)->including\\<^sub>S\\<^sub>e\\<^sub>q(f p x);\n        \\<tau>\n         |\\<noteq> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                               (map (f p) xs)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n                          xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding\n    Sequence{} (map (f p) xs)->including\\<^sub>S\\<^sub>e\\<^sub>q(f p x);\n        \\<tau>\n         |\\<noteq> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                               (map (f p) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> f p x\n 3. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding\n    Sequence{} (map (f p) xs)->including\\<^sub>S\\<^sub>e\\<^sub>q(f p x);\n        list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n         xs\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> f p x\n 4. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                              (map (f p) s_set)", "apply (metis (hide_lams, mono_tags) UML_Sequence.OclIncluding.def_valid_then_def UML_Sequence.OclIncluding.defined_args_valid foundation20)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Sequence.OclIncluding Sequence{}\n                              (map (f p) s_set)", "by(simp add: assms)"], ["", "lemma fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes \"\\<tau> \\<Turnstile> \\<upsilon> (foldl UML_Set.OclIncluding Set{} (List.map (f p) s_set))\"\n shows \"list_all (\\<lambda>x. (\\<tau> \\<Turnstile> \\<upsilon> (f p x))) s_set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) s_set", "apply(rule rev_induct[where P = \"\\<lambda>s_set. \\<tau> \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{} (List.map (f p) s_set) \\<longrightarrow> list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) s_set\", THEN mp])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                              (map (f p) []) \\<longrightarrow>\n    list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x) []\n 2. \\<And>x xs.\n       \\<tau>\n        \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                                 (map (f p) xs) \\<longrightarrow>\n       list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n        xs \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                                 (map (f p) (xs @ [x])) \\<longrightarrow>\n       list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n        (xs @ [x])\n 3. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                              (map (f p) s_set)", "apply(simp, auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{}\n  (map (f p) xs) and\n                              \\<upsilon> f p x;\n        \\<tau>\n         |\\<noteq> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                               (map (f p) xs)\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n                          xs\n 2. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{}\n  (map (f p) xs) and\n                              \\<upsilon> f p x;\n        \\<tau>\n         |\\<noteq> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                               (map (f p) xs)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> f p x\n 3. \\<And>x xs.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> foldl UML_Set.OclIncluding Set{}\n  (map (f p) xs) and\n                              \\<upsilon> f p x;\n        list_all (\\<lambda>x. \\<tau> \\<Turnstile> \\<upsilon> f p x)\n         xs\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> f p x\n 4. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                              (map (f p) s_set)", "apply (metis (hide_lams, mono_tags) foundation10' foundation20)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> \\<upsilon> foldl UML_Set.OclIncluding Set{}\n                              (map (f p) s_set)", "by(simp add: assms)"], ["", "lemma select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"s_set \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_set \\<noteq> []", "apply(insert def_sel, case_tac s_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau>\n              \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q\n                                     f s_set;\n     s_set = []\\<rbrakk>\n    \\<Longrightarrow> s_set \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "apply(simp add: select_object_any\\<^sub>S\\<^sub>e\\<^sub>q_def UML_Sequence.OclANY_def select_object\\<^sub>S\\<^sub>e\\<^sub>q_def select_object_def\n                  defined_def OclValid_def\n                  false_def true_def bot_fun_def bot_option_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>s_set = []; Sequence{} \\<tau> \\<noteq> invalid \\<tau>;\n     (case \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (Sequence{} \\<tau>)\\<rceil>\\<rceil> of\n      [] \\<Rightarrow> \\<bottom>\n      | a # list \\<Rightarrow> hd (a # list)) \\<noteq>\n     \\<bottom> \\<and>\n     (case \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (Sequence{} \\<tau>)\\<rceil>\\<rceil> of\n      [] \\<Rightarrow> \\<bottom>\n      | a # list \\<Rightarrow> hd (a # list)) \\<noteq>\n     null \\<tau>\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "apply(simp add: mtSequence_def, subst (asm) Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inverse, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "by(simp)"], ["", "lemma (*select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>t:*)\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"s_set \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_set \\<noteq> []", "apply(insert def_sel, case_tac s_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau>\n              \\<Turnstile> \\<delta> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t\n                                     f s_set;\n     s_set = []\\<rbrakk>\n    \\<Longrightarrow> s_set \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "apply(simp add: select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t_def UML_Sequence.OclANY_def select_object\\<^sub>S\\<^sub>e\\<^sub>t_def select_object_def\n                  defined_def OclValid_def\n                  false_def true_def bot_fun_def bot_option_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "by(simp)"], ["", "lemma select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"s_set \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s_set \\<noteq> []", "apply(insert def_sel, case_tac s_set)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau>\n              \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t\n                                     f s_set;\n     s_set = []\\<rbrakk>\n    \\<Longrightarrow> s_set \\<noteq> []\n 2. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "apply(simp add: select_object_any\\<^sub>S\\<^sub>e\\<^sub>t_def UML_Sequence.OclANY_def select_object\\<^sub>S\\<^sub>e\\<^sub>t_def select_object_def\n                  defined_def OclValid_def\n                  false_def true_def bot_fun_def bot_option_def\n                  OclInt0_def OclInt1_def StrongEq_def OclIf_def null_fun_def null_option_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> \\<delta> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t\n  f s_set;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> s_set \\<noteq> []", "by(simp)"], ["", "lemma select_object_any_exec0\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<triangleq> f (hd s_set))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                   s_set \\<triangleq>\n                  f (hd s_set)", "apply(insert def_sel[simplified foundation16],\n        simp add: select_object_any\\<^sub>S\\<^sub>e\\<^sub>q_def foundation22 UML_Sequence.OclANY_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<tau> \\<noteq>\n             invalid \\<tau>;\n     (case \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set\n                              \\<tau>)\\<rceil>\\<rceil> of\n      [] \\<Rightarrow> \\<bottom>\n      | a # list \\<Rightarrow> hd (a # list)) \\<noteq>\n     \\<bottom> \\<and>\n     (case \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                            (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set\n                              \\<tau>)\\<rceil>\\<rceil> of\n      [] \\<Rightarrow> \\<bottom>\n      | a # list \\<Rightarrow> hd (a # list)) \\<noteq>\n     null\\<rbrakk>\n    \\<Longrightarrow> (case \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n       (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set\n         \\<tau>)\\<rceil>\\<rceil> of\n                       [] \\<Rightarrow> \\<bottom>\n                       | a # list \\<Rightarrow> hd (a # list)) =\n                      f (hd s_set) \\<tau>", "apply(case_tac \"\\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<tau>)\\<rceil>\\<rceil>\", simp add: bot_option_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null;\n        \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (select_object\\<^sub>S\\<^sub>e\\<^sub>q f s_set\n                           \\<tau>)\\<rceil>\\<rceil> =\n        a # list\\<rbrakk>\n       \\<Longrightarrow> a = f (hd s_set) \\<tau>", "apply(simp add: select_object\\<^sub>S\\<^sub>e\\<^sub>q_def select_object_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>foldl UML_Sequence.OclIncluding Sequence{} (map f s_set)\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null;\n        \\<lceil>\\<lceil>Rep_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (foldl UML_Sequence.OclIncluding Sequence{}\n                           (map f s_set) \\<tau>)\\<rceil>\\<rceil> =\n        a # list\\<rbrakk>\n       \\<Longrightarrow> a = f (hd s_set) \\<tau>", "apply(subst (asm) select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>q)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a list.\n       \\<lbrakk>foldl UML_Sequence.OclIncluding Sequence{} (map f s_set)\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n                          (map f s_set)\n 2. \\<And>a list.\n       \\<lbrakk>foldl UML_Sequence.OclIncluding Sequence{} (map f s_set)\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null;\n        map (\\<lambda>f. f \\<tau>) (map f s_set) = a # list\\<rbrakk>\n       \\<Longrightarrow> a = f (hd s_set) \\<tau>", "apply(rule fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>q, simp add: foundation18' invalid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>foldl UML_Sequence.OclIncluding Sequence{} (map f s_set)\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null;\n        map (\\<lambda>f. f \\<tau>) (map f s_set) = a # list\\<rbrakk>\n       \\<Longrightarrow> a = f (hd s_set) \\<tau>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>foldl UML_Sequence.OclIncluding Sequence{} (map f s_set)\n                 \\<tau> \\<noteq>\n                invalid \\<tau>;\n        a \\<noteq> \\<bottom> \\<and> a \\<noteq> null;\n        map ((\\<lambda>f. f \\<tau>) \\<circ> f) s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> a = f (hd s_set) \\<tau>", "by(drule arg_cong[where f = hd], subst (asm) hd_map, simp add: select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>q[OF def_sel], simp)"], ["", "lemma select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>q:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set)\"\n shows \"\\<exists>e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f s_set \\<triangleq> f e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                      s_set \\<triangleq>\n                     f e", "apply(insert select_object_any_exec0\\<^sub>S\\<^sub>e\\<^sub>q[OF def_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                   s_set \\<triangleq>\n                  f (hd s_set) \\<Longrightarrow>\n    \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                      s_set \\<triangleq>\n                     f e", "apply(rule exI[where x = \"hd s_set\"], simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                   s_set \\<triangleq>\n                  f (hd s_set) \\<Longrightarrow>\n    List.member s_set (hd s_set)", "apply(case_tac s_set, simp add: select_object_any_defined\\<^sub>S\\<^sub>e\\<^sub>q[OF def_sel])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>\\<tau>\n                 \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>q f\n                               s_set \\<triangleq>\n                              f (hd s_set);\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> List.member s_set (hd s_set)", "by (metis list.sel member_rec(1))"], ["", "lemma (*select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>t:*)\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"\\<exists> e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<triangleq> f e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "have list_all_map: \"\\<And>P f l. list_all P (List.map f l) = list_all (P o f) l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P f l. list_all P (map f l) = list_all (P \\<circ> f) l", "by(induct_tac l, simp_all)"], ["proof (state)\nthis:\n  list_all ?P (map ?f ?l) = list_all (?P \\<circ> ?f) ?l\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "show ?thesis\n  when \"\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<tau>)\\<rceil>\\<rceil> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "apply(insert that def_sel[simplified foundation16],\n        simp add: select_object_any0\\<^sub>S\\<^sub>e\\<^sub>t_def foundation22 UML_Set.OclANY_def null_fun_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                                \\<tau>)\\<rceil>\\<rceil> =\n             z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     true \\<tau>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(simp add: select_object\\<^sub>S\\<^sub>e\\<^sub>t_def select_object_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (foldl UML_Set.OclIncluding Set{}\n                                (map f s_set) \\<tau>)\\<rceil>\\<rceil> =\n             z;\n     (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n     true \\<tau>;\n     (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n      foldl UML_Set.OclIncluding Set{}\n       (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(subst (asm) select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set))\n              \\<tau> =\n             true \\<tau>;\n     (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n      foldl UML_Set.OclIncluding Set{}\n       (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> list_all\n                       (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n                       (map f s_set)\n 2. \\<lbrakk>set (map (\\<lambda>f. f \\<tau>) (map f s_set)) = z;\n     (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n     true \\<tau>;\n     (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n      foldl UML_Set.OclIncluding Set{}\n       (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(rule fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>t, simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (map (\\<lambda>f. f \\<tau>) (map f s_set)) = z;\n     (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n     true \\<tau>;\n     (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n      foldl UML_Set.OclIncluding Set{}\n       (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x. f x \\<tau>) ` set s_set = z;\n     (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n     true \\<tau>;\n     (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n      foldl UML_Set.OclIncluding Set{}\n       (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     true \\<tau>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(case_tac s_set, simp, simp add: false_def true_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                z;\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{f a} (map f list))\n         \\<tau> =\n        true \\<tau>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{f a} (map f list) and\n         foldl UML_Set.OclIncluding Set{f a}\n          (map f list)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        true \\<tau>;\n        (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n        (SOME y. y \\<in> z) \\<noteq> null;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (a # list) e \\<and>\n                            (SOME y. y \\<in> z) = f e \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                z;\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{f a} (map f list))\n         \\<tau> =\n        true \\<tau>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{f a} (map f list) and\n         foldl UML_Set.OclIncluding Set{f a}\n          (map f list)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        true \\<tau>;\n        (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n        (SOME y. y \\<in> z) \\<noteq> null;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (a # list) e \\<and>\n                            (SOME y. y \\<in> z) = f e \\<tau>", "fix a l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                z;\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{f a} (map f list))\n         \\<tau> =\n        true \\<tau>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{f a} (map f list) and\n         foldl UML_Set.OclIncluding Set{f a}\n          (map f list)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        true \\<tau>;\n        (SOME y. y \\<in> z) \\<noteq> \\<bottom> \\<and>\n        (SOME y. y \\<in> z) \\<noteq> null;\n        s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (a # list) e \\<and>\n                            (SOME y. y \\<in> z) = f e \\<tau>", "show \"insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z \\<Longrightarrow>\n        \\<exists>e. List.member (a # l) e \\<and> (SOME y. y \\<in> z) = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    \\<exists>e.\n       List.member (a # l) e \\<and> (SOME y. y \\<in> z) = f e \\<tau>", "apply(rule list.induct[where P = \"\\<lambda>l. \\<forall>z a. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z \\<longrightarrow>\n        (\\<exists>e. List.member (a # l) e \\<and> ((SOME y. y \\<in> z) = f e \\<tau>))\", THEN spec, THEN spec, THEN mp], intro allI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member [xa] e \\<and>\n                            (SOME y. y \\<in> x) = f e \\<tau>\n 2. \\<And>x1 x2.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x xa.\n           insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2) =\n           x \\<longrightarrow>\n           (\\<exists>e.\n               List.member (xa # x2) e \\<and>\n               (SOME y. y \\<in> x) = f e \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa.\n                            insert (f xa \\<tau>)\n                             ((\\<lambda>x. f x \\<tau>) ` set (x1 # x2)) =\n                            x \\<longrightarrow>\n                            (\\<exists>e.\n                                List.member (xa # x1 # x2) e \\<and>\n                                (SOME y. y \\<in> x) = f e \\<tau>)\n 3. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member [xa] e \\<and>\n                            (SOME y. y \\<in> x) = f e \\<tau>\n 2. \\<And>x1 x2.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x xa.\n           insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2) =\n           x \\<longrightarrow>\n           (\\<exists>e.\n               List.member (xa # x2) e \\<and>\n               (SOME y. y \\<in> x) = f e \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa.\n                            insert (f xa \\<tau>)\n                             ((\\<lambda>x. f x \\<tau>) ` set (x1 # x2)) =\n                            x \\<longrightarrow>\n                            (\\<exists>e.\n                                List.member (xa # x1 # x2) e \\<and>\n                                (SOME y. y \\<in> x) = f e \\<tau>)\n 3. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "fix x xa"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x xa.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member [xa] e \\<and>\n                            (SOME y. y \\<in> x) = f e \\<tau>\n 2. \\<And>x1 x2.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x xa.\n           insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2) =\n           x \\<longrightarrow>\n           (\\<exists>e.\n               List.member (xa # x2) e \\<and>\n               (SOME y. y \\<in> x) = f e \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa.\n                            insert (f xa \\<tau>)\n                             ((\\<lambda>x. f x \\<tau>) ` set (x1 # x2)) =\n                            x \\<longrightarrow>\n                            (\\<exists>e.\n                                List.member (xa # x1 # x2) e \\<and>\n                                (SOME y. y \\<in> x) = f e \\<tau>)\n 3. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "show \"insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) = x \\<Longrightarrow> \\<exists>e. List.member [xa] e \\<and> (SOME y. y \\<in> x) = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n    x \\<Longrightarrow>\n    \\<exists>e. List.member [xa] e \\<and> (SOME y. y \\<in> x) = f e \\<tau>", "apply(rule exI[where x = xa], simp add: List.member_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f xa \\<tau>} = x \\<Longrightarrow> (SOME y. y \\<in> x) = f xa \\<tau>", "apply(subst some_equality[where a = \"f xa \\<tau>\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. {f xa \\<tau>} = x \\<Longrightarrow> f xa \\<tau> \\<in> x\n 2. \\<And>xb.\n       \\<lbrakk>{f xa \\<tau>} = x; xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xb = f xa \\<tau>\n 3. {f xa \\<tau>} = x \\<Longrightarrow> f xa \\<tau> = f xa \\<tau>", "apply (metis (mono_tags) insertI1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>xb.\n       \\<lbrakk>{f xa \\<tau>} = x; xb \\<in> x\\<rbrakk>\n       \\<Longrightarrow> xb = f xa \\<tau>\n 2. {f xa \\<tau>} = x \\<Longrightarrow> f xa \\<tau> = f xa \\<tau>", "apply (metis (mono_tags) empty_iff insert_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {f xa \\<tau>} = x \\<Longrightarrow> f xa \\<tau> = f xa \\<tau>", "by(simp)"], ["proof (state)\nthis:\n  insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n  x \\<Longrightarrow>\n  \\<exists>e. List.member [xa] e \\<and> (SOME y. y \\<in> x) = f e \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x xa.\n           insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2) =\n           x \\<longrightarrow>\n           (\\<exists>e.\n               List.member (xa # x2) e \\<and>\n               (SOME y. y \\<in> x) = f e \\<tau>)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x xa.\n                            insert (f xa \\<tau>)\n                             ((\\<lambda>x. f x \\<tau>) ` set (x1 # x2)) =\n                            x \\<longrightarrow>\n                            (\\<exists>e.\n                                List.member (xa # x1 # x2) e \\<and>\n                                (SOME y. y \\<in> x) = f e \\<tau>)\n 2. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "apply_end(intro allI impI, simp)"], ["proof (state)\nthis:\n  insert (f xa \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set []) =\n  x \\<Longrightarrow>\n  \\<exists>e. List.member [xa] e \\<and> (SOME y. y \\<in> x) = f e \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x xa.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x.\n           \\<exists>e.\n              List.member (x # x2) e \\<and>\n              (SOME y.\n                  y = f x \\<tau> \\<or>\n                  y \\<in> (\\<lambda>x. f x \\<tau>) ` set x2) =\n              f e \\<tau>;\n        insert (f xa \\<tau>)\n         (insert (f x1 \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2)) =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xa # x1 # x2) e \\<and>\n                            (SOME y. y \\<in> x) = f e \\<tau>\n 2. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "fix x list xa xb"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 x xa.\n       \\<lbrakk>insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z;\n        \\<forall>x.\n           \\<exists>e.\n              List.member (x # x2) e \\<and>\n              (SOME y.\n                  y = f x \\<tau> \\<or>\n                  y \\<in> (\\<lambda>x. f x \\<tau>) ` set x2) =\n              f e \\<tau>;\n        insert (f xa \\<tau>)\n         (insert (f x1 \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set x2)) =\n        x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xa # x1 # x2) e \\<and>\n                            (SOME y. y \\<in> x) = f e \\<tau>\n 2. insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) =\n    z \\<Longrightarrow>\n    insert (f a \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set l) = z", "show \" \\<forall>x. \\<exists>e. List.member (x # list) e \\<and> (SOME y. y = f x \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) = f e \\<tau> \\<Longrightarrow>\n       insert (f xb \\<tau>) (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) = xa \\<Longrightarrow>\n       \\<exists>e. List.member (xb # x # list) e \\<and> (SOME y. y \\<in> xa) = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply(case_tac \"x = xb\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa;\n     x = xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # xb # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply(erule allE[where x = xb])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n             xa;\n     x = xb;\n     \\<exists>e.\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # xb # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply(erule exE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                xa;\n        x = xb;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # xb # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                xa;\n        x = xb;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # xb # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n                xa;\n        x = xb;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # xb # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "show \"insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa \\<Longrightarrow>\n         x = xb \\<Longrightarrow>\n         List.member (xb # list) e \\<and> (SOME y. y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) = f e \\<tau> \\<Longrightarrow>\n         \\<exists>e. List.member (xb # xb # list) e \\<and> (SOME y. y \\<in> xa) = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) =\n             xa;\n     x = xb;\n     List.member (xb # list) e \\<and>\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # xb # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply(rule exI[where x = e], auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x = xb;\n     xa = insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list);\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> List.member (xb # xb # list) e", "by (metis member_rec(1))"], ["proof (state)\nthis:\n  \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa;\n   x = xb;\n   List.member (xb # list) e \\<and>\n   (SOME y.\n       y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n   f e \\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e.\n                       List.member (xb # xb # list) e \\<and>\n                       (SOME y. y \\<in> xa) = f e \\<tau>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply_end(case_tac \"List.member list x\")"], ["proof (state)\nthis:\n  \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa;\n   x = xb;\n   List.member (xb # list) e \\<and>\n   (SOME y.\n       y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n   f e \\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e.\n                       List.member (xb # xb # list) e \\<and>\n                       (SOME y. y \\<in> xa) = f e \\<tau>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; \\<not> List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply_end(erule allE[where x = xb])"], ["proof (state)\nthis:\n  \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa;\n   x = xb;\n   List.member (xb # list) e \\<and>\n   (SOME y.\n       y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n   f e \\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e.\n                       List.member (xb # xb # list) e \\<and>\n                       (SOME y. y \\<in> xa) = f e \\<tau>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>insert (f xb \\<tau>)\n              (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n             xa;\n     x \\<noteq> xb; List.member list x;\n     \\<exists>e.\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; \\<not> List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply_end(erule exE)"], ["proof (state)\nthis:\n  \\<lbrakk>insert (f xb \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list) = xa;\n   x = xb;\n   List.member (xb # list) e \\<and>\n   (SOME y.\n       y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n   f e \\<tau>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e.\n                       List.member (xb # xb # list) e \\<and>\n                       (SOME y. y \\<in> xa) = f e \\<tau>\n\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>)\n                 (insert (f x \\<tau>)\n                   ((\\<lambda>x. f x \\<tau>) ` set list)) =\n                xa;\n        x \\<noteq> xb; List.member list x;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # x # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; \\<not> List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "fix e"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>)\n                 (insert (f x \\<tau>)\n                   ((\\<lambda>x. f x \\<tau>) ` set list)) =\n                xa;\n        x \\<noteq> xb; List.member list x;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # x # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; \\<not> List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "let ?P = \"\\<lambda>y. y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>e.\n       \\<lbrakk>insert (f xb \\<tau>)\n                 (insert (f x \\<tau>)\n                   ((\\<lambda>x. f x \\<tau>) ` set list)) =\n                xa;\n        x \\<noteq> xb; List.member list x;\n        List.member (xb # list) e \\<and>\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member (xb # x # list) e \\<and>\n                            (SOME y. y \\<in> xa) = f e \\<tau>\n 2. \\<lbrakk>\\<forall>x.\n                \\<exists>e.\n                   List.member (x # list) e \\<and>\n                   (SOME y.\n                       y = f x \\<tau> \\<or>\n                       y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                   f e \\<tau>;\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n     xa;\n     x \\<noteq> xb; \\<not> List.member list x\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "show \"insert (f xb \\<tau>) (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) = xa \\<Longrightarrow>\n         x \\<noteq> xb \\<Longrightarrow>\n         List.member list x \\<Longrightarrow>\n         List.member (xb # list) e \\<and> (SOME y. y = f xb \\<tau> \\<or> y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) = f e \\<tau> \\<Longrightarrow>\n         \\<exists>e. List.member (xb # x # list) e \\<and> (SOME y. y \\<in> xa) = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>insert (f xb \\<tau>)\n              (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list)) =\n             xa;\n     x \\<noteq> xb; List.member list x;\n     List.member (xb # list) e \\<and>\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member (xb # x # list) e \\<and>\n                         (SOME y. y \\<in> xa) = f e \\<tau>", "apply(rule exI[where x = e], auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> List.member (xb # x # list) e\n 2. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>", "apply (metis member_rec(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>", "apply(subgoal_tac \"?P (f e \\<tau>)\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> = f xb \\<tau> \\<or>\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>\n 2. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> = f xb \\<tau> \\<or>\n                      f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> = f xb \\<tau> \\<or>\n                      f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\n 2. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> = f xb \\<tau> \\<or>\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>", "apply(case_tac \"xb = e\", simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     xb \\<noteq> e\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> = f xb \\<tau> \\<or>\n                      f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\n 2. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> = f xb \\<tau> \\<or>\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>", "apply (metis (mono_tags) image_eqI in_set_member member_rec(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> = f xb \\<tau> \\<or>\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> (SOME y.\n                          y = f xb \\<tau> \\<or>\n                          y = f x \\<tau> \\<or>\n                          y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n                      f e \\<tau>", "apply(rule someI2[where a = \"f e \\<tau>\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> = f xb \\<tau> \\<or>\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> = f xb \\<tau> \\<or>\n                      f e \\<tau> = f x \\<tau> \\<or>\n                      f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> xb; List.member list x;\n        xa =\n        insert (f xb \\<tau>)\n         (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n        List.member (xb # list) e;\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>;\n        f e \\<tau> = f xb \\<tau> \\<or>\n        f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list;\n        x = f xb \\<tau> \\<or>\n        x = f x \\<tau> \\<or>\n        x \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n       \\<Longrightarrow> x = f e \\<tau>", "apply(erule disjE, simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> = f xb \\<tau> \\<or>\n                      f e \\<tau> = f x \\<tau> \\<or>\n                      f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> xb; List.member list x;\n        xa =\n        insert (f xb \\<tau>)\n         (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n        List.member (xb # list) e;\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>;\n        f e \\<tau> = f xb \\<tau> \\<or>\n        f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list;\n        x = f xb \\<tau> \\<or>\n        x = f x \\<tau> \\<or>\n        x \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n       \\<Longrightarrow> x = f e \\<tau>", "apply(rule disjI2)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<noteq> xb; List.member list x;\n     xa =\n     insert (f xb \\<tau>)\n      (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n     List.member (xb # list) e;\n     (SOME y.\n         y = f xb \\<tau> \\<or>\n         y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n     f e \\<tau>;\n     f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n    \\<Longrightarrow> f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list\n 2. \\<And>x.\n       \\<lbrakk>x \\<noteq> xb; List.member list x;\n        xa =\n        insert (f xb \\<tau>)\n         (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n        List.member (xb # list) e;\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>;\n        f e \\<tau> = f xb \\<tau> \\<or>\n        f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list;\n        x = f xb \\<tau> \\<or>\n        x = f x \\<tau> \\<or>\n        x \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n       \\<Longrightarrow> x = f e \\<tau>", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<noteq> xb; List.member list x;\n        xa =\n        insert (f xb \\<tau>)\n         (insert (f x \\<tau>) ((\\<lambda>x. f x \\<tau>) ` set list));\n        List.member (xb # list) e;\n        (SOME y.\n            y = f xb \\<tau> \\<or>\n            y \\<in> (\\<lambda>x. f x \\<tau>) ` set list) =\n        f e \\<tau>;\n        f e \\<tau> = f xb \\<tau> \\<or>\n        f e \\<tau> \\<in> (\\<lambda>x. f x \\<tau>) ` set list;\n        x = f xb \\<tau> \\<or>\n        x = f x \\<tau> \\<or>\n        x \\<in> (\\<lambda>x. f x \\<tau>) ` set list\\<rbrakk>\n       \\<Longrightarrow> x = f e \\<tau>", "oops"], ["", "lemma select_object_any_exec\\<^sub>S\\<^sub>e\\<^sub>t:\n assumes def_sel: \"\\<tau> \\<Turnstile> \\<delta> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\"\n shows \"\\<exists> e. List.member s_set e \\<and> (\\<tau> \\<Turnstile> (select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<triangleq> f e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "have card_singl: \"\\<And>A a. finite A \\<Longrightarrow> card (insert a A) = 1 \\<Longrightarrow> A \\<subseteq> {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A a.\n       \\<lbrakk>finite A; card (insert a A) = 1\\<rbrakk>\n       \\<Longrightarrow> A \\<subseteq> {a}", "by (auto, metis Suc_inject card_Suc_eq card_eq_0_iff insert_absorb insert_not_empty singleton_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?A; card (insert ?a ?A) = 1\\<rbrakk>\n  \\<Longrightarrow> ?A \\<subseteq> {?a}\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "have list_same: \"\\<And>f s_set z' x. f ` set s_set = {z'} \\<Longrightarrow> List.member s_set x \\<Longrightarrow> f x = z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f s_set z' x.\n       \\<lbrakk>f ` set s_set = {z'}; List.member s_set x\\<rbrakk>\n       \\<Longrightarrow> f x = z'", "by (metis (full_types) empty_iff imageI in_set_member insert_iff)"], ["proof (state)\nthis:\n  \\<lbrakk>?f1 ` set ?s_set1 = {?z'1}; List.member ?s_set1 ?x1\\<rbrakk>\n  \\<Longrightarrow> ?f1 ?x1 = ?z'1\n\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "show ?thesis\n  when \"\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set \\<tau>)\\<rceil>\\<rceil> = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       List.member s_set e \\<and>\n       \\<tau>\n        \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                      s_set \\<triangleq>\n                     f e", "apply(insert that def_sel[simplified foundation16],\n        simp add: select_object_any\\<^sub>S\\<^sub>e\\<^sub>t_def foundation22\n                  Let_def null_fun_def bot_fun_def OclIf_def\n             split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                              (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                                \\<tau>)\\<rceil>\\<rceil> =\n             z;\n     (select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->size\\<^sub>S\\<^sub>e\\<^sub>t() \\<triangleq>\n      \\<one>)\n      \\<tau> =\n     true \\<tau>;\n     select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n      s_set->any\\<^sub>S\\<^sub>e\\<^sub>t()\n      \\<tau> \\<noteq>\n     \\<bottom> \\<and>\n     select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n      s_set->any\\<^sub>S\\<^sub>e\\<^sub>t()\n      \\<tau> \\<noteq>\n     null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n                          s_set->any\\<^sub>S\\<^sub>e\\<^sub>t()\n                          \\<tau> =\n                         f e \\<tau>", "apply(simp add: StrongEq_def OclInt1_def true_def UML_Set.OclSize_def\n                  bot_option_def UML_Set.OclANY_def null_fun_def\n                  split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(subgoal_tac \"\\<exists>z'. z = {z'}\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null; \\<exists>z'. z = {z'}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>\n 2. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z'. z = {z'}", "prefer 2"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null\\<rbrakk>\n    \\<Longrightarrow> \\<exists>z'. z = {z'}\n 2. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null; \\<exists>z'. z = {z'}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(rule finite.cases[where a = z], simp, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>A a.\n       \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        card (insert a A) = Suc 0;\n        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                           \\<tau>)\\<rceil>\\<rceil> =\n        insert a A;\n        (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (SOME y. y = a \\<or> y \\<in> A) \\<noteq> \\<bottom>;\n        (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n         select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n          s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (SOME y. y = a \\<or> y \\<in> A) \\<noteq> null; z = insert a A;\n        finite A\\<rbrakk>\n       \\<Longrightarrow> A \\<subseteq> {a}\n 2. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null; \\<exists>z'. z = {z'}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(rule card_singl, simp, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n              \\<tau> =\n             \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     finite z; card z = Suc 0;\n     \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                      (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                        \\<tau>)\\<rceil>\\<rceil> =\n     z;\n     (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> \\<bottom>;\n     (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n      select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n       s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n      \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n     (SOME y. y \\<in> z) \\<noteq> null; \\<exists>z'. z = {z'}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e.\n                         List.member s_set e \\<and>\n                         (SOME y. y \\<in> z) = f e \\<tau>", "apply(erule exE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z'.\n       \\<lbrakk>(\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set)\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                           \\<tau>)\\<rceil>\\<rceil> =\n        {z'};\n        (\\<upsilon> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set and\n         select_object\\<^sub>S\\<^sub>e\\<^sub>t f\n          s_set->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "apply(simp add: select_object\\<^sub>S\\<^sub>e\\<^sub>t_def select_object_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z'.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                         (foldl UML_Set.OclIncluding Set{} (map f s_set)\n                           \\<tau>)\\<rceil>\\<rceil> =\n        {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "apply(subst (asm) select_fold_exec\\<^sub>S\\<^sub>e\\<^sub>t)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>z'.\n       \\<lbrakk>(\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'};\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> list_all\n                          (\\<lambda>f. \\<tau> \\<Turnstile> \\<upsilon> f)\n                          (map f s_set)\n 2. \\<And>z'.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        set (map (\\<lambda>f. f \\<tau>) (map f s_set)) = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "apply(rule fold_val_elem\\<^sub>S\\<^sub>e\\<^sub>t, simp add: OclValid_def true_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z'.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        set (map (\\<lambda>f. f \\<tau>) (map f s_set)) = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "apply(simp add: comp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z'.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "apply(case_tac s_set, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>z' a list.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}; s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z' a list.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}; s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "fix z' a list"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>z' a list.\n       \\<lbrakk>(\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set))\n                 \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n        (\\<upsilon> foldl UML_Set.OclIncluding Set{} (map f s_set)) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> \\<bottom>;\n        (\\<delta> foldl UML_Set.OclIncluding Set{} (map f s_set) and\n         foldl UML_Set.OclIncluding Set{}\n          (map f s_set)->notEmpty\\<^sub>S\\<^sub>e\\<^sub>t())\n         \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        z' \\<noteq> null; z = {z'}; s_set = a # list\\<rbrakk>\n       \\<Longrightarrow> \\<exists>e.\n                            List.member s_set e \\<and> z' = f e \\<tau>", "show \"(\\<lambda>x. f x \\<tau>) ` set s_set = {z'} \\<Longrightarrow> s_set = a # list \\<Longrightarrow> \\<exists>e. List.member s_set e \\<and> z' = f e \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n     s_set = a # list\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. List.member s_set e \\<and> z' = f e \\<tau>", "apply(drule list_same[where x1 = a])"], ["proof (prove)\ngoal (2 subgoals):\n 1. s_set = a # list \\<Longrightarrow> List.member s_set a\n 2. \\<lbrakk>s_set = a # list; f a \\<tau> = z'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. List.member s_set e \\<and> z' = f e \\<tau>", "apply (metis member_rec(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s_set = a # list; f a \\<tau> = z'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>e. List.member s_set e \\<and> z' = f e \\<tau>", "by (metis (hide_lams, mono_tags) ListMem_iff elem in_set_member)"], ["proof (state)\nthis:\n  \\<lbrakk>(\\<lambda>x. f x \\<tau>) ` set s_set = {z'};\n   s_set = a # list\\<rbrakk>\n  \\<Longrightarrow> \\<exists>e. List.member s_set e \\<and> z' = f e \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                   (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                     \\<tau>)\\<rceil>\\<rceil> =\n  z \\<Longrightarrow>\n  \\<exists>e.\n     List.member s_set e \\<and>\n     \\<tau>\n      \\<Turnstile> select_object_any\\<^sub>S\\<^sub>e\\<^sub>t f\n                    s_set \\<triangleq>\n                   f e\n\ngoal (1 subgoal):\n 1. \\<lceil>\\<lceil>Rep_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n                     (select_object\\<^sub>S\\<^sub>e\\<^sub>t f s_set\n                       \\<tau>)\\<rceil>\\<rceil> =\n    ?z3", "qed blast+"], ["", "end"]]}