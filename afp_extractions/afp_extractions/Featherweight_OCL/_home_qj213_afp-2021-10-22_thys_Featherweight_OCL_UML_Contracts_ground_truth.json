{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_Contracts.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma strict0 [simp]: \"f invalid X = invalid\"", "lemma nullstrict0[simp]: \"f null X = invalid\"", "lemma cp0 : \"f self a1 \\<tau> = f (\\<lambda> _. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>\"", "theorem unfold' : \n      assumes context_ok:    \"cp E\"\n      and args_def_or_valid: \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> f_\\<upsilon> a1 \\<tau>\"\n      and pre_satisfied:     \"\\<tau> \\<Turnstile> PRE self a1\"\n      and post_satisfiable:  \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 (\\<lambda> _. res))\"\n      and sat_for_sols_post: \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1)\"", "lemma unfold2' :\n      assumes context_ok:      \"cp E\"\n      and args_def_or_valid:   \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (f_\\<upsilon> a1 \\<tau>)\"\n      and pre_satisfied:       \"\\<tau> \\<Turnstile> PRE self a1\"\n      and postsplit_satisfied: \"\\<tau> \\<Turnstile> POST' self a1\" (* split constraint holds on post-state *)\n      and post_decomposable  : \"\\<And> res. (POST self a1 res) = \n                                       ((POST' self a1)  and (res \\<triangleq> (BODY self a1)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1)) = (\\<tau> \\<Turnstile> E(BODY self a1))\"", "lemma cp_pre: \"cp self' \\<Longrightarrow>  cp (\\<lambda>X. PRE (self' X)  )\"", "lemma cp_post: \"cp self' \\<Longrightarrow> cp res'  \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (res' X))\"", "lemma cp [simp]:  \"cp self' \\<Longrightarrow>  cp res' \\<Longrightarrow> cp (\\<lambda>X. f (self' X) )\"", "lemmas unfold = unfold'[simplified]", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self\"\n      and                      \"\\<tau> \\<Turnstile> POST' self\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self res) = \n                                       ((POST' self)  and (res \\<triangleq> (BODY self)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self)) = (\\<tau> \\<Turnstile> E(BODY self))\"", "lemma strict1[simp]: \"f self invalid = invalid\"", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\"", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow>  cp (\\<lambda>X. PRE (self' X) (a1' X)  )\"", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (res' X))\"", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow>  cp res' \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X))\"", "lemmas unfold = unfold'", "lemmas unfold2 = unfold2'", "lemma strict0'[simp] : \"f invalid X Y = invalid\"", "lemma nullstrict0'[simp]: \"f null X Y = invalid\"", "lemma strict1[simp]: \"f self invalid Y = invalid\"", "lemma strict2[simp]: \"f self X invalid = invalid\"", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f X Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> X) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\"", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) )\"", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (a2' X) (res' X))\"", "lemma cp0' : \"f self a1 a2 \\<tau> = f (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) \\<tau>\"", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp res'\n                       \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X))\"", "theorem unfold : \n      assumes                \"cp E\"\n      and                    \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2)\"\n      and                    \"\\<tau> \\<Turnstile> PRE self a1 a2\"\n      and                    \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 a2 (\\<lambda> _. res))\"\n      and                    \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 a2 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1 a2)\"", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self a1 a2\"\n      and                      \"\\<tau> \\<Turnstile> POST' self a1 a2\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self a1 a2 res) = \n                                       ((POST' self a1 a2)  and (res \\<triangleq> (BODY self a1 a2)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1 a2)) = (\\<tau> \\<Turnstile> E(BODY self a1 a2))\"", "lemma strict0'[simp] : \"f invalid X Y Z = invalid\"", "lemma nullstrict0'[simp]: \"f null X Y Z = invalid\"", "lemma strict1[simp]: \"f self invalid Y Z = invalid\"", "lemma strict2[simp]: \"f self X invalid Z = invalid\"", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f W X Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> W) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> X) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\"", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2'\\<Longrightarrow> cp a3' \n                  \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) (a3' X) )\"", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp a3' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (a2' X) (a3' X)  (res' X))\"", "lemma cp0' : \"f self a1 a2 a3 \\<tau> = f (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) (\\<lambda> _. a3 \\<tau>) \\<tau>\"", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp a3' \\<Longrightarrow> cp res'\n                       \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X) (a3' X))\"", "theorem unfold : \n      assumes                \"cp E\"\n      and                    \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a3)\"\n      and                    \"\\<tau> \\<Turnstile> PRE self a1 a2 a3\"\n      and                    \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 a2 a3 (\\<lambda> _. res))\"\n      and                    \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 a2 a3 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1 a2 a3)\"", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a3)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self a1 a2 a3\"\n      and                      \"\\<tau> \\<Turnstile> POST' self a1 a2 a3\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self a1 a2 a3 res) = \n                                       ((POST' self a1 a2 a3)  and (res \\<triangleq> (BODY self a1 a2 a3)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1 a2 a3)) = (\\<tau> \\<Turnstile> E(BODY self a1 a2 a3))\""], "translations": [["", "lemma strict0 [simp]: \"f invalid X = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid X = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme' StrongEq_def OclValid_def false_def true_def)"], ["", "lemma nullstrict0[simp]: \"f null X = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null X = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme' StrongEq_def OclValid_def false_def true_def)"], ["", "lemma cp0 : \"f self a1 \\<tau> = f (\\<lambda> _. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "have A: \"(\\<tau> \\<Turnstile> \\<delta> (\\<lambda>_. self \\<tau>)) = (\\<tau> \\<Turnstile> \\<delta> self)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> (\\<lambda>_. self \\<tau>)) =\n    (\\<tau> \\<Turnstile> \\<delta> self)", "by(simp add: OclValid_def cp_defined[symmetric])"], ["proof (state)\nthis:\n  (\\<tau> \\<Turnstile> \\<delta> (\\<lambda>_. self \\<tau>)) =\n  (\\<tau> \\<Turnstile> \\<delta> self)\n\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "have B: \"f_\\<upsilon> (f_lam a1 \\<tau>) \\<tau> = f_\\<upsilon> a1 \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_\\<upsilon> (f_lam a1 \\<tau>) \\<tau> = f_\\<upsilon> a1 \\<tau>", "by (rule f_\\<upsilon>_val)"], ["proof (state)\nthis:\n  f_\\<upsilon> (f_lam a1 \\<tau>) \\<tau> = f_\\<upsilon> a1 \\<tau>\n\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "have D: \"(\\<tau> \\<Turnstile> PRE (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>)) = ( \\<tau> \\<Turnstile> PRE self a1 )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> PRE (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>)) =\n    (\\<tau> \\<Turnstile> PRE self a1)", "by(simp add: OclValid_def cp\\<^sub>P\\<^sub>R\\<^sub>E'[symmetric])"], ["proof (state)\nthis:\n  (\\<tau> \\<Turnstile> PRE (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>)) =\n  (\\<tau> \\<Turnstile> PRE self a1)\n\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>", "apply(auto simp: def_scheme' A B D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME res.\n        let res = \\<lambda>_. res\n        in (\\<tau> \\<Turnstile> \\<delta> self \\<and>\n            f_\\<upsilon> a1 \\<tau> \\<longrightarrow>\n            \\<tau> \\<Turnstile> PRE self a1 \\<and>\n            \\<tau> \\<Turnstile> POST self a1 res) \\<and>\n           ((\\<tau> \\<Turnstile> \\<delta> self \\<longrightarrow>\n             \\<not> f_\\<upsilon> a1 \\<tau>) \\<longrightarrow>\n            \\<tau> \\<Turnstile> res \\<triangleq> invalid)) =\n    (SOME res.\n        let res = \\<lambda>_. res\n        in (\\<tau> \\<Turnstile> \\<delta> self \\<and>\n            f_\\<upsilon> a1 \\<tau> \\<longrightarrow>\n            \\<tau> \\<Turnstile> PRE self a1 \\<and>\n            \\<tau>\n             \\<Turnstile> POST (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>)\n                           res) \\<and>\n           ((\\<tau> \\<Turnstile> \\<delta> self \\<longrightarrow>\n             \\<not> f_\\<upsilon> a1 \\<tau>) \\<longrightarrow>\n            \\<tau> \\<Turnstile> res \\<triangleq> invalid))", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME res.\n        let res = \\<lambda>_. res\n        in ((\\<delta> self) \\<tau> = true \\<tau> \\<and>\n            f_\\<upsilon> a1 \\<tau> \\<longrightarrow>\n            PRE self a1 \\<tau> = true \\<tau> \\<and>\n            POST self a1 res \\<tau> = true \\<tau>) \\<and>\n           (((\\<delta> self) \\<tau> = true \\<tau> \\<longrightarrow>\n             \\<not> f_\\<upsilon> a1 \\<tau>) \\<longrightarrow>\n            (res \\<triangleq> invalid) \\<tau> = true \\<tau>)) =\n    (SOME res.\n        let res = \\<lambda>_. res\n        in ((\\<delta> self) \\<tau> = true \\<tau> \\<and>\n            f_\\<upsilon> a1 \\<tau> \\<longrightarrow>\n            PRE self a1 \\<tau> = true \\<tau> \\<and>\n            POST (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) res \\<tau> =\n            true \\<tau>) \\<and>\n           (((\\<delta> self) \\<tau> = true \\<tau> \\<longrightarrow>\n             \\<not> f_\\<upsilon> a1 \\<tau>) \\<longrightarrow>\n            (res \\<triangleq> invalid) \\<tau> = true \\<tau>))", "by(subst cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T', simp)"], ["proof (state)\nthis:\n  f self a1 \\<tau> = f (\\<lambda>_. self \\<tau>) (f_lam a1 \\<tau>) \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem unfold' : \n      assumes context_ok:    \"cp E\"\n      and args_def_or_valid: \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> f_\\<upsilon> a1 \\<tau>\"\n      and pre_satisfied:     \"\\<tau> \\<Turnstile> PRE self a1\"\n      and post_satisfiable:  \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 (\\<lambda> _. res))\"\n      and sat_for_sols_post: \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1)", "have cp0: \"\\<And> X \\<tau>. E X \\<tau> = E (\\<lambda>_. X \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X \\<tau>. E X \\<tau> = E (\\<lambda>_. X \\<tau>) \\<tau>", "by(insert context_ok[simplified cp_def], auto)"], ["proof (state)\nthis:\n  E ?X ?\\<tau> = E (\\<lambda>_. ?X ?\\<tau>) ?\\<tau>\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1)", "apply(simp add: OclValid_def, subst cp0, fold OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (\\<lambda>_. f self a1 \\<tau>)", "apply(simp add:def_scheme' args_def_or_valid pre_satisfied)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>\n     \\<Turnstile> E (\\<lambda>_.\n                        SOME res.\n                           \\<tau>\n                            \\<Turnstile> POST self a1 (\\<lambda>_. res))", "apply(insert post_satisfiable, elim exE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res.\n       \\<tau> \\<Turnstile> POST self a1 (\\<lambda>_. res) \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> E (\\<lambda>_.\n                           SOME res.\n                              \\<tau>\n                               \\<Turnstile> POST self a1 (\\<lambda>_. res))", "apply(rule Hilbert_Choice.someI2, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>res uu_.\n       \\<lbrakk>\\<tau> \\<Turnstile> POST self a1 (\\<lambda>_. res);\n        \\<tau> \\<Turnstile> POST self a1 (\\<lambda>_. uu_)\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda>_. uu_)", "by(rule sat_for_sols_post, simp)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> E (f self a1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma unfold2' :\n      assumes context_ok:      \"cp E\"\n      and args_def_or_valid:   \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (f_\\<upsilon> a1 \\<tau>)\"\n      and pre_satisfied:       \"\\<tau> \\<Turnstile> PRE self a1\"\n      and postsplit_satisfied: \"\\<tau> \\<Turnstile> POST' self a1\" (* split constraint holds on post-state *)\n      and post_decomposable  : \"\\<And> res. (POST self a1 res) = \n                                       ((POST' self a1)  and (res \\<triangleq> (BODY self a1)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1)) = (\\<tau> \\<Turnstile> E(BODY self a1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "have cp0: \"\\<And> X \\<tau>. E X \\<tau> = E (\\<lambda>_. X \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X \\<tau>. E X \\<tau> = E (\\<lambda>_. X \\<tau>) \\<tau>", "by(insert context_ok[simplified cp_def], auto)"], ["proof (state)\nthis:\n  E ?X ?\\<tau> = E (\\<lambda>_. ?X ?\\<tau>) ?\\<tau>\n\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "apply(simp add: OclValid_def, subst cp0, fold OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (\\<lambda>_. f self a1 \\<tau>)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "apply(simp add:def_scheme' args_def_or_valid pre_satisfied \n                        post_decomposable postsplit_satisfied foundation10')"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>\n      \\<Turnstile> E (\\<lambda>_.\n                         SOME res.\n                            \\<tau>\n                             \\<Turnstile> (\\<lambda>_. res) \\<triangleq>\n    BODY self a1)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "apply(subst some_equality)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>_. \\<tau> \\<Turnstile> (\\<lambda>_. ?y3) \\<triangleq> BODY self a1\n 2. \\<And>_ x.\n       \\<tau>\n        \\<Turnstile> (\\<lambda>_. x) \\<triangleq>\n                     BODY self a1 \\<Longrightarrow>\n       x = ?y3\n 3. (\\<tau> \\<Turnstile> E (\\<lambda>_. ?y3)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1))", "apply(simp add: OclValid_def StrongEq_def true_def)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. (E (\\<lambda>_. BODY self a1 \\<tau>) \\<tau> =\n     \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) =\n    (E (BODY self a1) \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>)", "by(subst (2) cp0, rule refl)"], ["proof (state)\nthis:\n  (\\<tau> \\<Turnstile> E (f self a1)) =\n  (\\<tau> \\<Turnstile> E (BODY self a1))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale contract0 =\n   fixes f   :: \"('\\<AA>,'\\<alpha>0::null)val \\<Rightarrow>            \n                  ('\\<AA>,'res::null)val\"\n   fixes PRE\n   fixes POST\n   assumes def_scheme: \"f self \\<equiv>  (\\<lambda> \\<tau>. SOME res. let res = \\<lambda> _. res in\n                                        if (\\<tau> \\<Turnstile> (\\<delta> self))\n                                        then (\\<tau> \\<Turnstile> PRE self) \\<and>\n                                             (\\<tau> \\<Turnstile> POST self res)\n                                        else \\<tau> \\<Turnstile> res \\<triangleq> invalid)\"\n   assumes all_post: \"\\<forall> \\<sigma> \\<sigma>' \\<sigma>''. ((\\<sigma>,\\<sigma>') \\<Turnstile> PRE self) = ((\\<sigma>,\\<sigma>'') \\<Turnstile> PRE self)\"\n           (* PRE is really a pre-condition semantically,\n              i.e. it does not depend on the post-state. ... *)\n   assumes cp\\<^sub>P\\<^sub>R\\<^sub>E: \"PRE (self)  \\<tau> = PRE (\\<lambda> _. self \\<tau>) \\<tau> \"\n           (* this interface is preferable than :\n              assumes \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) )\"\n              which is too polymorphic. *)\n   assumes cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T:\"POST (self) (res) \\<tau> = POST (\\<lambda> _. self \\<tau>) (\\<lambda> _. res \\<tau>) \\<tau>\""], ["", "sublocale contract0 < contract_scheme \"\\<lambda>_ _. True\" \"\\<lambda>x _. x\" \"\\<lambda>x _. f x\" \"\\<lambda>x _. PRE x\" \"\\<lambda>x _. POST x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_scheme (\\<lambda>_ _. True) (\\<lambda>x _. x)\n     (\\<lambda>x _. f x) (\\<lambda>x _. PRE x) (\\<lambda>x _. POST x)", "apply(unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>self x.\n       f self \\<equiv>\n       \\<lambda>\\<tau>.\n          SOME res.\n             let res = \\<lambda>_. res\n             in if \\<tau> \\<Turnstile> \\<delta> self \\<and> True\n                then \\<tau> \\<Turnstile> PRE self \\<and>\n                     \\<tau> \\<Turnstile> POST self res\n                else \\<tau> \\<Turnstile> res \\<triangleq> invalid\n 2. \\<And>self x.\n       \\<forall>\\<sigma> \\<sigma>' \\<sigma>''.\n          ((\\<sigma>, \\<sigma>') \\<Turnstile> PRE self) =\n          ((\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self)\n 3. \\<And>self x \\<tau>.\n       PRE self \\<tau> = PRE (\\<lambda>_. self \\<tau>) \\<tau>\n 4. \\<And>self x res \\<tau>.\n       POST self res \\<tau> =\n       POST (\\<lambda>_. self \\<tau>) (\\<lambda>_. res \\<tau>) \\<tau>\n 5. \\<And>\\<tau> a1. True = True", "apply(simp add: def_scheme, rule all_post, rule cp\\<^sub>P\\<^sub>R\\<^sub>E, rule cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> a1. True = True", "by simp"], ["", "context contract0\nbegin"], ["", "lemma cp_pre: \"cp self' \\<Longrightarrow>  cp (\\<lambda>X. PRE (self' X)  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp self' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X))", "by(rule_tac f=PRE in cpI1, auto intro: cp\\<^sub>P\\<^sub>R\\<^sub>E)"], ["", "lemma cp_post: \"cp self' \\<Longrightarrow> cp res'  \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (res' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (res' X))", "by(rule_tac f=POST in cpI2, auto intro: cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["", "lemma cp [simp]:  \"cp self' \\<Longrightarrow>  cp res' \\<Longrightarrow> cp (\\<lambda>X. f (self' X) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (self' X))", "by(rule_tac f=f in cpI1, auto intro:cp0)"], ["", "lemmas unfold = unfold'[simplified]"], ["", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self\"\n      and                      \"\\<tau> \\<Turnstile> POST' self\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self res) = \n                                       ((POST' self)  and (res \\<triangleq> (BODY self)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self)) = (\\<tau> \\<Turnstile> E(BODY self))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self)) = (\\<tau> \\<Turnstile> E (BODY self))", "apply(rule unfold2'[simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cp E\n 2. \\<tau> \\<Turnstile> \\<delta> self\n 3. \\<tau> \\<Turnstile> PRE self\n 4. \\<tau> \\<Turnstile> ?POST' self ?a1.0\n 5. \\<And>res.\n       POST self res = (?POST' self ?a1.0 and (res \\<triangleq> BODY self))", "by((rule assms)+)"], ["", "end"], ["", "locale contract1 =\n   fixes f   :: \"('\\<AA>,'\\<alpha>0::null)val \\<Rightarrow>            \n                  ('\\<AA>,'\\<alpha>1::null)val \\<Rightarrow> \n                  ('\\<AA>,'res::null)val\"\n   fixes PRE\n   fixes POST \n   assumes def_scheme: \"f self a1 \\<equiv> \n                               (\\<lambda> \\<tau>. SOME res. let res = \\<lambda> _. res in\n                                     if (\\<tau> \\<Turnstile> (\\<delta> self)) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a1)\n                                     then (\\<tau> \\<Turnstile> PRE self a1) \\<and>\n                                          (\\<tau> \\<Turnstile> POST self a1 res)\n                                     else \\<tau> \\<Turnstile> res \\<triangleq> invalid) \"\n   assumes all_post: \"\\<forall> \\<sigma> \\<sigma>' \\<sigma>''.  ((\\<sigma>,\\<sigma>') \\<Turnstile> PRE self a1) = ((\\<sigma>,\\<sigma>'') \\<Turnstile> PRE self a1)\"\n           (* PRE is really a pre-condition semantically,\n              i.e. it does not depend on the post-state. ... *)\n   assumes cp\\<^sub>P\\<^sub>R\\<^sub>E: \"PRE (self) (a1)  \\<tau> = PRE (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) \\<tau> \"\n           (* this interface is preferable than :\n              assumes \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) )\"\n              which is too polymorphic. *)\n   assumes cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T:\"POST (self) (a1) (res) \\<tau> = POST (\\<lambda> _. self \\<tau>)(\\<lambda> _. a1 \\<tau>) (\\<lambda> _. res \\<tau>) \\<tau>\""], ["", "sublocale contract1 < contract_scheme \"\\<lambda>a1 \\<tau>. (\\<tau> \\<Turnstile> \\<upsilon> a1)\" \"\\<lambda>a1 \\<tau>. (\\<lambda> _. a1 \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_scheme (\\<lambda>a1 \\<tau>. \\<tau> \\<Turnstile> \\<upsilon> a1)\n     (\\<lambda>a1 \\<tau> _. a1 \\<tau>) f PRE POST", "apply(unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>self x.\n       f self x \\<equiv>\n       \\<lambda>\\<tau>.\n          SOME res.\n             let res = \\<lambda>_. res\n             in if \\<tau> \\<Turnstile> \\<delta> self \\<and>\n                   \\<tau> \\<Turnstile> \\<upsilon> x\n                then \\<tau> \\<Turnstile> PRE self x \\<and>\n                     \\<tau> \\<Turnstile> POST self x res\n                else \\<tau> \\<Turnstile> res \\<triangleq> invalid\n 2. \\<And>self x.\n       \\<forall>\\<sigma> \\<sigma>' \\<sigma>''.\n          ((\\<sigma>, \\<sigma>') \\<Turnstile> PRE self x) =\n          ((\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self x)\n 3. \\<And>self x \\<tau>.\n       PRE self x \\<tau> =\n       PRE (\\<lambda>_. self \\<tau>) (\\<lambda>_. x \\<tau>) \\<tau>\n 4. \\<And>self x res \\<tau>.\n       POST self x res \\<tau> =\n       POST (\\<lambda>_. self \\<tau>) (\\<lambda>_. x \\<tau>)\n        (\\<lambda>_. res \\<tau>) \\<tau>\n 5. \\<And>\\<tau> a1.\n       (\\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. a1 \\<tau>)) =\n       (\\<tau> \\<Turnstile> \\<upsilon> a1)", "apply(rule def_scheme, rule all_post, rule cp\\<^sub>P\\<^sub>R\\<^sub>E, rule cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> a1.\n       (\\<tau> \\<Turnstile> \\<upsilon> (\\<lambda>_. a1 \\<tau>)) =\n       (\\<tau> \\<Turnstile> \\<upsilon> a1)", "by(simp add: OclValid_def cp_valid[symmetric])"], ["", "context contract1\nbegin"], ["", "lemma strict1[simp]: \"f self invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self invalid = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> f Y Z \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> Y \\<and> \\<tau> \\<Turnstile> \\<upsilon> Z", "by(auto simp: valid_def bot_fun_def invalid_def \n                 def_scheme StrongEq_def OclValid_def false_def true_def\n           split: if_split_asm)"], ["", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow>  cp (\\<lambda>X. PRE (self' X) (a1' X)  )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X))", "by(rule_tac f=PRE in cpI2, auto intro: cp\\<^sub>P\\<^sub>R\\<^sub>E)"], ["", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (res' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (res' X))", "by(rule_tac f=POST in cpI3, auto intro: cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow>  cp res' \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X))", "by(rule_tac f=f in cpI2, auto intro:cp0)"], ["", "lemmas unfold = unfold'"], ["", "lemmas unfold2 = unfold2'"], ["", "end"], ["", "locale contract2 =\n   fixes f   :: \"('\\<AA>,'\\<alpha>0::null)val \\<Rightarrow>            \n                  ('\\<AA>,'\\<alpha>1::null)val \\<Rightarrow> ('\\<AA>,'\\<alpha>2::null)val \\<Rightarrow>\n                  ('\\<AA>,'res::null)val\"\n   fixes PRE \n   fixes POST \n   assumes def_scheme: \"f self a1 a2 \\<equiv> \n                               (\\<lambda> \\<tau>. SOME res. let res = \\<lambda> _. res in\n                                     if (\\<tau> \\<Turnstile> (\\<delta> self)) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2)\n                                     then (\\<tau> \\<Turnstile> PRE self a1 a2) \\<and>\n                                          (\\<tau> \\<Turnstile> POST self a1 a2 res)\n                                     else \\<tau> \\<Turnstile> res \\<triangleq> invalid) \"\n   assumes all_post: \"\\<forall> \\<sigma> \\<sigma>' \\<sigma>''.  ((\\<sigma>,\\<sigma>') \\<Turnstile> PRE self a1 a2) = ((\\<sigma>,\\<sigma>'') \\<Turnstile> PRE self a1 a2)\"\n           (* PRE is really a pre-condition semantically,\n              i.e. it does not depend on the post-state. ... *)\n   assumes cp\\<^sub>P\\<^sub>R\\<^sub>E: \"PRE (self) (a1) (a2) \\<tau> = PRE (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) \\<tau> \"\n           (* this interface is preferable than :\n              assumes \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) )\"\n              which is too polymorphic. *)\n   assumes cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T:\"\\<And>res. POST (self) (a1) (a2) (res) \\<tau> = \n                         POST (\\<lambda> _. self \\<tau>)(\\<lambda> _. a1 \\<tau>)(\\<lambda> _. a2 \\<tau>) (\\<lambda> _. res \\<tau>) \\<tau>\""], ["", "sublocale contract2 < contract_scheme \"\\<lambda>(a1,a2) \\<tau>. (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a2)\" \n                                      \"\\<lambda>(a1,a2) \\<tau>. (\\<lambda> _.a1 \\<tau>, \\<lambda> _.a2 \\<tau>)\"\n                                      \"(\\<lambda>x (a,b). f x a b)\"\n                                      \"(\\<lambda>x (a,b). PRE x a b)\"\n                                      \"(\\<lambda>x (a,b). POST x a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_scheme\n     (\\<lambda>(a1, a2) \\<tau>.\n         \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n         \\<tau> \\<Turnstile> \\<upsilon> a2)\n     (\\<lambda>(a1, a2) \\<tau>.\n         (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>))\n     (\\<lambda>x (a, b). f x a b) (\\<lambda>x (a, b). PRE x a b)\n     (\\<lambda>x (a, b). POST x a b)", "apply(unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>self x.\n       case x of (a, b) \\<Rightarrow> f self a b \\<equiv>\n       \\<lambda>\\<tau>.\n          SOME res.\n             let res = \\<lambda>_. res\n             in if \\<tau> \\<Turnstile> \\<delta> self \\<and>\n                   (case x of\n                    (a1, a2) \\<Rightarrow>\n                      \\<lambda>\\<tau>.\n                         \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n                         \\<tau> \\<Turnstile> \\<upsilon> a2)\n                    \\<tau>\n                then \\<tau>\n                      \\<Turnstile> case x of\n                                   (a, b) \\<Rightarrow> PRE self a b \\<and>\n                     \\<tau>\n                      \\<Turnstile> (case x of\n                                    (a, b) \\<Rightarrow> POST self a b)\n                                    res\n                else \\<tau> \\<Turnstile> res \\<triangleq> invalid\n 2. \\<And>self x.\n       \\<forall>\\<sigma> \\<sigma>' \\<sigma>''.\n          ((\\<sigma>, \\<sigma>')\n            \\<Turnstile> case x of (a, b) \\<Rightarrow> PRE self a b) =\n          ((\\<sigma>, \\<sigma>'')\n            \\<Turnstile> case x of (a, b) \\<Rightarrow> PRE self a b)\n 3. \\<And>self x \\<tau>.\n       (case x of (a, b) \\<Rightarrow> PRE self a b) \\<tau> =\n       (case (case x of\n              (a1, a2) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>))\n              \\<tau> of\n        (a, b) \\<Rightarrow> PRE (\\<lambda>_. self \\<tau>) a b)\n        \\<tau>\n 4. \\<And>self x res \\<tau>.\n       (case x of (a, b) \\<Rightarrow> POST self a b) res \\<tau> =\n       (case (case x of\n              (a1, a2) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>))\n              \\<tau> of\n        (a, b) \\<Rightarrow> POST (\\<lambda>_. self \\<tau>) a b)\n        (\\<lambda>_. res \\<tau>) \\<tau>\n 5. \\<And>\\<tau> a1.\n       (case (case a1 of\n              (a1, a2) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>))\n              \\<tau> of\n        (a1, a2) \\<Rightarrow>\n          \\<lambda>\\<tau>.\n             \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a2)\n        \\<tau> =\n       (case a1 of\n        (a1, a2) \\<Rightarrow>\n          \\<lambda>\\<tau>.\n             \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a2)\n        \\<tau>", "apply(auto simp add: def_scheme)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>self a b \\<sigma> \\<sigma>' \\<sigma>''.\n       (\\<sigma>, \\<sigma>') \\<Turnstile> PRE self a b \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self a b\n 2. \\<And>self a b \\<sigma> \\<sigma>' \\<sigma>''.\n       (\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self a b \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<Turnstile> PRE self a b\n 3. \\<And>self a b aa ba.\n       PRE self a b (aa, ba) =\n       PRE (\\<lambda>_. self (aa, ba)) (\\<lambda>_. a (aa, ba))\n        (\\<lambda>_. b (aa, ba)) (aa, ba)\n 4. \\<And>self a b res aa ba.\n       POST self a b res (aa, ba) =\n       POST (\\<lambda>_. self (aa, ba)) (\\<lambda>_. a (aa, ba))\n        (\\<lambda>_. b (aa, ba)) (\\<lambda>_. res (aa, ba)) (aa, ba)\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 6. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 7. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 8. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply (metis all_post, metis all_post)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>self a b aa ba.\n       PRE self a b (aa, ba) =\n       PRE (\\<lambda>_. self (aa, ba)) (\\<lambda>_. a (aa, ba))\n        (\\<lambda>_. b (aa, ba)) (aa, ba)\n 2. \\<And>self a b res aa ba.\n       POST self a b res (aa, ba) =\n       POST (\\<lambda>_. self (aa, ba)) (\\<lambda>_. a (aa, ba))\n        (\\<lambda>_. b (aa, ba)) (\\<lambda>_. res (aa, ba)) (aa, ba)\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 6. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply(subst cp\\<^sub>P\\<^sub>R\\<^sub>E, simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>self a b res aa ba.\n       POST self a b res (aa, ba) =\n       POST (\\<lambda>_. self (aa, ba)) (\\<lambda>_. a (aa, ba))\n        (\\<lambda>_. b (aa, ba)) (\\<lambda>_. res (aa, ba)) (aa, ba)\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 5. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply(subst cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 2. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 3. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 4. \\<And>a b aa ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "by(simp_all add: OclValid_def cp_valid[symmetric])"], ["", "context contract2\nbegin"], ["", "lemma strict0'[simp] : \"f invalid X Y = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid X Y = invalid", "by(insert strict0[of \"(X,Y)\"], simp)"], ["", "lemma nullstrict0'[simp]: \"f null X Y = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null X Y = invalid", "by(insert nullstrict0[of \"(X,Y)\"], simp)"], ["", "lemma strict1[simp]: \"f self invalid Y = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self invalid Y = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma strict2[simp]: \"f self X invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self X invalid = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f X Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> X) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> f X Y Z \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> X \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> Y \\<and> \\<tau> \\<Turnstile> \\<upsilon> Z", "by(auto simp: valid_def bot_fun_def invalid_def \n                 def_scheme StrongEq_def OclValid_def false_def true_def\n           split: if_split_asm)"], ["", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X))", "by(rule_tac f=PRE in cpI3, auto intro: cp\\<^sub>P\\<^sub>R\\<^sub>E)"], ["", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (a2' X) (res' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X.\n                             POST (self' X) (a1' X) (a2' X) (res' X))", "by(rule_tac f=POST in cpI4, auto intro: cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["", "lemma cp0' : \"f self a1 a2 \\<tau> = f (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self a1 a2 \\<tau> =\n    f (\\<lambda>_. self \\<tau>) (\\<lambda>_. a1 \\<tau>)\n     (\\<lambda>_. a2 \\<tau>) \\<tau>", "by (rule cp0[of _ \"(a1,a2)\", simplified])"], ["", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp res'\n                       \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X))", "by(rule_tac f=f in cpI3, auto intro:cp0')"], ["", "theorem unfold : \n      assumes                \"cp E\"\n      and                    \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2)\"\n      and                    \"\\<tau> \\<Turnstile> PRE self a1 a2\"\n      and                    \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 a2 (\\<lambda> _. res))\"\n      and                    \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 a2 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1 a2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1 a2)", "apply(rule unfold'[of _ _ _ \"(a1, a2)\", simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cp E\n 2. \\<tau> \\<Turnstile> \\<delta> self \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a2\n 3. \\<tau> \\<Turnstile> PRE self a1 a2\n 4. \\<exists>res. \\<tau> \\<Turnstile> POST self a1 a2 (\\<lambda>_. res)\n 5. \\<And>res.\n       \\<tau>\n        \\<Turnstile> POST self a1 a2 (\\<lambda>_. res) \\<Longrightarrow>\n       \\<tau> \\<Turnstile> E (\\<lambda>a. res)", "by((rule assms)+)"], ["", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self a1 a2\"\n      and                      \"\\<tau> \\<Turnstile> POST' self a1 a2\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self a1 a2 res) = \n                                       ((POST' self a1 a2)  and (res \\<triangleq> (BODY self a1 a2)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1 a2)) = (\\<tau> \\<Turnstile> E(BODY self a1 a2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1 a2)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1 a2))", "apply(rule unfold2'[of _ _ _ \"(a1, a2)\", simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cp E\n 2. \\<tau> \\<Turnstile> \\<delta> self \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a2\n 3. \\<tau> \\<Turnstile> PRE self a1 a2\n 4. \\<tau> \\<Turnstile> ?POST' self (a1, a2)\n 5. \\<And>res.\n       POST self a1 a2 res =\n       (?POST' self (a1, a2) and (res \\<triangleq> BODY self a1 a2))", "by((rule assms)+)"], ["", "end"], ["", "locale contract3 =\n   fixes f   :: \"('\\<AA>,'\\<alpha>0::null)val \\<Rightarrow>            \n                  ('\\<AA>,'\\<alpha>1::null)val \\<Rightarrow> \n                  ('\\<AA>,'\\<alpha>2::null)val \\<Rightarrow>\n                  ('\\<AA>,'\\<alpha>3::null)val \\<Rightarrow>\n                  ('\\<AA>,'res::null)val\"\n   fixes PRE \n   fixes POST \n   assumes def_scheme: \"f self a1 a2 a3 \\<equiv> \n                               (\\<lambda> \\<tau>. SOME res. let res = \\<lambda> _. res in\n                                     if (\\<tau> \\<Turnstile> (\\<delta> self)) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a3)\n                                     then (\\<tau> \\<Turnstile> PRE self a1 a2 a3) \\<and>\n                                          (\\<tau> \\<Turnstile> POST self a1 a2 a3 res)\n                                     else \\<tau> \\<Turnstile> res \\<triangleq> invalid) \"\n   assumes all_post: \"\\<forall> \\<sigma> \\<sigma>' \\<sigma>''.  ((\\<sigma>,\\<sigma>') \\<Turnstile> PRE self a1 a2 a3) = ((\\<sigma>,\\<sigma>'') \\<Turnstile> PRE self a1 a2 a3)\"\n           (* PRE is really a pre-condition semantically,\n              i.e. it does not depend on the post-state. ... *)\n   assumes cp\\<^sub>P\\<^sub>R\\<^sub>E: \"PRE (self) (a1) (a2) (a3) \\<tau> = PRE (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) (\\<lambda> _. a3 \\<tau>) \\<tau> \"\n           (* this interface is preferable than :\n              assumes \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp a3' \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) (a3' X) )\"\n              which is too polymorphic. *)\n   assumes cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T:\"\\<And>res. POST (self) (a1) (a2) (a3) (res) \\<tau> = \n                         POST (\\<lambda> _. self \\<tau>)(\\<lambda> _. a1 \\<tau>)(\\<lambda> _. a2 \\<tau>)(\\<lambda> _. a3 \\<tau>) (\\<lambda> _. res \\<tau>) \\<tau>\""], ["", "sublocale contract3 < contract_scheme \"\\<lambda>(a1,a2,a3) \\<tau>. (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a2)\\<and> (\\<tau> \\<Turnstile> \\<upsilon> a3)\" \n                                      \"\\<lambda>(a1,a2,a3) \\<tau>. (\\<lambda> _.a1 \\<tau>, \\<lambda> _.a2 \\<tau>, \\<lambda> _.a3 \\<tau>)\"\n                                      \"(\\<lambda>x (a,b,c). f x a b c)\"\n                                      \"(\\<lambda>x (a,b,c). PRE x a b c)\"\n                                      \"(\\<lambda>x (a,b,c). POST x a b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. contract_scheme\n     (\\<lambda>(a1, a2, a3) \\<tau>.\n         \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n         \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n         \\<tau> \\<Turnstile> \\<upsilon> a3)\n     (\\<lambda>(a1, a2, a3) \\<tau>.\n         (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>,\n          \\<lambda>_. a3 \\<tau>))\n     (\\<lambda>x (a, b, c). f x a b c) (\\<lambda>x (a, b, c). PRE x a b c)\n     (\\<lambda>x (a, b, c). POST x a b c)", "apply(unfold_locales)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>self x.\n       case x of (a, b, c) \\<Rightarrow> f self a b c \\<equiv>\n       \\<lambda>\\<tau>.\n          SOME res.\n             let res = \\<lambda>_. res\n             in if \\<tau> \\<Turnstile> \\<delta> self \\<and>\n                   (case x of\n                    (a1, a2, a3) \\<Rightarrow>\n                      \\<lambda>\\<tau>.\n                         \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n                         \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n                         \\<tau> \\<Turnstile> \\<upsilon> a3)\n                    \\<tau>\n                then \\<tau>\n                      \\<Turnstile> case x of\n                                   (a, b, c) \\<Rightarrow>\n                                     PRE self a b c \\<and>\n                     \\<tau>\n                      \\<Turnstile> (case x of\n                                    (a, b, c) \\<Rightarrow> POST self a b c)\n                                    res\n                else \\<tau> \\<Turnstile> res \\<triangleq> invalid\n 2. \\<And>self x.\n       \\<forall>\\<sigma> \\<sigma>' \\<sigma>''.\n          ((\\<sigma>, \\<sigma>')\n            \\<Turnstile> case x of (a, b, c) \\<Rightarrow> PRE self a b c) =\n          ((\\<sigma>, \\<sigma>'')\n            \\<Turnstile> case x of (a, b, c) \\<Rightarrow> PRE self a b c)\n 3. \\<And>self x \\<tau>.\n       (case x of (a, b, c) \\<Rightarrow> PRE self a b c) \\<tau> =\n       (case (case x of\n              (a1, a2, a3) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>,\n                    \\<lambda>_. a3 \\<tau>))\n              \\<tau> of\n        (a, b, c) \\<Rightarrow> PRE (\\<lambda>_. self \\<tau>) a b c)\n        \\<tau>\n 4. \\<And>self x res \\<tau>.\n       (case x of (a, b, c) \\<Rightarrow> POST self a b c) res \\<tau> =\n       (case (case x of\n              (a1, a2, a3) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>,\n                    \\<lambda>_. a3 \\<tau>))\n              \\<tau> of\n        (a, b, c) \\<Rightarrow> POST (\\<lambda>_. self \\<tau>) a b c)\n        (\\<lambda>_. res \\<tau>) \\<tau>\n 5. \\<And>\\<tau> a1.\n       (case (case a1 of\n              (a1, a2, a3) \\<Rightarrow>\n                \\<lambda>\\<tau>.\n                   (\\<lambda>_. a1 \\<tau>, \\<lambda>_. a2 \\<tau>,\n                    \\<lambda>_. a3 \\<tau>))\n              \\<tau> of\n        (a1, a2, a3) \\<Rightarrow>\n          \\<lambda>\\<tau>.\n             \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a3)\n        \\<tau> =\n       (case a1 of\n        (a1, a2, a3) \\<Rightarrow>\n          \\<lambda>\\<tau>.\n             \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n             \\<tau> \\<Turnstile> \\<upsilon> a3)\n        \\<tau>", "apply(auto simp add: def_scheme)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<And>self a aa b \\<sigma> \\<sigma>' \\<sigma>''.\n       (\\<sigma>, \\<sigma>') \\<Turnstile> PRE self a aa b \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self a aa b\n 2. \\<And>self a aa b \\<sigma> \\<sigma>' \\<sigma>''.\n       (\\<sigma>, \\<sigma>'') \\<Turnstile> PRE self a aa b \\<Longrightarrow>\n       (\\<sigma>, \\<sigma>') \\<Turnstile> PRE self a aa b\n 3. \\<And>self a aa b ab ba.\n       PRE self a aa b (ab, ba) =\n       PRE (\\<lambda>_. self (ab, ba)) (\\<lambda>_. a (ab, ba))\n        (\\<lambda>_. aa (ab, ba)) (\\<lambda>_. b (ab, ba)) (ab, ba)\n 4. \\<And>self a aa b res ab ba.\n       POST self a aa b res (ab, ba) =\n       POST (\\<lambda>_. self (ab, ba)) (\\<lambda>_. a (ab, ba))\n        (\\<lambda>_. aa (ab, ba)) (\\<lambda>_. b (ab, ba))\n        (\\<lambda>_. res (ab, ba)) (ab, ba)\n 5. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 6. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ab\n 7. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 8. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 9. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b))\n 10. \\<And>a b aa ab ba.\n        \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n         (a, b) \\<Turnstile> \\<upsilon> ab;\n         (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n        \\<Longrightarrow> (a, b)\n                           \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply (metis all_post, metis all_post)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<And>self a aa b ab ba.\n       PRE self a aa b (ab, ba) =\n       PRE (\\<lambda>_. self (ab, ba)) (\\<lambda>_. a (ab, ba))\n        (\\<lambda>_. aa (ab, ba)) (\\<lambda>_. b (ab, ba)) (ab, ba)\n 2. \\<And>self a aa b res ab ba.\n       POST self a aa b res (ab, ba) =\n       POST (\\<lambda>_. self (ab, ba)) (\\<lambda>_. a (ab, ba))\n        (\\<lambda>_. aa (ab, ba)) (\\<lambda>_. b (ab, ba))\n        (\\<lambda>_. res (ab, ba)) (ab, ba)\n 3. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 4. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ab\n 5. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 6. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 7. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b))\n 8. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply(subst cp\\<^sub>P\\<^sub>R\\<^sub>E, simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>self a aa b res ab ba.\n       POST self a aa b res (ab, ba) =\n       POST (\\<lambda>_. self (ab, ba)) (\\<lambda>_. a (ab, ba))\n        (\\<lambda>_. aa (ab, ba)) (\\<lambda>_. b (ab, ba))\n        (\\<lambda>_. res (ab, ba)) (ab, ba)\n 2. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 3. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ab\n 4. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 5. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 6. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b))\n 7. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "apply(subst cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T, simp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> aa\n 2. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ab\n 3. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b));\n        (a, b) \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))\\<rbrakk>\n       \\<Longrightarrow> (a, b) \\<Turnstile> \\<upsilon> ba\n 4. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. aa (a, b))\n 5. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ab (a, b))\n 6. \\<And>a b aa ab ba.\n       \\<lbrakk>(a, b) \\<Turnstile> \\<upsilon> aa;\n        (a, b) \\<Turnstile> \\<upsilon> ab;\n        (a, b) \\<Turnstile> \\<upsilon> ba\\<rbrakk>\n       \\<Longrightarrow> (a, b)\n                          \\<Turnstile> \\<upsilon> (\\<lambda>_. ba (a, b))", "by(simp_all add: OclValid_def cp_valid[symmetric])"], ["", "context contract3\nbegin"], ["", "lemma strict0'[simp] : \"f invalid X Y Z = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid X Y Z = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma nullstrict0'[simp]: \"f null X Y Z = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null X Y Z = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma strict1[simp]: \"f self invalid Y Z = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self invalid Y Z = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma strict2[simp]: \"f self X invalid Z = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self X invalid Z = invalid", "by(rule ext, rename_tac \"\\<tau>\", simp add: def_scheme StrongEq_def OclValid_def false_def true_def)"], ["", "lemma defined_mono : \"\\<tau> \\<Turnstile>\\<upsilon>(f W X Y Z) \\<Longrightarrow> (\\<tau> \\<Turnstile>\\<delta> W) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> X) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Y) \\<and> (\\<tau> \\<Turnstile>\\<upsilon> Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> f W X Y Z \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> W \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> X \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> Y \\<and> \\<tau> \\<Turnstile> \\<upsilon> Z", "by(auto simp: valid_def bot_fun_def invalid_def \n                 def_scheme StrongEq_def OclValid_def false_def true_def\n           split: if_split_asm)"], ["", "lemma cp_pre: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2'\\<Longrightarrow> cp a3' \n                  \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) (a3' X) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'; cp a3'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. PRE (self' X) (a1' X) (a2' X) (a3' X))", "by(rule_tac f=PRE in cpI4, auto intro: cp\\<^sub>P\\<^sub>R\\<^sub>E)"], ["", "lemma cp_post: \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp a3' \\<Longrightarrow> cp res'\n                   \\<Longrightarrow> cp (\\<lambda>X. POST (self' X) (a1' X) (a2' X) (a3' X)  (res' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'; cp a3'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X.\n                             POST (self' X) (a1' X) (a2' X) (a3' X)\n                              (res' X))", "by(rule_tac f=POST in cpI5, auto intro: cp\\<^sub>P\\<^sub>O\\<^sub>S\\<^sub>T)"], ["", "lemma cp0' : \"f self a1 a2 a3 \\<tau> = f (\\<lambda> _. self \\<tau>) (\\<lambda> _. a1 \\<tau>) (\\<lambda> _. a2 \\<tau>) (\\<lambda> _. a3 \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f self a1 a2 a3 \\<tau> =\n    f (\\<lambda>_. self \\<tau>) (\\<lambda>_. a1 \\<tau>)\n     (\\<lambda>_. a2 \\<tau>) (\\<lambda>_. a3 \\<tau>) \\<tau>", "by (rule cp0[of _ \"(a1,a2,a3)\", simplified])"], ["", "lemma cp [simp]:  \"cp self' \\<Longrightarrow> cp a1' \\<Longrightarrow> cp a2' \\<Longrightarrow> cp a3' \\<Longrightarrow> cp res'\n                       \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X) (a3' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp self'; cp a1'; cp a2'; cp a3'; cp res'\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (self' X) (a1' X) (a2' X) (a3' X))", "by(rule_tac f=f in cpI4, auto intro:cp0')"], ["", "theorem unfold : \n      assumes                \"cp E\"\n      and                    \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a3)\"\n      and                    \"\\<tau> \\<Turnstile> PRE self a1 a2 a3\"\n      and                    \" \\<exists>res. (\\<tau> \\<Turnstile> POST self a1 a2 a3 (\\<lambda> _. res))\"\n      and                    \"(\\<And>res. \\<tau> \\<Turnstile> POST self a1 a2 a3 (\\<lambda> _. res)  \\<Longrightarrow> \\<tau> \\<Turnstile> E (\\<lambda> _. res))\"\n      shows                  \"\\<tau> \\<Turnstile> E(f self a1 a2 a3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> E (f self a1 a2 a3)", "apply(rule unfold'[of _ _ _ \"(a1, a2, a3)\", simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cp E\n 2. \\<tau> \\<Turnstile> \\<delta> self \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a3\n 3. \\<tau> \\<Turnstile> PRE self a1 a2 a3\n 4. \\<exists>res. \\<tau> \\<Turnstile> POST self a1 a2 a3 (\\<lambda>_. res)\n 5. \\<And>res.\n       \\<tau>\n        \\<Turnstile> POST self a1 a2 a3 (\\<lambda>_. res) \\<Longrightarrow>\n       \\<tau> \\<Turnstile> E (\\<lambda>a. res)", "by((rule assms)+)"], ["", "lemma unfold2 :\n      assumes                  \"cp E\"\n      and                      \"(\\<tau> \\<Turnstile> \\<delta> self) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> a1) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a2) \\<and>  (\\<tau> \\<Turnstile> \\<upsilon> a3)\"\n      and                      \"\\<tau> \\<Turnstile> PRE self a1 a2 a3\"\n      and                      \"\\<tau> \\<Turnstile> POST' self a1 a2 a3\" (* split constraint holds on post-state *)\n      and                      \"\\<And> res. (POST self a1 a2 a3 res) = \n                                       ((POST' self a1 a2 a3)  and (res \\<triangleq> (BODY self a1 a2 a3)))\"\n      shows \"(\\<tau> \\<Turnstile> E(f self a1 a2 a3)) = (\\<tau> \\<Turnstile> E(BODY self a1 a2 a3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> E (f self a1 a2 a3)) =\n    (\\<tau> \\<Turnstile> E (BODY self a1 a2 a3))", "apply(rule unfold2'[of _ _ _ \"(a1, a2, a3)\", simplified])"], ["proof (prove)\ngoal (5 subgoals):\n 1. cp E\n 2. \\<tau> \\<Turnstile> \\<delta> self \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a1 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a2 \\<and>\n    \\<tau> \\<Turnstile> \\<upsilon> a3\n 3. \\<tau> \\<Turnstile> PRE self a1 a2 a3\n 4. \\<tau> \\<Turnstile> ?POST' self (a1, a2, a3)\n 5. \\<And>res.\n       POST self a1 a2 a3 res =\n       (?POST' self (a1, a2, a3) and (res \\<triangleq> BODY self a1 a2 a3))", "by((rule assms)+)"], ["", "end"], ["", "end"]]}