{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/basic_types/UML_Boolean.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma [simp,code_unfold] : \"(true \\<doteq> false) = false\"", "lemma [simp,code_unfold] : \"(false \\<doteq> true) = false\"", "lemma null_non_false [simp,code_unfold]:\"(null \\<doteq> false) = false\"", "lemma null_non_true [simp,code_unfold]:\"(null \\<doteq> true) = false\"", "lemma false_non_null [simp,code_unfold]:\"(false \\<doteq> null) = false\"", "lemma true_non_null [simp,code_unfold]:\"(true \\<doteq> null) = false\"", "lemma \"(invalid \\<doteq> false) = invalid\"", "lemma \"(invalid \\<doteq> true) = invalid\"", "lemma \"(false \\<doteq> invalid) = invalid\"", "lemma \"(true \\<doteq> invalid) = invalid\"", "lemma \"((invalid::('\\<AA>)Boolean) \\<doteq> invalid) = invalid\""], "translations": [["", "lemma [simp,code_unfold] : \"(true \\<doteq> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<doteq> false) = false", "by(simp add:StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n)"], ["", "lemma [simp,code_unfold] : \"(false \\<doteq> true) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<doteq> true) = false", "by(simp add:StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n)"], ["", "lemma null_non_false [simp,code_unfold]:\"(null \\<doteq> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> false) = false", "apply(rule ext, simp add: StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n StrongEq_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<upsilon> (\\<lambda>\\<tau>.\n                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>))\n         x =\n        true x \\<longrightarrow>\n        null x \\<noteq> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) \\<and>\n       ((\\<upsilon> (\\<lambda>\\<tau>.\n                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>))\n         x \\<noteq>\n        true x \\<longrightarrow>\n        invalid x = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)", "by (metis drop.simps cp_valid false_def is_none_code(2) Option.is_none_def valid4\n           bot_option_def null_fun_def null_option_def)"], ["", "lemma null_non_true [simp,code_unfold]:\"(null \\<doteq> true) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> true) = false", "apply(rule ext, simp add: StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n StrongEq_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. null x \\<noteq> true x", "by(simp add: true_def bot_option_def null_fun_def null_option_def)"], ["", "lemma false_non_null [simp,code_unfold]:\"(false \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<doteq> null) = false", "apply(rule ext, simp add: StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n StrongEq_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<upsilon> (\\<lambda>\\<tau>.\n                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>))\n         x =\n        true x \\<longrightarrow>\n        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<noteq> null x) \\<and>\n       ((\\<upsilon> (\\<lambda>\\<tau>.\n                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>))\n         x \\<noteq>\n        true x \\<longrightarrow>\n        invalid x = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)", "by(metis drop.simps cp_valid false_def is_none_code(2) Option.is_none_def valid4\n          bot_option_def null_fun_def null_option_def )"], ["", "lemma true_non_null [simp,code_unfold]:\"(true \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<doteq> null) = false", "apply(rule ext, simp add: StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n StrongEq_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. true x \\<noteq> null x", "by(simp add: true_def bot_option_def null_fun_def null_option_def)"], ["", "text\\<open>With respect to strictness properties and miscelleaneous side-calculi,\nstrict referential equality behaves on booleans as described in the\n@{term \"profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v\"}:\\<close>"], ["", "interpretation StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n : profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v \"\\<lambda> x y. (x::('\\<AA>)Boolean) \\<doteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v\n     (\\<doteq>)", "by unfold_locales (auto simp:StrictRefEq\\<^sub>B\\<^sub>o\\<^sub>o\\<^sub>l\\<^sub>e\\<^sub>a\\<^sub>n)"], ["", "text\\<open>In particular, it is strict, cp-preserving and const-preserving. In particular,\nit generates the simplifier rules for terms like:\\<close>"], ["", "lemma \"(invalid \\<doteq> false) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid \\<doteq> false) = invalid", "by(simp)"], ["", "lemma \"(invalid \\<doteq> true) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid \\<doteq> true) = invalid", "by(simp)"], ["", "lemma \"(false \\<doteq> invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<doteq> invalid) = invalid", "by(simp)"], ["", "lemma \"(true \\<doteq> invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<doteq> invalid) = invalid", "by(simp)"], ["", "lemma \"((invalid::('\\<AA>)Boolean) \\<doteq> invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid \\<doteq> invalid) = invalid", "by(simp)"], ["", "text\\<open>Thus, the weak equality is \\emph{not} reflexive.\\<close>"], ["", "subsection\\<open>Test Statements on Boolean Operations.\\<close>"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "text\\<open>Elementary computations on Boolean\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon>(true)\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<delta>(false)\""], ["", "Assert \"\\<tau> |\\<noteq> \\<delta>(null)\""], ["", "Assert \"\\<tau> |\\<noteq> \\<delta>(invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon>((null::('\\<AA>)Boolean))\""], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon>(invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> (true and true)\""], ["", "Assert \"\\<tau> \\<Turnstile> (true and true \\<triangleq> true)\""], ["", "Assert \"\\<tau> \\<Turnstile> ((null or null) \\<triangleq> null)\""], ["", "Assert \"\\<tau> \\<Turnstile> ((null or null) \\<doteq> null)\""], ["", "Assert \"\\<tau> \\<Turnstile> ((true \\<triangleq> false) \\<triangleq> false)\""], ["", "Assert \"\\<tau> \\<Turnstile> ((invalid \\<triangleq> false) \\<triangleq> false)\""], ["", "Assert \"\\<tau> \\<Turnstile> ((invalid \\<doteq> false) \\<triangleq> invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> (true <> false)\""], ["", "Assert \"\\<tau> \\<Turnstile> (false <> true)\""], ["", "end"]]}