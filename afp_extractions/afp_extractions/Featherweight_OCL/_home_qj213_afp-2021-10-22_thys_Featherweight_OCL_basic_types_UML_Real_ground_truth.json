{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/basic_types/UML_Real.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma  \"\\<delta>(null::('\\<AA>)Real) = false\"", "lemma  \"\\<upsilon>(null::('\\<AA>)Real) = true\"", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<zero>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<zero>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<one>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<one>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<two>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<two>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<six>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<six>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<eight>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<eight>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<delta> \\<nine>.\\<zero> = true\"", "lemma [simp,code_unfold]: \"\\<upsilon> \\<nine>.\\<zero> = true\"", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_commute: \"(X +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l Y) = (Y +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l X)\"", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_zero1[simp,code_unfold] :\n\"(x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\"", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_zero2[simp,code_unfold] :\n\"(\\<zero>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l x) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\"", "lemma real_non_null [simp]: \"((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> (null::('\\<AA>)Real)) = false\"", "lemma null_non_real [simp]: \"((null::('\\<AA>)Real) \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) = false\"", "lemma OclReal0_non_null [simp,code_unfold]: \"(\\<zero>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal0 [simp,code_unfold]: \"(null \\<doteq> \\<zero>.\\<zero>) = false\"", "lemma OclReal1_non_null [simp,code_unfold]: \"(\\<one>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal1 [simp,code_unfold]: \"(null \\<doteq> \\<one>.\\<zero>) = false\"", "lemma OclReal2_non_null [simp,code_unfold]: \"(\\<two>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal2 [simp,code_unfold]: \"(null \\<doteq> \\<two>.\\<zero>) = false\"", "lemma OclReal6_non_null [simp,code_unfold]: \"(\\<six>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal6 [simp,code_unfold]: \"(null \\<doteq> \\<six>.\\<zero>) = false\"", "lemma OclReal8_non_null [simp,code_unfold]: \"(\\<eight>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal8 [simp,code_unfold]: \"(null \\<doteq> \\<eight>.\\<zero>) = false\"", "lemma OclReal9_non_null [simp,code_unfold]: \"(\\<nine>.\\<zero> \\<doteq> null) = false\"", "lemma null_non_OclReal9 [simp,code_unfold]: \"(null \\<doteq> \\<nine>.\\<zero>) = false\""], "translations": [["", "lemma  \"\\<delta>(null::('\\<AA>)Real) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> null = false", "by simp"], ["", "lemma  \"\\<upsilon>(null::('\\<AA>)Real) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> null = true", "by simp"], ["", "lemma [simp,code_unfold]: \"\\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:defined_def true_def\n               bot_fun_def bot_option_def null_fun_def null_option_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) = true", "by(simp add:valid_def true_def\n               bot_fun_def bot_option_def)"], ["", "(* ecclectic proofs to make examples executable *)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<zero>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<zero>.\\<zero> = true", "by(simp add:OclReal0_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<zero>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<zero>.\\<zero> = true", "by(simp add:OclReal0_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<one>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<one>.\\<zero> = true", "by(simp add:OclReal1_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<one>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<one>.\\<zero> = true", "by(simp add:OclReal1_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<two>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<two>.\\<zero> = true", "by(simp add:OclReal2_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<two>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<two>.\\<zero> = true", "by(simp add:OclReal2_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<six>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<six>.\\<zero> = true", "by(simp add:OclReal6_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<six>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<six>.\\<zero> = true", "by(simp add:OclReal6_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<eight>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<eight>.\\<zero> = true", "by(simp add:OclReal8_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<eight>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<eight>.\\<zero> = true", "by(simp add:OclReal8_def)"], ["", "lemma [simp,code_unfold]: \"\\<delta> \\<nine>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<nine>.\\<zero> = true", "by(simp add:OclReal9_def)"], ["", "lemma [simp,code_unfold]: \"\\<upsilon> \\<nine>.\\<zero> = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<nine>.\\<zero> = true", "by(simp add:OclReal9_def)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>Arithmetical Operations\\<close>"], ["", "subsubsection\\<open>Definition\\<close>"], ["", "text\\<open>Here is a common case of a built-in operation on built-in types.\nNote that the arguments must be both defined (non-null, non-bot).\\<close>"], ["", "text\\<open>Note that we can not follow the lexis of the OCL Standard for Isabelle\ntechnical reasons; these operators are heavily overloaded in the HOL library\nthat a further overloading would lead to heavy technical buzz in this\ndocument.\n\\<close>"], ["", "definition OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real\" (infix \"+\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 40)\nwhere \"x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> + \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l : profile_bin\\<^sub>d_\\<^sub>d \"(+\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> + \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (+\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> +\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by unfold_locales (auto simp:OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def bot_option_def null_option_def)"], ["", "definition OclMinus\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real\" (infix \"-\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 41)\nwhere \"x -\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> - \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclMinus\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l : profile_bin\\<^sub>d_\\<^sub>d \"(-\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> - \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (-\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> -\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclMinus\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def bot_option_def null_option_def)"], ["", "definition OclMult\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real\" (infix \"*\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 45)\nwhere \"x *\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> * \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau>\""], ["", "interpretation OclMult\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l : profile_bin\\<^sub>d_\\<^sub>d \"OclMult\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> * \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (*\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> *\n                           \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclMult\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def bot_option_def null_option_def)"], ["", "text\\<open>Here is the special case of division, which is defined as invalid for division\nby zero.\\<close>"], ["", "definition OclDivision\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real\" (infix \"div\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 45)\nwhere \"x div\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then if y \\<tau> \\<noteq> OclReal0 \\<tau> then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> / \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> else invalid \\<tau> \n                       else invalid \\<tau> \""], ["", "(* TODO: special locale setup.*)"], ["", "definition \"mod_float a b = a - real_of_int (floor (a / b)) * b\""], ["", "definition OclModulus\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real\" (infix \"mod\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 45)\nwhere \"x mod\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then if y \\<tau> \\<noteq> OclReal0 \\<tau> then \\<lfloor>\\<lfloor>mod_float \\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> else invalid \\<tau> \n                       else invalid \\<tau> \""], ["", "(* TODO: special locale setup.*)"], ["", "definition OclLess\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Boolean\" (infix \"<\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 35)\nwhere \"x <\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> < \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclLess\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l : profile_bin\\<^sub>d_\\<^sub>d \"(<\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> < \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (<\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil>\n                           < \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclLess\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def bot_option_def null_option_def)"], ["", "definition OclLe\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l ::\"('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Real \\<Rightarrow> ('\\<AA>)Boolean\" (infix \"\\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l\" 35)\nwhere \"x \\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l y \\<equiv> \\<lambda> \\<tau>. if (\\<delta> x) \\<tau> = true \\<tau> \\<and> (\\<delta> y) \\<tau> = true \\<tau>\n                       then \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil> \\<le> \\<lceil>\\<lceil>y \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\n                       else invalid \\<tau> \""], ["", "interpretation OclLe\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l : profile_bin\\<^sub>d_\\<^sub>d \"(\\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\" \"\\<lambda> x y. \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil> \\<le> \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin\\<^sub>d_\\<^sub>d (\\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l)\n     (\\<lambda>x y.\n         \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\\<rceil>\\<rceil>\n                           \\<le> \\<lceil>\\<lceil>y\\<rceil>\\<rceil>\\<rfloor>\\<rfloor>)", "by   unfold_locales  (auto simp:OclLe\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def bot_option_def null_option_def)"], ["", "subsubsection\\<open>Basic Properties\\<close>"], ["", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_commute: \"(X +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l Y) = (Y +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l Y) =\n    (Y +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l X)", "by(rule ext,auto simp:true_def false_def OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def invalid_def\n                   split: option.split option.split_asm\n                          bool.split bool.split_asm)"], ["", "subsubsection\\<open>Execution with Invalid or Null or Zero as Argument\\<close>"], ["", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_zero1[simp,code_unfold] :\n\"(x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)", "proof (rule ext, rename_tac \\<tau>, case_tac \"(\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>\n 2. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "fix \\<tau>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>\n 2. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "show \"(\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau> \\<Longrightarrow>\n              (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n    true \\<tau> \\<Longrightarrow>\n    (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>", "apply(subst OclIf_true', simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> x and not (\\<delta> x)) \\<tau> =\n    true \\<tau> \\<Longrightarrow>\n    (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n    invalid \\<tau>", "by (metis OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def OclNot_defargs OclValid_def foundation5 foundation9)"], ["proof (state)\nthis:\n  (\\<upsilon> x and not (\\<delta> x)) \\<tau> = true \\<tau> \\<Longrightarrow>\n  (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n  (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "fix \\<tau>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "have A: \"\\<And>\\<tau>. (\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) = (x \\<tau> = invalid \\<tau> \\<or> \\<tau> \\<Turnstile> \\<delta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) =\n       (x \\<tau> = invalid \\<tau> \\<or> \\<tau> \\<Turnstile> \\<delta> x)", "by (metis OclNot_not OclOr_def defined5 defined6 defined_not_I foundation11 foundation18'\n            foundation6 foundation7 foundation9 invalid_def)"], ["proof (state)\nthis:\n  (?\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))) =\n  (x ?\\<tau> = invalid ?\\<tau> \\<or> ?\\<tau> \\<Turnstile> \\<delta> x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "have B: \"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> = x \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n    x \\<tau>", "apply(cases \"x \\<tau>\", metis bot_option_def foundation16)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n        x \\<tau> = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                      \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         x \\<tau>", "apply(rename_tac x', case_tac x', metis bot_option_def foundation16 null_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x' a.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n        x \\<tau> = \\<lfloor>x'\\<rfloor>; x' = \\<lfloor>a\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                      \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                         x \\<tau>", "by(simp)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n  \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n  x \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n       (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\n        \\<tau>", "show \"(x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\"\n    when \"\\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>", "apply(insert that, subst OclIf_false', simp, simp add: A, auto simp: OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_def OclReal0_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<tau> = invalid \\<tau>;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>invalid\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      invalid \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 3. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "(* *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<tau> = invalid \\<tau>;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>invalid\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      invalid \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 3. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "apply(simp add: foundation16'[simplified OclValid_def])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<lfloor>\\<lfloor>\\<lceil>\\<lceil>x\n                   \\<tau>\\<rceil>\\<rceil>\\<rfloor>\\<rfloor> =\n                      x \\<tau>\n 2. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "apply(simp add: B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     (\\<delta> x) \\<tau> \\<noteq> true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> invalid \\<tau> = x \\<tau>", "by(simp add: OclValid_def)"], ["proof (state)\nthis:\n  \\<tau>\n   \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x)) \\<Longrightarrow>\n  (x +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>) \\<tau> =\n  (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif) \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<upsilon> x and not (\\<delta> x)) \\<tau> \\<noteq>\n       true \\<tau> \\<Longrightarrow>\n       \\<tau> \\<Turnstile> not (\\<upsilon> x and not (\\<delta> x))", "qed(metis OclValid_def defined5 defined6 defined_and_I defined_not_I foundation9)"], ["", "lemma OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_zero2[simp,code_unfold] :\n\"(\\<zero>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l x) = (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<zero>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l x) =\n    (if \\<upsilon> x and not (\\<delta> x) then invalid else x endif)", "by(subst OclAdd\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l_commute, simp)"], ["", "(* TODO Basic proproperties for multiplication, division, modulus. *)"], ["", "subsection\\<open>Test Statements\\<close>"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> ( \\<nine>.\\<zero> \\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<one>\\<zero>.\\<zero> )\""], ["", "Assert \"\\<tau> \\<Turnstile> (( \\<four>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<four>.\\<zero> ) \\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<one>\\<zero>.\\<zero> )\""], ["", "Assert \"\\<tau> |\\<noteq> (( \\<four>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l ( \\<four>.\\<zero> +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<four>.\\<zero> )) <\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<one>\\<zero>.\\<zero> )\""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<upsilon> (null +\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<one>.\\<zero>)) \""], ["", "Assert \"\\<tau> \\<Turnstile> (((\\<nine>.\\<zero> *\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<four>.\\<zero>) div\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<one>\\<zero>.\\<zero>) \\<le>\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l  \\<four>.\\<zero>) \""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<delta> (\\<one>.\\<zero> div\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>)) \""], ["", "Assert \"\\<tau> \\<Turnstile> not (\\<upsilon> (\\<one>.\\<zero> div\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l \\<zero>.\\<zero>)) \""], ["", "lemma real_non_null [simp]: \"((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> (null::('\\<AA>)Real)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>) \\<doteq> null) =\n    false", "by(rule ext,auto simp: StrictRefEq\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l valid_def\n                         bot_fun_def bot_option_def null_fun_def null_option_def StrongEq_def)"], ["", "lemma null_non_real [simp]: \"((null::('\\<AA>)Real) \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> (\\<lambda>_. \\<lfloor>\\<lfloor>n\\<rfloor>\\<rfloor>)) =\n    false", "by(rule ext,auto simp: StrictRefEq\\<^sub>R\\<^sub>e\\<^sub>a\\<^sub>l valid_def\n                         bot_fun_def bot_option_def null_fun_def null_option_def StrongEq_def)"], ["", "lemma OclReal0_non_null [simp,code_unfold]: \"(\\<zero>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<zero>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal0_def)"], ["", "lemma null_non_OclReal0 [simp,code_unfold]: \"(null \\<doteq> \\<zero>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<zero>.\\<zero>) = false", "by(simp add: OclReal0_def)"], ["", "lemma OclReal1_non_null [simp,code_unfold]: \"(\\<one>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<one>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal1_def)"], ["", "lemma null_non_OclReal1 [simp,code_unfold]: \"(null \\<doteq> \\<one>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<one>.\\<zero>) = false", "by(simp add: OclReal1_def)"], ["", "lemma OclReal2_non_null [simp,code_unfold]: \"(\\<two>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<two>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal2_def)"], ["", "lemma null_non_OclReal2 [simp,code_unfold]: \"(null \\<doteq> \\<two>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<two>.\\<zero>) = false", "by(simp add: OclReal2_def)"], ["", "lemma OclReal6_non_null [simp,code_unfold]: \"(\\<six>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<six>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal6_def)"], ["", "lemma null_non_OclReal6 [simp,code_unfold]: \"(null \\<doteq> \\<six>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<six>.\\<zero>) = false", "by(simp add: OclReal6_def)"], ["", "lemma OclReal8_non_null [simp,code_unfold]: \"(\\<eight>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<eight>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal8_def)"], ["", "lemma null_non_OclReal8 [simp,code_unfold]: \"(null \\<doteq> \\<eight>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<eight>.\\<zero>) = false", "by(simp add: OclReal8_def)"], ["", "lemma OclReal9_non_null [simp,code_unfold]: \"(\\<nine>.\\<zero> \\<doteq> null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nine>.\\<zero> \\<doteq> null) = false", "by(simp add: OclReal9_def)"], ["", "lemma null_non_OclReal9 [simp,code_unfold]: \"(null \\<doteq> \\<nine>.\\<zero>) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null \\<doteq> \\<nine>.\\<zero>) = false", "by(simp add: OclReal9_def)"], ["", "text\\<open>Here follows a list of code-examples, that explain the meanings\nof the above definitions by compilation to code and execution to @{term \"True\"}.\\<close>"], ["", "text\\<open>Elementary computations on Real\\<close>"], ["", "Assert \"\\<tau> \\<Turnstile> \\<one>.\\<zero> <> \\<two>.\\<zero>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<two>.\\<zero> <> \\<one>.\\<zero>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<two>.\\<zero> \\<doteq> \\<two>.\\<zero>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> \\<four>.\\<zero>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<delta> \\<four>.\\<zero>\""], ["", "Assert \"\\<tau> \\<Turnstile> \\<upsilon> (null::('\\<AA>)Real)\""], ["", "Assert \"\\<tau> \\<Turnstile> (invalid \\<triangleq> invalid)\""], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<triangleq> null)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four>.\\<zero> \\<triangleq> \\<four>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<nine>.\\<zero> \\<triangleq> \\<one>\\<zero>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<triangleq> \\<one>\\<zero>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (null \\<triangleq> \\<one>\\<zero>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (invalid \\<doteq> (invalid::('\\<AA>)Real))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid \\<doteq> (invalid::('\\<AA>)Real))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> (invalid <> (invalid::('\\<AA>)Real))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> |\\<noteq> \\<upsilon> (invalid <> (invalid::('\\<AA>)Real))\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)Real) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (null \\<doteq> (null::('\\<AA>)Real) )\""], ["", "(* Without typeconstraint not executable.*)"], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four>.\\<zero> \\<doteq> \\<four>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<four>.\\<zero> <> \\<four>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<four>.\\<zero> \\<doteq> \\<one>\\<zero>.\\<zero>)\""], ["", "Assert \"\\<tau> \\<Turnstile> (\\<four>.\\<zero> <> \\<one>\\<zero>.\\<zero>)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<zero>.\\<zero> <\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l null)\""], ["", "Assert \"\\<tau> |\\<noteq> (\\<delta> (\\<zero>.\\<zero> <\\<^sub>r\\<^sub>e\\<^sub>a\\<^sub>l null))\""], ["", "end"]]}