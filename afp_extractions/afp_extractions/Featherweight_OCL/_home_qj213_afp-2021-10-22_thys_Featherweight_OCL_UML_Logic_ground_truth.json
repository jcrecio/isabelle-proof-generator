{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_Logic.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma bot_Boolean_def : \"(bot::('\\<AA>)Boolean) = (\\<lambda> \\<tau>. \\<bottom>)\"", "lemma null_Boolean_def : \"(null::('\\<AA>)Boolean) = (\\<lambda> \\<tau>. \\<lfloor>\\<bottom>\\<rfloor>)\"", "lemma bool_split_0: \"X \\<tau> = invalid \\<tau> \\<or> X \\<tau> = null \\<tau> \\<or>\n                   X \\<tau> = true \\<tau>    \\<or> X \\<tau> = false \\<tau>\"", "lemma [simp]: \"false (a, b) = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\"", "lemma [simp]: \"true (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\"", "lemma textbook_true: \"I\\<lbrakk>true\\<rbrakk> \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\"", "lemma textbook_false: \"I\\<lbrakk>false\\<rbrakk> \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\"", "lemma valid1[simp]: \"\\<upsilon> invalid = false\"", "lemma valid2[simp]: \"\\<upsilon> null = true\"", "lemma valid3[simp]: \"\\<upsilon> true = true\"", "lemma valid4[simp]: \"\\<upsilon> false = true\"", "lemma cp_valid: \"(\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda> _. X \\<tau>)) \\<tau>\"", "lemma defined1[simp]: \"\\<delta> invalid = false\"", "lemma defined2[simp]: \"\\<delta> null = false\"", "lemma defined3[simp]: \"\\<delta> true = true\"", "lemma defined4[simp]: \"\\<delta> false = true\"", "lemma defined5[simp]: \"\\<delta> \\<delta> X = true\"", "lemma defined6[simp]: \"\\<delta> \\<upsilon> X = true\"", "lemma valid5[simp]: \"\\<upsilon> \\<upsilon> X = true\"", "lemma valid6[simp]: \"\\<upsilon> \\<delta> X = true\"", "lemma cp_defined:\"(\\<delta> X)\\<tau> = (\\<delta> (\\<lambda> _. X \\<tau>)) \\<tau>\"", "lemma textbook_defined: \"I\\<lbrakk>\\<delta>(X)\\<rbrakk> \\<tau> = (if I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>bot\\<rbrakk> \\<tau>  \\<or> I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>null\\<rbrakk> \\<tau>\n                                     then I\\<lbrakk>false\\<rbrakk> \\<tau>\n                                     else I\\<lbrakk>true\\<rbrakk> \\<tau>)\"", "lemma textbook_valid: \"I\\<lbrakk>\\<upsilon>(X)\\<rbrakk> \\<tau> = (if I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>bot\\<rbrakk> \\<tau>\n                                   then I\\<lbrakk>false\\<rbrakk> \\<tau>\n                                   else I\\<lbrakk>true\\<rbrakk> \\<tau>)\"", "lemma [simp,code_unfold]: \"(true \\<triangleq> false) = false\"", "lemma [simp,code_unfold]: \"(false \\<triangleq> true) = false\"", "lemma StrongEq_refl [simp]: \"(X \\<triangleq> X) = true\"", "lemma StrongEq_sym: \"(X \\<triangleq> Y) = (Y \\<triangleq> X)\"", "lemma StrongEq_trans_strong [simp]:\n  assumes A: \"(X \\<triangleq> Y) = true\"\n  and     B: \"(Y \\<triangleq> Z) = true\"\n  shows   \"(X \\<triangleq> Z) = true\"", "lemma StrongEq_subst :\n  assumes cp: \"\\<And>X. P(X)\\<tau> = P(\\<lambda> _. X \\<tau>)\\<tau>\"\n  and     eq: \"(X \\<triangleq> Y)\\<tau> = true \\<tau>\"\n  shows   \"(P X \\<triangleq> P Y)\\<tau> = true \\<tau>\"", "lemma defined7[simp]: \"\\<delta> (X \\<triangleq> Y) = true\"", "lemma valid7[simp]: \"\\<upsilon> (X \\<triangleq> Y) = true\"", "lemma cp_StrongEq: \"(X \\<triangleq> Y) \\<tau> = ((\\<lambda> _. X \\<tau>) \\<triangleq> (\\<lambda> _. Y \\<tau>)) \\<tau>\"", "lemma cp_OclNot: \"(not X)\\<tau> = (not (\\<lambda> _. X \\<tau>)) \\<tau>\"", "lemma OclNot1[simp]: \"not invalid = invalid\"", "lemma OclNot2[simp]: \"not null = null\"", "lemma OclNot3[simp]: \"not true = false\"", "lemma OclNot4[simp]: \"not false = true\"", "lemma OclNot_not[simp]: \"not (not X) = X\"", "lemma OclNot_inject: \"\\<And> x y. not x = not y \\<Longrightarrow> x = y\"", "lemma textbook_OclNot:\n     \"I\\<lbrakk>not(X)\\<rbrakk> \\<tau> =  (case I\\<lbrakk>X\\<rbrakk> \\<tau> of   \\<bottom>   \\<Rightarrow> \\<bottom>\n                                 |  \\<lfloor> \\<bottom> \\<rfloor> \\<Rightarrow> \\<lfloor> \\<bottom> \\<rfloor>\n                                 | \\<lfloor>\\<lfloor> x \\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<lfloor> \\<not> x \\<rfloor>\\<rfloor>)\"", "lemma textbook_OclAnd:\n     \"I\\<lbrakk>X and Y\\<rbrakk> \\<tau> = (case I\\<lbrakk>X\\<rbrakk> \\<tau> of\n                            \\<bottom>  \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n                                          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)\n                        | \\<lfloor> \\<bottom> \\<rfloor> \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)\n                        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor>)\n                        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor> False \\<rfloor>\\<rfloor>)\"", "lemma cp_OclAnd:\"(X and Y) \\<tau> = ((\\<lambda> _. X \\<tau>) and (\\<lambda> _. Y \\<tau>)) \\<tau>\"", "lemma cp_OclOr:\"((X::('\\<AA>)Boolean) or Y) \\<tau> = ((\\<lambda> _. X \\<tau>) or (\\<lambda> _. Y \\<tau>)) \\<tau>\"", "lemma cp_OclImplies:\"(X implies Y) \\<tau> = ((\\<lambda> _. X \\<tau>) implies (\\<lambda> _. Y \\<tau>)) \\<tau>\"", "lemma OclAnd1[simp]: \"(invalid and true) = invalid\"", "lemma OclAnd2[simp]: \"(invalid and false) = false\"", "lemma OclAnd3[simp]: \"(invalid and null) = invalid\"", "lemma OclAnd4[simp]: \"(invalid and invalid) = invalid\"", "lemma OclAnd5[simp]: \"(null and true) = null\"", "lemma OclAnd6[simp]: \"(null and false) = false\"", "lemma OclAnd7[simp]: \"(null and null) = null\"", "lemma OclAnd8[simp]: \"(null and invalid) = invalid\"", "lemma OclAnd9[simp]: \"(false and true) = false\"", "lemma OclAnd10[simp]: \"(false and false) = false\"", "lemma OclAnd11[simp]: \"(false and null) = false\"", "lemma OclAnd12[simp]: \"(false and invalid) = false\"", "lemma OclAnd13[simp]: \"(true and true) = true\"", "lemma OclAnd14[simp]: \"(true and false) = false\"", "lemma OclAnd15[simp]: \"(true and null) = null\"", "lemma OclAnd16[simp]: \"(true and invalid) = invalid\"", "lemma OclAnd_idem[simp]: \"(X and X) = X\"", "lemma OclAnd_commute: \"(X and Y) = (Y and X)\"", "lemma OclAnd_false1[simp]: \"(false and X) = false\"", "lemma OclAnd_false2[simp]: \"(X and false) = false\"", "lemma OclAnd_true1[simp]: \"(true and X) = X\"", "lemma OclAnd_true2[simp]: \"(X and true) = X\"", "lemma OclAnd_bot1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> (bot and X) \\<tau> = bot \\<tau>\"", "lemma OclAnd_bot2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> (X and bot) \\<tau> = bot \\<tau>\"", "lemma OclAnd_null1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (null and X) \\<tau> = null \\<tau>\"", "lemma OclAnd_null2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (X and null) \\<tau> = null \\<tau>\"", "lemma OclAnd_assoc: \"(X and (Y and Z)) = (X and Y and Z)\"", "lemma OclOr1[simp]: \"(invalid or true) = true\"", "lemma OclOr2[simp]: \"(invalid or false) = invalid\"", "lemma OclOr3[simp]: \"(invalid or null) = invalid\"", "lemma OclOr4[simp]: \"(invalid or invalid) = invalid\"", "lemma OclOr5[simp]: \"(null or true) = true\"", "lemma OclOr6[simp]: \"(null or false) = null\"", "lemma OclOr7[simp]: \"(null or null) = null\"", "lemma OclOr8[simp]: \"(null or invalid) = invalid\"", "lemma OclOr_idem[simp]: \"(X or X) = X\"", "lemma OclOr_commute: \"(X or Y) = (Y or X)\"", "lemma OclOr_false1[simp]: \"(false or Y) = Y\"", "lemma OclOr_false2[simp]: \"(Y or false) = Y\"", "lemma OclOr_true1[simp]: \"(true or Y) = true\"", "lemma OclOr_true2: \"(Y or true) = true\"", "lemma OclOr_bot1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> (bot or X) \\<tau> = bot \\<tau>\"", "lemma OclOr_bot2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> (X or bot) \\<tau> = bot \\<tau>\"", "lemma OclOr_null1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (null or X) \\<tau> = null \\<tau>\"", "lemma OclOr_null2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (X or null) \\<tau> = null \\<tau>\"", "lemma OclOr_assoc: \"(X or (Y or Z)) = (X or Y or Z)\"", "lemma deMorgan1: \"not(X and Y) = ((not X) or (not Y))\"", "lemma deMorgan2: \"not(X or Y) = ((not X) and (not Y))\"", "lemma OclImplies_true1[simp]:\"(true implies X) = X\"", "lemma OclImplies_true2[simp]: \"(X implies true) = true\"", "lemma OclImplies_false1[simp]:\"(false implies X) = true\"", "lemma transform1: \"P = true \\<Longrightarrow> \\<tau> \\<Turnstile> P\"", "lemma transform1_rev: \"\\<forall> \\<tau>. \\<tau> \\<Turnstile> P \\<Longrightarrow> P = true\"", "lemma transform2: \"(P = Q) \\<Longrightarrow> ((\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q))\"", "lemma transform2_rev: \"\\<forall> \\<tau>. (\\<tau> \\<Turnstile> \\<delta> P) \\<and> (\\<tau> \\<Turnstile> \\<delta> Q) \\<and> (\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q) \\<Longrightarrow> P = Q\"", "lemma (*transform3:*)\nassumes H : \"P = true \\<Longrightarrow> Q = true\"\nshows \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> Q\"", "lemma foundation1[simp]: \"\\<tau> \\<Turnstile> true\"", "lemma foundation2[simp]: \"\\<not>(\\<tau> \\<Turnstile> false)\"", "lemma foundation3[simp]: \"\\<not>(\\<tau> \\<Turnstile> invalid)\"", "lemma foundation4[simp]: \"\\<not>(\\<tau> \\<Turnstile> null)\"", "lemma bool_split[simp]:\n\"(\\<tau> \\<Turnstile> (x \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> null)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> true)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> false))\"", "lemma defined_split:\n\"(\\<tau> \\<Turnstile> \\<delta> x) = ((\\<not>(\\<tau> \\<Turnstile> (x \\<triangleq> invalid))) \\<and> (\\<not> (\\<tau> \\<Turnstile> (x \\<triangleq> null))))\"", "lemma valid_bool_split: \"(\\<tau> \\<Turnstile> \\<upsilon> A) = ((\\<tau> \\<Turnstile> A \\<triangleq> null) \\<or> (\\<tau> \\<Turnstile> A) \\<or>  (\\<tau> \\<Turnstile> not A)) \"", "lemma defined_bool_split: \"(\\<tau> \\<Turnstile> \\<delta> A) = ((\\<tau> \\<Turnstile> A) \\<or> (\\<tau> \\<Turnstile> not A))\"", "lemma foundation5:\n\"\\<tau> \\<Turnstile> (P and Q) \\<Longrightarrow> (\\<tau> \\<Turnstile> P) \\<and> (\\<tau> \\<Turnstile> Q)\"", "lemma foundation6:\n\"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> P\"", "lemma foundation7[simp]:\n\"(\\<tau> \\<Turnstile> not (\\<delta> x)) = (\\<not> (\\<tau> \\<Turnstile> \\<delta> x))\"", "lemma foundation7'[simp]:\n\"(\\<tau> \\<Turnstile> not (\\<upsilon> x)) = (\\<not> (\\<tau> \\<Turnstile> \\<upsilon> x))\"", "lemma foundation8:\n\"(\\<tau> \\<Turnstile> \\<delta> x) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> null))\"", "lemma foundation9:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> (\\<tau> \\<Turnstile> not x) = (\\<not> (\\<tau> \\<Turnstile> x))\"", "lemma foundation9':\n\"\\<tau> \\<Turnstile> not x \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> x)\"", "lemma foundation9'':\n\"            \\<tau> \\<Turnstile> not x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> x\"", "lemma foundation10:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> y \\<Longrightarrow> (\\<tau> \\<Turnstile> (x and y)) = ( (\\<tau> \\<Turnstile> x) \\<and> (\\<tau> \\<Turnstile> y))\"", "lemma foundation10': \"(\\<tau> \\<Turnstile> (A and B)) = ((\\<tau> \\<Turnstile> A) \\<and> (\\<tau> \\<Turnstile> B))\"", "lemma foundation11:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> y \\<Longrightarrow> (\\<tau> \\<Turnstile> (x or y)) = ( (\\<tau> \\<Turnstile> x) \\<or> (\\<tau> \\<Turnstile> y))\"", "lemma foundation12:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> (\\<tau> \\<Turnstile> (x implies y)) = ( (\\<tau> \\<Turnstile> x) \\<longrightarrow> (\\<tau> \\<Turnstile> y))\"", "lemma foundation13:\"(\\<tau> \\<Turnstile> A \\<triangleq> true)    = (\\<tau> \\<Turnstile> A)\"", "lemma foundation14:\"(\\<tau> \\<Turnstile> A \\<triangleq> false)   = (\\<tau> \\<Turnstile> not A)\"", "lemma foundation15:\"(\\<tau> \\<Turnstile> A \\<triangleq> invalid) = (\\<tau> \\<Turnstile> not(\\<upsilon> A))\"", "lemma foundation16: \"\\<tau> \\<Turnstile> (\\<delta> X) = (X \\<tau> \\<noteq> bot \\<and> X \\<tau> \\<noteq> null)\"", "lemma foundation16'': \"\\<not>(\\<tau> \\<Turnstile> (\\<delta> X)) = ((\\<tau> \\<Turnstile> (X \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (X \\<triangleq> null)))\"", "lemma foundation16': \"(\\<tau> \\<Turnstile> (\\<delta> X)) = (X \\<tau> \\<noteq> invalid \\<tau> \\<and> X \\<tau> \\<noteq> null \\<tau>)\"", "lemma foundation18: \"(\\<tau> \\<Turnstile> (\\<upsilon> X)) = (X \\<tau> \\<noteq> invalid \\<tau>)\"", "lemma foundation18': \"(\\<tau> \\<Turnstile> (\\<upsilon> X)) = (X \\<tau> \\<noteq> bot)\"", "lemma foundation18'': \"(\\<tau> \\<Turnstile> (\\<upsilon> X) )=  (\\<not>(\\<tau> \\<Turnstile> (X \\<triangleq> invalid)))\"", "lemma foundation20 : \"\\<tau> \\<Turnstile> (\\<delta> X) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\"", "lemma foundation21: \"(not A \\<triangleq> not B) = (A \\<triangleq> B)\"", "lemma foundation22: \"(\\<tau> \\<Turnstile> (X \\<triangleq> Y)) = (X \\<tau> = Y \\<tau>)\"", "lemma foundation23: \"(\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> (\\<lambda> _ . P \\<tau>))\"", "lemma foundation24:\"(\\<tau> \\<Turnstile> not(X \\<triangleq> Y)) = (X \\<tau> \\<noteq> Y \\<tau>)\"", "lemma foundation25: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> (P or Q)\"", "lemma foundation25': \"\\<tau> \\<Turnstile> Q \\<Longrightarrow> \\<tau> \\<Turnstile> (P or Q)\"", "lemma foundation26:\nassumes defP: \"\\<tau> \\<Turnstile> \\<delta> P\"\nassumes defQ: \"\\<tau> \\<Turnstile> \\<delta> Q\"\nassumes H: \"\\<tau> \\<Turnstile> (P or Q)\"\nassumes P: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> R\"\nassumes Q: \"\\<tau> \\<Turnstile> Q \\<Longrightarrow> R\"\nshows \"R\"", "lemma foundation27: \"\\<tau> \\<Turnstile> A \\<Longrightarrow> (\\<tau> \\<Turnstile> A implies B) = (\\<tau> \\<Turnstile> B)\"", "lemma defined_not_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (not x)\"", "lemma valid_not_I : \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (not x)\"", "lemma defined_and_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x and y)\"", "lemma valid_and_I :   \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<upsilon> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x and y)\"", "lemma defined_or_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x or y)\"", "lemma valid_or_I :   \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<upsilon> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x or y)\"", "lemma StrongEq_L_refl: \"\\<tau> \\<Turnstile> (x \\<triangleq> x)\"", "lemma StrongEq_L_sym: \"\\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (y \\<triangleq> x)\"", "lemma StrongEq_L_trans: \"\\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (y \\<triangleq> z) \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> z)\"", "lemma StrongEq_L_subst1: \"\\<And> \\<tau>. cp P \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (P x \\<triangleq> P y)\"", "lemma StrongEq_L_subst2:\n\"\\<And> \\<tau>.  cp P \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (P x) \\<Longrightarrow> \\<tau> \\<Turnstile> (P y)\"", "lemma StrongEq_L_subst2_rev: \"\\<tau> \\<Turnstile> y \\<triangleq> x \\<Longrightarrow> cp P \\<Longrightarrow> \\<tau> \\<Turnstile> P x \\<Longrightarrow> \\<tau> \\<Turnstile> P y\"", "lemma  StrongEq_L_subst3:\nassumes cp: \"cp P\"\nand     eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\"\nshows       \"(\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)\"", "lemma  StrongEq_L_subst3_rev:\nassumes eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\" \nand     cp: \"cp P\"\nshows       \"(\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)\"", "lemma  StrongEq_L_subst4_rev:\nassumes eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\" \nand     cp: \"cp P\"\nshows       \"(\\<not>(\\<tau> \\<Turnstile> P x)) = (\\<not>(\\<tau> \\<Turnstile> P y))\"", "lemma cpI1:\n\"(\\<forall> X \\<tau>. f X \\<tau> = f(\\<lambda>_. X \\<tau>) \\<tau>) \\<Longrightarrow> cp P \\<Longrightarrow> cp(\\<lambda>X. f (P X))\"", "lemma cpI2:\n\"(\\<forall> X Y \\<tau>. f X Y \\<tau> = f(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X))\"", "lemma cpI3:\n\"(\\<forall> X Y Z \\<tau>. f X Y Z \\<tau> = f(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X) (R X))\"", "lemma cpI4:\n\"(\\<forall> W X Y Z \\<tau>. f W X Y Z \\<tau> = f(\\<lambda>_. W \\<tau>)(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp S \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X) (R X) (S X))\"", "lemma cpI5:\n\"(\\<forall> V W X Y Z \\<tau>. f V W X Y Z \\<tau> = f(\\<lambda>_. V \\<tau>) (\\<lambda>_. W \\<tau>)(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp N \\<Longrightarrow> cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp S \\<Longrightarrow> cp(\\<lambda>X. f (N X) (P X) (Q X) (R X) (S X))\"", "lemma cp_const : \"cp(\\<lambda>_. c)\"", "lemma cp_id :     \"cp(\\<lambda>X. X)\"", "lemmas cp_intro[intro!,simp,code_unfold] =\n       cp_const\n       cp_id\n       cp_defined[THEN allI[THEN allI[THEN cpI1], of defined]]\n       cp_valid[THEN allI[THEN allI[THEN cpI1], of valid]]\n       cp_OclNot[THEN allI[THEN allI[THEN cpI1], of not]]\n       cp_OclAnd[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(and)\"]]\n       cp_OclOr[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(or)\"]]\n       cp_OclImplies[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(implies)\"]]\n       cp_StrongEq[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n                   of \"StrongEq\"]]", "lemma cp_OclIf:\"((if C then B\\<^sub>1 else B\\<^sub>2 endif) \\<tau> =\n                  (if (\\<lambda> _. C \\<tau>) then (\\<lambda> _. B\\<^sub>1 \\<tau>) else (\\<lambda> _. B\\<^sub>2 \\<tau>) endif) \\<tau>)\"", "lemmas cp_intro'[intro!,simp,code_unfold] =\n       cp_intro\n       cp_OclIf[THEN allI[THEN allI[THEN allI[THEN allI[THEN cpI3]]], of \"OclIf\"]]", "lemma OclIf_invalid [simp]: \"(if invalid then B\\<^sub>1 else B\\<^sub>2 endif) = invalid\"", "lemma OclIf_null [simp]: \"(if null then B\\<^sub>1 else B\\<^sub>2 endif) = invalid\"", "lemma OclIf_true [simp]: \"(if true then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>1\"", "lemma OclIf_true' [simp]: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> (if P then B\\<^sub>1 else B\\<^sub>2 endif)\\<tau> = B\\<^sub>1 \\<tau>\"", "lemma OclIf_true'' [simp]: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> (if P then B\\<^sub>1 else B\\<^sub>2 endif) \\<triangleq> B\\<^sub>1\"", "lemma OclIf_false [simp]: \"(if false then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>2\"", "lemma OclIf_false' [simp]: \"\\<tau> \\<Turnstile> not P \\<Longrightarrow> (if P then B\\<^sub>1 else B\\<^sub>2 endif)\\<tau> = B\\<^sub>2 \\<tau>\"", "lemma OclIf_idem1[simp]:\"(if \\<delta> X then A else A endif) = A\"", "lemma OclIf_idem2[simp]:\"(if \\<upsilon> X then A else A endif) = A\"", "lemma OclNot_if[simp]:\n\"not(if P then C else E endif) = (if P then not C else not E endif)\"", "lemma OclNot_defargs:\n\"\\<tau> \\<Turnstile> (not P) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> P\"", "lemma OclNot_contrapos_nn:\n assumes A: \"\\<tau> \\<Turnstile> \\<delta> A\"\n assumes B: \"\\<tau> \\<Turnstile> not B\"\n assumes C: \"\\<tau> \\<Turnstile> A \\<Longrightarrow> \\<tau> \\<Turnstile> B\"\n shows      \"\\<tau> \\<Turnstile> not A\"", "lemma const_charn: \"const X \\<Longrightarrow> X \\<tau> = X \\<tau>'\"", "lemma const_subst:\n assumes const_X: \"const X\"\n     and const_Y: \"const Y\"\n     and eq :     \"X \\<tau> = Y \\<tau>\"\n     and cp_P:    \"cp P\"\n     and pp :     \"P Y \\<tau> = P Y \\<tau>'\"\n   shows \"P X \\<tau> = P X \\<tau>'\"", "lemma const_imply2 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q\"", "lemma const_imply3 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>' \\<Longrightarrow> R \\<tau> = R \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q \\<Longrightarrow> const R\"", "lemma const_imply4 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>' \\<Longrightarrow> R \\<tau> = R \\<tau>' \\<Longrightarrow> S \\<tau> = S \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q \\<Longrightarrow> const R \\<Longrightarrow> const S\"", "lemma const_lam : \"const (\\<lambda>_. e)\"", "lemma const_true[simp] : \"const true\"", "lemma const_false[simp] : \"const false\"", "lemma const_null[simp] : \"const null\"", "lemma const_invalid [simp]: \"const invalid\"", "lemma const_bot[simp] : \"const bot\"", "lemma const_defined :\n assumes \"const X\"\n shows   \"const (\\<delta> X)\"", "lemma const_valid :\n assumes \"const X\"\n shows   \"const (\\<upsilon> X)\"", "lemma const_OclAnd :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X and X')\"", "lemma const_OclNot :\n    assumes \"const X\"\n    shows   \"const (not X)\"", "lemma const_OclOr :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X or X')\"", "lemma const_OclImplies :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X implies X')\"", "lemma const_StrongEq:\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const(X \\<triangleq> X')\"", "lemma const_OclIf :\n  assumes \"const B\"\n      and \"const C1\"\n      and \"const C2\"\n    shows \"const (if B then C1 else C2 endif)\"", "lemma const_OclValid1:\n assumes \"const x\"\n shows   \"(\\<tau> \\<Turnstile> \\<delta> x) = (\\<tau>' \\<Turnstile> \\<delta> x)\"", "lemma const_OclValid2:\n assumes \"const x\"\n shows   \"(\\<tau> \\<Turnstile> \\<upsilon> x) = (\\<tau>' \\<Turnstile> \\<upsilon> x)\"", "lemma const_HOL_if : \"const C \\<Longrightarrow> const D \\<Longrightarrow> const F \\<Longrightarrow> const (\\<lambda>\\<tau>. if C \\<tau> then D \\<tau> else F \\<tau>)\"", "lemma const_HOL_and: \"const C \\<Longrightarrow> const D \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> \\<and> D \\<tau>)\"", "lemma const_HOL_eq : \"const C \\<Longrightarrow> const D \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> = D \\<tau>)\"", "lemmas const_ss = const_bot const_null  const_invalid  const_false  const_true  const_lam\n                  const_defined const_valid const_StrongEq const_OclNot const_OclAnd\n                  const_OclOr const_OclImplies const_OclIf\n                  const_HOL_if const_HOL_and const_HOL_eq"], "translations": [["", "lemma bot_Boolean_def : \"(bot::('\\<AA>)Boolean) = (\\<lambda> \\<tau>. \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UML_Types.bot_class.bot = Map.empty", "by(simp add: bot_fun_def bot_option_def)"], ["", "lemma null_Boolean_def : \"(null::('\\<AA>)Boolean) = (\\<lambda> \\<tau>. \\<lfloor>\\<bottom>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null = (\\<lambda>\\<tau>. \\<lfloor>\\<bottom>\\<rfloor>)", "by(simp add: null_fun_def null_option_def bot_option_def)"], ["", "definition true :: \"('\\<AA>)Boolean\"\nwhere     \"true \\<equiv> \\<lambda> \\<tau>. \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\""], ["", "definition false :: \"('\\<AA>)Boolean\"\nwhere     \"false \\<equiv>  \\<lambda> \\<tau>. \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\""], ["", "lemma bool_split_0: \"X \\<tau> = invalid \\<tau> \\<or> X \\<tau> = null \\<tau> \\<or>\n                   X \\<tau> = true \\<tau>    \\<or> X \\<tau> = false \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<tau> = invalid \\<tau> \\<or>\n    X \\<tau> = null \\<tau> \\<or>\n    X \\<tau> = true \\<tau> \\<or> X \\<tau> = false \\<tau>", "apply(simp add: invalid_def null_def true_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<tau> = UML_Types.bot_class.bot \\<or>\n    X \\<tau> = null \\<tau> \\<or>\n    X \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<or>\n    X \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>", "apply(case_tac \"X \\<tau>\",simp_all add: null_fun_def null_option_def bot_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       X \\<tau> = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       a = \\<bottom> \\<or>\n       a = \\<lfloor>True\\<rfloor> \\<or> a = \\<lfloor>False\\<rfloor>", "apply(case_tac \"a\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>X \\<tau> = \\<lfloor>a\\<rfloor>;\n        a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> a = \\<bottom> \\<or>\n                         a = \\<lfloor>True\\<rfloor> \\<or>\n                         a = \\<lfloor>False\\<rfloor>", "apply(case_tac \"aa\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a aa.\n       \\<lbrakk>X \\<tau> = \\<lfloor>a\\<rfloor>; a = \\<lfloor>aa\\<rfloor>;\n        \\<not> aa\\<rbrakk>\n       \\<Longrightarrow> a = \\<bottom> \\<or>\n                         a = \\<lfloor>True\\<rfloor> \\<or>\n                         a = \\<lfloor>False\\<rfloor>", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"false (a, b) = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. false (a, b) = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>", "by(simp add:false_def)"], ["", "lemma [simp]: \"true (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. true (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>", "by(simp add:true_def)"], ["", "lemma textbook_true: \"I\\<lbrakk>true\\<rbrakk> \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>true\\<rbrakk> \\<tau> =\n    \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>", "by(simp add: Sem_def true_def)"], ["", "lemma textbook_false: \"I\\<lbrakk>false\\<rbrakk> \\<tau> = \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>false\\<rbrakk> \\<tau> =\n    \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>", "by(simp add: Sem_def false_def)"], ["", "text \\<open>\n\\begin{table}[htbp]\n   \\centering\n   \\begin{tabu}{lX[,c,]}\n      \\toprule\n      Name & Theorem \\\\\n      \\midrule\n      @{thm [source] textbook_invalid}  & @{thm  [display=false] textbook_invalid} \\\\\n      @{thm [source] textbook_null_fun}  & @{thm [display=false] textbook_null_fun} \\\\\n      @{thm [source] textbook_true}   & @{thm  [display=false] textbook_true} \\\\\n      @{thm [source] textbook_false} & @{thm [display=false] textbook_false} \\\\\n      \\bottomrule\n   \\end{tabu}\n   \\caption{Basic semantic constant definitions of the logic}\n   \\label{tab:sem_basic_constants}\n\\end{table}\n\\<close>"], ["", "subsection\\<open>Validity and Definedness\\<close>"], ["", "text\\<open>However, this has also the consequence that core concepts like definedness,\nvalidity and even cp have to be redefined on this type class:\\<close>"], ["", "definition valid :: \"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>)Boolean\" (\"\\<upsilon> _\" [100]100)\nwhere   \"\\<upsilon> X \\<equiv>  \\<lambda> \\<tau> . if X \\<tau> = bot \\<tau> then false \\<tau> else true \\<tau>\""], ["", "lemma valid1[simp]: \"\\<upsilon> invalid = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> invalid = false", "by(rule ext,simp add: valid_def bot_fun_def bot_option_def\n                        invalid_def true_def false_def)"], ["", "lemma valid2[simp]: \"\\<upsilon> null = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> null = true", "by(rule ext,simp add: valid_def bot_fun_def bot_option_def null_is_valid\n                        null_fun_def invalid_def true_def false_def)"], ["", "lemma valid3[simp]: \"\\<upsilon> true = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> true = true", "by(rule ext,simp add: valid_def bot_fun_def bot_option_def null_is_valid\n                        null_fun_def invalid_def true_def false_def)"], ["", "lemma valid4[simp]: \"\\<upsilon> false = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> false = true", "by(rule ext,simp add: valid_def bot_fun_def bot_option_def null_is_valid\n                        null_fun_def invalid_def true_def false_def)"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemma cp_valid: \"(\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda> _. X \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>", "by(simp add: valid_def)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "definition defined :: \"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>)Boolean\" (\"\\<delta> _\" [100]100)\nwhere   \"\\<delta> X \\<equiv>  \\<lambda> \\<tau> . if X \\<tau> = bot \\<tau>  \\<or> X \\<tau> = null \\<tau> then false \\<tau> else true \\<tau>\""], ["", "text\\<open>The generalized definitions of invalid and definedness have the same\nproperties as the old ones :\\<close>"], ["", "lemma defined1[simp]: \"\\<delta> invalid = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> invalid = false", "by(rule ext,simp add: defined_def bot_fun_def bot_option_def\n                        null_def invalid_def true_def false_def)"], ["", "lemma defined2[simp]: \"\\<delta> null = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> null = false", "by(rule ext,simp add: defined_def bot_fun_def bot_option_def\n                        null_def null_option_def null_fun_def invalid_def true_def false_def)"], ["", "lemma defined3[simp]: \"\\<delta> true = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> true = true", "by(rule ext,simp add: defined_def bot_fun_def bot_option_def null_is_valid null_option_def\n                        null_fun_def invalid_def true_def false_def)"], ["", "lemma defined4[simp]: \"\\<delta> false = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> false = true", "by(rule ext,simp add: defined_def bot_fun_def bot_option_def null_is_valid null_option_def\n                        null_fun_def invalid_def true_def false_def)"], ["", "lemma defined5[simp]: \"\\<delta> \\<delta> X = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<delta> X = true", "by(rule ext,\n     auto simp:           defined_def true_def false_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma defined6[simp]: \"\\<delta> \\<upsilon> X = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> \\<upsilon> X = true", "by(rule ext,\n     auto simp: valid_def defined_def true_def false_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma valid5[simp]: \"\\<upsilon> \\<upsilon> X = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<upsilon> X = true", "by(rule ext,\n     auto simp: valid_def             true_def false_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma valid6[simp]: \"\\<upsilon> \\<delta> X = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> \\<delta> X = true", "by(rule ext,\n     auto simp: valid_def defined_def true_def false_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemma cp_defined:\"(\\<delta> X)\\<tau> = (\\<delta> (\\<lambda> _. X \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<delta> X) \\<tau> = (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>", "by(simp add: defined_def)"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "text\\<open>The definitions above for the constants @{const defined} and @{const valid}\ncan be rewritten into the conventional semantic \"textbook\" format  as follows:\\<close>"], ["", "lemma textbook_defined: \"I\\<lbrakk>\\<delta>(X)\\<rbrakk> \\<tau> = (if I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>bot\\<rbrakk> \\<tau>  \\<or> I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>null\\<rbrakk> \\<tau>\n                                     then I\\<lbrakk>false\\<rbrakk> \\<tau>\n                                     else I\\<lbrakk>true\\<rbrakk> \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>\\<delta> X\\<rbrakk> \\<tau> =\n    (if I\\<lbrakk>X\\<rbrakk> \\<tau> =\n        I\\<lbrakk>UML_Types.bot_class.bot\\<rbrakk> \\<tau> \\<or>\n        I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>null\\<rbrakk> \\<tau>\n     then I\\<lbrakk>false\\<rbrakk> \\<tau>\n     else I\\<lbrakk>true\\<rbrakk> \\<tau>)", "by(simp add: Sem_def defined_def)"], ["", "lemma textbook_valid: \"I\\<lbrakk>\\<upsilon>(X)\\<rbrakk> \\<tau> = (if I\\<lbrakk>X\\<rbrakk> \\<tau> = I\\<lbrakk>bot\\<rbrakk> \\<tau>\n                                   then I\\<lbrakk>false\\<rbrakk> \\<tau>\n                                   else I\\<lbrakk>true\\<rbrakk> \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>\\<upsilon> X\\<rbrakk> \\<tau> =\n    (if I\\<lbrakk>X\\<rbrakk> \\<tau> =\n        I\\<lbrakk>UML_Types.bot_class.bot\\<rbrakk> \\<tau>\n     then I\\<lbrakk>false\\<rbrakk> \\<tau>\n     else I\\<lbrakk>true\\<rbrakk> \\<tau>)", "by(simp add: Sem_def valid_def)"], ["", "text \\<open>\n\\autoref{tab:sem_definedness} and \\autoref{tab:alglaws_definedness}\nsummarize the results of this section.\n\\begin{table}[htbp]\n   \\centering\n   \\begin{tabu}{lX[,c,]}\n      \\toprule\n      Name & Theorem \\\\\n      \\midrule\n      @{thm [source] textbook_defined}  & @{thm [show_question_marks=false,display=false,margin=45] textbook_defined} \\\\\n      @{thm [source] textbook_valid}   & @{thm [show_question_marks=false,display=false,margin=45] textbook_valid} \\\\\n      \\bottomrule\n   \\end{tabu}\n   \\caption{Basic predicate definitions of the logic.}\n   \\label{tab:sem_definedness}\n\\end{table}\n\\begin{table}[htbp]\n   \\centering\n   \\begin{tabu}{lX[,c,]}\n      \\toprule\n      Name & Theorem \\\\\n      \\midrule\n      @{thm [source] defined1}  & @{thm  defined1} \\\\\n      @{thm [source] defined2}   & @{thm [display=false,margin=35] defined2} \\\\\n      @{thm [source] defined3}   & @{thm [display=false,margin=35] defined3} \\\\\n      @{thm [source] defined4}   & @{thm [display=false,margin=35] defined4} \\\\\n      @{thm [source] defined5}   & @{thm [display=false,margin=35] defined5} \\\\\n      @{thm [source] defined6}   & @{thm [display=false,margin=35] defined6} \\\\\n      \\bottomrule\n   \\end{tabu}\n   \\caption{Laws of the basic predicates of the logic.}\n   \\label{tab:alglaws_definedness}\n\\end{table}\n\\<close>"], ["", "subsection\\<open>The Equalities of OCL \\label{sec:equality}\\<close>"], ["", "text\\<open>\n  The OCL contains a particular version of equality, written in\n  Standard documents \\inlineocl+_ = _+ and \\inlineocl+_ <> _+ for its\n  negation, which is referred as \\emph{weak referential equality}\n  hereafter and for which we use the symbol \\inlineisar+_ \\<doteq> _+\n  throughout the formal part of this document. Its semantics is\n  motivated by the desire of fast execution, and similarity to\n  languages like Java and C, but does not satisfy the needs of logical\n  reasoning over OCL expressions and specifications. We therefore\n  introduce a second equality, referred as \\emph{strong equality} or\n  \\emph{logical equality} and written \\inlineisar+_ \\<triangleq> _+\n  which is not present in the current standard but was discussed in\n  prior texts on OCL like the Amsterdam\n  Manifesto~\\cite{cook.ea::amsterdam:2002} and was identified as\n  desirable extension of OCL in the Aachen\n  Meeting~\\cite{brucker.ea:summary-aachen:2013} in the future 2.5 OCL\n  Standard. The purpose of strong equality is to define and reason\n  over OCL. It is therefore a natural task in Featherweight OCL to\n  formally investigate the somewhat quite complex relationship between\n  these two.\\<close>"], ["", "text\\<open>Strong equality has two motivations: a\n  pragmatic one and a fundamental one.\n  \\begin{enumerate}\n  \\item The pragmatic reason is fairly simple: users of object-oriented languages want\n    something like a ``shallow object value equality''.\n    You will want to say\n    \\inlineisar+ a.boss \\<triangleq>  b.boss@pre +\n    instead of\n\\begin{isar}\n  a.boss \\<doteq> b.boss@pre and  (* just the pointers are equal! *)\n  a.boss.name \\<doteq> b.boss@pre.name@pre and\n  a.boss.age \\<doteq> b.boss@pre.age@pre\n\\end{isar}\n      Breaking a shallow-object equality down to referential equality\n      of attributes is cumbersome, error-prone, and makes\n      specifications difficult to extend (add for example an attribute\n      sex to your class, and check in your OCL specification\n      everywhere that you did it right with your simulation of strong\n      equality).  Therefore, languages like Java offer facilities\n      to handle two different equalities, and it is problematic even\n      in an execution oriented specification language to ignore\n      shallow object equality because it is so common in the code.\n    \\item The fundamental reason goes as follows: whatever you do to\n      reason consistently over a language, you need the concept of\n      equality: you need to know what expressions can be replaced by\n      others because they \\emph{mean the same thing.}  People call\n      this also ``Leibniz Equality'' because this philosopher brought\n      this principle first explicitly to paper and shed some light\n      over it. It is the theoretic foundation of what you do in an\n      optimizing compiler: you replace expressions by \\emph{equal}\n      ones, which you hope are easier to evaluate. In a typed\n      language, strong equality exists uniformly over all types, it is\n      ``polymorphic'' $\\_ = \\_ :: \\alpha * \\alpha \\rightarrow\n      bool$---this is the way that equality is defined in HOL itself.\n      We can express Leibniz principle as one logical rule of\n      surprising simplicity and beauty:\n    \\begin{gather}\n        s = t \\Longrightarrow P(s) = P(t)\n    \\end{gather}\n    ``Whenever we know, that $s$ is equal to $t$, we can replace the\n    sub-expression $s$ in a term $P$ by $t$ and we have that the\n    replacement is equal to the original.''\n\\end{enumerate}\n\\<close>"], ["", "text\\<open>\n  While weak referential equality is defined to be strict in the OCL\n  standard, we will define strong equality as non-strict.  It is quite\n  nasty (but not impossible) to define the logical equality in a\n  strict way (the substitutivity rule above would look more complex),\n  however, whenever references were used, strong equality is needed\n  since references refer to particular states (pre or post), and that\n  they mean the same thing can therefore not be taken for granted.\n\\<close>"], ["", "subsubsection\\<open>Definition\\<close>"], ["", "text\\<open>\n  The strict equality on basic types (actually on all types) must be\n  exceptionally defined on @{term \"null\"}---otherwise the entire\n  concept of null in the language does not make much sense. This is an\n  important exception from the general rule that null\n  arguments---especially if passed as ``self''-argument---lead to\n  invalid results.\n\\<close>"], ["", "text\\<open>\n  We define strong equality extremely generic, even for types that\n  contain a \\<open>null\\<close> or \\<open>\\<bottom>\\<close> element. Strong\n  equality is simply polymorphic in Featherweight OCL, \\ie, is\n  defined identical for all types in OCL and HOL.\n\\<close>"], ["", "definition StrongEq::\"['\\<AA> st \\<Rightarrow> '\\<alpha>,'\\<AA> st \\<Rightarrow> '\\<alpha>] \\<Rightarrow> ('\\<AA>)Boolean\"  (infixl \"\\<triangleq>\" 30)\nwhere     \"X \\<triangleq> Y \\<equiv>  \\<lambda> \\<tau>. \\<lfloor>\\<lfloor>X \\<tau> = Y \\<tau> \\<rfloor>\\<rfloor>\""], ["", "text\\<open>\n  From this follow already elementary properties like:\n\\<close>"], ["", "lemma [simp,code_unfold]: \"(true \\<triangleq> false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true \\<triangleq> false) = false", "by(rule ext, auto simp: StrongEq_def)"], ["", "lemma [simp,code_unfold]: \"(false \\<triangleq> true) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false \\<triangleq> true) = false", "by(rule ext, auto simp: StrongEq_def)"], ["", "subsubsection\\<open>Fundamental Predicates on Strong Equality\\<close>"], ["", "text\\<open>Equality reasoning in OCL is not humpty dumpty. While strong equality\nis clearly an equivalence:\\<close>"], ["", "lemma StrongEq_refl [simp]: \"(X \\<triangleq> X) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<triangleq> X) = true", "by(rule ext, simp add: null_def invalid_def true_def false_def StrongEq_def)"], ["", "lemma StrongEq_sym: \"(X \\<triangleq> Y) = (Y \\<triangleq> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<triangleq> Y) = (Y \\<triangleq> X)", "by(rule ext, simp add: eq_sym_conv invalid_def true_def false_def StrongEq_def)"], ["", "lemma StrongEq_trans_strong [simp]:\n  assumes A: \"(X \\<triangleq> Y) = true\"\n  and     B: \"(Y \\<triangleq> Z) = true\"\n  shows   \"(X \\<triangleq> Z) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<triangleq> Z) = true", "apply(insert A B)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(X \\<triangleq> Y) = true; (Y \\<triangleq> Z) = true\\<rbrakk>\n    \\<Longrightarrow> (X \\<triangleq> Z) = true", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(X \\<triangleq> Y) = true;\n        (Y \\<triangleq> Z) = true\\<rbrakk>\n       \\<Longrightarrow> (X \\<triangleq> Z) x = true x", "apply(simp add: null_def invalid_def true_def false_def StrongEq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>(\\<lambda>\\<tau>.\n                    \\<lfloor>\\<lfloor>X \\<tau> =\nY \\<tau>\\<rfloor>\\<rfloor>) =\n                (\\<lambda>\\<tau>. \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>);\n        (\\<lambda>\\<tau>.\n            \\<lfloor>\\<lfloor>Y \\<tau> = Z \\<tau>\\<rfloor>\\<rfloor>) =\n        (\\<lambda>\\<tau>. \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>)\\<rbrakk>\n       \\<Longrightarrow> X x = Z x", "apply(drule_tac x=x in fun_cong)+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<lfloor>\\<lfloor>X x = Y x\\<rfloor>\\<rfloor> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        \\<lfloor>\\<lfloor>Y x = Z x\\<rfloor>\\<rfloor> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> X x = Z x", "by auto"], ["", "text\\<open>\n    it is only in a limited sense a congruence, at least from the\n    point of view of this semantic theory. The point is that it is\n    only a congruence on OCL expressions, not arbitrary HOL\n    expressions (with which we can mix Featherweight OCL expressions). A\n    semantic---not syntactic---characterization of OCL expressions is\n    that they are \\emph{context-passing} or \\emph{context-invariant},\n    \\ie, the context of an entire OCL expression, \\ie the pre and\n    post state it referes to, is passed constantly and unmodified to\n    the sub-expressions, \\ie, all sub-expressions inside an OCL\n    expression refer to the same context. Expressed formally, this\n    boils down to:\n\\<close>"], ["", "lemma StrongEq_subst :\n  assumes cp: \"\\<And>X. P(X)\\<tau> = P(\\<lambda> _. X \\<tau>)\\<tau>\"\n  and     eq: \"(X \\<triangleq> Y)\\<tau> = true \\<tau>\"\n  shows   \"(P X \\<triangleq> P Y)\\<tau> = true \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (P X \\<triangleq> P Y) \\<tau> = true \\<tau>", "apply(insert cp eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>X. P X \\<tau> = P (\\<lambda>_. X \\<tau>) \\<tau>;\n     (X \\<triangleq> Y) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (P X \\<triangleq> P Y) \\<tau> = true \\<tau>", "apply(simp add: null_def invalid_def true_def false_def StrongEq_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>X. P X \\<tau> = P (\\<lambda>_. X \\<tau>) \\<tau>;\n     X \\<tau> = Y \\<tau>\\<rbrakk>\n    \\<Longrightarrow> P X \\<tau> = P Y \\<tau>", "apply(subst cp[of X])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>X. P X \\<tau> = P (\\<lambda>_. X \\<tau>) \\<tau>;\n     X \\<tau> = Y \\<tau>\\<rbrakk>\n    \\<Longrightarrow> P (\\<lambda>_. X \\<tau>) \\<tau> = P Y \\<tau>", "apply(subst cp[of Y])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>X. P X \\<tau> = P (\\<lambda>_. X \\<tau>) \\<tau>;\n     X \\<tau> = Y \\<tau>\\<rbrakk>\n    \\<Longrightarrow> P (\\<lambda>_. X \\<tau>) \\<tau> =\n                      P (\\<lambda>_. Y \\<tau>) \\<tau>", "by simp"], ["", "lemma defined7[simp]: \"\\<delta> (X \\<triangleq> Y) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> (X \\<triangleq> Y) = true", "by(rule ext,\n     auto simp: defined_def           true_def false_def StrongEq_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma valid7[simp]: \"\\<upsilon> (X \\<triangleq> Y) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> (X \\<triangleq> Y) = true", "by(rule ext,\n     auto simp: valid_def true_def false_def StrongEq_def\n                bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma cp_StrongEq: \"(X \\<triangleq> Y) \\<tau> = ((\\<lambda> _. X \\<tau>) \\<triangleq> (\\<lambda> _. Y \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<triangleq> Y) \\<tau> =\n    ((\\<lambda>_. X \\<tau>) \\<triangleq> (\\<lambda>_. Y \\<tau>)) \\<tau>", "by(simp add: StrongEq_def)"], ["", "subsection\\<open>Logical Connectives and their Universal Properties\\<close>"], ["", "text\\<open>\n  It is a design goal to give OCL a semantics that is as closely as\n  possible to a ``logical system'' in a known sense; a specification\n  logic where the logical connectives can not be understood other that\n  having the truth-table aside when reading fails its purpose in our\n  view.\n\n  Practically, this means that we want to give a definition to the\n  core operations to be as close as possible to the lattice laws; this\n  makes also powerful symbolic normalization of OCL specifications\n  possible as a pre-requisite for automated theorem provers. For\n  example, it is still possible to compute without any definedness\n  and validity reasoning the DNF of an OCL specification; be it for\n  test-case generations or for a smooth transition to a two-valued\n  representation of the specification amenable to fast standard\n  SMT-solvers, for example.\n\n  Thus, our representation of the OCL is merely a 4-valued\n  Kleene-Logics with @{term \"invalid\"} as least, @{term \"null\"} as\n  middle and @{term \"true\"} resp.  @{term \"false\"} as unrelated\n  top-elements.\n\\<close>"], ["", "definition OclNot :: \"('\\<AA>)Boolean \\<Rightarrow> ('\\<AA>)Boolean\" (\"not\")\nwhere     \"not X \\<equiv>  \\<lambda> \\<tau> . case X \\<tau> of\n                               \\<bottom>     \\<Rightarrow> \\<bottom>\n                           | \\<lfloor> \\<bottom> \\<rfloor>   \\<Rightarrow> \\<lfloor> \\<bottom> \\<rfloor>\n                           | \\<lfloor>\\<lfloor> x \\<rfloor>\\<rfloor>  \\<Rightarrow> \\<lfloor>\\<lfloor> \\<not> x \\<rfloor>\\<rfloor>\""], ["", "lemma cp_OclNot: \"(not X)\\<tau> = (not (\\<lambda> _. X \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not X \\<tau> = not (\\<lambda>_. X \\<tau>) \\<tau>", "by(simp add: OclNot_def)"], ["", "lemma OclNot1[simp]: \"not invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not invalid = invalid", "by(rule ext,simp add: OclNot_def null_def invalid_def true_def false_def bot_option_def)"], ["", "lemma OclNot2[simp]: \"not null = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not null = null", "by(rule ext,simp add: OclNot_def null_def invalid_def true_def false_def\n                        bot_option_def null_fun_def null_option_def )"], ["", "lemma OclNot3[simp]: \"not true = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not true = false", "by(rule ext,simp add: OclNot_def null_def invalid_def true_def false_def)"], ["", "lemma OclNot4[simp]: \"not false = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not false = true", "by(rule ext,simp add: OclNot_def null_def invalid_def true_def false_def)"], ["", "lemma OclNot_not[simp]: \"not (not X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not (not X) = X", "apply(rule ext,simp add: OclNot_def null_def invalid_def true_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n             | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>\\<bottom>\\<rfloor>\n             | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<bottom>\\<rfloor>\n        | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n       X x", "apply(case_tac \"X x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       X x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case case a of \\<bottom> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n             | \\<lfloor>x\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<bottom>\\<rfloor>\n        | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n       \\<lfloor>a\\<rfloor>", "apply(case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclNot_inject: \"\\<And> x y. not x = not y \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y. not x = not y \\<Longrightarrow> x = y", "by(subst OclNot_not[THEN sym], simp)"], ["", "definition OclAnd :: \"[('\\<AA>)Boolean, ('\\<AA>)Boolean] \\<Rightarrow> ('\\<AA>)Boolean\" (infixl \"and\" 30)\nwhere     \"X and Y \\<equiv>  (\\<lambda> \\<tau> . case X \\<tau> of\n                          \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>               \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                        | \\<bottom>        \\<Rightarrow> (case Y \\<tau> of\n                                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                                      | _        \\<Rightarrow> \\<bottom>)\n                        | \\<lfloor>\\<bottom>\\<rfloor>      \\<Rightarrow> (case Y \\<tau> of\n                                        \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                                      | \\<bottom>        \\<Rightarrow> \\<bottom>\n                                      | _        \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>)\n                        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>  \\<Rightarrow>               Y \\<tau>)\""], ["", "text\\<open>\n  Note that @{term \"not\"} is \\emph{not} defined as a strict function;\n  proximity to lattice laws implies that we \\emph{need} a definition\n  of @{term \"not\"} that satisfies \\<open>not(not(x))=x\\<close>.\n\\<close>"], ["", "text\\<open>\n  In textbook notation, the logical core constructs @{const\n    \"OclNot\"} and @{const \"OclAnd\"} were represented as follows:\n\\<close>"], ["", "lemma textbook_OclNot:\n     \"I\\<lbrakk>not(X)\\<rbrakk> \\<tau> =  (case I\\<lbrakk>X\\<rbrakk> \\<tau> of   \\<bottom>   \\<Rightarrow> \\<bottom>\n                                 |  \\<lfloor> \\<bottom> \\<rfloor> \\<Rightarrow> \\<lfloor> \\<bottom> \\<rfloor>\n                                 | \\<lfloor>\\<lfloor> x \\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<lfloor> \\<not> x \\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>not X\\<rbrakk> \\<tau> =\n    (case I\\<lbrakk>X\\<rbrakk> \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n     | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n     | \\<lfloor>\\<lfloor>x\\<rfloor>\\<rfloor> \\<Rightarrow>\n         \\<lfloor>\\<lfloor>\\<not> x\\<rfloor>\\<rfloor>)", "by(simp add: Sem_def OclNot_def)"], ["", "lemma textbook_OclAnd:\n     \"I\\<lbrakk>X and Y\\<rbrakk> \\<tau> = (case I\\<lbrakk>X\\<rbrakk> \\<tau> of\n                            \\<bottom>  \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n                                          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)\n                        | \\<lfloor> \\<bottom> \\<rfloor> \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)\n                        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> (case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n                                             \\<bottom> \\<Rightarrow>  \\<bottom>\n                                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n                                          | \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor>)\n                        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>  \\<lfloor>\\<lfloor> False \\<rfloor>\\<rfloor>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>X and Y\\<rbrakk> \\<tau> =\n    (case I\\<lbrakk>X\\<rbrakk> \\<tau> of\n     \\<bottom> \\<Rightarrow>\n       case I\\<lbrakk>Y\\<rbrakk> \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n       | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n       | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n       | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n           \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n     | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n         case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n         \\<bottom> \\<Rightarrow> \\<bottom>\n         | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<bottom>\\<rfloor>\n         | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<bottom>\\<rfloor>\n         | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n     | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n         case I\\<lbrakk>Y\\<rbrakk> \\<tau> of\n         \\<bottom> \\<Rightarrow> \\<bottom>\n         | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<bottom>\\<rfloor>\n         | \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor> \\<Rightarrow>\n             \\<lfloor>\\<lfloor>y\\<rfloor>\\<rfloor>\n     | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n         \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)", "by(simp add: OclAnd_def Sem_def split: option.split bool.split)"], ["", "definition OclOr :: \"[('\\<AA>)Boolean, ('\\<AA>)Boolean] \\<Rightarrow> ('\\<AA>)Boolean\"            (infixl \"or\" 25)\nwhere    \"X or Y \\<equiv> not(not X and not Y)\""], ["", "definition OclImplies :: \"[('\\<AA>)Boolean, ('\\<AA>)Boolean] \\<Rightarrow> ('\\<AA>)Boolean\"       (infixl \"implies\" 25)\nwhere    \"X implies Y \\<equiv> not X or Y\""], ["", "lemma cp_OclAnd:\"(X and Y) \\<tau> = ((\\<lambda> _. X \\<tau>) and (\\<lambda> _. Y \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and Y) \\<tau> =\n    ((\\<lambda>_. X \\<tau>) and (\\<lambda>_. Y \\<tau>)) \\<tau>", "by(simp add: OclAnd_def)"], ["", "lemma cp_OclOr:\"((X::('\\<AA>)Boolean) or Y) \\<tau> = ((\\<lambda> _. X \\<tau>) or (\\<lambda> _. Y \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X or Y) \\<tau> =\n    ((\\<lambda>_. X \\<tau>) or (\\<lambda>_. Y \\<tau>)) \\<tau>", "apply(simp add: OclOr_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. not (not X and not Y) \\<tau> =\n    not (not (\\<lambda>_. X \\<tau>) and not (\\<lambda>_. Y \\<tau>)) \\<tau>", "apply(subst cp_OclNot[of \"not (\\<lambda>_. X \\<tau>) and not (\\<lambda>_. Y \\<tau>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. not (not X and not Y) \\<tau> =\n    not (\\<lambda>_.\n            (not (\\<lambda>_. X \\<tau>) and not (\\<lambda>_. Y \\<tau>))\n             \\<tau>)\n     \\<tau>", "apply(subst cp_OclAnd[of \"not (\\<lambda>_. X \\<tau>)\" \"not (\\<lambda>_. Y \\<tau>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. not (not X and not Y) \\<tau> =\n    not (\\<lambda>_.\n            ((\\<lambda>_. not (\\<lambda>_. X \\<tau>) \\<tau>) and\n             (\\<lambda>_. not (\\<lambda>_. Y \\<tau>) \\<tau>))\n             \\<tau>)\n     \\<tau>", "by(simp add: cp_OclNot[symmetric] cp_OclAnd[symmetric] )"], ["", "lemma cp_OclImplies:\"(X implies Y) \\<tau> = ((\\<lambda> _. X \\<tau>) implies (\\<lambda> _. Y \\<tau>)) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X implies Y) \\<tau> =\n    ((\\<lambda>_. X \\<tau>) implies (\\<lambda>_. Y \\<tau>)) \\<tau>", "apply(simp add: OclImplies_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (not X or Y) \\<tau> =\n    (not (\\<lambda>_. X \\<tau>) or (\\<lambda>_. Y \\<tau>)) \\<tau>", "apply(subst cp_OclOr[of \"not (\\<lambda>_. X \\<tau>)\" \"(\\<lambda>_. Y \\<tau>)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (not X or Y) \\<tau> =\n    ((\\<lambda>_. not (\\<lambda>_. X \\<tau>) \\<tau>) or\n     (\\<lambda>_. Y \\<tau>))\n     \\<tau>", "by(simp add: cp_OclNot[symmetric] cp_OclOr[symmetric] )"], ["", "lemma OclAnd1[simp]: \"(invalid and true) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid and true) = invalid", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def)"], ["", "lemma OclAnd2[simp]: \"(invalid and false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid and false) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def)"], ["", "lemma OclAnd3[simp]: \"(invalid and null) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid and null) = invalid", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd4[simp]: \"(invalid and invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid and invalid) = invalid", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def)"], ["", "lemma OclAnd5[simp]: \"(null and true) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null and true) = null", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd6[simp]: \"(null and false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null and false) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd7[simp]: \"(null and null) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null and null) = null", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd8[simp]: \"(null and invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null and invalid) = invalid", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd9[simp]: \"(false and true) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false and true) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd10[simp]: \"(false and false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false and false) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd11[simp]: \"(false and null) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false and null) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd12[simp]: \"(false and invalid) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false and invalid) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd13[simp]: \"(true and true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true and true) = true", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd14[simp]: \"(true and false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true and false) = false", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["", "lemma OclAnd15[simp]: \"(true and null) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true and null) = null", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd16[simp]: \"(true and invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true and invalid) = invalid", "by(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def bot_option_def\n                        null_fun_def null_option_def)"], ["", "lemma OclAnd_idem[simp]: \"(X and X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and X) = X", "apply(rule ext,simp add: OclAnd_def null_def invalid_def true_def false_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case X x of\n        \\<bottom> \\<Rightarrow>\n          case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> X x\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       X x", "apply(case_tac \"X x\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a.\n       X x = \\<lfloor>a\\<rfloor> \\<Longrightarrow>\n       (case a of\n        \\<bottom> \\<Rightarrow>\n          case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<bottom>\\<rfloor>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<bottom>\\<rfloor>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>True\\<rfloor> \\<Rightarrow> X x\n        | \\<lfloor>False\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       \\<lfloor>a\\<rfloor>", "apply(case_tac \"a\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a aa.\n       \\<lbrakk>X x = \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>;\n        a = \\<lfloor>aa\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (case aa of True \\<Rightarrow> X x\n                          | False \\<Rightarrow>\n                              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n                         \\<lfloor>\\<lfloor>aa\\<rfloor>\\<rfloor>", "apply(case_tac \"aa\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAnd_commute: \"(X and Y) = (Y and X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and Y) = (Y and X)", "by(rule ext,auto simp:true_def false_def OclAnd_def invalid_def\n                   split: option.split option.split_asm\n                          bool.split bool.split_asm)"], ["", "lemma OclAnd_false1[simp]: \"(false and X) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false and X) = false", "apply(rule ext, simp add: OclAnd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case false x of\n        \\<bottom> \\<Rightarrow>\n          case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> X x\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       false x", "apply(auto simp:true_def false_def invalid_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAnd_false2[simp]: \"(X and false) = false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and false) = false", "by(simp add: OclAnd_commute)"], ["", "lemma OclAnd_true1[simp]: \"(true and X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true and X) = X", "apply(rule ext, simp add: OclAnd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case true x of\n        \\<bottom> \\<Rightarrow>\n          case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case X x of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> X x\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       X x", "apply(auto simp:true_def false_def invalid_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAnd_true2[simp]: \"(X and true) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and true) = X", "by(simp add: OclAnd_commute)"], ["", "lemma OclAnd_bot1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> (bot and X) \\<tau> = bot \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow>\n       (UML_Types.bot_class.bot and X) \\<tau> =\n       UML_Types.bot_class.bot \\<tau>", "apply(simp add: OclAnd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow>\n       (case UML_Types.bot_class.bot \\<tau> of\n        \\<bottom> \\<Rightarrow>\n          case X \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case X \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> X \\<tau>\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       UML_Types.bot_class.bot \\<tau>", "apply(auto simp:true_def false_def bot_fun_def bot_option_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAnd_bot2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> (X and bot) \\<tau> = bot \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow>\n       (X and UML_Types.bot_class.bot) \\<tau> =\n       UML_Types.bot_class.bot \\<tau>", "by(simp add: OclAnd_commute)"], ["", "lemma OclAnd_null1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (null and X) \\<tau> = null \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> false \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (null and X) \\<tau> = null \\<tau>", "apply(simp add: OclAnd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> false \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (case null \\<tau> of\n                          \\<bottom> \\<Rightarrow>\n                            case X \\<tau> of\n                            \\<bottom> \\<Rightarrow> \\<bottom>\n                            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                \\<bottom>\n                            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                \\<bottom>\n                            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                              case X \\<tau> of\n                              \\<bottom> \\<Rightarrow> \\<bottom>\n                              | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>\\<bottom>\\<rfloor>\n                              | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>\\<bottom>\\<rfloor>\n                              | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                              X \\<tau>\n                          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n                         null \\<tau>", "apply(auto simp:true_def false_def bot_fun_def bot_option_def null_fun_def null_option_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclAnd_null2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> false \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (X and null) \\<tau> = null \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> false \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (X and null) \\<tau> = null \\<tau>", "by(simp add: OclAnd_commute)"], ["", "lemma OclAnd_assoc: \"(X and (Y and Z)) = (X and Y and Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X and (Y and Z)) = (X and Y and Z)", "apply(rule ext, simp add: OclAnd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case X x of\n        \\<bottom> \\<Rightarrow>\n          case case Y x of\n               \\<bottom> \\<Rightarrow>\n                 case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<bottom>\n                 | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n               | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                   case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n                   | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                       \\<lfloor>\\<bottom>\\<rfloor>\n                   | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                       \\<lfloor>\\<bottom>\\<rfloor>\n                   | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                       \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n               | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> Z x\n               | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                   \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> of\n          \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case case Y x of\n                 \\<bottom> \\<Rightarrow>\n                   case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n                   | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n                   | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                       \\<bottom>\n                   | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                       \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                     case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n                     | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                         \\<lfloor>\\<bottom>\\<rfloor>\n                     | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                         \\<lfloor>\\<bottom>\\<rfloor>\n                     | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                         \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     Z x\n                 | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> of\n            \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n            case Y x of\n            \\<bottom> \\<Rightarrow>\n              case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n              | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                  \\<bottom>\n              | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n                | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                    \\<lfloor>\\<bottom>\\<rfloor>\n                | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                    \\<lfloor>\\<bottom>\\<rfloor>\n                | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                    \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> Z x\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n       (case case X x of\n             \\<bottom> \\<Rightarrow>\n               case Y x of \\<bottom> \\<Rightarrow> \\<bottom>\n               | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n               | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                   \\<bottom>\n               | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                   \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n             | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                 case Y x of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<bottom>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<bottom>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n             | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> Y x\n             | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> of\n        \\<bottom> \\<Rightarrow>\n          case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> \\<bottom>\n          | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            case Z x of \\<bottom> \\<Rightarrow> \\<bottom>\n            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<bottom>\\<rfloor>\n            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n        | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow> Z x\n        | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>)", "apply(auto simp:true_def false_def null_def invalid_def\n             split: option.split option.split_asm\n                    bool.split bool.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclOr1[simp]: \"(invalid or true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid or true) = true", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def)"], ["", "lemma OclOr2[simp]: \"(invalid or false) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid or false) = invalid", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def)"], ["", "lemma OclOr3[simp]: \"(invalid or null) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid or null) = invalid", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def null_fun_def null_option_def)"], ["", "lemma OclOr4[simp]: \"(invalid or invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (invalid or invalid) = invalid", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def)"], ["", "lemma OclOr5[simp]: \"(null or true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null or true) = true", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def null_fun_def null_option_def)"], ["", "lemma OclOr6[simp]: \"(null or false) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null or false) = null", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def null_fun_def null_option_def)"], ["", "lemma OclOr7[simp]: \"(null or null) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null or null) = null", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def null_fun_def null_option_def)"], ["", "lemma OclOr8[simp]: \"(null or invalid) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (null or invalid) = invalid", "by(rule ext, simp add: OclOr_def OclNot_def OclAnd_def null_def invalid_def true_def false_def\n                       bot_option_def null_fun_def null_option_def)"], ["", "lemma OclOr_idem[simp]: \"(X or X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X or X) = X", "by(simp add: OclOr_def)"], ["", "lemma OclOr_commute: \"(X or Y) = (Y or X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X or Y) = (Y or X)", "by(simp add: OclOr_def OclAnd_commute)"], ["", "lemma OclOr_false1[simp]: \"(false or Y) = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false or Y) = Y", "by(simp add: OclOr_def)"], ["", "lemma OclOr_false2[simp]: \"(Y or false) = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Y or false) = Y", "by(simp add: OclOr_def)"], ["", "lemma OclOr_true1[simp]: \"(true or Y) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true or Y) = true", "by(simp add: OclOr_def)"], ["", "lemma OclOr_true2: \"(Y or true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Y or true) = true", "by(simp add: OclOr_def)"], ["", "lemma OclOr_bot1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> (bot or X) \\<tau> = bot \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow>\n       (UML_Types.bot_class.bot or X) \\<tau> =\n       UML_Types.bot_class.bot \\<tau>", "apply(simp add: OclOr_def OclAnd_def OclNot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow>\n       (case case case UML_Types.bot_class.bot \\<tau> of\n                  \\<bottom> \\<Rightarrow> \\<bottom>\n                  | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                      \\<lfloor>\\<bottom>\\<rfloor>\n                  | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                      \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n             \\<bottom> \\<Rightarrow>\n               case case X \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n                    | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                        \\<lfloor>\\<bottom>\\<rfloor>\n                    | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                        \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n               \\<bottom> \\<Rightarrow> \\<bottom>\n               | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<bottom>\n               | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                   \\<bottom>\n               | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                   \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n             | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                 case case X \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n                      | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                          \\<lfloor>\\<bottom>\\<rfloor>\n                      | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                          \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n                 \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<bottom>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<bottom>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n             | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                 case X \\<tau> of \\<bottom> \\<Rightarrow> \\<bottom>\n                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<bottom>\\<rfloor>\n                 | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                     \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>\n             | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                 \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> of\n        \\<bottom> \\<Rightarrow> \\<bottom>\n        | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<bottom>\\<rfloor>\n        | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n            \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n       UML_Types.bot_class.bot \\<tau>", "apply(auto simp:true_def false_def bot_fun_def bot_option_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OclOr_bot2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> (X or bot) \\<tau> = bot \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow>\n       (X or UML_Types.bot_class.bot) \\<tau> =\n       UML_Types.bot_class.bot \\<tau>", "by(simp add: OclOr_commute)"], ["", "lemma OclOr_null1[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (null or X) \\<tau> = null \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> true \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (null or X) \\<tau> = null \\<tau>", "apply(simp add: OclOr_def OclAnd_def OclNot_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> true \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (case case case null \\<tau> of\n                                    \\<bottom> \\<Rightarrow> \\<bottom>\n                                    | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n  \\<lfloor>\\<bottom>\\<rfloor>\n                                    | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n  \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n                               \\<bottom> \\<Rightarrow>\n                                 case case X \\<tau> of\n\\<bottom> \\<Rightarrow> \\<bottom>\n| \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n| \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n    \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n                                 \\<bottom> \\<Rightarrow> \\<bottom>\n                                 | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                     \\<bottom>\n                                 | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                     \\<bottom>\n                                 | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                     \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                               | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                   case case X \\<tau> of\n  \\<bottom> \\<Rightarrow> \\<bottom>\n  | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n  | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n      \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor> of\n                                   \\<bottom> \\<Rightarrow> \\<bottom>\n                                   | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n \\<lfloor>\\<bottom>\\<rfloor>\n                                   | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n \\<lfloor>\\<bottom>\\<rfloor>\n                                   | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                               | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                   case X \\<tau> of\n                                   \\<bottom> \\<Rightarrow> \\<bottom>\n                                   | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n \\<lfloor>\\<bottom>\\<rfloor>\n                                   | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>\n                               | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                   \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> of\n                          \\<bottom> \\<Rightarrow> \\<bottom>\n                          | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>\\<bottom>\\<rfloor>\n                          | \\<lfloor>\\<lfloor>xa\\<rfloor>\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>\\<lfloor>\\<not> xa\\<rfloor>\\<rfloor>) =\n                         null \\<tau>", "apply(auto simp:true_def false_def bot_fun_def bot_option_def null_fun_def null_option_def\n             split: option.split option.split_asm)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b x2.\n       \\<lbrakk>X (a, b) = \\<lfloor>\\<lfloor>x2\\<rfloor>\\<rfloor>;\n        (case \\<not> x2 of True \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n         | False \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n        \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> x2\n 2. \\<And>a b x2 x2a.\n       \\<lbrakk>X (a, b) = \\<lfloor>\\<lfloor>x2\\<rfloor>\\<rfloor>;\n        (case \\<not> x2 of True \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n         | False \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n        \\<lfloor>\\<lfloor>x2a\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x2", "apply (metis (full_types) bool.simps(3) bot_option_def null_is_valid null_option_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b x2 x2a.\n       \\<lbrakk>X (a, b) = \\<lfloor>\\<lfloor>x2\\<rfloor>\\<rfloor>;\n        (case \\<not> x2 of True \\<Rightarrow> \\<lfloor>\\<bottom>\\<rfloor>\n         | False \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n        \\<lfloor>\\<lfloor>x2a\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> x2", "by (metis (full_types) bool.simps(3) option.distinct(1) option.sel)"], ["", "lemma OclOr_null2[simp]: \"\\<And>\\<tau>. X \\<tau> \\<noteq> true \\<tau> \\<Longrightarrow> X \\<tau> \\<noteq> bot \\<tau> \\<Longrightarrow> (X or null) \\<tau> = null \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>X \\<tau> \\<noteq> true \\<tau>;\n        X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<tau>\\<rbrakk>\n       \\<Longrightarrow> (X or null) \\<tau> = null \\<tau>", "by(simp add: OclOr_commute)"], ["", "lemma OclOr_assoc: \"(X or (Y or Z)) = (X or Y or Z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X or (Y or Z)) = (X or Y or Z)", "by(simp add: OclOr_def OclAnd_assoc)"], ["", "lemma deMorgan1: \"not(X and Y) = ((not X) or (not Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not (X and Y) = (not X or not Y)", "by(simp add: OclOr_def)"], ["", "lemma deMorgan2: \"not(X or Y) = ((not X) and (not Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not (X or Y) = (not X and not Y)", "by(simp add: OclOr_def)"], ["", "lemma OclImplies_true1[simp]:\"(true implies X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (true implies X) = X", "by(simp add: OclImplies_def)"], ["", "lemma OclImplies_true2[simp]: \"(X implies true) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (X implies true) = true", "by(simp add: OclImplies_def OclOr_true2)"], ["", "lemma OclImplies_false1[simp]:\"(false implies X) = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (false implies X) = true", "by(simp add: OclImplies_def)"], ["", "subsection\\<open>A Standard Logical Calculus for OCL\\<close>"], ["", "definition OclValid  :: \"[('\\<AA>)st, ('\\<AA>)Boolean] \\<Rightarrow> bool\" (\"(1(_)/ \\<Turnstile> (_))\" 50)\nwhere     \"\\<tau> \\<Turnstile> P \\<equiv> ((P \\<tau>) = true \\<tau>)\""], ["", "syntax OclNonValid  :: \"[('\\<AA>)st, ('\\<AA>)Boolean] \\<Rightarrow> bool\" (\"(1(_)/ |\\<noteq> (_))\" 50)"], ["", "translations \"\\<tau> |\\<noteq> P\" == \"\\<not>(\\<tau> \\<Turnstile> P)\""], ["", "subsubsection\\<open>Global vs. Local Judgements\\<close>"], ["", "lemma transform1: \"P = true \\<Longrightarrow> \\<tau> \\<Turnstile> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = true \\<Longrightarrow> \\<tau> \\<Turnstile> P", "by(simp add: OclValid_def)"], ["", "lemma transform1_rev: \"\\<forall> \\<tau>. \\<tau> \\<Turnstile> P \\<Longrightarrow> P = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<tau>. \\<tau> \\<Turnstile> P \\<Longrightarrow> P = true", "by(rule ext, auto simp: OclValid_def true_def)"], ["", "lemma transform2: \"(P = Q) \\<Longrightarrow> ((\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = Q \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q)", "by(auto simp: OclValid_def)"], ["", "lemma transform2_rev: \"\\<forall> \\<tau>. (\\<tau> \\<Turnstile> \\<delta> P) \\<and> (\\<tau> \\<Turnstile> \\<delta> Q) \\<and> (\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q) \\<Longrightarrow> P = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> P \\<and>\n       \\<tau> \\<Turnstile> \\<delta> Q \\<and>\n       (\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> Q) \\<Longrightarrow>\n    P = Q", "apply(rule ext,auto simp: OclValid_def true_def defined_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>a b.\n          (if P (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n              P (a, b) = null (a, b)\n           then false (a, b) else true (a, b)) =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (if Q (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n              Q (a, b) = null (a, b)\n           then false (a, b) else true (a, b)) =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (P (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) =\n          (Q (a, b) =\n           \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) \\<Longrightarrow>\n       P (a, b) = Q (a, b)", "apply(erule_tac x=a in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<forall>b.\n          (if P (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n              P (a, b) = null (a, b)\n           then false (a, b) else true (a, b)) =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (if Q (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n              Q (a, b) = null (a, b)\n           then false (a, b) else true (a, b)) =\n          \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n          (P (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) =\n          (Q (a, b) =\n           \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) \\<Longrightarrow>\n       P (a, b) = Q (a, b)", "apply(erule_tac x=b in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (if P (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n           P (a, b) = null (a, b)\n        then false (a, b) else true (a, b)) =\n       \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n       (if Q (a, b) = UML_Types.bot_class.bot (a, b) \\<or>\n           Q (a, b) = null (a, b)\n        then false (a, b) else true (a, b)) =\n       \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n       (P (a, b) = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) =\n       (Q (a, b) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>) \\<Longrightarrow>\n       P (a, b) = Q (a, b)", "apply(auto simp: false_def true_def defined_def bot_Boolean_def null_Boolean_def\n                 split: option.split_asm HOL.if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>However, certain properties (like transitivity) can not\n       be \\emph{transformed} from the global level to the local one,\n       they have to be re-proven on the local level.\\<close>"], ["", "lemma (*transform3:*)\nassumes H : \"P = true \\<Longrightarrow> Q = true\"\nshows \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> Q", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tau> = true \\<tau> \\<Longrightarrow> Q \\<tau> = true \\<tau>", "apply(rule H[THEN fun_cong])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tau> = true \\<tau> \\<Longrightarrow> P = true", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. P \\<tau> = true \\<tau> \\<Longrightarrow> P x = true x", "oops"], ["", "subsubsection\\<open>Local Validity and Meta-logic\\<close>"], ["", "text\\<open>\\label{sec:localVal}\\<close>"], ["", "lemma foundation1[simp]: \"\\<tau> \\<Turnstile> true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> true", "by(auto simp: OclValid_def)"], ["", "lemma foundation2[simp]: \"\\<not>(\\<tau> \\<Turnstile> false)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> false", "by(auto simp: OclValid_def true_def false_def)"], ["", "lemma foundation3[simp]: \"\\<not>(\\<tau> \\<Turnstile> invalid)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> invalid", "by(auto simp: OclValid_def true_def false_def invalid_def bot_option_def)"], ["", "lemma foundation4[simp]: \"\\<not>(\\<tau> \\<Turnstile> null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> null", "by(auto simp: OclValid_def true_def false_def null_def null_fun_def null_option_def bot_option_def)"], ["", "lemma bool_split[simp]:\n\"(\\<tau> \\<Turnstile> (x \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> null)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> true)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> false))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> true \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> false", "apply(insert bool_split_0[of x \\<tau>], auto)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid;\n     \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> x \\<triangleq> false;\n     x \\<tau> = invalid \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> x \\<triangleq> true\n 2. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid;\n     \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> x \\<triangleq> false; x \\<tau> = null \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> x \\<triangleq> true\n 3. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid;\n     \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> x \\<triangleq> false; x \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> x \\<triangleq> true\n 4. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid;\n     \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> x \\<triangleq> false; x \\<tau> = false \\<tau>\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> x \\<triangleq> true", "apply(simp_all add: OclValid_def StrongEq_def true_def null_def invalid_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma defined_split:\n\"(\\<tau> \\<Turnstile> \\<delta> x) = ((\\<not>(\\<tau> \\<Turnstile> (x \\<triangleq> invalid))) \\<and> (\\<not> (\\<tau> \\<Turnstile> (x \\<triangleq> null))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> x) =\n    (\\<tau> |\\<noteq> x \\<triangleq> invalid \\<and>\n     \\<tau> |\\<noteq> x \\<triangleq> null)", "by(simp add:defined_def true_def false_def invalid_def null_def\n               StrongEq_def OclValid_def bot_fun_def null_fun_def)"], ["", "lemma valid_bool_split: \"(\\<tau> \\<Turnstile> \\<upsilon> A) = ((\\<tau> \\<Turnstile> A \\<triangleq> null) \\<or> (\\<tau> \\<Turnstile> A) \\<or>  (\\<tau> \\<Turnstile> not A)) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> A) =\n    (\\<tau> \\<Turnstile> A \\<triangleq> null \\<or>\n     \\<tau> \\<Turnstile> A \\<or> \\<tau> \\<Turnstile> not A)", "by(auto simp:valid_def true_def false_def invalid_def null_def OclNot_def\n             StrongEq_def OclValid_def bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma defined_bool_split: \"(\\<tau> \\<Turnstile> \\<delta> A) = ((\\<tau> \\<Turnstile> A) \\<or> (\\<tau> \\<Turnstile> not A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> A) =\n    (\\<tau> \\<Turnstile> A \\<or> \\<tau> \\<Turnstile> not A)", "by(auto simp:defined_def true_def false_def invalid_def null_def OclNot_def\n             StrongEq_def OclValid_def bot_fun_def bot_option_def null_option_def null_fun_def)"], ["", "lemma foundation5:\n\"\\<tau> \\<Turnstile> (P and Q) \\<Longrightarrow> (\\<tau> \\<Turnstile> P) \\<and> (\\<tau> \\<Turnstile> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P and Q \\<Longrightarrow>\n    \\<tau> \\<Turnstile> P \\<and> \\<tau> \\<Turnstile> Q", "by(simp add: OclAnd_def OclValid_def true_def false_def defined_def\n             split: option.split option.split_asm bool.split bool.split_asm)"], ["", "lemma foundation6:\n\"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> P", "by(simp add: OclNot_def OclValid_def true_def false_def defined_def\n                null_option_def null_fun_def bot_option_def bot_fun_def\n             split: option.split option.split_asm)"], ["", "lemma foundation7[simp]:\n\"(\\<tau> \\<Turnstile> not (\\<delta> x)) = (\\<not> (\\<tau> \\<Turnstile> \\<delta> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> not (\\<delta> x)) = (\\<tau> |\\<noteq> \\<delta> x)", "by(simp add: OclNot_def OclValid_def true_def false_def defined_def\n             split: option.split option.split_asm)"], ["", "lemma foundation7'[simp]:\n\"(\\<tau> \\<Turnstile> not (\\<upsilon> x)) = (\\<not> (\\<tau> \\<Turnstile> \\<upsilon> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> not (\\<upsilon> x)) =\n    (\\<tau> |\\<noteq> \\<upsilon> x)", "by(simp add: OclNot_def OclValid_def true_def false_def valid_def\n             split: option.split option.split_asm)"], ["", "text\\<open>\n  Key theorem for the $\\delta$-closure: either an expression is\n  defined, or it can be replaced (substituted via \\<open>StrongEq_L_subst2\\<close>;\n  see below) by \\<open>invalid\\<close> or \\<open>null\\<close>. Strictness-reduction rules will\n  usually reduce these substituted terms drastically.\n\\<close>"], ["", "lemma foundation8:\n\"(\\<tau> \\<Turnstile> \\<delta> x) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> null))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null", "have 1 : \"(\\<tau> \\<Turnstile> \\<delta> x) \\<or> (\\<not>(\\<tau> \\<Turnstile> \\<delta> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or> \\<tau> |\\<noteq> \\<delta> x", "by auto"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x \\<or> \\<tau> |\\<noteq> \\<delta> x\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null", "have 2 : \"(\\<not>(\\<tau> \\<Turnstile> \\<delta> x)) = ((\\<tau> \\<Turnstile> (x \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (x \\<triangleq> null)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> |\\<noteq> \\<delta> x) =\n    (\\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n     \\<tau> \\<Turnstile> x \\<triangleq> null)", "by(simp only: defined_split, simp)"], ["proof (state)\nthis:\n  (\\<tau> |\\<noteq> \\<delta> x) =\n  (\\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n   \\<tau> \\<Turnstile> x \\<triangleq> null)\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n    \\<tau> \\<Turnstile> x \\<triangleq> null", "by(insert 1, simp add:2)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> x \\<or>\n  \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<or>\n  \\<tau> \\<Turnstile> x \\<triangleq> null\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma foundation9:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> (\\<tau> \\<Turnstile> not x) = (\\<not> (\\<tau> \\<Turnstile> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> not x) = (\\<tau> |\\<noteq> x)", "apply(simp add: defined_split )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> x \\<triangleq> invalid \\<and>\n    \\<tau> |\\<noteq> x \\<triangleq> null \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> not x) = (\\<tau> |\\<noteq> x)", "by(auto simp: OclNot_def null_fun_def null_option_def bot_option_def\n                 OclValid_def invalid_def true_def null_def StrongEq_def)"], ["", "lemma foundation9':\n\"\\<tau> \\<Turnstile> not x \\<Longrightarrow> \\<not> (\\<tau> \\<Turnstile> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not x \\<Longrightarrow> \\<tau> |\\<noteq> x", "by(auto simp: foundation6 foundation9)"], ["", "lemma foundation9'':\n\"            \\<tau> \\<Turnstile> not x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> x", "by(metis OclNot3 OclNot_not OclValid_def cp_OclNot cp_defined defined4)"], ["", "lemma foundation10:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> y \\<Longrightarrow> (\\<tau> \\<Turnstile> (x and y)) = ( (\\<tau> \\<Turnstile> x) \\<and> (\\<tau> \\<Turnstile> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     \\<tau> \\<Turnstile> \\<delta> y\\<rbrakk>\n    \\<Longrightarrow> (\\<tau> \\<Turnstile> x and y) =\n                      (\\<tau> \\<Turnstile> x \\<and> \\<tau> \\<Turnstile> y)", "apply(simp add: defined_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid \\<and>\n             \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> y \\<triangleq> invalid \\<and>\n     \\<tau> |\\<noteq> y \\<triangleq> null\\<rbrakk>\n    \\<Longrightarrow> (\\<tau> \\<Turnstile> x and y) =\n                      (\\<tau> \\<Turnstile> x \\<and> \\<tau> \\<Turnstile> y)", "by(auto simp: OclAnd_def OclValid_def invalid_def\n              true_def null_def StrongEq_def null_fun_def null_option_def bot_option_def\n        split:bool.split_asm)"], ["", "lemma foundation10': \"(\\<tau> \\<Turnstile> (A and B)) = ((\\<tau> \\<Turnstile> A) \\<and> (\\<tau> \\<Turnstile> B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> A and B) =\n    (\\<tau> \\<Turnstile> A \\<and> \\<tau> \\<Turnstile> B)", "(* stronger than foundation !*)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> A and B) =\n    (\\<tau> \\<Turnstile> A \\<and> \\<tau> \\<Turnstile> B)", "by(auto dest:foundation5 simp:foundation6 foundation10)"], ["", "lemma foundation11:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> y \\<Longrightarrow> (\\<tau> \\<Turnstile> (x or y)) = ( (\\<tau> \\<Turnstile> x) \\<or> (\\<tau> \\<Turnstile> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     \\<tau> \\<Turnstile> \\<delta> y\\<rbrakk>\n    \\<Longrightarrow> (\\<tau> \\<Turnstile> x or y) =\n                      (\\<tau> \\<Turnstile> x \\<or> \\<tau> \\<Turnstile> y)", "apply(simp add: defined_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> |\\<noteq> x \\<triangleq> invalid \\<and>\n             \\<tau> |\\<noteq> x \\<triangleq> null;\n     \\<tau> |\\<noteq> y \\<triangleq> invalid \\<and>\n     \\<tau> |\\<noteq> y \\<triangleq> null\\<rbrakk>\n    \\<Longrightarrow> (\\<tau> \\<Turnstile> x or y) =\n                      (\\<tau> \\<Turnstile> x \\<or> \\<tau> \\<Turnstile> y)", "by(auto simp: OclNot_def OclOr_def OclAnd_def OclValid_def invalid_def\n              true_def null_def StrongEq_def null_fun_def null_option_def bot_option_def\n        split:bool.split_asm bool.split)"], ["", "lemma foundation12:\n\"\\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow> (\\<tau> \\<Turnstile> (x implies y)) = ( (\\<tau> \\<Turnstile> x) \\<longrightarrow> (\\<tau> \\<Turnstile> y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> x implies y) =\n    (\\<tau> \\<Turnstile> x \\<longrightarrow> \\<tau> \\<Turnstile> y)", "apply(simp add: defined_split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> x \\<triangleq> invalid \\<and>\n    \\<tau> |\\<noteq> x \\<triangleq> null \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> x implies y) =\n    (\\<tau> \\<Turnstile> x \\<longrightarrow> \\<tau> \\<Turnstile> y)", "by(auto simp: OclNot_def OclOr_def OclAnd_def OclImplies_def bot_option_def\n              OclValid_def invalid_def true_def null_def StrongEq_def null_fun_def null_option_def\n        split:bool.split_asm bool.split option.split_asm)"], ["", "lemma foundation13:\"(\\<tau> \\<Turnstile> A \\<triangleq> true)    = (\\<tau> \\<Turnstile> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> A \\<triangleq> true) = (\\<tau> \\<Turnstile> A)", "by(auto simp: OclNot_def  OclValid_def invalid_def true_def null_def StrongEq_def\n              split:bool.split_asm bool.split)"], ["", "lemma foundation14:\"(\\<tau> \\<Turnstile> A \\<triangleq> false)   = (\\<tau> \\<Turnstile> not A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> A \\<triangleq> false) = (\\<tau> \\<Turnstile> not A)", "by(auto simp: OclNot_def  OclValid_def invalid_def false_def true_def null_def StrongEq_def\n        split:bool.split_asm bool.split option.split)"], ["", "lemma foundation15:\"(\\<tau> \\<Turnstile> A \\<triangleq> invalid) = (\\<tau> \\<Turnstile> not(\\<upsilon> A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> A \\<triangleq> invalid) =\n    (\\<tau> \\<Turnstile> not (\\<upsilon> A))", "by(auto simp: OclNot_def OclValid_def valid_def invalid_def false_def true_def null_def\n              StrongEq_def bot_option_def null_fun_def null_option_def bot_option_def bot_fun_def\n        split:bool.split_asm bool.split option.split)"], ["", "(* ... and the usual rules on strictness, definedness propoagation, and cp ... *)"], ["", "lemma foundation16: \"\\<tau> \\<Turnstile> (\\<delta> X) = (X \\<tau> \\<noteq> bot \\<and> X \\<tau> \\<noteq> null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> X) =\n    (X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<and>\n     X \\<tau> \\<noteq> null)", "by(auto simp: OclValid_def defined_def false_def true_def  bot_fun_def null_fun_def\n        split:if_split_asm)"], ["", "lemma foundation16'': \"\\<not>(\\<tau> \\<Turnstile> (\\<delta> X)) = ((\\<tau> \\<Turnstile> (X \\<triangleq> invalid)) \\<or> (\\<tau> \\<Turnstile> (X \\<triangleq> null)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> X) \\<noteq>\n    (\\<tau> \\<Turnstile> X \\<triangleq> invalid \\<or>\n     \\<tau> \\<Turnstile> X \\<triangleq> null)", "apply(simp add: foundation16)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<and>\n     X \\<tau> \\<noteq> null) =\n    (\\<tau> |\\<noteq> X \\<triangleq> invalid \\<and>\n     \\<tau> |\\<noteq> X \\<triangleq> null)", "by(auto simp:defined_def false_def true_def  bot_fun_def null_fun_def OclValid_def StrongEq_def invalid_def)"], ["", "(* correcter rule; the previous is deprecated *)"], ["", "lemma foundation16': \"(\\<tau> \\<Turnstile> (\\<delta> X)) = (X \\<tau> \\<noteq> invalid \\<tau> \\<and> X \\<tau> \\<noteq> null \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> X) =\n    (X \\<tau> \\<noteq> invalid \\<tau> \\<and> X \\<tau> \\<noteq> null \\<tau>)", "apply(simp add:invalid_def null_def null_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> X) =\n    (X \\<tau> \\<noteq> UML_Types.bot_class.bot \\<and>\n     X \\<tau> \\<noteq> null)", "by(auto simp: OclValid_def defined_def false_def true_def  bot_fun_def null_fun_def\n        split:if_split_asm)"], ["", "lemma foundation18: \"(\\<tau> \\<Turnstile> (\\<upsilon> X)) = (X \\<tau> \\<noteq> invalid \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X) = (X \\<tau> \\<noteq> invalid \\<tau>)", "by(auto simp: OclValid_def valid_def false_def true_def bot_fun_def invalid_def\n        split:if_split_asm)"], ["", "(*legacy*)"], ["", "lemma foundation18': \"(\\<tau> \\<Turnstile> (\\<upsilon> X)) = (X \\<tau> \\<noteq> bot)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X) =\n    (X \\<tau> \\<noteq> UML_Types.bot_class.bot)", "by(auto simp: OclValid_def valid_def false_def true_def bot_fun_def\n        split:if_split_asm)"], ["", "lemma foundation18'': \"(\\<tau> \\<Turnstile> (\\<upsilon> X) )=  (\\<not>(\\<tau> \\<Turnstile> (X \\<triangleq> invalid)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> X) =\n    (\\<tau> |\\<noteq> X \\<triangleq> invalid)", "by(auto simp:foundation15)"], ["", "lemma foundation20 : \"\\<tau> \\<Turnstile> (\\<delta> X) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> X \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> X", "by(simp add: foundation18 foundation16 invalid_def)"], ["", "lemma foundation21: \"(not A \\<triangleq> not B) = (A \\<triangleq> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (not A \\<triangleq> not B) = (A \\<triangleq> B)", "by(rule ext, auto simp: OclNot_def StrongEq_def\n                     split: bool.split_asm HOL.if_split_asm option.split)"], ["", "lemma foundation22: \"(\\<tau> \\<Turnstile> (X \\<triangleq> Y)) = (X \\<tau> = Y \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> X \\<triangleq> Y) = (X \\<tau> = Y \\<tau>)", "by(auto simp: StrongEq_def OclValid_def true_def)"], ["", "lemma foundation23: \"(\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> (\\<lambda> _ . P \\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> P) = (\\<tau> \\<Turnstile> \\<lambda>_. P \\<tau>)", "by(auto simp: OclValid_def true_def)"], ["", "lemma foundation24:\"(\\<tau> \\<Turnstile> not(X \\<triangleq> Y)) = (X \\<tau> \\<noteq> Y \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> not (X \\<triangleq> Y)) =\n    (X \\<tau> \\<noteq> Y \\<tau>)", "by(simp add: StrongEq_def  OclValid_def OclNot_def true_def)"], ["", "lemma foundation25: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> (P or Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> P or Q", "by(simp add: OclOr_def OclNot_def OclAnd_def OclValid_def true_def)"], ["", "lemma foundation25': \"\\<tau> \\<Turnstile> Q \\<Longrightarrow> \\<tau> \\<Turnstile> (P or Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> Q \\<Longrightarrow> \\<tau> \\<Turnstile> P or Q", "by(subst OclOr_commute, simp add: foundation25)"], ["", "lemma foundation26:\nassumes defP: \"\\<tau> \\<Turnstile> \\<delta> P\"\nassumes defQ: \"\\<tau> \\<Turnstile> \\<delta> Q\"\nassumes H: \"\\<tau> \\<Turnstile> (P or Q)\"\nassumes P: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> R\"\nassumes Q: \"\\<tau> \\<Turnstile> Q \\<Longrightarrow> R\"\nshows \"R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R", "by(insert H, subst (asm) foundation11[OF defP defQ], erule disjE, simp_all add: P Q)"], ["", "lemma foundation27: \"\\<tau> \\<Turnstile> A \\<Longrightarrow> (\\<tau> \\<Turnstile> A implies B) = (\\<tau> \\<Turnstile> B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> A \\<Longrightarrow>\n    (\\<tau> \\<Turnstile> A implies B) = (\\<tau> \\<Turnstile> B)", "by (simp add: foundation12 foundation6)"], ["", "lemma defined_not_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (not x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> not x", "by(auto simp: OclNot_def null_def invalid_def defined_def valid_def OclValid_def\n                  true_def false_def bot_option_def null_option_def null_fun_def bot_fun_def\n             split: option.split_asm HOL.if_split_asm)"], ["", "lemma valid_not_I : \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (not x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<upsilon> x \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> not x", "by(auto simp: OclNot_def null_def invalid_def defined_def valid_def OclValid_def\n                  true_def false_def bot_option_def null_option_def null_fun_def bot_fun_def\n          split: option.split_asm option.split HOL.if_split_asm)"], ["", "lemma defined_and_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x and y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     \\<tau> \\<Turnstile> \\<delta> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x and y)", "apply(simp add: OclAnd_def null_def invalid_def defined_def valid_def OclValid_def\n                  true_def false_def bot_option_def null_option_def null_fun_def bot_fun_def\n             split: option.split_asm HOL.if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>(\\<exists>ya. y \\<tau> = \\<lfloor>ya\\<rfloor>) \\<and>\n                y \\<tau> \\<noteq> \\<lfloor>\\<bottom>\\<rfloor>;\n        \\<exists>y. ya = \\<lfloor>y\\<rfloor>;\n        x \\<tau> = \\<lfloor>ya\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> (\\<exists>yaa.\n                             (case ya of\n                              \\<bottom> \\<Rightarrow>\n                                case y \\<tau> of\n                                \\<bottom> \\<Rightarrow> \\<bottom>\n                                | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                    \\<lfloor>\\<bottom>\\<rfloor>\n                                | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                    \\<lfloor>\\<bottom>\\<rfloor>\n                                | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                    \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                              | \\<lfloor>True\\<rfloor> \\<Rightarrow>\n                                  y \\<tau>\n                              | \\<lfloor>False\\<rfloor> \\<Rightarrow>\n                                  \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n                             \\<lfloor>yaa\\<rfloor>) \\<and>\n                         (case ya of\n                          \\<bottom> \\<Rightarrow>\n                            case y \\<tau> of\n                            \\<bottom> \\<Rightarrow> \\<bottom>\n                            | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>\\<bottom>\\<rfloor>\n                            | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>\\<bottom>\\<rfloor>\n                            | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                          | \\<lfloor>True\\<rfloor> \\<Rightarrow> y \\<tau>\n                          | \\<lfloor>False\\<rfloor> \\<Rightarrow>\n                              \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) \\<noteq>\n                         \\<lfloor>\\<bottom>\\<rfloor>", "apply(auto simp: null_option_def split: bool.split)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya yaa.\n       \\<lbrakk>x \\<tau> = \\<lfloor>\\<lfloor>ya\\<rfloor>\\<rfloor>;\n        y \\<tau> = \\<lfloor>\\<lfloor>yaa\\<rfloor>\\<rfloor>;\n        (case ya of True \\<Rightarrow> y \\<tau>\n         | False \\<Rightarrow> \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n        \\<lfloor>\\<bottom>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> False", "by(case_tac \"ya\",simp_all)"], ["", "lemma valid_and_I :   \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<upsilon> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x and y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x and y)", "apply(simp add: OclAnd_def null_def invalid_def defined_def valid_def OclValid_def\n                  true_def false_def bot_option_def null_option_def null_fun_def bot_fun_def\n             split: option.split_asm HOL.if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ya.\n       \\<lbrakk>\\<exists>ya. y \\<tau> = \\<lfloor>ya\\<rfloor>;\n        x \\<tau> = \\<lfloor>ya\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>yaa.\n                            (case ya of\n                             \\<bottom> \\<Rightarrow>\n                               case y \\<tau> of\n                               \\<bottom> \\<Rightarrow> \\<bottom>\n                               | \\<lfloor>\\<bottom>\\<rfloor> \\<Rightarrow>\n                                   \\<lfloor>\\<bottom>\\<rfloor>\n                               | \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                   \\<lfloor>\\<bottom>\\<rfloor>\n                               | \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor> \\<Rightarrow>\n                                   \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>\n                             | \\<lfloor>True\\<rfloor> \\<Rightarrow> y \\<tau>\n                             | \\<lfloor>False\\<rfloor> \\<Rightarrow>\n                                 \\<lfloor>\\<lfloor>False\\<rfloor>\\<rfloor>) =\n                            \\<lfloor>yaa\\<rfloor>", "by(auto simp: null_option_def split: option.split bool.split)"], ["", "lemma defined_or_I : \"\\<tau> \\<Turnstile> \\<delta> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<delta> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x or y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> x;\n     \\<tau> \\<Turnstile> \\<delta> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> (x or y)", "by(simp add: OclOr_def defined_and_I defined_not_I)"], ["", "lemma valid_or_I :   \"\\<tau> \\<Turnstile> \\<upsilon> (x) \\<Longrightarrow>  \\<tau> \\<Turnstile> \\<upsilon> (y) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x or y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> \\<upsilon> (x or y)", "by(simp add: OclOr_def valid_and_I valid_not_I)"], ["", "subsubsection\\<open>Local Judgements and Strong Equality\\<close>"], ["", "lemma StrongEq_L_refl: \"\\<tau> \\<Turnstile> (x \\<triangleq> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x \\<triangleq> x", "by(simp add: OclValid_def StrongEq_def)"], ["", "lemma StrongEq_L_sym: \"\\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (y \\<triangleq> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> x \\<triangleq> y \\<Longrightarrow>\n    \\<tau> \\<Turnstile> y \\<triangleq> x", "by(simp add: StrongEq_sym)"], ["", "lemma StrongEq_L_trans: \"\\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (y \\<triangleq> z) \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> x \\<triangleq> y;\n     \\<tau> \\<Turnstile> y \\<triangleq> z\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> x \\<triangleq> z", "by(simp add: OclValid_def StrongEq_def true_def)"], ["", "text\\<open>In order to establish substitutivity (which does not\nhold in general HOL formulas) we introduce the following\npredicate that allows for a calculus of the necessary side-conditions.\\<close>"], ["", "definition cp   :: \"(('\\<AA>,'\\<alpha>) val \\<Rightarrow> ('\\<AA>,'\\<beta>) val) \\<Rightarrow> bool\"\nwhere     \"cp P \\<equiv> (\\<exists> f. \\<forall> X \\<tau>. P X \\<tau> = f (X \\<tau>) \\<tau>)\""], ["", "text\\<open>The rule of substitutivity in Featherweight OCL holds only\nfor context-passing expressions, \\ie those that pass\nthe context \\<open>\\<tau>\\<close> without changing it. Fortunately, all\noperators of the OCL language satisfy this property\n(but not all HOL operators).\\<close>"], ["", "lemma StrongEq_L_subst1: \"\\<And> \\<tau>. cp P \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (P x \\<triangleq> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>cp P; \\<tau> \\<Turnstile> x \\<triangleq> y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> P x \\<triangleq> P y", "by(auto simp: OclValid_def StrongEq_def true_def cp_def)"], ["", "lemma StrongEq_L_subst2:\n\"\\<And> \\<tau>.  cp P \\<Longrightarrow> \\<tau> \\<Turnstile> (x \\<triangleq> y) \\<Longrightarrow> \\<tau> \\<Turnstile> (P x) \\<Longrightarrow> \\<tau> \\<Turnstile> (P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>cp P; \\<tau> \\<Turnstile> x \\<triangleq> y;\n        \\<tau> \\<Turnstile> P x\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> P y", "by(auto simp: OclValid_def StrongEq_def true_def cp_def)"], ["", "lemma StrongEq_L_subst2_rev: \"\\<tau> \\<Turnstile> y \\<triangleq> x \\<Longrightarrow> cp P \\<Longrightarrow> \\<tau> \\<Turnstile> P x \\<Longrightarrow> \\<tau> \\<Turnstile> P y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> y \\<triangleq> x; cp P;\n     \\<tau> \\<Turnstile> P x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> P y", "apply(erule StrongEq_L_subst2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> y \\<triangleq> x;\n     \\<tau> \\<Turnstile> P x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> ?x \\<triangleq> y\n 2. \\<lbrakk>\\<tau> \\<Turnstile> y \\<triangleq> x;\n     \\<tau> \\<Turnstile> P x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> P ?x", "apply(erule StrongEq_L_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> y \\<triangleq> x;\n     \\<tau> \\<Turnstile> P x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> P x", "by assumption"], ["", "lemma  StrongEq_L_subst3:\nassumes cp: \"cp P\"\nand     eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\"\nshows       \"(\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<tau> \\<Turnstile> P x \\<Longrightarrow> \\<tau> \\<Turnstile> P y\n 2. \\<tau> \\<Turnstile> P y \\<Longrightarrow> \\<tau> \\<Turnstile> P x", "apply(rule StrongEq_L_subst2[OF cp,OF eq],simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P y \\<Longrightarrow> \\<tau> \\<Turnstile> P x", "apply(rule StrongEq_L_subst2[OF cp,OF eq[THEN StrongEq_L_sym]],simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma  StrongEq_L_subst3_rev:\nassumes eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\" \nand     cp: \"cp P\"\nshows       \"(\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)", "by(insert cp, erule StrongEq_L_subst3, rule eq)"], ["", "lemma  StrongEq_L_subst4_rev:\nassumes eq: \"\\<tau> \\<Turnstile> (x \\<triangleq> y)\" \nand     cp: \"cp P\"\nshows       \"(\\<not>(\\<tau> \\<Turnstile> P x)) = (\\<not>(\\<tau> \\<Turnstile> P y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> |\\<noteq> P x) = (\\<tau> |\\<noteq> P y)", "thm arg_cong[of _ _ \"Not\"]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> |\\<noteq> P x) = (\\<tau> |\\<noteq> P y)", "apply(rule arg_cong[of _ _ \"Not\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> P x) = (\\<tau> \\<Turnstile> P y)", "by(insert cp, erule StrongEq_L_subst3, rule eq)"], ["", "lemma cpI1:\n\"(\\<forall> X \\<tau>. f X \\<tau> = f(\\<lambda>_. X \\<tau>) \\<tau>) \\<Longrightarrow> cp P \\<Longrightarrow> cp(\\<lambda>X. f (P X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X \\<tau>.\n                f X \\<tau> = f (\\<lambda>_. X \\<tau>) \\<tau>;\n     cp P\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (P X))", "apply(auto simp: true_def cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa.\n       \\<lbrakk>\\<forall>X a b.\n                   f X (a, b) = f (\\<lambda>_. X (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            \\<forall>X a b.\n                               f (P X) (a, b) = fa (X (a, b)) (a, b)", "apply(rule exI, (rule allI)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa X a b.\n       \\<lbrakk>\\<forall>X a b.\n                   f X (a, b) = f (\\<lambda>_. X (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (P X) (a, b) = ?f1 fa (X (a, b)) (a, b)", "by(erule_tac x=\"P X\" in allE, auto)"], ["", "lemma cpI2:\n\"(\\<forall> X Y \\<tau>. f X Y \\<tau> = f(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X Y \\<tau>.\n                f X Y \\<tau> =\n                f (\\<lambda>_. X \\<tau>) (\\<lambda>_. Y \\<tau>) \\<tau>;\n     cp P; cp Q\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X))", "apply(auto simp: true_def cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa.\n       \\<lbrakk>\\<forall>X Y a b.\n                   f X Y (a, b) =\n                   f (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            \\<forall>X a b.\n                               f (P X) (Q X) (a, b) = fa (X (a, b)) (a, b)", "apply(rule exI, (rule allI)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa X a b.\n       \\<lbrakk>\\<forall>X Y a b.\n                   f X Y (a, b) =\n                   f (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (P X) (Q X) (a, b) = ?f2 fa faa (X (a, b)) (a, b)", "by(erule_tac x=\"P X\" in allE, auto)"], ["", "lemma cpI3:\n\"(\\<forall> X Y Z \\<tau>. f X Y Z \\<tau> = f(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X) (R X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>X Y Z \\<tau>.\n                f X Y Z \\<tau> =\n                f (\\<lambda>_. X \\<tau>) (\\<lambda>_. Y \\<tau>)\n                 (\\<lambda>_. Z \\<tau>) \\<tau>;\n     cp P; cp Q; cp R\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X) (R X))", "apply(auto simp: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb.\n       \\<lbrakk>\\<forall>X Y Z a b.\n                   f X Y Z (a, b) =\n                   f (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b))\n                    (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fb (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            \\<forall>X a b.\n                               f (P X) (Q X) (R X) (a, b) =\n                               fa (X (a, b)) (a, b)", "apply(rule exI, (rule allI)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb X a b.\n       \\<lbrakk>\\<forall>X Y Z a b.\n                   f X Y Z (a, b) =\n                   f (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b))\n                    (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fb (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (P X) (Q X) (R X) (a, b) =\n                         ?f3 fa faa fb (X (a, b)) (a, b)", "by(erule_tac x=\"P X\" in allE, auto)"], ["", "lemma cpI4:\n\"(\\<forall> W X Y Z \\<tau>. f W X Y Z \\<tau> = f(\\<lambda>_. W \\<tau>)(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp S \\<Longrightarrow> cp(\\<lambda>X. f (P X) (Q X) (R X) (S X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>W X Y Z \\<tau>.\n                f W X Y Z \\<tau> =\n                f (\\<lambda>_. W \\<tau>) (\\<lambda>_. X \\<tau>)\n                 (\\<lambda>_. Y \\<tau>) (\\<lambda>_. Z \\<tau>) \\<tau>;\n     cp P; cp Q; cp R; cp S\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X) (R X) (S X))", "apply(auto simp: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb fc.\n       \\<lbrakk>\\<forall>W X Y Z a b.\n                   f W X Y Z (a, b) =\n                   f (\\<lambda>_. W (a, b)) (\\<lambda>_. X (a, b))\n                    (\\<lambda>_. Y (a, b)) (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fb (X (a, b)) (a, b);\n        \\<forall>X a b. S X (a, b) = fc (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            \\<forall>X a b.\n                               f (P X) (Q X) (R X) (S X) (a, b) =\n                               fa (X (a, b)) (a, b)", "apply(rule exI, (rule allI)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb fc X a b.\n       \\<lbrakk>\\<forall>W X Y Z a b.\n                   f W X Y Z (a, b) =\n                   f (\\<lambda>_. W (a, b)) (\\<lambda>_. X (a, b))\n                    (\\<lambda>_. Y (a, b)) (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fb (X (a, b)) (a, b);\n        \\<forall>X a b. S X (a, b) = fc (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (P X) (Q X) (R X) (S X) (a, b) =\n                         ?f4 fa faa fb fc (X (a, b)) (a, b)", "by(erule_tac x=\"P X\" in allE, auto)"], ["", "lemma cpI5:\n\"(\\<forall> V W X Y Z \\<tau>. f V W X Y Z \\<tau> = f(\\<lambda>_. V \\<tau>) (\\<lambda>_. W \\<tau>)(\\<lambda>_. X \\<tau>)(\\<lambda>_. Y \\<tau>)(\\<lambda>_. Z \\<tau>) \\<tau>) \\<Longrightarrow>\n cp N \\<Longrightarrow> cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp R \\<Longrightarrow> cp S \\<Longrightarrow> cp(\\<lambda>X. f (N X) (P X) (Q X) (R X) (S X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>V W X Y Z \\<tau>.\n                f V W X Y Z \\<tau> =\n                f (\\<lambda>_. V \\<tau>) (\\<lambda>_. W \\<tau>)\n                 (\\<lambda>_. X \\<tau>) (\\<lambda>_. Y \\<tau>)\n                 (\\<lambda>_. Z \\<tau>) \\<tau>;\n     cp N; cp P; cp Q; cp R; cp S\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (N X) (P X) (Q X) (R X) (S X))", "apply(auto simp: cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb fc fd.\n       \\<lbrakk>\\<forall>V W X Y Z a b.\n                   f V W X Y Z (a, b) =\n                   f (\\<lambda>_. V (a, b)) (\\<lambda>_. W (a, b))\n                    (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b))\n                    (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. N X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = fb (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fc (X (a, b)) (a, b);\n        \\<forall>X a b. S X (a, b) = fd (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>fa.\n                            \\<forall>X a b.\n                               f (N X) (P X) (Q X) (R X) (S X) (a, b) =\n                               fa (X (a, b)) (a, b)", "apply(rule exI, (rule allI)+)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fa faa fb fc fd X a b.\n       \\<lbrakk>\\<forall>V W X Y Z a b.\n                   f V W X Y Z (a, b) =\n                   f (\\<lambda>_. V (a, b)) (\\<lambda>_. W (a, b))\n                    (\\<lambda>_. X (a, b)) (\\<lambda>_. Y (a, b))\n                    (\\<lambda>_. Z (a, b)) (a, b);\n        \\<forall>X a b. N X (a, b) = fa (X (a, b)) (a, b);\n        \\<forall>X a b. P X (a, b) = faa (X (a, b)) (a, b);\n        \\<forall>X a b. Q X (a, b) = fb (X (a, b)) (a, b);\n        \\<forall>X a b. R X (a, b) = fc (X (a, b)) (a, b);\n        \\<forall>X a b. S X (a, b) = fd (X (a, b)) (a, b)\\<rbrakk>\n       \\<Longrightarrow> f (N X) (P X) (Q X) (R X) (S X) (a, b) =\n                         ?f5 fa faa fb fc fd (X (a, b)) (a, b)", "by(erule_tac x=\"N X\" in allE, auto)"], ["", "lemma cp_const : \"cp(\\<lambda>_. c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp (\\<lambda>_. c)", "by (simp add: cp_def, fast)"], ["", "lemma cp_id :     \"cp(\\<lambda>X. X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp (\\<lambda>X. X)", "by (simp add: cp_def, fast)"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemmas cp_intro[intro!,simp,code_unfold] =\n       cp_const\n       cp_id\n       cp_defined[THEN allI[THEN allI[THEN cpI1], of defined]]\n       cp_valid[THEN allI[THEN allI[THEN cpI1], of valid]]\n       cp_OclNot[THEN allI[THEN allI[THEN cpI1], of not]]\n       cp_OclAnd[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(and)\"]]\n       cp_OclOr[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(or)\"]]\n       cp_OclImplies[THEN allI[THEN allI[THEN allI[THEN cpI2]], of \"(implies)\"]]\n       cp_StrongEq[THEN allI[THEN allI[THEN allI[THEN cpI2]],\n                   of \"StrongEq\"]]"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "subsection\\<open>OCL's if then else endif\\<close>"], ["", "definition OclIf :: \"[('\\<AA>)Boolean , ('\\<AA>,'\\<alpha>::null) val, ('\\<AA>,'\\<alpha>) val] \\<Rightarrow> ('\\<AA>,'\\<alpha>) val\"\n                     (\"if (_) then (_) else (_) endif\" [10,10,10]50)\nwhere \"(if C then B\\<^sub>1 else B\\<^sub>2 endif) = (\\<lambda> \\<tau>. if (\\<delta> C) \\<tau> = true \\<tau>\n                                           then (if (C \\<tau>) = true \\<tau>\n                                                then B\\<^sub>1 \\<tau>\n                                                else B\\<^sub>2 \\<tau>)\n                                           else invalid \\<tau>)\""], ["", "lemma cp_OclIf:\"((if C then B\\<^sub>1 else B\\<^sub>2 endif) \\<tau> =\n                  (if (\\<lambda> _. C \\<tau>) then (\\<lambda> _. B\\<^sub>1 \\<tau>) else (\\<lambda> _. B\\<^sub>2 \\<tau>) endif) \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if C then B\\<^sub>1 else B\\<^sub>2 endif) \\<tau> =\n    (if (\\<lambda>_.\n            C \\<tau>) then (\\<lambda>_.\n                               B\\<^sub>1\n                                \\<tau>) else (\\<lambda>_.\n           B\\<^sub>2 \\<tau>) endif)\n     \\<tau>", "by(simp only: OclIf_def, subst cp_defined, rule refl)"], ["", "text_raw\\<open>\\isatagafp\\<close>"], ["", "lemmas cp_intro'[intro!,simp,code_unfold] =\n       cp_intro\n       cp_OclIf[THEN allI[THEN allI[THEN allI[THEN allI[THEN cpI3]]], of \"OclIf\"]]"], ["", "text_raw\\<open>\\endisatagafp\\<close>"], ["", "lemma OclIf_invalid [simp]: \"(if invalid then B\\<^sub>1 else B\\<^sub>2 endif) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if invalid then B\\<^sub>1 else B\\<^sub>2 endif) = invalid", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclIf_null [simp]: \"(if null then B\\<^sub>1 else B\\<^sub>2 endif) = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if null then B\\<^sub>1 else B\\<^sub>2 endif) = invalid", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclIf_true [simp]: \"(if true then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if true then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>1", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclIf_true' [simp]: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> (if P then B\\<^sub>1 else B\\<^sub>2 endif)\\<tau> = B\\<^sub>1 \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P \\<Longrightarrow>\n    (if P then B\\<^sub>1 else B\\<^sub>2 endif) \\<tau> = B\\<^sub>1 \\<tau>", "apply(subst cp_OclIf,auto simp: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tau> = true \\<tau> \\<Longrightarrow>\n    (if (\\<lambda>_.\n            true\n             \\<tau>) then (\\<lambda>_.\n                              B\\<^sub>1\n                               \\<tau>) else (\\<lambda>_.\n          B\\<^sub>2 \\<tau>) endif)\n     \\<tau> =\n    B\\<^sub>1 \\<tau>", "by(simp add:cp_OclIf[symmetric])"], ["", "lemma OclIf_true'' [simp]: \"\\<tau> \\<Turnstile> P \\<Longrightarrow> \\<tau> \\<Turnstile> (if P then B\\<^sub>1 else B\\<^sub>2 endif) \\<triangleq> B\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> P \\<Longrightarrow>\n    \\<tau>\n     \\<Turnstile> if P then B\\<^sub>1 else B\\<^sub>2 endif \\<triangleq>\n                  B\\<^sub>1", "by(subst OclValid_def, simp add: StrongEq_def true_def)"], ["", "lemma OclIf_false [simp]: \"(if false then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if false then B\\<^sub>1 else B\\<^sub>2 endif) = B\\<^sub>2", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclIf_false' [simp]: \"\\<tau> \\<Turnstile> not P \\<Longrightarrow> (if P then B\\<^sub>1 else B\\<^sub>2 endif)\\<tau> = B\\<^sub>2 \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not P \\<Longrightarrow>\n    (if P then B\\<^sub>1 else B\\<^sub>2 endif) \\<tau> = B\\<^sub>2 \\<tau>", "apply(subst cp_OclIf)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not P \\<Longrightarrow>\n    (if (\\<lambda>_.\n            P \\<tau>) then (\\<lambda>_.\n                               B\\<^sub>1\n                                \\<tau>) else (\\<lambda>_.\n           B\\<^sub>2 \\<tau>) endif)\n     \\<tau> =\n    B\\<^sub>2 \\<tau>", "apply(auto simp: foundation14[symmetric] foundation22)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<tau> = false \\<tau> \\<Longrightarrow>\n    (if (\\<lambda>_.\n            false\n             \\<tau>) then (\\<lambda>_.\n                              B\\<^sub>1\n                               \\<tau>) else (\\<lambda>_.\n          B\\<^sub>2 \\<tau>) endif)\n     \\<tau> =\n    B\\<^sub>2 \\<tau>", "by(auto simp: cp_OclIf[symmetric])"], ["", "lemma OclIf_idem1[simp]:\"(if \\<delta> X then A else A endif) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<delta> X then A else A endif) = A", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclIf_idem2[simp]:\"(if \\<upsilon> X then A else A endif) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if \\<upsilon> X then A else A endif) = A", "by(rule ext, auto simp: OclIf_def)"], ["", "lemma OclNot_if[simp]:\n\"not(if P then C else E endif) = (if P then not C else not E endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. not (if P then C else E endif) = (if P then not C else not E endif)", "(* non-trivial but elementary *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. not (if P then C else E endif) = (if P then not C else not E endif)", "apply(rule OclNot_inject, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if P then C else E endif) = not (if P then not C else not E endif)", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if P then C else E endif) x =\n       not (if P then not C else not E endif) x", "apply(subst cp_OclNot, simp add: OclIf_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P x = true x \\<longrightarrow>\n        ((\\<delta> P) x = true x \\<longrightarrow>\n         C x = not (\\<lambda>_. not C x) x) \\<and>\n        ((\\<delta> P) x \\<noteq> true x \\<longrightarrow>\n         invalid x = not (\\<lambda>_. invalid x) x)) \\<and>\n       (P x \\<noteq> true x \\<longrightarrow>\n        ((\\<delta> P) x = true x \\<longrightarrow>\n         E x = not (\\<lambda>_. not E x) x) \\<and>\n        ((\\<delta> P) x \\<noteq> true x \\<longrightarrow>\n         invalid x = not (\\<lambda>_. invalid x) x))", "apply(subst cp_OclNot[symmetric])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (P x = true x \\<longrightarrow>\n        ((\\<delta> P) x = true x \\<longrightarrow>\n         C x = not (not C) x) \\<and>\n        ((\\<delta> P) x \\<noteq> true x \\<longrightarrow>\n         invalid x = not invalid x)) \\<and>\n       (P x \\<noteq> true x \\<longrightarrow>\n        ((\\<delta> P) x = true x \\<longrightarrow>\n         E x = not (not E) x) \\<and>\n        ((\\<delta> P) x \\<noteq> true x \\<longrightarrow>\n         invalid x = not invalid x))", "by simp"], ["", "subsection\\<open>Fundamental Predicates on Basic Types: Strict (Referential) Equality\\<close>"], ["", "text\\<open>\n  In contrast to logical equality, the OCL standard defines an equality operation\n  which we call ``strict referential equality''. It behaves differently for all\n  types---on value types, it is basically a strict version of strong equality, \n  for defined values it behaves identical. But on object types it will compare \n  their references within the store. We  introduce strict referential equality \n  as an \\emph{overloaded} concept and will handle it for\n  each type instance individually.\n\\<close>"], ["", "consts StrictRefEq :: \"[('\\<AA>,'a)val,('\\<AA>,'a)val] \\<Rightarrow> ('\\<AA>)Boolean\" (infixl \"\\<doteq>\" 30)"], ["", "text\\<open>with {term \"not\"} we can express the notation:\\<close>"], ["", "syntax\n  \"notequal\"        :: \"('\\<AA>)Boolean \\<Rightarrow> ('\\<AA>)Boolean \\<Rightarrow> ('\\<AA>)Boolean\"   (infix \"<>\" 40)"], ["", "translations\n  \"a <> b\" == \"CONST OclNot(a \\<doteq> b)\""], ["", "text\\<open>We will define instances of this equality in a case-by-case basis.\\<close>"], ["", "subsection\\<open>Laws to Establish Definedness (\\texorpdfstring{$\\delta$}{d}-closure)\\<close>"], ["", "text\\<open>For the logical connectives, we have --- beyond\n@{thm foundation6} --- the following facts:\\<close>"], ["", "lemma OclNot_defargs:\n\"\\<tau> \\<Turnstile> (not P) \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not P \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<delta> P", "by(auto simp: OclNot_def OclValid_def true_def invalid_def defined_def false_def\n                 bot_fun_def bot_option_def null_fun_def null_option_def\n        split: bool.split_asm HOL.if_split_asm option.split option.split_asm)"], ["", "lemma OclNot_contrapos_nn:\n assumes A: \"\\<tau> \\<Turnstile> \\<delta> A\"\n assumes B: \"\\<tau> \\<Turnstile> not B\"\n assumes C: \"\\<tau> \\<Turnstile> A \\<Longrightarrow> \\<tau> \\<Turnstile> B\"\n shows      \"\\<tau> \\<Turnstile> not A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not A", "have D : \"\\<tau> \\<Turnstile> \\<delta> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> \\<delta> B", "by(rule B[THEN OclNot_defargs])"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> \\<delta> B\n\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not A", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> not A", "apply(insert B,simp add: A D foundation9)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> |\\<noteq> B \\<Longrightarrow> \\<tau> |\\<noteq> A", "by(erule contrapos_nn, auto intro: C)"], ["proof (state)\nthis:\n  \\<tau> \\<Turnstile> not A\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection\\<open>A Side-calculus for Constant Terms\\<close>"], ["", "definition \"const X \\<equiv> \\<forall> \\<tau> \\<tau>'. X \\<tau> = X \\<tau>'\""], ["", "lemma const_charn: \"const X \\<Longrightarrow> X \\<tau> = X \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const X \\<Longrightarrow> X \\<tau> = X \\<tau>'", "by(auto simp: const_def)"], ["", "lemma const_subst:\n assumes const_X: \"const X\"\n     and const_Y: \"const Y\"\n     and eq :     \"X \\<tau> = Y \\<tau>\"\n     and cp_P:    \"cp P\"\n     and pp :     \"P Y \\<tau> = P Y \\<tau>'\"\n   shows \"P X \\<tau> = P X \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "have A: \"\\<And>Y. P Y \\<tau> = P (\\<lambda>_. Y \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. P Y \\<tau> = P (\\<lambda>_. Y \\<tau>) \\<tau>", "apply(insert cp_P, unfold cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<exists>f.\n          \\<forall>X \\<tau>.\n             P X \\<tau> = f (X \\<tau>) \\<tau> \\<Longrightarrow>\n       P Y \\<tau> = P (\\<lambda>_. Y \\<tau>) \\<tau>", "apply(elim exE, erule_tac x=Y in allE', erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y f.\n       \\<lbrakk>\\<forall>x \\<tau>. P x \\<tau> = f (x \\<tau>) \\<tau>;\n        P Y \\<tau> = f (Y \\<tau>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> P Y \\<tau> = P (\\<lambda>_. Y \\<tau>) \\<tau>", "apply(erule_tac x=\"(\\<lambda>_. Y \\<tau>)\" in allE, erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y f.\n       \\<lbrakk>P Y \\<tau> = f (Y \\<tau>) \\<tau>;\n        P (\\<lambda>_. Y \\<tau>) \\<tau> = f (Y \\<tau>) \\<tau>\\<rbrakk>\n       \\<Longrightarrow> P Y \\<tau> = P (\\<lambda>_. Y \\<tau>) \\<tau>", "by simp"], ["proof (state)\nthis:\n  P ?Y \\<tau> = P (\\<lambda>_. ?Y \\<tau>) \\<tau>\n\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "have B: \"\\<And>Y. P Y \\<tau>' = P (\\<lambda>_. Y \\<tau>') \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y. P Y \\<tau>' = P (\\<lambda>_. Y \\<tau>') \\<tau>'", "apply(insert cp_P, unfold cp_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       \\<exists>f.\n          \\<forall>X \\<tau>.\n             P X \\<tau> = f (X \\<tau>) \\<tau> \\<Longrightarrow>\n       P Y \\<tau>' = P (\\<lambda>_. Y \\<tau>') \\<tau>'", "apply(elim exE, erule_tac x=Y in allE', erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y f.\n       \\<lbrakk>\\<forall>x \\<tau>. P x \\<tau> = f (x \\<tau>) \\<tau>;\n        P Y \\<tau>' = f (Y \\<tau>') \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> P Y \\<tau>' = P (\\<lambda>_. Y \\<tau>') \\<tau>'", "apply(erule_tac x=\"(\\<lambda>_. Y \\<tau>')\" in allE, erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y f.\n       \\<lbrakk>P Y \\<tau>' = f (Y \\<tau>') \\<tau>';\n        P (\\<lambda>_. Y \\<tau>') \\<tau>' = f (Y \\<tau>') \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> P Y \\<tau>' = P (\\<lambda>_. Y \\<tau>') \\<tau>'", "by simp"], ["proof (state)\nthis:\n  P ?Y \\<tau>' = P (\\<lambda>_. ?Y \\<tau>') \\<tau>'\n\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "have C: \"X \\<tau>' = Y \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<tau>' = Y \\<tau>'", "apply(rule trans, subst const_charn[OF const_X],rule eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<tau> = Y \\<tau>'", "by(rule const_charn[OF const_Y])"], ["proof (state)\nthis:\n  X \\<tau>' = Y \\<tau>'\n\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. P X \\<tau> = P X \\<tau>'", "apply(subst A, subst B, simp add: eq C)"], ["proof (prove)\ngoal (1 subgoal):\n 1. P (\\<lambda>_. Y \\<tau>) \\<tau> = P (\\<lambda>_. Y \\<tau>') \\<tau>'", "apply(subst A[symmetric],subst B[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. P Y \\<tau> = P Y \\<tau>'", "by(simp add:pp)"], ["proof (state)\nthis:\n  P X \\<tau> = P X \\<tau>'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma const_imply2 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const P \\<Longrightarrow> const Q", "by(simp add: const_def, insert assms, blast)"], ["", "lemma const_imply3 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>' \\<Longrightarrow> R \\<tau> = R \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q \\<Longrightarrow> const R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>const P; const Q\\<rbrakk> \\<Longrightarrow> const R", "by(simp add: const_def, insert assms, blast)"], ["", "lemma const_imply4 :\n assumes \"\\<And>\\<tau> \\<tau>'. P \\<tau> = P \\<tau>' \\<Longrightarrow> Q \\<tau> = Q \\<tau>' \\<Longrightarrow> R \\<tau> = R \\<tau>' \\<Longrightarrow> S \\<tau> = S \\<tau>'\"\n shows \"const P \\<Longrightarrow> const Q \\<Longrightarrow> const R \\<Longrightarrow> const S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>const P; const Q; const R\\<rbrakk> \\<Longrightarrow> const S", "by(simp add: const_def, insert assms, blast)"], ["", "lemma const_lam : \"const (\\<lambda>_. e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (\\<lambda>_. e)", "by(simp add: const_def)"], ["", "lemma const_true[simp] : \"const true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const true", "by(simp add: const_def true_def)"], ["", "lemma const_false[simp] : \"const false\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const false", "by(simp add: const_def false_def)"], ["", "lemma const_null[simp] : \"const null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const null", "by(simp add: const_def null_fun_def)"], ["", "lemma const_invalid [simp]: \"const invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const invalid", "by(simp add: const_def invalid_def)"], ["", "lemma const_bot[simp] : \"const bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const UML_Types.bot_class.bot", "by(simp add: const_def bot_fun_def)"], ["", "lemma const_defined :\n assumes \"const X\"\n shows   \"const (\\<delta> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (\\<delta> X)", "by(rule const_imply2[OF _ assms],\n   simp add: defined_def false_def true_def bot_fun_def bot_option_def null_fun_def null_option_def)"], ["", "lemma const_valid :\n assumes \"const X\"\n shows   \"const (\\<upsilon> X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (\\<upsilon> X)", "by(rule const_imply2[OF _ assms],\n   simp add: valid_def false_def true_def bot_fun_def null_fun_def assms)"], ["", "lemma const_OclAnd :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X and X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (X and X')", "by(rule const_imply3[OF _ assms], subst (1 2) cp_OclAnd, simp add: assms OclAnd_def)"], ["", "lemma const_OclNot :\n    assumes \"const X\"\n    shows   \"const (not X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (not X)", "by(rule const_imply2[OF _ assms],subst cp_OclNot,simp add: assms OclNot_def)"], ["", "lemma const_OclOr :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X or X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (X or X')", "by(simp add: assms OclOr_def const_OclNot const_OclAnd)"], ["", "lemma const_OclImplies :\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const (X implies X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (X implies X')", "by(simp add: assms OclImplies_def const_OclNot const_OclOr)"], ["", "lemma const_StrongEq:\n  assumes \"const X\"\n  assumes \"const X'\"\n  shows   \"const(X \\<triangleq> X')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (X \\<triangleq> X')", "apply(simp only: StrongEq_def const_def, intro allI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lfloor>\\<lfloor>X \\<tau> = X' \\<tau>\\<rfloor>\\<rfloor> =\n       \\<lfloor>\\<lfloor>X \\<tau>' = X' \\<tau>'\\<rfloor>\\<rfloor>", "apply(subst assms(1)[THEN const_charn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lfloor>\\<lfloor>X (?\\<tau>'2 \\<tau> \\<tau>') =\n                         X' \\<tau>\\<rfloor>\\<rfloor> =\n       \\<lfloor>\\<lfloor>X \\<tau>' = X' \\<tau>'\\<rfloor>\\<rfloor>", "apply(subst assms(2)[THEN const_charn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lfloor>\\<lfloor>X (?\\<tau>''4 \\<tau> \\<tau> \\<tau>' \\<tau>') =\n                         X' (?\\<tau>'3 \\<tau> \\<tau>')\\<rfloor>\\<rfloor> =\n       \\<lfloor>\\<lfloor>X \\<tau>' = X' \\<tau>'\\<rfloor>\\<rfloor>", "by simp"], ["", "lemma const_OclIf :\n  assumes \"const B\"\n      and \"const C1\"\n      and \"const C2\"\n    shows \"const (if B then C1 else C2 endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (if B then C1 else C2 endif)", "apply(rule const_imply4[OF _ assms],\n       subst (1 2) cp_OclIf, simp only: OclIf_def cp_defined[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>B \\<tau> = B \\<tau>'; C1 \\<tau> = C1 \\<tau>';\n        C2 \\<tau> = C2 \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> (if (\\<delta> (\\<lambda>_. B \\<tau>')) \\<tau> =\n                             true \\<tau>\n                          then if B \\<tau>' = true \\<tau> then C1 \\<tau>'\n                               else C2 \\<tau>'\n                          else invalid \\<tau>) =\n                         (if (\\<delta> B) \\<tau>' = true \\<tau>'\n                          then if B \\<tau>' = true \\<tau>' then C1 \\<tau>'\n                               else C2 \\<tau>'\n                          else invalid \\<tau>')", "apply(simp add: const_defined[OF assms(1), simplified const_def, THEN spec, THEN spec]\n                 const_true[simplified const_def, THEN spec, THEN spec]\n                 assms[simplified const_def, THEN spec, THEN spec]\n                 const_invalid[simplified const_def, THEN spec, THEN spec])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       (B \\<tau>' = true \\<tau> \\<longrightarrow>\n        ((\\<delta> (\\<lambda>_. true \\<tau>')) \\<tau> =\n         true \\<tau> \\<longrightarrow>\n         (\\<delta> B) \\<tau>' \\<noteq> true \\<tau>' \\<longrightarrow>\n         C1 \\<tau>' = invalid \\<tau>') \\<and>\n        ((\\<delta> (\\<lambda>_. true \\<tau>')) \\<tau> \\<noteq>\n         true \\<tau> \\<longrightarrow>\n         (\\<delta> B) \\<tau>' = true \\<tau>' \\<longrightarrow>\n         invalid \\<tau> = C1 \\<tau>')) \\<and>\n       (B \\<tau>' \\<noteq> true \\<tau> \\<longrightarrow>\n        (B \\<tau>' = true \\<tau>' \\<longrightarrow>\n         ((\\<delta> (\\<lambda>_. true \\<tau>')) \\<tau> =\n          true \\<tau> \\<longrightarrow>\n          (\\<delta> B) \\<tau>' \\<noteq> true \\<tau>' \\<longrightarrow>\n          C1 \\<tau>' = invalid \\<tau>') \\<and>\n         ((\\<delta> (\\<lambda>_. true \\<tau>')) \\<tau> \\<noteq>\n          true \\<tau> \\<longrightarrow>\n          (\\<delta> B) \\<tau>' = true \\<tau>' \\<longrightarrow>\n          invalid \\<tau> = C1 \\<tau>')) \\<and>\n        (B \\<tau>' \\<noteq> true \\<tau>' \\<longrightarrow>\n         ((\\<delta> (\\<lambda>_. B \\<tau>')) \\<tau> =\n          true \\<tau> \\<longrightarrow>\n          (\\<delta> B) \\<tau>' \\<noteq> true \\<tau>' \\<longrightarrow>\n          C2 \\<tau>' = invalid \\<tau>') \\<and>\n         ((\\<delta> (\\<lambda>_. B \\<tau>')) \\<tau> \\<noteq>\n          true \\<tau> \\<longrightarrow>\n          (\\<delta> B) \\<tau>' = true \\<tau>' \\<longrightarrow>\n          invalid \\<tau> = C2 \\<tau>')))", "by (metis (no_types) bot_fun_def OclValid_def const_def const_true defined_def \n                 foundation16[THEN iffD1]  null_fun_def)"], ["", "lemma const_OclValid1:\n assumes \"const x\"\n shows   \"(\\<tau> \\<Turnstile> \\<delta> x) = (\\<tau>' \\<Turnstile> \\<delta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> x) = (\\<tau>' \\<Turnstile> \\<delta> x)", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<delta> x) \\<tau> = true \\<tau>) =\n    ((\\<delta> x) \\<tau>' = true \\<tau>')", "apply(subst const_defined[OF assms, THEN const_charn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<delta> x) ?\\<tau>' = true \\<tau>) =\n    ((\\<delta> x) \\<tau>' = true \\<tau>')", "by(simp add: true_def)"], ["", "lemma const_OclValid2:\n assumes \"const x\"\n shows   \"(\\<tau> \\<Turnstile> \\<upsilon> x) = (\\<tau>' \\<Turnstile> \\<upsilon> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<upsilon> x) = (\\<tau>' \\<Turnstile> \\<upsilon> x)", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<upsilon> x) \\<tau> = true \\<tau>) =\n    ((\\<upsilon> x) \\<tau>' = true \\<tau>')", "apply(subst const_valid[OF assms, THEN const_charn])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<upsilon> x) ?\\<tau>' = true \\<tau>) =\n    ((\\<upsilon> x) \\<tau>' = true \\<tau>')", "by(simp add: true_def)"], ["", "lemma const_HOL_if : \"const C \\<Longrightarrow> const D \\<Longrightarrow> const F \\<Longrightarrow> const (\\<lambda>\\<tau>. if C \\<tau> then D \\<tau> else F \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>const C; const D; const F\\<rbrakk>\n    \\<Longrightarrow> const\n                       (\\<lambda>\\<tau>.\n                           if C \\<tau> then D \\<tau> else F \\<tau>)", "by(auto simp: const_def)"], ["", "lemma const_HOL_and: \"const C \\<Longrightarrow> const D \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> \\<and> D \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>const C; const D\\<rbrakk>\n    \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> \\<and> D \\<tau>)", "by(auto simp: const_def)"], ["", "lemma const_HOL_eq : \"const C \\<Longrightarrow> const D \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> = D \\<tau>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>const C; const D\\<rbrakk>\n    \\<Longrightarrow> const (\\<lambda>\\<tau>. C \\<tau> = D \\<tau>)", "apply(auto simp: const_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau> = D \\<tau>\\<rbrakk>\n       \\<Longrightarrow> C \\<tau>' = D \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau> = D \\<tau>; \\<forall>\\<tau>'. C \\<tau> = C \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau>' = D \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau> = D \\<tau>; \\<forall>\\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau>'. D \\<tau> = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau>' = D \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau> = D \\<tau>; \\<forall>\\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau> = C \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau>' = D \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau> = D \\<tau>; C \\<tau> = C \\<tau>';\n        D \\<tau> = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau>' = D \\<tau>'\n 2. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>\\<forall>\\<tau> \\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau>' = D \\<tau>';\n        \\<forall>\\<tau>'. C \\<tau> = C \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau> in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau>' = D \\<tau>';\n        \\<forall>\\<tau>'. C \\<tau> = C \\<tau>';\n        \\<forall>\\<tau>'. D \\<tau> = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau>' = D \\<tau>';\n        \\<forall>\\<tau>'. D \\<tau> = D \\<tau>';\n        C \\<tau> = C \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "apply(erule_tac x=\\<tau>' in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> \\<tau>'.\n       \\<lbrakk>C \\<tau>' = D \\<tau>'; C \\<tau> = C \\<tau>';\n        D \\<tau> = D \\<tau>'\\<rbrakk>\n       \\<Longrightarrow> C \\<tau> = D \\<tau>", "by simp"], ["", "lemmas const_ss = const_bot const_null  const_invalid  const_false  const_true  const_lam\n                  const_defined const_valid const_StrongEq const_OclNot const_OclAnd\n                  const_OclOr const_OclImplies const_OclIf\n                  const_HOL_if const_HOL_and const_HOL_eq"], ["", "text\\<open>Miscellaneous: Overloading the syntax of ``bottom''\\<close>"], ["", "notation bot (\"\\<bottom>\")"], ["", "end"]]}