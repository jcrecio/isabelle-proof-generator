{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_Types.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma textbook_invalid: \"I\\<lbrakk>invalid\\<rbrakk>\\<tau> = bot\"", "lemma textbook_null_fun: \"I\\<lbrakk>null::('\\<AA>,'\\<alpha>::null) val\\<rbrakk> \\<tau> = (null::('\\<alpha>::null))\""], "translations": [["", "lemma textbook_invalid: \"I\\<lbrakk>invalid\\<rbrakk>\\<tau> = bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>invalid\\<rbrakk> \\<tau> = UML_Types.bot_class.bot", "by(simp add: invalid_def Sem_def)"], ["", "text \\<open>Note that the definition :\n{\\small\n\\begin{isar}[mathescape]\ndefinition null    :: \"('$\\mathfrak{A}$,'\\<alpha>::null) val\"\nwhere     \"null    \\<equiv> \\<lambda> \\<tau>. null\"\n\\end{isar}\n} is not  necessary since we defined the entire function space over null types\nagain as null-types; the crucial definition is @{thm \"null_fun_def\"}.\nThus, the polymorphic constant @{const null} is simply the result of\na general type class construction. Nevertheless, we can derive the\nsemantic textbook definition for the OCL null constant based on the\nabstract null:\n\\<close>"], ["", "lemma textbook_null_fun: \"I\\<lbrakk>null::('\\<AA>,'\\<alpha>::null) val\\<rbrakk> \\<tau> = (null::('\\<alpha>::null))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I\\<lbrakk>null\\<rbrakk> \\<tau> = null", "by(simp add: null_fun_def Sem_def)"], ["", "section\\<open>Basic OCL Value Types\\<close>"], ["", "text \\<open>The structure of this section roughly follows the structure of Chapter\n11 of the OCL standard~\\cite{omg:ocl:2012}, which introduces the OCL\nLibrary.\\<close>"], ["", "text\\<open>The semantic domain of the (basic) boolean type is now defined as the Standard:\nthe space of valuation to @{typ \"bool option option\"}, \\ie{} the Boolean base type:\\<close>"], ["", "type_synonym Boolean\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  = \"bool option option\""], ["", "type_synonym ('\\<AA>)Boolean = \"('\\<AA>,Boolean\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "text\\<open>Because of the previous class definitions, Isabelle type-inference establishes that\n@{typ \"('\\<AA>)Boolean\"} lives actually both in the type class @{term bot} and @{term null};\nthis type is sufficiently rich to contain at least these two elements.\nAnalogously we build:\\<close>"], ["", "type_synonym Integer\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  = \"int option option\""], ["", "type_synonym ('\\<AA>)Integer = \"('\\<AA>,Integer\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_synonym String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  = \"string option option\""], ["", "type_synonym ('\\<AA>)String = \"('\\<AA>,String\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_synonym Real\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e = \"real option option\""], ["", "type_synonym ('\\<AA>)Real = \"('\\<AA>,Real\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "text\\<open>Since @{term \"Real\"} is again a basic type, we define its semantic domain\nas the valuations over \\<open>real option option\\<close> --- i.e. the mathematical type of real numbers.\nThe HOL-theory for \\<open>real\\<close> ``Real'' transcendental numbers such as $\\pi$ and $e$ as well as\ninfrastructure to reason over infinite convergent Cauchy-sequences (it is thus possible, in principle,\nto reason in Featherweight OCL that the sum of inverted two-s exponentials is actually 2.\n\nIf needed, a code-generator to compile \\<open>Real\\<close> to floating-point\nnumbers can be added; this allows for mapping reals to an efficient machine representation;\nof course, this feature would be logically unsafe.\\<close>"], ["", "text\\<open>For technical reasons related to the Isabelle type inference for type-classes\n(we don't get the properties in the right order that class instantiation provides them,\nif we would follow the previous scheme), we give a slightly atypic definition:\\<close>"], ["", "typedef Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e = \"{X::unit option option. X = bot \\<or> X = null }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> {X. X = UML_Types.bot_class.bot \\<or> X = null}", "by(rule_tac x=\"bot\" in exI, simp)"], ["", "type_synonym ('\\<AA>)Void = \"('\\<AA>,Void\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "section\\<open>Some OCL Collection Types\\<close>"], ["", "text\\<open>For the semantic construction of the collection types, we have two goals:\n\\begin{enumerate}\n\\item we want the types to be \\emph{fully abstract}, \\ie, the type should not\n      contain junk-elements that are not representable by OCL expressions, and\n\\item we want a possibility to nest collection types (so, we want the\n      potential of talking about \\<open>Set(Set(Sequences(Pairs(X,Y))))\\<close>).\n\\end{enumerate}\nThe former principle rules out the option to define \\<open>'\\<alpha> Set\\<close> just by\n \\<open>('\\<AA>, ('\\<alpha> option option) set) val\\<close>. This would allow sets to contain\njunk elements such as \\<open>{\\<bottom>}\\<close> which we need to identify with undefinedness\nitself. Abandoning fully abstractness of rules would later on produce all sorts\nof problems when quantifying over the elements of a type.\nHowever, if we build an own type, then it must conform to our abstract interface\nin order to have nested types: arguments of type-constructors must conform to our\nabstract interface, and the result type too.\n\\<close>"], ["", "subsection\\<open>The Construction of the Pair Type (Tuples)\\<close>"], ["", "text\\<open>The core of an own type construction is done via a type\n  definition which provides the base-type \\<open>('\\<alpha>, '\\<beta>) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<close>. It\n  is shown that this type ``fits'' indeed into the abstract type\n  interface discussed in the previous section.\\<close>"], ["", "typedef (overloaded) ('\\<alpha>, '\\<beta>) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e = \"{X::('\\<alpha>::null \\<times> '\\<beta>::null) option option.\n                                           X = bot \\<or> X = null \\<or> (fst\\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<noteq> bot \\<and> snd\\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<noteq> bot)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {X. X = UML_Types.bot_class.bot \\<or>\n                   X = null \\<or>\n                   fst \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<noteq>\n                   UML_Types.bot_class.bot \\<and>\n                   snd \\<lceil>\\<lceil>X\\<rceil>\\<rceil> \\<noteq>\n                   UML_Types.bot_class.bot}", "by (rule_tac x=\"bot\" in exI, simp)"], ["", "text\\<open>We ``carve'' out from the concrete type @{typ \"('\\<alpha>::null \\<times> '\\<beta>::null) option option\"} \nthe new fully abstract type, which will not contain representations like @{term \"\\<lfloor>\\<lfloor>(\\<bottom>,a)\\<rfloor>\\<rfloor>\"}\nor @{term \"\\<lfloor>\\<lfloor>(b,\\<bottom>)\\<rfloor>\\<rfloor>\"}. The type constuctor \\<open>Pair{x,y}\\<close> to be defined later will\nidentify these with @{term \"invalid\"}.\n\\<close>"], ["", "instantiation   Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null,null)bot\nbegin"], ["", "definition bot_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(bot_class.bot :: ('a::null,'b::null) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     (('a, 'b) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, UML_Types.bot_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "show \"\\<exists>x::('a,'b) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e. x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "apply(rule_tac x=\"Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<bottom>\\<rfloor> \\<noteq>\n    UML_Types.bot_class.bot", "by(simp add: bot_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def  Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject  null_option_def bot_option_def)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation   Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null,null)null\nbegin"], ["", "definition null_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(null::('a::null,'b::null) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor> None \\<rfloor>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(('a, 'b) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, null_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "show \"(null::('a::null,'b::null) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "by(simp add: bot_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                               null_option_def bot_option_def)"], ["proof (state)\nthis:\n  null \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>...  and lifting this type to the format of a valuation gives us:\\<close>"], ["", "type_synonym    ('\\<AA>,'\\<alpha>,'\\<beta>) Pair  = \"('\\<AA>, ('\\<alpha>,'\\<beta>) Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_notation   Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (\"Pair'(_,_')\")"], ["", "subsection\\<open>The Construction of the Set Type\\<close>"], ["", "text\\<open>The core of an own type construction is done via a type\n  definition which provides the raw-type \\<open>'\\<alpha> Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<close>. It\n  is shown that this type ``fits'' indeed into the abstract type\n  interface discussed in the previous section. Note that we make \n  no restriction whatsoever to \\emph{finite} sets; while with \n  the standards type-constructors only finite sets can be denoted,\n  there is the possibility to define in fact infinite \n  type constructors in \\FOCL (c.f. \\autoref{sec:type-extensions}).\\<close>"], ["", "typedef (overloaded) '\\<alpha> Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e =\"{X::('\\<alpha>::null) set option option. X = bot \\<or> X = null \\<or> (\\<forall>x\\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>. x \\<noteq> bot)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {X. X = UML_Types.bot_class.bot \\<or>\n                   X = null \\<or>\n                   (\\<forall>x\\<in>\\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n                       x \\<noteq> UML_Types.bot_class.bot)}", "by (rule_tac x=\"bot\" in exI, simp)"], ["", "instantiation   Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)bot\nbegin"], ["", "definition bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(bot::('a::null) Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, UML_Types.bot_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "show \"\\<exists>x::'a Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e. x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "apply(rule_tac x=\"Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<bottom>\\<rfloor> \\<noteq>\n    UML_Types.bot_class.bot", "by(simp add: bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject null_option_def bot_option_def)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation   Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)null\nbegin"], ["", "definition null_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(null::('a::null) Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor> None \\<rfloor>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, null_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "show \"(null::('a::null) Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "by(simp add:null_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                              null_option_def bot_option_def)"], ["proof (state)\nthis:\n  null \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>...  and lifting this type to the format of a valuation gives us:\\<close>"], ["", "type_synonym    ('\\<AA>,'\\<alpha>) Set  = \"('\\<AA>, '\\<alpha> Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_notation   Set\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (\"Set'(_')\")"], ["", "subsection\\<open>The Construction of the Bag Type\\<close>"], ["", "text\\<open>The core of an own type construction is done via a type\n  definition which provides the raw-type \\<open>'\\<alpha> Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<close>\n  based on multi-sets from the \\HOL library. As in Sets, it\n  is shown that this type ``fits'' indeed into the abstract type\n  interface discussed in the previous section, and as in sets, we make \n  no restriction whatsoever to \\emph{finite} multi-sets; while with \n  the standards type-constructors only finite sets can be denoted,\n  there is the possibility to define in fact infinite \n  type constructors in \\FOCL (c.f. \\autoref{sec:type-extensions}). \n  However, while several \\<open>null\\<close> elements are possible in a Bag, there\n  can't be no bottom (invalid) element in them.\n\\<close>"], ["", "typedef (overloaded) '\\<alpha> Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e =\"{X::('\\<alpha>::null \\<Rightarrow> nat) option option. X = bot \\<or> X = null \\<or> \\<lceil>\\<lceil>X\\<rceil>\\<rceil> bot = 0 }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {X. X = UML_Types.bot_class.bot \\<or>\n                   X = null \\<or>\n                   \\<lceil>\\<lceil>X\\<rceil>\\<rceil>\n                    UML_Types.bot_class.bot =\n                   0}", "by (rule_tac x=\"bot\" in exI, simp)"], ["", "instantiation   Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)bot\nbegin"], ["", "definition bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(bot::('a::null) Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, UML_Types.bot_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "show \"\\<exists>x::'a Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e. x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "apply(rule_tac x=\"Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<bottom>\\<rfloor> \\<noteq>\n    UML_Types.bot_class.bot", "by(simp add: bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                               null_option_def bot_option_def)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation   Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)null\nbegin"], ["", "definition null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(null::('a::null) Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor> None \\<rfloor>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, null_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "show \"(null::('a::null) Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "by(simp add:null_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def bot_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                              null_option_def bot_option_def)"], ["proof (state)\nthis:\n  null \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>...  and lifting this type to the format of a valuation gives us:\\<close>"], ["", "type_synonym    ('\\<AA>,'\\<alpha>) Bag  = \"('\\<AA>, '\\<alpha> Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_notation   Bag\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (\"Bag'(_')\")"], ["", "subsection\\<open>The Construction of the Sequence Type\\<close>"], ["", "text\\<open>The core of an own type construction is done via a type\n  definition which provides the base-type \\<open>'\\<alpha> Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\\<close>. It\n  is shown that this type ``fits'' indeed into the abstract type\n  interface discussed in the previous section.\\<close>"], ["", "typedef (overloaded) '\\<alpha> Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e =\"{X::('\\<alpha>::null) list option option.\n                                        X = bot \\<or> X = null \\<or> (\\<forall>x\\<in>set \\<lceil>\\<lceil>X\\<rceil>\\<rceil>. x \\<noteq> bot)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x.\n       x \\<in> {X. X = UML_Types.bot_class.bot \\<or>\n                   X = null \\<or>\n                   (\\<forall>x\\<in>set \\<lceil>\\<lceil>X\\<rceil>\\<rceil>.\n                       x \\<noteq> UML_Types.bot_class.bot)}", "by (rule_tac x=\"bot\" in exI, simp)"], ["", "instantiation   Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)bot\nbegin"], ["", "definition bot_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(bot::('a::null) Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e None\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS\n     ('a Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, UML_Types.bot_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "show \"\\<exists>x::'a Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e. x \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<noteq> UML_Types.bot_class.bot", "apply(rule_tac x=\"Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor>None\\<rfloor>\" in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e\n     \\<lfloor>\\<bottom>\\<rfloor> \\<noteq>\n    UML_Types.bot_class.bot", "by(auto simp:bot_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                               null_option_def bot_option_def)"], ["proof (state)\nthis:\n  \\<exists>x. x \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instantiation   Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e  :: (null)null\nbegin"], ["", "definition null_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def: \"(null::('a::null) Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<equiv> Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e \\<lfloor> None \\<rfloor>\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, null_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "show \"(null::('a::null) Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) \\<noteq> bot\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null \\<noteq> UML_Types.bot_class.bot", "by(auto simp:bot_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def null_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_def Abs_Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e_inject \n                               null_option_def bot_option_def)"], ["proof (state)\nthis:\n  null \\<noteq> UML_Types.bot_class.bot\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>...  and lifting this type to the format of a valuation gives us:\\<close>"], ["", "type_synonym    ('\\<AA>,'\\<alpha>) Sequence  = \"('\\<AA>, '\\<alpha> Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e) val\""], ["", "type_notation   Sequence\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e (\"Sequence'(_')\")"], ["", "subsection\\<open>Discussion: The Representation of UML/OCL Types in Featherweight OCL\\<close>"], ["", "text\\<open>In the introduction, we mentioned that there is an ``injective representation\nmapping'' between the types of OCL and the types of Featherweight OCL (and its \nmeta-language: HOL). This injectivity is at the heart of our representation technique\n--- a so-called \\emph{shallow embedding} --- and means: OCL types were mapped one-to-one\nto types in HOL, ruling out a resentation where\neverything is mapped on some common HOL-type, say ``OCL-expression'', in which we \nwould have to sort out the typing of OCL and its impact on the semantic representation\nfunction in an own, quite heavy side-calculus.\n\\<close>"], ["", "text\\<open>After the previous sections, we are now able to exemplify this representation as follows:\n\n\\begin{table}[htbp]\n   \\centering\n   \\begin{tabu}{lX[,c,]}\n      \\toprule\n      OCL Type & HOL Type \\\\\n      \\midrule \n      \\inlineocl|Boolean|  & @{typ  \"('\\<AA>)Boolean\"} \\\\\n      \\inlineocl|Boolean -> Boolean| & @{typ  \"('\\<AA>)Boolean \\<Rightarrow> ('\\<AA>)Boolean\"} \\\\\n      \\inlineocl|(Integer,Integer) -> Boolean| & @{typ  \"('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Integer \\<Rightarrow> ('\\<AA>)Boolean\"} \\\\\n      \\inlineocl|Set(Integer)| & @{typ \"('\\<AA>,Integer\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e)Set\"} \\\\\n      \\inlineocl|Set(Integer)-> Real| & @{typ \"('\\<AA>,Integer\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e)Set \\<Rightarrow> ('\\<AA>)Real\"} \\\\\n      \\inlineocl|Set(Pair(Integer,Boolean))| & @{typ \"('\\<AA>,(Integer\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e, Boolean\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e)Pair\\<^sub>b\\<^sub>a\\<^sub>s\\<^sub>e)Set\"} \\\\\n      \\inlineocl|Set(<T>)| & @{typ \"('\\<AA>,'\\<alpha>::null)Set\"} \\\\\n      \\bottomrule\n   \\end{tabu}\n   \\caption{Correspondance between \\OCL types and \\HOL types}\n   \\label{tab:types}\n\\end{table}\nWe do not formalize the representation map here; however, its principles are quite straight-forward:\n\\begin{enumerate}\n\\item cartesion products of arguments were curried,\n\\item constants of type \\inlineocl{T} were mapped to valuations over the\n      HOL-type for \\inlineocl{T},\n\\item functions \\inlineocl{T -> T'} were mapped to functions in HOL, where\n      \\inlineocl{T} and  \\inlineocl{T'}  were mapped to the valuations for them, and\n\\item the arguments of type constructors  \\inlineocl{Set(T)} remain corresponding HOL base-types.\n\\end{enumerate}\n      \n\\<close>"], ["", "text\\<open>Note, furthermore, that our construction of ``fully abstract types'' (no junk, no confusion)\nassures that the logical equality to be defined in the next section works correctly and comes\nas element of the ``lingua franca'', \\ie{} HOL.\\<close>"], ["", "(*<*)"], ["", "section\\<open>Miscelleaneous: ML assertions\\<close>"], ["", "text\\<open>We introduce here a new command \\emph{Assert} similar as \\emph{value} for proving\n that the given term in argument is a true proposition. The difference with \\emph{value} is that\n\\emph{Assert} fails if the normal form of the term evaluated is not equal to @{term True}. \nMoreover, in case \\emph{value} could not normalize the given term, as another strategy of reduction\n we try to prove it with a single ``simp'' tactic.\\<close>"], ["", "ML\\<open>\nfun disp_msg title msg status = title ^ \": '\" ^ msg ^ \"' \" ^ status\n\nfun lemma msg specification_theorem concl in_local thy =\n  SOME\n    (in_local (fn lthy =>\n           specification_theorem Thm.theoremK NONE (K I) Binding.empty_atts [] [] \n             (Element.Shows [(Binding.empty_atts, [(concl lthy, [])])])\n             false lthy\n        |> Proof.global_terminal_proof\n             ((Method.Combinator ( Method.no_combinator_info\n                                 , Method.Then\n                                 , [Method.Basic (fn ctxt => SIMPLE_METHOD (asm_full_simp_tac ctxt 1))]),\n               (Position.none, Position.none)), NONE))\n              thy)\n  handle ERROR s =>\n    (warning s; writeln (disp_msg \"KO\" msg \"failed to normalize\"); NONE)\n\nfun outer_syntax_command command_spec theory in_local =\n  Outer_Syntax.command command_spec \"assert that the given specification is true\"\n    (Parse.term >> (fn elems_concl => theory (fn thy =>\n      case\n        lemma \"nbe\" (Specification.theorem true)\n          (fn lthy => \n            let val expr = Nbe.dynamic_value lthy (Syntax.read_term lthy elems_concl)\n                val thy = Proof_Context.theory_of lthy\n                open HOLogic in\n            if Sign.typ_equiv thy (fastype_of expr, @{typ \"prop\"}) then\n              expr\n            else mk_Trueprop (mk_eq (@{term \"True\"}, expr))\n            end)\n          in_local\n          thy\n      of  NONE => \n            let val attr_simp = \"simp\" in\n            case lemma attr_simp (Specification.theorem_cmd true) (K elems_concl) in_local thy of\n               NONE => raise (ERROR \"Assertion failed\")\n             | SOME thy => \n                (writeln (disp_msg \"OK\" \"simp\" \"finished the normalization\");\n                 thy)\n            end\n        | SOME thy => thy)))\n\nval () = outer_syntax_command @{command_keyword Assert} Toplevel.theory Named_Target.theory_map\nval () = outer_syntax_command @{command_keyword Assert_local} (Toplevel.local_theory NONE NONE) I\n\\<close>"], ["", "(*>*)"], ["", "end"]]}