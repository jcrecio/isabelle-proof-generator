{"file_name": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL/UML_PropertyProfiles.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Featherweight_OCL", "problem_names": ["lemma strict[simp,code_unfold]: \" f invalid = invalid\"", "lemma null_strict[simp,code_unfold]: \" f null = invalid\"", "lemma cp0 : \"f X \\<tau> = f (\\<lambda> _. X \\<tau>) \\<tau>\"", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X) )\"", "lemma strict[simp,code_unfold]: \" f invalid = invalid\"", "lemma cp0 : \"f X \\<tau> = f (\\<lambda> _. X \\<tau>) \\<tau>\"", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X) )\"", "lemma const[simp,code_unfold] : \n          assumes C1 :\"const X\"\n          shows       \"const(f X)\"", "lemma def_homo[simp,code_unfold]: \"\\<delta>(f x) = (\\<delta> x)\"", "lemma def_valid_then_def: \"\\<upsilon>(f x) = (\\<delta>(f x))\"", "lemmas [simp,code_unfold] = bin'_def bin_def", "lemma strict1[simp,code_unfold]: \" f invalid y = invalid\"", "lemma strict2[simp,code_unfold]: \" f x invalid = invalid\"", "lemma cp0 : \"f X Y \\<tau> = f (\\<lambda> _. X \\<tau>) (\\<lambda> _. Y \\<tau>) \\<tau>\"", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X))\"", "lemma def_homo[simp,code_unfold]: \"\\<delta>(f x y) = (d\\<^sub>x x and d\\<^sub>y y)\"", "lemma def_valid_then_def: \"\\<upsilon>(f x y) = (\\<delta>(f x y))\"", "lemma defined_args_valid: \"(\\<tau> \\<Turnstile> \\<delta> (f x y)) = ((\\<tau> \\<Turnstile> d\\<^sub>x x) \\<and> (\\<tau> \\<Turnstile> d\\<^sub>y y))\"", "lemma const[simp,code_unfold] : \n          assumes C1 :\"const X\" and C2 : \"const Y\"\n          shows       \"const(f X Y)\"", "lemma strict3[simp,code_unfold]: \" f null y = invalid\"", "lemma strict4[simp,code_unfold]: \" f x null = invalid\"", "lemma idem[simp,code_unfold]: \" f null null = true\"", "lemma defargs: \"\\<tau> \\<Turnstile> f x y \\<Longrightarrow> (\\<tau> \\<Turnstile> \\<upsilon> x) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> y)\"", "lemma defined_args_valid' : \"\\<delta> (f x y) = (\\<upsilon> x and \\<upsilon> y)\"", "lemma refl_ext[simp,code_unfold] : \"(f x x) = (if (\\<upsilon> x) then true else invalid endif)\"", "lemma sym : \"\\<tau> \\<Turnstile> (f x y) \\<Longrightarrow> \\<tau> \\<Turnstile> (f y x)\"", "lemma symmetric : \"(f x y) = (f y x)\"", "lemma trans : \"\\<tau> \\<Turnstile> (f x y) \\<Longrightarrow> \\<tau> \\<Turnstile> (f y z) \\<Longrightarrow> \\<tau> \\<Turnstile> (f x z)\"", "lemma StrictRefEq_vs_StrongEq: \"\\<tau> \\<Turnstile>(\\<upsilon> x) \\<Longrightarrow> \\<tau> \\<Turnstile>(\\<upsilon> y) \\<Longrightarrow> (\\<tau> \\<Turnstile> ((f x y) \\<triangleq> (x \\<triangleq> y)))\""], "translations": [["", "lemma strict[simp,code_unfold]: \" f invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid = invalid", "by(rule ext, simp add: def_scheme true_def false_def)"], ["", "lemma null_strict[simp,code_unfold]: \" f null = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null = invalid", "by(rule ext, simp add: def_scheme true_def false_def)"], ["", "lemma cp0 : \"f X \\<tau> = f (\\<lambda> _. X \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f X \\<tau> = f (\\<lambda>_. X \\<tau>) \\<tau>", "by(simp add: def_scheme  cp_defined[symmetric])"], ["", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X))", "by(rule cpI1[of \"f\"], intro allI, rule cp0, simp_all)"], ["", "end"], ["", "locale profile_mono_schemeV =\n   fixes f :: \"('\\<AA>,'\\<alpha>::null)val \\<Rightarrow> ('\\<AA>,'\\<beta>::null)val\"\n   fixes g\n   assumes def_scheme: \"(f x) \\<equiv> \\<lambda> \\<tau>. if (\\<upsilon> x) \\<tau> = true \\<tau> then g (x \\<tau>) else invalid \\<tau>\"\nbegin"], ["", "lemma strict[simp,code_unfold]: \" f invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid = invalid", "by(rule ext, simp add: def_scheme true_def false_def)"], ["", "lemma cp0 : \"f X \\<tau> = f (\\<lambda> _. X \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f X \\<tau> = f (\\<lambda>_. X \\<tau>) \\<tau>", "by(simp add: def_scheme  cp_valid[symmetric])"], ["", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X) )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cp P \\<Longrightarrow> cp (\\<lambda>X. f (P X))", "by(rule cpI1[of \"f\"], intro allI, rule cp0, simp_all)"], ["", "end"], ["", "locale profile_mono\\<^sub>d = profile_mono_scheme_defined +\n   assumes \"\\<And> x. x \\<noteq> bot \\<Longrightarrow> x \\<noteq> null \\<Longrightarrow> g x \\<noteq> bot\"\nbegin"], ["", "lemma const[simp,code_unfold] : \n          assumes C1 :\"const X\"\n          shows       \"const(f X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (f X)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. const (f X)", "have const_g : \"const (\\<lambda>\\<tau>. g (X \\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (\\<lambda>\\<tau>. g (X \\<tau>))", "by(insert C1, auto simp:const_def, metis)"], ["proof (state)\nthis:\n  const (\\<lambda>\\<tau>. g (X \\<tau>))\n\ngoal (1 subgoal):\n 1. const (f X)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. const (f X)", "by(simp_all add : def_scheme const_ss C1 const_g)"], ["proof (state)\nthis:\n  const (f X)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale profile_mono0 = profile_mono_scheme_defined +\n   assumes def_body:  \"\\<And> x. x \\<noteq> bot \\<Longrightarrow> x \\<noteq> null \\<Longrightarrow> g x \\<noteq> bot \\<and> g x \\<noteq> null\""], ["", "sublocale profile_mono0 < profile_mono\\<^sub>d"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_mono\\<^sub>d f g", "by(unfold_locales, simp add: def_scheme, simp add: def_body)"], ["", "context profile_mono0\nbegin"], ["", "lemma def_homo[simp,code_unfold]: \"\\<delta>(f x) = (\\<delta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> f x = \\<delta> x", "apply(rule ext, rename_tac \"\\<tau>\",subst foundation22[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>. \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x", "apply(case_tac \"\\<not>(\\<tau> \\<Turnstile> \\<delta> x)\", simp add:defined_split, elim disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x\n 2. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> null \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x\n 3. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x", "apply(erule StrongEq_L_subst2_rev, simp,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> null \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x\n 2. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x", "apply(erule StrongEq_L_subst2_rev, simp,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> \\<delta> x", "apply(rule foundation13[THEN iffD2,THEN StrongEq_L_subst2_rev, where y =\"\\<delta> x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> x\n 2. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       cp ((\\<triangleq>) (\\<delta> f x))\n 3. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<delta> f x \\<triangleq> true", "apply(simp_all add:def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<delta> (\\<lambda>a.\n                                  if (\\<delta> x) a = true a then g (x a)\n                                  else invalid a) \\<triangleq>\n                     true", "apply(simp add: OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<delta> x) \\<tau> = true \\<tau> \\<Longrightarrow>\n       (\\<delta> (\\<lambda>a.\n                     if (\\<delta> x) a = true a then g (x a)\n                     else invalid a) \\<triangleq>\n        true)\n        \\<tau> =\n       true \\<tau>", "by(auto simp:foundation13 StrongEq_def false_def true_def defined_def bot_fun_def null_fun_def def_body\n           split: if_split_asm)"], ["", "lemma def_valid_then_def: \"\\<upsilon>(f x) = (\\<delta>(f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> f x = \\<delta> f x", "apply(rule ext, rename_tac \"\\<tau>\",subst foundation22[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> f x", "apply(case_tac \"\\<not>(\\<tau> \\<Turnstile> \\<delta> x)\", simp add:defined_split, elim disjE)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> invalid \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> x\n 2. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> null \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> x\n 3. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> f x", "apply(erule StrongEq_L_subst2_rev, simp,simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> x \\<triangleq> null \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> x\n 2. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> f x", "apply(erule StrongEq_L_subst2_rev, simp,simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> f x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau> \\<Turnstile> \\<upsilon> f x \\<triangleq> \\<delta> x", "apply(simp_all add:def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau> \\<Turnstile> \\<delta> x \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<upsilon> (\\<lambda>\\<tau>.\n                                    if (\\<delta> x) \\<tau> = true \\<tau>\n                                    then g (x \\<tau>)\n                                    else invalid \\<tau>) \\<triangleq>\n                     \\<delta> x", "apply(simp add: OclValid_def valid_def, subst cp_StrongEq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<delta> x) \\<tau> = true \\<tau> \\<Longrightarrow>\n       ((\\<lambda>_.\n            if (if (\\<delta> x) \\<tau> = true \\<tau> then g (x \\<tau>)\n                else invalid \\<tau>) =\n               \\<bottom> \\<tau>\n            then false \\<tau> else true \\<tau>) \\<triangleq>\n        (\\<lambda>_. (\\<delta> x) \\<tau>))\n        \\<tau> =\n       true \\<tau>", "apply(subst (2) cp_defined, simp, simp add: cp_defined[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       (\\<delta> x) \\<tau> = true \\<tau> \\<Longrightarrow>\n       g (x \\<tau>) = \\<bottom> \\<tau> \\<longrightarrow>\n       ((\\<lambda>_. false \\<tau>) \\<triangleq> (\\<lambda>_. true \\<tau>))\n        \\<tau> =\n       true \\<tau>", "by(auto simp:foundation13 StrongEq_def false_def true_def defined_def bot_fun_def null_fun_def def_body\n           split: if_split_asm)"], ["", "end"], ["", "subsection\\<open>Property Profiles for Single\\<close>"], ["", "locale profile_single =\n   fixes d:: \"('\\<AA>,'a::null)val \\<Rightarrow> '\\<AA> Boolean\"\n   assumes d_strict[simp,code_unfold]: \"d invalid = false\"\n   assumes d_cp0: \"d X \\<tau> = d (\\<lambda> _. X \\<tau>) \\<tau>\"\n   assumes d_const[simp,code_unfold]: \"const X \\<Longrightarrow> const (d X)\""], ["", "subsection\\<open>Property Profiles for Binary Operators\\<close>"], ["", "definition \"bin' f g d\\<^sub>x d\\<^sub>y X Y =\n                       (f X Y = (\\<lambda> \\<tau>. if (d\\<^sub>x X) \\<tau> = true \\<tau> \\<and> (d\\<^sub>y Y) \\<tau> = true \\<tau>\n                                      then g X Y \\<tau>\n                                      else invalid \\<tau> ))\""], ["", "definition \"bin f g = bin' f (\\<lambda>X Y \\<tau>. g (X \\<tau>) (Y \\<tau>))\""], ["", "lemmas [simp,code_unfold] = bin'_def bin_def"], ["", "locale profile_bin_scheme =\n   fixes d\\<^sub>x:: \"('\\<AA>,'a::null)val \\<Rightarrow> '\\<AA> Boolean\"\n   fixes d\\<^sub>y:: \"('\\<AA>,'b::null)val \\<Rightarrow> '\\<AA> Boolean\"\n   fixes f::\"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>,'b::null)val \\<Rightarrow> ('\\<AA>,'c::null)val\"\n   fixes g\n   assumes d\\<^sub>x' : \"profile_single d\\<^sub>x\"\n   assumes d\\<^sub>y' : \"profile_single d\\<^sub>y\"\n   assumes d\\<^sub>x_d\\<^sub>y_homo[simp,code_unfold]: \"cp (f X) \\<Longrightarrow> \n                          cp (\\<lambda>x. f x Y) \\<Longrightarrow> \n                          f X invalid = invalid \\<Longrightarrow>\n                          f invalid Y = invalid \\<Longrightarrow>\n                          (\\<not> (\\<tau> \\<Turnstile> d\\<^sub>x X) \\<or> \\<not> (\\<tau> \\<Turnstile> d\\<^sub>y Y)) \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> (\\<delta> f X Y \\<triangleq> (d\\<^sub>x X and d\\<^sub>y Y))\"\n   assumes def_scheme''[simplified]: \"bin f g d\\<^sub>x d\\<^sub>y X Y\"\n   assumes 1: \"\\<tau> \\<Turnstile> d\\<^sub>x X \\<Longrightarrow> \\<tau> \\<Turnstile> d\\<^sub>y Y \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y\"\nbegin"], ["", "interpretation d\\<^sub>x : profile_single d\\<^sub>x"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_single d\\<^sub>x", "by (rule d\\<^sub>x')"], ["", "interpretation d\\<^sub>y : profile_single d\\<^sub>y"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_single d\\<^sub>y", "by (rule d\\<^sub>y')"], ["", "lemma strict1[simp,code_unfold]: \" f invalid y = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f invalid y = invalid", "by(rule ext, simp add: def_scheme'' true_def false_def)"], ["", "lemma strict2[simp,code_unfold]: \" f x invalid = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x invalid = invalid", "by(rule ext, simp add: def_scheme'' true_def false_def)"], ["", "lemma cp0 : \"f X Y \\<tau> = f (\\<lambda> _. X \\<tau>) (\\<lambda> _. Y \\<tau>) \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f X Y \\<tau> = f (\\<lambda>_. X \\<tau>) (\\<lambda>_. Y \\<tau>) \\<tau>", "by(simp add: def_scheme'' d\\<^sub>x.d_cp0[symmetric] d\\<^sub>y.d_cp0[symmetric] cp_defined[symmetric])"], ["", "lemma cp[simp,code_unfold] : \" cp P \\<Longrightarrow> cp Q \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cp P; cp Q\\<rbrakk>\n    \\<Longrightarrow> cp (\\<lambda>X. f (P X) (Q X))", "by(rule cpI2[of \"f\"], intro allI, rule cp0, simp_all)"], ["", "lemma def_homo[simp,code_unfold]: \"\\<delta>(f x y) = (d\\<^sub>x x and d\\<^sub>y y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> f x y = (d\\<^sub>x x and d\\<^sub>y y)", "apply(rule ext, rename_tac \"\\<tau>\",subst foundation22[symmetric])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<tau>\n        \\<Turnstile> \\<delta> f x y \\<triangleq>\n                     (d\\<^sub>x x and d\\<^sub>y y)", "apply(case_tac \"\\<not>(\\<tau> \\<Turnstile> d\\<^sub>x x)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<not> \\<tau> |\\<noteq> d\\<^sub>x x \\<Longrightarrow>\n       \\<tau>\n        \\<Turnstile> \\<delta> f x y \\<triangleq>\n                     (d\\<^sub>x x and d\\<^sub>y y)", "apply(case_tac \"\\<not>(\\<tau> \\<Turnstile> d\\<^sub>y y)\", simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>\\<not> \\<tau> |\\<noteq> d\\<^sub>x x;\n        \\<not> \\<tau> |\\<noteq> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f x y \\<triangleq>\n (d\\<^sub>x x and d\\<^sub>y y)", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f x y \\<triangleq>\n (d\\<^sub>x x and d\\<^sub>y y)", "apply(rule foundation13[THEN iffD2,THEN StrongEq_L_subst2_rev, where y =\"d\\<^sub>x x\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> d\\<^sub>x x\n 2. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> cp (\\<lambda>a.\n                                \\<delta> f x y \\<triangleq>\n                                (a and d\\<^sub>y y))\n 3. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f x y \\<triangleq>\n (true and d\\<^sub>y y)", "apply(simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f x y \\<triangleq>\n d\\<^sub>y y", "apply(rule foundation13[THEN iffD2,THEN StrongEq_L_subst2_rev, where y =\"d\\<^sub>y y\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> d\\<^sub>y y\n 2. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> cp ((\\<triangleq>) (\\<delta> f x y))\n 3. \\<And>\\<tau>.\n       \\<lbrakk>\\<tau> \\<Turnstile> d\\<^sub>x x;\n        \\<tau> \\<Turnstile> d\\<^sub>y y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f x y \\<triangleq> true", "apply(simp_all add: 1 foundation13)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma def_valid_then_def: \"\\<upsilon>(f x y) = (\\<delta>(f x y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> f x y = \\<delta> f x y", "(* [simp,code_unfold] ? *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<upsilon> f x y = \\<delta> f x y", "apply(rule ext, rename_tac \"\\<tau>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>. (\\<upsilon> f x y) \\<tau> = (\\<delta> f x y) \\<tau>", "apply(simp_all add: valid_def defined_def def_scheme''\n                             true_def false_def invalid_def \n                             null_def null_fun_def null_option_def bot_fun_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau>.\n       d\\<^sub>x x \\<tau> = \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<and>\n       d\\<^sub>y y \\<tau> =\n       \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor> \\<longrightarrow>\n       null \\<noteq> \\<bottom> \\<longrightarrow>\n       g (x \\<tau>) (y \\<tau>) \\<noteq> null", "by (metis \"1\" OclValid_def def_scheme'' foundation16 true_def)"], ["", "lemma defined_args_valid: \"(\\<tau> \\<Turnstile> \\<delta> (f x y)) = ((\\<tau> \\<Turnstile> d\\<^sub>x x) \\<and> (\\<tau> \\<Turnstile> d\\<^sub>y y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau> \\<Turnstile> \\<delta> f x y) =\n    (\\<tau> \\<Turnstile> d\\<^sub>x x \\<and> \\<tau> \\<Turnstile> d\\<^sub>y y)", "by(simp add: foundation10')"], ["", "lemma const[simp,code_unfold] : \n          assumes C1 :\"const X\" and C2 : \"const Y\"\n          shows       \"const(f X Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (f X Y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. const (f X Y)", "have const_g : \"const (\\<lambda>\\<tau>. g (X \\<tau>) (Y \\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const (\\<lambda>\\<tau>. g (X \\<tau>) (Y \\<tau>))", "by(insert C1 C2, auto simp:const_def, metis)"], ["proof (state)\nthis:\n  const (\\<lambda>\\<tau>. g (X \\<tau>) (Y \\<tau>))\n\ngoal (1 subgoal):\n 1. const (f X Y)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. const (f X Y)", "by(simp_all add : def_scheme'' const_ss C1 C2 const_g)"], ["proof (state)\nthis:\n  const (f X Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\nIn our context, we will use Locales as ``Property Profiles'' for OCL operators;\nif an operator @{term \"f\"} is of profile @{term \"profile_bin_scheme defined f g\"} we know\nthat it satisfies a number of properties like \\<open>strict1\\<close> or \\<open>strict2\\<close>\n\\ie{} @{term \"f invalid y = invalid\"} and @{term \"f null y = invalid\"}.\nSince some of the more advanced Locales come with 10 - 15 theorems, property profiles\nrepresent a major structuring mechanism for the OCL library.\n\\<close>"], ["", "locale profile_bin_scheme_defined =\n   fixes d\\<^sub>y:: \"('\\<AA>,'b::null)val \\<Rightarrow> '\\<AA> Boolean\"\n   fixes f::\"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>,'b::null)val \\<Rightarrow> ('\\<AA>,'c::null)val\"\n   fixes g\n   assumes d\\<^sub>y : \"profile_single d\\<^sub>y\"\n   assumes d\\<^sub>y_homo[simp,code_unfold]: \"cp (f X) \\<Longrightarrow> \n                          f X invalid = invalid \\<Longrightarrow>\n                          \\<not> \\<tau> \\<Turnstile> d\\<^sub>y Y \\<Longrightarrow>\n                          \\<tau> \\<Turnstile> \\<delta> f X Y \\<triangleq> (\\<delta> X and d\\<^sub>y Y)\"\n   assumes def_scheme'[simplified]: \"bin f g defined d\\<^sub>y X Y\"\n   assumes def_body':  \"\\<And> x y \\<tau>. x\\<noteq>bot \\<Longrightarrow> x\\<noteq>null \\<Longrightarrow> (d\\<^sub>y y) \\<tau> = true \\<tau> \\<Longrightarrow> g x (y \\<tau>) \\<noteq> bot \\<and> g x (y \\<tau>) \\<noteq> null \"\nbegin"], ["", "lemma strict3[simp,code_unfold]: \" f null y = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null y = invalid", "by(rule ext, simp add: def_scheme' true_def false_def)"], ["", "end"], ["", "sublocale profile_bin_scheme_defined < profile_bin_scheme defined"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme defined d\\<^sub>y f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin_scheme defined d\\<^sub>y f g", "interpret d\\<^sub>y : profile_single d\\<^sub>y"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_single d\\<^sub>y", "by (rule d\\<^sub>y)"], ["proof (state)\ngoal (1 subgoal):\n 1. profile_bin_scheme defined d\\<^sub>y f g", "show \"profile_bin_scheme defined d\\<^sub>y f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme defined d\\<^sub>y f g", "apply(unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<delta> invalid = false\n 2. \\<And>X \\<tau>.\n       (\\<delta> X) \\<tau> = (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>\n 3. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 4. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<delta> X \\<or>\n        \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 5. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 6. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X \\<tau>.\n       (\\<delta> X) \\<tau> = (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>\n 2. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 3. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<delta> X \\<or>\n        \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 4. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 5. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(subst cp_defined, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 2. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<delta> X \\<or>\n        \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 3. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 4. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(rule const_defined, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<delta> X \\<or>\n        \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 2. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 3. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add:defined_split, elim disjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> \\<Turnstile> X \\<triangleq> invalid\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 2. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> \\<Turnstile> X \\<triangleq> null\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 3. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid; \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 4. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 5. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(erule StrongEq_L_subst2_rev, simp, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid; \\<tau> |\\<noteq> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and d\\<^sub>y Y)\n 2. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 3. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y. bin f g defined d\\<^sub>y X Y\n 2. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add: def_scheme')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<delta> X;\n        \\<tau> \\<Turnstile> d\\<^sub>y Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add: defined_def OclValid_def false_def true_def \n              bot_fun_def null_fun_def def_scheme' split: if_split_asm, rule def_body')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>\\<tau> X Y.\n       \\<lbrakk>d\\<^sub>y Y \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        X \\<tau> \\<noteq> \\<bottom> \\<and> X \\<tau> \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> X \\<tau> \\<noteq> \\<bottom>\n 2. \\<And>\\<tau> X Y.\n       \\<lbrakk>d\\<^sub>y Y \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        X \\<tau> \\<noteq> \\<bottom> \\<and> X \\<tau> \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> X \\<tau> \\<noteq> null\n 3. \\<And>\\<tau> X Y.\n       \\<lbrakk>d\\<^sub>y Y \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        X \\<tau> \\<noteq> \\<bottom> \\<and> X \\<tau> \\<noteq> null\\<rbrakk>\n       \\<Longrightarrow> d\\<^sub>y Y \\<tau> = true \\<tau>", "by(simp add: true_def)+"], ["proof (state)\nthis:\n  profile_bin_scheme defined d\\<^sub>y f g\n\ngoal:\nNo subgoals!", "qed"], ["", "locale profile_bin\\<^sub>d_\\<^sub>d =\n   fixes f::\"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>,'b::null)val \\<Rightarrow> ('\\<AA>,'c::null)val\"\n   fixes g\n   assumes def_scheme[simplified]: \"bin f g defined defined X Y\"\n   assumes def_body:  \"\\<And> x y. x\\<noteq>bot \\<Longrightarrow> x\\<noteq>null \\<Longrightarrow> y\\<noteq>bot \\<Longrightarrow> y\\<noteq>null \\<Longrightarrow>\n                               g x y \\<noteq> bot \\<and> g x y \\<noteq> null \"\nbegin"], ["", "lemma strict4[simp,code_unfold]: \" f x null = invalid\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x null = invalid", "by(rule ext, simp add: def_scheme true_def false_def)"], ["", "end"], ["", "sublocale profile_bin\\<^sub>d_\\<^sub>d < profile_bin_scheme_defined defined"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme_defined defined f g", "apply(unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<delta> invalid = false\n 2. \\<And>X \\<tau>.\n       (\\<delta> X) \\<tau> = (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>\n 3. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 4. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<delta> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 5. \\<And>X Y. bin f g defined defined X Y\n 6. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp)+"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X \\<tau>.\n       (\\<delta> X) \\<tau> = (\\<delta> (\\<lambda>_. X \\<tau>)) \\<tau>\n 2. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 3. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<delta> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 4. \\<And>X Y. bin f g defined defined X Y\n 5. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(subst cp_defined, simp)+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X. const X \\<Longrightarrow> const (\\<delta> X)\n 2. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<delta> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 3. \\<And>X Y. bin f g defined defined X Y\n 4. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(rule const_defined, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<delta> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 2. \\<And>X Y. bin f g defined defined X Y\n 3. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp add:defined_split, elim disjE)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> \\<Turnstile> Y \\<triangleq> invalid\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 2. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> \\<Turnstile> Y \\<triangleq> null\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<delta> Y)\n 3. \\<And>X Y. bin f g defined defined X Y\n 4. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(erule StrongEq_L_subst2_rev, simp, simp)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y. bin f g defined defined X Y\n 2. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp add: def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<delta> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp add: defined_def OclValid_def false_def true_def bot_fun_def null_fun_def def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (if y \\<tau> = \\<bottom> \\<or> y \\<tau> = null then false \\<tau>\n         else true \\<tau>) =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(rule def_body, simp_all add: true_def false_def split:if_split_asm)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "locale profile_bin\\<^sub>d_\\<^sub>v =\n   fixes f::\"('\\<AA>,'a::null)val \\<Rightarrow> ('\\<AA>,'b::null)val \\<Rightarrow> ('\\<AA>,'c::null)val\"\n   fixes g\n   assumes def_scheme[simplified]: \"bin f g defined valid X Y\"\n   assumes def_body:  \"\\<And> x y. x\\<noteq>bot \\<Longrightarrow> x\\<noteq>null \\<Longrightarrow> y\\<noteq>bot \\<Longrightarrow> g x y \\<noteq> bot \\<and> g x y \\<noteq> null\""], ["", "sublocale profile_bin\\<^sub>d_\\<^sub>v < profile_bin_scheme_defined valid"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme_defined valid f g", "apply(unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<upsilon> invalid = false\n 2. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 3. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 4. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<upsilon> Y)\n 5. \\<And>X Y. bin f g defined valid X Y\n 6. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 2. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 3. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<upsilon> Y)\n 4. \\<And>X Y. bin f g defined valid X Y\n 5. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(subst cp_valid, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 2. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<upsilon> Y)\n 3. \\<And>X Y. bin f g defined valid X Y\n 4. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(rule const_valid, simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<upsilon> Y)\n 2. \\<And>X Y. bin f g defined valid X Y\n 3. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp add:foundation18'')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X \\<tau> Y.\n       \\<lbrakk>cp (f X); f X invalid = invalid;\n        \\<tau> \\<Turnstile> Y \\<triangleq> invalid\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<delta> X and \\<upsilon> Y)\n 2. \\<And>X Y. bin f g defined valid X Y\n 3. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(erule StrongEq_L_subst2_rev, simp, simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y. bin f g defined valid X Y\n 2. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "apply(simp add: def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y \\<tau>.\n       \\<lbrakk>x \\<noteq> \\<bottom>; x \\<noteq> null;\n        (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n       \\<Longrightarrow> g x (y \\<tau>) \\<noteq> \\<bottom> \\<and>\n                         g x (y \\<tau>) \\<noteq> null", "by (metis OclValid_def def_body foundation18')"], ["", "locale profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v =\n   fixes f :: \"('\\<AA>,'\\<alpha>::null)val \\<Rightarrow> ('\\<AA>,'\\<alpha>::null)val \\<Rightarrow> ('\\<AA>) Boolean\"\n   assumes def_scheme[simplified]: \"bin' f StrongEq valid valid X Y\""], ["", "sublocale profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v < profile_bin_scheme valid valid f \"\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme valid valid f\n     (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>)", "apply(unfold_locales)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<upsilon> invalid = false\n 2. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 3. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 4. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 5. \\<And>X Y.\n       bin f (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>) valid\n        valid X Y\n 6. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 2. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 3. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 4. \\<And>X Y.\n       bin f (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>) valid\n        valid X Y\n 5. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(subst cp_valid, simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 2. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 3. \\<And>X Y.\n       bin f (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>) valid\n        valid X Y\n 4. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply (simp add: const_valid)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 2. \\<And>X Y.\n       bin f (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>) valid\n        valid X Y\n 3. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply (metis (hide_lams, mono_tags) OclValid_def def_scheme defined5 defined6 defined_and_I foundation1 foundation10' foundation16' foundation18 foundation21 foundation22 foundation9)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y.\n       bin f (\\<lambda>x y. \\<lfloor>\\<lfloor>x = y\\<rfloor>\\<rfloor>) valid\n        valid X Y\n 2. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add: def_scheme, subst StrongEq_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "by (metis OclValid_def def_scheme defined7 foundation16)"], ["", "context profile_bin\\<^sub>S\\<^sub>t\\<^sub>r\\<^sub>o\\<^sub>n\\<^sub>g\\<^sub>E\\<^sub>q_\\<^sub>v_\\<^sub>v\n   begin"], ["", "lemma idem[simp,code_unfold]: \" f null null = true\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f null null = true", "by(rule ext, simp add: def_scheme true_def false_def)"], ["", "(* definedness *)"], ["", "lemma defargs: \"\\<tau> \\<Turnstile> f x y \\<Longrightarrow> (\\<tau> \\<Turnstile> \\<upsilon> x) \\<and> (\\<tau> \\<Turnstile> \\<upsilon> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> f x y \\<Longrightarrow>\n    \\<tau> \\<Turnstile> \\<upsilon> x \\<and> \\<tau> \\<Turnstile> \\<upsilon> y", "by(simp add: def_scheme OclValid_def true_def invalid_def valid_def bot_option_def\n               split: bool.split_asm HOL.if_split_asm)"], ["", "lemma defined_args_valid' : \"\\<delta> (f x y) = (\\<upsilon> x and \\<upsilon> y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta> f x y = (\\<upsilon> x and \\<upsilon> y)", "by(auto intro!: transform2_rev defined_and_I simp:foundation10 defined_args_valid)"], ["", "(* logic and algebraic properties *)"], ["", "lemma refl_ext[simp,code_unfold] : \"(f x x) = (if (\\<upsilon> x) then true else invalid endif)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x x = (if \\<upsilon> x then true else invalid endif)", "by(rule ext, simp add: def_scheme OclIf_def)"], ["", "lemma sym : \"\\<tau> \\<Turnstile> (f x y) \\<Longrightarrow> \\<tau> \\<Turnstile> (f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> \\<Turnstile> f x y \\<Longrightarrow> \\<tau> \\<Turnstile> f y x", "apply(case_tac \"\\<tau> \\<Turnstile> \\<upsilon> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> f x y;\n     \\<tau> \\<Turnstile> \\<upsilon> x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f y x\n 2. \\<lbrakk>\\<tau> \\<Turnstile> f x y;\n     \\<tau> |\\<noteq> \\<upsilon> x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f y x", "apply(auto simp: def_scheme OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x \\<triangleq> y) \\<tau> = true \\<tau>;\n     (\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (y \\<triangleq> x) \\<tau> = true \\<tau>", "by(fold OclValid_def, erule StrongEq_L_sym)"], ["", "lemma symmetric : \"(f x y) = (f y x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f x y = f y x", "by(rule ext, rename_tac \\<tau>, auto simp: def_scheme StrongEq_sym)"], ["", "lemma trans : \"\\<tau> \\<Turnstile> (f x y) \\<Longrightarrow> \\<tau> \\<Turnstile> (f y z) \\<Longrightarrow> \\<tau> \\<Turnstile> (f x z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z", "apply(case_tac \"\\<tau> \\<Turnstile> \\<upsilon> x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z;\n     \\<tau> \\<Turnstile> \\<upsilon> x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z\n 2. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z;\n     \\<tau> |\\<noteq> \\<upsilon> x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z", "apply(case_tac \"\\<tau> \\<Turnstile> \\<upsilon> y\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z;\n     \\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z\n 2. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z;\n     \\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> |\\<noteq> \\<upsilon> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z\n 3. \\<lbrakk>\\<tau> \\<Turnstile> f x y; \\<tau> \\<Turnstile> f y z;\n     \\<tau> |\\<noteq> \\<upsilon> x\\<rbrakk>\n    \\<Longrightarrow> \\<tau> \\<Turnstile> f x z", "apply(auto simp: def_scheme OclValid_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>(x \\<triangleq> y) \\<tau> = true \\<tau>;\n     (y \\<triangleq> z) \\<tau> = true \\<tau>;\n     (\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> = true \\<tau>;\n     (\\<upsilon> z) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (x \\<triangleq> z) \\<tau> = true \\<tau>\n 2. \\<lbrakk>invalid \\<tau> = true \\<tau>;\n     (\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> \\<noteq> true \\<tau>;\n     (\\<upsilon> z) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> (x \\<triangleq> z) \\<tau> = true \\<tau>", "by(fold OclValid_def, auto elim: StrongEq_L_trans)"], ["", "lemma StrictRefEq_vs_StrongEq: \"\\<tau> \\<Turnstile>(\\<upsilon> x) \\<Longrightarrow> \\<tau> \\<Turnstile>(\\<upsilon> y) \\<Longrightarrow> (\\<tau> \\<Turnstile> ((f x y) \\<triangleq> (x \\<triangleq> y)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> x;\n     \\<tau> \\<Turnstile> \\<upsilon> y\\<rbrakk>\n    \\<Longrightarrow> \\<tau>\n                       \\<Turnstile> f x y \\<triangleq> (x \\<triangleq> y)", "apply(simp add: def_scheme OclValid_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>\\<tau>.\n                           if (\\<upsilon> x) \\<tau> = true \\<tau> \\<and>\n                              (\\<upsilon> y) \\<tau> = true \\<tau>\n                           then (x \\<triangleq> y) \\<tau>\n                           else invalid \\<tau>) \\<triangleq>\n                       (x \\<triangleq> y))\n                       \\<tau> =\n                      true \\<tau>", "apply(subst cp_StrongEq[of _ \"(x \\<triangleq> y)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<upsilon> x) \\<tau> = true \\<tau>;\n     (\\<upsilon> y) \\<tau> = true \\<tau>\\<rbrakk>\n    \\<Longrightarrow> ((\\<lambda>_.\n                           if (\\<upsilon> x) \\<tau> = true \\<tau> \\<and>\n                              (\\<upsilon> y) \\<tau> = true \\<tau>\n                           then (x \\<triangleq> y) \\<tau>\n                           else invalid \\<tau>) \\<triangleq>\n                       (\\<lambda>_. (x \\<triangleq> y) \\<tau>))\n                       \\<tau> =\n                      true \\<tau>", "by simp"], ["", "end"], ["", "locale profile_bin\\<^sub>v_\\<^sub>v =\n   fixes f :: \"('\\<AA>,'\\<alpha>::null)val \\<Rightarrow> ('\\<AA>,'\\<beta>::null)val \\<Rightarrow> ('\\<AA>,'\\<gamma>::null)val\"\n   fixes g\n   assumes def_scheme[simplified]: \"bin f g valid valid X Y\"\n   assumes def_body:  \"\\<And> x y. x\\<noteq>bot \\<Longrightarrow> y\\<noteq>bot \\<Longrightarrow> g x y \\<noteq> bot \\<and> g x y \\<noteq> null\""], ["", "sublocale profile_bin\\<^sub>v_\\<^sub>v < profile_bin_scheme valid valid"], ["proof (prove)\ngoal (1 subgoal):\n 1. profile_bin_scheme valid valid f g", "apply(unfold_locales)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<upsilon> invalid = false\n 2. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 3. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 4. \\<upsilon> invalid = false\n 5. \\<And>X \\<tau>.\n       (\\<upsilon> X) \\<tau> = (\\<upsilon> (\\<lambda>_. X \\<tau>)) \\<tau>\n 6. \\<And>X. const X \\<Longrightarrow> const (\\<upsilon> X)\n 7. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 8. \\<And>X Y. bin f g valid valid X Y\n 9. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp, subst cp_valid, simp, rule const_valid, simp)+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>X Y \\<tau>.\n       \\<lbrakk>cp (f X); cp (\\<lambda>x. f x Y); f X invalid = invalid;\n        f invalid Y = invalid;\n        \\<tau> |\\<noteq> \\<upsilon> X \\<or>\n        \\<tau> |\\<noteq> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau>\n                          \\<Turnstile> \\<delta> f X Y \\<triangleq>\n (\\<upsilon> X and \\<upsilon> Y)\n 2. \\<And>X Y. bin f g valid valid X Y\n 3. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply (metis (hide_lams, mono_tags) OclValid_def def_scheme defined5 defined6 defined_and_I \n         foundation1 foundation10' foundation16' foundation18 foundation21 foundation22 foundation9)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>X Y. bin f g valid valid X Y\n 2. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add: def_scheme)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<tau> X Y.\n       \\<lbrakk>\\<tau> \\<Turnstile> \\<upsilon> X;\n        \\<tau> \\<Turnstile> \\<upsilon> Y\\<rbrakk>\n       \\<Longrightarrow> \\<tau> \\<Turnstile> \\<delta> f X Y", "apply(simp add: defined_def OclValid_def false_def true_def \n              bot_fun_def null_fun_def def_scheme split: if_split_asm, rule def_body)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<tau> X Y.\n       \\<lbrakk>(\\<upsilon> X) \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> Y) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> X \\<tau> \\<noteq> \\<bottom>\n 2. \\<And>\\<tau> X Y.\n       \\<lbrakk>(\\<upsilon> X) \\<tau> =\n                \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>;\n        (\\<upsilon> Y) \\<tau> =\n        \\<lfloor>\\<lfloor>True\\<rfloor>\\<rfloor>\\<rbrakk>\n       \\<Longrightarrow> Y \\<tau> \\<noteq> \\<bottom>", "by (metis OclValid_def foundation18' true_def)+"], ["", "end"]]}