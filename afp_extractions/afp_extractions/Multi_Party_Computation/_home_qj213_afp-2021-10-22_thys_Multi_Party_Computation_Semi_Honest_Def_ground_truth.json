{"file_name": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation/Semi_Honest_Def.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation", "problem_names": ["lemma equiv_defs_P1:\n  assumes lossless_D: \"\\<forall> view. lossless_spmf ((D:: 'view1 adversary_det) view)\" \n  shows \"adv_P1_game m1 m2 D = adv_P1 m1 m2 D\"", "lemma equiv_defs_P2:\n  assumes lossless_D: \"\\<forall> view. lossless_spmf ((D:: 'view2 adversary_det) view)\" \n  shows \"adv_P2_game m1 m2 D = adv_P2 m1 m2 D\""], "translations": [["", "lemma equiv_defs_P1:\n  assumes lossless_D: \"\\<forall> view. lossless_spmf ((D:: 'view1 adversary_det) view)\" \n  shows \"adv_P1_game m1 m2 D = adv_P1 m1 m2 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "have return_True_not_False: \"spmf (return_spmf (b)) True = spmf (return_spmf (\\<not> b)) False\" \n    for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (return_spmf b) True = spmf (return_spmf (\\<not> b)) False", "by(cases b; auto)"], ["proof (state)\nthis:\n  spmf (return_spmf ?b) True = spmf (return_spmf (\\<not> ?b)) False\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "have lossless_ideal: \"lossless_spmf ((funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S1 m1 out1 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b'))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (funct m1 m2 \\<bind>\n      (\\<lambda>(out1, out2).\n          S1 m1 out1 \\<bind>\n          (\\<lambda>sview.\n              D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))", "by(simp add: lossless_S1 lossless_funct lossless_weight_spmfD split_def lossless_D)"], ["proof (state)\nthis:\n  lossless_spmf\n   (funct m1 m2 \\<bind>\n    (\\<lambda>(out1, out2).\n        S1 m1 out1 \\<bind>\n        (\\<lambda>sview.\n            D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "have return: \"spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S1 m1 o1 \\<bind> D)) True \n                  = spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S1 m1 o1 \\<bind> (\\<lambda> view. D view \\<bind> (\\<lambda> b. return_spmf b)))) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S1 m1 o1 \\<bind> D))\n     True =\n    spmf\n     (funct m1 m2 \\<bind>\n      (\\<lambda>(o1, o2).\n          S1 m1 o1 \\<bind> (\\<lambda>view. D view \\<bind> return_spmf)))\n     True", "by simp"], ["proof (state)\nthis:\n  spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S1 m1 o1 \\<bind> D)) True =\n  spmf\n   (funct m1 m2 \\<bind>\n    (\\<lambda>(o1, o2).\n        S1 m1 o1 \\<bind> (\\<lambda>view. D view \\<bind> return_spmf)))\n   True\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "have \"2*(spmf (P1_game_alt m1 m2 D ) True) - 1 = (spmf (R1 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n        - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S1 m1 out1 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * spmf (P1_game_alt m1 m2 D) True - 1 =\n    spmf\n     (R1 m1 m2 \\<bind>\n      (\\<lambda>rview.\n          D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n     True -\n    (1 -\n     spmf\n      (funct m1 m2 \\<bind>\n       (\\<lambda>(out1, out2).\n           S1 m1 out1 \\<bind>\n           (\\<lambda>sview.\n               D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n      True)", "by(simp add: spmf_bind integral_spmf_of_set adv_P1_game_def P1_game_alt_def spmf_of_set\n          UNIV_bool bind_spmf_const lossless_R1 lossless_S1 lossless_funct lossless_weight_spmfD)"], ["proof (state)\nthis:\n  2 * spmf (P1_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R1 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S1 m1 out1 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "hence \"adv_P1_game m1 m2 D = \\<bar>(spmf (R1 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n        - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S1 m1 out1 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\\<bar>\""], ["proof (prove)\nusing this:\n  2 * spmf (P1_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R1 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S1 m1 out1 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D =\n    \\<bar>spmf\n           (R1 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S1 m1 out1 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar>", "using adv_P1_game_def"], ["proof (prove)\nusing this:\n  2 * spmf (P1_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R1 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S1 m1 out1 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n  adv_P1_game ?m1.0 ?m2.0 ?D =\n  \\<bar>2 * spmf (P1_game_alt ?m1.0 ?m2.0 ?D) True - 1\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D =\n    \\<bar>spmf\n           (R1 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S1 m1 out1 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar>", "by simp"], ["proof (state)\nthis:\n  adv_P1_game m1 m2 D =\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "also"], ["proof (state)\nthis:\n  adv_P1_game m1 m2 D =\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "have \"\\<bar>(spmf (R1 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n                      - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S1 m1 out1 \\<bind> (\\<lambda>sview. D sview \n                            \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\\<bar> = adv_P1 m1 m2 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (R1 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S1 m1 out1 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar> =\n    adv_P1 m1 m2 D", "apply(simp only: adv_P1_def spmf_False_conv_True[symmetric] lossless_ideal; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (R1 m1 m2 \\<bind> D) True -\n          spmf\n           (funct m1 m2 \\<bind>\n            (\\<lambda>(out1, out2).\n                S1 m1 out1 \\<bind>\n                (\\<lambda>sview.\n                    D sview \\<bind>\n                    (\\<lambda>b'. return_spmf (\\<not> b')))))\n           False\\<bar> =\n    \\<bar>spmf (R1 m1 m2 \\<bind> D) True -\n          spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S1 m1 o1 \\<bind> D))\n           True\\<bar>", "by(simp only: return)(simp only: split_def spmf_bind return_True_not_False)"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P1 m1 m2 D\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "ultimately"], ["proof (chain)\npicking this:\n  adv_P1_game m1 m2 D =\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P1 m1 m2 D", "show ?thesis"], ["proof (prove)\nusing this:\n  adv_P1_game m1 m2 D =\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n  \\<bar>spmf\n         (R1 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S1 m1 out1 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P1 m1 m2 D\n\ngoal (1 subgoal):\n 1. adv_P1_game m1 m2 D = adv_P1 m1 m2 D", "by simp"], ["proof (state)\nthis:\n  adv_P1_game m1 m2 D = adv_P1 m1 m2 D\n\ngoal:\nNo subgoals!", "qed"], ["", "definition P2_game_alt :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> 'view2 adversary_det \\<Rightarrow> bool spmf\"\n  where \"P2_game_alt m1 m2 D = do {\n    b \\<leftarrow> coin_spmf;\n    (out1, out2) \\<leftarrow> funct m1 m2;\n    rview :: 'view2 \\<leftarrow> R2 m1 m2;\n    sview :: 'view2 \\<leftarrow> S2 m2 out2;\n    b' \\<leftarrow> D (if b then rview else sview);\n    return_spmf (b = b')}\""], ["", "definition adv_P2_game :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> 'view2 adversary_det \\<Rightarrow> real\"\n  where \"adv_P2_game m1 m2 D = \\<bar>2*(spmf (P2_game_alt m1 m2 D ) True) - 1\\<bar>\""], ["", "lemma equiv_defs_P2:\n  assumes lossless_D: \"\\<forall> view. lossless_spmf ((D:: 'view2 adversary_det) view)\" \n  shows \"adv_P2_game m1 m2 D = adv_P2 m1 m2 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "have return_True_not_False: \"spmf (return_spmf (b)) True = spmf (return_spmf (\\<not> b)) False\" \n    for b"], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (return_spmf b) True = spmf (return_spmf (\\<not> b)) False", "by(cases b; auto)"], ["proof (state)\nthis:\n  spmf (return_spmf ?b) True = spmf (return_spmf (\\<not> ?b)) False\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "have lossless_ideal: \"lossless_spmf ((funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S2 m2 out2 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b'))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf\n     (funct m1 m2 \\<bind>\n      (\\<lambda>(out1, out2).\n          S2 m2 out2 \\<bind>\n          (\\<lambda>sview.\n              D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))", "by(simp add: lossless_S2 lossless_funct lossless_weight_spmfD split_def lossless_D)"], ["proof (state)\nthis:\n  lossless_spmf\n   (funct m1 m2 \\<bind>\n    (\\<lambda>(out1, out2).\n        S2 m2 out2 \\<bind>\n        (\\<lambda>sview.\n            D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "have return: \"spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S2 m2 o2 \\<bind> D)) True = spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S2 m2 o2 \\<bind> (\\<lambda> view. D view \\<bind> (\\<lambda> b. return_spmf b)))) True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S2 m2 o2 \\<bind> D))\n     True =\n    spmf\n     (funct m1 m2 \\<bind>\n      (\\<lambda>(o1, o2).\n          S2 m2 o2 \\<bind> (\\<lambda>view. D view \\<bind> return_spmf)))\n     True", "by simp"], ["proof (state)\nthis:\n  spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S2 m2 o2 \\<bind> D)) True =\n  spmf\n   (funct m1 m2 \\<bind>\n    (\\<lambda>(o1, o2).\n        S2 m2 o2 \\<bind> (\\<lambda>view. D view \\<bind> return_spmf)))\n   True\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "have \n    \"2*(spmf (P2_game_alt m1 m2 D ) True) - 1 = (spmf (R2 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n        - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S2 m2 out2 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * spmf (P2_game_alt m1 m2 D) True - 1 =\n    spmf\n     (R2 m1 m2 \\<bind>\n      (\\<lambda>rview.\n          D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n     True -\n    (1 -\n     spmf\n      (funct m1 m2 \\<bind>\n       (\\<lambda>(out1, out2).\n           S2 m2 out2 \\<bind>\n           (\\<lambda>sview.\n               D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n      True)", "by(simp add: spmf_bind integral_spmf_of_set adv_P1_game_def P2_game_alt_def spmf_of_set \n          UNIV_bool bind_spmf_const lossless_R2 lossless_S2 lossless_funct lossless_weight_spmfD)"], ["proof (state)\nthis:\n  2 * spmf (P2_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R2 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S2 m2 out2 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "hence \"adv_P2_game m1 m2 D = \\<bar>(spmf (R2 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n        - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S2 m2 out2 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\\<bar>\""], ["proof (prove)\nusing this:\n  2 * spmf (P2_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R2 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S2 m2 out2 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D =\n    \\<bar>spmf\n           (R2 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S2 m2 out2 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar>", "using adv_P2_game_def"], ["proof (prove)\nusing this:\n  2 * spmf (P2_game_alt m1 m2 D) True - 1 =\n  spmf\n   (R2 m1 m2 \\<bind>\n    (\\<lambda>rview.\n        D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n   True -\n  (1 -\n   spmf\n    (funct m1 m2 \\<bind>\n     (\\<lambda>(out1, out2).\n         S2 m2 out2 \\<bind>\n         (\\<lambda>sview.\n             D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))\n    True)\n  adv_P2_game ?m1.0 ?m2.0 ?D =\n  \\<bar>2 * spmf (P2_game_alt ?m1.0 ?m2.0 ?D) True - 1\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D =\n    \\<bar>spmf\n           (R2 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S2 m2 out2 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar>", "by simp"], ["proof (state)\nthis:\n  adv_P2_game m1 m2 D =\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "also"], ["proof (state)\nthis:\n  adv_P2_game m1 m2 D =\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "have \"\\<bar>(spmf (R2 m1 m2 \\<bind> (\\<lambda>rview. D rview \\<bind> (\\<lambda>(b':: bool). return_spmf (True = b'))))) True\n        - (1 - (spmf (funct m1 m2 \\<bind> (\\<lambda>(out1, out2). S2 m2 out2 \\<bind> (\\<lambda>sview. D sview \\<bind> (\\<lambda>b'. return_spmf (False = b')))))) True)\\<bar> = adv_P2 m1 m2 D\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (R2 m1 m2 \\<bind>\n            (\\<lambda>rview.\n                D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n           True -\n          (1 -\n           spmf\n            (funct m1 m2 \\<bind>\n             (\\<lambda>(out1, out2).\n                 S2 m2 out2 \\<bind>\n                 (\\<lambda>sview.\n                     D sview \\<bind>\n                     (\\<lambda>b'. return_spmf (False = b')))))\n            True)\\<bar> =\n    adv_P2 m1 m2 D", "apply(simp only: adv_P2_def spmf_False_conv_True[symmetric] lossless_ideal; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (R2 m1 m2 \\<bind> D) True -\n          spmf\n           (funct m1 m2 \\<bind>\n            (\\<lambda>(out1, out2).\n                S2 m2 out2 \\<bind>\n                (\\<lambda>sview.\n                    D sview \\<bind>\n                    (\\<lambda>b'. return_spmf (\\<not> b')))))\n           False\\<bar> =\n    \\<bar>spmf (R2 m1 m2 \\<bind> D) True -\n          spmf (funct m1 m2 \\<bind> (\\<lambda>(o1, o2). S2 m2 o2 \\<bind> D))\n           True\\<bar>", "by(simp only: return)(simp only: split_def spmf_bind return_True_not_False)"], ["proof (state)\nthis:\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P2 m1 m2 D\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "ultimately"], ["proof (chain)\npicking this:\n  adv_P2_game m1 m2 D =\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P2 m1 m2 D", "show ?thesis"], ["proof (prove)\nusing this:\n  adv_P2_game m1 m2 D =\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar>\n  \\<bar>spmf\n         (R2 m1 m2 \\<bind>\n          (\\<lambda>rview.\n              D rview \\<bind> (\\<lambda>b'. return_spmf (True = b'))))\n         True -\n        (1 -\n         spmf\n          (funct m1 m2 \\<bind>\n           (\\<lambda>(out1, out2).\n               S2 m2 out2 \\<bind>\n               (\\<lambda>sview.\n                   D sview \\<bind>\n                   (\\<lambda>b'. return_spmf (False = b')))))\n          True)\\<bar> =\n  adv_P2 m1 m2 D\n\ngoal (1 subgoal):\n 1. adv_P2_game m1 m2 D = adv_P2 m1 m2 D", "by simp"], ["proof (state)\nthis:\n  adv_P2_game m1 m2 D = adv_P2 m1 m2 D\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsubsection \\<open> Security definitions for non deterministic functionalities \\<close>"], ["", "locale sim_non_det_def = \n  fixes R1 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> ('view1 \\<times> ('out1 \\<times> 'out2)) spmf\"\n    and S1  :: \"'msg1 \\<Rightarrow> 'out1 \\<Rightarrow> 'view1 spmf\"\n    and Out1 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> 'out1 \\<Rightarrow> ('out1 \\<times> 'out2) spmf\" \\<comment> \\<open>takes the input of the other party so can form the outputs of parties\\<close>\n    and R2 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> ('view2 \\<times> ('out1 \\<times> 'out2)) spmf\"\n    and S2  :: \"'msg2 \\<Rightarrow> 'out2 \\<Rightarrow> 'view2 spmf\"\n    and Out2 :: \"'msg2 \\<Rightarrow> 'msg1 \\<Rightarrow> 'out2 \\<Rightarrow> ('out1 \\<times> 'out2) spmf\"\n    and funct :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> ('out1 \\<times> 'out2) spmf\"\nbegin"], ["", "type_synonym ('view', 'out1', 'out2') adversary_non_det = \"('view' \\<times> ('out1' \\<times> 'out2')) \\<Rightarrow> bool spmf\""], ["", "definition Ideal1 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> 'out1  \\<Rightarrow> ('view1 \\<times> ('out1 \\<times> 'out2)) spmf\"\n  where \"Ideal1 m1 m2 out1 = do {\n    view1 :: 'view1 \\<leftarrow> S1 m1 out1;\n    out1 \\<leftarrow> Out1 m1 m2 out1;\n    return_spmf (view1, out1)}\""], ["", "definition Ideal2 :: \"'msg2 \\<Rightarrow> 'msg1 \\<Rightarrow> 'out2 \\<Rightarrow> ('view2 \\<times> ('out1 \\<times> 'out2)) spmf\"\n  where \"Ideal2 m2 m1 out2 = do {\n    view2 :: 'view2 \\<leftarrow> S2 m2 out2;\n    out2 \\<leftarrow> Out2 m2 m1 out2;\n    return_spmf (view2, out2)}\""], ["", "definition adv_P1 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> ('view1, 'out1, 'out2) adversary_non_det \\<Rightarrow> real\"\n  where \"adv_P1 m1 m2 D \\<equiv> \\<bar>(spmf (R1 m1 m2 \\<bind> (\\<lambda> view. D view)) True) - spmf (funct m1 m2 \\<bind> (\\<lambda> (o1, o2). Ideal1 m1 m2 o1 \\<bind> (\\<lambda> view. D view))) True\\<bar>\""], ["", "definition \"perfect_sec_P1 m1 m2 \\<equiv> (R1 m1 m2 = funct m1 m2 \\<bind> (\\<lambda> (s1, s2). Ideal1 m1 m2 s1))\""], ["", "definition adv_P2 :: \"'msg1 \\<Rightarrow> 'msg2 \\<Rightarrow> ('view2, 'out1, 'out2) adversary_non_det \\<Rightarrow> real\"\n  where \"adv_P2 m1 m2 D = \\<bar>spmf (R2 m1 m2 \\<bind> (\\<lambda> view. D view)) True - spmf (funct m1 m2 \\<bind> (\\<lambda> (o1, o2). Ideal2 m2 m1 o2 \\<bind> (\\<lambda> view. D view))) True\\<bar>\""], ["", "definition \"perfect_sec_P2 m1 m2 \\<equiv> (R2 m1 m2 = funct m1 m2 \\<bind> (\\<lambda> (s1, s2). Ideal2 m2 m1 s2))\""], ["", "end"], ["", "subsubsection \\<open> Secret sharing schemes \\<close>"], ["", "locale secret_sharing_scheme = \n  fixes share :: \"'input_out \\<Rightarrow> ('share \\<times> 'share) spmf\"\n    and reconstruct :: \"('share \\<times> 'share) \\<Rightarrow> 'input_out spmf\"\n    and F :: \"('input_out \\<Rightarrow> 'input_out \\<Rightarrow> 'input_out spmf) set\"\nbegin"], ["", "definition \"sharing_correct input \\<equiv> (share input \\<bind> (\\<lambda> (s1,s2). reconstruct (s1,s2)) = return_spmf input)\""], ["", "definition \"correct_share_eval input1 input2 \\<equiv> (\\<forall> gate_eval \\<in> F. \n              \\<exists> gate_protocol :: ('share \\<times> 'share) \\<Rightarrow> ('share \\<times> 'share) \\<Rightarrow> ('share \\<times> 'share) spmf. \n                  share input1 \\<bind> (\\<lambda> (s1,s2). share input2 \n                      \\<bind> (\\<lambda> (s3,s4). gate_protocol (s1,s3) (s2,s4) \n                          \\<bind> (\\<lambda> (S1,S2). reconstruct (S1,S2)))) = gate_eval input1 input2)\""], ["", "end"], ["", "end"]]}