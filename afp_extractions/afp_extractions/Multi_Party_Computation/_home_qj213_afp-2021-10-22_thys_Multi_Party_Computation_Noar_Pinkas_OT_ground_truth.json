{"file_name": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation/Noar_Pinkas_OT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation", "problem_names": ["lemma prime_field: \"a < (order \\<G>) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coprime a (order \\<G>)\"", "lemma weight_sample_uniform_units: \"weight_spmf (sample_uniform_units (order \\<G>)) = 1\"", "lemma lossless_protocol: \"lossless_spmf (protocol M \\<sigma>)\"", "lemma lossless_R1: \"lossless_spmf (R1 M \\<sigma>)\"", "lemma lossless_S1: \"lossless_spmf (S1 M out1)\"", "lemma lossless_R2: \"lossless_spmf (R2 M \\<sigma>)\"", "lemma lossless_S2: \"lossless_spmf (S2 \\<sigma> out2)\"", "lemma protocol_inverse: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\" \n  shows\" ((\\<^bold>g [^] ((a*b) mod (order \\<G>))) [^] (s1 :: nat)) \\<otimes> ((\\<^bold>g [^] b) [^] (r1::nat)) \\<otimes> (if v then m0 else m1) \\<otimes> inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) \n        = (if v then m0 else m1)\"\n(is \"?lhs = ?rhs\")", "lemma correctness: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\" \n  shows \"sim_def.correctness (m0,m1) \\<sigma>\"", "lemma security_P1: \n  shows \"sim_def.adv_P1 msgs \\<sigma> D \\<le> ddh.advantage (R1_inter_adversary D msgs) + ddh.advantage (inter_S1_adversary D msgs)\"\n    (is \"?lhs \\<le> ?rhs\")", "lemma add_mult_one_time_pad: \n  assumes \"s0 < order \\<G>\" \n    and \"s0 \\<noteq> 0\"\n  shows \"map_spmf (\\<lambda> c\\<^sub>v'. (((b* r0) + (s0 * c\\<^sub>v')) mod(order \\<G>))) (sample_uniform (order \\<G>)) = sample_uniform (order \\<G>)\"", "lemma security_P2: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\"\n  shows \"sim_def.perfect_sec_P2 (m0,m1) \\<sigma>\"", "theorem correctness_asymp: \n  assumes \"m0 \\<in> carrier (\\<G> \\<eta>)\" \"m1 \\<in> carrier (\\<G> \\<eta>)\"\n  shows \"sim_def.correctness \\<eta> (m0, m1) \\<sigma>\"", "theorem security_P1_asymp: \n  assumes \"negligible (\\<lambda> \\<eta>. ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\"\n    and \"negligible (\\<lambda> \\<eta>. ddh.advantage \\<eta> (R1_inter_adversary \\<eta>  D msgs))\"\n  shows \"negligible (\\<lambda> \\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)\"", "theorem security_P2_asymp: \n  assumes \"m0 \\<in> carrier (\\<G> \\<eta>)\" \"m1 \\<in> carrier (\\<G> \\<eta>)\"\n  shows \"sim_def.perfect_sec_P2 \\<eta> (m0,m1) \\<sigma>\""], "translations": [["", "lemma prime_field: \"a < (order \\<G>) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coprime a (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < order \\<G>; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> coprime a (order \\<G>)", "by(metis dvd_imp_le neq0_conv not_le prime_imp_coprime prime_order coprime_commute)"], ["", "lemma weight_sample_uniform_units: \"weight_spmf (sample_uniform_units (order \\<G>)) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. weight_spmf (sample_uniform_units (order \\<G>)) = 1", "using  lossless_spmf_def lossless_sample_uniform_units prime_order  prime_gt_1_nat"], ["proof (prove)\nusing this:\n  lossless_spmf ?p = (weight_spmf ?p = 1)\n  1 < ?q \\<Longrightarrow> lossless_spmf (sample_uniform_units ?q)\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n\ngoal (1 subgoal):\n 1. weight_spmf (sample_uniform_units (order \\<G>)) = 1", "by auto"], ["", "definition protocol :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> (unit \\<times> 'grp) spmf\"\n  where \"protocol M v = do {\n    let (m0,m1) = M;\n    a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let c\\<^sub>v = (a*b) mod (order \\<G>);\n    c\\<^sub>v' :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n    let z0' = ((\\<^bold>g [^] (if v then c\\<^sub>v' else c\\<^sub>v)) [^] s0) \\<otimes> ((\\<^bold>g [^] b) [^] r0);\n    r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n    let z1' = ((\\<^bold>g [^] ((if v then c\\<^sub>v else c\\<^sub>v'))) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n    let enc_m0 = z0' \\<otimes> m0;\n    let enc_m1 = z1' \\<otimes> m1;\n    let out_2 = (if v then enc_m1 \\<otimes> inv (w1 [^] b) else enc_m0 \\<otimes> inv (w0 [^] b));\n    return_spmf ((), out_2)}\""], ["", "lemma lossless_protocol: \"lossless_spmf (protocol M \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (protocol M \\<sigma>)", "apply(auto simp add: protocol_def Let_def split_def lossless_sample_uniform_units or_gt_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < order \\<G> \\<Longrightarrow>\n       lossless_spmf (sample_uniform_units (order \\<G>))", "using prime_order prime_gt_1_nat lossless_sample_uniform_units"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n  1 < ?q \\<Longrightarrow> lossless_spmf (sample_uniform_units ?q)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x < order \\<G> \\<Longrightarrow>\n       lossless_spmf (sample_uniform_units (order \\<G>))", "by simp"], ["", "type_synonym 'grp' view1 = \"(('grp' \\<times> 'grp') \\<times> ('grp' \\<times> 'grp' \\<times> 'grp' \\<times> 'grp')) spmf\""], ["", "type_synonym 'grp' dist_adversary = \"(('grp' \\<times> 'grp') \\<times> 'grp' \\<times> 'grp' \\<times> 'grp' \\<times> 'grp') \\<Rightarrow> bool spmf\""], ["", "definition R1 :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'grp view1\"\n  where \"R1 msgs \\<sigma> = do {\n    let (m0, m1) = msgs;\n    a \\<leftarrow> sample_uniform (order \\<G>);\n    b \\<leftarrow> sample_uniform (order \\<G>);\n    let c\\<^sub>\\<sigma> = a*b;\n    c\\<^sub>\\<sigma>' \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (msgs, (\\<^bold>g [^] a, \\<^bold>g [^] b, (if \\<sigma> then \\<^bold>g [^] c\\<^sub>\\<sigma>' else \\<^bold>g [^] c\\<^sub>\\<sigma>), (if \\<sigma> then \\<^bold>g [^] c\\<^sub>\\<sigma> else \\<^bold>g [^] c\\<^sub>\\<sigma>')))}\""], ["", "lemma lossless_R1: \"lossless_spmf (R1 M \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (R1 M \\<sigma>)", "by(simp add: R1_def Let_def lossless_sample_uniform_units or_gt_0)"], ["", "definition inter :: \"('grp \\<times> 'grp) \\<Rightarrow> 'grp view1\"\n  where \"inter msgs = do {\n    a \\<leftarrow> sample_uniform (order \\<G>);\n    b \\<leftarrow> sample_uniform (order \\<G>);  \n    c \\<leftarrow> sample_uniform (order \\<G>);\n    d \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (msgs, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c, \\<^bold>g [^] d)}\""], ["", "definition S1 :: \"('grp \\<times> 'grp) \\<Rightarrow> unit \\<Rightarrow> 'grp view1\"\n  where \"S1 msgs out1 = do {\n    let (m0, m1) = msgs;\n    a \\<leftarrow> sample_uniform (order \\<G>);\n    b \\<leftarrow> sample_uniform (order \\<G>);\n    c \\<leftarrow> sample_uniform (order \\<G>);\n    return_spmf (msgs, (\\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c, \\<^bold>g [^] (a*b)))}\""], ["", "lemma lossless_S1: \"lossless_spmf (S1 M out1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (S1 M out1)", "by(simp add: S1_def Let_def lossless_sample_uniform_units or_gt_0)"], ["", "fun R1_inter_adversary :: \"'grp dist_adversary \\<Rightarrow> ('grp \\<times> 'grp) \\<Rightarrow> 'grp \\<Rightarrow> 'grp \\<Rightarrow> 'grp \\<Rightarrow> bool spmf\"\n  where \"R1_inter_adversary \\<A> msgs \\<alpha> \\<beta> \\<gamma> = do {\n    c \\<leftarrow> sample_uniform (order \\<G>);\n    \\<A> (msgs, \\<alpha>, \\<beta>, \\<gamma>, \\<^bold>g [^] c)}\""], ["", "fun inter_S1_adversary :: \"'grp dist_adversary \\<Rightarrow> ('grp \\<times> 'grp) \\<Rightarrow> 'grp \\<Rightarrow> 'grp \\<Rightarrow> 'grp \\<Rightarrow> bool spmf\"\n  where \"inter_S1_adversary \\<A> msgs \\<alpha> \\<beta> \\<gamma> = do {\n    c \\<leftarrow> sample_uniform (order \\<G>);\n    \\<A> (msgs, \\<alpha>, \\<beta>, \\<^bold>g [^] c, \\<gamma>)}\""], ["", "sublocale ddh: ddh \\<G>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "definition R2 :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> (bool \\<times> 'grp \\<times> 'grp \\<times>  'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) spmf\" \n  where \"R2 M v  = do {\n  let (m0,m1) = M;\n  a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n  b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n  let c\\<^sub>v = (a*b) mod (order \\<G>);\n  c\\<^sub>v' :: nat \\<leftarrow> sample_uniform (order \\<G>);\n  r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n  let z = ((\\<^bold>g [^] c\\<^sub>v') [^] s0) \\<otimes> ((\\<^bold>g [^] b) [^] r0);\n  r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n  let enc_m = z \\<otimes> (if v then m0 else m1);\n  let enc_m' = z' \\<otimes> (if v then m1 else m0) ;\n  return_spmf(v, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["", "lemma lossless_R2: \"lossless_spmf (R2 M \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (R2 M \\<sigma>)", "apply(simp add: R2_def Let_def split_def lossless_sample_uniform_units or_gt_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x < order \\<G>) \\<longrightarrow>\n    lossless_spmf (sample_uniform_units (order \\<G>))", "using prime_order prime_gt_1_nat lossless_sample_uniform_units"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n  1 < ?q \\<Longrightarrow> lossless_spmf (sample_uniform_units ?q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x < order \\<G>) \\<longrightarrow>\n    lossless_spmf (sample_uniform_units (order \\<G>))", "by simp"], ["", "definition S2 :: \"bool \\<Rightarrow> 'grp \\<Rightarrow> (bool \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) spmf\" \n  where \"S2 v m =  do {\n  a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n  b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n  let c\\<^sub>v = (a*b) mod (order \\<G>);\n  r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n  r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n  let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n  s' \\<leftarrow> sample_uniform (order \\<G>);\n  let enc_m =  \\<^bold>g [^] s';\n  let enc_m' = z' \\<otimes> m ;\n  return_spmf(v, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["", "lemma lossless_S2: \"lossless_spmf (S2 \\<sigma> out2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (S2 \\<sigma> out2)", "apply(simp add: S2_def Let_def lossless_sample_uniform_units or_gt_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>x. x < order \\<G>) \\<longrightarrow>\n    lossless_spmf (sample_uniform_units (order \\<G>))", "using prime_order prime_gt_1_nat lossless_sample_uniform_units"], ["proof (prove)\nusing this:\n  prime (order \\<G>)\n  prime ?p \\<Longrightarrow> 1 < ?p\n  1 < ?q \\<Longrightarrow> lossless_spmf (sample_uniform_units ?q)\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x < order \\<G>) \\<longrightarrow>\n    lossless_spmf (sample_uniform_units (order \\<G>))", "by simp"], ["", "sublocale sim_def: sim_det_def R1 S1 R2 S2 funct_OT_12 protocol"], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_det_def R1 S1 R2 S2 funct_OT_12", "unfolding sim_det_def_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>m1 m2. lossless_spmf (R1 m1 m2)) \\<and>\n     (\\<forall>m1 out1. lossless_spmf (S1 m1 out1))) \\<and>\n    (\\<forall>m1 m2. lossless_spmf (R2 m1 m2)) \\<and>\n    (\\<forall>m2 out2. lossless_spmf (S2 m2 out2)) \\<and>\n    (\\<forall>m1 m2. lossless_spmf (funct_OT_12 m1 m2))", "by(auto simp add: lossless_R1 lossless_S1 lossless_R2 lossless_S2 lossless_protocol lossless_funct_OT_12)"], ["", "end"], ["", "locale np = np_base + cyclic_group \\<G>\nbegin"], ["", "lemma protocol_inverse: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\" \n  shows\" ((\\<^bold>g [^] ((a*b) mod (order \\<G>))) [^] (s1 :: nat)) \\<otimes> ((\\<^bold>g [^] b) [^] (r1::nat)) \\<otimes> (if v then m0 else m1) \\<otimes> inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) \n        = (if v then m0 else m1)\"\n(is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have  1: \"(a*b)*(s1) + b*r1 =((a::nat)*(s1) + r1)*b \""], ["proof (prove)\ngoal (1 subgoal):\n 1. a * b * s1 + b * r1 = (a * s1 + r1) * b", "using mult.commute mult.assoc  add_mult_distrib"], ["proof (prove)\nusing this:\n  ?a * ?b = ?b * ?a\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  (?m + ?n) * ?k = ?m * ?k + ?n * ?k\n\ngoal (1 subgoal):\n 1. a * b * s1 + b * r1 = (a * s1 + r1) * b", "by auto"], ["proof (state)\nthis:\n  a * b * s1 + b * r1 = (a * s1 + r1) * b\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have \"?lhs = \n ((\\<^bold>g [^] (a*b)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1) \\<otimes> (if v then m0 else m1) \\<otimes> inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b)", "by(simp add: pow_generator_mod)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have \"... = (\\<^bold>g [^] ((a*b)*(s1))) \\<otimes> ((\\<^bold>g [^] (b*r1))) \\<otimes> ((if v then m0 else m1) \\<otimes> inv (((\\<^bold>g [^] ((a*(s1) + r1)*b)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n    ((if v then m0 else m1) \\<otimes>\n     inv (\\<^bold>g [^] ((a * s1 + r1) * b)))", "by(auto simp add: nat_pow_pow nat_pow_mult assms cyclic_group_assoc)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  ((if v then m0 else m1) \\<otimes> inv (\\<^bold>g [^] ((a * s1 + r1) * b)))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (a * b)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  ((if v then m0 else m1) \\<otimes> inv (\\<^bold>g [^] ((a * s1 + r1) * b)))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have \"... = \\<^bold>g [^] ((a*b)*(s1)) \\<otimes> \\<^bold>g [^] (b*r1) \\<otimes> ((inv (((\\<^bold>g [^] ((a*(s1) + r1)*b))))) \\<otimes> (if v then m0 else m1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n    ((if v then m0 else m1) \\<otimes>\n     inv (\\<^bold>g [^] ((a * s1 + r1) * b))) =\n    \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n    (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n     (if v then m0 else m1))", "by(simp add: nat_pow_mult cyclic_group_commute assms)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  ((if v then m0 else m1) \\<otimes>\n   inv (\\<^bold>g [^] ((a * s1 + r1) * b))) =\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes> (if v then m0 else m1))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  ((if v then m0 else m1) \\<otimes>\n   inv (\\<^bold>g [^] ((a * s1 + r1) * b))) =\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes> (if v then m0 else m1))\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have \"... = (\\<^bold>g [^] ((a*b)*(s1) + b*r1) \\<otimes> inv (((\\<^bold>g [^] ((a*(s1) + r1)*b))))) \\<otimes> (if v then m0 else m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n    (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n     (if v then m0 else m1)) =\n    \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n    inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n    (if v then m0 else m1)", "by(simp add: nat_pow_mult cyclic_group_assoc assms)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n   (if v then m0 else m1)) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a * b * s1) \\<otimes> \\<^bold>g [^] (b * r1) \\<otimes>\n  (inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n   (if v then m0 else m1)) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "have \"... = (\\<^bold>g [^] ((a*b)*(s1) + b*r1) \\<otimes> inv (((\\<^bold>g [^] (((a*b)*(s1) + r1*b)))))) \\<otimes> (if v then m0 else m1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n    inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n    (if v then m0 else m1) =\n    \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n    inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n    (if v then m0 else m1)", "using 1"], ["proof (prove)\nusing this:\n  a * b * s1 + b * r1 = (a * s1 + r1) * b\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n    inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n    (if v then m0 else m1) =\n    \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n    inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n    (if v then m0 else m1)", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n  (if v then m0 else m1)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "ultimately"], ["proof (chain)\npicking this:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1)\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n  (if v then m0 else m1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1)\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n  (if v then m0 else m1)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "using l_cancel_inv assms"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1)\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] ((a * s1 + r1) * b)) \\<otimes>\n  (if v then m0 else m1) =\n  \\<^bold>g [^] (a * b * s1 + b * r1) \\<otimes>\n  inv (\\<^bold>g [^] (a * b * s1 + r1 * b)) \\<otimes>\n  (if v then m0 else m1)\n  ?h \\<in> carrier \\<G> \\<Longrightarrow>\n  \\<^bold>g [^] ?a \\<otimes> inv (\\<^bold>g [^] ?a) \\<otimes> ?h = ?h\n  m0 \\<in> carrier \\<G>\n  m1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n    (\\<^bold>g [^] b) [^] r1 \\<otimes>\n    (if v then m0 else m1) \\<otimes>\n    inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n    (if v then m0 else m1)", "by (simp add: mult.commute)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (a * b mod order \\<G>)) [^] s1 \\<otimes>\n  (\\<^bold>g [^] b) [^] r1 \\<otimes>\n  (if v then m0 else m1) \\<otimes>\n  inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b) =\n  (if v then m0 else m1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma correctness: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\" \n  shows \"sim_def.correctness (m0,m1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.correctness (m0, m1) \\<sigma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sim_def.correctness (m0, m1) \\<sigma>", "have \"protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "have \"protocol (m0, m1) \\<sigma> = do {\n    a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n    let out_2 = ((\\<^bold>g [^] ((a*b) mod (order \\<G>))) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1) \\<otimes> (if \\<sigma> then m1 else m0) \\<otimes> inv (((\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1) [^] b);\n    return_spmf ((), out_2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            sample_uniform_units (order \\<G>) \\<bind>\n            (\\<lambda>r1.\n                sample_uniform_units (order \\<G>) \\<bind>\n                (\\<lambda>s1.\n                    let out_2 =\n                          (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                          s1 \\<otimes>\n                          (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                          (if \\<sigma> then m1 else m0) \\<otimes>\n                          inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                                \\<^bold>g [^] r1) [^]\n                               b)\n                    in return_spmf ((), out_2)))))", "by(simp add: protocol_def lossless_sample_uniform_units bind_spmf_const weight_sample_uniform_units or_gt_0)"], ["proof (state)\nthis:\n  protocol (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2)))))\n\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "also"], ["proof (state)\nthis:\n  protocol (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2)))))\n\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "have \"... = do {   \n    let out_2 = (if \\<sigma> then m1 else m0);\n    return_spmf ((), out_2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            sample_uniform_units (order \\<G>) \\<bind>\n            (\\<lambda>r1.\n                sample_uniform_units (order \\<G>) \\<bind>\n                (\\<lambda>s1.\n                    let out_2 =\n                          (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                          s1 \\<otimes>\n                          (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                          (if \\<sigma> then m1 else m0) \\<otimes>\n                          inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                                \\<^bold>g [^] r1) [^]\n                               b)\n                    in return_spmf ((), out_2))))) =\n    (let out_2 = if \\<sigma> then m1 else m0 in return_spmf ((), out_2))", "by(simp add: protocol_inverse assms lossless_sample_uniform_units bind_spmf_const weight_sample_uniform_units or_gt_0)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2))))) =\n  (let out_2 = if \\<sigma> then m1 else m0 in return_spmf ((), out_2))\n\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "ultimately"], ["proof (chain)\npicking this:\n  protocol (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2)))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2))))) =\n  (let out_2 = if \\<sigma> then m1 else m0 in return_spmf ((), out_2))", "show ?thesis"], ["proof (prove)\nusing this:\n  protocol (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2)))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          sample_uniform_units (order \\<G>) \\<bind>\n          (\\<lambda>r1.\n              sample_uniform_units (order \\<G>) \\<bind>\n              (\\<lambda>s1.\n                  let out_2 =\n                        (\\<^bold>g [^] (a * b mod order \\<G>)) [^]\n                        s1 \\<otimes>\n                        (\\<^bold>g [^] b) [^] r1 \\<otimes>\n                        (if \\<sigma> then m1 else m0) \\<otimes>\n                        inv (((\\<^bold>g [^] a) [^] s1 \\<otimes>\n                              \\<^bold>g [^] r1) [^]\n                             b)\n                  in return_spmf ((), out_2))))) =\n  (let out_2 = if \\<sigma> then m1 else m0 in return_spmf ((), out_2))\n\ngoal (1 subgoal):\n 1. protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>", "by(simp add: Let_def funct_OT_12_def)"], ["proof (state)\nthis:\n  protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>\n\ngoal (1 subgoal):\n 1. sim_def.correctness (m0, m1) \\<sigma>", "thus ?thesis"], ["proof (prove)\nusing this:\n  protocol (m0, m1) \\<sigma> = funct_OT_12 (m0, m1) \\<sigma>\n\ngoal (1 subgoal):\n 1. sim_def.correctness (m0, m1) \\<sigma>", "by(simp add: sim_def.correctness_def)"], ["proof (state)\nthis:\n  sim_def.correctness (m0, m1) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma security_P1: \n  shows \"sim_def.adv_P1 msgs \\<sigma> D \\<le> ddh.advantage (R1_inter_adversary D msgs) + ddh.advantage (inter_S1_adversary D msgs)\"\n    (is \"?lhs \\<le> ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "proof(cases \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "case True"], ["proof (state)\nthis:\n  \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "have \"R1 msgs \\<sigma> = S1 msgs out1\" for out1"], ["proof (prove)\ngoal (1 subgoal):\n 1. R1 msgs \\<sigma> = S1 msgs out1", "by(simp add: R1_def S1_def True)"], ["proof (state)\nthis:\n  R1 msgs \\<sigma> = S1 msgs ?out1.0\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "then"], ["proof (chain)\npicking this:\n  R1 msgs \\<sigma> = S1 msgs ?out1.0", "have \"sim_def.adv_P1 msgs \\<sigma> D = 0\""], ["proof (prove)\nusing this:\n  R1 msgs \\<sigma> = S1 msgs ?out1.0\n\ngoal (1 subgoal):\n 1. sim_def.adv_P1 msgs \\<sigma> D = 0", "by(simp add: sim_def.adv_P1_def funct_OT_12_def)"], ["proof (state)\nthis:\n  sim_def.adv_P1 msgs \\<sigma> D = 0\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "also"], ["proof (state)\nthis:\n  sim_def.adv_P1 msgs \\<sigma> D = 0\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "have \"ddh.advantage A \\<ge> 0\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> local.ddh.advantage A", "using ddh.advantage_def"], ["proof (prove)\nusing this:\n  local.ddh.advantage ?\\<A> =\n  \\<bar>spmf (local.ddh.ddh_0 ?\\<A>) True -\n        spmf (local.ddh.ddh_1 ?\\<A>) True\\<bar>\n\ngoal (1 subgoal):\n 1. 0 \\<le> local.ddh.advantage A", "by simp"], ["proof (state)\nthis:\n  0 \\<le> local.ddh.advantage ?A\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "ultimately"], ["proof (chain)\npicking this:\n  sim_def.adv_P1 msgs \\<sigma> D = 0\n  0 \\<le> local.ddh.advantage ?A", "show ?thesis"], ["proof (prove)\nusing this:\n  sim_def.adv_P1 msgs \\<sigma> D = 0\n  0 \\<le> local.ddh.advantage ?A\n\ngoal (1 subgoal):\n 1. sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "by simp"], ["proof (state)\nthis:\n  sim_def.adv_P1 msgs \\<sigma> D\n  \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n        local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "have bounded_advantage: \"\\<bar>(a :: real) - b\\<bar> = e1 \\<Longrightarrow> \\<bar>b - c\\<bar> = e2 \\<Longrightarrow> \\<bar>a - c\\<bar> \\<le> e1 + e2\" \n    for a b e1 c e2"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<bar>a - b\\<bar> = e1; \\<bar>b - c\\<bar> = e2\\<rbrakk>\n    \\<Longrightarrow> \\<bar>a - c\\<bar> \\<le> e1 + e2", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<bar>?a - ?b\\<bar> = ?e1.0; \\<bar>?b - ?c\\<bar> = ?e2.0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>?a - ?c\\<bar> \\<le> ?e1.0 + ?e2.0\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "also"], ["proof (state)\nthis:\n  \\<lbrakk>\\<bar>?a - ?b\\<bar> = ?e1.0; \\<bar>?b - ?c\\<bar> = ?e2.0\\<rbrakk>\n  \\<Longrightarrow> \\<bar>?a - ?c\\<bar> \\<le> ?e1.0 + ?e2.0\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "have R1_inter_dist: \"\\<bar>spmf (R1 msgs False \\<bind> D) True - spmf ((inter msgs) \\<bind> D) True\\<bar> = ddh.advantage (R1_inter_adversary D msgs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (local.inter msgs \\<bind> D) True\\<bar> =\n    local.ddh.advantage (R1_inter_adversary D msgs)", "unfolding R1_def inter_def ddh.advantage_def ddh.ddh_0_def ddh.ddh_1_def Let_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>a.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>b.\n                    sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>c\\<^sub>\\<sigma>'.\n                        return_spmf\n                         (msgs, \\<^bold>g [^] a, \\<^bold>g [^] b,\n                          if False then \\<^bold>g [^] c\\<^sub>\\<sigma>'\n                          else \\<^bold>g [^] (a * b),\n                          if False then \\<^bold>g [^] (a * b)\n                          else \\<^bold>g [^] c\\<^sub>\\<sigma>')))) \\<bind>\n            D)\n           True -\n          spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>a.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>b.\n                    sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>c.\n                        sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>d.\n                            return_spmf\n                             (msgs, \\<^bold>g [^] a, \\<^bold>g [^] b,\n                              \\<^bold>g [^] c, \\<^bold>g [^] d))))) \\<bind>\n            D)\n           True\\<bar> =\n    \\<bar>spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>y.\n                    R1_inter_adversary D msgs (\\<^bold>g [^] x)\n                     (\\<^bold>g [^] y) (\\<^bold>g [^] (x * y)))))\n           True -\n          spmf\n           (sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>y.\n                    sample_uniform (order \\<G>) \\<bind>\n                    (\\<lambda>z.\n                        R1_inter_adversary D msgs (\\<^bold>g [^] x)\n                         (\\<^bold>g [^] y) (\\<^bold>g [^] z)))))\n           True\\<bar>", "by(simp)"], ["proof (state)\nthis:\n  \\<bar>spmf (R1 msgs False \\<bind> D) True -\n        spmf (local.inter msgs \\<bind> D) True\\<bar> =\n  local.ddh.advantage (R1_inter_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "also"], ["proof (state)\nthis:\n  \\<bar>spmf (R1 msgs False \\<bind> D) True -\n        spmf (local.inter msgs \\<bind> D) True\\<bar> =\n  local.ddh.advantage (R1_inter_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "have inter_S1_dist: \"\\<bar>spmf ((inter msgs) \\<bind> D) True - spmf (S1 msgs out1 \\<bind> D) True\\<bar> = ddh.advantage (inter_S1_adversary D msgs)\" \n    for out1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.inter msgs \\<bind> D) True -\n          spmf (S1 msgs out1 \\<bind> D) True\\<bar> =\n    local.ddh.advantage (inter_S1_adversary D msgs)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (local.inter msgs \\<bind> D) True -\n          spmf (S1 msgs out1 \\<bind> D) True\\<bar> =\n    local.ddh.advantage (inter_S1_adversary D msgs)", "by(simp add: S1_def inter_def ddh.advantage_def ddh.ddh_0_def ddh.ddh_1_def)"], ["proof (state)\nthis:\n  \\<bar>spmf (local.inter msgs \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar> =\n  local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<bar>spmf (R1 msgs False \\<bind> D) True - ?b1\\<bar> =\n           ?e1.3\n            \\<bar>spmf (R1 msgs False \\<bind> D) True -\n                  spmf (local.inter msgs \\<bind> D) True\\<bar>;\n   \\<bar>?b1 - spmf (local.inter msgs \\<bind> D) True\\<bar> =\n   ?e2.2\n    \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (local.inter msgs \\<bind> D) True\\<bar>\\<rbrakk>\n  \\<Longrightarrow> local.ddh.advantage (R1_inter_adversary D msgs)\n                    \\<le> ?e1.3\n                           (local.ddh.advantage\n                             (R1_inter_adversary D msgs)) +\n                          ?e2.2\n                           (local.ddh.advantage (R1_inter_adversary D msgs))\n  \\<bar>spmf (local.inter msgs \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar> =\n  local.ddh.advantage (inter_S1_adversary D msgs)", "have \"\\<bar>spmf (R1 msgs False \\<bind> (\\<lambda>view. D view)) True - spmf (S1 msgs out1 \\<bind> (\\<lambda>view. D view)) True\\<bar> \\<le> ?rhs\"\n    for out1"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<bar>spmf (R1 msgs False \\<bind> D) True - ?b1\\<bar> =\n           ?e1.3\n            \\<bar>spmf (R1 msgs False \\<bind> D) True -\n                  spmf (local.inter msgs \\<bind> D) True\\<bar>;\n   \\<bar>?b1 - spmf (local.inter msgs \\<bind> D) True\\<bar> =\n   ?e2.2\n    \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (local.inter msgs \\<bind> D) True\\<bar>\\<rbrakk>\n  \\<Longrightarrow> local.ddh.advantage (R1_inter_adversary D msgs)\n                    \\<le> ?e1.3\n                           (local.ddh.advantage\n                             (R1_inter_adversary D msgs)) +\n                          ?e2.2\n                           (local.ddh.advantage (R1_inter_adversary D msgs))\n  \\<bar>spmf (local.inter msgs \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar> =\n  local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (S1 msgs out1 \\<bind> D) True\\<bar>\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "using R1_inter_dist"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<bar>spmf (R1 msgs False \\<bind> D) True - ?b1\\<bar> =\n           ?e1.3\n            \\<bar>spmf (R1 msgs False \\<bind> D) True -\n                  spmf (local.inter msgs \\<bind> D) True\\<bar>;\n   \\<bar>?b1 - spmf (local.inter msgs \\<bind> D) True\\<bar> =\n   ?e2.2\n    \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (local.inter msgs \\<bind> D) True\\<bar>\\<rbrakk>\n  \\<Longrightarrow> local.ddh.advantage (R1_inter_adversary D msgs)\n                    \\<le> ?e1.3\n                           (local.ddh.advantage\n                             (R1_inter_adversary D msgs)) +\n                          ?e2.2\n                           (local.ddh.advantage (R1_inter_adversary D msgs))\n  \\<bar>spmf (local.inter msgs \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar> =\n  local.ddh.advantage (inter_S1_adversary D msgs)\n  \\<bar>spmf (R1 msgs False \\<bind> D) True -\n        spmf (local.inter msgs \\<bind> D) True\\<bar> =\n  local.ddh.advantage (R1_inter_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<bar>spmf (R1 msgs False \\<bind> D) True -\n          spmf (S1 msgs out1 \\<bind> D) True\\<bar>\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "by auto"], ["proof (state)\nthis:\n  \\<bar>spmf (R1 msgs False \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar>\n  \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n        local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>spmf (R1 msgs False \\<bind> D) True -\n        spmf (S1 msgs ?out1.0 \\<bind> D) True\\<bar>\n  \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n        local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal (1 subgoal):\n 1. sim_def.adv_P1 msgs \\<sigma> D\n    \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n          local.ddh.advantage (inter_S1_adversary D msgs)", "by(simp add: sim_def.adv_P1_def funct_OT_12_def False)"], ["proof (state)\nthis:\n  sim_def.adv_P1 msgs \\<sigma> D\n  \\<le> local.ddh.advantage (R1_inter_adversary D msgs) +\n        local.ddh.advantage (inter_S1_adversary D msgs)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma add_mult_one_time_pad: \n  assumes \"s0 < order \\<G>\" \n    and \"s0 \\<noteq> 0\"\n  shows \"map_spmf (\\<lambda> c\\<^sub>v'. (((b* r0) + (s0 * c\\<^sub>v')) mod(order \\<G>))) (sample_uniform (order \\<G>)) = sample_uniform (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n     (sample_uniform (order \\<G>)) =\n    sample_uniform (order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n     (sample_uniform (order \\<G>)) =\n    sample_uniform (order \\<G>)", "have \"gcd s0 (order \\<G>) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd s0 (order \\<G>) = 1", "using assms prime_field"], ["proof (prove)\nusing this:\n  s0 < order \\<G>\n  s0 \\<noteq> 0\n  \\<lbrakk>?a < order \\<G>; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a (order \\<G>)\n\ngoal (1 subgoal):\n 1. gcd s0 (order \\<G>) = 1", "by simp"], ["proof (state)\nthis:\n  gcd s0 (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n     (sample_uniform (order \\<G>)) =\n    sample_uniform (order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  gcd s0 (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n     (sample_uniform (order \\<G>)) =\n    sample_uniform (order \\<G>)", "using add_mult_one_time_pad"], ["proof (prove)\nusing this:\n  gcd s0 (order \\<G>) = 1\n  coprime ?x ?q \\<Longrightarrow>\n  map_spmf (\\<lambda>b. (?y + ?x * b) mod ?q) (sample_uniform ?q) =\n  sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n     (sample_uniform (order \\<G>)) =\n    sample_uniform (order \\<G>)", "by force"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>c\\<^sub>v'. (b * r0 + s0 * c\\<^sub>v') mod order \\<G>)\n   (sample_uniform (order \\<G>)) =\n  sample_uniform (order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma security_P2: \n  assumes \"m0 \\<in> carrier \\<G>\" \"m1 \\<in> carrier \\<G>\"\n  shows \"sim_def.perfect_sec_P2 (m0,m1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.perfect_sec_P2 (m0, m1) \\<sigma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. sim_def.perfect_sec_P2 (m0, m1) \\<sigma>", "have \"R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "have \"R2 (m0, m1) \\<sigma> = do {\n      a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      let c\\<^sub>v = (a*b) mod (order \\<G>);\n      c\\<^sub>v' :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n      let s' = (((b* r0) + ((c\\<^sub>v')*(s0))) mod(order \\<G>));\n      let z = \\<^bold>g [^] s' ;\n      r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n      let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n      let enc_m = z \\<otimes> (if \\<sigma> then m0 else m1); \n      let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0) ;\n      return_spmf(\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform (order \\<G>) \\<bind>\n               (\\<lambda>c\\<^sub>v'.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>r0.\n                       sample_uniform_units (order \\<G>) \\<bind>\n                       (\\<lambda>s0.\n                           let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                    \\<^bold>g [^] r0;\n                               s' = (b * r0 + c\\<^sub>v' * s0) mod\n                                    order \\<G>;\n                               z = \\<^bold>g [^] s'\n                           in sample_uniform_units (order \\<G>) \\<bind>\n                              (\\<lambda>r1.\n                                  sample_uniform_units (order \\<G>) \\<bind>\n                                  (\\<lambda>s1.\nlet w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n    z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n         (\\<^bold>g [^] b) [^] r1;\n    enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n    enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\nin return_spmf\n    (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n     w0, enc_m, w1, enc_m'))))))))", "by(simp add: R2_def nat_pow_pow nat_pow_mult pow_generator_mod add.commute)"], ["proof (state)\nthis:\n  R2 (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>c\\<^sub>v'.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>r0.\n                     sample_uniform_units (order \\<G>) \\<bind>\n                     (\\<lambda>s0.\n                         let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                  \\<^bold>g [^] r0;\n                             s' = (b * r0 + c\\<^sub>v' * s0) mod order \\<G>;\n                             z = \\<^bold>g [^] s'\n                         in sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>r1.\n                                sample_uniform_units (order \\<G>) \\<bind>\n                                (\\<lambda>s1.\n                                    let w1 =\n    (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1;\n  enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n  enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n                                    in return_spmf\n  (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0,\n   enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "also"], ["proof (state)\nthis:\n  R2 (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>c\\<^sub>v'.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>r0.\n                     sample_uniform_units (order \\<G>) \\<bind>\n                     (\\<lambda>s0.\n                         let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                  \\<^bold>g [^] r0;\n                             s' = (b * r0 + c\\<^sub>v' * s0) mod order \\<G>;\n                             z = \\<^bold>g [^] s'\n                         in sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>r1.\n                                sample_uniform_units (order \\<G>) \\<bind>\n                                (\\<lambda>s1.\n                                    let w1 =\n    (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1;\n  enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n  enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n                                    in return_spmf\n  (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0,\n   enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "have \"... =  do {\n      a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      let c\\<^sub>v = (a*b) mod (order \\<G>);\n      r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n      s' \\<leftarrow> map_spmf (\\<lambda> c\\<^sub>v'. (((b* r0) + ((c\\<^sub>v')*(s0))) mod(order \\<G>))) (sample_uniform (order \\<G>));\n      let z = \\<^bold>g [^] s';\n      r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n      let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n      let enc_m = z \\<otimes> (if \\<sigma> then m0 else m1); \n      let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0) ;\n      return_spmf(\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform (order \\<G>) \\<bind>\n               (\\<lambda>c\\<^sub>v'.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>r0.\n                       sample_uniform_units (order \\<G>) \\<bind>\n                       (\\<lambda>s0.\n                           let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                    \\<^bold>g [^] r0;\n                               s' = (b * r0 + c\\<^sub>v' * s0) mod\n                                    order \\<G>;\n                               z = \\<^bold>g [^] s'\n                           in sample_uniform_units (order \\<G>) \\<bind>\n                              (\\<lambda>r1.\n                                  sample_uniform_units (order \\<G>) \\<bind>\n                                  (\\<lambda>s1.\nlet w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n    z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n         (\\<^bold>g [^] b) [^] r1;\n    enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n    enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\nin return_spmf\n    (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n     w0, enc_m, w1, enc_m')))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in map_spmf\n                           (\\<lambda>c\\<^sub>v'.\n                               (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>s'.\n                              let z = \\<^bold>g [^] s'\n                              in sample_uniform_units (order \\<G>) \\<bind>\n                                 (\\<lambda>r1.\n                                     sample_uniform_units\n(order \\<G>) \\<bind>\n                                     (\\<lambda>s1.\n   let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n       z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n            (\\<^bold>g [^] b) [^] r1;\n       enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n       enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m'))))))))", "by(simp add: bind_map_spmf o_def Let_def)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>c\\<^sub>v'.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>r0.\n                     sample_uniform_units (order \\<G>) \\<bind>\n                     (\\<lambda>s0.\n                         let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                  \\<^bold>g [^] r0;\n                             s' = (b * r0 + c\\<^sub>v' * s0) mod order \\<G>;\n                             z = \\<^bold>g [^] s'\n                         in sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>r1.\n                                sample_uniform_units (order \\<G>) \\<bind>\n                                (\\<lambda>s1.\n                                    let w1 =\n    (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1;\n  enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n  enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n                                    in return_spmf\n  (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0,\n   enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in map_spmf\n                         (\\<lambda>c\\<^sub>v'.\n                             (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform (order \\<G>) \\<bind>\n             (\\<lambda>c\\<^sub>v'.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>r0.\n                     sample_uniform_units (order \\<G>) \\<bind>\n                     (\\<lambda>s0.\n                         let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                  \\<^bold>g [^] r0;\n                             s' = (b * r0 + c\\<^sub>v' * s0) mod order \\<G>;\n                             z = \\<^bold>g [^] s'\n                         in sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>r1.\n                                sample_uniform_units (order \\<G>) \\<bind>\n                                (\\<lambda>s1.\n                                    let w1 =\n    (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n  z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1;\n  enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n  enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n                                    in return_spmf\n  (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0,\n   enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in map_spmf\n                         (\\<lambda>c\\<^sub>v'.\n                             (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "have \"... =  do {\n      a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      let c\\<^sub>v = (a*b) mod (order \\<G>);\n      r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n      s' \\<leftarrow>  (sample_uniform (order \\<G>));\n      let z = \\<^bold>g [^] s';\n      r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n      let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n      let enc_m = z \\<otimes> (if \\<sigma> then m0 else m1); \n      let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0) ;\n      return_spmf(\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in map_spmf\n                           (\\<lambda>c\\<^sub>v'.\n                               (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                           (sample_uniform (order \\<G>)) \\<bind>\n                          (\\<lambda>s'.\n                              let z = \\<^bold>g [^] s'\n                              in sample_uniform_units (order \\<G>) \\<bind>\n                                 (\\<lambda>r1.\n                                     sample_uniform_units\n(order \\<G>) \\<bind>\n                                     (\\<lambda>s1.\n   let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n       z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n            (\\<^bold>g [^] b) [^] r1;\n       enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n       enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m')))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in sample_uniform (order \\<G>) \\<bind>\n                          (\\<lambda>s'.\n                              let z = \\<^bold>g [^] s'\n                              in sample_uniform_units (order \\<G>) \\<bind>\n                                 (\\<lambda>r1.\n                                     sample_uniform_units\n(order \\<G>) \\<bind>\n                                     (\\<lambda>s1.\n   let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n       z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n            (\\<^bold>g [^] b) [^] r1;\n       enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n       enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m'))))))))", "by(simp add: add_mult_one_time_pad Let_def mult.commute cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in map_spmf\n                         (\\<lambda>c\\<^sub>v'.\n                             (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in map_spmf\n                         (\\<lambda>c\\<^sub>v'.\n                             (b * r0 + c\\<^sub>v' * s0) mod order \\<G>)\n                         (sample_uniform (order \\<G>)) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "have \"... =  do {\n      a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      let c\\<^sub>v = (a*b) mod (order \\<G>);\n      r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n      r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n      let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n      enc_m \\<leftarrow> map_spmf (\\<lambda> s'.  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1)) (sample_uniform (order \\<G>)); \n      let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0) ;\n      return_spmf(\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in sample_uniform (order \\<G>) \\<bind>\n                          (\\<lambda>s'.\n                              let z = \\<^bold>g [^] s'\n                              in sample_uniform_units (order \\<G>) \\<bind>\n                                 (\\<lambda>r1.\n                                     sample_uniform_units\n(order \\<G>) \\<bind>\n                                     (\\<lambda>s1.\n   let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n       z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n            (\\<^bold>g [^] b) [^] r1;\n       enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n       enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m')))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in sample_uniform_units (order \\<G>) \\<bind>\n                          (\\<lambda>r1.\n                              sample_uniform_units (order \\<G>) \\<bind>\n                              (\\<lambda>s1.\n                                  let w1 =\n  (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\nz' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                  in map_spmf\n(\\<lambda>s'. \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n(sample_uniform (order \\<G>)) \\<bind>\n                                     (\\<lambda>enc_m.\n   let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m'))))))))", "by(simp add: bind_map_spmf o_def Let_def)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform (order \\<G>) \\<bind>\n                        (\\<lambda>s'.\n                            let z = \\<^bold>g [^] s'\n                            in sample_uniform_units (order \\<G>) \\<bind>\n                               (\\<lambda>r1.\n                                   sample_uniform_units (order \\<G>) \\<bind>\n                                   (\\<lambda>s1.\n let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n     z' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes>\n          (\\<^bold>g [^] b) [^] r1;\n     enc_m = z \\<otimes> (if \\<sigma> then m0 else m1);\n     enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "have \"... =  do {\n      a :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      b :: nat \\<leftarrow> sample_uniform (order \\<G>);\n      let c\\<^sub>v = (a*b) mod (order \\<G>);\n      r0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s0 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes> \\<^bold>g [^] r0;\n      r1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      s1 :: nat \\<leftarrow> sample_uniform_units (order \\<G>);\n      let w1 = (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n      let z' = ((\\<^bold>g [^] (c\\<^sub>v)) [^] s1) \\<otimes> ((\\<^bold>g [^] b) [^] r1);\n      enc_m \\<leftarrow> map_spmf (\\<lambda> s'.  \\<^bold>g [^] s') (sample_uniform (order \\<G>)); \n      let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0) ;\n      return_spmf(\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v, w0, enc_m, w1, enc_m')}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in sample_uniform_units (order \\<G>) \\<bind>\n                          (\\<lambda>r1.\n                              sample_uniform_units (order \\<G>) \\<bind>\n                              (\\<lambda>s1.\n                                  let w1 =\n  (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\nz' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                  in map_spmf\n(\\<lambda>s'. \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n(sample_uniform (order \\<G>)) \\<bind>\n                                     (\\<lambda>enc_m.\n   let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m')))))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>a.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>b.\n            let c\\<^sub>v = a * b mod order \\<G>\n            in sample_uniform_units (order \\<G>) \\<bind>\n               (\\<lambda>r0.\n                   sample_uniform_units (order \\<G>) \\<bind>\n                   (\\<lambda>s0.\n                       let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                                \\<^bold>g [^] r0\n                       in sample_uniform_units (order \\<G>) \\<bind>\n                          (\\<lambda>r1.\n                              sample_uniform_units (order \\<G>) \\<bind>\n                              (\\<lambda>s1.\n                                  let w1 =\n  (\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\nz' = (\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                  in map_spmf (([^]) \\<^bold>g)\n(sample_uniform (order \\<G>)) \\<bind>\n                                     (\\<lambda>enc_m.\n   let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n   in return_spmf\n       (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n        w0, enc_m, w1, enc_m'))))))))", "by(simp add: sample_uniform_one_time_pad assms)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf (([^]) \\<^bold>g)\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "ultimately"], ["proof (chain)\npicking this:\n  R2 (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf (([^]) \\<^bold>g)\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  R2 (m0, m1) \\<sigma> =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf\n                                    (\\<lambda>s'.\n  \\<^bold>g [^] s' \\<otimes> (if \\<sigma> then m0 else m1))\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m')))))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>a.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>b.\n          let c\\<^sub>v = a * b mod order \\<G>\n          in sample_uniform_units (order \\<G>) \\<bind>\n             (\\<lambda>r0.\n                 sample_uniform_units (order \\<G>) \\<bind>\n                 (\\<lambda>s0.\n                     let w0 = (\\<^bold>g [^] a) [^] s0 \\<otimes>\n                              \\<^bold>g [^] r0\n                     in sample_uniform_units (order \\<G>) \\<bind>\n                        (\\<lambda>r1.\n                            sample_uniform_units (order \\<G>) \\<bind>\n                            (\\<lambda>s1.\n                                let w1 =\n(\\<^bold>g [^] a) [^] s1 \\<otimes> \\<^bold>g [^] r1;\n                                    z' =\n(\\<^bold>g [^] c\\<^sub>v) [^] s1 \\<otimes> (\\<^bold>g [^] b) [^] r1\n                                in map_spmf (([^]) \\<^bold>g)\n                                    (sample_uniform (order \\<G>)) \\<bind>\n                                   (\\<lambda>enc_m.\n let enc_m' = z' \\<otimes> (if \\<sigma> then m1 else m0)\n in return_spmf\n     (\\<sigma>, \\<^bold>g [^] a, \\<^bold>g [^] b, \\<^bold>g [^] c\\<^sub>v,\n      w0, enc_m, w1, enc_m'))))))))\n\ngoal (1 subgoal):\n 1. R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)", "by(simp add: S2_def Let_def bind_map_spmf o_def)"], ["proof (state)\nthis:\n  R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)\n\ngoal (1 subgoal):\n 1. sim_def.perfect_sec_P2 (m0, m1) \\<sigma>", "thus ?thesis"], ["proof (prove)\nusing this:\n  R2 (m0, m1) \\<sigma> = S2 \\<sigma> (if \\<sigma> then m1 else m0)\n\ngoal (1 subgoal):\n 1. sim_def.perfect_sec_P2 (m0, m1) \\<sigma>", "by(simp add: sim_def.perfect_sec_P2_def funct_OT_12_def)"], ["proof (state)\nthis:\n  sim_def.perfect_sec_P2 (m0, m1) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale np_asymp = \n  fixes \\<G> :: \"security \\<Rightarrow> 'grp cyclic_group\"\n  assumes np: \"\\<And>\\<eta>. np (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale np \"\\<G> \\<eta>\" for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. np (\\<G> \\<eta>)", "by(simp add: np)"], ["", "theorem correctness_asymp: \n  assumes \"m0 \\<in> carrier (\\<G> \\<eta>)\" \"m1 \\<in> carrier (\\<G> \\<eta>)\"\n  shows \"sim_def.correctness \\<eta> (m0, m1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.correctness \\<eta> (m0, m1) \\<sigma>", "by(simp add: correctness assms)"], ["", "theorem security_P1_asymp: \n  assumes \"negligible (\\<lambda> \\<eta>. ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\"\n    and \"negligible (\\<lambda> \\<eta>. ddh.advantage \\<eta> (R1_inter_adversary \\<eta>  D msgs))\"\n  shows \"negligible (\\<lambda> \\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "have \"sim_def.adv_P1 \\<eta> msgs \\<sigma> D \\<le> ddh.advantage \\<eta> (R1_inter_adversary \\<eta>  D msgs) + ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs)\" \n    for \\<eta>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.adv_P1 \\<eta> msgs \\<sigma> D\n    \\<le> local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n          local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs)", "using security_P1"], ["proof (prove)\nusing this:\n  sim_def.adv_P1 ?\\<eta> ?msgs ?\\<sigma> ?D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> ?D ?msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> ?D ?msgs)\n\ngoal (1 subgoal):\n 1. sim_def.adv_P1 \\<eta> msgs \\<sigma> D\n    \\<le> local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n          local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs)", "by simp"], ["proof (state)\nthis:\n  sim_def.adv_P1 ?\\<eta> msgs \\<sigma> D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> D msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> D msgs)\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "moreover"], ["proof (state)\nthis:\n  sim_def.adv_P1 ?\\<eta> msgs \\<sigma> D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> D msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> D msgs)\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "have \"negligible (\\<lambda> \\<eta>. ddh.advantage \\<eta> (R1_inter_adversary \\<eta>  D msgs) + ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>.\n         local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n         local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))", "using assms"], ["proof (prove)\nusing this:\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>.\n         local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n         local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))", "by (simp add: negligible_plus)"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n       local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "ultimately"], ["proof (chain)\npicking this:\n  sim_def.adv_P1 ?\\<eta> msgs \\<sigma> D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> D msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> D msgs)\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n       local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))", "show ?thesis"], ["proof (prove)\nusing this:\n  sim_def.adv_P1 ?\\<eta> msgs \\<sigma> D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> D msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> D msgs)\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n       local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "using negligible_le sim_def.adv_P1_def"], ["proof (prove)\nusing this:\n  sim_def.adv_P1 ?\\<eta> msgs \\<sigma> D\n  \\<le> local.ddh.advantage ?\\<eta> (R1_inter_adversary ?\\<eta> D msgs) +\n        local.ddh.advantage ?\\<eta> (inter_S1_adversary ?\\<eta> D msgs)\n  Negligible.negligible\n   (\\<lambda>\\<eta>.\n       local.ddh.advantage \\<eta> (R1_inter_adversary \\<eta> D msgs) +\n       local.ddh.advantage \\<eta> (inter_S1_adversary \\<eta> D msgs))\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  sim_def.adv_P1 ?\\<eta> ?m1.0 ?m2.0 ?D \\<equiv>\n  \\<bar>spmf (R1 ?\\<eta> ?m1.0 ?m2.0 \\<bind> ?D) True -\n        spmf\n         (funct_OT_12 ?m1.0 ?m2.0 \\<bind>\n          (\\<lambda>(o1, o2). S1 ?\\<eta> ?m1.0 o1 \\<bind> ?D))\n         True\\<bar>\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)", "by auto"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>\\<eta>. sim_def.adv_P1 \\<eta> msgs \\<sigma> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem security_P2_asymp: \n  assumes \"m0 \\<in> carrier (\\<G> \\<eta>)\" \"m1 \\<in> carrier (\\<G> \\<eta>)\"\n  shows \"sim_def.perfect_sec_P2 \\<eta> (m0,m1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sim_def.perfect_sec_P2 \\<eta> (m0, m1) \\<sigma>", "by(simp add: security_P2 assms)"], ["", "end"], ["", "end"]]}