{"file_name": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation/Uniform_Sampling.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation", "problem_names": ["lemma set_spmf_sampl_uni_units [simp]: \"set_spmf (sample_uniform_units q) = {..< q} - {0}\"", "lemma lossless_sample_uniform_units: \n  assumes \"q > 1\"\n  shows \"lossless_spmf (sample_uniform_units q)\"", "lemma one_time_pad_units: \n  assumes inj_on: \"inj_on f ({..<q} - {0})\" \n    and sur: \"f ` ({..<q} - {0}) = ({..<q} - {0})\"  \n  shows \"map_spmf f (sample_uniform_units q) = (sample_uniform_units q)\"\n    (is \"?lhs = ?rhs\")", "lemma one_time_pad: \n  assumes inj_on: \"inj_on f {..<q}\" \n    and sur: \"f ` {..<q} = {..<q}\"  \n  shows \"map_spmf f (sample_uniform q) = (sample_uniform q)\"\n    (is \"?lhs = ?rhs\")", "lemma inj_add: \n  assumes x:  \"x < q\" \n    and x': \"x' < q\" \n    and map: \"((y :: nat) + x) mod q = (y + x') mod q\"  \n  shows \"x = x'\"", "lemma inj_uni_samp_add: \"inj_on (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\"", "lemma surj_uni_samp: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + b) mod q) ` {..< q} =  {..< q}\"", "lemma samp_uni_plus_one_time_pad: \n  shows \"map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) = (sample_uniform q)\"", "lemma inj_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and y: \"y < q\" \n    and y': \"y' < q\" \n  and map: \"x * y mod q = x * y' mod q\" \nshows \"y = y'\"", "lemma inj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"", "lemma surj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"\n  shows \"(\\<lambda> b. x*b mod q) ` {..< q} = {..< q}\"", "lemma mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform q) = (sample_uniform q)\"", "lemma inj_on_mult_units: \n  assumes 1: \"coprime x (q::nat)\" shows \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"", "lemma surj_on_mult_units: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"\n  shows \"(\\<lambda> b. x*b mod q) ` ({..<q} - {0}) = ({..<q} - {0})\"", "lemma mult_one_time_pad_units: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform_units q) = sample_uniform_units q\"", "lemma samp_uni_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and xa: \"xa < q\" \n    and ya: \"ya < q\" \n    and map: \"(y + x * xa) mod q = (y + x * ya) mod q\" \n  shows \"xa = ya\"", "lemma inj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\"", "lemma surj_on_add_mult: assumes coprime: \"coprime x (q::nat)\" and inj: \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\" \n  shows \"(\\<lambda> b. (y + x*b) mod q) ` {..< q} = {..< q}\"", "lemma add_mult_one_time_pad: assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. (y + x*b) mod q) (sample_uniform q) = (sample_uniform q)\"", "lemma inj_minus: \n  assumes x: \"(x :: nat) < q\" \n    and ya: \"ya < q\" \n    and map: \"(y + q - x) mod q = (y + q - ya) mod q\" \n  shows  \"x = ya\"", "lemma inj_on_minus: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\"", "lemma surj_on_minus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + (q - b)) mod q) ` {..< q} = {..< q}\"", "lemma samp_uni_minus_one_time_pad: \n  shows \"map_spmf(\\<lambda> b. (y + (q - b)) mod q) (sample_uniform q) = (sample_uniform q)\"", "lemma not_coin_flip: \"map_spmf (\\<lambda> a. \\<not> a) coin_spmf = coin_spmf\"", "lemma xor_uni_samp: \"map_spmf(\\<lambda> b. y \\<oplus> b) (coin_spmf) = map_spmf(\\<lambda> b. b) (coin_spmf)\"\n  (is \"?lhs = ?rhs\")"], "translations": [["", "lemma set_spmf_sampl_uni_units [simp]: \"set_spmf (sample_uniform_units q) = {..< q} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (sample_uniform_units q) = {..<q} - {0}", "by(simp add: sample_uniform_units_def)"], ["", "lemma lossless_sample_uniform_units: \n  assumes \"q > 1\"\n  shows \"lossless_spmf (sample_uniform_units q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_uniform_units q)", "apply(simp add: sample_uniform_units_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> {..<q} \\<subseteq> {0}", "using assms"], ["proof (prove)\nusing this:\n  1 < q\n\ngoal (1 subgoal):\n 1. \\<not> {..<q} \\<subseteq> {0}", "by auto"], ["", "text \\<open>General lemma for mapping using uniform sampling from units.\\<close>"], ["", "lemma one_time_pad_units: \n  assumes inj_on: \"inj_on f ({..<q} - {0})\" \n    and sur: \"f ` ({..<q} - {0}) = ({..<q} - {0})\"  \n  shows \"map_spmf f (sample_uniform_units q) = (sample_uniform_units q)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have rhs: \"?rhs = spmf_of_set (({..<q} - {0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform_units q = spmf_of_set ({..<q} - {0})", "by(auto simp add: sample_uniform_units_def)"], ["proof (state)\nthis:\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "also"], ["proof (state)\nthis:\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have \"map_spmf(\\<lambda>s. f s) (spmf_of_set ({..<q} - {0})) = spmf_of_set ((\\<lambda>s. f s) ` ({..<q} - {0}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (spmf_of_set ({..<q} - {0})) =\n    spmf_of_set (f ` ({..<q} - {0}))", "by(simp add: inj_on)"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set ({..<q} - {0})) = spmf_of_set (f ` ({..<q} - {0}))\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "also"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set ({..<q} - {0})) = spmf_of_set (f ` ({..<q} - {0}))\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "have \"f ` ({..<q} - {0}) = ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` ({..<q} - {0}) = {..<q} - {0}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite ({..<q} - {0})\n 2. f ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 3. inj_on f ({..<q} - {0})", "by(simp, simp add: sur, simp add: inj_on)"], ["proof (state)\nthis:\n  f ` ({..<q} - {0}) = {..<q} - {0}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform_units q) = spmf_of_set (f ` ({..<q} - {0}))\n  f ` ({..<q} - {0}) = {..<q} - {0}\n  sample_uniform_units q = spmf_of_set ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform_units q) = sample_uniform_units q", "by simp"], ["proof (state)\nthis:\n  map_spmf f (sample_uniform_units q) = sample_uniform_units q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>General lemma for mapping using uniform sampling.\\<close>"], ["", "lemma one_time_pad: \n  assumes inj_on: \"inj_on f {..<q}\" \n    and sur: \"f ` {..<q} = {..<q}\"  \n  shows \"map_spmf f (sample_uniform q) = (sample_uniform q)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have rhs: \"?rhs = spmf_of_set ({..< q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform q = spmf_of_set {..<q}", "by(auto simp add: sample_uniform_def)"], ["proof (state)\nthis:\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "also"], ["proof (state)\nthis:\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have \"map_spmf(\\<lambda>s. f s) (spmf_of_set {..<q}) = spmf_of_set ((\\<lambda>s. f s) ` {..<q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})", "by(simp add: inj_on)"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "also"], ["proof (state)\nthis:\n  map_spmf f (spmf_of_set {..<q}) = spmf_of_set (f ` {..<q})\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "have \"f ` {..<q} = {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. f ` {..<q} \\<subseteq> {..<q}\n 3. inj_on f {..<q}", "by(simp, simp add: sur, simp add: inj_on)"], ["proof (state)\nthis:\n  f ` {..<q} = {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "ultimately"], ["proof (chain)\npicking this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf f (sample_uniform q) = spmf_of_set (f ` {..<q})\n  f ` {..<q} = {..<q}\n  sample_uniform q = spmf_of_set {..<q}\n\ngoal (1 subgoal):\n 1. map_spmf f (sample_uniform q) = sample_uniform q", "by simp"], ["proof (state)\nthis:\n  map_spmf f (sample_uniform q) = sample_uniform q\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The addition map case.\\<close>"], ["", "lemma inj_add: \n  assumes x:  \"x < q\" \n    and x': \"x' < q\" \n    and map: \"((y :: nat) + x) mod q = (y + x') mod q\"  \n  shows \"x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = x'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = x'", "have aa: \"((y :: nat) + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have 4: \"((y:: nat) + x) mod q = (y + x') mod q \\<Longrightarrow> [((y:: nat) + x) = (y + x')] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow>\n    [y + x = y + x'] (mod q)", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> [y + x = y + x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have 5: \"[((y:: nat) + x) = (y + x')] (mod q) \\<Longrightarrow> [x = x'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)", "by (simp add: cong_add_lcancel_nat)"], ["proof (state)\nthis:\n  [y + x = y + x'] (mod q) \\<Longrightarrow> [x = x'] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "have 6: \"[x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q", "then"], ["proof (chain)\npicking this:\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q", "show ?thesis"], ["proof (prove)\nusing this:\n  [x = x'] (mod q) \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x mod q = x' mod q", "by(simp add: map 4 5 6)"], ["proof (state)\nthis:\n  x mod q = x' mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x = x'", "also"], ["proof (state)\nthis:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n\ngoal (1 subgoal):\n 1. x = x'", "have bb: \"x mod q = x' mod q \\<Longrightarrow> x = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod q = x' mod q \\<Longrightarrow> x = x'", "by(simp add: x x')"], ["proof (state)\nthis:\n  x mod q = x' mod q \\<Longrightarrow> x = x'\n\ngoal (1 subgoal):\n 1. x = x'", "ultimately"], ["proof (chain)\npicking this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n  x mod q = x' mod q \\<Longrightarrow> x = x'", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x) mod q = (y + x') mod q \\<Longrightarrow> x mod q = x' mod q\n  x mod q = x' mod q \\<Longrightarrow> x = x'\n\ngoal (1 subgoal):\n 1. x = x'", "by(simp add: map)"], ["proof (state)\nthis:\n  x = x'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_uni_samp_add: \"inj_on (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "by(simp add: inj_on_def)(auto simp only: inj_add)"], ["", "lemma surj_uni_samp: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + b) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + b) mod q) ` {..< q} =  {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + b) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "using inj"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (y + b) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + b) mod q) {..<q}", "by auto"], ["", "lemma samp_uni_plus_one_time_pad: \n  shows \"map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) = (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_uni_samp_add surj_uni_samp one_time_pad"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (?y + b) mod ?q) {..<?q}\n  inj_on (\\<lambda>b. (?y + b) mod ?q) {..<?q} \\<Longrightarrow>\n  (\\<lambda>b. (?y + b) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + b) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "text \\<open>The multiplicaton map case.\\<close>"], ["", "lemma inj_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and y: \"y < q\" \n    and y': \"y' < q\" \n  and map: \"x * y mod q = x * y' mod q\" \nshows \"y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = y'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. y = y'", "have \"x*y mod q = x*y' mod q \\<Longrightarrow> y mod q = y' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"x*y mod q = x*y' mod q \\<Longrightarrow> [x*y = x*y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "also"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [x * y = x * y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"[x*y = x*y'] (mod q) = [y = y'] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * y = x * y'] (mod q) = [y = y'] (mod q)", "by(simp add: cong_mult_lcancel_nat coprime)"], ["proof (state)\nthis:\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "also"], ["proof (state)\nthis:\n  [x * y = x * y'] (mod q) = [y = y'] (mod q)\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "have \"[y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q", "by(simp add: cong_def)"], ["proof (state)\nthis:\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q", "ultimately"], ["proof (chain)\npicking this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [y = y'] (mod q)\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> [y = y'] (mod q)\n  [y = y'] (mod q) \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y mod q = y' mod q", "by(simp add: map)"], ["proof (state)\nthis:\n  y mod q = y' mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y = y'", "also"], ["proof (state)\nthis:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n\ngoal (1 subgoal):\n 1. y = y'", "have \"y mod q = y' mod q \\<Longrightarrow> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y mod q = y' mod q \\<Longrightarrow> y = y'", "by(simp add: y y')"], ["proof (state)\nthis:\n  y mod q = y' mod q \\<Longrightarrow> y = y'\n\ngoal (1 subgoal):\n 1. y = y'", "ultimately"], ["proof (chain)\npicking this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n  y mod q = y' mod q \\<Longrightarrow> y = y'", "show ?thesis"], ["proof (prove)\nusing this:\n  x * y mod q = x * y' mod q \\<Longrightarrow> y mod q = y' mod q\n  y mod q = y' mod q \\<Longrightarrow> y = y'\n\ngoal (1 subgoal):\n 1. y = y'", "by(simp add: map)"], ["proof (state)\nthis:\n  y = y'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. x*b mod q) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) {..<q}", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; y < q; x * xa mod q = x * y mod q\\<rbrakk>\n       \\<Longrightarrow> xa = y", "using coprime"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; y < q; x * xa mod q = x * y mod q\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by(simp only: inj_mult)"], ["", "lemma surj_on_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) {..<q}\"\n  shows \"(\\<lambda> b. x*b mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. x * b mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. x * b mod q) {..<q}", "using coprime inj"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. x * b mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. x * b mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. x * b mod q) {..<q}", "by auto"], ["", "lemma mult_one_time_pad: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform q) = (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform q) = sample_uniform q", "using inj_on_mult surj_on_mult one_time_pad coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow> inj_on (\\<lambda>b. ?x * b mod ?q) {..<?q}\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. ?x * b mod ?q) {..<?q}\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. ?x * b mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform q) = sample_uniform q", "by simp"], ["", "text \\<open>The multiplication map for sampling from units.\\<close>"], ["", "lemma inj_on_mult_units: \n  assumes 1: \"coprime x (q::nat)\" shows \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; 0 < xa; y < q; x * xa mod q = x * y mod q;\n        0 < y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "using 1"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa y.\n       \\<lbrakk>xa < q; 0 < xa; y < q; x * xa mod q = x * y mod q;\n        0 < y\\<rbrakk>\n       \\<Longrightarrow> xa = y", "by(simp only: inj_mult)"], ["", "lemma surj_on_mult_units: \n  assumes coprime: \"coprime x (q::nat)\" \n    and inj: \"inj_on (\\<lambda> b. x*b mod q) ({..<q} - {0})\"\n  shows \"(\\<lambda> b. x*b mod q) ` ({..<q} - {0}) = ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) = {..<q} - {0}", "proof(rule endo_inj_surj)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite ({..<q} - {0})\n 2. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 3. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \"finite ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({..<q} - {0})", "using coprime inj"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. finite ({..<q} - {0})", "by(simp)"], ["proof (state)\nthis:\n  finite ({..<q} - {0})\n\ngoal (2 subgoals):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n 2. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \"(\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "obtain n :: \"nat set \\<Rightarrow> (nat \\<Rightarrow> nat) \\<Rightarrow> nat set \\<Rightarrow> nat\" where\n      \"\\<forall>x0 x1 x2. (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) = (n x0 x1 x2 \\<in> x2 \\<and> x1 (n x0 x1 x2) \\<notin> x0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        \\<forall>x0 x1 x2.\n           (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n           (n x0 x1 x2 \\<in> x2 \\<and>\n            x1 (n x0 x1 x2) \\<notin> x0) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by moura"], ["proof (state)\nthis:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n     (n x0 x1 x2 \\<in> x2 \\<and> x1 (n x0 x1 x2) \\<notin> x0)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n     (n x0 x1 x2 \\<in> x2 \\<and> x1 (n x0 x1 x2) \\<notin> x0)", "have subset: \"\\<forall>N f Na. n Na f N \\<in> N \\<and> f (n Na f N) \\<notin> Na \\<or> f ` N \\<subseteq> Na\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1 x2.\n     (\\<exists>v3. v3 \\<in> x2 \\<and> x1 v3 \\<notin> x0) =\n     (n x0 x1 x2 \\<in> x2 \\<and> x1 (n x0 x1 x2) \\<notin> x0)\n\ngoal (1 subgoal):\n 1. \\<forall>N f Na.\n       n Na f N \\<in> N \\<and> f (n Na f N) \\<notin> Na \\<or>\n       f ` N \\<subseteq> Na", "by (meson image_subsetI)"], ["proof (state)\nthis:\n  \\<forall>N f Na.\n     n Na f N \\<in> N \\<and> f (n Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have mem_insert: \"x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<notin> {..<q} \\<or> x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<notin> {..<q} \\<or>\n    x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> insert 0 {..<q}", "by force"], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {..<q} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have map_eq: \"(x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q} - {0}) = (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n     \\<in> insert 0 {..<q} - {0}) =\n    (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n     \\<in> {..<q} - {0})", "by simp"], ["proof (state)\nthis:\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q = x * 0 mod q\""], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "then"], ["proof (chain)\npicking this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q", "have \"(0 \\<le> q) = (0 = q) \\<or> (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} \\<or> n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<in> {0}) \\<or> n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} - {0} \\<or> x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q\n\ngoal (1 subgoal):\n 1. (0 \\<le> q) = (0 = q) \\<or>\n    (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n     \\<notin> {..<q} \\<or>\n     n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n     \\<in> {0}) \\<or>\n    n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n    \\<notin> {..<q} - {0} \\<or>\n    x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> {..<q} - {0}", "by (metis antisym_conv1 insertCI lessThan_iff local.coprime inj_mult)"], ["proof (state)\nthis:\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "moreover"], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"0 \\<noteq> x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\""], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "moreover"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "{"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "assume \"x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> insert 0 {..<q} \\<and> x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<notin> {0}\""], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "then"], ["proof (chain)\npicking this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}", "have \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "using map_eq subset"], ["proof (prove)\nusing this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0}\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> insert 0 {..<q} - {0}) =\n  (x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n   \\<in> {..<q} - {0})\n  \\<forall>N f Na.\n     n Na f N \\<in> N \\<and> f (n Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "by (meson Diff_iff)"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "ultimately"], ["proof (chain)\npicking this:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "have \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or> (0 \\<le> q) = (0 = q)\""], ["proof (prove)\nusing this:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    (0 \\<le> q) = (0 = q)", "using mem_insert"], ["proof (prove)\nusing this:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q} \\<and>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {0} \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<notin> {..<q} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> insert 0 {..<q}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    (0 \\<le> q) = (0 = q)", "by (metis antisym_conv1 lessThan_iff mod_less_divisor singletonD)"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "}"], ["proof (state)\nthis:\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "ultimately"], ["proof (chain)\npicking this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)", "have \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or> n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) \\<notin> {..<q} - {0} \\<or> x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q \\<in> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q =\n  x * 0 mod q \\<Longrightarrow>\n  (0 \\<le> q) = (0 = q) \\<or>\n  (n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<notin> {..<q} \\<or>\n   n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n   \\<in> {0}) \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  0 \\<noteq>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod\n  q \\<Longrightarrow>\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  (0 \\<le> q) = (0 = q)\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0})\n    \\<subseteq> {..<q} - {0} \\<or>\n    n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n    \\<notin> {..<q} - {0} \\<or>\n    x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n    \\<in> {..<q} - {0}", "by force"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}", "show \"(\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\""], ["proof (prove)\nusing this:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "using subset"], ["proof (prove)\nusing this:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0} \\<or>\n  n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0})\n  \\<notin> {..<q} - {0} \\<or>\n  x * n ({..<q} - {0}) (\\<lambda>n. x * n mod q) ({..<q} - {0}) mod q\n  \\<in> {..<q} - {0}\n  \\<forall>N f Na.\n     n Na f N \\<in> N \\<and> f (n Na f N) \\<notin> Na \\<or>\n     f ` N \\<subseteq> Na\n\ngoal (1 subgoal):\n 1. (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}", "by meson"], ["proof (state)\nthis:\n  (\\<lambda>n. x * n mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>b. x * b mod q) ` ({..<q} - {0}) \\<subseteq> {..<q} - {0}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "show \"inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "using assms"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})", "by(simp)"], ["proof (state)\nthis:\n  inj_on (\\<lambda>b. x * b mod q) ({..<q} - {0})\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mult_one_time_pad_units: \n  assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. x*b mod q) (sample_uniform_units q) = sample_uniform_units q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform_units q) =\n    sample_uniform_units q", "using inj_on_mult_units surj_on_mult_units one_time_pad_units coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow>\n  inj_on (\\<lambda>b. ?x * b mod ?q) ({..<?q} - {0})\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. ?x * b mod ?q) ({..<?q} - {0})\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. ?x * b mod ?q) ` ({..<?q} - {0}) =\n                    {..<?q} - {0}\n  \\<lbrakk>inj_on ?f ({..<?q} - {0});\n   ?f ` ({..<?q} - {0}) = {..<?q} - {0}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform_units ?q) =\n                    sample_uniform_units ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. x * b mod q) (sample_uniform_units q) =\n    sample_uniform_units q", "by simp"], ["", "text \\<open>Addition and multiplication map.\\<close>"], ["", "lemma samp_uni_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n    and xa: \"xa < q\" \n    and ya: \"ya < q\" \n    and map: \"(y + x * xa) mod q = (y + x * ya) mod q\" \n  shows \"xa = ya\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa = ya", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. xa = ya", "have \"(y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow> xa mod q = ya mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    xa mod q = ya mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    xa mod q = ya mod q", "have \"(y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow> [y + x*xa = y + x *ya] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    [y + x * xa = y + x * ya] (mod q)", "using cong_def"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    [y + x * xa = y + x * ya] (mod q)", "by blast"], ["proof (state)\nthis:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  [y + x * xa = y + x * ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    xa mod q = ya mod q", "also"], ["proof (state)\nthis:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  [y + x * xa = y + x * ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    xa mod q = ya mod q", "have \"[y + x*xa = y + x *ya] (mod q) \\<Longrightarrow> [xa = ya] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + x * xa = y + x * ya] (mod q) \\<Longrightarrow> [xa = ya] (mod q)", "by(simp add: cong_add_lcancel_nat)(simp add: coprime cong_mult_lcancel_nat)"], ["proof (state)\nthis:\n  [y + x * xa = y + x * ya] (mod q) \\<Longrightarrow> [xa = ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n    xa mod q = ya mod q", "ultimately"], ["proof (chain)\npicking this:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  [y + x * xa = y + x * ya] (mod q)\n  [y + x * xa = y + x * ya] (mod q) \\<Longrightarrow> [xa = ya] (mod q)", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  [y + x * xa = y + x * ya] (mod q)\n  [y + x * xa = y + x * ya] (mod q) \\<Longrightarrow> [xa = ya] (mod q)\n\ngoal (1 subgoal):\n 1. xa mod q = ya mod q", "by(simp add: cong_def map)"], ["proof (state)\nthis:\n  xa mod q = ya mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  xa mod q = ya mod q\n\ngoal (1 subgoal):\n 1. xa = ya", "also"], ["proof (state)\nthis:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  xa mod q = ya mod q\n\ngoal (1 subgoal):\n 1. xa = ya", "have \"xa mod q = ya mod q \\<Longrightarrow> xa = ya\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xa mod q = ya mod q \\<Longrightarrow> xa = ya", "by(simp add: xa ya)"], ["proof (state)\nthis:\n  xa mod q = ya mod q \\<Longrightarrow> xa = ya\n\ngoal (1 subgoal):\n 1. xa = ya", "ultimately"], ["proof (chain)\npicking this:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  xa mod q = ya mod q\n  xa mod q = ya mod q \\<Longrightarrow> xa = ya", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + x * xa) mod q = (y + x * ya) mod q \\<Longrightarrow>\n  xa mod q = ya mod q\n  xa mod q = ya mod q \\<Longrightarrow> xa = ya\n\ngoal (1 subgoal):\n 1. xa = ya", "by(simp add: map)"], ["proof (state)\nthis:\n  xa = ya\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_add_mult: \n  assumes coprime: \"coprime x (q::nat)\" \n  shows \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "apply(auto simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa < q; ya < q;\n        (y + x * xa) mod q = (y + x * ya) mod q\\<rbrakk>\n       \\<Longrightarrow> xa = ya", "using coprime"], ["proof (prove)\nusing this:\n  coprime x q\n\ngoal (1 subgoal):\n 1. \\<And>xa ya.\n       \\<lbrakk>xa < q; ya < q;\n        (y + x * xa) mod q = (y + x * ya) mod q\\<rbrakk>\n       \\<Longrightarrow> xa = ya", "by(simp only: samp_uni_add_mult)"], ["", "lemma surj_on_add_mult: assumes coprime: \"coprime x (q::nat)\" and inj: \"inj_on (\\<lambda> b. (y + x*b) mod q) {..<q}\" \n  shows \"(\\<lambda> b. (y + x*b) mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + x * b) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + x * b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "using coprime inj"], ["proof (prove)\nusing this:\n  coprime x q\n  inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + x * b) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + x * b) mod q) {..<q}", "by auto"], ["", "lemma add_mult_one_time_pad: assumes coprime: \"coprime x q\" \n  shows \"map_spmf (\\<lambda> b. (y + x*b) mod q) (sample_uniform q) = (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + x * b) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_on_add_mult surj_on_add_mult one_time_pad coprime"], ["proof (prove)\nusing this:\n  coprime ?x ?q \\<Longrightarrow>\n  inj_on (\\<lambda>b. (?y + ?x * b) mod ?q) {..<?q}\n  \\<lbrakk>coprime ?x ?q;\n   inj_on (\\<lambda>b. (?y + ?x * b) mod ?q) {..<?q}\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>b. (?y + ?x * b) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n  coprime x q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + x * b) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "text \\<open>Subtraction Map.\\<close>"], ["", "lemma inj_minus: \n  assumes x: \"(x :: nat) < q\" \n    and ya: \"ya < q\" \n    and map: \"(y + q - x) mod q = (y + q - ya) mod q\" \n  shows  \"x = ya\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = ya", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = ya", "have \"(y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow> x mod q = ya mod q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "have \"(y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow> [y + q - x = y + q - ya] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    [y + q - x = y + q - ya] (mod q)", "using cong_def"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    [y + q - x = y + q - ya] (mod q)", "by blast"], ["proof (state)\nthis:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  [y + q - x = y + q - ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "moreover"], ["proof (state)\nthis:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  [y + q - x = y + q - ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "have \"[y + q - x = y + q - ya] (mod q) \\<Longrightarrow> [q - x = q - ya] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n    [q - x = q - ya] (mod q)", "using x ya cong_add_lcancel_nat"], ["proof (prove)\nusing this:\n  x < q\n  ya < q\n  [?a + ?x = ?a + ?y] (mod ?n) = [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n    [q - x = q - ya] (mod q)", "by fastforce"], ["proof (state)\nthis:\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q - x = q - ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "moreover"], ["proof (state)\nthis:\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q - x = q - ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "have \"[y + q - x = y + q - ya] (mod q) \\<Longrightarrow> [q + x = q + ya] (mod q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n    [q + x = q + ya] (mod q)", "by (metis add_diff_inverse_nat calculation(2) cong_add_lcancel_nat cong_add_rcancel_nat cong_sym less_imp_le_nat not_le x ya)"], ["proof (state)\nthis:\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q + x = q + ya] (mod q)\n\ngoal (1 subgoal):\n 1. (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n    x mod q = ya mod q", "ultimately"], ["proof (chain)\npicking this:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  [y + q - x = y + q - ya] (mod q)\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q - x = q - ya] (mod q)\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q + x = q + ya] (mod q)", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  [y + q - x = y + q - ya] (mod q)\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q - x = q - ya] (mod q)\n  [y + q - x = y + q - ya] (mod q) \\<Longrightarrow>\n  [q + x = q + ya] (mod q)\n\ngoal (1 subgoal):\n 1. x mod q = ya mod q", "by (simp add: cong_def map)"], ["proof (state)\nthis:\n  x mod q = ya mod q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  x mod q = ya mod q\n\ngoal (1 subgoal):\n 1. x = ya", "moreover"], ["proof (state)\nthis:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  x mod q = ya mod q\n\ngoal (1 subgoal):\n 1. x = ya", "have \"x mod q = ya mod q \\<Longrightarrow> x = ya\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x mod q = ya mod q \\<Longrightarrow> x = ya", "by(simp add: x ya)"], ["proof (state)\nthis:\n  x mod q = ya mod q \\<Longrightarrow> x = ya\n\ngoal (1 subgoal):\n 1. x = ya", "ultimately"], ["proof (chain)\npicking this:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  x mod q = ya mod q\n  x mod q = ya mod q \\<Longrightarrow> x = ya", "show ?thesis"], ["proof (prove)\nusing this:\n  (y + q - x) mod q = (y + q - ya) mod q \\<Longrightarrow>\n  x mod q = ya mod q\n  x mod q = ya mod q \\<Longrightarrow> x = ya\n\ngoal (1 subgoal):\n 1. x = ya", "by(simp add: map)"], ["proof (state)\nthis:\n  x = ya\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_on_minus: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "by(auto simp add: inj_on_def inj_minus)"], ["", "lemma surj_on_minus: \n  assumes inj: \"inj_on  (\\<lambda>(b :: nat). (y + (q - b)) mod q ) {..<q}\" \n  shows \"(\\<lambda>(b :: nat). (y + (q - b)) mod q) ` {..< q} = {..< q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} = {..<q}", "apply(rule endo_inj_surj)"], ["proof (prove)\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "using inj"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}\n\ngoal (3 subgoals):\n 1. finite {..<q}\n 2. (\\<lambda>b. (y + (q - b)) mod q) ` {..<q} \\<subseteq> {..<q}\n 3. inj_on (\\<lambda>b. (y + (q - b)) mod q) {..<q}", "by auto"], ["", "lemma samp_uni_minus_one_time_pad: \n  shows \"map_spmf(\\<lambda> b. (y + (q - b)) mod q) (sample_uniform q) = (sample_uniform q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + (q - b)) mod q) (sample_uniform q) =\n    sample_uniform q", "using inj_on_minus surj_on_minus one_time_pad"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>b. (?y + (?q - b)) mod ?q) {..<?q}\n  inj_on (\\<lambda>b. (?y + (?q - b)) mod ?q) {..<?q} \\<Longrightarrow>\n  (\\<lambda>b. (?y + (?q - b)) mod ?q) ` {..<?q} = {..<?q}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. (y + (q - b)) mod q) (sample_uniform q) =\n    sample_uniform q", "by simp"], ["", "lemma not_coin_flip: \"map_spmf (\\<lambda> a. \\<not> a) coin_spmf = coin_spmf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "have \"inj_on Not {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on Not {True, False}", "by simp"], ["proof (state)\nthis:\n  inj_on Not {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "also"], ["proof (state)\nthis:\n  inj_on Not {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "have  \"Not ` {True, False} = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Not ` {True, False} = {True, False}", "by auto"], ["proof (state)\nthis:\n  Not ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "ultimately"], ["proof (chain)\npicking this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "using one_time_pad"], ["proof (prove)\nusing this:\n  inj_on Not {True, False}\n  Not ` {True, False} = {True, False}\n  \\<lbrakk>inj_on ?f {..<?q}; ?f ` {..<?q} = {..<?q}\\<rbrakk>\n  \\<Longrightarrow> map_spmf ?f (sample_uniform ?q) = sample_uniform ?q\n\ngoal (1 subgoal):\n 1. map_spmf Not coin_spmf = coin_spmf", "by (simp add: UNIV_bool)"], ["proof (state)\nthis:\n  map_spmf Not coin_spmf = coin_spmf\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma xor_uni_samp: \"map_spmf(\\<lambda> b. y \\<oplus> b) (coin_spmf) = map_spmf(\\<lambda> b. b) (coin_spmf)\"\n  (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have rhs: \"?rhs = spmf_of_set {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}", "by (simp add: UNIV_bool insert_commute)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have \"map_spmf(\\<lambda> b. y \\<oplus> b) (spmf_of_set {True, False}) = spmf_of_set((\\<lambda> b. y \\<oplus> b) ` {True, False})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n    spmf_of_set ((\\<oplus>) y ` {True, False})", "by (simp add: xor_def)"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n  spmf_of_set ((\\<oplus>) y ` {True, False})\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "also"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) (spmf_of_set {True, False}) =\n  spmf_of_set ((\\<oplus>) y ` {True, False})\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "have \"(\\<lambda> b. xor y b) ` {True, False} = {True, False}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<oplus>) y ` {True, False} = {True, False}", "using xor_def"], ["proof (prove)\nusing this:\n  ?x \\<oplus> ?y = (?x \\<squnion> ?y) \\<sqinter> - (?x \\<sqinter> ?y)\n\ngoal (1 subgoal):\n 1. (\\<oplus>) y ` {True, False} = {True, False}", "by auto"], ["proof (state)\nthis:\n  (\\<oplus>) y ` {True, False} = {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "finally"], ["proof (chain)\npicking this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}", "show ?thesis"], ["proof (prove)\nusing this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "using rhs"], ["proof (prove)\nusing this:\n  map_spmf ((\\<oplus>) y) (map_spmf (\\<lambda>b. b) coin_spmf) =\n  spmf_of_set {True, False}\n  map_spmf (\\<lambda>b. b) coin_spmf = spmf_of_set {True, False}\n\ngoal (1 subgoal):\n 1. map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf", "by(simp)"], ["proof (state)\nthis:\n  map_spmf ((\\<oplus>) y) coin_spmf = map_spmf (\\<lambda>b. b) coin_spmf\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}