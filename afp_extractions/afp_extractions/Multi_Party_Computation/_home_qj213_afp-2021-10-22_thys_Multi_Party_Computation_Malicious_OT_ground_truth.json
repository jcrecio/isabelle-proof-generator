{"file_name": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation/Malicious_OT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation", "problem_names": ["lemma prime_field: \"a < (order \\<G>) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coprime a (order \\<G>)\"", "lemma P1_ideal_ideal_eq:\n  shows  \"mal_def.ideal_view_1 x y z (P1_S1, P1_S2) \\<A> = P1_ideal_model x y z \\<A>\"", "lemma P1_advantages_eq: \n  shows \"mal_def.adv_P1 x y z (P1_S1, P1_S2) \\<A> D = P1_adv_real_ideal_model D x y \\<A> z\"", "lemma P2_ideal_model_rewrite: \"P2_ideal_model M \\<sigma> z \\<A> = P2_ideal_model' M \\<sigma> z \\<A> \"", "lemma P2_real_model_rewrite: \"P2_real_model M \\<sigma> z \\<A> = P2_real_model' M \\<sigma> z \\<A>\"", "lemma P2_ideal_view_unfold: \"mal_def.ideal_view_2 (x0,x1) \\<sigma> z (P2_S1, P2_S2) \\<A> = P2_ideal_model (x0,x1) \\<sigma> z \\<A>\"", "lemma P1_assert_correct1: \n  shows \"((\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat) \\<otimes> \\<^bold>g \\<otimes> inv ((\\<^bold>g [^] (\\<alpha>1::nat)) [^] r \\<otimes> \\<^bold>g) \n                = (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r)\"\n    (is \"?lhs = ?rhs\")", "lemma P1_assert_correct2: \n  shows   \"(\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat) \\<otimes> inv ((\\<^bold>g [^] (\\<alpha>1::nat)) [^] r) = (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r\"\n    (is \"?lhs = ?rhs\")", "lemma P1_real_ddh0_\\<sigma>_false:\n  assumes \"\\<sigma> = False\"\n  shows \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\"", "lemma P1_ideal_ddh1_\\<sigma>_false:\n  assumes \"\\<sigma> = False\"\n  shows \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\"", "lemma P1_real_ddh1_\\<sigma>_true:\n  assumes \"\\<sigma> = True\"\n  shows \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\"", "lemma P1_ideal_ddh0_\\<sigma>_true:\n  assumes \"\\<sigma> = True\"\n  shows \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\"", "lemma P1_real_ideal_DDH_advantage_false:\n  assumes \"\\<sigma> = False\" \n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D = ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)\"", "lemma P1_real_ideal_DDH_advantage_false_bound:\n  assumes \"\\<sigma> = False\"\n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D \n          \\<le> ddh.advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D) \n            + ddh.advantage (ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\"", "lemma P1_real_ideal_DDH_advantage_true:\n  assumes \"\\<sigma> = True\" \n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D = ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)\"", "lemma P1_real_ideal_DDH_advantage_true_bound:\n  assumes \"\\<sigma> = True\"\n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D \n          \\<le> ddh.advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D) \n            + ddh.advantage (ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\"", "lemma P2_output_rewrite:\n  assumes \"s < order \\<G>\"\n  shows \"(\\<^bold>g [^] (r * u1 + v1),  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1)\n           = (\\<^bold>g [^] (r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>),  \n             \\<^bold>g [^] (r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n               \\<otimes> inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))\"", "lemma P2_inv_g_rewrite:\n  assumes \"s < order \\<G>\" \n  shows \"(inv \\<^bold>g) [^] (u1' + (order \\<G> - s)) = \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\"", "lemma P2_inv_g_s_rewrite:\n  assumes \"s < order \\<G>\" \n  shows \"\\<^bold>g [^] ((r::nat) * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] (u1 + (order \\<G> - s)) = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> \\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1\"", "lemma P2_e0_rewrite: \n  assumes \"s < order \\<G> \"\n  shows \"(\\<^bold>g [^] (r * x + xa), \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] x)  = \n            (\\<^bold>g [^] (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>),\n               \\<^bold>g [^] (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  \\<otimes> \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))\"", "lemma P2_case_l_new_1_gt_e0_rewrite:\n  assumes \"s < order \\<G>\"\n  shows \"(\\<^bold>g [^] (r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n            + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>),\n              \\<^bold>g [^] (r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n                  \\<^bold>g [^] (t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> \n                    + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = (\\<^bold>g [^] (r * x + xa), \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * x))\"", "lemma P2_case_l_neq_1_gt_x0_rewrite:\n  assumes \"t < order \\<G>\" \n    and \"t \\<noteq> 0\"\n  shows \"\\<^bold>g [^] (t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = \\<^bold>g [^] (t * u0) \\<otimes>  \\<^bold>g [^] s\"", "lemma P2_ideal_real_end_eq:\n  assumes b0_inv_b1: \"b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\"\n    and assert_in_carrier: \"h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\"\n    and x1_in_carrier: \"x1 \\<in> carrier \\<G>\" \n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"\n  shows \"P2_ideal_model_end (x0,x1) (b0 \\<otimes> (inv (h0 [^] r))) ((h0,h1, \\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3 = P2_real_model_end (x0,x1) ((h0,h1, \\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3\"", "lemma P2_ideal_real_eq: \n  assumes x1_in_carrier: \"x1 \\<in> carrier \\<G>\" \n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"  \n  shows \"P2_real_model (x0,x1) \\<sigma>  z \\<A>  = P2_ideal_model (x0,x1) \\<sigma>  z \\<A>\"", "lemma malicious_sec_P2:   \n  assumes x1_in_carrier: \"x1 \\<in> carrier \\<G>\"\n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"  \n  shows \"mal_def.perfect_sec_P2 (x0,x1) \\<sigma> z (P2_S1, P2_S2) \\<A>\"", "lemma correct:\n  assumes \"x0 \\<in> carrier \\<G>\" \n    and \"x1 \\<in> carrier \\<G>\"\n  shows \"funct_OT_12 (x0, x1) \\<sigma> = protocol_ot (x0,x1) \\<sigma>\"", "lemma correctness:\n  assumes \"x0 \\<in> carrier \\<G>\" \n    and \"x1 \\<in> carrier \\<G>\"\n  shows \"mal_def.correct (x0,x1) \\<sigma>\"", "lemma correctness_asym:\n  assumes \"x0 \\<in> carrier (\\<G> n)\" \n    and \"x1 \\<in> carrier (\\<G> n)\" \n  shows \"mal_def.correct n (x0,x1) \\<sigma>\"", "lemma P1_security_asym:\n  \"negligible (\\<lambda> n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\" \n  if neg1: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\"\n    and neg2: \"negligible (\\<lambda> n. ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\" \n    and neg3: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\"\n    and neg4: \"negligible (\\<lambda> n. ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\"", "lemma P2_security_asym:   \n  assumes x1_in_carrier: \"x1 \\<in> carrier (\\<G> n)\"\n    and x0_in_carrier: \"x0 \\<in> carrier (\\<G> n)\"  \n  shows \"mal_def.perfect_sec_P2 n (x0,x1) \\<sigma> z (P2_S1 n, P2_S2 n) \\<A>\""], "translations": [["", "lemma prime_field: \"a < (order \\<G>) \\<Longrightarrow> a \\<noteq> 0 \\<Longrightarrow> coprime a (order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a < order \\<G>; a \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> coprime a (order \\<G>)", "by (metis dvd_imp_le neq0_conv not_le prime_imp_coprime prime_order coprime_commute)"], ["", "text\\<open>The protocol uses a call to an idealised functionality of a zero knowledge protocol for the \nDDH relation, this is described by the functionality given below.\\<close>"], ["", "fun funct_DH_ZK :: \"('grp \\<times> 'grp \\<times> 'grp) \\<Rightarrow> (('grp \\<times> 'grp \\<times> 'grp) \\<times> nat)  \\<Rightarrow> (bool \\<times> unit) spmf\"\n  where \"funct_DH_ZK (h,a,b) ((h',a',b'),r) = return_spmf (a = \\<^bold>g [^] r \\<and> b = h [^] r \\<and> (h,a,b) = (h',a',b'), ())\""], ["", "text\\<open>The probabilistic program that defines the output for both parties in the protocol.\\<close>"], ["", "definition protocol_ot :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> (unit \\<times> 'grp) spmf\"\n  where \"protocol_ot M \\<sigma> = do {\n  let (x0,x1) = M;\n  r \\<leftarrow> sample_uniform (order \\<G>);\n  \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n  \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n  let h0 = \\<^bold>g [^] \\<alpha>0;\n  let h1 = \\<^bold>g [^] \\<alpha>1;\n  let a = \\<^bold>g [^] r;\n  let b0 = h0 [^] r \\<otimes> \\<^bold>g [^] (if \\<sigma> then (1::nat) else 0);\n  let b1 = h1 [^] r \\<otimes> \\<^bold>g [^] (if \\<sigma> then (1::nat) else 0);\n  let h = h0 \\<otimes> inv h1;\n  let b = b0 \\<otimes> inv b1;\n  _ :: unit \\<leftarrow> assert_spmf (a = \\<^bold>g [^] r \\<and> b = h [^] r);\n  u0 \\<leftarrow> sample_uniform (order \\<G>);\n  u1 \\<leftarrow> sample_uniform (order \\<G>);\n  v0 \\<leftarrow> sample_uniform (order \\<G>);\n  v1 \\<leftarrow> sample_uniform (order \\<G>); \n  let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n  let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n  let e0 = (w0, z0);\n  let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n  let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n  let e1 = (w1, z1);\n  return_spmf ((), (if \\<sigma> then (z1 \\<otimes> inv (w1 [^] \\<alpha>1)) else (z0 \\<otimes> inv (w0 [^] \\<alpha>0))))}\""], ["", "text\\<open>Party 1 sends three messages (including the output) in the protocol so we split the adversary into three parts, one part\nto output each message. The real view of the protocol for party 1 outputs the correct output for party 2 \nand the adversary outputs the output for party 1.\\<close>"], ["", "definition P1_real_model :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out1, 'state) adv_mal_P1 \\<Rightarrow> ('adv_out1 \\<times> 'grp) spmf\"\n  where \"P1_real_model M \\<sigma> z \\<A> = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = h0 [^] r \\<otimes> (if \\<sigma> then \\<^bold>g else \\<one>);\n    let b1 = h1 [^] r \\<otimes> (if \\<sigma> then \\<^bold>g else \\<one>);\n    ((in1 :: 'grp, in2 ::'grp, in3 :: 'grp), s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (b :: bool, _ :: unit) \\<leftarrow> funct_DH_ZK (in1, in2, in3) ((h,a,b), r);\n    _ :: unit \\<leftarrow> assert_spmf (b); \n    (((w0,z0),(w1,z1)), s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    adv_out :: 'adv_out1  \\<leftarrow> \\<A>3 s';\n    return_spmf (adv_out, (if \\<sigma> then (z1 \\<otimes> (inv w1 [^] \\<alpha>1)) else (z0 \\<otimes> (inv w0 [^] \\<alpha>0))))}\""], ["", "text\\<open>The first and second part of the simulator for party 1 are defined below.\\<close>"], ["", "definition P1_S1 :: \"('aux, 'grp, 'adv_out1, 'state) adv_mal_P1 \\<Rightarrow> ('grp \\<times> 'grp) \\<Rightarrow> 'aux \\<Rightarrow> (('grp \\<times> 'grp) \\<times> 'state) spmf\"\n  where \"P1_S1 \\<A> M z = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = h0 [^] r;\n    let b1 = h1 [^] r \\<otimes> \\<^bold>g;\n    ((in1 :: 'grp, in2 ::'grp, in3 :: 'grp), s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    _ :: unit \\<leftarrow> assert_spmf ((in1, in2, in3) = (h,a,b));\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x0 = (z0 \\<otimes> (inv w0 [^] \\<alpha>0));\n    let x1 = (z1 \\<otimes> (inv w1 [^] \\<alpha>1));\n    return_spmf ((x0,x1), s')}\""], ["", "definition P1_S2 :: \"('aux, 'grp, 'adv_out1,'state) adv_mal_P1 \\<Rightarrow> ('grp \\<times> 'grp) \\<Rightarrow> 'aux \\<Rightarrow> unit \\<Rightarrow> 'state \\<Rightarrow> 'adv_out1 spmf\"\n  where \"P1_S2 \\<A> M z out1 s' = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    \\<A>3 s'}\""], ["", "text\\<open>We explicitly provide the unfolded definition of the ideal model for convieience in the proof.\\<close>"], ["", "definition P1_ideal_model :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out1,'state) adv_mal_P1 \\<Rightarrow> ('adv_out1 \\<times> 'grp) spmf\"\n  where \"P1_ideal_model M \\<sigma> z \\<A>  = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = h0 [^] r;\n    let b1 = h1 [^] r \\<otimes> \\<^bold>g;\n    ((in1 :: 'grp, in2 ::'grp, in3 :: 'grp), s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    _ :: unit \\<leftarrow> assert_spmf ((in1, in2, in3) = (h,a,b));\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x0' = z0 \\<otimes> inv w0 [^] \\<alpha>0;\n    let x1' = z1 \\<otimes> inv w1 [^] \\<alpha>1;\n    (_, f_out2) \\<leftarrow> funct_OT_12  (x0', x1') \\<sigma>;\n    adv_out :: 'adv_out1  \\<leftarrow> \\<A>3 s';\n    return_spmf (adv_out, f_out2)}\""], ["", "text\\<open>The advantage associated with the unfolded definition of the ideal view.\\<close>"], ["", "definition \n  \"P1_adv_real_ideal_model (D :: ('adv_out1 \\<times> 'grp) \\<Rightarrow> bool spmf) M \\<sigma> \\<A> z\n                  = \\<bar>spmf ((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) True \n                              - spmf ((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) True\\<bar>\""], ["", "text\\<open>We now define the real view and simulators for party 2 in an analogous way.\\<close>"], ["", "definition P2_real_model :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out2,'state) adv_mal_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_real_model M \\<sigma> z \\<A> = do {\n    let (x0,x1) = M;\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G> \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3 :: 'grp), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>); \n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let e0 = (w0, z0);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let e1 = (w1, z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["", "definition P2_S1 :: \"('aux, 'grp, 'adv_out2,'state) adv_mal_P2 \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> (bool \\<times> ('grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) \\<times> 'state)  spmf\"\n  where \"P2_S1 \\<A> \\<sigma> z = do {\n   let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z; \n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3 :: 'grp), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    let l = b0 \\<otimes> (inv (h0 [^] r));\n    return_spmf ((if l = \\<one> then False else True), (h0,h1,a,b0,b1), s')}\""], ["", "definition P2_S2 :: \"('aux, 'grp, 'adv_out2,'state) adv_mal_P2 \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> 'grp \\<Rightarrow> (('grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) \\<times> 'state) \\<Rightarrow> 'adv_out2 spmf\"\n  where \"P2_S2 \\<A> \\<sigma>' z x\\<sigma> aux_out  = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    let ((h0,h1,a,b0,b1),s) = aux_out;\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> (if \\<sigma>' then \\<one> else x\\<sigma>);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> (if \\<sigma>' then x\\<sigma> else \\<one>);\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    \\<A>3 e0 e1 s}\""], ["", "sublocale mal_def : malicious_base funct_OT_12 protocol_ot P1_S1 P1_S2 P1_real_model P2_S1 P2_S2 P2_real_model"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "text\\<open>We prove the unfolded definition of the ideal views are equal to the definition we provide in the \nabstract locale that defines security.\\<close>"], ["", "lemma P1_ideal_ideal_eq:\n  shows  \"mal_def.ideal_view_1 x y z (P1_S1, P1_S2) \\<A> = P1_ideal_model x y z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.ideal_view_1 x y z (P1_S1, P1_S2) \\<A> =\n    P1_ideal_model x y z \\<A>", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.ideal_view_1 x y z (P1_S1, P1_S2) \\<A> =\n    P1_ideal_model x y z \\<A>", "unfolding mal_def.ideal_view_1_def mal_def.ideal_game_1_def P1_ideal_model_def P1_S1_def P1_S2_def Let_def split_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst (\\<lambda>\\<A> M z.\n                 sample_uniform (order \\<G>) \\<bind>\n                 (\\<lambda>r.\n                     sample_uniform (order \\<G>) \\<bind>\n                     (\\<lambda>\\<alpha>0.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>\\<alpha>1.\n                             fst \\<A> M (\\<^bold>g [^] \\<alpha>0)\n                              (\\<^bold>g [^] \\<alpha>1) (\\<^bold>g [^] r)\n                              ((\\<^bold>g [^] \\<alpha>0) [^] r)\n                              ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                               \\<^bold>g)\n                              z \\<bind>\n                             (\\<lambda>p.\n                                 assert_spmf\n                                  ((fst (fst p), fst (snd (fst p)),\n                                    snd (snd (fst p))) =\n                                   (fst (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n   inv (\\<^bold>g [^] \\<alpha>1),\n   \\<^bold>g [^] r,\n   (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n   inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)),\n                                    fst (snd\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n     \\<^bold>g [^] r,\n     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))),\n                                    snd (snd\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n     \\<^bold>g [^] r,\n     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))))) \\<bind>\n                                 (\\<lambda>_.\n                                     fst (snd \\<A>)\n(\\<^bold>g [^] \\<alpha>0) (\\<^bold>g [^] \\<alpha>1)\n(fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n           \\<^bold>g [^] r,\n           (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n           inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))))\n((\\<^bold>g [^] \\<alpha>0) [^] r)\n((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) M (snd p) \\<bind>\n                                     (\\<lambda>p.\n   return_spmf\n    ((snd (fst (fst p)) \\<otimes> inv fst (fst (fst p)) [^] \\<alpha>0,\n      snd (snd (fst p)) \\<otimes> inv fst (snd (fst p)) [^] \\<alpha>1),\n     snd p))))))),\n              \\<lambda>\\<A> M z out1. snd (snd \\<A>))\n          \\<A>,\n         snd (\\<lambda>\\<A> M z.\n                 sample_uniform (order \\<G>) \\<bind>\n                 (\\<lambda>r.\n                     sample_uniform (order \\<G>) \\<bind>\n                     (\\<lambda>\\<alpha>0.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>\\<alpha>1.\n                             fst \\<A> M (\\<^bold>g [^] \\<alpha>0)\n                              (\\<^bold>g [^] \\<alpha>1) (\\<^bold>g [^] r)\n                              ((\\<^bold>g [^] \\<alpha>0) [^] r)\n                              ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                               \\<^bold>g)\n                              z \\<bind>\n                             (\\<lambda>p.\n                                 assert_spmf\n                                  ((fst (fst p), fst (snd (fst p)),\n                                    snd (snd (fst p))) =\n                                   (fst (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n   inv (\\<^bold>g [^] \\<alpha>1),\n   \\<^bold>g [^] r,\n   (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n   inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)),\n                                    fst (snd\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n     \\<^bold>g [^] r,\n     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))),\n                                    snd (snd\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n     \\<^bold>g [^] r,\n     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))))) \\<bind>\n                                 (\\<lambda>_.\n                                     fst (snd \\<A>)\n(\\<^bold>g [^] \\<alpha>0) (\\<^bold>g [^] \\<alpha>1)\n(fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n           \\<^bold>g [^] r,\n           (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n           inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))))\n((\\<^bold>g [^] \\<alpha>0) [^] r)\n((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) M (snd p) \\<bind>\n                                     (\\<lambda>p.\n   return_spmf\n    ((snd (fst (fst p)) \\<otimes> inv fst (fst (fst p)) [^] \\<alpha>0,\n      snd (snd (fst p)) \\<otimes> inv fst (snd (fst p)) [^] \\<alpha>1),\n     snd p))))))),\n              \\<lambda>\\<A> M z out1. snd (snd \\<A>))\n          \\<A>)\n     x z \\<bind>\n    (\\<lambda>p.\n        mal_def.trusted_party (fst p) y \\<bind>\n        (\\<lambda>pa.\n            snd (fst (\\<lambda>\\<A> M z.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>r.\n                             sample_uniform (order \\<G>) \\<bind>\n                             (\\<lambda>\\<alpha>0.\n                                 sample_uniform (order \\<G>) \\<bind>\n                                 (\\<lambda>\\<alpha>1.\n                                     fst \\<A> M (\\<^bold>g [^] \\<alpha>0)\n(\\<^bold>g [^] \\<alpha>1) (\\<^bold>g [^] r)\n((\\<^bold>g [^] \\<alpha>0) [^] r)\n((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) z \\<bind>\n                                     (\\<lambda>p.\n   assert_spmf\n    ((fst (fst p), fst (snd (fst p)), snd (snd (fst p))) =\n     (fst (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n           \\<^bold>g [^] r,\n           (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n           inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)),\n      fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                inv (\\<^bold>g [^] \\<alpha>1),\n                \\<^bold>g [^] r,\n                (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))),\n      snd (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                inv (\\<^bold>g [^] \\<alpha>1),\n                \\<^bold>g [^] r,\n                (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                     \\<^bold>g))))) \\<bind>\n   (\\<lambda>_.\n       fst (snd \\<A>) (\\<^bold>g [^] \\<alpha>0) (\\<^bold>g [^] \\<alpha>1)\n        (fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                   inv (\\<^bold>g [^] \\<alpha>1),\n                   \\<^bold>g [^] r,\n                   (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                   inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                        \\<^bold>g))))\n        ((\\<^bold>g [^] \\<alpha>0) [^] r)\n        ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) M\n        (snd p) \\<bind>\n       (\\<lambda>p.\n           return_spmf\n            ((snd (fst (fst p)) \\<otimes>\n              inv fst (fst (fst p)) [^] \\<alpha>0,\n              snd (snd (fst p)) \\<otimes>\n              inv fst (snd (fst p)) [^] \\<alpha>1),\n             snd p))))))),\n                      \\<lambda>\\<A> M z out1. snd (snd \\<A>))\n                  \\<A>,\n                 snd (\\<lambda>\\<A> M z.\n                         sample_uniform (order \\<G>) \\<bind>\n                         (\\<lambda>r.\n                             sample_uniform (order \\<G>) \\<bind>\n                             (\\<lambda>\\<alpha>0.\n                                 sample_uniform (order \\<G>) \\<bind>\n                                 (\\<lambda>\\<alpha>1.\n                                     fst \\<A> M (\\<^bold>g [^] \\<alpha>0)\n(\\<^bold>g [^] \\<alpha>1) (\\<^bold>g [^] r)\n((\\<^bold>g [^] \\<alpha>0) [^] r)\n((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) z \\<bind>\n                                     (\\<lambda>p.\n   assert_spmf\n    ((fst (fst p), fst (snd (fst p)), snd (snd (fst p))) =\n     (fst (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1),\n           \\<^bold>g [^] r,\n           (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n           inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)),\n      fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                inv (\\<^bold>g [^] \\<alpha>1),\n                \\<^bold>g [^] r,\n                (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))),\n      snd (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                inv (\\<^bold>g [^] \\<alpha>1),\n                \\<^bold>g [^] r,\n                (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                     \\<^bold>g))))) \\<bind>\n   (\\<lambda>_.\n       fst (snd \\<A>) (\\<^bold>g [^] \\<alpha>0) (\\<^bold>g [^] \\<alpha>1)\n        (fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                   inv (\\<^bold>g [^] \\<alpha>1),\n                   \\<^bold>g [^] r,\n                   (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                   inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                        \\<^bold>g))))\n        ((\\<^bold>g [^] \\<alpha>0) [^] r)\n        ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) M\n        (snd p) \\<bind>\n       (\\<lambda>p.\n           return_spmf\n            ((snd (fst (fst p)) \\<otimes>\n              inv fst (fst (fst p)) [^] \\<alpha>0,\n              snd (snd (fst p)) \\<otimes>\n              inv fst (snd (fst p)) [^] \\<alpha>1),\n             snd p))))))),\n                      \\<lambda>\\<A> M z out1. snd (snd \\<A>))\n                  \\<A>)\n             (fst p) z (fst pa) (snd p) \\<bind>\n            (\\<lambda>out1'. return_spmf (out1', snd pa)))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>r.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>\\<alpha>0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>\\<alpha>1.\n                fst \\<A> x (\\<^bold>g [^] \\<alpha>0)\n                 (\\<^bold>g [^] \\<alpha>1) (\\<^bold>g [^] r)\n                 ((\\<^bold>g [^] \\<alpha>0) [^] r)\n                 ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)\n                 z \\<bind>\n                (\\<lambda>p.\n                    assert_spmf\n                     ((fst (fst p), fst (snd (fst p)), snd (snd (fst p))) =\n                      (fst (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                            inv (\\<^bold>g [^] \\<alpha>1),\n                            \\<^bold>g [^] r,\n                            (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                            inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                                 \\<^bold>g)),\n                       fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                                 inv (\\<^bold>g [^] \\<alpha>1),\n                                 \\<^bold>g [^] r,\n                                 (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                                 inv ((\\<^bold>g [^] \\<alpha>1) [^]\nr \\<otimes>\n\\<^bold>g))),\n                       snd (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                                 inv (\\<^bold>g [^] \\<alpha>1),\n                                 \\<^bold>g [^] r,\n                                 (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                                 inv ((\\<^bold>g [^] \\<alpha>1) [^]\nr \\<otimes>\n\\<^bold>g))))) \\<bind>\n                    (\\<lambda>_.\n                        fst (snd \\<A>) (\\<^bold>g [^] \\<alpha>0)\n                         (\\<^bold>g [^] \\<alpha>1)\n                         (fst (snd (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                                    inv (\\<^bold>g [^] \\<alpha>1),\n                                    \\<^bold>g [^] r,\n                                    (\\<^bold>g [^] \\<alpha>0) [^]\n                                    r \\<otimes>\n                                    inv ((\\<^bold>g [^] \\<alpha>1) [^]\n   r \\<otimes>\n   \\<^bold>g))))\n                         ((\\<^bold>g [^] \\<alpha>0) [^] r)\n                         ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                          \\<^bold>g)\n                         x (snd p) \\<bind>\n                        (\\<lambda>p.\n                            mal_def.trusted_party\n                             (snd (fst (fst p)) \\<otimes>\n                              inv fst (fst (fst p)) [^] \\<alpha>0,\n                              snd (snd (fst p)) \\<otimes>\n                              inv fst (snd (fst p)) [^] \\<alpha>1)\n                             y \\<bind>\n                            (\\<lambda>pa.\n                                snd (snd \\<A>) (snd p) \\<bind>\n                                (\\<lambda>adv_out.\n                                    return_spmf (adv_out, snd pa)))))))))", "by(simp add: split_def)"], ["", "lemma P1_advantages_eq: \n  shows \"mal_def.adv_P1 x y z (P1_S1, P1_S2) \\<A> D = P1_adv_real_ideal_model D x y \\<A> z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.adv_P1 x y z (P1_S1, P1_S2) \\<A> D =\n    P1_adv_real_ideal_model D x y \\<A> z", "by(simp add: mal_def.adv_P1_def P1_adv_real_ideal_model_def P1_ideal_ideal_eq)"], ["", "fun P1_DDH_mal_adv_\\<sigma>_false :: \"('grp \\<times> 'grp) \\<Rightarrow> 'aux  \\<Rightarrow> ('aux, 'grp, 'adv_out1,'state) adv_mal_P1 \\<Rightarrow> (('adv_out1 \\<times> 'grp) \\<Rightarrow> bool spmf) \\<Rightarrow> 'grp ddh.adversary\"\n  where \"P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D h a t = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = h;\n    let b0 = a [^] \\<alpha>0;\n    let b1 = t;\n    ((in1 :: 'grp, in2 ::'grp, in3 :: 'grp),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    _ :: unit \\<leftarrow> assert_spmf (in1 = h0 \\<otimes> inv h1 \\<and> in2 = a \\<and> in3 = b0 \\<otimes> inv b1);\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x0 = (z0 \\<otimes> (inv w0 [^] \\<alpha>0));\n    adv_out :: 'adv_out1 \\<leftarrow> \\<A>3 s';\n    D (adv_out, x0)}\""], ["", "fun P1_DDH_mal_adv_\\<sigma>_true :: \"('grp \\<times> 'grp) \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out1,'state) adv_mal_P1 \\<Rightarrow> (('adv_out1 \\<times> 'grp) \\<Rightarrow> bool spmf) \\<Rightarrow> 'grp ddh.adversary\"\n  where \"P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D h a t = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    \\<alpha>1 :: nat \\<leftarrow> sample_uniform (order \\<G>);\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let h0 = h;\n    let b0 = t;\n    let b1 = a [^] \\<alpha>1 \\<otimes> \\<^bold>g;\n    ((in1 :: 'grp, in2 ::'grp, in3 :: 'grp),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    _ :: unit \\<leftarrow> assert_spmf (in1 = h0 \\<otimes> inv h1 \\<and> in2 = a \\<and> in3 = b0 \\<otimes> inv b1);\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x1 = (z1 \\<otimes> (inv w1 [^] \\<alpha>1));\n    adv_out :: 'adv_out1 \\<leftarrow> \\<A>3 s';\n    D (adv_out, x1)}\""], ["", "definition P2_ideal_model :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow>  ('aux, 'grp, 'adv_out2, 'state) adv_mal_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_ideal_model M \\<sigma> z \\<A> = do {\n    let (x0,x1) = M;\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1), s) \\<leftarrow> \\<A>1 \\<sigma> z; \n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r); \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    let l = b0 \\<otimes> (inv (h0 [^] r)); \n    let \\<sigma>' = (if l = \\<one> then False else True);\n    (_ :: unit, x\\<sigma>) \\<leftarrow> funct_OT_12 (x0, x1) \\<sigma>'; \n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> (if \\<sigma>' then \\<one> else x\\<sigma>);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> (if \\<sigma>' then x\\<sigma> else \\<one>);\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["", "definition P2_ideal_model_end :: \"('grp \\<times> 'grp) \\<Rightarrow> 'grp \\<Rightarrow> (('grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) \\<times> 'state)\n                                    \\<Rightarrow> ('grp, 'adv_out2, 'state) adv_3_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_ideal_model_end M l bs \\<A>3 = do {\n    let (x0,x1) = M;\n    let ((h0,h1,a,b0,b1),s) = bs;\n    let \\<sigma>' = (if l = \\<one> then False else True);\n    (_:: unit, x\\<sigma>) \\<leftarrow> funct_OT_12 (x0, x1) \\<sigma>';\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> (if \\<sigma>' then \\<one> else x\\<sigma>);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> (if \\<sigma>' then x\\<sigma> else \\<one>);\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s;\n    return_spmf ((), out)}\""], ["", "definition P2_ideal_model' :: \"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out2, 'state) adv_mal_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_ideal_model' M \\<sigma> z \\<A> = do {\n    let (x0,x1) = M;\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3 :: 'grp), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    let l = b0 \\<otimes> (inv (h0 [^] r));\n    P2_ideal_model_end (x0,x1) l ((h0,h1,a,b0,b1),s') \\<A>3}\""], ["", "lemma P2_ideal_model_rewrite: \"P2_ideal_model M \\<sigma> z \\<A> = P2_ideal_model' M \\<sigma> z \\<A> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model M \\<sigma> z \\<A> = P2_ideal_model' M \\<sigma> z \\<A>", "by(simp add: P2_ideal_model'_def P2_ideal_model_def P2_ideal_model_end_def Let_def split_def)"], ["", "definition P2_real_model_end :: \"('grp \\<times> 'grp) \\<Rightarrow> (('grp \\<times> 'grp \\<times> 'grp \\<times> 'grp \\<times> 'grp) \\<times> 'state) \n                                    \\<Rightarrow> ('grp, 'adv_out2,'state) adv_3_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_real_model_end M bs \\<A>3 = do {\n    let (x0,x1) = M;\n    let ((h0,h1,a,b0,b1),s) = bs;\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>); \n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let e0 = (w0, z0);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let e1 = (w1, z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s;\n    return_spmf ((), out)}\""], ["", "definition P2_real_model' ::\"('grp \\<times> 'grp) \\<Rightarrow> bool \\<Rightarrow> 'aux \\<Rightarrow> ('aux, 'grp, 'adv_out2, 'state) adv_mal_P2 \\<Rightarrow> (unit \\<times> 'adv_out2) spmf\"\n  where \"P2_real_model' M \\<sigma> z \\<A> = do {\n    let (x0,x1) = M;\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3 :: 'grp), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    P2_real_model_end M ((h0,h1,a,b0,b1),s') \\<A>3}\""], ["", "lemma P2_real_model_rewrite: \"P2_real_model M \\<sigma> z \\<A> = P2_real_model' M \\<sigma> z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_real_model M \\<sigma> z \\<A> = P2_real_model' M \\<sigma> z \\<A>", "by(simp add: P2_real_model'_def P2_real_model_def P2_real_model_end_def split_def)"], ["", "lemma P2_ideal_view_unfold: \"mal_def.ideal_view_2 (x0,x1) \\<sigma> z (P2_S1, P2_S2) \\<A> = P2_ideal_model (x0,x1) \\<sigma> z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.ideal_view_2 (x0, x1) \\<sigma> z (P2_S1, P2_S2) \\<A> =\n    P2_ideal_model (x0, x1) \\<sigma> z \\<A>", "unfolding local.mal_def.ideal_view_2_def P2_ideal_model_def local.mal_def.ideal_game_2_def P2_S1_def P2_S2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (S1, S2) =\n           (\\<lambda>\\<A> \\<sigma> z.\n               let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n               in \\<A>1 \\<sigma> z \\<bind>\n                  (\\<lambda>((h0, h1, a, b0, b1), s).\n                      assert_spmf\n                       (h0 \\<in> carrier \\<G> \\<and>\n                        h1 \\<in> carrier \\<G> \\<and>\n                        a \\<in> carrier \\<G> \\<and>\n                        b0 \\<in> carrier \\<G> \\<and>\n                        b1 \\<in> carrier \\<G>) \\<bind>\n                      (\\<lambda>_.\n                          \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                          (\\<lambda>(((in1, in2, in3), r), s').\n                              let (h, a, b) =\n                                    (h0 \\<otimes> inv h1, a,\n                                     b0 \\<otimes> inv b1)\n                              in funct_DH_ZK (h, a, b)\n                                  ((in1, in2, in3), r) \\<bind>\n                                 (\\<lambda>(out_zk_funct, uu_).\n                                     assert_spmf out_zk_funct \\<bind>\n                                     (\\<lambda>_.\n   let l = b0 \\<otimes> inv (h0 [^] r)\n   in return_spmf\n       (if l = \\<one> then False else True, (h0, h1, a, b0, b1), s')))))),\n            \\<lambda>\\<A> \\<sigma>' z x\\<sigma> aux_out.\n               let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n                   ((h0, h1, a, b0, b1), s) = aux_out\n               in sample_uniform (order \\<G>) \\<bind>\n                  (\\<lambda>u0.\n                      sample_uniform (order \\<G>) \\<bind>\n                      (\\<lambda>v0.\n                          sample_uniform (order \\<G>) \\<bind>\n                          (\\<lambda>u1.\n                              sample_uniform (order \\<G>) \\<bind>\n                              (\\<lambda>v1.\n                                  let w0 =\n  a [^] u0 \\<otimes> \\<^bold>g [^] v0;\nw1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\nz0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes>\n     (if \\<sigma>' then \\<one> else x\\<sigma>);\nz1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes>\n     (if \\<sigma>' then x\\<sigma> else \\<one>);\ne0 = (w0, z0); e1 = (w1, z1)\n                                  in \\<A>3 e0 e1 s)))));\n         (A1, A2) = (S1 \\<A>, S2 \\<A>)\n     in A1 \\<sigma> z \\<bind>\n        (\\<lambda>(y', aux_out).\n            mal_def.trusted_party (x0, x1) y' \\<bind>\n            (\\<lambda>(out1, out2).\n                A2 y' z out2 aux_out \\<bind>\n                (\\<lambda>out2'. return_spmf (out1, out2'))))) =\n    (let (x0, x1) = (x0, x1); (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               let l = b0 \\<otimes> inv (h0 [^] r);\n                                   \\<sigma>' =\n                                     if l = \\<one> then False else True\n                               in mal_def.trusted_party (x0, x1)\n                                   \\<sigma>' \\<bind>\n                                  (\\<lambda>(uu_, x\\<sigma>).\nsample_uniform (order \\<G>) \\<bind>\n(\\<lambda>u0.\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>v0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>u1.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>v1.\n                let w0 = a [^] u0 \\<otimes> \\<^bold>g [^] v0;\n                    w1 = a [^] u1 \\<otimes> \\<^bold>g [^] v1;\n                    z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes>\n                         (if \\<sigma>' then \\<one> else x\\<sigma>);\n                    z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                         h1 [^] v1 \\<otimes>\n                         (if \\<sigma>' then x\\<sigma> else \\<one>);\n                    e0 = (w0, z0); e1 = (w1, z1)\n                in \\<A>3 e0 e1 s' \\<bind>\n                   (\\<lambda>out. return_spmf ((), out)))))))))))))", "by(auto simp add: Let_def split_def)"], ["", "end"], ["", "locale ot = ot_base + cyclic_group \\<G>\nbegin"], ["", "lemma P1_assert_correct1: \n  shows \"((\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat) \\<otimes> \\<^bold>g \\<otimes> inv ((\\<^bold>g [^] (\\<alpha>1::nat)) [^] r \\<otimes> \\<^bold>g) \n                = (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r)\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have in_carrier1: \"(\\<^bold>g [^] \\<alpha>1) [^] r \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>1) [^] r \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>1) [^] r \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have in_carrier2: \"inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have 1:\"?lhs = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> inv \\<^bold>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    inv \\<^bold>g", "using  cyclic_group_assoc nat_pow_pow inverse_split in_carrier1"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  ?x \\<in> carrier \\<G> \\<Longrightarrow>\n  (?x [^] ?n) [^] ?m = ?x [^] (?n * ?m)\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> inv (?a \\<otimes> ?b) = inv ?a \\<otimes> inv ?b\n  (\\<^bold>g [^] \\<alpha>1) [^] r \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    inv \\<^bold>g", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have 2:\"... = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes> inv \\<^bold>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n    inv \\<^bold>g", "using cyclic_group_assoc in_carrier2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n    inv \\<^bold>g", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have \"... = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes> inv \\<^bold>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n    inv \\<^bold>g", "using in_carrier2 cyclic_group_commute"], ["proof (prove)\nusing this:\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n    inv \\<^bold>g", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (\\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n  inv \\<^bold>g\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have 3: \"... = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> (\\<^bold>g \\<otimes> inv \\<^bold>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    (\\<^bold>g \\<otimes> inv \\<^bold>g)", "using cyclic_group_assoc in_carrier2"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n    inv \\<^bold>g =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    (\\<^bold>g \\<otimes> inv \\<^bold>g)", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  (\\<^bold>g \\<otimes> inv \\<^bold>g)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  (inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes> \\<^bold>g) \\<otimes>\n  inv \\<^bold>g =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  (\\<^bold>g \\<otimes> inv \\<^bold>g)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have \"... = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n    (\\<^bold>g \\<otimes> inv \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r)", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  (\\<^bold>g \\<otimes> inv \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) \\<otimes>\n  (\\<^bold>g \\<otimes> inv \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have \"... = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1)) [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv (\\<^bold>g [^] \\<alpha>1) [^] r", "using inverse_pow_pow"], ["proof (prove)\nusing this:\n  ?a \\<in> carrier \\<G> \\<Longrightarrow> inv (?a [^] ?r) = inv ?a [^] ?r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv (\\<^bold>g [^] \\<alpha>1) [^] r", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv (\\<^bold>g [^] \\<alpha>1) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "ultimately"], ["proof (chain)\npicking this:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r)\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv (\\<^bold>g [^] \\<alpha>1) [^] r", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r)\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv (\\<^bold>g [^] \\<alpha>1) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "by (simp add: cyclic_group_commute pow_mult_distrib)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g) =\n  (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_assert_correct2: \n  shows   \"(\\<^bold>g [^] (\\<alpha>0::nat)) [^] (r::nat) \\<otimes> inv ((\\<^bold>g [^] (\\<alpha>1::nat)) [^] r) = (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r\"\n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "have in_carrier2:\"\\<^bold>g [^] \\<alpha>1 \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] \\<alpha>1 \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] \\<alpha>1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "hence \"?lhs = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1)) [^] r\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] \\<alpha>1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv (\\<^bold>g [^] \\<alpha>1) [^] r", "using inverse_pow_pow"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] \\<alpha>1 \\<in> carrier \\<G>\n  ?a \\<in> carrier \\<G> \\<Longrightarrow> inv (?a [^] ?r) = inv ?a [^] ?r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv (\\<^bold>g [^] \\<alpha>1) [^] r", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv (\\<^bold>g [^] \\<alpha>1) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv (\\<^bold>g [^] \\<alpha>1) [^] r\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n    inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n    (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r", "by (simp add: cyclic_group_commute monoid_comm_monoidI pow_mult_distrib)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n  inv ((\\<^bold>g [^] \\<alpha>1) [^] r) =\n  (\\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1)) [^] r\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale ddh: ddh_ext"], ["proof (prove)\ngoal (1 subgoal):\n 1. ddh_ext \\<G>", "by (simp add: cyclic_group_axioms ddh_ext.intro)"], ["", "lemma P1_real_ddh0_\\<sigma>_false:\n  assumes \"\\<sigma> = False\"\n  shows \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "have \n    \"(in2 = \\<^bold>g [^] (r::nat) \\<and> in3 = in1 [^] r \\<and> in1 = \\<^bold>g [^] (\\<alpha>0::nat) \\<otimes> inv (\\<^bold>g [^] (\\<alpha>1::nat)) \n        \\<and> in2 = \\<^bold>g [^] r \\<and> in3 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r))\n          \\<longleftrightarrow> (in1 = \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and> in2 = \\<^bold>g [^] r \\<and> in3 \n            = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r))\"  \n    for in1 in2 in3 r \\<alpha>0 \\<alpha>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (in2 = \\<^bold>g [^] r \\<and>\n     in3 = in1 [^] r \\<and>\n     in1 =\n     \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and>\n     in2 = \\<^bold>g [^] r \\<and>\n     in3 =\n     (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r)) =\n    (in1 =\n     \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and>\n     in2 = \\<^bold>g [^] r \\<and>\n     in3 =\n     (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r))", "by (auto simp add: P1_assert_correct2 power_swap)"], ["proof (state)\nthis:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "moreover"], ["proof (state)\nthis:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "have \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n    let b1 = h1 [^] r;\n    ((in1, in2, in3),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (b :: bool, _ :: unit) \\<leftarrow> funct_DH_ZK (in1, in2, in3) ((h,a,b), r);\n    _ :: unit \\<leftarrow> assert_spmf (b); \n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    adv_out \\<leftarrow> \\<A>3 s';\n    D (adv_out, ((z0 \\<otimes> (inv w0 [^] \\<alpha>0))))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>\\<alpha>0.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>\\<alpha>1.\n                    let h0 = \\<^bold>g [^] \\<alpha>0;\n                        h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                        b0 = (\\<^bold>g [^] r) [^] \\<alpha>0; b1 = h1 [^] r\n                    in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                       (\\<lambda>((in1, in2, in3), s).\n                           let (h, a, b) =\n                                 (h0 \\<otimes> inv h1, a,\n                                  b0 \\<otimes> inv b1)\n                           in funct_DH_ZK (in1, in2, in3)\n                               ((h, a, b), r) \\<bind>\n                              (\\<lambda>(b, uu_).\n                                  assert_spmf b \\<bind>\n                                  (\\<lambda>_.\n\\<A>2 h0 h1 a b0 b1 M s \\<bind>\n(\\<lambda>(((w0, z0), w1, z1), s').\n    \\<A>3 s' \\<bind>\n    (\\<lambda>adv_out.\n        D (adv_out, z0 \\<otimes> inv w0 [^] \\<alpha>0))))))))))", "by(simp add: P1_real_model_def assms split_def Let_def power_swap)"], ["proof (state)\nthis:\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0; b1 = h1 [^] r\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z0 \\<otimes> inv w0 [^] \\<alpha>0))))))))))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "ultimately"], ["proof (chain)\npicking this:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23))\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0; b1 = h1 [^] r\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z0 \\<otimes> inv w0 [^] \\<alpha>0))))))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23))\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0; b1 = h1 [^] r\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z0 \\<otimes> inv w0 [^] \\<alpha>0))))))))))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "by(simp add: P1_real_model_def ddh.DDH0_def Let_def)"], ["proof (state)\nthis:\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_ideal_ddh1_\\<sigma>_false:\n  assumes \"\\<sigma> = False\"\n  shows \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "have \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n    let b1 = h1 [^] r \\<otimes> \\<^bold>g;\n    ((in1, in2, in3),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    _ :: unit \\<leftarrow> assert_spmf ((in1, in2, in3) = (h,a,b));\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x0 = (z0 \\<otimes> (inv w0 [^] \\<alpha>0));\n    let x1 = (z1 \\<otimes> (inv w1 [^] \\<alpha>1));\n    (_, f_out2) \\<leftarrow> funct_OT_12  (x0, x1) \\<sigma>;\n    adv_out \\<leftarrow> \\<A>3 s';\n    D (adv_out, f_out2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>\\<alpha>0.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>\\<alpha>1.\n                    let h0 = \\<^bold>g [^] \\<alpha>0;\n                        h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                        b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                        b1 = h1 [^] r \\<otimes> \\<^bold>g\n                    in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                       (\\<lambda>((in1, in2, in3), s).\n                           let (h, a, b) =\n                                 (h0 \\<otimes> inv h1, a,\n                                  b0 \\<otimes> inv b1)\n                           in assert_spmf\n                               ((in1, in2, in3) = (h, a, b)) \\<bind>\n                              (\\<lambda>_.\n                                  \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                  (\\<lambda>(((w0, z0), w1, z1), s').\nlet x0 = z0 \\<otimes> inv w0 [^] \\<alpha>0;\n    x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\nin mal_def.trusted_party (x0, x1) \\<sigma> \\<bind>\n   (\\<lambda>(uu_, f_out2).\n       \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))", "by(simp add: P1_ideal_model_def assms split_def Let_def  power_swap)"], ["proof (state)\nthis:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in assert_spmf\n                             ((in1, in2, in3) = (h, a, b)) \\<bind>\n                            (\\<lambda>_.\n                                \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                (\\<lambda>(((w0, z0), w1, z1), s').\n                                    let x0 =\n    z0 \\<otimes> inv w0 [^] \\<alpha>0;\n  x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\n                                    in mal_def.trusted_party (x0, x1)\n  \\<sigma> \\<bind>\n (\\<lambda>(uu_, f_out2).\n     \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))\n\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in assert_spmf\n                             ((in1, in2, in3) = (h, a, b)) \\<bind>\n                            (\\<lambda>_.\n                                \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                (\\<lambda>(((w0, z0), w1, z1), s').\n                                    let x0 =\n    z0 \\<otimes> inv w0 [^] \\<alpha>0;\n  x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\n                                    in mal_def.trusted_party (x0, x1)\n  \\<sigma> \\<bind>\n (\\<lambda>(uu_, f_out2).\n     \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))\n\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "by(auto simp add: P1_ideal_model_def ddh.DDH1_def funct_OT_12_def Let_def assms )"], ["proof (state)\nthis:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_real_ddh1_\\<sigma>_true:\n  assumes \"\\<sigma> = True\"\n  shows \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "have \"(in2 = \\<^bold>g [^] (r::nat) \\<and> in3 = in1 [^] r \\<and> in1 = \\<^bold>g [^] (\\<alpha>0::nat) \\<otimes> inv (\\<^bold>g [^] (\\<alpha>1::nat)) \n          \\<and> in2 = \\<^bold>g [^] r \\<and> in3 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes> \\<^bold>g \\<otimes> inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g))\n          \\<longleftrightarrow> (in1 = \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and> in2 = \\<^bold>g [^] r \n              \\<and> in3 = (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes> inv ((\\<^bold>g [^] r) [^] \\<alpha>1 \\<otimes> \\<^bold>g))\"\n    for in1 in2 in3 r \\<alpha>0 \\<alpha>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (in2 = \\<^bold>g [^] r \\<and>\n     in3 = in1 [^] r \\<and>\n     in1 =\n     \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and>\n     in2 = \\<^bold>g [^] r \\<and>\n     in3 =\n     (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes> \\<^bold>g \\<otimes>\n     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g)) =\n    (in1 =\n     \\<^bold>g [^] \\<alpha>0 \\<otimes> inv (\\<^bold>g [^] \\<alpha>1) \\<and>\n     in2 = \\<^bold>g [^] r \\<and>\n     in3 =\n     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv ((\\<^bold>g [^] r) [^] \\<alpha>1 \\<otimes> \\<^bold>g))", "by (auto simp add: P1_assert_correct1 power_swap)"], ["proof (state)\nthis:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23 \\<otimes> \\<^bold>g)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?\\<alpha>0.23) [^] ?r23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?r23) [^] ?\\<alpha>1.23 \\<otimes> \\<^bold>g))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "moreover"], ["proof (state)\nthis:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23 \\<otimes> \\<^bold>g)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?\\<alpha>0.23) [^] ?r23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?r23) [^] ?\\<alpha>1.23 \\<otimes> \\<^bold>g))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "have \"((P1_real_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = ((\\<^bold>g [^] r) [^] \\<alpha>0) \\<otimes> \\<^bold>g;\n    let b1 = (h1 [^] r) \\<otimes> \\<^bold>g;\n    ((in1, in2, in3),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (b :: bool, _ :: unit) \\<leftarrow> funct_DH_ZK (in1, in2, in3) ((h,a,b), r);\n    _ :: unit \\<leftarrow> assert_spmf (b); \n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    adv_out \\<leftarrow> \\<A>3 s';\n    D (adv_out, ((z1 \\<otimes> (inv w1 [^] \\<alpha>1))))}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>\\<alpha>0.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>\\<alpha>1.\n                    let h0 = \\<^bold>g [^] \\<alpha>0;\n                        h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                        b0 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n                             \\<^bold>g;\n                        b1 = h1 [^] r \\<otimes> \\<^bold>g\n                    in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                       (\\<lambda>((in1, in2, in3), s).\n                           let (h, a, b) =\n                                 (h0 \\<otimes> inv h1, a,\n                                  b0 \\<otimes> inv b1)\n                           in funct_DH_ZK (in1, in2, in3)\n                               ((h, a, b), r) \\<bind>\n                              (\\<lambda>(b, uu_).\n                                  assert_spmf b \\<bind>\n                                  (\\<lambda>_.\n\\<A>2 h0 h1 a b0 b1 M s \\<bind>\n(\\<lambda>(((w0, z0), w1, z1), s').\n    \\<A>3 s' \\<bind>\n    (\\<lambda>adv_out.\n        D (adv_out, z1 \\<otimes> inv w1 [^] \\<alpha>1))))))))))", "by(simp add: P1_real_model_def assms split_def Let_def power_swap)"], ["proof (state)\nthis:\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n                           \\<^bold>g;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z1 \\<otimes> inv w1 [^] \\<alpha>1))))))))))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "ultimately"], ["proof (chain)\npicking this:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23 \\<otimes> \\<^bold>g)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?\\<alpha>0.23) [^] ?r23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?r23) [^] ?\\<alpha>1.23 \\<otimes> \\<^bold>g))\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n                           \\<^bold>g;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z1 \\<otimes> inv w1 [^] \\<alpha>1))))))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  (?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 = ?in1.23 [^] ?r23 \\<and>\n   ?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?r23) [^] ?\\<alpha>0.23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23 \\<otimes> \\<^bold>g)) =\n  (?in1.23 =\n   \\<^bold>g [^] ?\\<alpha>0.23 \\<otimes>\n   inv (\\<^bold>g [^] ?\\<alpha>1.23) \\<and>\n   ?in2.23 = \\<^bold>g [^] ?r23 \\<and>\n   ?in3.23 =\n   (\\<^bold>g [^] ?\\<alpha>0.23) [^] ?r23 \\<otimes> \\<^bold>g \\<otimes>\n   inv ((\\<^bold>g [^] ?r23) [^] ?\\<alpha>1.23 \\<otimes> \\<^bold>g))\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0 \\<otimes>\n                           \\<^bold>g;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in funct_DH_ZK (in1, in2, in3)\n                             ((h, a, b), r) \\<bind>\n                            (\\<lambda>(b, uu_).\n                                assert_spmf b \\<bind>\n                                (\\<lambda>_.\n                                    \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                    (\\<lambda>(((w0, z0), w1, z1), s').\n  \\<A>3 s' \\<bind>\n  (\\<lambda>adv_out. D (adv_out, z1 \\<otimes> inv w1 [^] \\<alpha>1))))))))))\n\ngoal (1 subgoal):\n 1. P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "by(simp add: Let_def P1_real_model_def ddh.DDH1_def assms power_swap)"], ["proof (state)\nthis:\n  P1_real_model M \\<sigma> z \\<A> \\<bind> D =\n  local.ddh.DDH1 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_ideal_ddh0_\\<sigma>_true:\n  assumes \"\\<sigma> = True\"\n  shows \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = (ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "have \"((P1_ideal_model M \\<sigma> z \\<A>) \\<bind> (\\<lambda> view. D view)) = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    r \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>0 \\<leftarrow> sample_uniform (order \\<G>);\n    \\<alpha>1 \\<leftarrow> sample_uniform (order \\<G>);\n    let h0 = \\<^bold>g [^] \\<alpha>0;\n    let h1 = \\<^bold>g [^] \\<alpha>1;\n    let a = \\<^bold>g [^] r;\n    let b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n    let b1 = h1 [^] r \\<otimes> \\<^bold>g;\n    ((in1, in2, in3),s) \\<leftarrow> \\<A>1 M h0 h1 a b0 b1 z;\n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    _ :: unit \\<leftarrow> assert_spmf ((in1, in2, in3) = (h,a,b));\n    (((w0,z0),(w1,z1)),s') \\<leftarrow> \\<A>2 h0 h1 a b0 b1 M s;\n    let x0 = (z0 \\<otimes> (inv w0 [^] \\<alpha>0));\n    let x1 = (z1 \\<otimes> (inv w1 [^] \\<alpha>1));\n    (_, f_out2) \\<leftarrow> funct_OT_12  (x0, x1) \\<sigma>;\n    adv_out \\<leftarrow> \\<A>3 s';\n    D (adv_out, f_out2)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>r.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>\\<alpha>0.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>\\<alpha>1.\n                    let h0 = \\<^bold>g [^] \\<alpha>0;\n                        h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                        b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                        b1 = h1 [^] r \\<otimes> \\<^bold>g\n                    in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                       (\\<lambda>((in1, in2, in3), s).\n                           let (h, a, b) =\n                                 (h0 \\<otimes> inv h1, a,\n                                  b0 \\<otimes> inv b1)\n                           in assert_spmf\n                               ((in1, in2, in3) = (h, a, b)) \\<bind>\n                              (\\<lambda>_.\n                                  \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                  (\\<lambda>(((w0, z0), w1, z1), s').\nlet x0 = z0 \\<otimes> inv w0 [^] \\<alpha>0;\n    x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\nin mal_def.trusted_party (x0, x1) \\<sigma> \\<bind>\n   (\\<lambda>(uu_, f_out2).\n       \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))", "by(simp add: P1_ideal_model_def assms Let_def split_def power_swap)"], ["proof (state)\nthis:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in assert_spmf\n                             ((in1, in2, in3) = (h, a, b)) \\<bind>\n                            (\\<lambda>_.\n                                \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                (\\<lambda>(((w0, z0), w1, z1), s').\n                                    let x0 =\n    z0 \\<otimes> inv w0 [^] \\<alpha>0;\n  x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\n                                    in mal_def.trusted_party (x0, x1)\n  \\<sigma> \\<bind>\n (\\<lambda>(uu_, f_out2).\n     \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))\n\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "thus ?thesis"], ["proof (prove)\nusing this:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>r.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>\\<alpha>0.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>\\<alpha>1.\n                  let h0 = \\<^bold>g [^] \\<alpha>0;\n                      h1 = \\<^bold>g [^] \\<alpha>1; a = \\<^bold>g [^] r;\n                      b0 = (\\<^bold>g [^] r) [^] \\<alpha>0;\n                      b1 = h1 [^] r \\<otimes> \\<^bold>g\n                  in \\<A>1 M h0 h1 a b0 b1 z \\<bind>\n                     (\\<lambda>((in1, in2, in3), s).\n                         let (h, a, b) =\n                               (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                         in assert_spmf\n                             ((in1, in2, in3) = (h, a, b)) \\<bind>\n                            (\\<lambda>_.\n                                \\<A>2 h0 h1 a b0 b1 M s \\<bind>\n                                (\\<lambda>(((w0, z0), w1, z1), s').\n                                    let x0 =\n    z0 \\<otimes> inv w0 [^] \\<alpha>0;\n  x1 = z1 \\<otimes> inv w1 [^] \\<alpha>1\n                                    in mal_def.trusted_party (x0, x1)\n  \\<sigma> \\<bind>\n (\\<lambda>(uu_, f_out2).\n     \\<A>3 s' \\<bind> (\\<lambda>adv_out. D (adv_out, f_out2))))))))))\n\ngoal (1 subgoal):\n 1. P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n    local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "by(simp add: split_def Let_def P1_ideal_model_def ddh.DDH0_def assms funct_OT_12_def power_swap)"], ["proof (state)\nthis:\n  P1_ideal_model M \\<sigma> z \\<A> \\<bind> D =\n  local.ddh.DDH0 (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P1_real_ideal_DDH_advantage_false:\n  assumes \"\\<sigma> = False\" \n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D = ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D =\n    local.ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D)", "by(simp add: P1_adv_real_ideal_model_def ddh.DDH_advantage_def P1_ideal_ddh1_\\<sigma>_false P1_real_ddh0_\\<sigma>_false assms P1_advantages_eq)"], ["", "lemma P1_real_ideal_DDH_advantage_false_bound:\n  assumes \"\\<sigma> = False\"\n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D \n          \\<le> ddh.advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D) \n            + ddh.advantage (ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D\n    \\<le> local.ddh.advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D) +\n          local.ddh.advantage\n           (local.ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))", "using P1_real_ideal_DDH_advantage_false ddh.DDH_advantage_bound assms"], ["proof (prove)\nusing this:\n  ?\\<sigma> = False \\<Longrightarrow>\n  mal_def.adv_P1 ?M ?\\<sigma> ?z (P1_S1, P1_S2) ?\\<A> ?D =\n  local.ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_false ?M ?z ?\\<A> ?D)\n  local.ddh.DDH_advantage ?\\<A>\n  \\<le> local.ddh.advantage ?\\<A> +\n        local.ddh.advantage (local.ddh.DDH_\\<A>' ?\\<A>)\n  \\<sigma> = False\n\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D\n    \\<le> local.ddh.advantage (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D) +\n          local.ddh.advantage\n           (local.ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_false M z \\<A> D))", "by metis"], ["", "lemma P1_real_ideal_DDH_advantage_true:\n  assumes \"\\<sigma> = True\" \n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D = ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D =\n    local.ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D)", "by(simp add: P1_adv_real_ideal_model_def ddh.DDH_advantage_def P1_real_ddh1_\\<sigma>_true P1_ideal_ddh0_\\<sigma>_true assms P1_advantages_eq)"], ["", "lemma P1_real_ideal_DDH_advantage_true_bound:\n  assumes \"\\<sigma> = True\"\n  shows \"mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D \n          \\<le> ddh.advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D) \n            + ddh.advantage (ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D\n    \\<le> local.ddh.advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D) +\n          local.ddh.advantage\n           (local.ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))", "using P1_real_ideal_DDH_advantage_true ddh.DDH_advantage_bound assms"], ["proof (prove)\nusing this:\n  ?\\<sigma> = True \\<Longrightarrow>\n  mal_def.adv_P1 ?M ?\\<sigma> ?z (P1_S1, P1_S2) ?\\<A> ?D =\n  local.ddh.DDH_advantage (P1_DDH_mal_adv_\\<sigma>_true ?M ?z ?\\<A> ?D)\n  local.ddh.DDH_advantage ?\\<A>\n  \\<le> local.ddh.advantage ?\\<A> +\n        local.ddh.advantage (local.ddh.DDH_\\<A>' ?\\<A>)\n  \\<sigma> = True\n\ngoal (1 subgoal):\n 1. mal_def.adv_P1 M \\<sigma> z (P1_S1, P1_S2) \\<A> D\n    \\<le> local.ddh.advantage (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D) +\n          local.ddh.advantage\n           (local.ddh.DDH_\\<A>' (P1_DDH_mal_adv_\\<sigma>_true M z \\<A> D))", "by metis"], ["", "(*Auxillary proofs that we use in the proof of security, mainly rewriting things for P2*)"], ["", "lemma P2_output_rewrite:\n  assumes \"s < order \\<G>\"\n  shows \"(\\<^bold>g [^] (r * u1 + v1),  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1)\n           = (\\<^bold>g [^] (r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>),  \n             \\<^bold>g [^] (r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n               \\<otimes> inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "have \"\\<^bold>g [^] (r * u1 + v1) = \\<^bold>g [^] (r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 + v1) =\n    \\<^bold>g [^]\n    (r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 + v1) =\n    \\<^bold>g [^]\n    (r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G>)", "have \"[(r * u1 + v1) = (r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>)] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "have \"[(r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>) = r * (s + u1) + (r * order \\<G> - r * s + v1)] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod\n     order\n      \\<G> = r * (s + u1) + (r * order \\<G> - r * s + v1)] (mod order \\<G>)", "by (metis (no_types, hide_lams) cong_def mod_add_left_eq mod_add_right_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order\n    \\<G> = r * (s + u1) + (r * order \\<G> - r * s + v1)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>) = r * s + r * u1 + r * order \\<G> - r * s + v1] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order\n    \\<G> = r * (s + u1) + (r * order \\<G> - r * s + v1)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod\n     order\n      \\<G> = r * s + r * u1 + r * order \\<G> - r * s + v1] (mod order \\<G>)", "by (metis (no_types, lifting) Nat.add_diff_assoc add.assoc assms distrib_left less_or_eq_imp_le mult_le_mono)"], ["proof (state)\nthis:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order\n    \\<G> = r * s + r * u1 + r * order \\<G> - r * s + v1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G>) = r * u1 + r * order \\<G> + v1] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order\n    \\<G> = r * s + r * u1 + r * order \\<G> - r * s + v1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod\n     order \\<G> = r * u1 + r * order \\<G> + v1] (mod order \\<G>)", "by simp"], ["proof (state)\nthis:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order \\<G> = r * u1 + r * order \\<G> + v1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod\n   order \\<G> = r * u1 + r * order \\<G> + v1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * u1 +\n     v1 = r * ((s + u1) mod order \\<G>) +\n          (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "by (simp add: cong_def semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  [r * u1 +\n   v1 = r * ((s + u1) mod order \\<G>) +\n        (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * u1 +\n   v1 = r * ((s + u1) mod order \\<G>) +\n        (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 + v1) =\n    \\<^bold>g [^]\n    (r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [r * u1 +\n   v1 = r * ((s + u1) mod order \\<G>) +\n        (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r * u1 +\n   v1 = r * ((s + u1) mod order \\<G>) +\n        (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 + v1) =\n    \\<^bold>g [^]\n    (r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G>)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r * u1 +\n   v1 = r * ((s + u1) mod order \\<G>) +\n        (r * order \\<G> - r * s + v1) mod order \\<G>] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 + v1) =\n    \\<^bold>g [^]\n    (r * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 + v1) =\n  \\<^bold>g [^]\n  (r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 + v1) =\n  \\<^bold>g [^]\n  (r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 + v1) =\n  \\<^bold>g [^]\n  (r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "have \" \\<^bold>g [^] (r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n               \\<otimes> inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) \n                    = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "have \"\\<^bold>g [^] (r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)", "have \"[(r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "have \"[(r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * (s + u1) + (r * order \\<G> - r * s + v1) * \\<alpha>] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * (s + u1) +\n                (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)", "using cong_def mod_add_cong mod_mult_left_eq mod_mult_right_eq"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  \\<lbrakk>?a mod ?c = ?a' mod ?c; ?b mod ?c = ?b' mod ?c\\<rbrakk>\n  \\<Longrightarrow> (?a + ?b) mod ?c = (?a' + ?b') mod ?c\n  ?a mod ?c * ?b mod ?c = ?a * ?b mod ?c\n  ?a * (?b mod ?c) mod ?c = ?a * ?b mod ?c\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * (s + u1) +\n                (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (s + u1) +\n              (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * s + r * \\<alpha> * u1 + (r * order \\<G> - r * s + v1) * \\<alpha>] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (s + u1) +\n              (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n                (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n              (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * s + r * \\<alpha> * u1 + r * order \\<G> * \\<alpha> - r * s * \\<alpha> + v1 * \\<alpha>] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n              (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n                r * order \\<G> * \\<alpha> -\n                r * s * \\<alpha> +\n                v1 * \\<alpha>] (mod order \\<G>)", "using distrib_right assms"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n              (r * order \\<G> - r * s + v1) * \\<alpha>] (mod order \\<G>)\n  (?a + ?b) * ?c = ?a * ?c + ?b * ?c\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n                r * order \\<G> * \\<alpha> -\n                r * s * \\<alpha> +\n                v1 * \\<alpha>] (mod order \\<G>)", "by (smt Groups.mult_ac(3) order_gt_0 Nat.add_diff_assoc2 add.commute diff_mult_distrib2 mult.commute mult_strict_mono order.strict_implies_order semiring_normalization_rules(25) zero_order(1))"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n              r * order \\<G> * \\<alpha> -\n              r * s * \\<alpha> +\n              v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((s + u1) mod order \\<G>) + (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * u1 + r * order \\<G> * \\<alpha> + v1 * \\<alpha>] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * s + r * \\<alpha> * u1 +\n              r * order \\<G> * \\<alpha> -\n              r * s * \\<alpha> +\n              v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + r * order \\<G> * \\<alpha> +\n                v1 * \\<alpha>] (mod order \\<G>)", "by simp"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + r * order \\<G> * \\<alpha> +\n              v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + r * order \\<G> * \\<alpha> +\n              v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)", "by (simp add: cong_def semiring_normalization_rules(16) semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * u1 + v1 * \\<alpha>] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "have \"inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) = inv \\<^bold>g [^] u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    inv \\<^bold>g [^] u1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    inv \\<^bold>g [^] u1", "have \"[((s + u1) mod order \\<G> + (order \\<G> - s)) = u1] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)", "have \"[((s + u1) mod order \\<G> + (order \\<G> - s)) = s + u1 + (order \\<G> - s)] (mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> +\n     (order \\<G> - s) = s + u1 + (order \\<G> - s)] (mod order \\<G>)", "by (simp add: add.commute mod_add_right_eq cong_def)"], ["proof (state)\nthis:\n  [(s + u1) mod order \\<G> +\n   (order \\<G> - s) = s + u1 + (order \\<G> - s)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)", "hence \"[((s + u1) mod order \\<G> + (order \\<G> - s)) = u1 + order \\<G>] (mod (order \\<G>))\""], ["proof (prove)\nusing this:\n  [(s + u1) mod order \\<G> +\n   (order \\<G> - s) = s + u1 + (order \\<G> - s)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> +\n     (order \\<G> - s) = u1 + order \\<G>] (mod order \\<G>)", "using assms"], ["proof (prove)\nusing this:\n  [(s + u1) mod order \\<G> +\n   (order \\<G> - s) = s + u1 + (order \\<G> - s)] (mod order \\<G>)\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> +\n     (order \\<G> - s) = u1 + order \\<G>] (mod order \\<G>)", "by simp"], ["proof (state)\nthis:\n  [(s + u1) mod order \\<G> +\n   (order \\<G> - s) = u1 + order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(s + u1) mod order \\<G> +\n   (order \\<G> - s) = u1 + order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    inv \\<^bold>g [^] u1", "hence \"\\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) = \\<^bold>g [^] u1\""], ["proof (prove)\nusing this:\n  [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] u1", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [(s + u1) mod order \\<G> + (order \\<G> - s) = u1] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] u1", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    inv \\<^bold>g [^] u1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    inv \\<^bold>g [^] u1", "by (metis generator_closed inverse_pow_pow)"], ["proof (state)\nthis:\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  inv \\<^bold>g [^] u1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  inv \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  inv \\<^bold>g [^] u1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>)\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  inv \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n     (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "by argo"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] u1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (r * u1 + v1) =\n  \\<^bold>g [^]\n  (r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G>)\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] u1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * u1 + v1) =\n  \\<^bold>g [^]\n  (r * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G>)\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n   (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] u1\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * u1 + v1),\n     \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] u1) =\n    (\\<^bold>g [^]\n     (r * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n      (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n     inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (r * u1 + v1),\n   \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n   inv \\<^bold>g [^] u1) =\n  (\\<^bold>g [^]\n   (r * ((s + u1) mod order \\<G>) +\n    (r * order \\<G> - r * s + v1) mod order \\<G>),\n   \\<^bold>g [^]\n   (r * \\<alpha> * ((s + u1) mod order \\<G>) +\n    (r * order \\<G> - r * s + v1) mod order \\<G> * \\<alpha>) \\<otimes>\n   inv \\<^bold>g [^] ((s + u1) mod order \\<G> + (order \\<G> - s)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_inv_g_rewrite:\n  assumes \"s < order \\<G>\" \n  shows \"(inv \\<^bold>g) [^] (u1' + (order \\<G> - s)) = \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have power_commute_rewrite: \"\\<^bold>g [^] (((order \\<G> - s) + u1') mod order \\<G>) =  \\<^bold>g [^] (u1' + (order \\<G> - s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n    \\<^bold>g [^] (u1' + (order \\<G> - s))", "using add.commute pow_generator_mod"], ["proof (prove)\nusing this:\n  ?a + ?b = ?b + ?a\n  \\<^bold>g [^] (?k mod order \\<G>) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n    \\<^bold>g [^] (u1' + (order \\<G> - s))", "by metis"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n  \\<^bold>g [^] (u1' + (order \\<G> - s))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"(order \\<G> - s + u1') mod order \\<G> = (int (order \\<G>) - int s + int u1') mod order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int ((order \\<G> - s + u1') mod order \\<G>) =\n    (int (order \\<G>) - int s + int u1') mod int (order \\<G>)", "by (metis of_nat_add of_nat_diff order.strict_implies_order zmod_int assms(1))"], ["proof (state)\nthis:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"... = (- int s + int u1') mod order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int (order \\<G>) - int s + int u1') mod int (order \\<G>) =\n    (- int s + int u1') mod int (order \\<G>)", "by (metis (full_types) add.commute minus_mod_self1 mod_add_right_eq)"], ["proof (state)\nthis:\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>) =\n  (- int s + int u1') mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "ultimately"], ["proof (chain)\npicking this:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>)\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>) =\n  (- int s + int u1') mod int (order \\<G>)", "have \"(order \\<G> - s + u1') mod order \\<G> = (- int s mod (order \\<G>) + int u1' mod (order \\<G>)) mod order \\<G>\""], ["proof (prove)\nusing this:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>)\n  (int (order \\<G>) - int s + int u1') mod int (order \\<G>) =\n  (- int s + int u1') mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. int ((order \\<G> - s + u1') mod order \\<G>) =\n    (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n    int (order \\<G>)", "by presburger"], ["proof (state)\nthis:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "hence \"\\<^bold>g [^] (((order \\<G> - s) + u1') mod order \\<G>)\n              = \\<^bold>g [^] ((- int s mod (order \\<G>) + int u1' mod (order \\<G>)) mod order \\<G>)\""], ["proof (prove)\nusing this:\n  int ((order \\<G> - s + u1') mod order \\<G>) =\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n  int (order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n    \\<^bold>g [^]\n    ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n     int (order \\<G>))", "by (metis int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "hence \"\\<^bold>g [^] (u1' + (order \\<G> - s))\n              = \\<^bold>g [^] ((- int s mod (order \\<G>) + int u1' mod (order \\<G>)) mod order \\<G>)\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^]\n    ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n     int (order \\<G>))", "using power_commute_rewrite"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>))\n  \\<^bold>g [^] ((order \\<G> - s + u1') mod order \\<G>) =\n  \\<^bold>g [^] (u1' + (order \\<G> - s))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^]\n    ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n     int (order \\<G>))", "by argo"], ["proof (state)\nthis:\n  \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"...\n              = \\<^bold>g [^] (- int s mod (order \\<G>) + int u1' mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^]\n    (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>))", "using pow_generator_mod_int"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (?k mod int (order \\<G>)) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n     int (order \\<G>)) =\n    \\<^bold>g [^]\n    (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>))", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^]\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  ((- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) mod\n   int (order \\<G>)) =\n  \\<^bold>g [^]\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"... = \\<^bold>g [^] (- int s mod (order \\<G>)) \\<otimes> \\<^bold>g [^] (int u1' mod (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) =\n    \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^] (int u1' mod int (order \\<G>))", "by (simp add: int_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) =\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (- int s mod int (order \\<G>) + int u1' mod int (order \\<G>)) =\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"... = \\<^bold>g [^] (- int s) \\<otimes> \\<^bold>g [^] (int u1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^] (int u1' mod int (order \\<G>)) =\n    \\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1'", "using pow_generator_mod_int"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (?k mod int (order \\<G>)) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n    \\<^bold>g [^] (int u1' mod int (order \\<G>)) =\n    \\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1'", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>)) =\n  \\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1'\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>))\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>)) =\n  \\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1'", "have \"inv (\\<^bold>g [^] (u1' + (order \\<G> - s))) = inv (\\<^bold>g [^] (- int s) \\<otimes> \\<^bold>g [^] (int u1'))\""], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>))\n  \\<^bold>g [^] (- int s mod int (order \\<G>)) \\<otimes>\n  \\<^bold>g [^] (int u1' mod int (order \\<G>)) =\n  \\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1'\n\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] (u1' + (order \\<G> - s))) =\n    inv (\\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1')", "by simp"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] (u1' + (order \\<G> - s))) =\n  inv (\\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "hence \"inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod (order \\<G>)) ) = inv (\\<^bold>g [^] (- int s)) \\<otimes> inv (\\<^bold>g [^] (int u1'))\""], ["proof (prove)\nusing this:\n  inv (\\<^bold>g [^] (u1' + (order \\<G> - s))) =\n  inv (\\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n    inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1')", "using pow_generator_mod"], ["proof (prove)\nusing this:\n  inv (\\<^bold>g [^] (u1' + (order \\<G> - s))) =\n  inv (\\<^bold>g [^] - int s \\<otimes> \\<^bold>g [^] int u1')\n  \\<^bold>g [^] (?k mod order \\<G>) = \\<^bold>g [^] ?k\n\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n    inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1')", "by (simp add: inverse_split)"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n  inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n  inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"... = \\<^bold>g [^] (int s) \\<otimes> inv (\\<^bold>g [^] (int u1'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1') =\n    \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1')", "by (simp add: int_pow_neg)"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1') =\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "also"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] - int s) \\<otimes> inv (\\<^bold>g [^] int u1') =\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "have \"... = \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1') =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "by (simp add: int_pow_int)"], ["proof (state)\nthis:\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1') =\n  \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "ultimately"], ["proof (chain)\npicking this:\n  inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1')\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1') =\n  \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "show ?thesis"], ["proof (prove)\nusing this:\n  inv (\\<^bold>g [^] ((u1' + (order \\<G> - s)) mod order \\<G>)) =\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1')\n  \\<^bold>g [^] int s \\<otimes> inv (\\<^bold>g [^] int u1') =\n  \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\n\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n    \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')", "by (simp add: inverse_pow_pow pow_generator_mod )"], ["proof (state)\nthis:\n  inv \\<^bold>g [^] (u1' + (order \\<G> - s)) =\n  \\<^bold>g [^] s \\<otimes> inv (\\<^bold>g [^] u1')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_inv_g_s_rewrite:\n  assumes \"s < order \\<G>\" \n  shows \"\\<^bold>g [^] ((r::nat) * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] (u1 + (order \\<G> - s)) = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> \\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "have in_carrier1: \"inv \\<^bold>g [^] (u1 + (order \\<G> - s)) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] (u1 + (order \\<G> - s)) \\<in> carrier \\<G>", "by blast"], ["proof (state)\nthis:\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "have in_carrier2: \"inv \\<^bold>g [^] u1 \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<^bold>g [^] u1 \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  inv \\<^bold>g [^] u1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "have in_carrier_3: \"\\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "have \"\\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> (inv \\<^bold>g [^] (u1 + (order \\<G> - s))) =  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)", "using P2_inv_g_rewrite assms"], ["proof (prove)\nusing this:\n  ?s < order \\<G> \\<Longrightarrow>\n  inv \\<^bold>g [^] (?u1' + (order \\<G> - ?s)) =\n  \\<^bold>g [^] ?s \\<otimes> inv (\\<^bold>g [^] ?u1')\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)", "by (simp add: inverse_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "using cyclic_group_assoc in_carrier1 in_carrier2"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  (\\<^bold>g [^] s \\<otimes> inv \\<^bold>g [^] u1)\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) \\<in> carrier \\<G>\n  inv \\<^bold>g [^] u1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] (u1 + (order \\<G> - s)) =\n  \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] s \\<otimes>\n  inv \\<^bold>g [^] u1\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_e0_rewrite: \n  assumes \"s < order \\<G> \"\n  shows \"(\\<^bold>g [^] (r * x + xa), \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] x)  = \n            (\\<^bold>g [^] (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>),\n               \\<^bold>g [^] (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  \\<otimes> \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "have \"\\<^bold>g [^] (r * x + xa) = \\<^bold>g [^] (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * x + xa) =\n    \\<^bold>g [^]\n    (r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * x + xa) =\n    \\<^bold>g [^]\n    (r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G>)", "have \"[(r * x + xa) = (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "have \"[(r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>) \n              = (r * ((order \\<G> - s + x)) + (r * s + xa))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order \\<G> = r * (order \\<G> - s + x) + (r * s + xa)] (mod order \\<G>)", "by (metis (no_types, lifting) mod_mod_trivial cong_add cong_def mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * (order \\<G> - s + x) + (r * s + xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>) \n              = r * (order \\<G> - s) + r * x + r * s + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * (order \\<G> - s + x) + (r * s + xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * (order \\<G> - s) + r * x + r * s + xa] (mod order \\<G>)", "by (simp add: add.assoc distrib_left)"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * (order \\<G> - s) + r * x + r * s + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>) \n              = r * x + r * s + r * (order \\<G> - s) + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * (order \\<G> - s) + r * x + r * s + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * (order \\<G> - s) + xa] (mod order \\<G>)", "by (metis add.assoc add.commute)"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * x + r * s + r * (order \\<G> - s) + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>) \n              = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order \\<G> = r * x + r * s + r * (order \\<G> - s) + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * (order \\<G> - s) +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)", "have \"[(xa + r * s) mod order \\<G> + r * ((x + (order \\<G> - s)) mod order \\<G>) = xa + r * (s + x + (order \\<G> - s))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(xa + r * s) mod order \\<G> +\n     r *\n     ((x + (order \\<G> - s)) mod\n      order \\<G>) = xa + r * (s + x + (order \\<G> - s))] (mod order \\<G>)", "by (metis (no_types) \\<open>[r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> = r * x + r * s + r * (order \\<G> - s) + xa] (mod order \\<G>)\\<close> add.commute distrib_left)"], ["proof (state)\nthis:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + r * (s + x + (order \\<G> - s))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * (order \\<G> - s) +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + r * (s + x + (order \\<G> - s))] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + r * (s + x + (order \\<G> - s))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)", "by (simp add: assms add.commute distrib_left order.strict_implies_order)"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order\n    \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order\n    \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "hence \"[(r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>) \n              = r * x + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod\n   order\n    \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)", "have \"[(xa + r * s) mod order \\<G> + r * ((x + (order \\<G> - s)) mod order \\<G>) = xa + (r * x + r * order \\<G>)] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(xa + r * s) mod order \\<G> +\n     r *\n     ((x + (order \\<G> - s)) mod\n      order \\<G>) = xa + (r * x + r * order \\<G>)] (mod order \\<G>)", "by (metis (no_types) \\<open>[r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> = r * x + r * s + r * order \\<G> - r * s + xa] (mod order \\<G>)\\<close> add.commute add.left_commute add_diff_cancel_left')"], ["proof (state)\nthis:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + (r * x + r * order \\<G>)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod\n     order\n      \\<G> = r * x + r * s + r * order \\<G> - r * s +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + (r * x + r * order \\<G>)] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [(xa + r * s) mod order \\<G> +\n   r *\n   ((x + (order \\<G> - s)) mod\n    order \\<G>) = xa + (r * x + r * order \\<G>)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)", "by (metis (no_types) add.commute cong_add_lcancel_nat cong_def distrib_left mod_add_self2 mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "using cong_def"], ["proof (prove)\nusing this:\n  [r * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [r * x +\n     xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n          (r * s + xa) mod order \\<G>] (mod order \\<G>)", "by metis"], ["proof (state)\nthis:\n  [r * x +\n   xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n        (r * s + xa) mod order \\<G>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * x +\n   xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n        (r * s + xa) mod order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * x + xa) =\n    \\<^bold>g [^]\n    (r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [r * x +\n   xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n        (r * s + xa) mod order \\<G>] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r * x +\n   xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n        (r * s + xa) mod order \\<G>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * x + xa) =\n    \\<^bold>g [^]\n    (r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G>)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r * x +\n   xa = r * ((order \\<G> - s + x) mod order \\<G>) +\n        (r * s + xa) mod order \\<G>] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * x + xa) =\n    \\<^bold>g [^]\n    (r * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * x + xa) =\n  \\<^bold>g [^]\n  (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * x + xa) =\n  \\<^bold>g [^]\n  (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * x + xa) =\n  \\<^bold>g [^]\n  (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "have \"\\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] x = \n              \\<^bold>g [^] (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  \\<otimes> \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "have \"\\<^bold>g [^] (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                = \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "have \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "have \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = (r * \\<alpha> * ((order \\<G> - s) + x) + (r * s + xa) * \\<alpha>)] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * (order \\<G> - s + x) +\n                (r * s + xa) * \\<alpha>] (mod order \\<G>)", "by (metis (no_types, lifting) cong_add cong_def mod_mult_left_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (order \\<G> - s + x) +\n              (r * s + xa) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * x + r * s * \\<alpha> + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (order \\<G> - s + x) +\n              (r * s + xa) * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * x +\n                r * s * \\<alpha> +\n                xa * \\<alpha>] (mod order \\<G>)", "by (simp add: add.assoc distrib_left distrib_right)"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * x +\n              r * s * \\<alpha> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s) + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * x +\n              r * s * \\<alpha> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>)", "by (simp add: add.commute add.left_commute)"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * (order \\<G> - s) +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> - r * \\<alpha> * s + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * (order \\<G> - s) +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "have \"\\<forall>n na. \\<not> (n::nat) \\<le> na \\<or> n + (na - n) = na\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na. \\<not> n \\<le> na \\<or> n + (na - n) = na", "by (meson ordered_cancel_comm_monoid_diff_class.add_diff_inverse)"], ["proof (state)\nthis:\n  \\<forall>n na. \\<not> n \\<le> na \\<or> n + (na - n) = na\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  \\<forall>n na. \\<not> n \\<le> na \\<or> n + (na - n) = na", "have \"r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) = r * \\<alpha> * order \\<G>\""], ["proof (prove)\nusing this:\n  \\<forall>n na. \\<not> n \\<le> na \\<or> n + (na - n) = na\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n    r * \\<alpha> * order \\<G>", "by (metis add_mult_distrib2 assms less_or_eq_imp_le)"], ["proof (state)\nthis:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * order \\<G>\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * order \\<G>", "have \"r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> = r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) + (r * \\<alpha> * x + r * s * \\<alpha>)\""], ["proof (prove)\nusing this:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * order \\<G>\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> =\n    r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) +\n    (r * \\<alpha> * x + r * s * \\<alpha>)", "by presburger"], ["proof (state)\nthis:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> =\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) +\n  (r * \\<alpha> * x + r * s * \\<alpha>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> =\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) +\n  (r * \\<alpha> * x + r * s * \\<alpha>)", "have f1: \"r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> - r * \\<alpha> * s = r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) - r * \\<alpha> * s + (r * \\<alpha> * x + r * s * \\<alpha>)\""], ["proof (prove)\nusing this:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> =\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) +\n  (r * \\<alpha> * x + r * s * \\<alpha>)\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n    r * \\<alpha> * s =\n    r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) - r * \\<alpha> * s +\n    (r * \\<alpha> * x + r * s * \\<alpha>)", "by simp"], ["proof (state)\nthis:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) - r * \\<alpha> * s +\n  (r * \\<alpha> * x + r * s * \\<alpha>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "have \"r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) = r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n    r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s", "by presburger"], ["proof (state)\nthis:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s", "have \"r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> - r * \\<alpha> * s = r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)\""], ["proof (prove)\nusing this:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n    r * \\<alpha> * s =\n    r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)", "using f1 diff_add_inverse2"], ["proof (prove)\nusing this:\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) =\n  r * \\<alpha> * (order \\<G> - s) + r * \\<alpha> * s\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * s + r * \\<alpha> * (order \\<G> - s) - r * \\<alpha> * s +\n  (r * \\<alpha> * x + r * s * \\<alpha>)\n  ?m + ?n - ?n = ?m\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n    r * \\<alpha> * s =\n    r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)", "by presburger"], ["proof (state)\nthis:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * (order \\<G> - s) +\n                xa * \\<alpha>] (mod order \\<G>) \\<Longrightarrow>\n    [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)", "show ?thesis"], ["proof (prove)\nusing this:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "using \\<open>[r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s) + xa * \\<alpha>] (mod order \\<G>)\\<close>"], ["proof (prove)\nusing this:\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * order \\<G> -\n  r * \\<alpha> * s =\n  r * \\<alpha> * x + r * s * \\<alpha> + r * \\<alpha> * (order \\<G> - s)\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * (order \\<G> - s) +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "by presburger"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * x + r * \\<alpha> * s + r * \\<alpha> * order \\<G> - r * \\<alpha> * s + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * s +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "using add.commute add.assoc"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * s * \\<alpha> +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n  ?a + ?b = ?b + ?a\n  ?a + ?b + ?c = ?a + (?b + ?c)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * s +\n                r * \\<alpha> * order \\<G> -\n                r * \\<alpha> * s +\n                xa * \\<alpha>] (mod order \\<G>)", "by force"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * s +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[(r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G> * \\<alpha>) \n                  = r * \\<alpha> * x + r * \\<alpha> * order \\<G> + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * s +\n              r * \\<alpha> * order \\<G> -\n              r * \\<alpha> * s +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * order \\<G> +\n                xa * \\<alpha>] (mod order \\<G>)", "by simp"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * order \\<G> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * order \\<G> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "using cong_def semiring_normalization_rules(23)"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + r * \\<alpha> * order \\<G> +\n              xa * \\<alpha>] (mod order \\<G>)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  ?a + ?b + ?c = ?a + ?c + ?b\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "by (simp add: \\<open>\\<And>c b a. [b = c] (mod a) = (b mod a = c mod a)\\<close> \\<open>\\<And>c b a. a + b + c = a + c + b\\<close>)"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "have \"\\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) = \\<^bold>g [^] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) =\n    \\<^bold>g [^] x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) =\n    \\<^bold>g [^] x", "have \"[((order \\<G> - s + x) mod order \\<G> + s) = x] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)", "have \"[((order \\<G> - s + x) mod order \\<G> + s) = (order \\<G> - s + x+ s)] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> +\n     s = order \\<G> - s + x + s] (mod order \\<G>)", "by (simp add: add.commute cong_def mod_add_right_eq)"], ["proof (state)\nthis:\n  [(order \\<G> - s + x) mod order \\<G> +\n   s = order \\<G> - s + x + s] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)", "hence \"[((order \\<G> - s + x) mod order \\<G> + s) = (order \\<G> + x)] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [(order \\<G> - s + x) mod order \\<G> +\n   s = order \\<G> - s + x + s] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> +\n     s = order \\<G> + x] (mod order \\<G>)", "using assms"], ["proof (prove)\nusing this:\n  [(order \\<G> - s + x) mod order \\<G> +\n   s = order \\<G> - s + x + s] (mod order \\<G>)\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> +\n     s = order \\<G> + x] (mod order \\<G>)", "by auto"], ["proof (state)\nthis:\n  [(order \\<G> - s + x) mod order \\<G> +\n   s = order \\<G> + x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(order \\<G> - s + x) mod order \\<G> +\n   s = order \\<G> + x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) =\n    \\<^bold>g [^] x", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) =\n    \\<^bold>g [^] x", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [(order \\<G> - s + x) mod order \\<G> + s = x] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) =\n    \\<^bold>g [^] x", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) = \\<^bold>g [^] x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) = \\<^bold>g [^] x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s) = \\<^bold>g [^] x\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] x =\n    \\<^bold>g [^]\n    (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n     (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "by argo"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] x =\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] x =\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^] (r * x + xa) =\n  \\<^bold>g [^]\n  (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] x =\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * x + xa) =\n  \\<^bold>g [^]\n  (r * ((order \\<G> - s + x) mod order \\<G>) + (r * s + xa) mod order \\<G>)\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] x =\n  \\<^bold>g [^]\n  (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n   (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] x) =\n    (\\<^bold>g [^]\n     (r * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n      (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (r * x + xa),\n   \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n   \\<^bold>g [^] x) =\n  (\\<^bold>g [^]\n   (r * ((order \\<G> - s + x) mod order \\<G>) +\n    (r * s + xa) mod order \\<G>),\n   \\<^bold>g [^]\n   (r * \\<alpha> * ((order \\<G> - s + x) mod order \\<G>) +\n    (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n   \\<^bold>g [^] ((order \\<G> - s + x) mod order \\<G> + s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_case_l_new_1_gt_e0_rewrite:\n  assumes \"s < order \\<G>\"\n  shows \"(\\<^bold>g [^] (r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n            + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>),\n              \\<^bold>g [^] (r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n                  \\<^bold>g [^] (t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> \n                    + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = (\\<^bold>g [^] (r * x + xa), \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "have \"\\<^bold>g [^] ((r::nat) * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>)\n                   + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>)\n                                = \\<^bold>g [^] (r * x + xa)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "proof(cases \"r = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "case True"], ["proof (state)\nthis:\n  r = 0\n\ngoal (2 subgoals):\n 1. r = 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)\n 2. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "then"], ["proof (chain)\npicking this:\n  r = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  r = 0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "by (simp add: pow_generator_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "case False"], ["proof (state)\nthis:\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "have \"[(r::nat) * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>)\n                  + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> = r * x + xa] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "have \"[r * ((order \\<G> * order \\<G> - s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) + x) mod order \\<G>) \n                  + (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod order \\<G>\n                        =  (r * (((order \\<G> * order \\<G> - s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>)) + x)) \n                              + (r * s * nat (fst (bezw t (order \\<G>))) + xa))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>)", "have \"order \\<G> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. order \\<G> \\<noteq> 0", "using order_gt_0"], ["proof (prove)\nusing this:\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. order \\<G> \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  order \\<G> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  order \\<G> \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  order \\<G> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>)", "using  cong_add cong_def mod_mult_right_eq"], ["proof (prove)\nusing this:\n  order \\<G> \\<noteq> 0\n  \\<lbrakk>[?b = ?c] (mod ?a); [?d = ?e] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b + ?d = ?c + ?e] (mod ?a)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  ?a * (?b mod ?c) mod ?c = ?a * ?b mod ?c\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>)", "by (smt mod_mod_trivial)"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n            x) +\n           (r * s * nat (fst (bezw t (order \\<G>))) + xa)] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n            x) +\n           (r * s * nat (fst (bezw t (order \\<G>))) + xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "hence \"[r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                  + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>\n                        =  r * (order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))) + r * x \n                              + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa)] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n            x) +\n           (r * s * nat (fst (bezw t (order \\<G>))) + xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x +\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa)] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x +\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa)] (mod order \\<G>)", "have \"[r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                = r * (order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))) + r * x] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order\n       \\<G>) = r *\n               (order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n               r * x] (mod order \\<G>)", "by (simp add: cong_def distrib_left mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order\n     \\<G>) = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>))) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * (nat (fst (bezw t (order \\<G>))) mod order \\<G>) +\n              x) +\n             (r * s * nat (fst (bezw t (order \\<G>))) +\n              xa)] (mod order \\<G>) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x +\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa)] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order\n     \\<G>) = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order\n     \\<G>) = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x +\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa)] (mod order \\<G>)", "using assms cong_add gr_implies_not0"], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order\n     \\<G>) = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x] (mod order \\<G>)\n  s < order \\<G>\n  \\<lbrakk>[?b = ?c] (mod ?a); [?d = ?e] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b + ?d = ?c + ?e] (mod ?a)\n  ?m < ?n \\<Longrightarrow> ?n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r *\n             (order \\<G> * order \\<G> -\n              s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n             r * x +\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa)] (mod order \\<G>)", "by fastforce"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n           r * x +\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            xa)] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n           r * x +\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "hence \"[r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                    + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>\n                          =  r * order \\<G> * order \\<G> - r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + r * x \n                                + r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order\n    \\<G> = r *\n           (order \\<G> * order \\<G> -\n            s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n           r * x +\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            xa)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r * order \\<G> * order \\<G> -\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             r * x +\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             xa] (mod order \\<G>)", "by (simp add: ab_semigroup_mult_class.mult_ac(1) right_diff_distrib' add.assoc)"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order\n    \\<G> = r * order \\<G> * order \\<G> -\n           r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n           r * x +\n           r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n           xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "hence \"[r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                    + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>\n                          =  r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order\n    \\<G> = r * order \\<G> * order \\<G> -\n           r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n           r * x +\n           r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n           xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r * order \\<G> * order \\<G> -\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             r * x +\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "have \"r * order \\<G> * order \\<G> - r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "have \"order \\<G> * order \\<G> > s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "have \"(nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) \\<le> order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "have \"\\<forall>x0 x1. ((x0::int) mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x0 x1.\n       (x0 mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)", "by linarith"], ["proof (state)\nthis:\n  \\<forall>x0 x1. (x0 mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)\n\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "then"], ["proof (chain)\npicking this:\n  \\<forall>x0 x1. (x0 mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)", "have \"\\<not> int (order \\<G>) + - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<forall>x0 x1. (x0 mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<not> int (order \\<G>) +\n           - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n           \\<le> 0", "using of_nat_0_less_iff order_gt_0"], ["proof (prove)\nusing this:\n  \\<forall>x0 x1. (x0 mod x1 < x1) = (\\<not> x1 + - 1 * (x0 mod x1) \\<le> 0)\n  ((0::?'a) < of_nat ?n) = (0 < ?n)\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<not> int (order \\<G>) +\n           - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n           \\<le> 0", "by fastforce"], ["proof (state)\nthis:\n  \\<not> int (order \\<G>) +\n         - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n         \\<le> 0\n\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "then"], ["proof (chain)\npicking this:\n  \\<not> int (order \\<G>) +\n         - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n         \\<le> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> int (order \\<G>) +\n         - 1 * (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n         \\<le> 0\n\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "by linarith"], ["proof (state)\nthis:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "using assms"], ["proof (prove)\nusing this:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n             \\<le> order \\<G>;\n     s < order \\<G>\\<rbrakk>\n    \\<Longrightarrow> s *\n                      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n                      < order \\<G> * order \\<G>", "have \"\\<forall>n na. \\<not> n \\<le> na \\<or> \\<not> na * order \\<G> < n * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n na.\n       \\<not> n \\<le> na \\<or>\n       \\<not> na * order \\<G>\n              < n * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "by (meson \\<open>nat (fst (bezw (t::nat) (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\\<close> mult_le_mono not_le)"], ["proof (state)\nthis:\n  \\<forall>n na.\n     \\<not> n \\<le> na \\<or>\n     \\<not> na * order \\<G>\n            < n * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n             \\<le> order \\<G>;\n     s < order \\<G>\\<rbrakk>\n    \\<Longrightarrow> s *\n                      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n                      < order \\<G> * order \\<G>", "then"], ["proof (chain)\npicking this:\n  \\<forall>n na.\n     \\<not> n \\<le> na \\<or>\n     \\<not> na * order \\<G>\n            < n * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>n na.\n     \\<not> n \\<le> na \\<or>\n     \\<not> na * order \\<G>\n            < n * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "by(metis  (no_types, hide_lams) \\<open>(s::nat) < order \\<G>\\<close> mult_less_cancel2 nat_less_le not_le not_less_zero)"], ["proof (state)\nthis:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "using False"], ["proof (prove)\nusing this:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "by auto"], ["proof (state)\nthis:\n  0 < r * order \\<G> * order \\<G> -\n      r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < r * order \\<G> * order \\<G> -\n      r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order\n      \\<G> = r * order \\<G> * order \\<G> -\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             r * x +\n             r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n             xa] (mod order \\<G>) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < r * order \\<G> * order \\<G> -\n      r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s *\n        nat (fst (bezw t (order \\<G>)) mod\n             int (order \\<G>)) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "have \"r * order \\<G> * order \\<G> + r * x + xa = r * (order \\<G> * order \\<G> - s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) + (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) + r * x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * order \\<G> * order \\<G> + r * x + xa =\n    r *\n    (order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n    (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) +\n    r * x", "using \\<open>(0::nat) < (r::nat) * order \\<G> * order \\<G> - r * (s::nat) * nat (fst (bezw (t::nat) (order \\<G>)) mod int (order \\<G>))\\<close> diff_mult_distrib2"], ["proof (prove)\nusing this:\n  0 < r * order \\<G> * order \\<G> -\n      r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  ?k * (?m - ?n) = ?k * ?m - ?k * ?n\n\ngoal (1 subgoal):\n 1. r * order \\<G> * order \\<G> + r * x + xa =\n    r *\n    (order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n    (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) +\n    r * x", "by force"], ["proof (state)\nthis:\n  r * order \\<G> * order \\<G> + r * x + xa =\n  r *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) +\n  r * x\n\ngoal (1 subgoal):\n 1. 0 < r * order \\<G> * order \\<G> -\n        r * s *\n        nat (fst (bezw t (order \\<G>)) mod\n             int (order \\<G>)) \\<Longrightarrow>\n    [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * order \\<G> * order \\<G> + r * x + xa =\n  r *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) +\n  r * x", "show ?thesis"], ["proof (prove)\nusing this:\n  r * order \\<G> * order \\<G> + r * x + xa =\n  r *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) +\n  r * x\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)", "by (metis (no_types) \\<open>[(r::nat) * ((order \\<G> * order \\<G> - (s::nat) * nat (fst (bezw (t::nat) (order \\<G>)) mod int (order \\<G>)) + (x::nat)) mod order \\<G>) + (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + (xa::nat)) mod order \\<G> = r * (order \\<G> * order \\<G> - s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) + r * x + (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa)] (mod order \\<G>)\\<close> semiring_normalization_rules(23))"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "hence \"[r * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                    + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G>\n                          = r * x + xa] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * order \\<G> * order \\<G> + r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "by (metis (no_types, lifting) mod_mult_self4 add.assoc mult.commute cong_def)"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> = r * x + xa] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. r \\<noteq> 0 \\<Longrightarrow>\n    \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "then"], ["proof (chain)\npicking this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> = r * x + xa] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G>) =\n    \\<^bold>g [^] (r * x + xa)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "moreover"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "have \"\\<^bold>g [^] (r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) \n                      + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> \n                                  + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))\n                                      =  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "have \"\\<^bold>g [^] (r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>)\n              = \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "have \"[r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>\n                  = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "have \"[r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>\n                  = r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))) + x) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> *\n                (order \\<G> * order \\<G> -\n                 s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 x) +\n                (r * s *\n                 nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 xa) *\n                \\<alpha>] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> *\n                (order \\<G> * order \\<G> -\n                 s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 x) +\n                (r * s *\n                 nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 xa) *\n                \\<alpha>] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> *\n                (order \\<G> * order \\<G> -\n                 s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 x) +\n                (r * s *\n                 nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                 xa) *\n                \\<alpha>] (mod order \\<G>)", "by (meson cong_def mod_add_cong mod_mult_left_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               x) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) *\n              \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               x) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) *\n              \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence mod_eq: \"[r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>\n                  = r * \\<alpha> * (order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))) + r * \\<alpha> * x + r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) * \\<alpha> + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               x) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) *\n              \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> *\n                (order \\<G> * order \\<G> -\n                 s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n                r * \\<alpha> * x +\n                r * s *\n                nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) *\n                \\<alpha> +\n                xa * \\<alpha>] (mod order \\<G>)", "by (simp add: distrib_left distrib_right add.assoc)"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n              r * \\<alpha> * x +\n              r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) *\n              \\<alpha> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence mod_eq': \"[r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>\n                  = r * \\<alpha> * order \\<G> * order \\<G> - r * \\<alpha> * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + r * \\<alpha> * x + r * \\<alpha> * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n              r * \\<alpha> * x +\n              r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) *\n              \\<alpha> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                r * \\<alpha> * s *\n                nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                r * \\<alpha> * x +\n                r * \\<alpha> * s *\n                nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                xa * \\<alpha>] (mod order \\<G>)", "by (simp add: semiring_normalization_rules(16) diff_mult_distrib2 semiring_normalization_rules(18))"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n              r * \\<alpha> * s *\n              nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              r * \\<alpha> * x +\n              r * \\<alpha> * s *\n              nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "hence \"[r * \\<alpha> * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G>) + (r * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + xa) mod order \\<G> * \\<alpha>\n                  = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n              r * \\<alpha> * s *\n              nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              r * \\<alpha> * x +\n              r * \\<alpha> * s *\n              nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "proof(cases \"r * \\<alpha> = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> = 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)\n 2. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "case True"], ["proof (state)\nthis:\n  r * \\<alpha> = 0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> = 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)\n 2. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  r * \\<alpha> = 0\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "by (metis mod_eq' diff_zero mult_0 plus_nat.add_0)"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "case False"], ["proof (state)\nthis:\n  r * \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "hence bound: \" r * \\<alpha> * order \\<G> * order \\<G> - r * \\<alpha> * s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) > 0\""], ["proof (prove)\nusing this:\n  r * \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. r * \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "have \"s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) < order \\<G> * order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "using assms"], ["proof (prove)\nusing this:\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n    < order \\<G> * order \\<G>", "by (simp add: mult_strict_mono nat_less_iff)"], ["proof (state)\nthis:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal (1 subgoal):\n 1. r * \\<alpha> \\<noteq> 0 \\<Longrightarrow>\n    0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "using False"], ["proof (prove)\nusing this:\n  s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  < order \\<G> * order \\<G>\n  r * \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "by auto"], ["proof (state)\nthis:\n  0 < r * \\<alpha> * order \\<G> * order \\<G> -\n      r * \\<alpha> * s *\n      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < r * \\<alpha> * order \\<G> * order \\<G> -\n      r * \\<alpha> * s *\n      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>[r * \\<alpha> *\n              ((order \\<G> * order \\<G> -\n                s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n                x) mod\n               order \\<G>) +\n              (r * s *\n               nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n               xa) mod\n              order \\<G> *\n              \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> -\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         r * \\<alpha> * x +\n                         r * \\<alpha> * s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         xa * \\<alpha>] (mod order \\<G>);\n     r * \\<alpha> \\<noteq> 0\\<rbrakk>\n    \\<Longrightarrow> [r * \\<alpha> *\n                       ((order \\<G> * order \\<G> -\n                         s *\n                         nat (fst (bezw t (order \\<G>)) mod\n                              int (order \\<G>)) +\n                         x) mod\n                        order \\<G>) +\n                       (r * s *\n                        nat (fst (bezw t (order \\<G>)) mod\n                             int (order \\<G>)) +\n                        xa) mod\n                       order \\<G> *\n                       \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> +\n                                  r * \\<alpha> * x +\n                                  xa * \\<alpha>] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < r * \\<alpha> * order \\<G> * order \\<G> -\n      r * \\<alpha> * s *\n      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod\n             int (order \\<G>)) \\<Longrightarrow>\n    [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "have \"r * \\<alpha> * order \\<G> * order \\<G> = r * \\<alpha> * (order \\<G> * order \\<G> - s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) \n                                                      + r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * \\<alpha> * order \\<G> * order \\<G> =\n    r * \\<alpha> *\n    (order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n    r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>", "using bound diff_mult_distrib2"], ["proof (prove)\nusing this:\n  0 < r * \\<alpha> * order \\<G> * order \\<G> -\n      r * \\<alpha> * s *\n      nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  ?k * (?m - ?n) = ?k * ?m - ?k * ?n\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * order \\<G> * order \\<G> =\n    r * \\<alpha> *\n    (order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n    r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>", "by force"], ["proof (state)\nthis:\n  r * \\<alpha> * order \\<G> * order \\<G> =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod\n             int (order \\<G>)) \\<Longrightarrow>\n    [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * order \\<G> * order \\<G> =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>", "have \"r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x = r * \\<alpha> * (order \\<G> * order \\<G> - s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) \n                                                                  + r * \\<alpha> * x + r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\""], ["proof (prove)\nusing this:\n  r * \\<alpha> * order \\<G> * order \\<G> =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\n\ngoal (1 subgoal):\n 1. r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x =\n    r * \\<alpha> *\n    (order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n    r * \\<alpha> * x +\n    r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>", "by presburger"], ["proof (state)\nthis:\n  r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * \\<alpha> * x +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 < r * \\<alpha> * order \\<G> * order \\<G> -\n        r * \\<alpha> * s *\n        nat (fst (bezw t (order \\<G>)) mod\n             int (order \\<G>)) \\<Longrightarrow>\n    [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "then"], ["proof (chain)\npicking this:\n  r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * \\<alpha> * x +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>", "show ?thesis"], ["proof (prove)\nusing this:\n  r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * \\<alpha> * x +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "using mod_eq"], ["proof (prove)\nusing this:\n  r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x =\n  r * \\<alpha> *\n  (order \\<G> * order \\<G> -\n   s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n  r * \\<alpha> * x +\n  r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) * \\<alpha>\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> *\n              (order \\<G> * order \\<G> -\n               s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) +\n              r * \\<alpha> * x +\n              r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) *\n              \\<alpha> +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n                xa * \\<alpha>] (mod order \\<G>)", "by presburger"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * order \\<G> * order \\<G> + r * \\<alpha> * x +\n              xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "by (metis (mono_tags, lifting) add.assoc cong_def mod_mult_self3)"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "then"], ["proof (chain)\npicking this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)", "show ?thesis"], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha> = r * \\<alpha> * x + xa * \\<alpha>] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "have \"\\<^bold>g [^] (t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))\n                    = \\<^bold>g [^] (t * x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * x)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * x)", "have \"[t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))) = t * x] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * x] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * x] (mod order \\<G>)", "have \"[t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))\n                    = (t * (order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> -\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)) +\n                            x +\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod order \\<G>)", "using cong_def mod_add_left_eq mod_mult_cong"], ["proof (prove)\nusing this:\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  (?a mod ?c + ?b) mod ?c = (?a + ?b) mod ?c\n  \\<lbrakk>?a mod ?c = ?a' mod ?c; ?b mod ?c = ?b' mod ?c\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b mod ?c = ?a' * ?b' mod ?c\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> -\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)) +\n                            x +\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t *\n                         (order \\<G> * order \\<G> -\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)) +\n                          x +\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * x] (mod order \\<G>)", "hence \"[t * ((order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + x) mod order \\<G> + s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))\n                    = t * (order \\<G> * order \\<G> + x )] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t *\n                         (order \\<G> * order \\<G> -\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)) +\n                          x +\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> + x)] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> -\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)) +\n                            x +\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order\n \\<G>)))] (mod order \\<G>) \\<Longrightarrow>\n    [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> + x)] (mod order \\<G>)", "have \"order \\<G> * order \\<G> - s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "have \"(nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) \\<le> order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "using nat_le_iff order.strict_implies_order order_gt_0"], ["proof (prove)\nusing this:\n  (nat ?x \\<le> ?n) = (?x \\<le> int ?n)\n  ?a < ?b \\<Longrightarrow> ?a \\<le> ?b\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>", "by (simp add: order.strict_implies_order)"], ["proof (state)\nthis:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "thus ?thesis"], ["proof (prove)\nusing this:\n  nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) \\<le> order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))", "by (metis assms diff_mult_distrib le0 linorder_neqE_nat mult_strict_mono not_le zero_less_diff)"], ["proof (state)\nthis:\n  0 < order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> -\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)) +\n                            x +\n                            s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order\n \\<G>)))] (mod order \\<G>) \\<Longrightarrow>\n    [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> + x)] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  0 < order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> + x)] (mod order \\<G>)", "using \\<open>[(t::nat) * ((order \\<G> * order \\<G> - (s::nat) * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + (x::nat)) mod order \\<G> + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) = t * (order \\<G> * order \\<G> - s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + x + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))] (mod order \\<G>)\\<close>"], ["proof (prove)\nusing this:\n  0 < order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t *\n                         (order \\<G> * order \\<G> -\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)) +\n                          x +\n                          s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t *\n                           (order \\<G> * order \\<G> + x)] (mod order \\<G>)", "by auto"], ["proof (state)\nthis:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * (order \\<G> * order \\<G> + x)] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * (order \\<G> * order \\<G> + x)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * x] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * (order \\<G> * order \\<G> + x)] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * x] (mod order \\<G>)", "by (metis (no_types, hide_lams) add.commute cong_def mod_mult_right_eq mod_mult_self1)"], ["proof (state)\nthis:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * x] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * x] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * x)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * x] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * x)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * x)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>)\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * x)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (r * \\<alpha> *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G>) +\n     (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n     order \\<G> *\n     \\<alpha>) \\<otimes>\n    \\<^bold>g [^]\n    (t *\n     ((order \\<G> * order \\<G> -\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       x) mod\n      order \\<G> +\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * x)", "by argo"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) \\<otimes>\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) \\<otimes>\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * x)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "ultimately"], ["proof (chain)\npicking this:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) \\<otimes>\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * x)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (r *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G>) =\n  \\<^bold>g [^] (r * x + xa)\n  \\<^bold>g [^]\n  (r * \\<alpha> *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G>) +\n   (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n   order \\<G> *\n   \\<alpha>) \\<otimes>\n  \\<^bold>g [^]\n  (t *\n   ((order \\<G> * order \\<G> -\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n     x) mod\n    order \\<G> +\n    s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * x)\n\ngoal (1 subgoal):\n 1. (\\<^bold>g [^]\n     (r *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G>),\n     \\<^bold>g [^]\n     (r * \\<alpha> *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G>) +\n      (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n       xa) mod\n      order \\<G> *\n      \\<alpha>) \\<otimes>\n     \\<^bold>g [^]\n     (t *\n      ((order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        x) mod\n       order \\<G> +\n       s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n    (\\<^bold>g [^] (r * x + xa),\n     \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n     \\<^bold>g [^] (t * x))", "by simp"], ["proof (state)\nthis:\n  (\\<^bold>g [^]\n   (r *\n    ((order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n      x) mod\n     order \\<G>) +\n    (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n    order \\<G>),\n   \\<^bold>g [^]\n   (r * \\<alpha> *\n    ((order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n      x) mod\n     order \\<G>) +\n    (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) + xa) mod\n    order \\<G> *\n    \\<alpha>) \\<otimes>\n   \\<^bold>g [^]\n   (t *\n    ((order \\<G> * order \\<G> -\n      s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n      x) mod\n     order \\<G> +\n     s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))))) =\n  (\\<^bold>g [^] (r * x + xa),\n   \\<^bold>g [^] (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n   \\<^bold>g [^] (t * x))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_case_l_neq_1_gt_x0_rewrite:\n  assumes \"t < order \\<G>\" \n    and \"t \\<noteq> 0\"\n  shows \"\\<^bold>g [^] (t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = \\<^bold>g [^] (t * u0) \\<otimes>  \\<^bold>g [^] s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "from assms"], ["proof (chain)\npicking this:\n  t < order \\<G>\n  t \\<noteq> 0", "have gcd: \"gcd t (order \\<G>) = 1\""], ["proof (prove)\nusing this:\n  t < order \\<G>\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd t (order \\<G>) = 1", "using prime_field coprime_imp_gcd_eq_1"], ["proof (prove)\nusing this:\n  t < order \\<G>\n  t \\<noteq> 0\n  \\<lbrakk>?a < order \\<G>; ?a \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> coprime ?a (order \\<G>)\n  coprime ?a ?b \\<Longrightarrow> gcd ?a ?b = (1::?'a)\n\ngoal (1 subgoal):\n 1. gcd t (order \\<G>) = 1", "by blast"], ["proof (state)\nthis:\n  gcd t (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "hence inverse_t: \"[ s * (t * (fst (bezw t (order \\<G>)))) = s * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  gcd t (order \\<G>) = 1\n\ngoal (1 subgoal):\n 1. [int s *\n     (int t *\n      fst (bezw t (order \\<G>))) = int (s * 1)] (mod int (order \\<G>))", "by (metis Num.of_nat_simps(2) Num.of_nat_simps(5) cong_scalar_left order_gt_0 inverse)"], ["proof (state)\nthis:\n  [int s *\n   (int t * fst (bezw t (order \\<G>))) = int (s * 1)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "hence inverse_t': \"[t * u0 + s * (t * (fst (bezw t (order \\<G>)))) =t * u0 + s * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int s *\n   (int t * fst (bezw t (order \\<G>))) = int (s * 1)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (t * u0) +\n     int s *\n     (int t *\n      fst (bezw t\n            (order \\<G>))) = int (t * u0 + s * 1)] (mod int (order \\<G>))", "using cong_add_lcancel"], ["proof (prove)\nusing this:\n  [int s *\n   (int t * fst (bezw t (order \\<G>))) = int (s * 1)] (mod int (order \\<G>))\n  [?a + ?x = ?a + ?y] (mod ?n) = [?x = ?y] (mod ?n)\n\ngoal (1 subgoal):\n 1. [int (t * u0) +\n     int s *\n     (int t *\n      fst (bezw t\n            (order \\<G>))) = int (t * u0 + s * 1)] (mod int (order \\<G>))", "by fastforce"], ["proof (state)\nthis:\n  [int (t * u0) +\n   int s *\n   (int t *\n    fst (bezw t\n          (order \\<G>))) = int (t * u0 + s * 1)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "have eq: \"int (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) = (fst (bezw t (order \\<G>))) mod order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "have \"(fst (bezw t (order \\<G>))) mod order \\<G> \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> fst (bezw t (order \\<G>)) mod int (order \\<G>)", "using order_gt_0"], ["proof (prove)\nusing this:\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. 0 \\<le> fst (bezw t (order \\<G>)) mod int (order \\<G>)", "by simp"], ["proof (state)\nthis:\n  0 \\<le> fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "hence \"(nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) = (fst (bezw t (order \\<G>))) mod order \\<G>\""], ["proof (prove)\nusing this:\n  0 \\<le> fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "by linarith"], ["proof (state)\nthis:\n  int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n  fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n  fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n    fst (bezw t (order \\<G>)) mod int (order \\<G>)", "by blast"], ["proof (state)\nthis:\n  int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n  fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n  fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "have \"[(t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = t * u0 + s] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "have \"[t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))) = t * u0 + t * (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t * u0 +\n                           t *\n                           (s *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod order \\<G>)", "by (simp add: distrib_left)"], ["proof (state)\nthis:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * u0 +\n                         t *\n                         (s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "hence \"[t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))) = t * u0 + s * (t * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * u0 +\n                         t *\n                         (s *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order\n                 \\<G>))) = t * u0 +\n                           s *\n                           (t *\n                            nat (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod order \\<G>)", "by (simp add: ab_semigroup_mult_class.mult_ac(1) mult.left_commute)"], ["proof (state)\nthis:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * u0 +\n                         s *\n                         (t *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "hence \"[t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))) = t * u0 + s * (t * ( ((fst (bezw t (order \\<G>))) mod order \\<G>)))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * u0 +\n                         s *\n                         (t *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [int (t *\n          (u0 +\n           s *\n           nat (fst (bezw t (order \\<G>)) mod\n                int (order\n                      \\<G>)))) = int (t * u0) +\n                                 int s *\n                                 (int t *\n                                  (fst (bezw t (order \\<G>)) mod\n                                   int (order\n   \\<G>)))] (mod int (order \\<G>))", "using eq"], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order\n               \\<G>))) = t * u0 +\n                         s *\n                         (t *\n                          nat (fst (bezw t (order \\<G>)) mod\n                               int (order \\<G>)))] (mod order \\<G>)\n  int (nat (fst (bezw t (order \\<G>)) mod int (order \\<G>))) =\n  fst (bezw t (order \\<G>)) mod int (order \\<G>)\n\ngoal (1 subgoal):\n 1. [int (t *\n          (u0 +\n           s *\n           nat (fst (bezw t (order \\<G>)) mod\n                int (order\n                      \\<G>)))) = int (t * u0) +\n                                 int s *\n                                 (int t *\n                                  (fst (bezw t (order \\<G>)) mod\n                                   int (order\n   \\<G>)))] (mod int (order \\<G>))", "by (simp add: distrib_left mult.commute semiring_normalization_rules(18))"], ["proof (state)\nthis:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "hence \"[t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))) = t * u0 + s * (t * (fst (bezw t (order \\<G>))))] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                (fst (bezw t (order \\<G>)) mod\n                                 int (order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [int (t *\n          (u0 +\n           s *\n           nat (fst (bezw t (order \\<G>)) mod\n                int (order\n                      \\<G>)))) = int (t * u0) +\n                                 int s *\n                                 (int t *\n                                  fst (bezw t\n  (order \\<G>)))] (mod int (order \\<G>))", "by (metis (no_types, hide_lams) cong_def mod_add_right_eq mod_mult_right_eq)"], ["proof (state)\nthis:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                fst (bezw t\n(order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "hence \"[t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))) = t * u0 + s * 1] (mod order \\<G>)\""], ["proof (prove)\nusing this:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                fst (bezw t\n(order \\<G>)))] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s * 1] (mod order \\<G>)", "using inverse_t'"], ["proof (prove)\nusing this:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                fst (bezw t\n(order \\<G>)))] (mod int (order \\<G>))\n  [int (t * u0) +\n   int s *\n   (int t *\n    fst (bezw t\n          (order \\<G>))) = int (t * u0 + s * 1)] (mod int (order \\<G>))\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s * 1] (mod order \\<G>)", "using cong_trans cong_int_iff"], ["proof (prove)\nusing this:\n  [int (t *\n        (u0 +\n         s *\n         nat (fst (bezw t (order \\<G>)) mod\n              int (order\n                    \\<G>)))) = int (t * u0) +\n                               int s *\n                               (int t *\n                                fst (bezw t\n(order \\<G>)))] (mod int (order \\<G>))\n  [int (t * u0) +\n   int s *\n   (int t *\n    fst (bezw t\n          (order \\<G>))) = int (t * u0 + s * 1)] (mod int (order \\<G>))\n  \\<lbrakk>[?b = ?c] (mod ?a); [?c = ?d] (mod ?a)\\<rbrakk>\n  \\<Longrightarrow> [?b = ?d] (mod ?a)\n  [int ?m = int ?q] (mod int ?n) = [?m = ?q] (mod ?n)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s * 1] (mod order \\<G>)", "by blast"], ["proof (state)\nthis:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s * 1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s * 1] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. [t *\n     (u0 +\n      s *\n      nat (fst (bezw t (order \\<G>)) mod\n           int (order \\<G>))) = t * u0 + s] (mod order \\<G>)", "by simp"], ["proof (state)\nthis:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s] (mod order \\<G>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "hence \"\\<^bold>g [^] (t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>))))) = \\<^bold>g [^] (t * u0 + s)\""], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0 + s)", "using finite_group pow_generator_eq_iff_cong"], ["proof (prove)\nusing this:\n  [t *\n   (u0 +\n    s *\n    nat (fst (bezw t (order \\<G>)) mod\n         int (order \\<G>))) = t * u0 + s] (mod order \\<G>)\n  finite (carrier \\<G>)\n  finite (carrier \\<G>) \\<Longrightarrow>\n  (\\<^bold>g [^] ?x = \\<^bold>g [^] ?y) = [?x = ?y] (mod order \\<G>)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0 + s)", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * u0 + s)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<^bold>g [^]\n  (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * u0 + s)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^]\n    (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n    \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s", "by (simp add: nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^]\n  (t * (u0 + s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)))) =\n  \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open> Now we show the two end definitions are equal when the input for l (in the ideal model, the second input) is the one constructed by the simulator \\<close>"], ["", "lemma P2_ideal_real_end_eq:\n  assumes b0_inv_b1: \"b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\"\n    and assert_in_carrier: \"h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\"\n    and x1_in_carrier: \"x1 \\<in> carrier \\<G>\" \n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"\n  shows \"P2_ideal_model_end (x0,x1) (b0 \\<otimes> (inv (h0 [^] r))) ((h0,h1, \\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3 = P2_real_model_end (x0,x1) ((h0,h1, \\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "including monad_normalisation"], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "proof(cases \"(b0 \\<otimes> (inv (h0 [^] r))) = \\<one>\") \\<comment> \\<open> The case distinctions follow the 3 cases give on p 193/194*) \\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "case True"], ["proof (state)\nthis:\n  b0 \\<otimes> inv (h0 [^] r) = \\<one>\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have b1_h1: \"b1 = h1 [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "from b0_inv_b1 assert_in_carrier"], ["proof (chain)\npicking this:\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>", "have \"b0 \\<otimes> inv b1 = h0 [^] r \\<otimes> inv h1 [^] r\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv b1 = h0 [^] r \\<otimes> inv h1 [^] r", "by (simp add: pow_mult_distrib cyclic_group_commute monoid_comm_monoidI)"], ["proof (state)\nthis:\n  b0 \\<otimes> inv b1 = h0 [^] r \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "hence \"b0 \\<otimes> inv h0 [^] r = b1 \\<otimes> inv h1 [^] r\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv b1 = h0 [^] r \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv h0 [^] r = b1 \\<otimes> inv h1 [^] r", "by (metis Units_eq Units_l_cancel local.inv_equality True assert_in_carrier \n              cyclic_group.inverse_pow_pow cyclic_group_axioms \n                  inv_closed nat_pow_closed r_inv)"], ["proof (state)\nthis:\n  b0 \\<otimes> inv h0 [^] r = b1 \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "with True"], ["proof (chain)\npicking this:\n  b0 \\<otimes> inv (h0 [^] r) = \\<one>\n  b0 \\<otimes> inv h0 [^] r = b1 \\<otimes> inv h1 [^] r", "have \"\\<one> = b1 \\<otimes> inv h1 [^] r\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) = \\<one>\n  b0 \\<otimes> inv h0 [^] r = b1 \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. \\<one> = b1 \\<otimes> inv h1 [^] r", "by (simp add: assert_in_carrier inverse_pow_pow)"], ["proof (state)\nthis:\n  \\<one> = b1 \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "hence \"\\<one> \\<otimes> h1 [^] r = b1\""], ["proof (prove)\nusing this:\n  \\<one> = b1 \\<otimes> inv h1 [^] r\n\ngoal (1 subgoal):\n 1. \\<one> \\<otimes> h1 [^] r = b1", "by (metis assert_in_carrier cyclic_group.inverse_pow_pow cyclic_group_axioms inv_closed inv_inv l_one local.inv_equality nat_pow_closed)"], ["proof (state)\nthis:\n  \\<one> \\<otimes> h1 [^] r = b1\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<one> \\<otimes> h1 [^] r = b1\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "using assert_in_carrier l_one"], ["proof (prove)\nusing this:\n  \\<one> \\<otimes> h1 [^] r = b1\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  ?x \\<in> carrier \\<G> \\<Longrightarrow> \\<one> \\<otimes> ?x = ?x\n\ngoal (1 subgoal):\n 1. b1 = h1 [^] r", "by blast"], ["proof (state)\nthis:\n  b1 = h1 [^] r\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b1 = h1 [^] r\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "obtain \\<alpha> :: nat where \\<alpha>: \"\\<^bold>g [^] \\<alpha> = h1\" and \"\\<alpha> < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<lbrakk>\\<^bold>g [^] \\<alpha> = h1; \\<alpha> < order \\<G>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis mod_less_divisor assert_in_carrier generatorE order_gt_0 pow_generator_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^] \\<alpha> = h1\n  \\<alpha> < order \\<G>\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "obtain s :: nat where s: \"\\<^bold>g [^] s = x1\" and s_lt: \"s < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<^bold>g [^] s = x1; s < order \\<G>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis assms(3) mod_less_divisor generatorE order_gt_0 pow_generator_mod)"], ["proof (state)\nthis:\n  \\<^bold>g [^] s = x1\n  s < order \\<G>\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"b1 \\<otimes> inv \\<^bold>g = \\<^bold>g [^] (r * \\<alpha>) \\<otimes> inv \\<^bold>g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b1 \\<otimes> inv \\<^bold>g =\n    \\<^bold>g [^] (r * \\<alpha>) \\<otimes> inv \\<^bold>g", "by (metis \\<alpha> b1_h1 generator_closed mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  b1 \\<otimes> inv \\<^bold>g =\n  \\<^bold>g [^] (r * \\<alpha>) \\<otimes> inv \\<^bold>g\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have a_g_exp_rewrite: \"(\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0 =  \\<^bold>g [^] (r * u0 + v0)\" \n    for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0 =\n    \\<^bold>g [^] (r * u0 + v0)", "by (simp add: nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] r) [^] ?u0.23 \\<otimes> \\<^bold>g [^] ?v0.23 =\n  \\<^bold>g [^] (r * ?u0.23 + ?v0.23)\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z1_rewrite: \"(b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> \\<one> = \\<^bold>g [^] (r * \\<alpha> * u1 +  v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1\" \n    for u1 v1 :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes>\n    \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    inv \\<^bold>g [^] u1", "by (smt \\<alpha> b1_h1 pow_mult_distrib cyclic_group_commute generator_closed inv_closed m_assoc m_closed monoid_comm_monoidI mult.commute nat_pow_closed nat_pow_mult nat_pow_pow r_one)"], ["proof (state)\nthis:\n  (b1 \\<otimes> inv \\<^bold>g) [^] ?u1.23 \\<otimes> h1 [^] ?v1.23 \\<otimes>\n  \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u1.23 + ?v1.23 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ?u1.23\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z1_rewrite': \"\\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> \\<^bold>g [^] s \\<otimes>  inv \\<^bold>g [^] u1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1\"\n    for u1 v1"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1 =\n    (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1", "using assert_in_carrier cyclic_group_commute m_assoc s z1_rewrite"], ["proof (prove)\nusing this:\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  \\<lbrakk>?x \\<in> carrier \\<G>; ?y \\<in> carrier \\<G>;\n   ?z \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<otimes> ?y \\<otimes> ?z =\n                    ?x \\<otimes> (?y \\<otimes> ?z)\n  \\<^bold>g [^] s = x1\n  (b1 \\<otimes> inv \\<^bold>g) [^] ?u1.23 \\<otimes> h1 [^] ?v1.23 \\<otimes>\n  \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u1.23 + ?v1.23 * \\<alpha>) \\<otimes>\n  inv \\<^bold>g [^] ?u1.23\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] s \\<otimes>\n    inv \\<^bold>g [^] u1 =\n    (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * ?u1.23 + ?v1.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] s \\<otimes>\n  inv \\<^bold>g [^] ?u1.23 =\n  (b1 \\<otimes> inv \\<^bold>g) [^] ?u1.23 \\<otimes> h1 [^] ?v1.23 \\<otimes>\n  x1\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"P2_ideal_model_end (x0,x1) (b0 \\<otimes> (inv (h0 [^] r))) ((h0,h1, \\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3 = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> \\<one>;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             \\<one>;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: P2_ideal_model_end_def True funct_OT_12_def)"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           \\<one>;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           \\<one>;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             \\<one>;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: z1_rewrite)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           \\<one>;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           \\<one>;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = \\<^bold>g [^] (r * u1 + v1);\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] u1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: a_g_exp_rewrite)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> map_spmf (\\<lambda> u1'. (s + u1') mod (order \\<G>)) (sample_uniform (order \\<G>));\n    v1 \\<leftarrow> map_spmf (\\<lambda> v1'. ((r * order \\<G> - r * s) + v1')  mod (order \\<G>)) (sample_uniform (order \\<G>));\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = \\<^bold>g [^] (r * u1 + v1);\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>u1.\n                map_spmf\n                 (\\<lambda>v1'.\n                     (r * order \\<G> - r * s + v1') mod order \\<G>)\n                 (sample_uniform (order \\<G>)) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "apply(simp add: bind_map_spmf o_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     ((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<^bold>g [^] (r * u1 + v1),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                      inv \\<^bold>g [^] u1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xa.\n                    \\<A>3\n                     ((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<^bold>g [^]\n                      (r * ((s + x) mod order \\<G>) +\n                       (r * order \\<G> - r * s + xa) mod order \\<G>),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * ((s + x) mod order \\<G>) +\n                       (r * order \\<G> - r * s + xa) mod order \\<G> *\n                       \\<alpha>) \\<otimes>\n                      inv \\<^bold>g [^]\n                      ((s + x) mod order \\<G> + (order \\<G> - s)))\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "using P2_output_rewrite assms s_lt assms"], ["proof (prove)\nusing this:\n  ?s < order \\<G> \\<Longrightarrow>\n  (\\<^bold>g [^] (?r * ?u1.0 + ?v1.0),\n   \\<^bold>g [^] (?r * ?\\<alpha> * ?u1.0 + ?v1.0 * ?\\<alpha>) \\<otimes>\n   inv \\<^bold>g [^] ?u1.0) =\n  (\\<^bold>g [^]\n   (?r * ((?s + ?u1.0) mod order \\<G>) +\n    (?r * order \\<G> - ?r * ?s + ?v1.0) mod order \\<G>),\n   \\<^bold>g [^]\n   (?r * ?\\<alpha> * ((?s + ?u1.0) mod order \\<G>) +\n    (?r * order \\<G> - ?r * ?s + ?v1.0) mod order \\<G> *\n    ?\\<alpha>) \\<otimes>\n   inv \\<^bold>g [^] ((?s + ?u1.0) mod order \\<G> + (order \\<G> - ?s)))\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  s < order \\<G>\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     ((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<^bold>g [^] (r * u1 + v1),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                      inv \\<^bold>g [^] u1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>x.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xa.\n                    \\<A>3\n                     ((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<^bold>g [^]\n                      (r * ((s + x) mod order \\<G>) +\n                       (r * order \\<G> - r * s + xa) mod order \\<G>),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * ((s + x) mod order \\<G>) +\n                       (r * order \\<G> - r * s + xa) mod order \\<G> *\n                       \\<alpha>) \\<otimes>\n                      inv \\<^bold>g [^]\n                      ((s + x) mod order \\<G> + (order \\<G> - s)))\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "by presburger"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>u1.\n              map_spmf\n               (\\<lambda>v1'. (r * order \\<G> - r * s + v1') mod order \\<G>)\n               (sample_uniform (order \\<G>)) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>u1.\n              map_spmf\n               (\\<lambda>v1'. (r * order \\<G> - r * s + v1') mod order \\<G>)\n               (sample_uniform (order \\<G>)) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = \\<^bold>g [^] (r * u1 + v1);\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n             (sample_uniform (order \\<G>)) \\<bind>\n            (\\<lambda>u1.\n                map_spmf\n                 (\\<lambda>v1'.\n                     (r * order \\<G> - r * s + v1') mod order \\<G>)\n                 (sample_uniform (order \\<G>)) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>u1.\n              map_spmf\n               (\\<lambda>v1'. (r * order \\<G> - r * s + v1') mod order \\<G>)\n               (sample_uniform (order \\<G>)) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          map_spmf (\\<lambda>u1'. (s + u1') mod order \\<G>)\n           (sample_uniform (order \\<G>)) \\<bind>\n          (\\<lambda>u1.\n              map_spmf\n               (\\<lambda>v1'. (r * order \\<G> - r * s + v1') mod order \\<G>)\n               (sample_uniform (order \\<G>)) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = \\<^bold>g [^] (r * u1 + v1);\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = \\<^bold>g [^] (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes> \\<^bold>g [^] s \\<otimes>  inv \\<^bold>g [^] u1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] s \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: P2_inv_g_s_rewrite assms s_lt cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           inv \\<^bold>g [^] (u1 + (order \\<G> - s));\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = \\<^bold>g [^] (r * u1 + v1);\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = \\<^bold>g [^]\n                             (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] s \\<otimes>\n                             inv \\<^bold>g [^] u1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: a_g_exp_rewrite z1_rewrite')"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. b0 \\<otimes> inv (h0 [^] r) = \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "ultimately"], ["proof (chain)\npicking this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = \\<^bold>g [^] (r * u1 + v1);\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = \\<^bold>g [^]\n                           (r * \\<alpha> * u1 + v1 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] s \\<otimes>\n                           inv \\<^bold>g [^] u1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "by(simp add: P2_real_model_end_def)"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "obtain \\<alpha> :: nat where \\<alpha>: \"\\<^bold>g [^] \\<alpha> = h0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<^bold>g [^] \\<alpha> = h0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using generatorE assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<^bold>g [^] \\<alpha> = h0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assert_in_carrier"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> carrier \\<G>;\n   \\<And>n. ?x = \\<^bold>g [^] n \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<^bold>g [^] \\<alpha> = h0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] \\<alpha> = h0\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have w0_rewrite: \"\\<^bold>g [^] (r * u0 + v0) =  (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0\"\n    for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u0 + v0) =\n    (\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0", "by (simp add: nat_pow_mult nat_pow_pow)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * ?u0.23 + ?v0.23) =\n  (\\<^bold>g [^] r) [^] ?u0.23 \\<otimes> \\<^bold>g [^] ?v0.23\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have order_gt_0: \"order \\<G> > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "using order_gt_0"], ["proof (prove)\nusing this:\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. 0 < order \\<G>", "by simp"], ["proof (state)\nthis:\n  0 < order \\<G>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "obtain s :: nat where s: \"\\<^bold>g [^] s = x0\" and s_lt: \"s < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<lbrakk>\\<^bold>g [^] s = x0; s < order \\<G>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis mod_less_divisor generatorE order_gt_0 pow_generator_mod x0_in_carrier)"], ["proof (state)\nthis:\n  \\<^bold>g [^] s = x0\n  s < order \\<G>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "case False \\<comment> \\<open>case 2\\<close>"], ["proof (state)\nthis:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "hence l_neq_1: \"(b0 \\<otimes> (inv (h0 [^] r))) \\<noteq> \\<one>\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>", "by auto"], ["proof (state)\nthis:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one> \\<Longrightarrow>\n    P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "then"], ["proof (chain)\npicking this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "proof(cases \"(b0 \\<otimes> (inv (h0 [^] r))) = \\<^bold>g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "case True"], ["proof (state)\nthis:\n  b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "hence \"b0 = \\<^bold>g \\<otimes> h0 [^] r\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\n\ngoal (1 subgoal):\n 1. b0 = \\<^bold>g \\<otimes> h0 [^] r", "by (metis assert_in_carrier generator_closed inv_solve_right nat_pow_closed)"], ["proof (state)\nthis:\n  b0 = \\<^bold>g \\<otimes> h0 [^] r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "hence \"b0 = \\<^bold>g \\<otimes> \\<^bold>g [^] (r * \\<alpha>)\""], ["proof (prove)\nusing this:\n  b0 = \\<^bold>g \\<otimes> h0 [^] r\n\ngoal (1 subgoal):\n 1. b0 = \\<^bold>g \\<otimes> \\<^bold>g [^] (r * \\<alpha>)", "by (metis \\<alpha> generator_closed mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  b0 = \\<^bold>g \\<otimes> \\<^bold>g [^] (r * \\<alpha>)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite: \"b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] u0\" \n      for u0 v0 :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] u0", "by (smt \\<alpha> \\<open>b0 = \\<^bold>g \\<otimes> \\<^bold>g [^] (r * \\<alpha>)\\<close> pow_mult_distrib cyclic_group_commute generator_closed m_assoc monoid_comm_monoidI mult.commute nat_pow_closed nat_pow_mult nat_pow_pow r_one)"], ["proof (state)\nthis:\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ?u0.23\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite': \"\\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (u0 + s) =  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] u0 \\<otimes> \\<^bold>g [^] s\"\n      for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (u0 + s) =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] u0 \\<otimes>\n    \\<^bold>g [^] s", "by (simp add: add.assoc nat_pow_mult)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (?u0.23 + s) =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ?u0.23 \\<otimes>\n  \\<^bold>g [^] s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite'': \"\\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] u0 \\<otimes> x0 =  b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0\"\n      for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] u0 \\<otimes>\n    x0 =\n    b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0", "using z0_rewrite"], ["proof (prove)\nusing this:\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ?u0.23\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] u0 \\<otimes>\n    x0 =\n    b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0", "using assert_in_carrier"], ["proof (prove)\nusing this:\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ?u0.23\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] u0 \\<otimes>\n    x0 =\n    b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] ?u0.23 \\<otimes>\n  x0 =\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> x0\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"P2_ideal_model_end (x0,x1) (b0 \\<otimes> (inv (h0 [^] r))) ((h0,h1,\\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3 = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "apply(simp add: P2_ideal_model_end_def True funct_OT_12_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g = \\<one> \\<longrightarrow>\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     (\\<one>, b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<one>,\n                      (b1 \\<otimes> \\<one>) [^] u1 \\<otimes>\n                      h1 [^] v1 \\<otimes>\n                      \\<one>)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     (\\<one>,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>)\n                     (\\<one>,\n                      (b1 \\<otimes> \\<one>) [^] u1 \\<otimes>\n                      h1 [^] v1 \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "using order_gt_0 order_gt_1_gen_not_1 True l_neq_1"], ["proof (prove)\nusing this:\n  0 < order \\<G>\n  1 < order \\<G> \\<Longrightarrow> \\<^bold>g \\<noteq> \\<one>\n  b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n\ngoal (1 subgoal):\n 1. \\<^bold>g = \\<one> \\<longrightarrow>\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     (\\<one>, b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0)\n                     (\\<one>,\n                      (b1 \\<otimes> \\<one>) [^] u1 \\<otimes>\n                      h1 [^] v1 \\<otimes>\n                      \\<one>)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    \\<A>3\n                     (\\<one>,\n                      b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>)\n                     (\\<one>,\n                      (b1 \\<otimes> \\<one>) [^] u1 \\<otimes>\n                      h1 [^] v1 \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "by auto"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] u0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] u0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: z0_rewrite w0_rewrite)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one>;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> map_spmf (\\<lambda> u0. ((order \\<G> - s) + u0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    v0 \\<leftarrow> map_spmf (\\<lambda> v0. (r * s + v0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (u0 + s);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] u0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (u0 + s);\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "apply(simp add: bind_map_spmf o_def Let_def cong: bind_spmf_cong_simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>xb.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xc.\n                    \\<A>3\n                     (\\<^bold>g [^] (r * x + xa),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n                      \\<^bold>g [^] x)\n                     ((\\<^bold>g [^] r) [^] xb \\<otimes> \\<^bold>g [^] xc,\n                      (b1 \\<otimes> inv \\<^bold>g) [^] xb \\<otimes>\n                      h1 [^] xc \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>xb.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xc.\n                    \\<A>3\n                     (\\<^bold>g [^]\n                      (r * ((order \\<G> - s + x) mod order \\<G>) +\n                       (r * s + xa) mod order \\<G>),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> *\n                       ((order \\<G> - s + x) mod order \\<G>) +\n                       (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n                      \\<^bold>g [^]\n                      ((order \\<G> - s + x) mod order \\<G> + s))\n                     ((\\<^bold>g [^] r) [^] xb \\<otimes> \\<^bold>g [^] xc,\n                      (b1 \\<otimes> inv \\<^bold>g) [^] xb \\<otimes>\n                      h1 [^] xc \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "using P2_e0_rewrite assms s_lt assms"], ["proof (prove)\nusing this:\n  ?s < order \\<G> \\<Longrightarrow>\n  (\\<^bold>g [^] (?r * ?x + ?xa),\n   \\<^bold>g [^] (?r * ?\\<alpha> * ?x + ?xa * ?\\<alpha>) \\<otimes>\n   \\<^bold>g [^] ?x) =\n  (\\<^bold>g [^]\n   (?r * ((order \\<G> - ?s + ?x) mod order \\<G>) +\n    (?r * ?s + ?xa) mod order \\<G>),\n   \\<^bold>g [^]\n   (?r * ?\\<alpha> * ((order \\<G> - ?s + ?x) mod order \\<G>) +\n    (?r * ?s + ?xa) mod order \\<G> * ?\\<alpha>) \\<otimes>\n   \\<^bold>g [^] ((order \\<G> - ?s + ?x) mod order \\<G> + ?s))\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  s < order \\<G>\n  b0 \\<otimes> inv b1 = (h0 \\<otimes> inv h1) [^] r\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>xb.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xc.\n                    \\<A>3\n                     (\\<^bold>g [^] (r * x + xa),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> * x + xa * \\<alpha>) \\<otimes>\n                      \\<^bold>g [^] x)\n                     ((\\<^bold>g [^] r) [^] xb \\<otimes> \\<^bold>g [^] xc,\n                      (b1 \\<otimes> inv \\<^bold>g) [^] xb \\<otimes>\n                      h1 [^] xc \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>x.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>xa.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>xb.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>xc.\n                    \\<A>3\n                     (\\<^bold>g [^]\n                      (r * ((order \\<G> - s + x) mod order \\<G>) +\n                       (r * s + xa) mod order \\<G>),\n                      \\<^bold>g [^]\n                      (r * \\<alpha> *\n                       ((order \\<G> - s + x) mod order \\<G>) +\n                       (r * s + xa) mod order \\<G> * \\<alpha>) \\<otimes>\n                      \\<^bold>g [^]\n                      ((order \\<G> - s + x) mod order \\<G> + s))\n                     ((\\<^bold>g [^] r) [^] xb \\<otimes> \\<^bold>g [^] xc,\n                      (b1 \\<otimes> inv \\<^bold>g) [^] xb \\<otimes>\n                      h1 [^] xc \\<otimes>\n                      x1)\n                     s' \\<bind>\n                    (\\<lambda>out. return_spmf ((), out))))))", "by presburger"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (u0 + s);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (u0 + s);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> map_spmf (\\<lambda> u0. ((order \\<G> - s) + u0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    v0 \\<leftarrow> map_spmf (\\<lambda> v0. (r * s + v0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] u0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (u0 + s);\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] u0 \\<otimes>\n                             x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: z0_rewrite' s)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (u0 + s);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0 \\<otimes>\n                           x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (u0 + s);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0 \\<otimes>\n                           x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> map_spmf (\\<lambda> u0. ((order \\<G> - s) + u0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    v0 \\<leftarrow> map_spmf (\\<lambda> v0. (r * s + v0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] u0 \\<otimes>\n                             x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: w0_rewrite z0_rewrite'')"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0 \\<otimes>\n                           x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] u0 \\<otimes>\n                           x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"... = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) = \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n 2. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "ultimately"], ["proof (chain)\npicking this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  map_spmf (\\<lambda>u0. (order \\<G> - s + u0) mod order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf (\\<lambda>v0. (r * s + v0) mod order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "by(simp add: P2_real_model_end_def)"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "case False \\<comment> \\<open>case 3\\<close>"], ["proof (state)\nthis:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have b0_l: \"b0 = (b0 \\<otimes> (inv (h0 [^] r))) \\<otimes> h0 [^] r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r", "by (simp add: assert_in_carrier m_assoc)"], ["proof (state)\nthis:\n  b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have b0_g_r:\"b0 = (b0 \\<otimes> (inv (h0 [^] r))) \\<otimes> \\<^bold>g [^] (r * \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> \\<^bold>g [^] (r * \\<alpha>)", "by (metis \\<alpha> b0_l generator_closed mult.commute nat_pow_pow)"], ["proof (state)\nthis:\n  b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> \\<^bold>g [^] (r * \\<alpha>)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "obtain t :: nat where t: \"\\<^bold>g [^] t = (b0 \\<otimes> (inv (h0 [^] r)))\" and t_lt_order_g: \"t < order \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<lbrakk>\\<^bold>g [^] t = b0 \\<otimes> inv (h0 [^] r);\n         t < order \\<G>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (full_types) mod_less_divisor order_gt_0 pow_generator_mod \n                assert_in_carrier cyclic_group.generatorE cyclic_group_axioms \n                      inv_closed m_closed nat_pow_closed)"], ["proof (state)\nthis:\n  \\<^bold>g [^] t = b0 \\<otimes> inv (h0 [^] r)\n  t < order \\<G>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "with l_neq_1"], ["proof (chain)\npicking this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n  \\<^bold>g [^] t = b0 \\<otimes> inv (h0 [^] r)\n  t < order \\<G>", "have t_neq_0: \"t \\<noteq> 0\""], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n  \\<^bold>g [^] t = b0 \\<otimes> inv (h0 [^] r)\n  t < order \\<G>\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0", "using l_neq_1_exp_neq_0"], ["proof (prove)\nusing this:\n  b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>\n  \\<^bold>g [^] t = b0 \\<otimes> inv (h0 [^] r)\n  t < order \\<G>\n  \\<lbrakk>?l \\<in> carrier \\<G>; ?l \\<noteq> \\<one>;\n   ?l = \\<^bold>g [^] ?t\\<rbrakk>\n  \\<Longrightarrow> ?t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. t \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  t \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite: \"b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0\"\n      for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "from b0_l"], ["proof (chain)\npicking this:\n  b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r", "have \"b0 [^] u0 \\<otimes> h0 [^] v0 = ((b0 \\<otimes> (inv (h0 [^] r))) \\<otimes> h0 [^] r) [^] u0 \\<otimes> h0 [^] v0\""], ["proof (prove)\nusing this:\n  b0 = b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 =\n    (b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r) [^] u0 \\<otimes>\n    h0 [^] v0", "by simp"], ["proof (state)\nthis:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  (b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r) [^] u0 \\<otimes>\n  h0 [^] v0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "hence \"b0 [^] u0 \\<otimes> h0 [^] v0 = ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0 \\<otimes> (h0 [^] r) [^] u0 \\<otimes> h0 [^] v0\""], ["proof (prove)\nusing this:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  (b0 \\<otimes> inv (h0 [^] r) \\<otimes> h0 [^] r) [^] u0 \\<otimes>\n  h0 [^] v0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 =\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0 \\<otimes>\n    (h0 [^] r) [^] u0 \\<otimes>\n    h0 [^] v0", "by (simp add: assert_in_carrier pow_mult_distrib cyclic_group_commute monoid_comm_monoidI)"], ["proof (state)\nthis:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0 \\<otimes> (h0 [^] r) [^] u0 \\<otimes>\n  h0 [^] v0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "hence \"b0 [^] u0 \\<otimes> h0 [^] v0 = ((\\<^bold>g [^] \\<alpha>) [^] r) [^] u0 \\<otimes> (\\<^bold>g [^] \\<alpha>) [^] v0 \\<otimes> ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0\""], ["proof (prove)\nusing this:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0 \\<otimes> (h0 [^] r) [^] u0 \\<otimes>\n  h0 [^] v0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 =\n    ((\\<^bold>g [^] \\<alpha>) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>) [^] v0 \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "using cyclic_group_assoc cyclic_group_commute assert_in_carrier \\<alpha>"], ["proof (prove)\nusing this:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0 \\<otimes> (h0 [^] r) [^] u0 \\<otimes>\n  h0 [^] v0\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  \\<^bold>g [^] \\<alpha> = h0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 =\n    ((\\<^bold>g [^] \\<alpha>) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>) [^] v0 \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "by simp"], ["proof (state)\nthis:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  ((\\<^bold>g [^] \\<alpha>) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>) [^] v0 \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "hence \"b0 [^] u0 \\<otimes> h0 [^] v0 =  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>  ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0\""], ["proof (prove)\nusing this:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  ((\\<^bold>g [^] \\<alpha>) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>) [^] v0 \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "by (simp add: monoid.nat_pow_pow mult.commute nat_pow_mult)"], ["proof (state)\nthis:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "thus ?thesis"], ["proof (prove)\nusing this:\n  b0 [^] u0 \\<otimes> h0 [^] v0 =\n  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0\n\ngoal (1 subgoal):\n 1. b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0", "by (simp add: assert_in_carrier)"], ["proof (state)\nthis:\n  b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] u0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] ?u0.23\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite': \"\\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0 =  \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * u0)\"\n      for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    (b0 \\<otimes> inv (h0 [^] r)) [^] u0 =\n    \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * u0)", "by (metis generator_closed nat_pow_pow t)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] ?u0.23 =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * ?u0.23)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have z0_rewrite'': \"\\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s =  b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0\"\n      for u0 v0"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * u0) \\<otimes>\n    \\<^bold>g [^] s =\n    b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0", "using assert_in_carrier s z0_rewrite z0_rewrite'"], ["proof (prove)\nusing this:\n  h0 \\<in> carrier \\<G> \\<and>\n  h1 \\<in> carrier \\<G> \\<and>\n  b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>\n  \\<^bold>g [^] s = x0\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> \\<one> =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] ?u0.23\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  (b0 \\<otimes> inv (h0 [^] r)) [^] ?u0.23 =\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * ?u0.23)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n    \\<^bold>g [^] (t * u0) \\<otimes>\n    \\<^bold>g [^] s =\n    b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0", "by auto"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * \\<alpha> * ?u0.23 + ?v0.23 * \\<alpha>) \\<otimes>\n  \\<^bold>g [^] (t * ?u0.23) \\<otimes>\n  \\<^bold>g [^] s =\n  b0 [^] ?u0.23 \\<otimes> h0 [^] ?v0.23 \\<otimes> x0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"P2_ideal_model_end (x0,x1) (b0 \\<otimes> (inv (h0 [^] r))) ((h0,h1,\\<^bold>g [^] (r::nat),b0,b1),s') \\<A>3 = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> ((b0 \\<otimes> (inv (h0 [^] r)))) [^] u0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: P2_ideal_model_end_def l_neq_1 funct_OT_12_def w0_rewrite z0_rewrite)"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"...  = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * u0);\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (t * u0);\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: z0_rewrite')"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           (b0 \\<otimes> inv (h0 [^] r)) [^] u0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"...  = do {\n    u0 \\<leftarrow> map_spmf (\\<lambda> u0. (order \\<G> * order \\<G> - (s * ((nat (((fst (bezw t (order \\<G>)))) mod (order \\<G>))))) + u0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    v0 \\<leftarrow> map_spmf (\\<lambda> v0. (r * s *  (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)) + v0) mod (order \\<G>)) (sample_uniform (order \\<G>));\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))));\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (t * u0);\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    map_spmf\n     (\\<lambda>u0.\n         (order \\<G> * order \\<G> -\n          s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n          u0) mod\n         order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf\n         (\\<lambda>v0.\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              v0) mod\n             order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^]\n                             (t *\n                              (u0 +\n                               s *\n                               nat (fst (bezw t (order \\<G>)) mod\n                                    int (order \\<G>))));\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: bind_map_spmf o_def Let_def s_lt P2_case_l_new_1_gt_e0_rewrite cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf\n   (\\<lambda>u0.\n       (order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        u0) mod\n       order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf\n       (\\<lambda>v0.\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            v0) mod\n           order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0);\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  map_spmf\n   (\\<lambda>u0.\n       (order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        u0) mod\n       order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf\n       (\\<lambda>v0.\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            v0) mod\n           order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"...  = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * (u0 + (s * (nat ((fst (bezw t (order \\<G>))) mod order \\<G>)))));\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_spmf\n     (\\<lambda>u0.\n         (order \\<G> * order \\<G> -\n          s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n          u0) mod\n         order \\<G>)\n     (sample_uniform (order \\<G>)) \\<bind>\n    (\\<lambda>u0.\n        map_spmf\n         (\\<lambda>v0.\n             (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n              v0) mod\n             order \\<G>)\n         (sample_uniform (order \\<G>)) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^]\n                             (t *\n                              (u0 +\n                               s *\n                               nat (fst (bezw t (order \\<G>)) mod\n                                    int (order \\<G>))));\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^]\n                             (t *\n                              (u0 +\n                               s *\n                               nat (fst (bezw t (order \\<G>)) mod\n                                    int (order \\<G>))));\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: samp_uni_plus_one_time_pad)"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>u0.\n       (order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        u0) mod\n       order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf\n       (\\<lambda>v0.\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            v0) mod\n           order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  map_spmf\n   (\\<lambda>u0.\n       (order \\<G> * order \\<G> -\n        s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n        u0) mod\n       order \\<G>)\n   (sample_uniform (order \\<G>)) \\<bind>\n  (\\<lambda>u0.\n      map_spmf\n       (\\<lambda>v0.\n           (r * s * nat (fst (bezw t (order \\<G>)) mod int (order \\<G>)) +\n            v0) mod\n           order \\<G>)\n       (sample_uniform (order \\<G>)) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"...  = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = \\<^bold>g [^] (r * u0 + v0);\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = \\<^bold>g [^] (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes> \\<^bold>g [^] (t * u0) \\<otimes> \\<^bold>g [^] s;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^]\n                             (t *\n                              (u0 +\n                               s *\n                               nat (fst (bezw t (order \\<G>)) mod\n                                    int (order \\<G>))));\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (t * u0) \\<otimes>\n                             \\<^bold>g [^] s;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: P2_case_l_neq_1_gt_x0_rewrite t_lt_order_g t_neq_0 cyclic_group_assoc)"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "also"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^]\n                           (t *\n                            (u0 +\n                             s *\n                             nat (fst (bezw t (order \\<G>)) mod\n                                  int (order \\<G>))));\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "have \"...  = do {\n    u0 \\<leftarrow> sample_uniform (order \\<G>);\n    v0 \\<leftarrow> sample_uniform (order \\<G>);\n    u1 \\<leftarrow> sample_uniform (order \\<G>);\n    v1 \\<leftarrow> sample_uniform (order \\<G>);\n    let w0 = (\\<^bold>g [^] (r::nat)) [^] u0 \\<otimes> \\<^bold>g [^] v0;\n    let w1 = (\\<^bold>g [^] (r::nat)) [^] u1 \\<otimes> \\<^bold>g [^] v1;\n    let z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n    let z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> h1 [^] v1 \\<otimes> x1;\n    let e0 = (w0,z0);\n    let e1 = (w1,z1);\n    out \\<leftarrow> \\<A>3 e0 e1 s';\n    return_spmf ((), out)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = \\<^bold>g [^] (r * u0 + v0);\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = \\<^bold>g [^]\n                             (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                             \\<^bold>g [^] (t * u0) \\<otimes>\n                             \\<^bold>g [^] s;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out)))))) =\n    sample_uniform (order \\<G>) \\<bind>\n    (\\<lambda>u0.\n        sample_uniform (order \\<G>) \\<bind>\n        (\\<lambda>v0.\n            sample_uniform (order \\<G>) \\<bind>\n            (\\<lambda>u1.\n                sample_uniform (order \\<G>) \\<bind>\n                (\\<lambda>v1.\n                    let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                             \\<^bold>g [^] v0;\n                        w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                             \\<^bold>g [^] v1;\n                        z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                        z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                             h1 [^] v1 \\<otimes>\n                             x1;\n                        e0 = (w0, z0); e1 = (w1, z1)\n                    in \\<A>3 e0 e1 s' \\<bind>\n                       (\\<lambda>out. return_spmf ((), out))))))", "by(simp add: w0_rewrite z0_rewrite'')"], ["proof (state)\nthis:\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<one>;\n     b0 \\<otimes> inv (h0 [^] r) \\<noteq> \\<^bold>g\\<rbrakk>\n    \\<Longrightarrow> P2_ideal_model_end (x0, x1)\n                       (b0 \\<otimes> inv (h0 [^] r))\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n                      P2_real_model_end (x0, x1)\n                       ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "ultimately"], ["proof (chain)\npicking this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = \\<^bold>g [^] (r * u0 + v0);\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = \\<^bold>g [^]\n                           (r * \\<alpha> * u0 + v0 * \\<alpha>) \\<otimes>\n                           \\<^bold>g [^] (t * u0) \\<otimes>\n                           \\<^bold>g [^] s;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out)))))) =\n  sample_uniform (order \\<G>) \\<bind>\n  (\\<lambda>u0.\n      sample_uniform (order \\<G>) \\<bind>\n      (\\<lambda>v0.\n          sample_uniform (order \\<G>) \\<bind>\n          (\\<lambda>u1.\n              sample_uniform (order \\<G>) \\<bind>\n              (\\<lambda>v1.\n                  let w0 = (\\<^bold>g [^] r) [^] u0 \\<otimes>\n                           \\<^bold>g [^] v0;\n                      w1 = (\\<^bold>g [^] r) [^] u1 \\<otimes>\n                           \\<^bold>g [^] v1;\n                      z0 = b0 [^] u0 \\<otimes> h0 [^] v0 \\<otimes> x0;\n                      z1 = (b1 \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes>\n                           h1 [^] v1 \\<otimes>\n                           x1;\n                      e0 = (w0, z0); e1 = (w1, z1)\n                  in \\<A>3 e0 e1 s' \\<bind>\n                     (\\<lambda>out. return_spmf ((), out))))))\n\ngoal (1 subgoal):\n 1. P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n     ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n    P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3", "by(simp add: P2_real_model_end_def)"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P2_ideal_model_end (x0, x1) (b0 \\<otimes> inv (h0 [^] r))\n   ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3 =\n  P2_real_model_end (x0, x1) ((h0, h1, \\<^bold>g [^] r, b0, b1), s') \\<A>3\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_ideal_real_eq: \n  assumes x1_in_carrier: \"x1 \\<in> carrier \\<G>\" \n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"  \n  shows \"P2_real_model (x0,x1) \\<sigma>  z \\<A>  = P2_ideal_model (x0,x1) \\<sigma>  z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_real_model (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model (x0, x1) \\<sigma> z \\<A>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P2_real_model (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model (x0, x1) \\<sigma> z \\<A>", "have \"P2_real_model' (x0, x1) \\<sigma>  z \\<A> = P2_ideal_model' (x0, x1) \\<sigma>  z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "have 1:\"do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    let l = b0 \\<otimes> (inv (h0 [^] r));\n    P2_ideal_model_end (x0,x1) l ((h0,h1,a,b0,b1),s') \\<A>3} = P2_ideal_model' (x0,x1) \\<sigma> z \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               let l = b0 \\<otimes> inv (h0 [^] r)\n                               in P2_ideal_model_end (x0, x1) l\n                                   ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "unfolding P2_ideal_model'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               let l = b0 \\<otimes> inv (h0 [^] r)\n                               in P2_ideal_model_end (x0, x1) l\n                                   ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n    (let (x0, x1) = (x0, x1); (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               let l = b0 \\<otimes> inv (h0 [^] r)\n                               in P2_ideal_model_end (x0, x1) l\n                                   ((h0, h1, a, b0, b1), s') \\<A>3))))))", "by simp"], ["proof (state)\nthis:\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             let l = b0 \\<otimes> inv (h0 [^] r)\n                             in P2_ideal_model_end (x0, x1) l\n                                 ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n  P2_ideal_model' (x0, x1) \\<sigma> z \\<A>\n\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "have \"P2_real_model' (x0, x1) \\<sigma>  z \\<A> = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    P2_real_model_end (x0, x1) ((h0,h1,a,b0,b1),s') \\<A>3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               P2_real_model_end (x0, x1)\n                                ((h0, h1, a, b0, b1), s') \\<A>3))))))", "by(simp add: P2_real_model'_def)"], ["proof (state)\nthis:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3))))))\n\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "also"], ["proof (state)\nthis:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3))))))\n\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "have \"... = do {\n    let (\\<A>1, \\<A>2, \\<A>3) = \\<A>;\n    ((h0,h1,a,b0,b1),s) \\<leftarrow> \\<A>1 \\<sigma> z;\n    _ :: unit \\<leftarrow> assert_spmf (h0 \\<in> carrier \\<G> \\<and> h1 \\<in> carrier \\<G>  \\<and> a \\<in> carrier \\<G> \\<and> b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>);\n    (((in1, in2, in3), r),s') \\<leftarrow> \\<A>2 (h0,h1,a,b0,b1) s; \n    let (h,a,b) = (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1);\n    (out_zk_funct, _) \\<leftarrow> funct_DH_ZK (h,a,b) ((in1, in2, in3), r);  \n    _ :: unit \\<leftarrow> assert_spmf out_zk_funct;\n    let l = b0 \\<otimes> (inv (h0 [^] r));\n    P2_ideal_model_end (x0,x1) l ((h0,h1,a,b0,b1),s') \\<A>3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               P2_real_model_end (x0, x1)\n                                ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n    (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n     in \\<A>1 \\<sigma> z \\<bind>\n        (\\<lambda>((h0, h1, a, b0, b1), s).\n            assert_spmf\n             (h0 \\<in> carrier \\<G> \\<and>\n              h1 \\<in> carrier \\<G> \\<and>\n              a \\<in> carrier \\<G> \\<and>\n              b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n            (\\<lambda>_.\n                \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n                (\\<lambda>(((in1, in2, in3), r), s').\n                    let (h, a, b) =\n                          (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                    in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                       (\\<lambda>(out_zk_funct, uu_).\n                           assert_spmf out_zk_funct \\<bind>\n                           (\\<lambda>_.\n                               let l = b0 \\<otimes> inv (h0 [^] r)\n                               in P2_ideal_model_end (x0, x1) l\n                                   ((h0, h1, a, b0, b1), s') \\<A>3))))))", "by(simp add: P2_ideal_real_end_eq assms cong: bind_spmf_cong_simp)"], ["proof (state)\nthis:\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             let l = b0 \\<otimes> inv (h0 [^] r)\n                             in P2_ideal_model_end (x0, x1) l\n                                 ((h0, h1, a, b0, b1), s') \\<A>3))))))\n\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "ultimately"], ["proof (chain)\npicking this:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3))))))\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             let l = b0 \\<otimes> inv (h0 [^] r)\n                             in P2_ideal_model_end (x0, x1) l\n                                 ((h0, h1, a, b0, b1), s') \\<A>3))))))", "show ?thesis"], ["proof (prove)\nusing this:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3))))))\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             P2_real_model_end (x0, x1)\n                              ((h0, h1, a, b0, b1), s') \\<A>3)))))) =\n  (let (\\<A>1, \\<A>2, \\<A>3) = \\<A>\n   in \\<A>1 \\<sigma> z \\<bind>\n      (\\<lambda>((h0, h1, a, b0, b1), s).\n          assert_spmf\n           (h0 \\<in> carrier \\<G> \\<and>\n            h1 \\<in> carrier \\<G> \\<and>\n            a \\<in> carrier \\<G> \\<and>\n            b0 \\<in> carrier \\<G> \\<and> b1 \\<in> carrier \\<G>) \\<bind>\n          (\\<lambda>_.\n              \\<A>2 (h0, h1, a, b0, b1) s \\<bind>\n              (\\<lambda>(((in1, in2, in3), r), s').\n                  let (h, a, b) =\n                        (h0 \\<otimes> inv h1, a, b0 \\<otimes> inv b1)\n                  in funct_DH_ZK (h, a, b) ((in1, in2, in3), r) \\<bind>\n                     (\\<lambda>(out_zk_funct, uu_).\n                         assert_spmf out_zk_funct \\<bind>\n                         (\\<lambda>_.\n                             let l = b0 \\<otimes> inv (h0 [^] r)\n                             in P2_ideal_model_end (x0, x1) l\n                                 ((h0, h1, a, b0, b1), s') \\<A>3))))))\n\ngoal (1 subgoal):\n 1. P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model' (x0, x1) \\<sigma> z \\<A>", "by(simp add: P2_real_model'_def P2_ideal_model'_def)"], ["proof (state)\nthis:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  P2_ideal_model' (x0, x1) \\<sigma> z \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  P2_ideal_model' (x0, x1) \\<sigma> z \\<A>\n\ngoal (1 subgoal):\n 1. P2_real_model (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model (x0, x1) \\<sigma> z \\<A>", "thus ?thesis"], ["proof (prove)\nusing this:\n  P2_real_model' (x0, x1) \\<sigma> z \\<A> =\n  P2_ideal_model' (x0, x1) \\<sigma> z \\<A>\n\ngoal (1 subgoal):\n 1. P2_real_model (x0, x1) \\<sigma> z \\<A> =\n    P2_ideal_model (x0, x1) \\<sigma> z \\<A>", "by(simp add: P2_ideal_model_rewrite P2_real_model_rewrite)"], ["proof (state)\nthis:\n  P2_real_model (x0, x1) \\<sigma> z \\<A> =\n  P2_ideal_model (x0, x1) \\<sigma> z \\<A>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma malicious_sec_P2:   \n  assumes x1_in_carrier: \"x1 \\<in> carrier \\<G>\"\n    and x0_in_carrier: \"x0 \\<in> carrier \\<G>\"  \n  shows \"mal_def.perfect_sec_P2 (x0,x1) \\<sigma> z (P2_S1, P2_S2) \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.perfect_sec_P2 (x0, x1) \\<sigma> z (P2_S1, P2_S2) \\<A>", "unfolding malicious_base.perfect_sec_P2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.ideal_view_2 (x0, x1) \\<sigma> z (P2_S1, P2_S2) \\<A> =\n    P2_real_model (x0, x1) \\<sigma> z \\<A>", "by (simp add: P2_ideal_real_eq P2_ideal_view_unfold assms)"], ["", "(*correctness*)"], ["", "lemma correct:\n  assumes \"x0 \\<in> carrier \\<G>\" \n    and \"x1 \\<in> carrier \\<G>\"\n  shows \"funct_OT_12 (x0, x1) \\<sigma> = protocol_ot (x0,x1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>", "have \\<sigma>_eq_0_output_correct:\n    \"((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes> (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes> x0 \\<otimes>\n                      inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^] \\<alpha>0) = x0\"\n    (is \"?lhs = ?rhs\")\n    for \\<alpha>0 r u0 v0 :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have mult_com: \"r * u0 * \\<alpha>0 = \\<alpha>0 * r * u0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r * u0 * \\<alpha>0 = \\<alpha>0 * r * u0", "by simp"], ["proof (state)\nthis:\n  r * u0 * \\<alpha>0 = \\<alpha>0 * r * u0\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have in_carrier1: \"((\\<^bold>g [^] (r  * u0 * \\<alpha>0))) \\<otimes> (\\<^bold>g [^] (v0 * \\<alpha>0)) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0)\n    \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0)\n  \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have in_carrier2: \"inv ((\\<^bold>g [^] (r  * u0 * \\<alpha>0))) \\<otimes> (\\<^bold>g [^] (v0 * \\<alpha>0)) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] (r * u0 * \\<alpha>0)) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0)\n    \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0)) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0)\n  \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have \"?lhs = ((\\<^bold>g [^] (\\<alpha>0 * r * u0))) \\<otimes> (\\<^bold>g [^] (\\<alpha>0 * v0)) \\<otimes> x0 \\<otimes>\n                        inv (((\\<^bold>g [^] (r  * u0 * \\<alpha>0)) \\<otimes> \\<^bold>g [^] (v0 * \\<alpha>0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n    \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0))", "by (simp add: nat_pow_pow pow_mult_distrib cyclic_group_commute monoid_comm_monoidI)"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n  \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "also"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n  \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have \"... = (((\\<^bold>g [^] (r  * u0 * \\<alpha>0))) \\<otimes> (\\<^bold>g [^] (v0 * \\<alpha>0))) \\<otimes> x0 \\<otimes>\n                        (inv (((\\<^bold>g [^] (r  * u0 * \\<alpha>0)) \\<otimes> \\<^bold>g [^] (v0 * \\<alpha>0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n    \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0))", "using mult.commute mult.assoc mult_com"], ["proof (prove)\nusing this:\n  ?a * ?b = ?b * ?a\n  ?a * ?b * ?c = ?a * (?b * ?c)\n  r * u0 * \\<alpha>0 = \\<alpha>0 * r * u0\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n    \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0))", "by (metis (no_types) mult.commute)"], ["proof (state)\nthis:\n  \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n  \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (\\<alpha>0 * r * u0) \\<otimes>\n  \\<^bold>g [^] (\\<alpha>0 * v0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have \"... = x0 \\<otimes> (((\\<^bold>g [^] (r  * u0 * \\<alpha>0))) \\<otimes> (\\<^bold>g [^] (v0 * \\<alpha>0))) \\<otimes>\n                        (inv (((\\<^bold>g [^] (r  * u0 * \\<alpha>0)) \\<otimes> \\<^bold>g [^] (v0 * \\<alpha>0))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0))", "using cyclic_group_commute in_carrier1 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0)\n  \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n    \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n    x0 \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0))", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n  x0 \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "have \"... = x0 \\<otimes> ((((\\<^bold>g [^] (r  * u0 * \\<alpha>0))) \\<otimes> (\\<^bold>g [^] (v0 * \\<alpha>0))) \\<otimes>\n                        (inv (((\\<^bold>g [^] (r  * u0 * \\<alpha>0)) \\<otimes> \\<^bold>g [^] (v0 * \\<alpha>0)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n     inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n          \\<^bold>g [^] (v0 * \\<alpha>0)))", "using cyclic_group_assoc in_carrier1 in_carrier2 assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  \\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0)\n  \\<in> carrier \\<G>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0)) \\<otimes>\n  \\<^bold>g [^] (v0 * \\<alpha>0)\n  \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n         \\<^bold>g [^] (v0 * \\<alpha>0)) =\n    x0 \\<otimes>\n    (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n     \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n     inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n          \\<^bold>g [^] (v0 * \\<alpha>0)))", "by auto"], ["proof (state)\nthis:\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n   inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n        \\<^bold>g [^] (v0 * \\<alpha>0)))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n   inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n        \\<^bold>g [^] (v0 * \\<alpha>0)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n   inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n        \\<^bold>g [^] (v0 * \\<alpha>0)))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "using assms"], ["proof (prove)\nusing this:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0))\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n       \\<^bold>g [^] (v0 * \\<alpha>0)) =\n  x0 \\<otimes>\n  (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n   \\<^bold>g [^] (v0 * \\<alpha>0) \\<otimes>\n   inv (\\<^bold>g [^] (r * u0 * \\<alpha>0) \\<otimes>\n        \\<^bold>g [^] (v0 * \\<alpha>0)))\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n    x0 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n         \\<alpha>0) =\n    x0", "by simp"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>0) [^] r) [^] u0 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n       \\<alpha>0) =\n  x0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] ?\\<alpha>0.23) [^] ?r23) [^] ?u0.23 \\<otimes>\n  (\\<^bold>g [^] ?\\<alpha>0.23) [^] ?v0.23 \\<otimes>\n  x0 \\<otimes>\n  inv (((\\<^bold>g [^] ?r23) [^] ?u0.23 \\<otimes> \\<^bold>g [^] ?v0.23) [^]\n       ?\\<alpha>0.23) =\n  x0\n\ngoal (1 subgoal):\n 1. mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>", "have \\<sigma>_eq_1_output_correct: \n    \"((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes> x1 \\<otimes>\n                               inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^] \\<alpha>1) = x1\"\n    (is \"?lhs = ?rhs\")\n    for \\<alpha>1 r u1 v1 :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have com1: \"\\<alpha>1 * r * u1 = r *  u1 * \\<alpha>1\" \"v1 * \\<alpha>1 = \\<alpha>1 * v1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>1 * r * u1 = r * u1 * \\<alpha>1 &&&\n    v1 * \\<alpha>1 = \\<alpha>1 * v1", "by simp+"], ["proof (state)\nthis:\n  \\<alpha>1 * r * u1 = r * u1 * \\<alpha>1\n  v1 * \\<alpha>1 = \\<alpha>1 * v1\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have in_carrier1: \"(\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> (\\<^bold>g [^] (v1 * \\<alpha>1)) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1)\n    \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1)\n  \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have in_carrier2: \"inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> (\\<^bold>g [^] (v1 * \\<alpha>1))) \\<in> carrier \\<G>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))\n    \\<in> carrier \\<G>", "by simp"], ["proof (state)\nthis:\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n  \\<in> carrier \\<G>\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have lhs: \"?lhs = ((\\<^bold>g [^] (\\<alpha>1*r)) \\<otimes> \\<^bold>g \\<otimes> inv \\<^bold>g) [^] u1 \\<otimes> (\\<^bold>g [^] (\\<alpha>1 * v1)) \\<otimes> x1 \\<otimes>\n                                 inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> \\<^bold>g [^] (v1*\\<alpha>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "by (simp add: nat_pow_pow pow_mult_distrib cyclic_group_commute monoid_comm_monoidI)"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "also"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have lhs1: \"... = (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes> (\\<^bold>g [^] (\\<alpha>1 * v1)) \\<otimes> x1 \\<otimes>\n                                 inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> \\<^bold>g [^] (v1*\\<alpha>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n    \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "by (simp add: cyclic_group_assoc)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have lhs2: \"... = (\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> (\\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes> x1 \\<otimes>\n                                 inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> \\<^bold>g [^] (v1 * \\<alpha>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n    \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "by (simp add: nat_pow_pow pow_mult_distrib cyclic_group_commute monoid_comm_monoidI com1)"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "also"], ["proof (state)\nthis:\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have \"... = (((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> (\\<^bold>g [^] (v1 * \\<alpha>1))) \\<otimes> x1) \\<otimes>\n                                 inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> \\<^bold>g [^] (v1 * \\<alpha>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "using in_carrier1 in_carrier2 assms cyclic_group_assoc"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1)\n  \\<in> carrier \\<G>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n  \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "by blast"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "also"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "have \"... = (x1 \\<otimes> ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> (\\<^bold>g [^] (v1 * \\<alpha>1)))) \\<otimes>\n                                 inv ((\\<^bold>g [^] (r *  u1 * \\<alpha>1)) \\<otimes> \\<^bold>g [^] (v1 * \\<alpha>1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    x1 \\<otimes>\n    (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n     \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "using in_carrier1 assms cyclic_group_commute"], ["proof (prove)\nusing this:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1)\n  \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n\ngoal (1 subgoal):\n 1. \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n    \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n    x1 \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1)) =\n    x1 \\<otimes>\n    (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n     \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n    inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n         \\<^bold>g [^] (v1 * \\<alpha>1))", "by simp"], ["proof (state)\nthis:\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  x1 \\<otimes>\n  (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n   \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "ultimately"], ["proof (chain)\npicking this:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^] \\<alpha>1)\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  x1 \\<otimes>\n  (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n   \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))", "show ?thesis"], ["proof (prove)\nusing this:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^] \\<alpha>1)\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  x1 \\<otimes>\n  (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n   \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "using cyclic_group_assoc assms in_carrier1 in_carrier1 assms cyclic_group_commute lhs1 lhs2 lhs"], ["proof (prove)\nusing this:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^] \\<alpha>1)\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  x1 \\<otimes>\n  (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n   \\<^bold>g [^] (v1 * \\<alpha>1)) \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>;\n   ?c \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b \\<otimes> ?c =\n                    ?a \\<otimes> (?b \\<otimes> ?c)\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1)\n  \\<in> carrier \\<G>\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1)\n  \\<in> carrier \\<G>\n  x0 \\<in> carrier \\<G>\n  x1 \\<in> carrier \\<G>\n  \\<lbrakk>?a \\<in> carrier \\<G>; ?b \\<in> carrier \\<G>\\<rbrakk>\n  \\<Longrightarrow> ?a \\<otimes> ?b = ?b \\<otimes> ?a\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n  (\\<^bold>g [^] (\\<alpha>1 * r)) [^] u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1)) =\n  \\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n  \\<^bold>g [^] (v1 * \\<alpha>1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  (\\<^bold>g [^] (\\<alpha>1 * r) \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  \\<^bold>g [^] (\\<alpha>1 * v1) \\<otimes>\n  x1 \\<otimes>\n  inv (\\<^bold>g [^] (r * u1 * \\<alpha>1) \\<otimes>\n       \\<^bold>g [^] (v1 * \\<alpha>1))\n\ngoal (1 subgoal):\n 1. ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n     inv \\<^bold>g) [^]\n    u1 \\<otimes>\n    (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n    x1 \\<otimes>\n    inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n         \\<alpha>1) =\n    x1", "by force"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  u1 \\<otimes>\n  (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n       \\<alpha>1) =\n  x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ((\\<^bold>g [^] ?\\<alpha>1.23) [^] ?r23 \\<otimes> \\<^bold>g \\<otimes>\n   inv \\<^bold>g) [^]\n  ?u1.23 \\<otimes>\n  (\\<^bold>g [^] ?\\<alpha>1.23) [^] ?v1.23 \\<otimes>\n  x1 \\<otimes>\n  inv (((\\<^bold>g [^] ?r23) [^] ?u1.23 \\<otimes> \\<^bold>g [^] ?v1.23) [^]\n       ?\\<alpha>1.23) =\n  x1\n\ngoal (1 subgoal):\n 1. mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>", "unfolding funct_OT_12_def protocol_ot_def Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. return_spmf ((), if \\<sigma> then snd (x0, x1) else fst (x0, x1)) =\n    (case (x0, x1) of\n     (x0, x1) \\<Rightarrow>\n       sample_uniform (order \\<G>) \\<bind>\n       (\\<lambda>r.\n           sample_uniform (order \\<G>) \\<bind>\n           (\\<lambda>\\<alpha>0.\n               sample_uniform (order \\<G>) \\<bind>\n               (\\<lambda>\\<alpha>1.\n                   assert_spmf\n                    (\\<^bold>g [^] r = \\<^bold>g [^] r \\<and>\n                     (\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n                     \\<^bold>g [^] (if \\<sigma> then 1 else 0) \\<otimes>\n                     inv ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n                          \\<^bold>g [^] (if \\<sigma> then 1 else 0)) =\n                     (\\<^bold>g [^] \\<alpha>0 \\<otimes>\n                      inv (\\<^bold>g [^] \\<alpha>1)) [^]\n                     r) \\<bind>\n                   (\\<lambda>_.\n                       sample_uniform (order \\<G>) \\<bind>\n                       (\\<lambda>u0.\n                           sample_uniform (order \\<G>) \\<bind>\n                           (\\<lambda>u1.\n                               sample_uniform (order \\<G>) \\<bind>\n                               (\\<lambda>v0.\n                                   sample_uniform (order \\<G>) \\<bind>\n                                   (\\<lambda>v1.\n return_spmf\n  ((),\n   if \\<sigma>\n   then ((\\<^bold>g [^] \\<alpha>1) [^] r \\<otimes>\n         \\<^bold>g [^] (if \\<sigma> then 1 else 0) \\<otimes>\n         inv \\<^bold>g) [^]\n        u1 \\<otimes>\n        (\\<^bold>g [^] \\<alpha>1) [^] v1 \\<otimes>\n        x1 \\<otimes>\n        inv (((\\<^bold>g [^] r) [^] u1 \\<otimes> \\<^bold>g [^] v1) [^]\n             \\<alpha>1)\n   else ((\\<^bold>g [^] \\<alpha>0) [^] r \\<otimes>\n         \\<^bold>g [^] (if \\<sigma> then 1 else 0)) [^]\n        u0 \\<otimes>\n        (\\<^bold>g [^] \\<alpha>0) [^] v0 \\<otimes>\n        x0 \\<otimes>\n        inv (((\\<^bold>g [^] r) [^] u0 \\<otimes> \\<^bold>g [^] v0) [^]\n             \\<alpha>0)))))))))))", "by(cases \\<sigma>; auto simp add: assms \\<sigma>_eq_1_output_correct \\<sigma>_eq_0_output_correct bind_spmf_const\n        lossless_sample_uniform_units order_gt_0 P1_assert_correct1 P1_assert_correct2 lossless_weight_spmfD)"], ["proof (state)\nthis:\n  mal_def.trusted_party (x0, x1) \\<sigma> = protocol_ot (x0, x1) \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma correctness:\n  assumes \"x0 \\<in> carrier \\<G>\" \n    and \"x1 \\<in> carrier \\<G>\"\n  shows \"mal_def.correct (x0,x1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.correct (x0, x1) \\<sigma>", "unfolding mal_def.correct_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. protocol_ot (x0, x1) \\<sigma> = mal_def.trusted_party (x0, x1) \\<sigma>", "by(simp add: correct assms)"], ["", "end"], ["", "locale OT_asymp = \n  fixes \\<G> :: \"nat \\<Rightarrow> 'grp cyclic_group\"\n  assumes ot: \"\\<And>\\<eta>. ot (\\<G> \\<eta>)\"\nbegin"], ["", "sublocale ot \"\\<G> n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. ot (\\<G> n)", "using ot"], ["proof (prove)\nusing this:\n  ot (\\<G> ?\\<eta>)\n\ngoal (1 subgoal):\n 1. ot (\\<G> n)", "by simp"], ["", "lemma correctness_asym:\n  assumes \"x0 \\<in> carrier (\\<G> n)\" \n    and \"x1 \\<in> carrier (\\<G> n)\" \n  shows \"mal_def.correct n (x0,x1) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.correct n (x0, x1) \\<sigma>", "using assms correctness"], ["proof (prove)\nusing this:\n  x0 \\<in> carrier (\\<G> n)\n  x1 \\<in> carrier (\\<G> n)\n  \\<lbrakk>?x0.0 \\<in> carrier (\\<G> ?n);\n   ?x1.0 \\<in> carrier (\\<G> ?n)\\<rbrakk>\n  \\<Longrightarrow> mal_def.correct ?n (?x0.0, ?x1.0) ?\\<sigma>\n\ngoal (1 subgoal):\n 1. mal_def.correct n (x0, x1) \\<sigma>", "by simp"], ["", "lemma P1_security_asym:\n  \"negligible (\\<lambda> n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\" \n  if neg1: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\"\n    and neg2: \"negligible (\\<lambda> n. ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\" \n    and neg3: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\"\n    and neg4: \"negligible (\\<lambda> n. ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "have neg_add1: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) \n        + ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\" \n    and neg_add2: \"negligible (\\<lambda> n. ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)\n        + ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) +\n         local.ddh.advantage n\n          (local.ddh.DDH_\\<A>' n\n            (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))) &&&\n    Negligible.negligible\n     (\\<lambda>n.\n         local.ddh.advantage n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n         local.ddh.advantage n\n          (local.ddh.DDH_\\<A>' n\n            (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))", "using neg1 neg2 neg3 neg4 negligible_plus"], ["proof (prove)\nusing this:\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n  \\<lbrakk>Negligible.negligible ?f; Negligible.negligible ?g\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible\n                     (\\<lambda>\\<eta>. ?f \\<eta> + ?g \\<eta>)\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n.\n         local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) +\n         local.ddh.advantage n\n          (local.ddh.DDH_\\<A>' n\n            (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))) &&&\n    Negligible.negligible\n     (\\<lambda>n.\n         local.ddh.advantage n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n         local.ddh.advantage n\n          (local.ddh.DDH_\\<A>' n\n            (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))", "by(blast)+"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) +\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "proof(cases \\<sigma>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "case True"], ["proof (state)\nthis:\n  \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "have bound_mod: \"\\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar> \n            \\<le> ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) \n              + ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))", "by (metis (no_types) True abs_idempotent P1_adv_real_ideal_model_def P1_advantages_eq P1_real_ideal_DDH_advantage_true_bound)"], ["proof (state)\nthis:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D))\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n 2. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "then"], ["proof (chain)\npicking this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "using P1_real_ideal_DDH_advantage_true_bound that bound_mod that negligible_le neg_add1"], ["proof (prove)\nusing this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D))\n  ?\\<sigma> = True \\<Longrightarrow>\n  mal_def.adv_P1 ?n ?M ?\\<sigma> ?z (P1_S1 ?n, P1_S2) ?\\<A> ?D\n  \\<le> local.ddh.advantage ?n\n         (P1_DDH_mal_adv_\\<sigma>_true ?n ?M ?z ?\\<A> ?D) +\n        local.ddh.advantage ?n\n         (local.ddh.DDH_\\<A>' ?n\n           (P1_DDH_mal_adv_\\<sigma>_true ?n ?M ?z ?\\<A> ?D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_true ?n1 M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D) +\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "by presburger"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "have bound_mod: \"\\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar> \n            \\<le> ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) \n              + ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "have \"\\<bar>spmf (P1_real_model n M \\<sigma> z \\<A> \\<bind> D) True - spmf (P1_ideal_model n M \\<sigma> z \\<A> \\<bind> D) True\\<bar> \n                    \\<le> local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)    \n                            + local.ddh.advantage n (ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>spmf (P1_real_model n M \\<sigma> z \\<A> \\<bind> D) True -\n          spmf (P1_ideal_model n M \\<sigma> z \\<A> \\<bind> D) True\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "by (metis (no_types) False P1_adv_real_ideal_model_def P1_advantages_eq P1_real_ideal_DDH_advantage_false_bound)"], ["proof (state)\nthis:\n  \\<bar>spmf (P1_real_model n M \\<sigma> z \\<A> \\<bind> D) True -\n        spmf (P1_ideal_model n M \\<sigma> z \\<A> \\<bind> D) True\\<bar>\n  \\<le> local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n        local.ddh.advantage n\n         (local.ddh.DDH_\\<A>' n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n\ngoal (1 subgoal):\n 1. \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "then"], ["proof (chain)\npicking this:\n  \\<bar>spmf (P1_real_model n M \\<sigma> z \\<A> \\<bind> D) True -\n        spmf (P1_ideal_model n M \\<sigma> z \\<A> \\<bind> D) True\\<bar>\n  \\<le> local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n        local.ddh.advantage n\n         (local.ddh.DDH_\\<A>' n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>spmf (P1_real_model n M \\<sigma> z \\<A> \\<bind> D) True -\n        spmf (P1_ideal_model n M \\<sigma> z \\<A> \\<bind> D) True\\<bar>\n  \\<le> local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n        local.ddh.advantage n\n         (local.ddh.DDH_\\<A>' n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n\ngoal (1 subgoal):\n 1. \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n    \\<le> local.ddh.advantage n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n          local.ddh.advantage n\n           (local.ddh.DDH_\\<A>' n\n             (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))", "by (simp add: P1_adv_real_ideal_model_def P1_advantages_eq)"], ["proof (state)\nthis:\n  \\<bar>mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n        local.ddh.advantage n\n         (local.ddh.DDH_\\<A>' n\n           (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D))\n\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<Longrightarrow>\n    Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "then"], ["proof (chain)\npicking this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "using P1_real_ideal_DDH_advantage_false_bound  bound_mod that negligible_le neg_add2"], ["proof (prove)\nusing this:\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D))\n  ?\\<sigma> = False \\<Longrightarrow>\n  mal_def.adv_P1 ?n ?M ?\\<sigma> ?z (P1_S1 ?n, P1_S2) ?\\<A> ?D\n  \\<le> local.ddh.advantage ?n\n         (P1_DDH_mal_adv_\\<sigma>_false ?n ?M ?z ?\\<A> ?D) +\n        local.ddh.advantage ?n\n         (local.ddh.DDH_\\<A>' ?n\n           (P1_DDH_mal_adv_\\<sigma>_false ?n ?M ?z ?\\<A> ?D))\n  \\<bar>mal_def.adv_P1 ?n1 M \\<sigma> z (P1_S1 ?n1, P1_S2) \\<A> D\\<bar>\n  \\<le> local.ddh.advantage ?n1\n         (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D) +\n        local.ddh.advantage ?n1\n         (local.ddh.DDH_\\<A>' ?n1\n           (P1_DDH_mal_adv_\\<sigma>_false ?n1 M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n (P1_DDH_mal_adv_\\<sigma>_true n M z \\<A> D)))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D))\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n  Negligible.negligible\n   (\\<lambda>n.\n       local.ddh.advantage n (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D) +\n       local.ddh.advantage n\n        (local.ddh.DDH_\\<A>' n\n          (P1_DDH_mal_adv_\\<sigma>_false n M z \\<A> D)))\n\ngoal (1 subgoal):\n 1. Negligible.negligible\n     (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)", "by presburger"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Negligible.negligible\n   (\\<lambda>n. mal_def.adv_P1 n M \\<sigma> z (P1_S1 n, P1_S2) \\<A> D)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma P2_security_asym:   \n  assumes x1_in_carrier: \"x1 \\<in> carrier (\\<G> n)\"\n    and x0_in_carrier: \"x0 \\<in> carrier (\\<G> n)\"  \n  shows \"mal_def.perfect_sec_P2 n (x0,x1) \\<sigma> z (P2_S1 n, P2_S2 n) \\<A>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mal_def.perfect_sec_P2 n (x0, x1) \\<sigma> z (P2_S1 n, P2_S2 n) \\<A>", "using assms malicious_sec_P2"], ["proof (prove)\nusing this:\n  x1 \\<in> carrier (\\<G> n)\n  x0 \\<in> carrier (\\<G> n)\n  \\<lbrakk>?x1.0 \\<in> carrier (\\<G> ?n);\n   ?x0.0 \\<in> carrier (\\<G> ?n)\\<rbrakk>\n  \\<Longrightarrow> mal_def.perfect_sec_P2 ?n (?x0.0, ?x1.0) ?\\<sigma> ?z\n                     (P2_S1 ?n, P2_S2 ?n) ?\\<A>\n\ngoal (1 subgoal):\n 1. mal_def.perfect_sec_P2 n (x0, x1) \\<sigma> z (P2_S1 n, P2_S2 n) \\<A>", "by fast"], ["", "end"], ["", "end"]]}