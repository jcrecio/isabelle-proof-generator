{"file_name": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation/ETP_RSA_OT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Multi_Party_Computation", "problem_names": ["lemma prime_set_non_empty: \"prime_set \\<noteq> {}\"", "lemma coprime_set_non_empty: \n  assumes \"N > 2\" \n  shows \"coprime_set N \\<noteq> {}\"", "lemma sample_coprime_e_gt_1:\n  assumes \"e \\<in> set_spmf (sample_coprime N)\"\n  shows \"e > 1\"", "lemma lossless_sample_coprime: \n  assumes \"\\<not> prime N\" \n    and \"N > 2\"\n  shows  \"lossless_spmf (sample_coprime N)\"", "lemma set_spmf_sample_coprime: \n  shows \"set_spmf (sample_coprime N) = {x. coprime x N \\<and> x > 1 \\<and> x < N}\"", "lemma lossless_sample_primes:\n  shows \"lossless_spmf sample_primes\"", "lemma set_spmf_sample_primes: \n  shows \"set_spmf sample_primes \\<subseteq> {x. prime x \\<and> x > 2}\"", "lemma mem_samp_primes_gt_2: \n  shows \"x \\<in> set_spmf sample_primes \\<Longrightarrow> x > 2\"", "lemma mem_samp_primes_prime: \n  shows \"x \\<in> set_spmf sample_primes \\<Longrightarrow> prime x\"", "lemma lossless_sample_primes_excl: \n  shows \"lossless_spmf (sample_primes_excl {P})\"", "lemma set_spmf_sample_set_excl [simp]: \n  assumes \"finite (Q - P)\" \n  shows \"set_spmf (sample_set_excl Q P) = (Q - P)\"", "lemma lossless_sample_set_excl: \n  assumes \"finite Q\" \n    and \"card Q > 2\"\n  shows \"lossless_spmf (sample_set_excl Q {P})\"", "lemma mem_samp_primes_excl_gt_2: \n  shows \"x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow> x > 2\"", "lemma mem_samp_primes_excl_prime : \n  shows \"x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow> prime x\"", "lemma sample_coprime_lem: \n  assumes \"x \\<in> set_spmf sample_primes\" \n    and \" y \\<in> set_spmf (sample_set_excl prime_set {x}) \"\n  shows \"lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))\"", "lemma lossless_I: \"lossless_spmf I\"", "lemma set_spmf_I_N:\n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  obtains P Q where \"N = P * Q\" \n    and \"P \\<noteq> Q\"  \n    and \"prime P\" \n    and \"prime Q\" \n    and \"coprime e ((P - 1)*(Q - 1))\" \n    and \"d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))\"", "lemma set_spmf_I_e_d: \n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  shows \"e > 1\" and \"d > 1\"", "lemma finite_range: \"finite (range index)\"", "lemma dom_eq_ran: \"domain index = range index\"", "lemma rsa_bijection:\n  assumes coprime: \"coprime e ((P-1)*(Q-1))\"\n    and prime_P: \"prime (P::nat)\" \n    and prime_Q: \"prime Q\"   \n    and P_neq_Q: \"P \\<noteq> Q\" \n    and x_lt_pq: \"x < P * Q\"\n    and y_lt_pd: \"y < P * Q\"\n    and rsa_map_eq: \"x ^ e mod (P * Q) = y ^ e mod (P * Q)\"\n  shows \"x = y\"", "lemma rsa_bij_betw:\n  assumes \"coprime e ((P - 1)*(Q - 1))\"\n    and \"prime P\" \n    and \"prime Q\"   \n    and \"P \\<noteq> Q\"\n  shows \"bij_betw (F ((P * Q), e)) (range ((P * Q), e)) (range ((P * Q), e))\"", "lemma bij_betw1:\n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  shows \"bij_betw (F ((N), e)) (range ((N), e)) (range ((N), e))\"", "lemma \n  assumes \"P dvd x\"\nshows \"[x = 0] (mod P)\"", "lemma rsa_inv: \n  assumes d: \"d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))\"\n    and coprime: \"coprime e ((P-1)*(Q-1))\"\n    and prime_P: \"prime (P::nat)\" \n    and prime_Q: \"prime Q\"   \n    and P_neq_Q: \"P \\<noteq> Q\" \n    and e_gt_1: \"e > 1\"\n    and d_gt_1: \"d > 1\" \n  shows \"((((x) ^ e) mod (P*Q)) ^ d) mod (P*Q) = x mod (P*Q)\"", "lemma rsa_inv_set_spmf_I:\n  assumes \"((N, e), d) \\<in> set_spmf I\"\n  shows \"((((x::nat) ^ e) mod N) ^ d) mod N = x mod N\"", "lemma correctness_rsa: \"etp.OT_12.correctness m1 m2\"", "lemma P1_security_rsa: \"etp.OT_12.perfect_sec_P1 m1 m2\"", "lemma P2_security_rsa:\n  assumes \"\\<forall> a. lossless_spmf (D a)\"\n    and \"\\<And>b\\<^sub>\\<sigma>. local.etp_rsa.HCP_adv etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> HCP_ad\"\n  shows \"etp.OT_12.adv_P2 m1 m2 D \\<le> 2 * HCP_ad\"", "lemma correctness_rsa_asymp: \n  shows \"etp.OT_12.correctness n m1 m2\"", "lemma P1_sec_asymp: \"etp.OT_12.perfect_sec_P1 n m1 m2\"", "lemma P2_sec_asym: \n  assumes \"\\<forall> a. lossless_spmf (D a)\" \n    and HCP_adv_neg: \"negligible (\\<lambda> n. hcp_advantage n)\"\n    and hcp_adv_bound:  \"\\<forall>b\\<^sub>\\<sigma> n. local.etp_rsa.HCP_adv n etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> hcp_advantage n\"\n  shows \"negligible (\\<lambda> n. etp.OT_12.adv_P2 n m1 m2 D)\""], "translations": [["", "lemma prime_set_non_empty: \"prime_set \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_set \\<noteq> {}", "using prime_set_gt_2"], ["proof (prove)\nusing this:\n  2 < card prime_set\n\ngoal (1 subgoal):\n 1. prime_set \\<noteq> {}", "by auto"], ["", "definition coprime_set :: \"nat \\<Rightarrow> nat set\"\n  where \"coprime_set N \\<equiv> {x. coprime x N \\<and> x > 1 \\<and> x < N}\""], ["", "lemma coprime_set_non_empty: \n  assumes \"N > 2\" \n  shows \"coprime_set N \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_set N \\<noteq> {}", "by(simp add: coprime_set_def; metis assms(1) Suc_lessE coprime_Suc_right_nat lessI numeral_2_eq_2)"], ["", "definition sample_coprime :: \"nat \\<Rightarrow> nat spmf\"\n  where \"sample_coprime N = spmf_of_set (coprime_set (N))\""], ["", "lemma sample_coprime_e_gt_1:\n  assumes \"e \\<in> set_spmf (sample_coprime N)\"\n  shows \"e > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < e", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> set_spmf (sample_coprime N)\n\ngoal (1 subgoal):\n 1. 1 < e", "by(simp add: sample_coprime_def coprime_set_def)"], ["", "lemma lossless_sample_coprime: \n  assumes \"\\<not> prime N\" \n    and \"N > 2\"\n  shows  \"lossless_spmf (sample_coprime N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "have \"coprime_set N \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime_set N \\<noteq> {}", "by(simp add: coprime_set_non_empty assms)"], ["proof (state)\nthis:\n  coprime_set N \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "also"], ["proof (state)\nthis:\n  coprime_set N \\<noteq> {}\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "have \"finite (coprime_set N)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (coprime_set N)", "by(simp add: coprime_set_def)"], ["proof (state)\nthis:\n  finite (coprime_set N)\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "ultimately"], ["proof (chain)\npicking this:\n  coprime_set N \\<noteq> {}\n  finite (coprime_set N)", "show ?thesis"], ["proof (prove)\nusing this:\n  coprime_set N \\<noteq> {}\n  finite (coprime_set N)\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime N)", "by(simp add: sample_coprime_def)"], ["proof (state)\nthis:\n  lossless_spmf (sample_coprime N)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_spmf_sample_coprime: \n  shows \"set_spmf (sample_coprime N) = {x. coprime x N \\<and> x > 1 \\<and> x < N}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (sample_coprime N) = {x. coprime x N \\<and> 1 < x \\<and> x < N}", "by(simp add: sample_coprime_def coprime_set_def)"], ["", "definition sample_primes :: \"nat spmf\"\n  where \"sample_primes = spmf_of_set prime_set\""], ["", "lemma lossless_sample_primes:\n  shows \"lossless_spmf sample_primes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf sample_primes", "by(simp add: sample_primes_def prime_set_non_empty finite_prime_set)"], ["", "lemma set_spmf_sample_primes: \n  shows \"set_spmf sample_primes \\<subseteq> {x. prime x \\<and> x > 2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf sample_primes \\<subseteq> {x. prime x \\<and> 2 < x}", "by(auto simp add: sample_primes_def prime_set_ass finite_prime_set)"], ["", "lemma mem_samp_primes_gt_2: \n  shows \"x \\<in> set_spmf sample_primes \\<Longrightarrow> x > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_spmf sample_primes \\<Longrightarrow> 2 < x", "apply (simp add: finite_prime_set sample_primes_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<Longrightarrow> 2 < x", "using prime_set_ass"], ["proof (prove)\nusing this:\n  prime_set \\<subseteq> {x. prime x \\<and> 2 < x}\n\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<Longrightarrow> 2 < x", "by blast"], ["", "lemma mem_samp_primes_prime: \n  shows \"x \\<in> set_spmf sample_primes \\<Longrightarrow> prime x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_spmf sample_primes \\<Longrightarrow> prime x", "apply (simp add: finite_prime_set sample_primes_def prime_set_ass)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<Longrightarrow> prime x", "using prime_set_ass"], ["proof (prove)\nusing this:\n  prime_set \\<subseteq> {x. prime x \\<and> 2 < x}\n\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<Longrightarrow> prime x", "by blast"], ["", "definition sample_primes_excl :: \"nat set \\<Rightarrow> nat spmf\"\n  where \"sample_primes_excl P = spmf_of_set (prime_set - P)\""], ["", "lemma lossless_sample_primes_excl: \n  shows \"lossless_spmf (sample_primes_excl {P})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_primes_excl {P})", "apply(simp add: sample_primes_excl_def finite_prime_set)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prime_set \\<subseteq> {P}", "using prime_set_gt_2 subset_singletonD"], ["proof (prove)\nusing this:\n  2 < card prime_set\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n\ngoal (1 subgoal):\n 1. \\<not> prime_set \\<subseteq> {P}", "by fastforce"], ["", "definition sample_set_excl :: \"nat set \\<Rightarrow> nat set \\<Rightarrow> nat spmf\"\n  where \"sample_set_excl Q P = spmf_of_set (Q - P)\""], ["", "lemma set_spmf_sample_set_excl [simp]: \n  assumes \"finite (Q - P)\" \n  shows \"set_spmf (sample_set_excl Q P) = (Q - P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (sample_set_excl Q P) = Q - P", "unfolding  sample_set_excl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_spmf (spmf_of_set (Q - P)) = Q - P", "by (metis set_spmf_of_set assms)+"], ["", "lemma lossless_sample_set_excl: \n  assumes \"finite Q\" \n    and \"card Q > 2\"\n  shows \"lossless_spmf (sample_set_excl Q {P})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_set_excl Q {P})", "unfolding sample_set_excl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (spmf_of_set (Q - {P}))", "using assms subset_singletonD"], ["proof (prove)\nusing this:\n  finite Q\n  2 < card Q\n  ?A \\<subseteq> {?x} \\<Longrightarrow> ?A = {} \\<or> ?A = {?x}\n\ngoal (1 subgoal):\n 1. lossless_spmf (spmf_of_set (Q - {P}))", "by fastforce"], ["", "lemma mem_samp_primes_excl_gt_2: \n  shows \"x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow> x > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow> 2 < x", "apply(simp add: finite_prime_set sample_set_excl_def  prime_set_ass )"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<and> x \\<noteq> y \\<Longrightarrow> 2 < x", "using prime_set_ass"], ["proof (prove)\nusing this:\n  prime_set \\<subseteq> {x. prime x \\<and> 2 < x}\n\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<and> x \\<noteq> y \\<Longrightarrow> 2 < x", "by blast"], ["", "lemma mem_samp_primes_excl_prime : \n  shows \"x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow> prime x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> set_spmf (sample_set_excl prime_set {y}) \\<Longrightarrow>\n    prime x", "apply (simp add: finite_prime_set sample_set_excl_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<and> x \\<noteq> y \\<Longrightarrow> prime x", "using prime_set_ass"], ["proof (prove)\nusing this:\n  prime_set \\<subseteq> {x. prime x \\<and> 2 < x}\n\ngoal (1 subgoal):\n 1. x \\<in> prime_set \\<and> x \\<noteq> y \\<Longrightarrow> prime x", "by blast"], ["", "lemma sample_coprime_lem: \n  assumes \"x \\<in> set_spmf sample_primes\" \n    and \" y \\<in> set_spmf (sample_set_excl prime_set {x}) \"\n  shows \"lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "have gt_2: \"x > 2\" \"y > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < x &&& 2 < y", "using mem_samp_primes_gt_2 assms mem_samp_primes_excl_gt_2"], ["proof (prove)\nusing this:\n  ?x \\<in> set_spmf sample_primes \\<Longrightarrow> 2 < ?x\n  x \\<in> set_spmf sample_primes\n  y \\<in> set_spmf (sample_set_excl prime_set {x})\n  ?x \\<in> set_spmf (sample_set_excl prime_set {?y}) \\<Longrightarrow>\n  2 < ?x\n\ngoal (1 subgoal):\n 1. 2 < x &&& 2 < y", "by auto"], ["proof (state)\nthis:\n  2 < x\n  2 < y\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "have \"\\<not> prime ((x-1)*(y-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "have \"prime x\" \"prime y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime x &&& prime y", "using mem_samp_primes_prime mem_samp_primes_excl_prime assms"], ["proof (prove)\nusing this:\n  ?x \\<in> set_spmf sample_primes \\<Longrightarrow> prime ?x\n  ?x \\<in> set_spmf (sample_set_excl prime_set {?y}) \\<Longrightarrow>\n  prime ?x\n  x \\<in> set_spmf sample_primes\n  y \\<in> set_spmf (sample_set_excl prime_set {x})\n\ngoal (1 subgoal):\n 1. prime x &&& prime y", "by auto"], ["proof (state)\nthis:\n  prime x\n  prime y\n\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "then"], ["proof (chain)\npicking this:\n  prime x\n  prime y", "show ?thesis"], ["proof (prove)\nusing this:\n  prime x\n  prime y\n\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "using prod_not_prime gt_2"], ["proof (prove)\nusing this:\n  prime x\n  prime y\n  \\<lbrakk>prime ?x; prime ?y; 2 < ?x; 2 < ?y\\<rbrakk>\n  \\<Longrightarrow> \\<not> prime ((?x - 1) * (?y - 1))\n  2 < x\n  2 < y\n\ngoal (1 subgoal):\n 1. \\<not> prime ((x - 1) * (y - 1))", "by simp"], ["proof (state)\nthis:\n  \\<not> prime ((x - 1) * (y - 1))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> prime ((x - 1) * (y - 1))\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "also"], ["proof (state)\nthis:\n  \\<not> prime ((x - 1) * (y - 1))\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "have \"((x-1)*(y-1)) > 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 < (x - 1) * (y - 1)", "by (metis (no_types, lifting) gt_2 One_nat_def Suc_diff_1 assms(1) assms(2) calculation \n          divisors_zero less_2_cases nat_1_eq_mult_iff nat_neq_iff not_numeral_less_one numeral_2_eq_2 \n              prime_gt_0_nat rsa_base.mem_samp_primes_excl_prime rsa_base.mem_samp_primes_prime rsa_base_axioms two_is_prime_nat)"], ["proof (state)\nthis:\n  2 < (x - 1) * (y - 1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> prime ((x - 1) * (y - 1))\n  2 < (x - 1) * (y - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> prime ((x - 1) * (y - 1))\n  2 < (x - 1) * (y - 1)\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "using lossless_sample_coprime"], ["proof (prove)\nusing this:\n  \\<not> prime ((x - 1) * (y - 1))\n  2 < (x - 1) * (y - 1)\n  \\<lbrakk>\\<not> prime ?N; 2 < ?N\\<rbrakk>\n  \\<Longrightarrow> lossless_spmf (sample_coprime ?N)\n\ngoal (1 subgoal):\n 1. lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))", "by simp"], ["proof (state)\nthis:\n  lossless_spmf (sample_coprime ((x - Suc 0) * (y - Suc 0)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition I :: \"(index \\<times> trap) spmf\"\n  where \"I = do {\n    P \\<leftarrow> sample_primes;  \n    Q \\<leftarrow> sample_set_excl prime_set {P};\n    let N = P*Q;\n    let N' = (P-1)*(Q-1);\n    e \\<leftarrow> sample_coprime N';\n    let d = nat ((fst (bezw e N')) mod N');\n    return_spmf ((N, e), d)}\""], ["", "lemma lossless_I: \"lossless_spmf I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lossless_spmf I", "by(auto simp add: I_def lossless_sample_primes lossless_sample_set_excl finite_prime_set prime_set_gt_2 Let_def sample_coprime_lem)"], ["", "lemma set_spmf_I_N:\n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  obtains P Q where \"N = P * Q\" \n    and \"P \\<noteq> Q\"  \n    and \"prime P\" \n    and \"prime Q\" \n    and \"coprime e ((P - 1)*(Q - 1))\" \n    and \"d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q; P \\<noteq> Q; prime P; prime Q;\n         coprime e ((P - 1) * (Q - 1));\n         d =\n         nat (fst (bezw e ((P - 1) * (Q - 1))) mod\n              int ((P - 1) * (Q - 1)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  ((N, e), d) \\<in> set_spmf I\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q; P \\<noteq> Q; prime P; prime Q;\n         coprime e ((P - 1) * (Q - 1));\n         d =\n         nat (fst (bezw e ((P - 1) * (Q - 1))) mod\n              int ((P - 1) * (Q - 1)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp add: I_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>x * xa = P * Q; P \\<noteq> Q; prime P; prime Q;\n                    coprime e (P - Suc 0) \\<and> coprime e (Q - Suc 0);\n                    nat (fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n                         (int (x - Suc 0) * int (xa - Suc 0))) =\n                    nat (fst (bezw e ((P - Suc 0) * (Q - Suc 0))) mod\n                         (int (P - Suc 0) * int (Q - Suc 0)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        x \\<in> set_spmf sample_primes;\n        xa \\<in> set_spmf (sample_set_excl prime_set {x}); N = x * xa;\n        e \\<in> set_spmf (sample_coprime ((x - Suc 0) * (xa - Suc 0)));\n        d =\n        nat (fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n             (int (x - Suc 0) * int (xa - Suc 0)))\\<rbrakk>\n       \\<Longrightarrow> thesis", "using finite_prime_set mem_samp_primes_prime sample_set_excl_def rsa_base_axioms sample_primes_def"], ["proof (prove)\nusing this:\n  finite prime_set\n  ?x \\<in> set_spmf sample_primes \\<Longrightarrow> prime ?x\n  sample_set_excl ?Q ?P = spmf_of_set (?Q - ?P)\n  rsa_base prime_set\n  sample_primes = spmf_of_set prime_set\n\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>P Q.\n                   \\<lbrakk>x * xa = P * Q; P \\<noteq> Q; prime P; prime Q;\n                    coprime e (P - Suc 0) \\<and> coprime e (Q - Suc 0);\n                    nat (fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n                         (int (x - Suc 0) * int (xa - Suc 0))) =\n                    nat (fst (bezw e ((P - Suc 0) * (Q - Suc 0))) mod\n                         (int (P - Suc 0) * int (Q - Suc 0)))\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        x \\<in> set_spmf sample_primes;\n        xa \\<in> set_spmf (sample_set_excl prime_set {x}); N = x * xa;\n        e \\<in> set_spmf (sample_coprime ((x - Suc 0) * (xa - Suc 0)));\n        d =\n        nat (fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n             (int (x - Suc 0) * int (xa - Suc 0)))\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (simp add: set_spmf_sample_coprime)"], ["", "lemma set_spmf_I_e_d: \n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  shows \"e > 1\" and \"d > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < e &&& 1 < d", "using assms sample_coprime_e_gt_1"], ["proof (prove)\nusing this:\n  ((N, e), d) \\<in> set_spmf I\n  ?e \\<in> set_spmf (sample_coprime ?N) \\<Longrightarrow> 1 < ?e\n\ngoal (1 subgoal):\n 1. 1 < e &&& 1 < d", "apply(auto simp add: I_def Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       \\<lbrakk>\\<And>e N.\n                   e \\<in> set_spmf (sample_coprime N) \\<Longrightarrow>\n                   Suc 0 < e;\n        x \\<in> set_spmf sample_primes;\n        xa \\<in> set_spmf (sample_set_excl prime_set {x}); N = x * xa;\n        e \\<in> set_spmf (sample_coprime ((x - Suc 0) * (xa - Suc 0)));\n        d =\n        nat (fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n             (int (x - Suc 0) * int (xa - Suc 0)))\\<rbrakk>\n       \\<Longrightarrow> 1 < fst (bezw e ((x - Suc 0) * (xa - Suc 0))) mod\n                             (int (x - Suc 0) * int (xa - Suc 0))", "by (smt Euclidean_Division.pos_mod_sign Num.of_nat_simps(5) Suc_diff_1 bezw_inverse cong_def coprime_imp_gcd_eq_1 gr0I less_1_mult less_numeral_extra(2) mem_Collect_eq mod_by_0 mod_less more_arith_simps(6) nat_0 nat_0_less_mult_iff nat_int nat_neq_iff numerals(2) of_nat_0_le_iff of_nat_1 rsa_base.mem_samp_primes_gt_2 rsa_base_axioms set_spmf_sample_coprime zero_less_diff)"], ["", "definition domain :: \"index \\<Rightarrow> nat set\"\n  where \"domain index \\<equiv> {..< fst index}\""], ["", "definition range :: \"index \\<Rightarrow> nat set\"\n  where \"range index \\<equiv> {..< fst index}\""], ["", "lemma finite_range: \"finite (range index)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.range index)", "by(simp add: range_def)"], ["", "lemma dom_eq_ran: \"domain index = range index\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.domain index = local.range index", "by(simp add: range_def domain_def)"], ["", "definition F :: \"index \\<Rightarrow> (nat \\<Rightarrow> nat)\"\n  where \"F index x = x ^ (snd index) mod (fst index)\""], ["", "definition F\\<^sub>i\\<^sub>n\\<^sub>v :: \"index \\<Rightarrow> trap \\<Rightarrow> nat \\<Rightarrow> nat\"\n  where \"F\\<^sub>i\\<^sub>n\\<^sub>v \\<alpha> \\<tau> y = y ^ \\<tau> mod (fst \\<alpha>)\""], ["", "text \\<open> We must prove the RSA function is a bijection \\<close>"], ["", "lemma rsa_bijection:\n  assumes coprime: \"coprime e ((P-1)*(Q-1))\"\n    and prime_P: \"prime (P::nat)\" \n    and prime_Q: \"prime Q\"   \n    and P_neq_Q: \"P \\<noteq> Q\" \n    and x_lt_pq: \"x < P * Q\"\n    and y_lt_pd: \"y < P * Q\"\n    and rsa_map_eq: \"x ^ e mod (P * Q) = y ^ e mod (P * Q)\"\n  shows \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have flt_xP: \"[x ^ P = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ P = x] (mod P)", "using fermat_little prime_P"], ["proof (prove)\nusing this:\n  prime ?P \\<Longrightarrow> [?x ^ ?P = ?x] (mod ?P)\n  prime P\n\ngoal (1 subgoal):\n 1. [x ^ P = x] (mod P)", "by blast"], ["proof (state)\nthis:\n  [x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. x = y", "have flt_yP: \"[y ^ P = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ P = y] (mod P)", "using fermat_little prime_P"], ["proof (prove)\nusing this:\n  prime ?P \\<Longrightarrow> [?x ^ ?P = ?x] (mod ?P)\n  prime P\n\ngoal (1 subgoal):\n 1. [y ^ P = y] (mod P)", "by blast"], ["proof (state)\nthis:\n  [y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. x = y", "have flt_xQ: \"[x ^ Q = x] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ Q = x] (mod Q)", "using fermat_little prime_Q"], ["proof (prove)\nusing this:\n  prime ?P \\<Longrightarrow> [?x ^ ?P = ?x] (mod ?P)\n  prime Q\n\ngoal (1 subgoal):\n 1. [x ^ Q = x] (mod Q)", "by blast"], ["proof (state)\nthis:\n  [x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. x = y", "have flt_yQ: \"[y ^ Q = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ Q = y] (mod Q)", "using fermat_little prime_Q"], ["proof (prove)\nusing this:\n  prime ?P \\<Longrightarrow> [?x ^ ?P = ?x] (mod ?P)\n  prime Q\n\ngoal (1 subgoal):\n 1. [y ^ Q = y] (mod Q)", "by blast"], ["proof (state)\nthis:\n  [y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof(cases \"y \\<ge> x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "case True"], ["proof (state)\nthis:\n  x \\<le> y\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "hence ye_gt_xe: \"y^e \\<ge> x^e\""], ["proof (prove)\nusing this:\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. x ^ e \\<le> y ^ e", "by (simp add: power_mono)"], ["proof (state)\nthis:\n  x ^ e \\<le> y ^ e\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have x_y_exp_e: \"[x^e = y^e] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod P)", "using cong_modulus_mult_nat  cong_altdef_nat True ye_gt_xe cong_sym cong_def assms"], ["proof (prove)\nusing this:\n  [?x = ?y] (mod ?m * ?n) \\<Longrightarrow> [?x = ?y] (mod ?m)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  x \\<le> y\n  x ^ e \\<le> y ^ e\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  x < P * Q\n  y < P * Q\n  x ^ e mod (P * Q) = y ^ e mod (P * Q)\n\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod P)", "by blast"], ["proof (state)\nthis:\n  [x ^ e = y ^ e] (mod P)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "obtain d where d:  \"[e*d = 1] (mod (P-1)) \\<and> d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_inverse assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q;\n   ?P \\<noteq> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       [?e * d = 1] (mod ?P - 1) \\<and> d \\<noteq> 0\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  x < P * Q\n  y < P * Q\n  x ^ e mod (P * Q) = y ^ e mod (P * Q)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "obtain k where k: \"e*d = 1 + k*(P-1)\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_k_mod assms"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); ?P \\<noteq> ?Q; prime ?P;\n   prime ?Q; ?d \\<noteq> 0; [?e * ?d = 1] (mod ?P - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?e * ?d = 1 + k * (?P - 1)\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  x < P * Q\n  y < P * Q\n  x ^ e mod (P * Q) = y ^ e mod (P * Q)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e * d = 1 + k * (P - 1)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "hence xk_yk: \"[x^(1 + k*(P-1)) = y^(1 + k*(P-1))] (mod P)\""], ["proof (prove)\nusing this:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "by(metis k power_mult x_y_exp_e cong_pow)"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_x: \"[x^(1 + k*(P-1)) = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n 2. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n 2. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "case (Suc k)"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "assume  asm: \"[x ^ (1 + k * (P - 1)) = x] (mod P)\""], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "then"], ["proof (chain)\npicking this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)", "show ?case"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "have exp_rewrite: \"(k * (P - 1) + P) = (1 + (k + 1) * (P - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * (P - 1) + P = 1 + (k + 1) * (P - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_P prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "have \"[x * x ^ (k * (P - 1)) = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * x ^ (k * (P - 1)) = x] (mod P)", "using asm"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x * x ^ (k * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (k * (P - 1)) * x ^ P = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1)) * x ^ P = x] (mod P)", "using flt_xP"], ["proof (prove)\nusing this:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n  [x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1)) * x ^ P = x] (mod P)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [x ^ (k * (P - 1)) * x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (k * (P - 1) + P) = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1)) * x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1) + P) = x] (mod P)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)", "by argo"], ["proof (state)\nthis:\n  [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k * (P - 1)) = x] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k * (P - 1)) = x] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have yk_y: \"[y^(1 + k*(P-1)) = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n 2. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n 2. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "case (Suc k)"], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "assume  asm: \"[y ^ (1 + k * (P - 1)) = y] (mod P)\""], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "then"], ["proof (chain)\npicking this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)", "show ?case"], ["proof (prove)\nusing this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "have exp_rewrite: \"(k * (P - 1) + P) = (1 + (k + 1) * (P - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * (P - 1) + P = 1 + (k + 1) * (P - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_P prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "have \"[y * y ^ (k * (P - 1)) = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y * y ^ (k * (P - 1)) = y] (mod P)", "using asm"], ["proof (prove)\nusing this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y * y ^ (k * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (k * (P - 1)) * y ^ P = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1)) * y ^ P = y] (mod P)", "using flt_yP"], ["proof (prove)\nusing this:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n  [y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1)) * y ^ P = y] (mod P)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [y ^ (k * (P - 1)) * y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (k * (P - 1) + P) = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1)) * y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1) + P) = y] (mod P)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)", "by argo"], ["proof (state)\nthis:\n  [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k * (P - 1)) = y] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k * (P - 1)) = y] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have \"[x^e = y^e] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod Q)", "by (metis rsa_map_eq cong_modulus_mult_nat cong_def mult.commute)"], ["proof (state)\nthis:\n  [x ^ e = y ^ e] (mod Q)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "obtain d' where d':  \"[e*d' = 1] (mod (Q-1)) \\<and> d' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mult.commute ex_inverse prime_P prime_Q P_neq_Q coprime)"], ["proof (state)\nthis:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0", "obtain k' where k': \"e*d' = 1 + k'*(Q-1)\""], ["proof (prove)\nusing this:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        e * d' = 1 + k' * (Q - 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(metis ex_k_mod mult.commute prime_P prime_Q P_neq_Q coprime)"], ["proof (state)\nthis:\n  e * d' = 1 + k' * (Q - 1)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "hence xk_yk': \"[x^(1 + k'*(Q-1)) = y^(1 + k'*(Q-1))] (mod Q)\""], ["proof (prove)\nusing this:\n  e * d' = 1 + k' * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "by(metis k' power_mult \\<open>[x ^ e = y ^ e] (mod Q)\\<close> cong_pow)"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_x': \"[x^(1 + k'*(Q-1)) = x] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q)", "proof(induct k')"], ["proof (state)\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n 2. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n 2. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "case (Suc k')"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "assume  asm: \"[x ^ (1 + k' * (Q - 1)) = x] (mod Q)\""], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)", "show ?case"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "have exp_rewrite: \"(k' * (Q - 1) + Q) = (1 + (k' + 1) * (Q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_Q prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "have \"[x * x ^ (k' * (Q - 1)) = x] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * x ^ (k' * (Q - 1)) = x] (mod Q)", "using asm"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x * x ^ (k' * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)", "using flt_xQ"], ["proof (prove)\nusing this:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n  [x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (k' * (Q - 1) + Q) = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1) + Q) = x] (mod Q)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)", "by argo"], ["proof (state)\nthis:\n  [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have yk_y': \"[y^(1 + k'*(Q-1)) = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q)", "proof(induct k')"], ["proof (state)\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n 2. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n 2. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "case (Suc k')"], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "assume  asm: \"[y ^ (1 + k' * (Q - 1)) = y] (mod Q)\""], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)", "show ?case"], ["proof (prove)\nusing this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "have exp_rewrite: \"(k' * (Q - 1) + Q) = (1 + (k' + 1) * (Q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_Q prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "have \"[y * y ^ (k' * (Q - 1)) = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y * y ^ (k' * (Q - 1)) = y] (mod Q)", "using asm"], ["proof (prove)\nusing this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y * y ^ (k' * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)", "using flt_yQ"], ["proof (prove)\nusing this:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n  [y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (k' * (Q - 1) + Q) = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1) + Q) = y] (mod Q)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)", "by argo"], ["proof (state)\nthis:\n  [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have P_dvd_xy: \"P dvd (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P dvd y - x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P dvd y - x", "have \"[x = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = y] (mod P)", "using xk_x yk_y xk_yk"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n\ngoal (1 subgoal):\n 1. [x = y] (mod P)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x = y] (mod P)\n\ngoal (1 subgoal):\n 1. P dvd y - x", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x = y] (mod P)\n\ngoal (1 subgoal):\n 1. P dvd y - x", "using cong_altdef_nat cong_sym True"], ["proof (prove)\nusing this:\n  [x = y] (mod P)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. P dvd y - x", "by blast"], ["proof (state)\nthis:\n  P dvd y - x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P dvd y - x\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have Q_dvd_xy: \"Q dvd (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q dvd y - x", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Q dvd y - x", "have \"[x = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = y] (mod Q)", "using xk_x' yk_y' xk_yk'"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n  [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)\n\ngoal (1 subgoal):\n 1. [x = y] (mod Q)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x = y] (mod Q)\n\ngoal (1 subgoal):\n 1. Q dvd y - x", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x = y] (mod Q)\n\ngoal (1 subgoal):\n 1. Q dvd y - x", "using cong_altdef_nat cong_sym True"], ["proof (prove)\nusing this:\n  [x = y] (mod Q)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  x \\<le> y\n\ngoal (1 subgoal):\n 1. Q dvd y - x", "by blast"], ["proof (state)\nthis:\n  Q dvd y - x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q dvd y - x\n\ngoal (2 subgoals):\n 1. x \\<le> y \\<Longrightarrow> x = y\n 2. \\<not> x \\<le> y \\<Longrightarrow> x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"P*Q dvd (y - x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q dvd y - x", "using P_dvd_xy  Q_dvd_xy"], ["proof (prove)\nusing this:\n  P dvd y - x\n  Q dvd y - x\n\ngoal (1 subgoal):\n 1. P * Q dvd y - x", "by (simp add: assms divides_mult primes_coprime)"], ["proof (state)\nthis:\n  P * Q dvd y - x\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  P * Q dvd y - x", "have \"[x = y] (mod P*Q)\""], ["proof (prove)\nusing this:\n  P * Q dvd y - x\n\ngoal (1 subgoal):\n 1. [x = y] (mod P * Q)", "by (simp add: cong_altdef_nat cong_sym True)"], ["proof (state)\nthis:\n  [x = y] (mod P * Q)\n\ngoal (1 subgoal):\n 1. x = y", "hence \"x mod P*Q = y mod P*Q\""], ["proof (prove)\nusing this:\n  [x = y] (mod P * Q)\n\ngoal (1 subgoal):\n 1. x mod P * Q = y mod P * Q", "using  cong_def xk_x xk_yk yk_y"], ["proof (prove)\nusing this:\n  [x = y] (mod P * Q)\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. x mod P * Q = y mod P * Q", "by metis"], ["proof (state)\nthis:\n  x mod P * Q = y mod P * Q\n\ngoal (1 subgoal):\n 1. x = y", "then"], ["proof (chain)\npicking this:\n  x mod P * Q = y mod P * Q", "show ?thesis"], ["proof (prove)\nusing this:\n  x mod P * Q = y mod P * Q\n\ngoal (1 subgoal):\n 1. x = y", "using \\<open>[x = y] (mod P * Q)\\<close> cong_less_modulus_unique_nat x_lt_pq y_lt_pd"], ["proof (prove)\nusing this:\n  x mod P * Q = y mod P * Q\n  [x = y] (mod P * Q)\n  \\<lbrakk>[?x = ?y] (mod ?m); ?x < ?m; ?y < ?m\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  x < P * Q\n  y < P * Q\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "case False"], ["proof (state)\nthis:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "hence ye_gt_xe: \"x^e \\<ge> y^e\""], ["proof (prove)\nusing this:\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. y ^ e \\<le> x ^ e", "by (simp add: power_mono)"], ["proof (state)\nthis:\n  y ^ e \\<le> x ^ e\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have pow_eq: \"[x^e = y^e] (mod P*Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod P * Q)", "by (simp add: cong_def assms)"], ["proof (state)\nthis:\n  [x ^ e = y ^ e] (mod P * Q)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [x ^ e = y ^ e] (mod P * Q)", "have PQ_dvd_ye_xe: \"(P*Q) dvd (x^e - y^e)\""], ["proof (prove)\nusing this:\n  [x ^ e = y ^ e] (mod P * Q)\n\ngoal (1 subgoal):\n 1. P * Q dvd x ^ e - y ^ e", "using cong_altdef_nat False ye_gt_xe cong_sym"], ["proof (prove)\nusing this:\n  [x ^ e = y ^ e] (mod P * Q)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  \\<not> x \\<le> y\n  y ^ e \\<le> x ^ e\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n\ngoal (1 subgoal):\n 1. P * Q dvd x ^ e - y ^ e", "by blast"], ["proof (state)\nthis:\n  P * Q dvd x ^ e - y ^ e\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  P * Q dvd x ^ e - y ^ e", "have \"[x^e = y^e] (mod P)\""], ["proof (prove)\nusing this:\n  P * Q dvd x ^ e - y ^ e\n\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod P)", "using cong_modulus_mult_nat pow_eq"], ["proof (prove)\nusing this:\n  P * Q dvd x ^ e - y ^ e\n  [?x = ?y] (mod ?m * ?n) \\<Longrightarrow> [?x = ?y] (mod ?m)\n  [x ^ e = y ^ e] (mod P * Q)\n\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod P)", "by blast"], ["proof (state)\nthis:\n  [x ^ e = y ^ e] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "obtain d where d:  \"[e*d = 1] (mod (P-1)) \\<and> d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_inverse assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q;\n   ?P \\<noteq> ?Q\\<rbrakk>\n  \\<Longrightarrow> \\<exists>d.\n                       [?e * d = 1] (mod ?P - 1) \\<and> d \\<noteq> 0\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  x < P * Q\n  y < P * Q\n  x ^ e mod (P * Q) = y ^ e mod (P * Q)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0", "obtain k where k: \"e*d = 1 + k*(P-1)\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_k_mod assms"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1) \\<and> d \\<noteq> 0\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); ?P \\<noteq> ?Q; prime ?P;\n   prime ?Q; ?d \\<noteq> 0; [?e * ?d = 1] (mod ?P - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?e * ?d = 1 + k * (?P - 1)\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  x < P * Q\n  y < P * Q\n  x ^ e mod (P * Q) = y ^ e mod (P * Q)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_yk: \"[x^(1 + k*(P-1)) = y^(1 + k*(P-1))] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "have \"[(x^e)^d = (y^e)^d] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d = (y ^ e) ^ d] (mod P)", "using \\<open>[x ^ e = y ^ e] (mod P)\\<close> cong_pow"], ["proof (prove)\nusing this:\n  [x ^ e = y ^ e] (mod P)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b ^ ?n = ?c ^ ?n] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d = (y ^ e) ^ d] (mod P)", "by blast"], ["proof (state)\nthis:\n  [(x ^ e) ^ d = (y ^ e) ^ d] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "then"], ["proof (chain)\npicking this:\n  [(x ^ e) ^ d = (y ^ e) ^ d] (mod P)", "have \"[x^(e*d) = y^(e*d)] (mod P)\""], ["proof (prove)\nusing this:\n  [(x ^ e) ^ d = (y ^ e) ^ d] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = y ^ (e * d)] (mod P)", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  [x ^ (e * d) = y ^ (e * d)] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = y ^ (e * d)] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "using k"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = y ^ (e * d)] (mod P)\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_x: \"[x^(1 + k*(P-1)) = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n 2. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n 2. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + 0 * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + 0 * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "case (Suc k)"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "assume  asm: \"[x ^ (1 + k * (P - 1)) = x] (mod P)\""], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n       [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "then"], ["proof (chain)\npicking this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)", "show ?case"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "have exp_rewrite: \"(k * (P - 1) + P) = (1 + (k + 1) * (P - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * (P - 1) + P = 1 + (k + 1) * (P - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_P prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "have \"[x * x ^ (k * (P - 1)) = x] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * x ^ (k * (P - 1)) = x] (mod P)", "using asm"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x * x ^ (k * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (k * (P - 1)) * x ^ P = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1)) * x ^ P = x] (mod P)", "using flt_xP"], ["proof (prove)\nusing this:\n  [x * x ^ (k * (P - 1)) = x] (mod P)\n  [x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1)) * x ^ P = x] (mod P)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [x ^ (k * (P - 1)) * x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (k * (P - 1) + P) = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1)) * x ^ P = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (k * (P - 1) + P) = x] (mod P)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "hence \"[x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [x ^ (k * (P - 1) + P) = x] (mod P)\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)", "by argo"], ["proof (state)\nthis:\n  [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k * (P - 1)) = x] (mod P) \\<Longrightarrow>\n    [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (1 + (k + 1) * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k * (P - 1)) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k * (P - 1)) = x] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k * (P - 1)) = x] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have yk_y: \"[y^(1 + k*(P-1)) = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P)", "proof(induct k)"], ["proof (state)\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n 2. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n 2. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + 0 * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + 0 * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "case (Suc k)"], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "assume  asm: \"[y ^ (1 + k * (P - 1)) = y] (mod P)\""], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<And>k.\n       [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n       [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "then"], ["proof (chain)\npicking this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)", "show ?case"], ["proof (prove)\nusing this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "have exp_rewrite: \"(k * (P - 1) + P) = (1 + (k + 1) * (P - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k * (P - 1) + P = 1 + (k + 1) * (P - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_P prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "have \"[y * y ^ (k * (P - 1)) = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y * y ^ (k * (P - 1)) = y] (mod P)", "using asm"], ["proof (prove)\nusing this:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y * y ^ (k * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (k * (P - 1)) * y ^ P = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1)) * y ^ P = y] (mod P)", "using flt_yP"], ["proof (prove)\nusing this:\n  [y * y ^ (k * (P - 1)) = y] (mod P)\n  [y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1)) * y ^ P = y] (mod P)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [y ^ (k * (P - 1)) * y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (k * (P - 1) + P) = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1)) * y ^ P = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (k * (P - 1) + P) = y] (mod P)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "hence \"[y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\""], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [y ^ (k * (P - 1) + P) = y] (mod P)\n  k * (P - 1) + P = 1 + (k + 1) * (P - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)", "by argo"], ["proof (state)\nthis:\n  [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k * (P - 1)) = y] (mod P) \\<Longrightarrow>\n    [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [y ^ (1 + (k + 1) * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k * (P - 1)) = y] (mod P)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k * (P - 1)) = y] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k * (P - 1)) = y] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have P_dvd_xy: \"P dvd (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P dvd x - y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. P dvd x - y", "have \"[x = y] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = y] (mod P)", "using xk_x yk_y xk_yk"], ["proof (prove)\nusing this:\n  [x ^ (1 + k * (P - 1)) = x] (mod P)\n  [y ^ (1 + k * (P - 1)) = y] (mod P)\n  [x ^ (1 + k * (P - 1)) = y ^ (1 + k * (P - 1))] (mod P)\n\ngoal (1 subgoal):\n 1. [x = y] (mod P)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x = y] (mod P)\n\ngoal (1 subgoal):\n 1. P dvd x - y", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x = y] (mod P)\n\ngoal (1 subgoal):\n 1. P dvd x - y", "using cong_altdef_nat cong_sym False"], ["proof (prove)\nusing this:\n  [x = y] (mod P)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. P dvd x - y", "by simp"], ["proof (state)\nthis:\n  P dvd x - y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  P dvd x - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have \"[x^e = y^e] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod Q)", "using cong_modulus_mult_nat pow_eq PQ_dvd_ye_xe cong_dvd_modulus_nat dvd_triv_right"], ["proof (prove)\nusing this:\n  [?x = ?y] (mod ?m * ?n) \\<Longrightarrow> [?x = ?y] (mod ?m)\n  [x ^ e = y ^ e] (mod P * Q)\n  P * Q dvd x ^ e - y ^ e\n  \\<lbrakk>[?x = ?y] (mod ?m); ?n dvd ?m\\<rbrakk>\n  \\<Longrightarrow> [?x = ?y] (mod ?n)\n  ?a dvd ?b * ?a\n\ngoal (1 subgoal):\n 1. [x ^ e = y ^ e] (mod Q)", "by blast"], ["proof (state)\nthis:\n  [x ^ e = y ^ e] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "obtain d' where d':  \"[e*d' = 1] (mod (Q-1)) \\<and> d' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d'.\n        [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mult.commute ex_inverse prime_P prime_Q coprime P_neq_Q)"], ["proof (state)\nthis:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0", "obtain k' where k': \"e*d' = 1 + k'*(Q-1)\""], ["proof (prove)\nusing this:\n  [e * d' = 1] (mod Q - 1) \\<and> d' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>k'.\n        e * d' = 1 + k' * (Q - 1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(metis ex_k_mod mult.commute prime_P prime_Q coprime P_neq_Q)"], ["proof (state)\nthis:\n  e * d' = 1 + k' * (Q - 1)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_yk': \"[x^(1 + k'*(Q-1)) = y^(1 + k'*(Q-1))] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "have \"[(x^e)^d' = (y^e)^d'] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d' = (y ^ e) ^ d'] (mod Q)", "using \\<open>[x ^ e = y ^ e] (mod Q)\\<close> cong_pow"], ["proof (prove)\nusing this:\n  [x ^ e = y ^ e] (mod Q)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?b ^ ?n = ?c ^ ?n] (mod ?a)\n\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d' = (y ^ e) ^ d'] (mod Q)", "by blast"], ["proof (state)\nthis:\n  [(x ^ e) ^ d' = (y ^ e) ^ d'] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [(x ^ e) ^ d' = (y ^ e) ^ d'] (mod Q)", "have \"[x^(e*d') = y^(e*d')] (mod Q)\""], ["proof (prove)\nusing this:\n  [(x ^ e) ^ d' = (y ^ e) ^ d'] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d') = y ^ (e * d')] (mod Q)", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  [x ^ (e * d') = y ^ (e * d')] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (e * d') = y ^ (e * d')] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "using k'"], ["proof (prove)\nusing this:\n  [x ^ (e * d') = y ^ (e * d')] (mod Q)\n  e * d' = 1 + k' * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have xk_x': \"[x^(1 + k'*(Q-1)) = x] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q)", "proof(induct k')"], ["proof (state)\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n 2. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n 2. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + 0 * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "case (Suc k')"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "assume  asm: \"[x ^ (1 + k' * (Q - 1)) = x] (mod Q)\""], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n       [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)", "show ?case"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "have exp_rewrite: \"(k' * (Q - 1) + Q) = (1 + (k' + 1) * (Q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_Q prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "have \"[x * x ^ (k' * (Q - 1)) = x] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x * x ^ (k' * (Q - 1)) = x] (mod Q)", "using asm"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x * x ^ (k' * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)", "using flt_xQ"], ["proof (prove)\nusing this:\n  [x * x ^ (k' * (Q - 1)) = x] (mod Q)\n  [x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (k' * (Q - 1) + Q) = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1)) * x ^ Q = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (k' * (Q - 1) + Q) = x] (mod Q)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "hence \"[x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [x ^ (k' * (Q - 1) + Q) = x] (mod Q)\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)", "by argo"], ["proof (state)\nthis:\n  [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + k' * (Q - 1)) = x] (mod Q) \\<Longrightarrow>\n    [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (1 + (k' + 1) * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + Suc k' * (Q - 1)) = x] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have yk_y': \"[y^(1 + k'*(Q-1)) = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q)", "proof(induct k')"], ["proof (state)\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n 2. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n 2. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + 0 * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "case (Suc k')"], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "assume  asm: \"[y ^ (1 + k' * (Q - 1)) = y] (mod Q)\""], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<And>k'.\n       [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n       [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)", "show ?case"], ["proof (prove)\nusing this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "have exp_rewrite: \"(k' * (Q - 1) + Q) = (1 + (k' + 1) * (Q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)", "by (smt add.assoc add.commute le_add_diff_inverse nat_le_linear not_add_less1 prime_Q prime_gt_1_nat semiring_normalization_rules(3))"], ["proof (state)\nthis:\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "have \"[y * y ^ (k' * (Q - 1)) = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [y * y ^ (k' * (Q - 1)) = y] (mod Q)", "using asm"], ["proof (prove)\nusing this:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y * y ^ (k' * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)", "using flt_yQ"], ["proof (prove)\nusing this:\n  [y * y ^ (k' * (Q - 1)) = y] (mod Q)\n  [y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)", "by (metis cong_scalar_right cong_trans mult.commute)"], ["proof (state)\nthis:\n  [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (k' * (Q - 1) + Q) = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1)) * y ^ Q = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (k' * (Q - 1) + Q) = y] (mod Q)", "by (simp add: power_add)"], ["proof (state)\nthis:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "hence \"[y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\""], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)", "using exp_rewrite"], ["proof (prove)\nusing this:\n  [y ^ (k' * (Q - 1) + Q) = y] (mod Q)\n  k' * (Q - 1) + Q = 1 + (k' + 1) * (Q - 1)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)", "by argo"], ["proof (state)\nthis:\n  [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + k' * (Q - 1)) = y] (mod Q) \\<Longrightarrow>\n    [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [y ^ (1 + (k' + 1) * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + Suc k' * (Q - 1)) = y] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "have Q_dvd_xy: \"Q dvd (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q dvd x - y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Q dvd x - y", "have \"[x = y] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = y] (mod Q)", "using xk_x' yk_y' xk_yk'"], ["proof (prove)\nusing this:\n  [x ^ (1 + k' * (Q - 1)) = x] (mod Q)\n  [y ^ (1 + k' * (Q - 1)) = y] (mod Q)\n  [x ^ (1 + k' * (Q - 1)) = y ^ (1 + k' * (Q - 1))] (mod Q)\n\ngoal (1 subgoal):\n 1. [x = y] (mod Q)", "by (simp add: cong_def)"], ["proof (state)\nthis:\n  [x = y] (mod Q)\n\ngoal (1 subgoal):\n 1. Q dvd x - y", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x = y] (mod Q)\n\ngoal (1 subgoal):\n 1. Q dvd x - y", "using cong_altdef_nat cong_sym False"], ["proof (prove)\nusing this:\n  [x = y] (mod Q)\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  [?b = ?c] (mod ?a) \\<Longrightarrow> [?c = ?b] (mod ?a)\n  \\<not> x \\<le> y\n\ngoal (1 subgoal):\n 1. Q dvd x - y", "by simp"], ["proof (state)\nthis:\n  Q dvd x - y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Q dvd x - y\n\ngoal (1 subgoal):\n 1. \\<not> x \\<le> y \\<Longrightarrow> x = y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. x = y", "have \"P*Q dvd (x - y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P * Q dvd x - y", "using P_dvd_xy Q_dvd_xy"], ["proof (prove)\nusing this:\n  P dvd x - y\n  Q dvd x - y\n\ngoal (1 subgoal):\n 1. P * Q dvd x - y", "by (simp add: assms divides_mult primes_coprime)"], ["proof (state)\nthis:\n  P * Q dvd x - y\n\ngoal (1 subgoal):\n 1. x = y", "hence 1: \"[x = y] (mod P*Q)\""], ["proof (prove)\nusing this:\n  P * Q dvd x - y\n\ngoal (1 subgoal):\n 1. [x = y] (mod P * Q)", "using False cong_altdef_nat linear"], ["proof (prove)\nusing this:\n  P * Q dvd x - y\n  \\<not> x \\<le> y\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  ?x \\<le> ?y \\<or> ?y \\<le> ?x\n\ngoal (1 subgoal):\n 1. [x = y] (mod P * Q)", "by blast"], ["proof (state)\nthis:\n  [x = y] (mod P * Q)\n\ngoal (1 subgoal):\n 1. x = y", "hence \"x mod P*Q = y mod P*Q\""], ["proof (prove)\nusing this:\n  [x = y] (mod P * Q)\n\ngoal (1 subgoal):\n 1. x mod P * Q = y mod P * Q", "using cong_less_modulus_unique_nat x_lt_pq y_lt_pd"], ["proof (prove)\nusing this:\n  [x = y] (mod P * Q)\n  \\<lbrakk>[?x = ?y] (mod ?m); ?x < ?m; ?y < ?m\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  x < P * Q\n  y < P * Q\n\ngoal (1 subgoal):\n 1. x mod P * Q = y mod P * Q", "by blast"], ["proof (state)\nthis:\n  x mod P * Q = y mod P * Q\n\ngoal (1 subgoal):\n 1. x = y", "thus ?thesis"], ["proof (prove)\nusing this:\n  x mod P * Q = y mod P * Q\n\ngoal (1 subgoal):\n 1. x = y", "using 1 cong_less_modulus_unique_nat x_lt_pq y_lt_pd"], ["proof (prove)\nusing this:\n  x mod P * Q = y mod P * Q\n  [x = y] (mod P * Q)\n  \\<lbrakk>[?x = ?y] (mod ?m); ?x < ?m; ?y < ?m\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  x < P * Q\n  y < P * Q\n\ngoal (1 subgoal):\n 1. x = y", "by blast"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsa_bij_betw:\n  assumes \"coprime e ((P - 1)*(Q - 1))\"\n    and \"prime P\" \n    and \"prime Q\"   \n    and \"P \\<noteq> Q\"\n  shows \"bij_betw (F ((P * Q), e)) (range ((P * Q), e)) (range ((P * Q), e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "have PQ_not_0: \"prime P \\<longrightarrow> prime Q \\<longrightarrow> P * Q \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime P \\<longrightarrow> prime Q \\<longrightarrow> P * Q \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. prime P \\<longrightarrow> prime Q \\<longrightarrow> P * Q \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  prime P \\<longrightarrow> prime Q \\<longrightarrow> P * Q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "have \"inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) {..<fst (P * Q, e)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n     {..<fst (P * Q, e)}", "apply(simp add: inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<P * Q}.\n       \\<forall>y\\<in>{..<P * Q}.\n          x ^ e mod (P * Q) = y ^ e mod (P * Q) \\<longrightarrow> x = y", "using rsa_bijection assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q;\n   ?P \\<noteq> ?Q; ?x < ?P * ?Q; ?y < ?P * ?Q;\n   ?x ^ ?e mod (?P * ?Q) = ?y ^ ?e mod (?P * ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>{..<P * Q}.\n       \\<forall>y\\<in>{..<P * Q}.\n          x ^ e mod (P * Q) = y ^ e mod (P * Q) \\<longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n   {..<fst (P * Q, e)}\n\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "moreover"], ["proof (state)\nthis:\n  inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n   {..<fst (P * Q, e)}\n\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "have \"(\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) ` {..<fst (P * Q, e)} = {..<fst (P * Q, e)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n    {..<fst (P * Q, e)} =\n    {..<fst (P * Q, e)}", "apply(simp add: assms(2) assms(3) prime_gt_0_nat PQ_not_0)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x ^ e mod (P * Q)) ` {..<P * Q} = {..<P * Q}", "apply(rule endo_inj_surj; auto simp add: assms(2) assms(3) image_subsetI prime_gt_0_nat PQ_not_0 inj_on_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < P * Q; y < P * Q;\n        x ^ e mod (P * Q) = y ^ e mod (P * Q)\\<rbrakk>\n       \\<Longrightarrow> x = y", "using rsa_bijection assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q;\n   ?P \\<noteq> ?Q; ?x < ?P * ?Q; ?y < ?P * ?Q;\n   ?x ^ ?e mod (?P * ?Q) = ?y ^ ?e mod (?P * ?Q)\\<rbrakk>\n  \\<Longrightarrow> ?x = ?y\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x < P * Q; y < P * Q;\n        x ^ e mod (P * Q) = y ^ e mod (P * Q)\\<rbrakk>\n       \\<Longrightarrow> x = y", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n  {..<fst (P * Q, e)} =\n  {..<fst (P * Q, e)}\n\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "ultimately"], ["proof (chain)\npicking this:\n  inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n   {..<fst (P * Q, e)}\n  (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n  {..<fst (P * Q, e)} =\n  {..<fst (P * Q, e)}", "show ?thesis"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n   {..<fst (P * Q, e)}\n  (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n  {..<fst (P * Q, e)} =\n  {..<fst (P * Q, e)}\n\ngoal (1 subgoal):\n 1. bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n     (local.range (P * Q, e))", "unfolding bij_betw_def F_def range_def"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n   {..<fst (P * Q, e)}\n  (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n  {..<fst (P * Q, e)} =\n  {..<fst (P * Q, e)}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e))\n     {..<fst (P * Q, e)} \\<and>\n    (\\<lambda>x. x ^ snd (P * Q, e) mod fst (P * Q, e)) `\n    {..<fst (P * Q, e)} =\n    {..<fst (P * Q, e)}", "by blast"], ["proof (state)\nthis:\n  bij_betw (F (P * Q, e)) (local.range (P * Q, e)) (local.range (P * Q, e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw1:\n  assumes \"((N,e),d) \\<in> set_spmf I\" \n  shows \"bij_betw (F ((N), e)) (range ((N), e)) (range ((N), e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (F (N, e)) (local.range (N, e)) (local.range (N, e))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. bij_betw (F (N, e)) (local.range (N, e)) (local.range (N, e))", "obtain P Q where \"N = P * Q\" and \"bij_betw (F ((P*Q), e)) (range ((P*Q), e)) (range ((P*Q), e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q;\n         bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n          (local.range (P * Q, e))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q;\n         bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n          (local.range (P * Q, e))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain P Q where \"prime P\" and \"prime Q\" and \"N = P * Q\" and \"P \\<noteq> Q\" and \"coprime e ((P - 1)*(Q - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>prime P; prime Q; N = P * Q; P \\<noteq> Q;\n         coprime e ((P - 1) * (Q - 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using set_spmf_I_N assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>((?N, ?e), ?d) \\<in> set_spmf I;\n   \\<And>P Q.\n      \\<lbrakk>?N = P * Q; P \\<noteq> Q; prime P; prime Q;\n       coprime ?e ((P - 1) * (Q - 1));\n       ?d =\n       nat (fst (bezw ?e ((P - 1) * (Q - 1))) mod\n            int ((P - 1) * (Q - 1)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  ((N, e), d) \\<in> set_spmf I\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>prime P; prime Q; N = P * Q; P \\<noteq> Q;\n         coprime e ((P - 1) * (Q - 1))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  prime P\n  prime Q\n  N = P * Q\n  P \\<noteq> Q\n  coprime e ((P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q;\n         bij_betw (F (P * Q, e)) (local.range (P * Q, e))\n          (local.range (P * Q, e))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  prime P\n  prime Q\n  N = P * Q\n  P \\<noteq> Q\n  coprime e ((P - 1) * (Q - 1))", "show ?thesis"], ["proof (prove)\nusing this:\n  prime P\n  prime Q\n  N = P * Q\n  P \\<noteq> Q\n  coprime e ((P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. thesis", "using rsa_bij_betw that"], ["proof (prove)\nusing this:\n  prime P\n  prime Q\n  N = P * Q\n  P \\<noteq> Q\n  coprime e ((P - 1) * (Q - 1))\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q;\n   ?P \\<noteq> ?Q\\<rbrakk>\n  \\<Longrightarrow> bij_betw (F (?P * ?Q, ?e)) (local.range (?P * ?Q, ?e))\n                     (local.range (?P * ?Q, ?e))\n  \\<lbrakk>N = ?P * ?Q;\n   bij_betw (F (?P * ?Q, e)) (local.range (?P * ?Q, e))\n    (local.range (?P * ?Q, e))\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N = P * Q\n  bij_betw (F (P * Q, e)) (local.range (P * Q, e)) (local.range (P * Q, e))\n\ngoal (1 subgoal):\n 1. bij_betw (F (N, e)) (local.range (N, e)) (local.range (N, e))", "thus ?thesis"], ["proof (prove)\nusing this:\n  N = P * Q\n  bij_betw (F (P * Q, e)) (local.range (P * Q, e)) (local.range (P * Q, e))\n\ngoal (1 subgoal):\n 1. bij_betw (F (N, e)) (local.range (N, e)) (local.range (N, e))", "by blast"], ["proof (state)\nthis:\n  bij_betw (F (N, e)) (local.range (N, e)) (local.range (N, e))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \n  assumes \"P dvd x\"\nshows \"[x = 0] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x = 0::'a] (mod P)", "using assms cong_def"], ["proof (prove)\nusing this:\n  P dvd x\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [x = 0::'a] (mod P)", "by force"], ["", "lemma rsa_inv: \n  assumes d: \"d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))\"\n    and coprime: \"coprime e ((P-1)*(Q-1))\"\n    and prime_P: \"prime (P::nat)\" \n    and prime_Q: \"prime Q\"   \n    and P_neq_Q: \"P \\<noteq> Q\" \n    and e_gt_1: \"e > 1\"\n    and d_gt_1: \"d > 1\" \n  shows \"((((x) ^ e) mod (P*Q)) ^ d) mod (P*Q) = x mod (P*Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "proof(cases \"x = 0 \\<or> x = 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<or> x = 1 \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)\n 2. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "case True"], ["proof (state)\nthis:\n  x = 0 \\<or> x = 1\n\ngoal (2 subgoals):\n 1. x = 0 \\<or> x = 1 \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)\n 2. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "then"], ["proof (chain)\npicking this:\n  x = 0 \\<or> x = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  x = 0 \\<or> x = 1\n\ngoal (1 subgoal):\n 1. (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "by (metis assms(6) assms(7) le_simps(1) nat_power_eq_Suc_0_iff neq0_conv not_one_le_zero numeral_nat(7) power_eq_0_iff power_mod)"], ["proof (state)\nthis:\n  (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "case False"], ["proof (state)\nthis:\n  \\<not> (x = 0 \\<or> x = 1)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "hence x_gt_1: \"x > 1\""], ["proof (prove)\nusing this:\n  \\<not> (x = 0 \\<or> x = 1)\n\ngoal (1 subgoal):\n 1. 1 < x", "by simp"], ["proof (state)\nthis:\n  1 < x\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "define z where \"z = (x ^ e) ^ d - x\""], ["proof (state)\nthis:\n  z = (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "hence z_gt_0: \"z > 0\""], ["proof (prove)\nusing this:\n  z = (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. 0 < z", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. z = (x ^ e) ^ d - x \\<Longrightarrow> 0 < z", "have \"(x ^ e) ^ d - x = x ^ (e * d) - x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ e) ^ d - x = x ^ (e * d) - x", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  (x ^ e) ^ d - x = x ^ (e * d) - x\n\ngoal (1 subgoal):\n 1. z = (x ^ e) ^ d - x \\<Longrightarrow> 0 < z", "also"], ["proof (state)\nthis:\n  (x ^ e) ^ d - x = x ^ (e * d) - x\n\ngoal (1 subgoal):\n 1. z = (x ^ e) ^ d - x \\<Longrightarrow> 0 < z", "have \"... > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < x ^ (e * d) - x", "by (metis x_gt_1 e_gt_1 d_gt_1 le_neq_implies_less less_one linorder_not_less n_less_m_mult_n not_less_zero numeral_nat(7) power_increasing_iff power_one_right zero_less_diff)"], ["proof (state)\nthis:\n  0 < x ^ (e * d) - x\n\ngoal (1 subgoal):\n 1. z = (x ^ e) ^ d - x \\<Longrightarrow> 0 < z", "ultimately"], ["proof (chain)\npicking this:\n  (x ^ e) ^ d - x = x ^ (e * d) - x\n  0 < x ^ (e * d) - x", "show ?thesis"], ["proof (prove)\nusing this:\n  (x ^ e) ^ d - x = x ^ (e * d) - x\n  0 < x ^ (e * d) - x\n\ngoal (1 subgoal):\n 1. 0 < z", "using z_def"], ["proof (prove)\nusing this:\n  (x ^ e) ^ d - x = x ^ (e * d) - x\n  0 < x ^ (e * d) - x\n  z = (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. 0 < z", "by argo"], ["proof (state)\nthis:\n  0 < z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < z\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "hence \"[z = 0] (mod P)\""], ["proof (prove)\nusing this:\n  0 < z\n\ngoal (1 subgoal):\n 1. [z = 0] (mod P)", "proof(cases \"[x = 0] (mod P)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < z; [x = 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)\n 2. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "case True"], ["proof (state)\nthis:\n  [x = 0] (mod P)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>0 < z; [x = 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)\n 2. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "then"], ["proof (chain)\npicking this:\n  [x = 0] (mod P)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x = 0] (mod P)\n\ngoal (1 subgoal):\n 1. [z = 0] (mod P)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [x = 0] (mod P) \\<Longrightarrow> [z = 0] (mod P)", "have \"0 \\<noteq> d * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> d * e", "by (metis (no_types) assms assms mult_is_0 not_one_less_zero)"], ["proof (state)\nthis:\n  0 \\<noteq> d * e\n\ngoal (1 subgoal):\n 1. [x = 0] (mod P) \\<Longrightarrow> [z = 0] (mod P)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> d * e", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<noteq> d * e\n\ngoal (1 subgoal):\n 1. [z = 0] (mod P)", "by (metis (no_types) Groups.add_ac(2) True add_diff_inverse_nat cong_def cong_dvd_iff cong_mult_self_right dvd_0_right dvd_def dvd_trans mod_add_self2 more_arith_simps(5) nat_diff_split power_eq_if power_mult semiring_normalization_rules(7) z_def)"], ["proof (state)\nthis:\n  [z = 0] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [z = 0] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "case False"], ["proof (state)\nthis:\n  [x \\<noteq> 0] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "have \"[e * d = 1] (mod ((P - 1) * (Q - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [e * d = 1] (mod (P - 1) * (Q - 1))", "by (metis d bezw_inverse coprime coprime_imp_gcd_eq_1 nat_int)"], ["proof (state)\nthis:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "hence \"[e * d = 1] (mod (P - 1))\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. [e * d = 1] (mod P - 1)", "using assms cong_modulus_mult_nat"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n  [?x = ?y] (mod ?m * ?n) \\<Longrightarrow> [?x = ?y] (mod ?m)\n\ngoal (1 subgoal):\n 1. [e * d = 1] (mod P - 1)", "by blast"], ["proof (state)\nthis:\n  [e * d = 1] (mod P - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "then"], ["proof (chain)\npicking this:\n  [e * d = 1] (mod P - 1)", "obtain k where k: \"e*d = 1 + k*(P-1)\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_k_mod assms"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod P - 1)\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); ?P \\<noteq> ?Q; prime ?P;\n   prime ?Q; ?d \\<noteq> 0; [?e * ?d = 1] (mod ?P - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?e * ?d = 1 + k * (?P - 1)\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (P - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "hence \"x ^ (e * d) = x * ((x ^ (P - 1)) ^ k)\""], ["proof (prove)\nusing this:\n  e * d = 1 + k * (P - 1)\n\ngoal (1 subgoal):\n 1. x ^ (e * d) = x * (x ^ (P - 1)) ^ k", "by (metis power_add power_one_right mult.commute power_mult)"], ["proof (state)\nthis:\n  x ^ (e * d) = x * (x ^ (P - 1)) ^ k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "hence \"[x ^ (e * d) = x * ((x ^ (P - 1)) ^ k)] (mod P)\""], ["proof (prove)\nusing this:\n  x ^ (e * d) = x * (x ^ (P - 1)) ^ k\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * (x ^ (P - 1)) ^ k] (mod P)", "using cong_def"], ["proof (prove)\nusing this:\n  x ^ (e * d) = x * (x ^ (P - 1)) ^ k\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * (x ^ (P - 1)) ^ k] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * (x ^ (P - 1)) ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "moreover"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * (x ^ (P - 1)) ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "have \"[x ^ (P - 1) = 1] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (P - 1) = 1] (mod P)", "using prime_P fermat_theorem False"], ["proof (prove)\nusing this:\n  prime P\n  \\<lbrakk>prime ?p; \\<not> ?p dvd ?a\\<rbrakk>\n  \\<Longrightarrow> [?a ^ (?p - 1) = 1] (mod ?p)\n  [x \\<noteq> 0] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (P - 1) = 1] (mod P)", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  [x ^ (P - 1) = 1] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "moreover"], ["proof (state)\nthis:\n  [x ^ (P - 1) = 1] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "have \"[x ^ (e * d) = x * ((1) ^ k)] (mod P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * 1 ^ k] (mod P)", "by (metis \\<open>x ^ (e * d) = x * (x ^ (P - 1)) ^ k\\<close> calculation(2) cong_pow cong_scalar_left)"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * 1 ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "hence \"[x ^ (e * d) = x] (mod P)\""], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x * 1 ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (e * d) = x] (mod P)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < z; [x \\<noteq> 0] (mod P)\\<rbrakk>\n    \\<Longrightarrow> [z = 0] (mod P)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x] (mod P)\n\ngoal (1 subgoal):\n 1. [z = 0] (mod P)", "using z_def z_gt_0"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x] (mod P)\n  z = (x ^ e) ^ d - x\n  0 < z\n\ngoal (1 subgoal):\n 1. [z = 0] (mod P)", "by (simp add: cong_diff_iff_cong_0_nat power_mult)"], ["proof (state)\nthis:\n  [z = 0] (mod P)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [z = 0] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "moreover"], ["proof (state)\nthis:\n  [z = 0] (mod P)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "have \"[z = 0] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [z = 0] (mod Q)", "proof(cases \"[x = 0] (mod Q)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. [x = 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)\n 2. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "case True"], ["proof (state)\nthis:\n  [x = 0] (mod Q)\n\ngoal (2 subgoals):\n 1. [x = 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)\n 2. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [x = 0] (mod Q)", "show ?thesis"], ["proof (prove)\nusing this:\n  [x = 0] (mod Q)\n\ngoal (1 subgoal):\n 1. [z = 0] (mod Q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. [x = 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "have \"0 \\<noteq> d * e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<noteq> d * e", "by (metis (no_types) assms mult_is_0 not_one_less_zero)"], ["proof (state)\nthis:\n  0 \\<noteq> d * e\n\ngoal (1 subgoal):\n 1. [x = 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "then"], ["proof (chain)\npicking this:\n  0 \\<noteq> d * e", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<noteq> d * e\n\ngoal (1 subgoal):\n 1. [z = 0] (mod Q)", "by (metis (no_types) Groups.add_ac(2) True add_diff_inverse_nat cong_def cong_dvd_iff cong_mult_self_right dvd_0_right dvd_def dvd_trans mod_add_self2 more_arith_simps(5) nat_diff_split power_eq_if power_mult semiring_normalization_rules(7) z_def)"], ["proof (state)\nthis:\n  [z = 0] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [z = 0] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "case False"], ["proof (state)\nthis:\n  [x \\<noteq> 0] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "have \"[e * d = 1] (mod ((P - 1) * (Q - 1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [e * d = 1] (mod (P - 1) * (Q - 1))", "by (metis d bezw_inverse coprime coprime_imp_gcd_eq_1 nat_int)"], ["proof (state)\nthis:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "hence \"[e * d = 1] (mod (Q - 1))\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n\ngoal (1 subgoal):\n 1. [e * d = 1] (mod Q - 1)", "using assms cong_modulus_mult_nat mult.commute"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod (P - 1) * (Q - 1))\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n  [?x = ?y] (mod ?m * ?n) \\<Longrightarrow> [?x = ?y] (mod ?m)\n  ?a * ?b = ?b * ?a\n\ngoal (1 subgoal):\n 1. [e * d = 1] (mod Q - 1)", "by metis"], ["proof (state)\nthis:\n  [e * d = 1] (mod Q - 1)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "then"], ["proof (chain)\npicking this:\n  [e * d = 1] (mod Q - 1)", "obtain k where k: \"e*d = 1 + k*(Q-1)\""], ["proof (prove)\nusing this:\n  [e * d = 1] (mod Q - 1)\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (Q - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ex_k_mod assms"], ["proof (prove)\nusing this:\n  [e * d = 1] (mod Q - 1)\n  \\<lbrakk>coprime ?e ((?P - 1) * (?Q - 1)); ?P \\<noteq> ?Q; prime ?P;\n   prime ?Q; ?d \\<noteq> 0; [?e * ?d = 1] (mod ?P - 1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>k. ?e * ?d = 1 + k * (?P - 1)\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n\ngoal (1 subgoal):\n 1. (\\<And>k.\n        e * d = 1 + k * (Q - 1) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  e * d = 1 + k * (Q - 1)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "hence \"x ^ (e * d) = x * ((x ^ (Q - 1)) ^ k)\""], ["proof (prove)\nusing this:\n  e * d = 1 + k * (Q - 1)\n\ngoal (1 subgoal):\n 1. x ^ (e * d) = x * (x ^ (Q - 1)) ^ k", "by (metis power_add power_one_right mult.commute power_mult)"], ["proof (state)\nthis:\n  x ^ (e * d) = x * (x ^ (Q - 1)) ^ k\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "hence \"[x ^ (e * d) = x * ((x ^ (Q - 1)) ^ k)] (mod P)\""], ["proof (prove)\nusing this:\n  x ^ (e * d) = x * (x ^ (Q - 1)) ^ k\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * (x ^ (Q - 1)) ^ k] (mod P)", "using cong_def"], ["proof (prove)\nusing this:\n  x ^ (e * d) = x * (x ^ (Q - 1)) ^ k\n  [?b = ?c] (mod ?a) = (?b mod ?a = ?c mod ?a)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * (x ^ (Q - 1)) ^ k] (mod P)", "by simp"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * (x ^ (Q - 1)) ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "moreover"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * (x ^ (Q - 1)) ^ k] (mod P)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "have \"[x ^ (Q - 1) = 1] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (Q - 1) = 1] (mod Q)", "using prime_Q fermat_theorem False"], ["proof (prove)\nusing this:\n  prime Q\n  \\<lbrakk>prime ?p; \\<not> ?p dvd ?a\\<rbrakk>\n  \\<Longrightarrow> [?a ^ (?p - 1) = 1] (mod ?p)\n  [x \\<noteq> 0] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (Q - 1) = 1] (mod Q)", "by (simp add: cong_0_iff)"], ["proof (state)\nthis:\n  [x ^ (Q - 1) = 1] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "moreover"], ["proof (state)\nthis:\n  [x ^ (Q - 1) = 1] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "have \"[x ^ (e * d) = x * ((1) ^ k)] (mod Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x * 1 ^ k] (mod Q)", "by (metis \\<open>x ^ (e * d) = x * (x ^ (Q - 1)) ^ k\\<close> calculation(2) cong_pow cong_scalar_left)"], ["proof (state)\nthis:\n  [x ^ (e * d) = x * 1 ^ k] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "hence \"[x ^ (e * d) = x] (mod Q)\""], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x * 1 ^ k] (mod Q)\n\ngoal (1 subgoal):\n 1. [x ^ (e * d) = x] (mod Q)", "by simp"], ["proof (state)\nthis:\n  [x ^ (e * d) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [x \\<noteq> 0] (mod Q) \\<Longrightarrow> [z = 0] (mod Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x] (mod Q)\n\ngoal (1 subgoal):\n 1. [z = 0] (mod Q)", "using z_def z_gt_0"], ["proof (prove)\nusing this:\n  [x ^ (e * d) = x] (mod Q)\n  z = (x ^ e) ^ d - x\n  0 < z\n\ngoal (1 subgoal):\n 1. [z = 0] (mod Q)", "by (simp add: cong_diff_iff_cong_0_nat power_mult)"], ["proof (state)\nthis:\n  [z = 0] (mod Q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  [z = 0] (mod Q)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "ultimately"], ["proof (chain)\npicking this:\n  [z = 0] (mod P)\n  [z = 0] (mod Q)", "have \"Q dvd (x ^ e) ^ d - x\"\n                  \"P dvd (x ^ e) ^ d - x\""], ["proof (prove)\nusing this:\n  [z = 0] (mod P)\n  [z = 0] (mod Q)\n\ngoal (1 subgoal):\n 1. Q dvd (x ^ e) ^ d - x &&& P dvd (x ^ e) ^ d - x", "using z_def assms cong_0_iff"], ["proof (prove)\nusing this:\n  [z = 0] (mod P)\n  [z = 0] (mod Q)\n  z = (x ^ e) ^ d - x\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n  [?b = 0::?'a] (mod ?a) = (?a dvd ?b)\n\ngoal (1 subgoal):\n 1. Q dvd (x ^ e) ^ d - x &&& P dvd (x ^ e) ^ d - x", "by blast +"], ["proof (state)\nthis:\n  Q dvd (x ^ e) ^ d - x\n  P dvd (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "hence \"P * Q dvd ((x ^ e) ^ d - x)\""], ["proof (prove)\nusing this:\n  Q dvd (x ^ e) ^ d - x\n  P dvd (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. P * Q dvd (x ^ e) ^ d - x", "using assms divides_mult primes_coprime_nat"], ["proof (prove)\nusing this:\n  Q dvd (x ^ e) ^ d - x\n  P dvd (x ^ e) ^ d - x\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  coprime e ((P - 1) * (Q - 1))\n  prime P\n  prime Q\n  P \\<noteq> Q\n  1 < e\n  1 < d\n  \\<lbrakk>?a dvd ?c; ?b dvd ?c; coprime ?a ?b\\<rbrakk>\n  \\<Longrightarrow> ?a * ?b dvd ?c\n  \\<lbrakk>prime ?p; prime ?q; ?p \\<noteq> ?q\\<rbrakk>\n  \\<Longrightarrow> coprime ?p ?q\n\ngoal (1 subgoal):\n 1. P * Q dvd (x ^ e) ^ d - x", "by blast"], ["proof (state)\nthis:\n  P * Q dvd (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "hence \"[(x ^ e) ^ d = x] (mod (P * Q))\""], ["proof (prove)\nusing this:\n  P * Q dvd (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d = x] (mod P * Q)", "using z_gt_0 cong_altdef_nat z_def"], ["proof (prove)\nusing this:\n  P * Q dvd (x ^ e) ^ d - x\n  0 < z\n  ?b \\<le> ?a \\<Longrightarrow> [?a = ?b] (mod ?m) = (?m dvd ?a - ?b)\n  z = (x ^ e) ^ d - x\n\ngoal (1 subgoal):\n 1. [(x ^ e) ^ d = x] (mod P * Q)", "by auto"], ["proof (state)\nthis:\n  [(x ^ e) ^ d = x] (mod P * Q)\n\ngoal (1 subgoal):\n 1. \\<not> (x = 0 \\<or> x = 1) \\<Longrightarrow>\n    (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  [(x ^ e) ^ d = x] (mod P * Q)\n\ngoal (1 subgoal):\n 1. (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)", "by (simp add: cong_def power_mod)"], ["proof (state)\nthis:\n  (x ^ e mod (P * Q)) ^ d mod (P * Q) = x mod (P * Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rsa_inv_set_spmf_I:\n  assumes \"((N, e), d) \\<in> set_spmf I\"\n  shows \"((((x::nat) ^ e) mod N) ^ d) mod N = x mod N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "obtain P Q where \"N = P * Q\" and \"d = nat (fst (bezw e ((P-1)*(Q-1))) mod int ((P-1)*(Q-1)))\"  \n    and \"prime P\" \n    and \"prime Q\" \n    and \"coprime e ((P - 1)*(Q - 1))\" \n    and \"P \\<noteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q;\n         d =\n         nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)));\n         prime P; prime Q; coprime e ((P - 1) * (Q - 1));\n         P \\<noteq> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms set_spmf_I_N"], ["proof (prove)\nusing this:\n  ((N, e), d) \\<in> set_spmf I\n  \\<lbrakk>((?N, ?e), ?d) \\<in> set_spmf I;\n   \\<And>P Q.\n      \\<lbrakk>?N = P * Q; P \\<noteq> Q; prime P; prime Q;\n       coprime ?e ((P - 1) * (Q - 1));\n       ?d =\n       nat (fst (bezw ?e ((P - 1) * (Q - 1))) mod\n            int ((P - 1) * (Q - 1)))\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>P Q.\n        \\<lbrakk>N = P * Q;\n         d =\n         nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)));\n         prime P; prime Q; coprime e ((P - 1) * (Q - 1));\n         P \\<noteq> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  N = P * Q\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  prime P\n  prime Q\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "moreover"], ["proof (state)\nthis:\n  N = P * Q\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  prime P\n  prime Q\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "have \"e > 1\" and \"d > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < e &&& 1 < d", "using set_spmf_I_e_d assms"], ["proof (prove)\nusing this:\n  ((?N, ?e), ?d) \\<in> set_spmf I \\<Longrightarrow> 1 < ?e\n  ((?N, ?e), ?d) \\<in> set_spmf I \\<Longrightarrow> 1 < ?d\n  ((N, e), d) \\<in> set_spmf I\n\ngoal (1 subgoal):\n 1. 1 < e &&& 1 < d", "by auto"], ["proof (state)\nthis:\n  1 < e\n  1 < d\n\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "ultimately"], ["proof (chain)\npicking this:\n  N = P * Q\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  prime P\n  prime Q\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n  1 < e\n  1 < d", "show ?thesis"], ["proof (prove)\nusing this:\n  N = P * Q\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  prime P\n  prime Q\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n  1 < e\n  1 < d\n\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "using rsa_inv"], ["proof (prove)\nusing this:\n  N = P * Q\n  d = nat (fst (bezw e ((P - 1) * (Q - 1))) mod int ((P - 1) * (Q - 1)))\n  prime P\n  prime Q\n  coprime e ((P - 1) * (Q - 1))\n  P \\<noteq> Q\n  1 < e\n  1 < d\n  \\<lbrakk>?d =\n           nat (fst (bezw ?e ((?P - 1) * (?Q - 1))) mod\n                int ((?P - 1) * (?Q - 1)));\n   coprime ?e ((?P - 1) * (?Q - 1)); prime ?P; prime ?Q; ?P \\<noteq> ?Q;\n   1 < ?e; 1 < ?d\\<rbrakk>\n  \\<Longrightarrow> (?x ^ ?e mod (?P * ?Q)) ^ ?d mod (?P * ?Q) =\n                    ?x mod (?P * ?Q)\n\ngoal (1 subgoal):\n 1. (x ^ e mod N) ^ d mod N = x mod N", "by blast"], ["proof (state)\nthis:\n  (x ^ e mod N) ^ d mod N = x mod N\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale etp_rsa: etp I domain range F F\\<^sub>i\\<^sub>n\\<^sub>v"], ["proof (prove)\ngoal (1 subgoal):\n 1. etp I local.domain local.range F F\\<^sub>i\\<^sub>n\\<^sub>v", "unfolding etp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<forall>y.\n         y \\<in> set_spmf I \\<longrightarrow>\n         local.domain (fst y) = local.range (fst y)) \\<and>\n     (\\<forall>y.\n         y \\<in> set_spmf I \\<longrightarrow>\n         finite (local.range (fst y))) \\<and>\n     (\\<forall>y.\n         y \\<in> set_spmf I \\<longrightarrow>\n         local.range (fst y) \\<noteq> {})) \\<and>\n    (\\<forall>y.\n        y \\<in> set_spmf I \\<longrightarrow>\n        bij_betw (F (fst y)) (local.domain (fst y))\n         (local.range (fst y))) \\<and>\n    lossless_spmf I \\<and>\n    (\\<forall>y x.\n        y \\<in> set_spmf I \\<longrightarrow>\n        x \\<in> local.range (fst y) \\<longrightarrow>\n        F\\<^sub>i\\<^sub>n\\<^sub>v (fst y) (snd y) (F (fst y) x) = x)", "apply(auto simp add: etp_def dom_eq_ran finite_range bij_betw1 lossless_I)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba.\n       \\<lbrakk>((a, b), ba) \\<in> set_spmf I;\n        local.range (a, b) = {}\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a b ba x.\n       \\<lbrakk>((a, b), ba) \\<in> set_spmf I;\n        x \\<in> local.range (a, b)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>i\\<^sub>n\\<^sub>v (a, b) ba (F (a, b) x) =\n                         x", "apply (metis fst_conv lessThan_iff mem_simps(2) nat_0_less_mult_iff prime_gt_0_nat range_def set_spmf_I_N)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba x.\n       \\<lbrakk>((a, b), ba) \\<in> set_spmf I;\n        x \\<in> local.range (a, b)\\<rbrakk>\n       \\<Longrightarrow> F\\<^sub>i\\<^sub>n\\<^sub>v (a, b) ba (F (a, b) x) =\n                         x", "apply(auto simp add: F_def F\\<^sub>i\\<^sub>n\\<^sub>v_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba x.\n       \\<lbrakk>((a, b), ba) \\<in> set_spmf I;\n        x \\<in> local.range (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x ^ b mod a) ^ ba mod a = x", "using rsa_inv_set_spmf_I"], ["proof (prove)\nusing this:\n  ((?N, ?e), ?d) \\<in> set_spmf I \\<Longrightarrow>\n  (?x ^ ?e mod ?N) ^ ?d mod ?N = ?x mod ?N\n\ngoal (1 subgoal):\n 1. \\<And>a b ba x.\n       \\<lbrakk>((a, b), ba) \\<in> set_spmf I;\n        x \\<in> local.range (a, b)\\<rbrakk>\n       \\<Longrightarrow> (x ^ b mod a) ^ ba mod a = x", "by (simp add: range_def)"], ["", "sublocale etp: ETP_base I domain range B F F\\<^sub>i\\<^sub>n\\<^sub>v"], ["proof (prove)\ngoal (1 subgoal):\n 1. ETP_base I local.domain local.range F F\\<^sub>i\\<^sub>n\\<^sub>v", "unfolding ETP_base_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. etp I local.domain local.range F F\\<^sub>i\\<^sub>n\\<^sub>v", "by (simp add: etp_rsa.etp_axioms)"], ["", "text\\<open>After proving the RSA collection is an ETP the proofs of security come easily from the general proofs.\\<close>"], ["", "lemma correctness_rsa: \"etp.OT_12.correctness m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.correctness m1 m2", "by (rule local.etp.correct)"], ["", "lemma P1_security_rsa: \"etp.OT_12.perfect_sec_P1 m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.perfect_sec_P1 m1 m2", "by(rule local.etp.P1_security_inf_the)"], ["", "lemma P2_security_rsa:\n  assumes \"\\<forall> a. lossless_spmf (D a)\"\n    and \"\\<And>b\\<^sub>\\<sigma>. local.etp_rsa.HCP_adv etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> HCP_ad\"\n  shows \"etp.OT_12.adv_P2 m1 m2 D \\<le> 2 * HCP_ad\""], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.adv_P2 m1 m2 D \\<le> 2 * HCP_ad", "by(simp add: local.etp.P2_security assms)"], ["", "end"], ["", "locale rsa_asym =\n  fixes prime_set :: \"nat \\<Rightarrow> nat set\"\n    and B :: \"index \\<Rightarrow> nat \\<Rightarrow> bool\"\n  assumes rsa_proof_assm: \"\\<And> n. rsa_base (prime_set n)\"\nbegin"], ["", "sublocale rsa_base \"(prime_set n)\" B"], ["proof (prove)\ngoal (1 subgoal):\n 1. rsa_base (prime_set n)", "using local.rsa_proof_assm"], ["proof (prove)\nusing this:\n  rsa_base (prime_set ?n)\n\ngoal (1 subgoal):\n 1. rsa_base (prime_set n)", "by simp"], ["", "lemma correctness_rsa_asymp: \n  shows \"etp.OT_12.correctness n m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.correctness n m1 m2", "by(rule correctness_rsa)"], ["", "lemma P1_sec_asymp: \"etp.OT_12.perfect_sec_P1 n m1 m2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.perfect_sec_P1 n m1 m2", "by(rule local.P1_security_rsa)"], ["", "lemma P2_sec_asym: \n  assumes \"\\<forall> a. lossless_spmf (D a)\" \n    and HCP_adv_neg: \"negligible (\\<lambda> n. hcp_advantage n)\"\n    and hcp_adv_bound:  \"\\<forall>b\\<^sub>\\<sigma> n. local.etp_rsa.HCP_adv n etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> hcp_advantage n\"\n  shows \"negligible (\\<lambda> n. etp.OT_12.adv_P2 n m1 m2 D)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "have \"negligible (\\<lambda> n. 2 * hcp_advantage n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)", "using HCP_adv_neg"], ["proof (prove)\nusing this:\n  Negligible.negligible hcp_advantage\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)", "by (simp add: negligible_cmultI)"], ["proof (state)\nthis:\n  Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "moreover"], ["proof (state)\nthis:\n  Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "have \"\\<bar>etp.OT_12.adv_P2 n m1 m2 D\\<bar> = etp.OT_12.adv_P2 n m1 m2 D\" \n    for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>etp.OT_12.adv_P2 n m1 m2 D\\<bar> = etp.OT_12.adv_P2 n m1 m2 D", "unfolding sim_det_def.adv_P2_def local.etp.OT_12.adv_P2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<bar>spmf (etp.R2 n m1 m2 \\<bind> D) True -\n                spmf\n                 (funct_OT_12 m1 m2 \\<bind>\n                  (\\<lambda>(o1, o2). etp.S2 n m2 o2 \\<bind> D))\n                 True\\<bar>\\<bar> =\n    \\<bar>spmf (etp.R2 n m1 m2 \\<bind> D) True -\n          spmf\n           (funct_OT_12 m1 m2 \\<bind>\n            (\\<lambda>(o1, o2). etp.S2 n m2 o2 \\<bind> D))\n           True\\<bar>", "by linarith"], ["proof (state)\nthis:\n  \\<bar>etp.OT_12.adv_P2 ?n m1 m2 D\\<bar> = etp.OT_12.adv_P2 ?n m1 m2 D\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "moreover"], ["proof (state)\nthis:\n  \\<bar>etp.OT_12.adv_P2 ?n m1 m2 D\\<bar> = etp.OT_12.adv_P2 ?n m1 m2 D\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "have \"etp.OT_12.adv_P2 n m1 m2 D \\<le> 2 * hcp_advantage n\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. etp.OT_12.adv_P2 n m1 m2 D \\<le> 2 * hcp_advantage n", "using P2_security_rsa assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>a. lossless_spmf (?D a);\n   \\<And>b\\<^sub>\\<sigma>.\n      etp_rsa.HCP_adv ?n etp.\\<A> ?m2.0 b\\<^sub>\\<sigma> ?D\n      \\<le> ?HCP_ad\\<rbrakk>\n  \\<Longrightarrow> etp.OT_12.adv_P2 ?n ?m1.0 ?m2.0 ?D \\<le> 2 * ?HCP_ad\n  \\<forall>a. lossless_spmf (D a)\n  Negligible.negligible hcp_advantage\n  \\<forall>b\\<^sub>\\<sigma> n.\n     etp_rsa.HCP_adv n etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> hcp_advantage n\n\ngoal (1 subgoal):\n 1. etp.OT_12.adv_P2 n m1 m2 D \\<le> 2 * hcp_advantage n", "by blast"], ["proof (state)\nthis:\n  etp.OT_12.adv_P2 ?n m1 m2 D \\<le> 2 * hcp_advantage ?n\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "ultimately"], ["proof (chain)\npicking this:\n  Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)\n  \\<bar>etp.OT_12.adv_P2 ?n m1 m2 D\\<bar> = etp.OT_12.adv_P2 ?n m1 m2 D\n  etp.OT_12.adv_P2 ?n m1 m2 D \\<le> 2 * hcp_advantage ?n", "show ?thesis"], ["proof (prove)\nusing this:\n  Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)\n  \\<bar>etp.OT_12.adv_P2 ?n m1 m2 D\\<bar> = etp.OT_12.adv_P2 ?n m1 m2 D\n  etp.OT_12.adv_P2 ?n m1 m2 D \\<le> 2 * hcp_advantage ?n\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "using assms negligible_le"], ["proof (prove)\nusing this:\n  Negligible.negligible (\\<lambda>n. 2 * hcp_advantage n)\n  \\<bar>etp.OT_12.adv_P2 ?n m1 m2 D\\<bar> = etp.OT_12.adv_P2 ?n m1 m2 D\n  etp.OT_12.adv_P2 ?n m1 m2 D \\<le> 2 * hcp_advantage ?n\n  \\<forall>a. lossless_spmf (D a)\n  Negligible.negligible hcp_advantage\n  \\<forall>b\\<^sub>\\<sigma> n.\n     etp_rsa.HCP_adv n etp.\\<A> m2 b\\<^sub>\\<sigma> D \\<le> hcp_advantage n\n  \\<lbrakk>Negligible.negligible ?g;\n   \\<And>\\<eta>. \\<bar>?f \\<eta>\\<bar> \\<le> ?g \\<eta>\\<rbrakk>\n  \\<Longrightarrow> Negligible.negligible ?f\n\ngoal (1 subgoal):\n 1. Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)", "by presburger"], ["proof (state)\nthis:\n  Negligible.negligible (\\<lambda>n. etp.OT_12.adv_P2 n m1 m2 D)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}