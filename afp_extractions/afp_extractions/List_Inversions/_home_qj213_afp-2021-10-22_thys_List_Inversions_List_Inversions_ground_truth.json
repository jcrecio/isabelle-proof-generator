{"file_name": "/home/qj213/afp-2021-10-22/thys/List_Inversions/List_Inversions.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/List_Inversions", "problem_names": ["lemma inversions_subset: \"inversions xs \\<subseteq> Sigma {..<length xs} (\\<lambda>i. {i<..<length xs})\"", "lemma finite_inversions [intro]: \"finite (inversions xs)\"", "lemma inversions_altdef: \"inversions xs = {(i, j). i < j \\<and> j < length xs \\<and> less (xs ! j) (xs ! i)}\"", "lemma inversions_code:\n  \"inversions xs =\n     Sigma {..<length xs} (\\<lambda>i. Set.filter (\\<lambda>j. less (xs ! j) (xs ! i)) {i<..<length xs})\"", "lemmas (in -) [code] = inversions_code", "lemma inversions_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> inversions xs = {}\"", "lemma inversions_imp_less:\n  \"z \\<in> inversions xs \\<Longrightarrow> fst z < snd z\"\n  \"z \\<in> inversions xs \\<Longrightarrow> snd z < length xs\"", "lemma inversions_Nil [simp]: \"inversions [] = {}\"", "lemma inversions_Cons:\n  \"inversions (x # xs) =\n     (\\<lambda>j. (0, j + 1)) ` {j\\<in>{..<length xs}. less (xs ! j) x} \\<union>\n     map_prod Suc Suc ` inversions xs\" (is \"_ = ?rhs\")", "lemma finite_inversions_between [intro]: \"finite (inversions_between xs ys)\"", "lemma inversions_between_Nil [simp]:\n  \"inversions_between [] ys = {}\"\n  \"inversions_between xs [] = {}\"", "lemma inversions_between_code:\n  \"inversions_between xs ys =\n     Set.filter (\\<lambda>(i,j). less (ys ! j) (xs ! i)) ({..<length xs}\\<times>{..<length ys})\"", "lemmas (in -) [code] = inversions_between_code", "lemma inversion_number_Nil [simp]: \"inversion_number [] = 0\"", "lemma inversion_number_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> inversion_number xs = 0\"", "lemma inversion_number_between_Nil [simp]:\n  \"inversion_number_between [] ys = 0\"\n  \"inversion_number_between xs [] = 0\"", "lemma inversions_between_permute1:\n  assumes \"\\<pi> permutes {..<length xs}\"\n  shows   \"inversions_between (permute_list \\<pi> xs) ys =\n             map_prod (inv \\<pi>) id ` inversions_between xs ys\"", "lemma inversions_between_permute2:\n  assumes \"\\<pi> permutes {..<length ys}\"\n  shows   \"inversions_between xs (permute_list \\<pi> ys) =\n             map_prod id (inv \\<pi>) ` inversions_between xs ys\"", "lemma inversions_between_Cons_Cons:\n  assumes \"sorted_wrt less_eq (x # xs)\" and \"sorted_wrt less_eq (y # ys)\"\n  shows   \"inversions_between (x # xs) (y # ys) =\n             (if \\<not>less y x then\n                map_prod Suc id ` inversions_between xs (y # ys)\n              else\n                {..<length (x#xs)} \\<times> {0} \\<union>\n                map_prod id Suc ` inversions_between (x # xs) ys)\"", "lemma inversion_number_between_Cons_Cons:\n  assumes \"sorted_wrt less_eq (x # xs)\" and \"sorted_wrt less_eq (y # ys)\"\n  shows   \"inversion_number_between (x # xs) (y # ys) =\n             (if \\<not>less y x then\n                inversion_number_between xs (y # ys)\n              else\n                inversion_number_between (x # xs) ys + length (x # xs))\"", "theorem inversion_number_between_sorted_correct:\n  \"sorted_wrt less_eq xs \\<Longrightarrow> sorted_wrt less_eq ys \\<Longrightarrow>\n     inversion_number_between_sorted xs ys = inversion_number_between xs ys\"", "lemma set_merge_lists [simp]: \"set (merge_lists xs ys) = set xs \\<union> set ys\"", "lemma mset_merge_lists [simp]: \"mset (merge_lists xs ys) = mset xs + mset ys\"", "lemma sorted_merge_lists [simp, intro]:\n  \"sorted xs \\<Longrightarrow> sorted ys \\<Longrightarrow> sorted (merge_lists xs ys)\"", "lemmas [simp del] = merge_sort.simps", "lemma merge_sort_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> merge_sort xs = xs\"", "theorem mset_merge_sort [simp]: \"mset (merge_sort xs) = mset xs\"", "theorem sorted_merge_sort [simp, intro]: \"sorted (merge_sort xs)\"", "lemma inversion_number_between_code:\n  \"inversion_number_between xs ys = inversion_number_between_sorted (sort xs) (sort ys)\"", "lemmas (in -) [code_unfold] = inversion_number_between_code", "lemmas [simp del] = sort_and_count_inversions.simps", "theorem fst_sort_and_count_inversions [simp]:\n  \"fst (sort_and_count_inversions xs) = merge_sort xs\"", "theorem snd_sort_and_count_inversions [simp]:\n  \"snd (sort_and_count_inversions xs) = inversion_number xs\"", "lemmas (in -) [code_unfold] = snd_sort_and_count_inversions [symmetric]"], "translations": [["", "lemma inversions_subset: \"inversions xs \\<subseteq> Sigma {..<length xs} (\\<lambda>i. {i<..<length xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions xs \\<subseteq> (SIGMA i:{..<length xs}. {i<..<length xs})", "by (auto simp: inversions.simps)"], ["", "lemma finite_inversions [intro]: \"finite (inversions xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (inversions xs)", "by (rule finite_subset[OF inversions_subset]) auto"], ["", "lemma inversions_altdef: \"inversions xs = {(i, j). i < j \\<and> j < length xs \\<and> less (xs ! j) (xs ! i)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions xs =\n    {(i, j). i < j \\<and> j < length xs \\<and> xs ! j < xs ! i}", "by (auto simp: inversions.simps)"], ["", "lemma inversions_code:\n  \"inversions xs =\n     Sigma {..<length xs} (\\<lambda>i. Set.filter (\\<lambda>j. less (xs ! j) (xs ! i)) {i<..<length xs})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions xs =\n    (SIGMA i:{..<length xs}.\n        Set.filter (\\<lambda>j. xs ! j < xs ! i) {i<..<length xs})", "by (auto simp: inversions_altdef)"], ["", "lemmas (in -) [code] = inversions_code"], ["", "lemma inversions_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> inversions xs = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> Suc 0 \\<Longrightarrow> inversions xs = {}", "by (auto simp: inversions_altdef)"], ["", "lemma inversions_imp_less:\n  \"z \\<in> inversions xs \\<Longrightarrow> fst z < snd z\"\n  \"z \\<in> inversions xs \\<Longrightarrow> snd z < length xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> inversions xs \\<Longrightarrow> fst z < snd z) &&&\n    (z \\<in> inversions xs \\<Longrightarrow> snd z < length xs)", "by (auto simp: inversions_altdef)"], ["", "lemma inversions_Nil [simp]: \"inversions [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions [] = {}", "by (auto simp: inversions_altdef)"], ["", "lemma inversions_Cons:\n  \"inversions (x # xs) =\n     (\\<lambda>j. (0, j + 1)) ` {j\\<in>{..<length xs}. less (xs ! j) x} \\<union>\n     map_prod Suc Suc ` inversions xs\" (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions (x # xs) =\n    (\\<lambda>j. (0, j + 1)) ` {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n    map_prod Suc Suc ` inversions xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversions (x # xs) =\n    (\\<lambda>j. (0, j + 1)) ` {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n    map_prod Suc Suc ` inversions xs", "have \"z \\<in> inversions (x # xs) \\<longleftrightarrow> z \\<in> ?rhs\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> inversions (x # xs)) =\n    (z \\<in> (\\<lambda>j. (0, j + 1)) `\n             {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n             map_prod Suc Suc ` inversions xs)", "by (cases z) (auto simp: inversions_altdef map_prod_def nth_Cons split: nat.splits)"], ["proof (state)\nthis:\n  (?z \\<in> inversions (x # xs)) =\n  (?z \\<in> (\\<lambda>j. (0, j + 1)) `\n            {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n            map_prod Suc Suc ` inversions xs)\n\ngoal (1 subgoal):\n 1. inversions (x # xs) =\n    (\\<lambda>j. (0, j + 1)) ` {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n    map_prod Suc Suc ` inversions xs", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?z \\<in> inversions (x # xs)) =\n  (?z \\<in> (\\<lambda>j. (0, j + 1)) `\n            {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n            map_prod Suc Suc ` inversions xs)\n\ngoal (1 subgoal):\n 1. inversions (x # xs) =\n    (\\<lambda>j. (0, j + 1)) ` {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n    map_prod Suc Suc ` inversions xs", "by blast"], ["proof (state)\nthis:\n  inversions (x # xs) =\n  (\\<lambda>j. (0, j + 1)) ` {j \\<in> {..<length xs}. xs ! j < x} \\<union>\n  map_prod Suc Suc ` inversions xs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following function returns the inversions between two lists, i.\\,e.\\ all pairs of\n  an element in the first list with an element in the second list such that the former\n  is greater than the latter.\n\\<close>"], ["", "definition inversions_between :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> (nat \\<times> nat) set\" where\n  \"inversions_between xs ys =\n     {(i, j) \\<in> {..<length xs}\\<times>{..<length ys}. less (ys ! j) (xs ! i)}\""], ["", "lemma finite_inversions_between [intro]: \"finite (inversions_between xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (inversions_between xs ys)", "by (rule finite_subset[of _ \"{..<length xs} \\<times> {..<length xs + length ys}\"])\n       (auto simp: inversions_between_def)"], ["", "lemma inversions_between_Nil [simp]:\n  \"inversions_between [] ys = {}\"\n  \"inversions_between xs [] = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between [] ys = {} &&& inversions_between xs [] = {}", "by (simp_all add: inversions_between_def)"], ["", "text \\<open>\n  We can now show the following equality for the inversions of the concatenation of two lists:\n\\<close>"], ["", "proposition inversions_append:\n  fixes xs ys\n  defines \"m \\<equiv> length xs\" and \"n \\<equiv> length ys\"\n  shows \"inversions (xs @ ys) =\n           inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n           map_prod id ((+) m) ` inversions_between xs ys\"\n        (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions (xs @ ys) =\n    inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversions (xs @ ys) =\n    inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys", "note defs = inversions_altdef inversions_between_def m_def n_def map_prod_def"], ["proof (state)\nthis:\n  inversions ?xs =\n  {(i, j). i < j \\<and> j < length ?xs \\<and> ?xs ! j < ?xs ! i}\n  inversions_between ?xs ?ys =\n  {(i, j).\n   (i, j) \\<in> {..<length ?xs} \\<times> {..<length ?ys} \\<and>\n   ?ys ! j < ?xs ! i}\n  m \\<equiv> length xs\n  n \\<equiv> length ys\n  map_prod ?f ?g = (\\<lambda>(x, y). (?f x, ?g y))\n\ngoal (1 subgoal):\n 1. inversions (xs @ ys) =\n    inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys", "have \"z \\<in> inversions (xs @ ys) \\<longleftrightarrow> z \\<in> ?rhs\" for z"], ["proof (prove)\ngoal (1 subgoal):\n 1. (z \\<in> inversions (xs @ ys)) =\n    (z \\<in> inversions xs \\<union>\n             map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n             map_prod id ((+) m) ` inversions_between xs ys)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. z \\<in> inversions (xs @ ys) \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys \\<Longrightarrow>\n    z \\<in> inversions (xs @ ys)", "assume \"z \\<in> inversions (xs @ ys)\""], ["proof (state)\nthis:\n  z \\<in> inversions (xs @ ys)\n\ngoal (2 subgoals):\n 1. z \\<in> inversions (xs @ ys) \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys \\<Longrightarrow>\n    z \\<in> inversions (xs @ ys)", "then"], ["proof (chain)\npicking this:\n  z \\<in> inversions (xs @ ys)", "obtain i j where [simp]: \"z = (i, j)\"\n                      and ij: \"i < j\" \"j < m + n\" \"less ((xs @ ys) ! j) ((xs @ ys) ! i)\""], ["proof (prove)\nusing this:\n  z \\<in> inversions (xs @ ys)\n\ngoal (1 subgoal):\n 1. (\\<And>i j.\n        \\<lbrakk>z = (i, j); i < j; j < m + n;\n         (xs @ ys) ! j < (xs @ ys) ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases z) (auto simp: inversions_altdef m_def n_def)"], ["proof (state)\nthis:\n  z = (i, j)\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i\n\ngoal (2 subgoals):\n 1. z \\<in> inversions (xs @ ys) \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys \\<Longrightarrow>\n    z \\<in> inversions (xs @ ys)", "from ij"], ["proof (chain)\npicking this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i", "consider \"j < m\" | \"i \\<ge> m\" | \"i < m\" \"j \\<ge> m\""], ["proof (prove)\nusing this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < m \\<Longrightarrow> thesis;\n     m \\<le> i \\<Longrightarrow> thesis;\n     \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by linarith"], ["proof (state)\nthis:\n  \\<lbrakk>j < m \\<Longrightarrow> ?thesis;\n   m \\<le> i \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (2 subgoals):\n 1. z \\<in> inversions (xs @ ys) \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys \\<Longrightarrow>\n    z \\<in> inversions (xs @ ys)", "thus \"z \\<in> ?rhs\""], ["proof (prove)\nusing this:\n  \\<lbrakk>j < m \\<Longrightarrow> ?thesis;\n   m \\<le> i \\<Longrightarrow> ?thesis;\n   \\<lbrakk>i < m; m \\<le> j\\<rbrakk> \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "proof cases"], ["proof (state)\ngoal (3 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 3. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> z \\<in> inversions xs \\<union>\n                              map_prod ((+) m) ((+) m) `\n                              inversions ys \\<union>\n                              map_prod id ((+) m) ` inversions_between xs ys", "assume \"i < m\" \"j \\<ge> m\""], ["proof (state)\nthis:\n  i < m\n  m \\<le> j\n\ngoal (3 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 3. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> z \\<in> inversions xs \\<union>\n                              map_prod ((+) m) ((+) m) `\n                              inversions ys \\<union>\n                              map_prod id ((+) m) ` inversions_between xs ys", "define j' where \"j' = j - m\""], ["proof (state)\nthis:\n  j' = j - m\n\ngoal (3 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 3. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> z \\<in> inversions xs \\<union>\n                              map_prod ((+) m) ((+) m) `\n                              inversions ys \\<union>\n                              map_prod id ((+) m) ` inversions_between xs ys", "have [simp]: \"j = m + j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. j = m + j'", "using \\<open>j \\<ge> m\\<close>"], ["proof (prove)\nusing this:\n  m \\<le> j\n\ngoal (1 subgoal):\n 1. j = m + j'", "by (simp add: j'_def)"], ["proof (state)\nthis:\n  j = m + j'\n\ngoal (3 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 3. \\<lbrakk>i < m; m \\<le> j\\<rbrakk>\n    \\<Longrightarrow> z \\<in> inversions xs \\<union>\n                              map_prod ((+) m) ((+) m) `\n                              inversions ys \\<union>\n                              map_prod id ((+) m) ` inversions_between xs ys", "from ij and \\<open>i < m\\<close>"], ["proof (chain)\npicking this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i\n  i < m", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i\n  i < m\n\ngoal (1 subgoal):\n 1. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "by (auto simp: inversions_altdef map_prod_def inversions_between_def nth_append m_def n_def)"], ["proof (state)\nthis:\n  z \\<in> inversions xs \\<union>\n          map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n          map_prod id ((+) m) ` inversions_between xs ys\n\ngoal (2 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "assume \"i \\<ge> m\""], ["proof (state)\nthis:\n  m \\<le> i\n\ngoal (2 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "define i' j' where \"i' = i - m\" and \"j' = j - m\""], ["proof (state)\nthis:\n  i' = i - m\n  j' = j - m\n\ngoal (2 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "have [simp]: \"i = m + i'\" \"j = m + j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i = m + i' &&& j = m + j'", "using \\<open>i < j\\<close> and \\<open>i \\<ge> m\\<close>"], ["proof (prove)\nusing this:\n  i < j\n  m \\<le> i\n\ngoal (1 subgoal):\n 1. i = m + i' &&& j = m + j'", "by (simp_all add: i'_def j'_def)"], ["proof (state)\nthis:\n  i = m + i'\n  j = m + j'\n\ngoal (2 subgoals):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys\n 2. m \\<le> i \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "from ij"], ["proof (chain)\npicking this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < j\n  j < m + n\n  (xs @ ys) ! j < (xs @ ys) ! i\n\ngoal (1 subgoal):\n 1. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "by (auto simp: inversions_altdef map_prod_def nth_append m_def n_def)"], ["proof (state)\nthis:\n  z \\<in> inversions xs \\<union>\n          map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n          map_prod id ((+) m) ` inversions_between xs ys\n\ngoal (1 subgoal):\n 1. j < m \\<Longrightarrow>\n    z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys", "qed (use ij in \\<open>auto simp: nth_append defs\\<close>)"], ["proof (state)\nthis:\n  z \\<in> inversions xs \\<union>\n          map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n          map_prod id ((+) m) ` inversions_between xs ys\n\ngoal (1 subgoal):\n 1. z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys \\<Longrightarrow>\n    z \\<in> inversions (xs @ ys)", "qed (auto simp: nth_append defs)"], ["proof (state)\nthis:\n  (?z \\<in> inversions (xs @ ys)) =\n  (?z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversions (xs @ ys) =\n    inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?z \\<in> inversions (xs @ ys)) =\n  (?z \\<in> inversions xs \\<union>\n            map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n            map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversions (xs @ ys) =\n    inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys", "by blast"], ["proof (state)\nthis:\n  inversions (xs @ ys) =\n  inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n  map_prod id ((+) m) ` inversions_between xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Counting inversions\\<close>"], ["", "text \\<open>\n  We now define versions of @{const inversions} and @{const inversions_between} that\n  only return the \\<^emph>\\<open>number\\<close> of inversions.\n\\<close>"], ["", "definition inversion_number :: \"'a list \\<Rightarrow> nat\" where\n  \"inversion_number xs = card (inversions xs)\""], ["", "definition inversion_number_between where\n  \"inversion_number_between xs ys = card (inversions_between xs ys)\""], ["", "lemma inversions_between_code:\n  \"inversions_between xs ys =\n     Set.filter (\\<lambda>(i,j). less (ys ! j) (xs ! i)) ({..<length xs}\\<times>{..<length ys})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between xs ys =\n    Set.filter (\\<lambda>(i, j). ys ! j < xs ! i)\n     ({..<length xs} \\<times> {..<length ys})", "by (auto simp: inversions_between_def)"], ["", "lemmas (in -) [code] = inversions_between_code"], ["", "lemma inversion_number_Nil [simp]: \"inversion_number [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number [] = 0", "by (simp add: inversion_number_def)"], ["", "lemma inversion_number_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> inversion_number xs = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> Suc 0 \\<Longrightarrow> inversion_number xs = 0", "by (auto simp: inversion_number_def)"], ["", "lemma inversion_number_between_Nil [simp]:\n  \"inversion_number_between [] ys = 0\"\n  \"inversion_number_between xs [] = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between [] ys = 0 &&&\n    inversion_number_between xs [] = 0", "by (simp_all add: inversion_number_between_def)"], ["", "text \\<open>\n  We again get the following nice equation for the number of inversions of a concatenation:\n\\<close>"], ["", "proposition inversion_number_append:\n  \"inversion_number (xs @ ys) =\n     inversion_number xs + inversion_number ys + inversion_number_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "define m n where \"m = length xs\" and \"n = length ys\""], ["proof (state)\nthis:\n  m = length xs\n  n = length ys\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "let ?A = \"inversions xs\""], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "let ?B = \"map_prod ((+) m) ((+) m) ` inversions ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "let ?C = \"map_prod id ((+) m) ` inversions_between xs ys\""], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "have \"inversion_number (xs @ ys) = card (?A \\<union> ?B \\<union> ?C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    card\n     (inversions xs \\<union>\n      map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n      map_prod id ((+) m) ` inversions_between xs ys)", "by (simp add: inversion_number_def inversions_append m_def)"], ["proof (state)\nthis:\n  inversion_number (xs @ ys) =\n  card\n   (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "also"], ["proof (state)\nthis:\n  inversion_number (xs @ ys) =\n  card\n   (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "have \"\\<dots> = card (?A \\<union> ?B) + card ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     (inversions xs \\<union>\n      map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n      map_prod id ((+) m) ` inversions_between xs ys) =\n    card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) +\n    card (map_prod id ((+) m) ` inversions_between xs ys)", "by (intro card_Un_disjoint finite_inversions finite_inversions_between finite_UnI finite_imageI)\n       (auto simp: inversions_altdef inversions_between_def m_def n_def)"], ["proof (state)\nthis:\n  card\n   (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys) =\n  card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) +\n  card (map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "also"], ["proof (state)\nthis:\n  card\n   (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys \\<union>\n    map_prod id ((+) m) ` inversions_between xs ys) =\n  card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) +\n  card (map_prod id ((+) m) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "have \"card (?A \\<union> ?B) = inversion_number xs + card ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) =\n    inversion_number xs + card (map_prod ((+) m) ((+) m) ` inversions ys)", "unfolding inversion_number_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) =\n    card (inversions xs) + card (map_prod ((+) m) ((+) m) ` inversions ys)", "by (intro card_Un_disjoint finite_inversions finite_UnI finite_imageI)\n       (auto simp: inversions_altdef m_def n_def)"], ["proof (state)\nthis:\n  card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) =\n  inversion_number xs + card (map_prod ((+) m) ((+) m) ` inversions ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "also"], ["proof (state)\nthis:\n  card (inversions xs \\<union> map_prod ((+) m) ((+) m) ` inversions ys) =\n  inversion_number xs + card (map_prod ((+) m) ((+) m) ` inversions ys)\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "have \"card ?B = inversion_number ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod ((+) m) ((+) m) ` inversions ys) = inversion_number ys", "unfolding inversion_number_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod ((+) m) ((+) m) ` inversions ys) = card (inversions ys)", "by (intro card_image) (auto simp: map_prod_def inj_on_def)"], ["proof (state)\nthis:\n  card (map_prod ((+) m) ((+) m) ` inversions ys) = inversion_number ys\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "also"], ["proof (state)\nthis:\n  card (map_prod ((+) m) ((+) m) ` inversions ys) = inversion_number ys\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "have \"card ?C = inversion_number_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod id ((+) m) ` inversions_between xs ys) =\n    inversion_number_between xs ys", "unfolding inversion_number_between_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod id ((+) m) ` inversions_between xs ys) =\n    card (inversions_between xs ys)", "by (intro card_image inj_onI) (auto simp: map_prod_def)"], ["proof (state)\nthis:\n  card (map_prod id ((+) m) ` inversions_between xs ys) =\n  inversion_number_between xs ys\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "finally"], ["proof (chain)\npicking this:\n  inversion_number (xs @ ys) =\n  inversion_number xs + inversion_number ys + inversion_number_between xs ys", "show ?thesis"], ["proof (prove)\nusing this:\n  inversion_number (xs @ ys) =\n  inversion_number xs + inversion_number ys + inversion_number_between xs ys\n\ngoal (1 subgoal):\n 1. inversion_number (xs @ ys) =\n    inversion_number xs + inversion_number ys +\n    inversion_number_between xs ys", "."], ["proof (state)\nthis:\n  inversion_number (xs @ ys) =\n  inversion_number xs + inversion_number ys + inversion_number_between xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Stability of inversions between lists under permutations\\<close>"], ["", "text \\<open>\n  A crucial fact for counting list inversions with merge sort is that the number\n  of inversions \\<^emph>\\<open>between\\<close> two lists does not change when the lists are permuted. This is\n  true because the set of inversions commutes with the act of permuting the list:\n\\<close>"], ["", "lemma inversions_between_permute1:\n  assumes \"\\<pi> permutes {..<length xs}\"\n  shows   \"inversions_between (permute_list \\<pi> xs) ys =\n             map_prod (inv \\<pi>) id ` inversions_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi> xs) ys =\n    map_prod (inv \\<pi>) id ` inversions_between xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi> xs) ys =\n    map_prod (inv \\<pi>) id ` inversions_between xs ys", "from assms"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length xs}", "have [simp]: \"\\<pi> i < length xs\" if \"i < length xs\" \"\\<pi> permutes {..<length xs}\" for i \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. \\<pi> i < length xs", "using permutes_in_image[OF that(2)] that"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  (\\<pi> ?x \\<in> {..<length xs}) = (?x \\<in> {..<length xs})\n  i < length xs\n  \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. \\<pi> i < length xs", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length xs; ?\\<pi> permutes {..<length xs}\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> ?i < length xs\n\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi> xs) ys =\n    map_prod (inv \\<pi>) id ` inversions_between xs ys", "have *: \"inv \\<pi> permutes {..<length xs}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<pi> permutes {..<length xs}", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. inv \\<pi> permutes {..<length xs}", "by (rule permutes_inv)"], ["proof (state)\nthis:\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi> xs) ys =\n    map_prod (inv \\<pi>) id ` inversions_between xs ys", "from assms *"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length xs}\n  inv \\<pi> permutes {..<length xs}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi> xs) ys =\n    map_prod (inv \\<pi>) id ` inversions_between xs ys", "unfolding inversions_between_def map_prod_def"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length xs}\n  inv \\<pi> permutes {..<length xs}\n\ngoal (1 subgoal):\n 1. {(i, j).\n     (i, j)\n     \\<in> {..<length (permute_list \\<pi> xs)} \\<times>\n           {..<length ys} \\<and>\n     ys ! j < permute_list \\<pi> xs ! i} =\n    (\\<lambda>(x, y). (inv \\<pi> x, id y)) `\n    {(i, j).\n     (i, j) \\<in> {..<length xs} \\<times> {..<length ys} \\<and>\n     ys ! j < xs ! i}", "by (force simp: image_iff permute_list_nth permutes_inverses intro: exI[of _ \"\\<pi> i\" for i])"], ["proof (state)\nthis:\n  inversions_between (permute_list \\<pi> xs) ys =\n  map_prod (inv \\<pi>) id ` inversions_between xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inversions_between_permute2:\n  assumes \"\\<pi> permutes {..<length ys}\"\n  shows   \"inversions_between xs (permute_list \\<pi> ys) =\n             map_prod id (inv \\<pi>) ` inversions_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between xs (permute_list \\<pi> ys) =\n    map_prod id (inv \\<pi>) ` inversions_between xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversions_between xs (permute_list \\<pi> ys) =\n    map_prod id (inv \\<pi>) ` inversions_between xs ys", "from assms"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length ys}", "have [simp]: \"\\<pi> i < length ys\" if \"i < length ys\" \"\\<pi> permutes {..<length ys}\" for i \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. \\<pi> i < length ys", "using permutes_in_image[OF that(2)] that"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length ys}\n  (\\<pi> ?x \\<in> {..<length ys}) = (?x \\<in> {..<length ys})\n  i < length ys\n  \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. \\<pi> i < length ys", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i < length ys; ?\\<pi> permutes {..<length ys}\\<rbrakk>\n  \\<Longrightarrow> ?\\<pi> ?i < length ys\n\ngoal (1 subgoal):\n 1. inversions_between xs (permute_list \\<pi> ys) =\n    map_prod id (inv \\<pi>) ` inversions_between xs ys", "have *: \"inv \\<pi> permutes {..<length ys}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<pi> permutes {..<length ys}", "using assms"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. inv \\<pi> permutes {..<length ys}", "by (rule permutes_inv)"], ["proof (state)\nthis:\n  inv \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. inversions_between xs (permute_list \\<pi> ys) =\n    map_prod id (inv \\<pi>) ` inversions_between xs ys", "from assms *"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<length ys}\n  inv \\<pi> permutes {..<length ys}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length ys}\n  inv \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. inversions_between xs (permute_list \\<pi> ys) =\n    map_prod id (inv \\<pi>) ` inversions_between xs ys", "unfolding inversions_between_def map_prod_def"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<length ys}\n  inv \\<pi> permutes {..<length ys}\n\ngoal (1 subgoal):\n 1. {(i, j).\n     (i, j)\n     \\<in> {..<length xs} \\<times>\n           {..<length (permute_list \\<pi> ys)} \\<and>\n     permute_list \\<pi> ys ! j < xs ! i} =\n    (\\<lambda>(x, y). (id x, inv \\<pi> y)) `\n    {(i, j).\n     (i, j) \\<in> {..<length xs} \\<times> {..<length ys} \\<and>\n     ys ! j < xs ! i}", "by (force simp: image_iff permute_list_nth permutes_inverses intro: exI[of _ \"\\<pi> i\" for i])"], ["proof (state)\nthis:\n  inversions_between xs (permute_list \\<pi> ys) =\n  map_prod id (inv \\<pi>) ` inversions_between xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition inversions_between_permute:\n  assumes \"\\<pi>1 permutes {..<length xs}\" and \"\\<pi>2 permutes {..<length ys}\"\n  shows   \"inversions_between (permute_list \\<pi>1 xs) (permute_list \\<pi>2 ys) =\n             map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between (permute_list \\<pi>1 xs) (permute_list \\<pi>2 ys) =\n    map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys", "by (simp add: inversions_between_permute1 inversions_between_permute2 assms\n                map_prod_def image_image case_prod_unfold)"], ["", "corollary inversion_number_between_permute:\n  assumes \"\\<pi>1 permutes {..<length xs}\" and \"\\<pi>2 permutes {..<length ys}\"\n  shows   \"inversion_number_between (permute_list \\<pi>1 xs) (permute_list \\<pi>2 ys) =\n             inversion_number_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "have \"inversion_number_between (permute_list \\<pi>1 xs) (permute_list \\<pi>2 ys) =\n          card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys)", "by (simp add: inversion_number_between_def inversions_between_permute assms)"], ["proof (state)\nthis:\n  inversion_number_between (permute_list \\<pi>1 xs)\n   (permute_list \\<pi>2 ys) =\n  card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "also"], ["proof (state)\nthis:\n  inversion_number_between (permute_list \\<pi>1 xs)\n   (permute_list \\<pi>2 ys) =\n  card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys)\n\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "have \"\\<dots> = inversion_number_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys) =\n    inversion_number_between xs ys", "unfolding inversion_number_between_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys) =\n    card (inversions_between xs ys)", "using assms[THEN permutes_inj_on[OF permutes_inv]]"], ["proof (prove)\nusing this:\n  inj_on (inv \\<pi>1) ?A\n  inj_on (inv \\<pi>2) ?A\n\ngoal (1 subgoal):\n 1. card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys) =\n    card (inversions_between xs ys)", "by (intro card_image inj_onI) (auto simp: map_prod_def)"], ["proof (state)\nthis:\n  card (map_prod (inv \\<pi>1) (inv \\<pi>2) ` inversions_between xs ys) =\n  inversion_number_between xs ys\n\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "finally"], ["proof (chain)\npicking this:\n  inversion_number_between (permute_list \\<pi>1 xs)\n   (permute_list \\<pi>2 ys) =\n  inversion_number_between xs ys", "show ?thesis"], ["proof (prove)\nusing this:\n  inversion_number_between (permute_list \\<pi>1 xs)\n   (permute_list \\<pi>2 ys) =\n  inversion_number_between xs ys\n\ngoal (1 subgoal):\n 1. inversion_number_between (permute_list \\<pi>1 xs)\n     (permute_list \\<pi>2 ys) =\n    inversion_number_between xs ys", "."], ["proof (state)\nthis:\n  inversion_number_between (permute_list \\<pi>1 xs)\n   (permute_list \\<pi>2 ys) =\n  inversion_number_between xs ys\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following form of the above theorem is nicer to apply since it has the form of a \n  congruence rule.\n\\<close>"], ["", "corollary inversion_number_between_cong_mset:\n  assumes \"mset xs = mset xs'\" and \"mset ys = mset ys'\"\n  shows   \"inversion_number_between xs ys = inversion_number_between xs' ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between xs ys = inversion_number_between xs' ys'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inversion_number_between xs ys = inversion_number_between xs' ys'", "obtain \\<pi>1 \\<pi>2 where \\<pi>12: \"\\<pi>1 permutes {..<length xs'}\" \"xs = permute_list \\<pi>1 xs'\"\n                          \"\\<pi>2 permutes {..<length ys'}\" \"ys = permute_list \\<pi>2 ys'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>1 \\<pi>2.\n        \\<lbrakk>\\<pi>1 permutes {..<length xs'};\n         xs = permute_list \\<pi>1 xs'; \\<pi>2 permutes {..<length ys'};\n         ys = permute_list \\<pi>2 ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms[THEN mset_eq_permutation]"], ["proof (prove)\nusing this:\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length xs'}; permute_list p xs' = xs\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  (\\<And>p.\n      \\<lbrakk>p permutes {..<length ys'}; permute_list p ys' = ys\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>1 \\<pi>2.\n        \\<lbrakk>\\<pi>1 permutes {..<length xs'};\n         xs = permute_list \\<pi>1 xs'; \\<pi>2 permutes {..<length ys'};\n         ys = permute_list \\<pi>2 ys'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<pi>1 permutes {..<length xs'}\n  xs = permute_list \\<pi>1 xs'\n  \\<pi>2 permutes {..<length ys'}\n  ys = permute_list \\<pi>2 ys'\n\ngoal (1 subgoal):\n 1. inversion_number_between xs ys = inversion_number_between xs' ys'", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pi>1 permutes {..<length xs'}\n  xs = permute_list \\<pi>1 xs'\n  \\<pi>2 permutes {..<length ys'}\n  ys = permute_list \\<pi>2 ys'\n\ngoal (1 subgoal):\n 1. inversion_number_between xs ys = inversion_number_between xs' ys'", "by (simp add: inversion_number_between_permute)"], ["proof (state)\nthis:\n  inversion_number_between xs ys = inversion_number_between xs' ys'\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Inversions between sorted lists\\<close>"], ["", "text \\<open>\n  Another fact that is crucial to the efficient computation of the inversion number is this:\n  If we have two sorted lists, we can reduce computing the inversions by inspecting the \n  first elements and deleting one of them.\n\\<close>"], ["", "lemma inversions_between_Cons_Cons:\n  assumes \"sorted_wrt less_eq (x # xs)\" and \"sorted_wrt less_eq (y # ys)\"\n  shows   \"inversions_between (x # xs) (y # ys) =\n             (if \\<not>less y x then\n                map_prod Suc id ` inversions_between xs (y # ys)\n              else\n                {..<length (x#xs)} \\<times> {0} \\<union>\n                map_prod id Suc ` inversions_between (x # xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversions_between (x # xs) (y # ys) =\n    (if \\<not> y < x then map_prod Suc id ` inversions_between xs (y # ys)\n     else {..<length (x # xs)} \\<times> {0} \\<union>\n          map_prod id Suc ` inversions_between (x # xs) ys)", "using assms"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<le>) (x # xs)\n  sorted_wrt (\\<le>) (y # ys)\n\ngoal (1 subgoal):\n 1. inversions_between (x # xs) (y # ys) =\n    (if \\<not> y < x then map_prod Suc id ` inversions_between xs (y # ys)\n     else {..<length (x # xs)} \\<times> {0} \\<union>\n          map_prod id Suc ` inversions_between (x # xs) ys)", "unfolding inversions_between_def map_prod_def"], ["proof (prove)\nusing this:\n  sorted_wrt (\\<le>) (x # xs)\n  sorted_wrt (\\<le>) (y # ys)\n\ngoal (1 subgoal):\n 1. {(i, j).\n     (i, j) \\<in> {..<length (x # xs)} \\<times> {..<length (y # ys)} \\<and>\n     (y # ys) ! j < (x # xs) ! i} =\n    (if \\<not> y < x\n     then (\\<lambda>(x, y). (Suc x, id y)) `\n          {(i, j).\n           (i, j) \\<in> {..<length xs} \\<times> {..<length (y # ys)} \\<and>\n           (y # ys) ! j < xs ! i}\n     else {..<length (x # xs)} \\<times> {0} \\<union>\n          (\\<lambda>(x, y). (id x, Suc y)) `\n          {(i, j).\n           (i, j) \\<in> {..<length (x # xs)} \\<times> {..<length ys} \\<and>\n           ys ! j < (x # xs) ! i})", "by (auto, (auto simp: set_conv_nth nth_Cons less_le_not_le image_iff \n                  intro: order_trans split: nat.splits)?)"], ["", "(* A bit fragile, but doing this manually is annoying *)"], ["", "text \\<open>\n  This leads to the following analogous equation for counting the inversions between two\n  sorted lists. Note that a single step of this only takes constant time (assuming we \n  pre-computed the lengths of the lists) so that the entire function runs in linear time.\n\\<close>"], ["", "lemma inversion_number_between_Cons_Cons:\n  assumes \"sorted_wrt less_eq (x # xs)\" and \"sorted_wrt less_eq (y # ys)\"\n  shows   \"inversion_number_between (x # xs) (y # ys) =\n             (if \\<not>less y x then\n                inversion_number_between xs (y # ys)\n              else\n                inversion_number_between (x # xs) ys + length (x # xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "proof (cases \"less y x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))\n 2. \\<not> y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "case False"], ["proof (state)\nthis:\n  \\<not> y < x\n\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))\n 2. \\<not> y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "hence \"inversion_number_between (x # xs) (y # ys) = \n           card (map_prod Suc id ` inversions_between xs (y # ys))\""], ["proof (prove)\nusing this:\n  \\<not> y < x\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    card (map_prod Suc id ` inversions_between xs (y # ys))", "by (simp add: inversion_number_between_def inversions_between_Cons_Cons[OF assms])"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  card (map_prod Suc id ` inversions_between xs (y # ys))\n\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))\n 2. \\<not> y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "also"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  card (map_prod Suc id ` inversions_between xs (y # ys))\n\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))\n 2. \\<not> y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "have \"\\<dots> = inversion_number_between xs (y # ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod Suc id ` inversions_between xs (y # ys)) =\n    inversion_number_between xs (y # ys)", "unfolding inversion_number_between_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod Suc id ` inversions_between xs (y # ys)) =\n    card (inversions_between xs (y # ys))", "by (intro card_image inj_onI) (auto simp: map_prod_def)"], ["proof (state)\nthis:\n  card (map_prod Suc id ` inversions_between xs (y # ys)) =\n  inversion_number_between xs (y # ys)\n\ngoal (2 subgoals):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))\n 2. \\<not> y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "finally"], ["proof (chain)\npicking this:\n  inversion_number_between (x # xs) (y # ys) =\n  inversion_number_between xs (y # ys)", "show ?thesis"], ["proof (prove)\nusing this:\n  inversion_number_between (x # xs) (y # ys) =\n  inversion_number_between xs (y # ys)\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "using False"], ["proof (prove)\nusing this:\n  inversion_number_between (x # xs) (y # ys) =\n  inversion_number_between xs (y # ys)\n  \\<not> y < x\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "by simp"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  (if \\<not> y < x then inversion_number_between xs (y # ys)\n   else inversion_number_between (x # xs) ys + length (x # xs))\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "case True"], ["proof (state)\nthis:\n  y < x\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "hence \"inversion_number_between (x # xs) (y # ys) =\n           card ({..<length (x # xs)} \\<times> {0} \\<union> map_prod id Suc ` inversions_between (x # xs) ys)\""], ["proof (prove)\nusing this:\n  y < x\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    card\n     ({..<length (x # xs)} \\<times> {0} \\<union>\n      map_prod id Suc ` inversions_between (x # xs) ys)", "by (simp add: inversion_number_between_def inversions_between_Cons_Cons[OF assms])"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  card\n   ({..<length (x # xs)} \\<times> {0} \\<union>\n    map_prod id Suc ` inversions_between (x # xs) ys)\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "also"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  card\n   ({..<length (x # xs)} \\<times> {0} \\<union>\n    map_prod id Suc ` inversions_between (x # xs) ys)\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "have \"\\<dots> = length (x # xs) + card (map_prod id Suc ` inversions_between (x # xs) ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card\n     ({..<length (x # xs)} \\<times> {0} \\<union>\n      map_prod id Suc ` inversions_between (x # xs) ys) =\n    length (x # xs) +\n    card (map_prod id Suc ` inversions_between (x # xs) ys)", "by (subst card_Un_disjoint) auto"], ["proof (state)\nthis:\n  card\n   ({..<length (x # xs)} \\<times> {0} \\<union>\n    map_prod id Suc ` inversions_between (x # xs) ys) =\n  length (x # xs) + card (map_prod id Suc ` inversions_between (x # xs) ys)\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "also"], ["proof (state)\nthis:\n  card\n   ({..<length (x # xs)} \\<times> {0} \\<union>\n    map_prod id Suc ` inversions_between (x # xs) ys) =\n  length (x # xs) + card (map_prod id Suc ` inversions_between (x # xs) ys)\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "have \"card (map_prod id Suc ` inversions_between (x # xs) ys) =\n               inversion_number_between (x # xs) ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod id Suc ` inversions_between (x # xs) ys) =\n    inversion_number_between (x # xs) ys", "unfolding inversion_number_between_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (map_prod id Suc ` inversions_between (x # xs) ys) =\n    card (inversions_between (x # xs) ys)", "by (intro card_image inj_onI) (auto simp: map_prod_def)"], ["proof (state)\nthis:\n  card (map_prod id Suc ` inversions_between (x # xs) ys) =\n  inversion_number_between (x # xs) ys\n\ngoal (1 subgoal):\n 1. y < x \\<Longrightarrow>\n    inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "finally"], ["proof (chain)\npicking this:\n  inversion_number_between (x # xs) (y # ys) =\n  length (x # xs) + inversion_number_between (x # xs) ys", "show ?thesis"], ["proof (prove)\nusing this:\n  inversion_number_between (x # xs) (y # ys) =\n  length (x # xs) + inversion_number_between (x # xs) ys\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "using True"], ["proof (prove)\nusing this:\n  inversion_number_between (x # xs) (y # ys) =\n  length (x # xs) + inversion_number_between (x # xs) ys\n  y < x\n\ngoal (1 subgoal):\n 1. inversion_number_between (x # xs) (y # ys) =\n    (if \\<not> y < x then inversion_number_between xs (y # ys)\n     else inversion_number_between (x # xs) ys + length (x # xs))", "by simp"], ["proof (state)\nthis:\n  inversion_number_between (x # xs) (y # ys) =\n  (if \\<not> y < x then inversion_number_between xs (y # ys)\n   else inversion_number_between (x # xs) ys + length (x # xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  We now define a function to compute the inversion number between two lists that are\n  assumed to be sorted using the equalities we just derived.\n\\<close>"], ["", "fun inversion_number_between_sorted :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> nat\" where\n  \"inversion_number_between_sorted [] ys = 0\"\n| \"inversion_number_between_sorted xs [] = 0\"\n| \"inversion_number_between_sorted (x # xs) (y # ys) =\n             (if \\<not>less y x then\n                inversion_number_between_sorted xs (y # ys)\n              else\n                inversion_number_between_sorted (x # xs) ys + length (x # xs))\""], ["", "theorem inversion_number_between_sorted_correct:\n  \"sorted_wrt less_eq xs \\<Longrightarrow> sorted_wrt less_eq ys \\<Longrightarrow>\n     inversion_number_between_sorted xs ys = inversion_number_between xs ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted_wrt (\\<le>) xs; sorted_wrt (\\<le>) ys\\<rbrakk>\n    \\<Longrightarrow> inversion_number_between_sorted xs ys =\n                      inversion_number_between xs ys", "by (induction xs ys rule: inversion_number_between_sorted.induct)\n     (simp_all add: inversion_number_between_Cons_Cons)"], ["", "end"], ["", "subsection \\<open>Merge sort\\<close>"], ["", "(* TODO: Could be replaced by mergesort from HOL-Library in Isabelle 2019. *)"], ["", "text \\<open>\n  For convenience, we first define a simple merge sort that does not compute the inversions.\n  At this point, we need to start assuming a linear ordering since the merging function\n  does not work otherwise.\n\\<close>"], ["", "context linorder\nbegin"], ["", "definition split_list\n  where \"split_list xs = (let n = length xs div 2 in (take n xs, drop n xs))\""], ["", "fun merge_lists :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\" where\n  \"merge_lists [] ys = ys\"\n| \"merge_lists xs [] = xs\"\n| \"merge_lists (x # xs) (y # ys) =\n    (if less_eq x y then x # merge_lists xs (y # ys) else y # merge_lists (x # xs) ys)\""], ["", "lemma set_merge_lists [simp]: \"set (merge_lists xs ys) = set xs \\<union> set ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_lists xs ys) = set xs \\<union> set ys", "by (induction xs ys rule: merge_lists.induct) auto"], ["", "lemma mset_merge_lists [simp]: \"mset (merge_lists xs ys) = mset xs + mset ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (merge_lists xs ys) = mset xs + mset ys", "by (induction xs ys rule: merge_lists.induct) auto"], ["", "lemma sorted_merge_lists [simp, intro]:\n  \"sorted xs \\<Longrightarrow> sorted ys \\<Longrightarrow> sorted (merge_lists xs ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sorted xs; sorted ys\\<rbrakk>\n    \\<Longrightarrow> sorted (merge_lists xs ys)", "by (induction xs ys rule: merge_lists.induct) auto"], ["", "fun merge_sort :: \"'a list \\<Rightarrow> 'a list\" where\n  \"merge_sort xs =\n    (if length xs \\<le> 1 then\n       xs \n     else\n       merge_lists (merge_sort (take (length xs div 2) xs))\n                   (merge_sort (drop (length xs div 2) xs)))\""], ["", "lemmas [simp del] = merge_sort.simps"], ["", "lemma merge_sort_trivial [simp]: \"length xs \\<le> Suc 0 \\<Longrightarrow> merge_sort xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length xs \\<le> Suc 0 \\<Longrightarrow> merge_sort xs = xs", "by (subst merge_sort.simps) auto"], ["", "theorem mset_merge_sort [simp]: \"mset (merge_sort xs) = mset xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mset (merge_sort xs) = mset xs", "by (induction xs rule: merge_sort.induct)\n     (subst merge_sort.simps, auto simp flip: mset_append)"], ["", "corollary set_merge_sort [simp]: \"set (merge_sort xs) = set xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (merge_sort xs) = set xs", "by (rule mset_eq_setD) simp_all"], ["", "theorem sorted_merge_sort [simp, intro]: \"sorted (merge_sort xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sorted (merge_sort xs)", "by (induction xs rule: merge_sort.induct)\n     (subst merge_sort.simps, use sorted01 in auto)"], ["", "lemma inversion_number_between_code:\n  \"inversion_number_between xs ys = inversion_number_between_sorted (sort xs) (sort ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number_between xs ys =\n    inversion_number_between_sorted (sort xs) (sort ys)", "by (subst inversion_number_between_sorted_correct)\n     (simp_all add: sorted_sorted_wrt [symmetric] cong: inversion_number_between_cong_mset)"], ["", "lemmas (in -) [code_unfold] = inversion_number_between_code"], ["", "subsection \\<open>Merge sort with inversion counting\\<close>"], ["", "text \\<open>\n  Finally, we can put together all the components and define a variant of merge sort that\n  counts the number of inversions in the original list:\n\\<close>"], ["", "function sort_and_count_inversions :: \"'a list \\<Rightarrow> 'a list \\<times> nat\" where\n  \"sort_and_count_inversions xs =\n     (if length xs \\<le> 1 then\n        (xs, 0)\n      else\n        let (xs1, xs2) = split_list xs;\n            (xs1', m) = sort_and_count_inversions xs1;\n            (xs2', n) = sort_and_count_inversions xs2\n        in\n            (merge_lists xs1' xs2', m + n + inversion_number_between_sorted xs1' xs2'))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>xs. x = xs \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>xs xsa.\n       xs = xsa \\<Longrightarrow>\n       (if length xs \\<le> 1 then (xs, 0)\n        else let (xs1, xs2) = split_list xs;\n                 (xs1', m) = sort_and_count_inversions_sumC xs1;\n                 (xs2', n) = sort_and_count_inversions_sumC xs2\n             in (merge_lists xs1' xs2',\n                 m + n + inversion_number_between_sorted xs1' xs2')) =\n       (if length xsa \\<le> 1 then (xsa, 0)\n        else let (xs1, xs2) = split_list xsa;\n                 (xs1', m) = sort_and_count_inversions_sumC xs1;\n                 (xs2', n) = sort_and_count_inversions_sumC xs2\n             in (merge_lists xs1' xs2',\n                 m + n + inversion_number_between_sorted xs1' xs2'))", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. sort_and_count_inversions_dom x", "by (relation \"measure length\") (auto simp: split_list_def Let_def)"], ["", "lemmas [simp del] = sort_and_count_inversions.simps"], ["", "text \\<open>\n  The projection of this function to the first component is simply the standard merge sort\n  algorithm that we defined and proved correct before.\n\\<close>"], ["", "theorem fst_sort_and_count_inversions [simp]:\n  \"fst (sort_and_count_inversions xs) = merge_sort xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (sort_and_count_inversions xs) = merge_sort xs", "by (induction xs rule: length_induct)\n     (subst sort_and_count_inversions.simps, subst merge_sort.simps,\n      simp_all add: split_list_def case_prod_unfold Let_def)"], ["", "text \\<open>\n  The projection to the second component is the inversion number.\n\\<close>"], ["", "theorem snd_sort_and_count_inversions [simp]:\n  \"snd (sort_and_count_inversions xs) = inversion_number xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (sort_and_count_inversions xs) = inversion_number xs", "proof (induction xs rule: length_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          snd (sort_and_count_inversions ys) =\n          inversion_number ys \\<Longrightarrow>\n       snd (sort_and_count_inversions xs) = inversion_number xs", "case (1 xs)"], ["proof (state)\nthis:\n  \\<forall>ys.\n     length ys < length xs \\<longrightarrow>\n     snd (sort_and_count_inversions ys) = inversion_number ys\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<forall>ys.\n          length ys < length xs \\<longrightarrow>\n          snd (sort_and_count_inversions ys) =\n          inversion_number ys \\<Longrightarrow>\n       snd (sort_and_count_inversions xs) = inversion_number xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (sort_and_count_inversions xs) = inversion_number xs", "proof (cases \"length xs \\<le> 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "case False"], ["proof (state)\nthis:\n  \\<not> length xs \\<le> 1\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "have \"xs = take (length xs div 2) xs @ drop (length xs div 2) xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs = take (length xs div 2) xs @ drop (length xs div 2) xs", "by simp"], ["proof (state)\nthis:\n  xs = take (length xs div 2) xs @ drop (length xs div 2) xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "also"], ["proof (state)\nthis:\n  xs = take (length xs div 2) xs @ drop (length xs div 2) xs\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "have \"inversion_number \\<dots> = snd (sort_and_count_inversions xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inversion_number\n     (take (length xs div 2) xs @ drop (length xs div 2) xs) =\n    snd (sort_and_count_inversions xs)", "by (subst inversion_number_append, subst sort_and_count_inversions.simps)\n         (use False 1 in \\<open>auto simp: Let_def split_list_def case_prod_unfold \n                                     inversion_number_between_sorted_correct\n                                     sorted_sorted_wrt [symmetric]\n                               cong: inversion_number_between_cong_mset\\<close>)"], ["proof (state)\nthis:\n  inversion_number (take (length xs div 2) xs @ drop (length xs div 2) xs) =\n  snd (sort_and_count_inversions xs)\n\ngoal (2 subgoals):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs\n 2. \\<not> length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "finally"], ["proof (chain)\npicking this:\n  inversion_number xs = snd (sort_and_count_inversions xs)", "show ?thesis"], ["proof (prove)\nusing this:\n  inversion_number xs = snd (sort_and_count_inversions xs)\n\ngoal (1 subgoal):\n 1. snd (sort_and_count_inversions xs) = inversion_number xs", ".."], ["proof (state)\nthis:\n  snd (sort_and_count_inversions xs) = inversion_number xs\n\ngoal (1 subgoal):\n 1. length xs \\<le> 1 \\<Longrightarrow>\n    snd (sort_and_count_inversions xs) = inversion_number xs", "qed (auto simp: sort_and_count_inversions.simps)"], ["proof (state)\nthis:\n  snd (sort_and_count_inversions xs) = inversion_number xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas (in -) [code_unfold] = snd_sort_and_count_inversions [symmetric]"], ["", "end"], ["", "end"]]}