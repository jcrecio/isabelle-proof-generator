{"file_name": "/home/qj213/afp-2021-10-22/thys/Szpilrajn/Szpilrajn.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Szpilrajn", "problem_names": ["lemma show_strict_partial_order[intro]: \n  assumes \"trans r\" and \"irrefl r\" \n  shows \"strict_partial_order r\"", "lemma strict_partial_order_acyclic:\n  assumes \"strict_partial_order r\"\n  shows \"acyclic r\"", "lemma strict_partial_order_subset:\n  \"strict_partial_order {(x,y). x \\<subset> y}\"", "lemma strict_linear_order_def: \n  \"strict_linear_order r \\<longleftrightarrow> strict_partial_order r \\<and> total r\"", "lemma can_extend_partial_order: \n  assumes spo: \"strict_partial_order r\"\n    and no1: \"(x,y) \\<notin> r\"\n    and no2: \"(y,x) \\<notin> r\"\n    and neq: \"x\\<noteq>y\"\n  shows \"strict_ext r ((r \\<union> {(x,y)})\\<^sup>+)\"", "lemma Zorns_po_lemma_nonempty:\n  assumes po: \"Partial_order r\"\n    and u: \"\\<And>C. \\<lbrakk>C \\<in> Chains r; C\\<noteq>{}\\<rbrakk> \\<Longrightarrow> \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r\"\n    and ne: \"r \\<noteq> {}\"\n  shows \"\\<exists>m\\<in>Field r. \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\"", "theorem Szpilrajn:\n  assumes \"strict_partial_order base_r\"\n  shows \"\\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\"", "lemma exists_strict_partial_order_on_sets:\n  shows \"\\<exists>r. strict_linear_order r \\<and> {(x,y). x \\<subset> y} \\<subseteq> r\""], "translations": [["", "lemma show_strict_partial_order[intro]: \n  assumes \"trans r\" and \"irrefl r\" \n  shows \"strict_partial_order r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_partial_order r", "by (simp add: assms strict_partial_order_def)"], ["", "lemma strict_partial_order_acyclic:\n  assumes \"strict_partial_order r\"\n  shows \"acyclic r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic r", "by (metis acyclic_irrefl assms strict_partial_order_def trancl_id)"], ["", "text \\<open>A typical example is \\<^term>\\<open>(\\<subset>)\\<close> on sets:\\<close>"], ["", "lemma strict_partial_order_subset:\n  \"strict_partial_order {(x,y). x \\<subset> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_partial_order {(x, y). x \\<subset> y}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. trans {(x, y). x \\<subset> y}\n 2. irrefl {(x, y). x \\<subset> y}", "show \"trans {(x,y). x \\<subset> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans {(x, y). x \\<subset> y}", "by (auto simp add: trans_def)"], ["proof (state)\nthis:\n  trans {(x, y). x \\<subset> y}\n\ngoal (1 subgoal):\n 1. irrefl {(x, y). x \\<subset> y}", "show \"irrefl {(x, y). x \\<subset> y}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl {(x, y). x \\<subset> y}", "by (simp add: irrefl_def)"], ["proof (state)\nthis:\n  irrefl {(x, y). x \\<subset> y}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A strict linear order has all the properties of a strict partial order, but is also total: \\<close>"], ["", "lemma strict_linear_order_def: \n  \"strict_linear_order r \\<longleftrightarrow> strict_partial_order r \\<and> total r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_linear_order r = (strict_partial_order r \\<and> total r)", "by (simp add: strict_linear_order_on_def strict_partial_order_def)"], ["", "section \"The Proof\""], ["", "text \\<open>A relation \\<^term>\\<open>r\\<close> is a strict extension of a base relation \\<^term>\\<open>base_r\\<close>\nif \\<^term>\\<open>r\\<close> is a strict partial order and \\<^term>\\<open>r\\<close> includes \\<^term>\\<open>base_r\\<close>:\\<close>"], ["", "definition \"strict_ext base_r r \\<equiv> strict_partial_order r \\<and>  base_r \\<subseteq> r\""], ["", "text \\<open>We start by proving that a strict partial order with two incomparable elements\n\\<^term>\\<open>x\\<close> and \\<^term>\\<open>y\\<close> can be extended to a strict partial order where \\<^term>\\<open>x < y\\<close>. \\<close>"], ["", "lemma can_extend_partial_order: \n  assumes spo: \"strict_partial_order r\"\n    and no1: \"(x,y) \\<notin> r\"\n    and no2: \"(y,x) \\<notin> r\"\n    and neq: \"x\\<noteq>y\"\n  shows \"strict_ext r ((r \\<union> {(x,y)})\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_ext r ((r \\<union> {(x, y)})\\<^sup>+)", "unfolding strict_ext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_partial_order ((r \\<union> {(x, y)})\\<^sup>+) \\<and>\n    r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+", "proof (intro conjI show_strict_partial_order)"], ["proof (state)\ngoal (3 subgoals):\n 1. trans ((r \\<union> {(x, y)})\\<^sup>+)\n 2. irrefl ((r \\<union> {(x, y)})\\<^sup>+)\n 3. r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+", "show \"trans ((r \\<union> {(x, y)})\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. trans ((r \\<union> {(x, y)})\\<^sup>+)", "by simp"], ["proof (state)\nthis:\n  trans ((r \\<union> {(x, y)})\\<^sup>+)\n\ngoal (2 subgoals):\n 1. irrefl ((r \\<union> {(x, y)})\\<^sup>+)\n 2. r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+", "show \"r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+", "by auto"], ["proof (state)\nthis:\n  r \\<subseteq> (r \\<union> {(x, y)})\\<^sup>+\n\ngoal (1 subgoal):\n 1. irrefl ((r \\<union> {(x, y)})\\<^sup>+)", "from spo"], ["proof (chain)\npicking this:\n  strict_partial_order r", "have \"trans r\" and \"irrefl r\""], ["proof (prove)\nusing this:\n  strict_partial_order r\n\ngoal (1 subgoal):\n 1. trans r &&& irrefl r", "by (auto simp add: strict_partial_order_def)"], ["proof (state)\nthis:\n  trans r\n  irrefl r\n\ngoal (1 subgoal):\n 1. irrefl ((r \\<union> {(x, y)})\\<^sup>+)", "show \"irrefl ((r \\<union> {(x, y)})\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl ((r \\<union> {(x, y)})\\<^sup>+)", "proof (clarsimp simp add: acyclic_irrefl[symmetric], intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. acyclic r\n 2. (y, x) \\<notin> r\\<^sup>*", "show \"acyclic r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. acyclic r", "by (simp add: spo strict_partial_order_acyclic)"], ["proof (state)\nthis:\n  acyclic r\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r\\<^sup>*", "show \"(y, x) \\<notin> r\\<^sup>*\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r\\<^sup>*", "using \\<open>trans r\\<close> neq no2 rtranclD"], ["proof (prove)\nusing this:\n  trans r\n  x \\<noteq> y\n  (y, x) \\<notin> r\n  (?a, ?b) \\<in> ?R\\<^sup>* \\<Longrightarrow>\n  ?a = ?b \\<or> ?a \\<noteq> ?b \\<and> (?a, ?b) \\<in> ?R\\<^sup>+\n\ngoal (1 subgoal):\n 1. (y, x) \\<notin> r\\<^sup>*", "by fastforce"], ["proof (state)\nthis:\n  (y, x) \\<notin> r\\<^sup>*\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  irrefl ((r \\<union> {(x, y)})\\<^sup>+)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>With this, we can start the proof of the Szpilrajn extension theorem.\nFor this we will use a variant of Zorns Lemma, which only considers nonempty chains:\\<close>"], ["", "lemma Zorns_po_lemma_nonempty:\n  assumes po: \"Partial_order r\"\n    and u: \"\\<And>C. \\<lbrakk>C \\<in> Chains r; C\\<noteq>{}\\<rbrakk> \\<Longrightarrow> \\<exists>u\\<in>Field r. \\<forall>a\\<in>C. (a, u) \\<in> r\"\n    and ne: \"r \\<noteq> {}\"\n  shows \"\\<exists>m\\<in>Field r. \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "from \\<open>r\\<noteq>{}\\<close>"], ["proof (chain)\npicking this:\n  r \\<noteq> {}", "obtain x where \"x\\<in>Field r\""], ["proof (prove)\nusing this:\n  r \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> Field r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using FieldI2"], ["proof (prove)\nusing this:\n  r \\<noteq> {}\n  (?i, ?j) \\<in> ?R \\<Longrightarrow> ?j \\<in> Field ?R\n\ngoal (1 subgoal):\n 1. (\\<And>x. x \\<in> Field r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  x \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "with assms"], ["proof (chain)\npicking this:\n  Partial_order r\n  \\<lbrakk>?C \\<in> Chains r; ?C \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u\\<in>Field r.\n                       \\<forall>a\\<in>?C. (a, u) \\<in> r\n  r \\<noteq> {}\n  x \\<in> Field r", "show ?thesis"], ["proof (prove)\nusing this:\n  Partial_order r\n  \\<lbrakk>?C \\<in> Chains r; ?C \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u\\<in>Field r.\n                       \\<forall>a\\<in>?C. (a, u) \\<in> r\n  r \\<noteq> {}\n  x \\<in> Field r\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "using Zorns_po_lemma"], ["proof (prove)\nusing this:\n  Partial_order r\n  \\<lbrakk>?C \\<in> Chains r; ?C \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u\\<in>Field r.\n                       \\<forall>a\\<in>?C. (a, u) \\<in> r\n  r \\<noteq> {}\n  x \\<in> Field r\n  \\<lbrakk>Partial_order ?r;\n   \\<And>C.\n      C \\<in> Chains ?r \\<Longrightarrow>\n      \\<exists>u\\<in>Field ?r. \\<forall>a\\<in>C. (a, u) \\<in> ?r\\<rbrakk>\n  \\<Longrightarrow> \\<exists>m\\<in>Field ?r.\n                       \\<forall>a\\<in>Field ?r.\n                          (m, a) \\<in> ?r \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field r.\n       \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m", "by (metis empty_iff)"], ["proof (state)\nthis:\n  \\<exists>m\\<in>Field r.\n     \\<forall>a\\<in>Field r. (m, a) \\<in> r \\<longrightarrow> a = m\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Szpilrajn:\n  assumes \"strict_partial_order base_r\"\n  shows \"\\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "text \\<open>We define an order on the set of strict extensions of the base relation \\<^term>\\<open>base_r\\<close>, \n    where \\<^term>\\<open>r \\<le> s\\<close> iff \\<^term>\\<open>r \\<subseteq> s\\<close>:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "define order_of_orders :: \"('a rel) rel\" where order_of_orders_def: \n    \"order_of_orders = {(r,s). r\\<subseteq>s \\<and> strict_ext base_r r \\<and> strict_ext base_r s }\""], ["proof (state)\nthis:\n  order_of_orders =\n  {(r, s).\n   r \\<subseteq> s \\<and> strict_ext base_r r \\<and> strict_ext base_r s}\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "have ord_Field: \"Field order_of_orders = {r. strict_ext base_r r}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Field order_of_orders = {r. strict_ext base_r r}", "by (auto simp add: Field_def order_of_orders_def)"], ["proof (state)\nthis:\n  Field order_of_orders = {r. strict_ext base_r r}\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "text \\<open>We now show that this set has a maximum and that any maximum of this set is \n    a strict linear order and as thus is one of the extensions we are looking for.\\<close>"], ["proof (state)\nthis:\n  Field order_of_orders = {r. strict_ext base_r r}\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "text \\<open>We begin by showing the existence of a maximal element \\<^term>\\<open>m\\<close> using Zorns Lemma:\\<close>"], ["proof (state)\nthis:\n  Field order_of_orders = {r. strict_ext base_r r}\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "have \"\\<exists>m\\<in>Field order_of_orders. \n      \\<forall>a\\<in>Field order_of_orders. (m, a) \\<in> order_of_orders \\<longrightarrow> a = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>m\\<in>Field order_of_orders.\n       \\<forall>a\\<in>Field order_of_orders.\n          (m, a) \\<in> order_of_orders \\<longrightarrow> a = m", "proof (rule Zorns_po_lemma_nonempty)"], ["proof (state)\ngoal (3 subgoals):\n 1. Partial_order order_of_orders\n 2. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\n 3. order_of_orders \\<noteq> {}", "text \\<open>Zorns Lemma requires us to prove that our \\<^term>\\<open>order_of_orders\\<close> is a nonempty  partial order\n   and that every nonempty chain has an upper bound. \n   The partial order property is trivial, since we used \\<^term>\\<open>(\\<subseteq>)\\<close> for the relation:\\<close>"], ["proof (state)\ngoal (3 subgoals):\n 1. Partial_order order_of_orders\n 2. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\n 3. order_of_orders \\<noteq> {}", "show \"Partial_order order_of_orders\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Partial_order order_of_orders", "by (auto simp add: order_of_orders_def order_on_defs refl_on_def Field_def trans_def antisym_def)"], ["proof (state)\nthis:\n  Partial_order order_of_orders\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\n 2. order_of_orders \\<noteq> {}", "text \\<open>Also, our order is obviously not empty since it contains \\<^term>\\<open>(base_r, base_r)\\<close>:\\<close>"], ["proof (state)\nthis:\n  Partial_order order_of_orders\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\n 2. order_of_orders \\<noteq> {}", "have \"(base_r, base_r)\\<in>order_of_orders\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (base_r, base_r) \\<in> order_of_orders", "using assms strict_ext_def"], ["proof (prove)\nusing this:\n  strict_partial_order base_r\n  strict_ext ?base_r ?r \\<equiv>\n  strict_partial_order ?r \\<and> ?base_r \\<subseteq> ?r\n\ngoal (1 subgoal):\n 1. (base_r, base_r) \\<in> order_of_orders", "by (auto simp add: order_of_orders_def)"], ["proof (state)\nthis:\n  (base_r, base_r) \\<in> order_of_orders\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\n 2. order_of_orders \\<noteq> {}", "thus \"order_of_orders \\<noteq> {}\""], ["proof (prove)\nusing this:\n  (base_r, base_r) \\<in> order_of_orders\n\ngoal (1 subgoal):\n 1. order_of_orders \\<noteq> {}", "by force"], ["proof (state)\nthis:\n  order_of_orders \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders", "text \\<open>Next we show that each chain has an upper bound.\n    For the upper bound we take the union of all relations in the chain. \\<close>"], ["proof (state)\nthis:\n  order_of_orders \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>C.\n       \\<lbrakk>C \\<in> Chains order_of_orders; C \\<noteq> {}\\<rbrakk>\n       \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                            \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders", "show \"\\<exists>u\\<in>Field order_of_orders. \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders\" \n      if C_def: \"C \\<in> Chains order_of_orders\" and C_nonemtpy: \"C \\<noteq> {}\"\n      for C"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>u\\<in>Field order_of_orders.\n       \\<forall>a\\<in>C. (a, u) \\<in> order_of_orders", "proof (rule bexI[where x=\"\\<Union>C\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "text \\<open>Obviously each element in the chain is a strict extension of \\<^term>\\<open>base_r\\<close> by definition\n      and as such it is transitive, irreflexive and extends the base relation.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "have r_se: \"strict_ext base_r r\" if \"r \\<in> C\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_ext base_r r", "using \\<open>r \\<in> C\\<close> C_def"], ["proof (prove)\nusing this:\n  r \\<in> C\n  C \\<in> Chains order_of_orders\n\ngoal (1 subgoal):\n 1. strict_ext base_r r", "by (auto simp add: Chains_def order_of_orders_def)"], ["proof (state)\nthis:\n  ?r \\<in> C \\<Longrightarrow> strict_ext base_r ?r\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "hence r_trans: \"trans r\" \n        and r_irrefl: \"irrefl r\" \n        and r_extends_base: \"base_r \\<subseteq> r\" \n        if \"r \\<in> C\" for r"], ["proof (prove)\nusing this:\n  ?r \\<in> C \\<Longrightarrow> strict_ext base_r ?r\n\ngoal (1 subgoal):\n 1. trans r &&& irrefl r &&& base_r \\<subseteq> r", "using that"], ["proof (prove)\nusing this:\n  ?r \\<in> C \\<Longrightarrow> strict_ext base_r ?r\n  r \\<in> C\n\ngoal (1 subgoal):\n 1. trans r &&& irrefl r &&& base_r \\<subseteq> r", "by (auto simp add: strict_ext_def strict_partial_order_def)"], ["proof (state)\nthis:\n  ?r \\<in> C \\<Longrightarrow> trans ?r\n  ?r \\<in> C \\<Longrightarrow> irrefl ?r\n  ?r \\<in> C \\<Longrightarrow> base_r \\<subseteq> ?r\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "text \\<open>Because a chain is ordered, the union of the chain is also transitive:\\<close>"], ["proof (state)\nthis:\n  ?r \\<in> C \\<Longrightarrow> trans ?r\n  ?r \\<in> C \\<Longrightarrow> irrefl ?r\n  ?r \\<in> C \\<Longrightarrow> base_r \\<subseteq> ?r\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "have C_ordered: \"r\\<subseteq>s \\<or> s\\<subseteq>r\" if \"r \\<in> C\" and \"s \\<in> C\" for r s"], ["proof (prove)\ngoal (1 subgoal):\n 1. r \\<subseteq> s \\<or> s \\<subseteq> r", "using C_def that"], ["proof (prove)\nusing this:\n  C \\<in> Chains order_of_orders\n  r \\<in> C\n  s \\<in> C\n\ngoal (1 subgoal):\n 1. r \\<subseteq> s \\<or> s \\<subseteq> r", "by (auto simp add: Chains_def order_of_orders_def)"], ["proof (state)\nthis:\n  \\<lbrakk>?r \\<in> C; ?s \\<in> C\\<rbrakk>\n  \\<Longrightarrow> ?r \\<subseteq> ?s \\<or> ?s \\<subseteq> ?r\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "hence \"trans (\\<Union>C)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?r \\<in> C; ?s \\<in> C\\<rbrakk>\n  \\<Longrightarrow> ?r \\<subseteq> ?s \\<or> ?s \\<subseteq> ?r\n\ngoal (1 subgoal):\n 1. trans (\\<Union> C)", "by (simp add: chain_subset_def chain_subset_trans_Union r_trans)"], ["proof (state)\nthis:\n  trans (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "text \\<open>The other properties also can be transferred from the single relations \n       to the union of the chain.\n       Therefore the union is also a strict extension of \\<^term>\\<open>base_r\\<close>: \\<close>"], ["proof (state)\nthis:\n  trans (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "moreover"], ["proof (state)\nthis:\n  trans (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "have \"irrefl (\\<Union>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irrefl (\\<Union> C)", "using irrefl_def r_irrefl"], ["proof (prove)\nusing this:\n  irrefl ?r = (\\<forall>a. (a, a) \\<notin> ?r)\n  ?r \\<in> C \\<Longrightarrow> irrefl ?r\n\ngoal (1 subgoal):\n 1. irrefl (\\<Union> C)", "by auto"], ["proof (state)\nthis:\n  irrefl (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "moreover"], ["proof (state)\nthis:\n  irrefl (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "have \"base_r \\<subseteq> (\\<Union>C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. base_r \\<subseteq> \\<Union> C", "by (simp add: less_eq_Sup r_extends_base that)"], ["proof (state)\nthis:\n  base_r \\<subseteq> \\<Union> C\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "ultimately"], ["proof (chain)\npicking this:\n  trans (\\<Union> C)\n  irrefl (\\<Union> C)\n  base_r \\<subseteq> \\<Union> C", "have \"strict_ext base_r (\\<Union>C)\""], ["proof (prove)\nusing this:\n  trans (\\<Union> C)\n  irrefl (\\<Union> C)\n  base_r \\<subseteq> \\<Union> C\n\ngoal (1 subgoal):\n 1. strict_ext base_r (\\<Union> C)", "by (simp add: show_strict_partial_order strict_ext_def that)"], ["proof (state)\nthis:\n  strict_ext base_r (\\<Union> C)\n\ngoal (2 subgoals):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n 2. \\<Union> C \\<in> Field order_of_orders", "show \"(\\<Union>C) \\<in> Field order_of_orders\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Union> C \\<in> Field order_of_orders", "by (simp add: \\<open>strict_ext base_r (\\<Union> C)\\<close> ord_Field)"], ["proof (state)\nthis:\n  \\<Union> C \\<in> Field order_of_orders\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders", "text \\<open>The union is obviously an upper bound for the chain: \\<close>"], ["proof (state)\nthis:\n  \\<Union> C \\<in> Field order_of_orders\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders", "show \"\\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders", "by (simp add: Sup_upper \\<open>strict_ext base_r (\\<Union> C)\\<close> order_of_orders_def r_se)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>C. (a, \\<Union> C) \\<in> order_of_orders\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?C \\<in> Chains order_of_orders; ?C \\<noteq> {}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>u\\<in>Field order_of_orders.\n                       \\<forall>a\\<in>?C. (a, u) \\<in> order_of_orders\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>m\\<in>Field order_of_orders.\n     \\<forall>a\\<in>Field order_of_orders.\n        (m, a) \\<in> order_of_orders \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "text \\<open>Let our maximal element be named \\<^term>\\<open>max\\<close>:\\<close>"], ["proof (state)\nthis:\n  \\<exists>m\\<in>Field order_of_orders.\n     \\<forall>a\\<in>Field order_of_orders.\n        (m, a) \\<in> order_of_orders \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "from this"], ["proof (chain)\npicking this:\n  \\<exists>m\\<in>Field order_of_orders.\n     \\<forall>a\\<in>Field order_of_orders.\n        (m, a) \\<in> order_of_orders \\<longrightarrow> a = m", "obtain max \n    where max_field: \"max\\<in>Field order_of_orders\"\n      and is_max: \n        \"\\<forall>a\\<in>Field order_of_orders. (max, a) \\<in> order_of_orders \\<longrightarrow> a = max\""], ["proof (prove)\nusing this:\n  \\<exists>m\\<in>Field order_of_orders.\n     \\<forall>a\\<in>Field order_of_orders.\n        (m, a) \\<in> order_of_orders \\<longrightarrow> a = m\n\ngoal (1 subgoal):\n 1. (\\<And>max.\n        \\<lbrakk>max \\<in> Field order_of_orders;\n         \\<forall>a\\<in>Field order_of_orders.\n            (max, a) \\<in> order_of_orders \\<longrightarrow>\n            a = max\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  max \\<in> Field order_of_orders\n  \\<forall>a\\<in>Field order_of_orders.\n     (max, a) \\<in> order_of_orders \\<longrightarrow> a = max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "from max_field"], ["proof (chain)\npicking this:\n  max \\<in> Field order_of_orders", "have max_se: \"strict_ext base_r max\""], ["proof (prove)\nusing this:\n  max \\<in> Field order_of_orders\n\ngoal (1 subgoal):\n 1. strict_ext base_r max", "using ord_Field"], ["proof (prove)\nusing this:\n  max \\<in> Field order_of_orders\n  Field order_of_orders = {r. strict_ext base_r r}\n\ngoal (1 subgoal):\n 1. strict_ext base_r max", "by auto"], ["proof (state)\nthis:\n  strict_ext base_r max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "hence max_spo: \"strict_partial_order max\"\n    and \"base_r \\<subseteq> max\""], ["proof (prove)\nusing this:\n  strict_ext base_r max\n\ngoal (1 subgoal):\n 1. strict_partial_order max &&& base_r \\<subseteq> max", "using strict_ext_def"], ["proof (prove)\nusing this:\n  strict_ext base_r max\n  strict_ext ?base_r ?r \\<equiv>\n  strict_partial_order ?r \\<and> ?base_r \\<subseteq> ?r\n\ngoal (1 subgoal):\n 1. strict_partial_order max &&& base_r \\<subseteq> max", "by auto"], ["proof (state)\nthis:\n  strict_partial_order max\n  base_r \\<subseteq> max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "text \\<open>We still have to show, that \\<^term>\\<open>max\\<close> is a strict linear order, \n  meaning that it is also a total order: \\<close>"], ["proof (state)\nthis:\n  strict_partial_order max\n  base_r \\<subseteq> max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "have \"total max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. total max", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> max \\<or> (y, x) \\<in> max", "fix x y :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> max \\<or> (y, x) \\<in> max", "assume \"x\\<noteq>y\""], ["proof (state)\nthis:\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> UNIV; y \\<in> UNIV; x \\<noteq> y\\<rbrakk>\n       \\<Longrightarrow> (x, y) \\<in> max \\<or> (y, x) \\<in> max", "show \"(x, y) \\<in> max \\<or> (y, x) \\<in> max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x, y) \\<in> max \\<or> (y, x) \\<in> max", "proof (rule ccontr, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "text \\<open>Assume that \\<^term>\\<open>max\\<close> is not total, and \\<^term>\\<open>x\\<close> and \\<^term>\\<open>y\\<close> are incomparable.\n      Then we can extend \\<^term>\\<open>max\\<close> by setting $x < y$:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "assume \"(x, y) \\<notin> max\" and \"(y, x) \\<notin> max\""], ["proof (state)\nthis:\n  (x, y) \\<notin> max\n  (y, x) \\<notin> max\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "let ?max' = \"((max \\<union> {(x, y)})\\<^sup>+)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "from max_spo \\<open>(x, y) \\<notin> max\\<close> \\<open>(y, x) \\<notin> max\\<close> \\<open>x\\<noteq>y\\<close>"], ["proof (chain)\npicking this:\n  strict_partial_order max\n  (x, y) \\<notin> max\n  (y, x) \\<notin> max\n  x \\<noteq> y", "have max'_se_max: \"strict_ext max ?max'\""], ["proof (prove)\nusing this:\n  strict_partial_order max\n  (x, y) \\<notin> max\n  (y, x) \\<notin> max\n  x \\<noteq> y\n\ngoal (1 subgoal):\n 1. strict_ext max ((max \\<union> {(x, y)})\\<^sup>+)", "by (rule can_extend_partial_order)"], ["proof (state)\nthis:\n  strict_ext max ((max \\<union> {(x, y)})\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "hence max'_se: \"strict_ext base_r ?max'\""], ["proof (prove)\nusing this:\n  strict_ext max ((max \\<union> {(x, y)})\\<^sup>+)\n\ngoal (1 subgoal):\n 1. strict_ext base_r ((max \\<union> {(x, y)})\\<^sup>+)", "by (meson \\<open>base_r \\<subseteq> max\\<close> strict_ext_def subset_trans)"], ["proof (state)\nthis:\n  strict_ext base_r ((max \\<union> {(x, y)})\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "text \\<open>The extended relation is greater than \\<^term>\\<open>max\\<close>, which is a contradiction.\\<close>"], ["proof (state)\nthis:\n  strict_ext base_r ((max \\<union> {(x, y)})\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "have \"(max, ?max')\\<in>order_of_orders\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (max, (max \\<union> {(x, y)})\\<^sup>+) \\<in> order_of_orders", "using max'_se"], ["proof (prove)\nusing this:\n  strict_ext base_r ((max \\<union> {(x, y)})\\<^sup>+)\n\ngoal (1 subgoal):\n 1. (max, (max \\<union> {(x, y)})\\<^sup>+) \\<in> order_of_orders", "by (auto simp add: order_of_orders_def max_se)"], ["proof (state)\nthis:\n  (max, (max \\<union> {(x, y)})\\<^sup>+) \\<in> order_of_orders\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(x, y) \\<notin> max; (y, x) \\<notin> max\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  (max, (max \\<union> {(x, y)})\\<^sup>+) \\<in> order_of_orders\n\ngoal (1 subgoal):\n 1. False", "using FieldI2 \\<open>(x, y) \\<notin> max\\<close> is_max"], ["proof (prove)\nusing this:\n  (max, (max \\<union> {(x, y)})\\<^sup>+) \\<in> order_of_orders\n  (?i, ?j) \\<in> ?R \\<Longrightarrow> ?j \\<in> Field ?R\n  (x, y) \\<notin> max\n  \\<forall>a\\<in>Field order_of_orders.\n     (max, a) \\<in> order_of_orders \\<longrightarrow> a = max\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (x, y) \\<in> max \\<or> (y, x) \\<in> max\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  total max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "with max_spo"], ["proof (chain)\npicking this:\n  strict_partial_order max\n  total max", "have \"strict_linear_order max\""], ["proof (prove)\nusing this:\n  strict_partial_order max\n  total max\n\ngoal (1 subgoal):\n 1. strict_linear_order max", "by (auto simp add: strict_linear_order_def)"], ["proof (state)\nthis:\n  strict_linear_order max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "with \\<open>base_r \\<subseteq> max\\<close>"], ["proof (chain)\npicking this:\n  base_r \\<subseteq> max\n  strict_linear_order max", "show \"\\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\""], ["proof (prove)\nusing this:\n  base_r \\<subseteq> max\n  strict_linear_order max\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "by auto"], ["proof (state)\nthis:\n  \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>As a corollary, we can also show that we can extend any \\<^term>\\<open>acyclic\\<close> relation\nto a strict linear order: \\<close>"], ["", "corollary can_extend_acyclic_order_to_strict_linear:\n  assumes \"acyclic base_r\"\n  shows \"\\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "have \"strict_partial_order (base_r\\<^sup>+)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_partial_order (base_r\\<^sup>+)", "using acyclic_irrefl assms trans_trancl"], ["proof (prove)\nusing this:\n  acyclic ?r = irrefl (?r\\<^sup>+)\n  acyclic base_r\n  trans (?r\\<^sup>+)\n\ngoal (1 subgoal):\n 1. strict_partial_order (base_r\\<^sup>+)", "by blast"], ["proof (state)\nthis:\n  strict_partial_order (base_r\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "thus ?thesis"], ["proof (prove)\nusing this:\n  strict_partial_order (base_r\\<^sup>+)\n\ngoal (1 subgoal):\n 1. \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r", "by (meson Szpilrajn r_into_trancl' subset_iff)"], ["proof (state)\nthis:\n  \\<exists>r. strict_linear_order r \\<and> base_r \\<subseteq> r\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Let us conclude with an example, showing that there exists a strict linear \norder on sets, which includes the subset relation:\\<close>"], ["", "lemma exists_strict_partial_order_on_sets:\n  shows \"\\<exists>r. strict_linear_order r \\<and> {(x,y). x \\<subset> y} \\<subseteq> r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r.\n       strict_linear_order r \\<and> {(x, y). x \\<subset> y} \\<subseteq> r", "using strict_partial_order_subset"], ["proof (prove)\nusing this:\n  strict_partial_order {(x, y). x \\<subset> y}\n\ngoal (1 subgoal):\n 1. \\<exists>r.\n       strict_linear_order r \\<and> {(x, y). x \\<subset> y} \\<subseteq> r", "by (rule Szpilrajn)"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}