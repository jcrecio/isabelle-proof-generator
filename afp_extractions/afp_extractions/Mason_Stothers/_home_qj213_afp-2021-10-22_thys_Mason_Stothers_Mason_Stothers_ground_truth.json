{"file_name": "/home/qj213/afp-2021-10-22/thys/Mason_Stothers/Mason_Stothers.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Mason_Stothers", "problem_names": ["lemma degree_div:\n  assumes \"a dvd b\"\n  shows   \"degree (b div a) = degree b - degree a\"", "lemma degree_pderiv_le:\n  shows   \"degree (pderiv p) \\<le> degree p - 1\"", "lemma degree_pderiv_less:\n  assumes \"pderiv p \\<noteq> 0\"\n  shows   \"degree (pderiv p) < degree p\"", "lemma pderiv_eq_0:\n  assumes \"degree p = 0\"\n  shows   \"pderiv p = 0\"", "lemma radical_0 [simp]: \"radical 0 = 0\"", "lemma radical_nonzero: \"x \\<noteq> 0 \\<Longrightarrow> radical x = \\<Prod>(prime_factors x)\"", "lemma radical_eq_0_iff [simp]: \"radical x = 0 \\<longleftrightarrow> x = 0\"", "lemma prime_factorization_radical [simp]:\n  assumes \"x \\<noteq> 0\"\n  shows   \"prime_factorization (radical x) = mset_set (prime_factors x)\"", "lemma prime_factors_radical [simp]: \"x \\<noteq> 0 \\<Longrightarrow> prime_factors (radical x) = prime_factors x\"", "lemma radical_dvd [simp, intro]: \"radical x dvd x\"", "lemma multiplicity_radical_prime:\n  assumes \"prime p\" \"x \\<noteq> 0\"\n  shows   \"multiplicity p (radical x) = (if p dvd x then 1 else 0)\"", "lemma radical_1 [simp]: \"radical 1 = 1\"", "lemma radical_unit [simp]: \"is_unit x \\<Longrightarrow> radical x = 1\"", "lemma prime_factors_power:\n  assumes \"n > 0\"\n  shows   \"prime_factors (x ^ n) = prime_factors x\"", "lemma radical_power [simp]: \"n > 0 \\<Longrightarrow> radical (x ^ n) = radical x\"", "lemma radical_mult_coprime:\n  assumes \"coprime a b\"\n  shows   \"radical (a * b) = radical a * radical b\"", "lemma multiplicity_le_imp_dvd':\n  assumes \"x \\<noteq> 0\" \"\\<And>p. p \\<in> prime_factors x \\<Longrightarrow> multiplicity p x \\<le> multiplicity p y\"\n  shows   \"x dvd y\"", "lemma prime_power_dvd_pderiv:\n  fixes f p :: \"'a :: field_gcd poly\"\n  assumes \"prime_elem p\"\n  defines \"n \\<equiv> multiplicity p f - 1\"\n  shows   \"p ^ n dvd pderiv f\"", "lemma poly_div_radical_dvd_pderiv:\n  fixes p :: \"'a :: field_gcd poly\"\n  shows \"p div radical p dvd pderiv p\"", "lemma degree_pderiv_mult_less:\n  assumes \"pderiv C \\<noteq> 0\"\n  shows   \"degree (pderiv C * B) < degree B + degree C\"", "lemma Mason_Stothers_aux:\n  fixes A B C :: \"'a :: field_gcd poly\"\n  assumes nz: \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\" and sum: \"A + B + C = 0\" and coprime: \"Gcd {A, B, C} = 1\" \n     and deg_ge: \"degree A \\<ge> degree (radical (A * B * C))\"\n   shows \"pderiv A = 0\" \"pderiv B = 0\" \"pderiv C = 0\"", "theorem Mason_Stothers:\n  fixes A B C :: \"'a :: field_gcd poly\"\n  assumes nz: \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\" \"\\<exists>p\\<in>{A,B,C}. pderiv p \\<noteq> 0\" \n      and sum: \"A + B + C = 0\" and coprime: \"Gcd {A, B, C} = 1\" \n    shows \"Max {degree A, degree B, degree C} < degree (radical (A * B * C))\""], "translations": [["", "lemma degree_div:\n  assumes \"a dvd b\"\n  shows   \"degree (b div a) = degree b - degree a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (b div a) = degree b - degree a", "using assms"], ["proof (prove)\nusing this:\n  a dvd b\n\ngoal (1 subgoal):\n 1. degree (b div a) = degree b - degree a", "by (cases \"a = 0\"; cases \"b = 0\") (auto elim!: dvdE simp: degree_mult_eq)"], ["", "lemma degree_pderiv_le:\n  shows   \"degree (pderiv p) \\<le> degree p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv p) \\<le> degree p - 1", "by (rule degree_le, cases \"degree p = 0\") (auto simp: coeff_pderiv coeff_eq_0)"], ["", "lemma degree_pderiv_less:\n  assumes \"pderiv p \\<noteq> 0\"\n  shows   \"degree (pderiv p) < degree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "have \"degree (pderiv p) \\<le> degree p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv p) \\<le> degree p - 1", "by (rule degree_pderiv_le)"], ["proof (state)\nthis:\n  degree (pderiv p) \\<le> degree p - 1\n\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "also"], ["proof (state)\nthis:\n  degree (pderiv p) \\<le> degree p - 1\n\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "have \"degree p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p \\<noteq> 0", "by (auto intro!: Nat.gr0I elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "hence \"degree p - 1 < degree p\""], ["proof (prove)\nusing this:\n  degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree p - 1 < degree p", "by simp"], ["proof (state)\nthis:\n  degree p - 1 < degree p\n\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "finally"], ["proof (chain)\npicking this:\n  degree (pderiv p) < degree p", "show ?thesis"], ["proof (prove)\nusing this:\n  degree (pderiv p) < degree p\n\ngoal (1 subgoal):\n 1. degree (pderiv p) < degree p", "."], ["proof (state)\nthis:\n  degree (pderiv p) < degree p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pderiv_eq_0:\n  assumes \"degree p = 0\"\n  shows   \"pderiv p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv p = 0", "using assms"], ["proof (prove)\nusing this:\n  degree p = 0\n\ngoal (1 subgoal):\n 1. pderiv p = 0", "by (auto elim!: degree_eq_zeroE)"], ["", "subsection \\<open>Definition of a radical\\<close>"], ["", "text \\<open>\n  The following definition of a radical is generic for any factorial semiring.\n\\<close>"], ["", "context factorial_semiring\nbegin"], ["", "definition radical :: \"'a \\<Rightarrow> 'a\" where\n  \"radical x = (if x = 0 then 0 else \\<Prod>(prime_factors x))\""], ["", "lemma radical_0 [simp]: \"radical 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical (0::'a) = (0::'a)", "by (simp add: radical_def)"], ["", "lemma radical_nonzero: \"x \\<noteq> 0 \\<Longrightarrow> radical x = \\<Prod>(prime_factors x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    radical x = \\<Prod>(prime_factors x)", "by (simp add: radical_def)"], ["", "lemma radical_eq_0_iff [simp]: \"radical x = 0 \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (radical x = (0::'a)) = (x = (0::'a))", "by (auto simp: radical_def)"], ["", "lemma prime_factorization_radical [simp]:\n  assumes \"x \\<noteq> 0\"\n  shows   \"prime_factorization (radical x) = mset_set (prime_factors x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "have \"prime_factorization (radical x) = (\\<Sum>p\\<in>prime_factors x. prime_factorization p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization (radical x) =\n    sum prime_factorization (prime_factors x)", "unfolding radical_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factorization\n     (if x = (0::'a) then 0::'a else \\<Prod>(prime_factors x)) =\n    sum prime_factorization (prime_factors x)", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. prime_factorization\n     (if x = (0::'a) then 0::'a else \\<Prod>(prime_factors x)) =\n    sum prime_factorization (prime_factors x)", "by (auto intro!: prime_factorization_prod)"], ["proof (state)\nthis:\n  prime_factorization (radical x) =\n  sum prime_factorization (prime_factors x)\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "also"], ["proof (state)\nthis:\n  prime_factorization (radical x) =\n  sum prime_factorization (prime_factors x)\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "have \"\\<dots> = (\\<Sum>p\\<in>prime_factors x. {#p#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum prime_factorization (prime_factors x) =\n    (\\<Sum>p\\<in>prime_factors x. {#p#})", "by (intro Groups_Big.sum.cong) (auto intro!: prime_factorization_prime)"], ["proof (state)\nthis:\n  sum prime_factorization (prime_factors x) =\n  (\\<Sum>p\\<in>prime_factors x. {#p#})\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "also"], ["proof (state)\nthis:\n  sum prime_factorization (prime_factors x) =\n  (\\<Sum>p\\<in>prime_factors x. {#p#})\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "have \"\\<dots> = mset_set (prime_factors x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>prime_factors x. {#p#}) = mset_set (prime_factors x)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>prime_factors x. {#p#}) = mset_set (prime_factors x)\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "finally"], ["proof (chain)\npicking this:\n  prime_factorization (radical x) = mset_set (prime_factors x)", "show ?thesis"], ["proof (prove)\nusing this:\n  prime_factorization (radical x) = mset_set (prime_factors x)\n\ngoal (1 subgoal):\n 1. prime_factorization (radical x) = mset_set (prime_factors x)", "."], ["proof (state)\nthis:\n  prime_factorization (radical x) = mset_set (prime_factors x)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prime_factors_radical [simp]: \"x \\<noteq> 0 \\<Longrightarrow> prime_factors (radical x) = prime_factors x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow>\n    prime_factors (radical x) = prime_factors x", "by simp"], ["", "lemma radical_dvd [simp, intro]: \"radical x dvd x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical x dvd x", "by (cases \"x = 0\") (force intro: prime_factorization_subset_imp_dvd mset_set_set_mset_msubset)+"], ["", "lemma multiplicity_radical_prime:\n  assumes \"prime p\" \"x \\<noteq> 0\"\n  shows   \"multiplicity p (radical x) = (if p dvd x then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "have \"multiplicity p (radical x) = (\\<Sum>q\\<in>prime_factors x. multiplicity p q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = sum (multiplicity p) (prime_factors x)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = sum (multiplicity p) (prime_factors x)", "unfolding radical_def"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. multiplicity p\n     (if x = (0::'a) then 0::'a else \\<Prod>(prime_factors x)) =\n    sum (multiplicity p) (prime_factors x)", "by (auto simp: prime_elem_multiplicity_prod_distrib)"], ["proof (state)\nthis:\n  multiplicity p (radical x) = sum (multiplicity p) (prime_factors x)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "also"], ["proof (state)\nthis:\n  multiplicity p (radical x) = sum (multiplicity p) (prime_factors x)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "have \"\\<dots> = (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (multiplicity p) (prime_factors x) =\n    (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. sum (multiplicity p) (prime_factors x) =\n    (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0)", "by (intro Groups_Big.sum.cong) (auto intro!: prime_multiplicity_other)"], ["proof (state)\nthis:\n  sum (multiplicity p) (prime_factors x) =\n  (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "also"], ["proof (state)\nthis:\n  sum (multiplicity p) (prime_factors x) =\n  (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "have \"\\<dots> = (if p \\<in> prime_factors x then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0) =\n    (if p \\<in> prime_factors x then 1 else 0)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0) =\n  (if p \\<in> prime_factors x then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>prime_factors x. if p = q then 1 else 0) =\n  (if p \\<in> prime_factors x then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "have \"\\<dots> = (if p dvd x then 1 else 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if p \\<in> prime_factors x then 1 else 0) = (if p dvd x then 1 else 0)", "using assms"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (if p \\<in> prime_factors x then 1 else 0) = (if p dvd x then 1 else 0)", "by (auto simp: prime_factors_dvd)"], ["proof (state)\nthis:\n  (if p \\<in> prime_factors x then 1 else 0) = (if p dvd x then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "finally"], ["proof (chain)\npicking this:\n  multiplicity p (radical x) = (if p dvd x then 1 else 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  multiplicity p (radical x) = (if p dvd x then 1 else 0)\n\ngoal (1 subgoal):\n 1. multiplicity p (radical x) = (if p dvd x then 1 else 0)", "."], ["proof (state)\nthis:\n  multiplicity p (radical x) = (if p dvd x then 1 else 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma radical_1 [simp]: \"radical 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical (1::'a) = (1::'a)", "by (simp add: radical_def)"], ["", "lemma radical_unit [simp]: \"is_unit x \\<Longrightarrow> radical x = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit x \\<Longrightarrow> radical x = (1::'a)", "by (auto simp: radical_def prime_factorization_unit)"], ["", "lemma prime_factors_power:\n  assumes \"n > 0\"\n  shows   \"prime_factors (x ^ n) = prime_factors x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime_factors (x ^ n) = prime_factors x", "using assms"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. prime_factors (x ^ n) = prime_factors x", "by (cases \"x = 0\") (auto simp: prime_factors_dvd zero_power prime_dvd_power_iff)"], ["", "lemma radical_power [simp]: \"n > 0 \\<Longrightarrow> radical (x ^ n) = radical x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> radical (x ^ n) = radical x", "by (auto simp add: radical_def prime_factors_power)"], ["", "end"], ["", "context factorial_semiring_gcd\nbegin"], ["", "lemma radical_mult_coprime:\n  assumes \"coprime a b\"\n  shows   \"radical (a * b) = radical a * radical b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical (a * b) = radical a * radical b", "proof (cases \"a = 0 \\<or> b = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b", "case False"], ["proof (state)\nthis:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b", "with assms"], ["proof (chain)\npicking this:\n  coprime a b\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))", "have \"prime_factors a \\<inter> prime_factors b = {}\""], ["proof (prove)\nusing this:\n  coprime a b\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n\ngoal (1 subgoal):\n 1. prime_factors a \\<inter> prime_factors b = {}", "using not_prime_unit coprime_common_divisor"], ["proof (prove)\nusing this:\n  coprime a b\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n  is_unit ?x \\<Longrightarrow> \\<not> prime ?x\n  \\<lbrakk>coprime ?a ?b; ?c dvd ?a; ?c dvd ?b\\<rbrakk>\n  \\<Longrightarrow> is_unit ?c\n\ngoal (1 subgoal):\n 1. prime_factors a \\<inter> prime_factors b = {}", "by (auto simp: prime_factors_dvd)"], ["proof (state)\nthis:\n  prime_factors a \\<inter> prime_factors b = {}\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b", "hence \"\\<Prod>(prime_factors a \\<union> prime_factors b) = \\<Prod>(prime_factors a) * \\<Prod>(prime_factors b)\""], ["proof (prove)\nusing this:\n  prime_factors a \\<inter> prime_factors b = {}\n\ngoal (1 subgoal):\n 1. \\<Prod>(prime_factors a \\<union> prime_factors b) =\n    \\<Prod>(prime_factors a) * \\<Prod>(prime_factors b)", "by (intro prod.union_disjoint) auto"], ["proof (state)\nthis:\n  \\<Prod>(prime_factors a \\<union> prime_factors b) =\n  \\<Prod>(prime_factors a) * \\<Prod>(prime_factors b)\n\ngoal (2 subgoals):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b\n 2. \\<not> (a = (0::'a) \\<or> b = (0::'a)) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b", "with False"], ["proof (chain)\npicking this:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n  \\<Prod>(prime_factors a \\<union> prime_factors b) =\n  \\<Prod>(prime_factors a) * \\<Prod>(prime_factors b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (a = (0::'a) \\<or> b = (0::'a))\n  \\<Prod>(prime_factors a \\<union> prime_factors b) =\n  \\<Prod>(prime_factors a) * \\<Prod>(prime_factors b)\n\ngoal (1 subgoal):\n 1. radical (a * b) = radical a * radical b", "by (simp add: radical_def prime_factorization_mult)"], ["proof (state)\nthis:\n  radical (a * b) = radical a * radical b\n\ngoal (1 subgoal):\n 1. a = (0::'a) \\<or> b = (0::'a) \\<Longrightarrow>\n    radical (a * b) = radical a * radical b", "qed auto"], ["", "lemma multiplicity_le_imp_dvd':\n  assumes \"x \\<noteq> 0\" \"\\<And>p. p \\<in> prime_factors x \\<Longrightarrow> multiplicity p x \\<le> multiplicity p y\"\n  shows   \"x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x dvd y", "proof (rule multiplicity_le_imp_dvd)"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p x \\<le> multiplicity p y", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p x \\<le> multiplicity p y", "assume \"prime p\""], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. x \\<noteq> (0::'a)\n 2. \\<And>p.\n       prime p \\<Longrightarrow> multiplicity p x \\<le> multiplicity p y", "thus \"multiplicity p x \\<le> multiplicity p y\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. multiplicity p x \\<le> multiplicity p y", "using assms(1) assms(2)[of p]"], ["proof (prove)\nusing this:\n  prime p\n  x \\<noteq> (0::'a)\n  p \\<in> prime_factors x \\<Longrightarrow>\n  multiplicity p x \\<le> multiplicity p y\n\ngoal (1 subgoal):\n 1. multiplicity p x \\<le> multiplicity p y", "by (cases \"p dvd x\") (auto simp: prime_factors_dvd not_dvd_imp_multiplicity_0)"], ["proof (state)\nthis:\n  multiplicity p x \\<le> multiplicity p y\n\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a)", "qed fact+"], ["", "end"], ["", "subsection \\<open>Main result\\<close>"], ["", "text \\<open>\n  The following proofs are basically a one-to-one translation of Franz Lemmermeyer's\n  presentation~\\cite{lemmermeyer05} of Snyder's proof of the Mason--Stothers theorem.\n\\<close>"], ["", "lemma prime_power_dvd_pderiv:\n  fixes f p :: \"'a :: field_gcd poly\"\n  assumes \"prime_elem p\"\n  defines \"n \\<equiv> multiplicity p f - 1\"\n  shows   \"p ^ n dvd pderiv f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n dvd pderiv f", "proof (cases \"p dvd f \\<and> f \\<noteq> 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "case True"], ["proof (state)\nthis:\n  p dvd f \\<and> f \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "hence \"multiplicity p f > 0\""], ["proof (prove)\nusing this:\n  p dvd f \\<and> f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < multiplicity p f", "using assms"], ["proof (prove)\nusing this:\n  p dvd f \\<and> f \\<noteq> 0\n  prime_elem p\n  n \\<equiv> multiplicity p f - 1\n\ngoal (1 subgoal):\n 1. 0 < multiplicity p f", "by (subst prime_multiplicity_gt_zero_iff) auto"], ["proof (state)\nthis:\n  0 < multiplicity p f\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "hence Suc_n: \"Suc n = multiplicity p f\""], ["proof (prove)\nusing this:\n  0 < multiplicity p f\n\ngoal (1 subgoal):\n 1. Suc n = multiplicity p f", "by (simp add: n_def)"], ["proof (state)\nthis:\n  Suc n = multiplicity p f\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "define g where \"g = f div p ^ Suc n\""], ["proof (state)\nthis:\n  g = f div p ^ Suc n\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "have \"p ^ Suc n dvd f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ Suc n dvd f", "unfolding Suc_n"], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ multiplicity p f dvd f", "by (rule multiplicity_dvd)"], ["proof (state)\nthis:\n  p ^ Suc n dvd f\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "hence f_eq: \"f = p ^ Suc n * g\""], ["proof (prove)\nusing this:\n  p ^ Suc n dvd f\n\ngoal (1 subgoal):\n 1. f = p ^ Suc n * g", "by (simp add: g_def)"], ["proof (state)\nthis:\n  f = p ^ Suc n * g\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "also"], ["proof (state)\nthis:\n  f = p ^ Suc n * g\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "have \"pderiv \\<dots> = p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv (p ^ Suc n * g) =\n    p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)", "by (simp only: pderiv_mult pderiv_power_Suc) (simp add: algebra_simps)"], ["proof (state)\nthis:\n  pderiv (p ^ Suc n * g) =\n  p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "also"], ["proof (state)\nthis:\n  pderiv (p ^ Suc n * g) =\n  p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "have \"p ^ n dvd \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p ^ n dvd p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)", "by simp"], ["proof (state)\nthis:\n  p ^ n dvd p ^ n * (smult (of_nat (Suc n)) (pderiv p * g) + p * pderiv g)\n\ngoal (2 subgoals):\n 1. p dvd f \\<and> f \\<noteq> 0 \\<Longrightarrow> p ^ n dvd pderiv f\n 2. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "finally"], ["proof (chain)\npicking this:\n  p ^ n dvd pderiv f", "show ?thesis"], ["proof (prove)\nusing this:\n  p ^ n dvd pderiv f\n\ngoal (1 subgoal):\n 1. p ^ n dvd pderiv f", "."], ["proof (state)\nthis:\n  p ^ n dvd pderiv f\n\ngoal (1 subgoal):\n 1. \\<not> (p dvd f \\<and> f \\<noteq> 0) \\<Longrightarrow>\n    p ^ n dvd pderiv f", "qed (auto simp: n_def not_dvd_imp_multiplicity_0)"], ["", "lemma poly_div_radical_dvd_pderiv:\n  fixes p :: \"'a :: field_gcd poly\"\n  shows \"p div radical p dvd pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p div radical p dvd pderiv p", "proof (cases \"pderiv p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> p div radical p dvd pderiv p\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow> p div radical p dvd pderiv p", "case False"], ["proof (state)\nthis:\n  pderiv p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> p div radical p dvd pderiv p\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow> p div radical p dvd pderiv p", "hence \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. pderiv p = 0 \\<Longrightarrow> p div radical p dvd pderiv p\n 2. pderiv p \\<noteq> 0 \\<Longrightarrow> p div radical p dvd pderiv p", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. p div radical p dvd pderiv p", "proof (rule multiplicity_le_imp_dvd')"], ["proof (state)\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "fix q :: \"'a poly\""], ["proof (state)\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "assume q: \"q \\<in> prime_factors (p div radical p)\""], ["proof (state)\nthis:\n  q \\<in># prime_factorization (p div radical p)\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "hence \"q dvd p div radical p\""], ["proof (prove)\nusing this:\n  q \\<in># prime_factorization (p div radical p)\n\ngoal (1 subgoal):\n 1. q dvd p div radical p", "by auto"], ["proof (state)\nthis:\n  q dvd p div radical p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "also"], ["proof (state)\nthis:\n  q dvd p div radical p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "from \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  p \\<noteq> 0", "have \"\\<dots> dvd p\""], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p div radical p dvd p", "by (subst div_dvd_iff_mult) auto"], ["proof (state)\nthis:\n  p div radical p dvd p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "finally"], ["proof (chain)\npicking this:\n  q dvd p", "have \"q dvd p\""], ["proof (prove)\nusing this:\n  q dvd p\n\ngoal (1 subgoal):\n 1. q dvd p", "."], ["proof (state)\nthis:\n  q dvd p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "have \"p = p div radical p * radical p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p div radical p * radical p", "by simp"], ["proof (state)\nthis:\n  p = p div radical p * radical p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "also"], ["proof (state)\nthis:\n  p = p div radical p * radical p\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "from q and \\<open>p \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  q \\<in># prime_factorization (p div radical p)\n  p \\<noteq> 0", "have \"multiplicity q \\<dots> = Suc (multiplicity q (p div radical p))\""], ["proof (prove)\nusing this:\n  q \\<in># prime_factorization (p div radical p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity q (p div radical p * radical p) =\n    Suc (multiplicity q (p div radical p))", "by (subst prime_elem_multiplicity_mult_distrib)\n         (auto simp: dvd_div_eq_0_iff multiplicity_radical_prime \\<open>q dvd p\\<close> prime_factors_dvd)"], ["proof (state)\nthis:\n  multiplicity q (p div radical p * radical p) =\n  Suc (multiplicity q (p div radical p))\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "finally"], ["proof (chain)\npicking this:\n  multiplicity q p = Suc (multiplicity q (p div radical p))", "have \"multiplicity q (p div radical p) \\<le> multiplicity q p - 1\""], ["proof (prove)\nusing this:\n  multiplicity q p = Suc (multiplicity q (p div radical p))\n\ngoal (1 subgoal):\n 1. multiplicity q (p div radical p) \\<le> multiplicity q p - 1", "by simp"], ["proof (state)\nthis:\n  multiplicity q (p div radical p) \\<le> multiplicity q p - 1\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "also"], ["proof (state)\nthis:\n  multiplicity q (p div radical p) \\<le> multiplicity q p - 1\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "have \"\\<dots> \\<le> multiplicity q (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. multiplicity q p - 1 \\<le> multiplicity q (pderiv p)", "using \\<open>pderiv p \\<noteq> 0\\<close> and q and \\<open>p \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  pderiv p \\<noteq> 0\n  q \\<in># prime_factorization (p div radical p)\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. multiplicity q p - 1 \\<le> multiplicity q (pderiv p)", "by (intro multiplicity_geI prime_power_dvd_pderiv)\n         (auto simp: prime_factors_dvd dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  multiplicity q p - 1 \\<le> multiplicity q (pderiv p)\n\ngoal (2 subgoals):\n 1. p div radical p \\<noteq> 0\n 2. \\<And>pa.\n       pa \\<in># prime_factorization (p div radical p) \\<Longrightarrow>\n       multiplicity pa (p div radical p) \\<le> multiplicity pa (pderiv p)", "finally"], ["proof (chain)\npicking this:\n  multiplicity q (p div radical p) \\<le> multiplicity q (pderiv p)", "show \"multiplicity q (p div radical p) \\<le> multiplicity q (pderiv p)\""], ["proof (prove)\nusing this:\n  multiplicity q (p div radical p) \\<le> multiplicity q (pderiv p)\n\ngoal (1 subgoal):\n 1. multiplicity q (p div radical p) \\<le> multiplicity q (pderiv p)", "."], ["proof (state)\nthis:\n  multiplicity q (p div radical p) \\<le> multiplicity q (pderiv p)\n\ngoal (1 subgoal):\n 1. p div radical p \\<noteq> 0", "qed (insert \\<open>p \\<noteq> 0\\<close>, auto simp: dvd_div_eq_0_iff)"], ["proof (state)\nthis:\n  p div radical p dvd pderiv p\n\ngoal (1 subgoal):\n 1. pderiv p = 0 \\<Longrightarrow> p div radical p dvd pderiv p", "qed auto"], ["", "lemma degree_pderiv_mult_less:\n  assumes \"pderiv C \\<noteq> 0\"\n  shows   \"degree (pderiv C * B) < degree B + degree C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "have \"degree (pderiv C * B) \\<le> degree (pderiv C) + degree B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv C * B) \\<le> degree (pderiv C) + degree B", "by (rule degree_mult_le)"], ["proof (state)\nthis:\n  degree (pderiv C * B) \\<le> degree (pderiv C) + degree B\n\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "also"], ["proof (state)\nthis:\n  degree (pderiv C * B) \\<le> degree (pderiv C) + degree B\n\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "from assms"], ["proof (chain)\npicking this:\n  pderiv C \\<noteq> 0", "have \"degree (pderiv C) < degree C\""], ["proof (prove)\nusing this:\n  pderiv C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (pderiv C) < degree C", "by (rule degree_pderiv_less)"], ["proof (state)\nthis:\n  degree (pderiv C) < degree C\n\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow> x + degree B < y + degree B) \\<Longrightarrow>\n  degree (pderiv C * B) < degree C + degree B", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x < y \\<Longrightarrow> x + degree B < y + degree B) \\<Longrightarrow>\n  degree (pderiv C * B) < degree C + degree B\n\ngoal (1 subgoal):\n 1. degree (pderiv C * B) < degree B + degree C", "by simp"], ["proof (state)\nthis:\n  degree (pderiv C * B) < degree B + degree C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Mason_Stothers_aux:\n  fixes A B C :: \"'a :: field_gcd poly\"\n  assumes nz: \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\" and sum: \"A + B + C = 0\" and coprime: \"Gcd {A, B, C} = 1\" \n     and deg_ge: \"degree A \\<ge> degree (radical (A * B * C))\"\n   shows \"pderiv A = 0\" \"pderiv B = 0\" \"pderiv C = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv A = 0 &&& pderiv B = 0 &&& pderiv C = 0", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have C_eq: \"C = -A - B\" \"-C = A + B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C = - A - B &&& - C = A + B", "using sum"], ["proof (prove)\nusing this:\n  A + B + C = 0\n\ngoal (1 subgoal):\n 1. C = - A - B &&& - C = A + B", "by algebra+"], ["proof (state)\nthis:\n  C = - A - B\n  - C = A + B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "from coprime"], ["proof (chain)\npicking this:\n  Gcd {A, B, C} = 1", "have \"gcd A (gcd B (-C)) = 1\""], ["proof (prove)\nusing this:\n  Gcd {A, B, C} = 1\n\ngoal (1 subgoal):\n 1. gcd A (gcd B (- C)) = 1", "by simp"], ["proof (state)\nthis:\n  gcd A (gcd B (- C)) = 1\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "also"], ["proof (state)\nthis:\n  gcd A (gcd B (- C)) = 1\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "note C_eq(2)"], ["proof (state)\nthis:\n  - C = A + B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "finally"], ["proof (chain)\npicking this:\n  gcd A (gcd B (A + B)) = 1", "have \"coprime A B\""], ["proof (prove)\nusing this:\n  gcd A (gcd B (A + B)) = 1\n\ngoal (1 subgoal):\n 1. coprime A B", "by (simp add: gcd.commute add.commute[of A B] coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  coprime A B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "hence \"coprime A (-C)\" \"coprime B (-C)\""], ["proof (prove)\nusing this:\n  coprime A B\n\ngoal (1 subgoal):\n 1. coprime A (- C) &&& coprime B (- C)", "unfolding C_eq"], ["proof (prove)\nusing this:\n  coprime A B\n\ngoal (1 subgoal):\n 1. coprime A (- (- A - B)) &&& coprime B (- (- A - B))", "by (simp_all add: gcd.commute[of B A] gcd.commute[of B \"A + B\"]\n                                     add.commute coprime_iff_gcd_eq_1)"], ["proof (state)\nthis:\n  coprime A (- C)\n  coprime B (- C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "hence \"coprime A C\" \"coprime B C\""], ["proof (prove)\nusing this:\n  coprime A (- C)\n  coprime B (- C)\n\ngoal (1 subgoal):\n 1. coprime A C &&& coprime B C", "by simp_all"], ["proof (state)\nthis:\n  coprime A C\n  coprime B C\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "note coprime = coprime \\<open>coprime A B\\<close> this"], ["proof (state)\nthis:\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have coprime1: \"coprime (A div radical A) (B div radical B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (A div radical A) (B div radical B)", "by (rule coprime_divisors[OF _ _ \\<open>coprime A B\\<close>]) (insert nz, auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  coprime (A div radical A) (B div radical B)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have coprime2: \"coprime (A div radical A) (C div radical C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (A div radical A) (C div radical C)", "by (rule coprime_divisors[OF _ _ \\<open>coprime A C\\<close>]) (insert nz, auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  coprime (A div radical A) (C div radical C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have coprime3: \"coprime (B div radical B) (C div radical C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (B div radical B) (C div radical C)", "by (rule coprime_divisors[OF _ _ \\<open>coprime B C\\<close>]) (insert nz, auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  coprime (B div radical B) (C div radical C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have coprime4: \"coprime (A div radical A * (B div radical B)) (C div radical C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coprime (A div radical A * (B div radical B)) (C div radical C)", "using coprime2 coprime3"], ["proof (prove)\nusing this:\n  coprime (A div radical A) (C div radical C)\n  coprime (B div radical B) (C div radical C)\n\ngoal (1 subgoal):\n 1. coprime (A div radical A * (B div radical B)) (C div radical C)", "by (subst coprime_mult_left_iff) auto"], ["proof (state)\nthis:\n  coprime (A div radical A * (B div radical B)) (C div radical C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have eq: \"A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B", "by (simp add: C_eq pderiv_add pderiv_diff pderiv_minus algebra_simps)"], ["proof (state)\nthis:\n  A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"A div radical A dvd (A * pderiv B - pderiv A * B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A div radical A dvd A * pderiv B - pderiv A * B", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. A div radical A dvd A * pderiv B - pderiv A * B", "by (intro dvd_diff dvd_mult2 poly_div_radical_dvd_pderiv) (auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  A div radical A dvd A * pderiv B - pderiv A * B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "with eq"], ["proof (chain)\npicking this:\n  A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\n  A div radical A dvd A * pderiv B - pderiv A * B", "have \"A div radical A dvd (pderiv C * B - C * pderiv B)\""], ["proof (prove)\nusing this:\n  A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\n  A div radical A dvd A * pderiv B - pderiv A * B\n\ngoal (1 subgoal):\n 1. A div radical A dvd pderiv C * B - C * pderiv B", "by simp"], ["proof (state)\nthis:\n  A div radical A dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "moreover"], ["proof (state)\nthis:\n  A div radical A dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"C div radical C dvd (pderiv C * B - C * pderiv B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C div radical C dvd pderiv C * B - C * pderiv B", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. C div radical C dvd pderiv C * B - C * pderiv B", "by (intro dvd_diff dvd_mult2 poly_div_radical_dvd_pderiv) (auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  C div radical C dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "moreover"], ["proof (state)\nthis:\n  C div radical C dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"B div radical B dvd (pderiv C * B - C * pderiv B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B div radical B dvd pderiv C * B - C * pderiv B", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. B div radical B dvd pderiv C * B - C * pderiv B", "by (intro dvd_diff dvd_mult poly_div_radical_dvd_pderiv) (auto simp: div_dvd_iff_mult)"], ["proof (state)\nthis:\n  B div radical B dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "ultimately"], ["proof (chain)\npicking this:\n  A div radical A dvd pderiv C * B - C * pderiv B\n  C div radical C dvd pderiv C * B - C * pderiv B\n  B div radical B dvd pderiv C * B - C * pderiv B", "have \"(A div radical A) * (B div radical B) * (C div radical C) dvd \n                     (pderiv C * B - C * pderiv B)\""], ["proof (prove)\nusing this:\n  A div radical A dvd pderiv C * B - C * pderiv B\n  C div radical C dvd pderiv C * B - C * pderiv B\n  B div radical B dvd pderiv C * B - C * pderiv B\n\ngoal (1 subgoal):\n 1. A div radical A * (B div radical B) * (C div radical C) dvd\n    pderiv C * B - C * pderiv B", "using coprime coprime1 coprime4"], ["proof (prove)\nusing this:\n  A div radical A dvd pderiv C * B - C * pderiv B\n  C div radical C dvd pderiv C * B - C * pderiv B\n  B div radical B dvd pderiv C * B - C * pderiv B\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n  coprime (A div radical A) (B div radical B)\n  coprime (A div radical A * (B div radical B)) (C div radical C)\n\ngoal (1 subgoal):\n 1. A div radical A * (B div radical B) * (C div radical C) dvd\n    pderiv C * B - C * pderiv B", "by (intro divides_mult) auto"], ["proof (state)\nthis:\n  A div radical A * (B div radical B) * (C div radical C) dvd\n  pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "also"], ["proof (state)\nthis:\n  A div radical A * (B div radical B) * (C div radical C) dvd\n  pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"(A div radical A) * (B div radical B) * (C div radical C) =\n               (A * B * C) div (radical A * radical B * radical C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A div radical A * (B div radical B) * (C div radical C) =\n    A * B * C div (radical A * radical B * radical C)", "by (simp add: div_mult_div_if_dvd mult_dvd_mono)"], ["proof (state)\nthis:\n  A div radical A * (B div radical B) * (C div radical C) =\n  A * B * C div (radical A * radical B * radical C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "also"], ["proof (state)\nthis:\n  A div radical A * (B div radical B) * (C div radical C) =\n  A * B * C div (radical A * radical B * radical C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"radical A * radical B * radical C = radical (A * B) * radical C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical A * radical B * radical C = radical (A * B) * radical C", "using coprime"], ["proof (prove)\nusing this:\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n\ngoal (1 subgoal):\n 1. radical A * radical B * radical C = radical (A * B) * radical C", "by (subst radical_mult_coprime) auto"], ["proof (state)\nthis:\n  radical A * radical B * radical C = radical (A * B) * radical C\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "also"], ["proof (state)\nthis:\n  radical A * radical B * radical C = radical (A * B) * radical C\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"\\<dots> = radical (A * B * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical (A * B) * radical C = radical (A * B * C)", "using coprime"], ["proof (prove)\nusing this:\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n\ngoal (1 subgoal):\n 1. radical (A * B) * radical C = radical (A * B * C)", "by (subst radical_mult_coprime [symmetric]) auto"], ["proof (state)\nthis:\n  radical (A * B) * radical C = radical (A * B * C)\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "finally"], ["proof (chain)\npicking this:\n  A * B * C div radical (A * B * C) dvd pderiv C * B - C * pderiv B", "have dvd: \"((A * B * C) div radical (A * B * C)) dvd (pderiv C * B - C * pderiv B)\""], ["proof (prove)\nusing this:\n  A * B * C div radical (A * B * C) dvd pderiv C * B - C * pderiv B\n\ngoal (1 subgoal):\n 1. A * B * C div radical (A * B * C) dvd pderiv C * B - C * pderiv B", "."], ["proof (state)\nthis:\n  A * B * C div radical (A * B * C) dvd pderiv C * B - C * pderiv B\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "have \"pderiv B = 0 \\<and> pderiv C = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv B = 0 \\<and> pderiv C = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "assume \"\\<not>(pderiv B = 0 \\<and> pderiv C = 0)\""], ["proof (state)\nthis:\n  \\<not> (pderiv B = 0 \\<and> pderiv C = 0)\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "hence *: \"pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> (pderiv B = 0 \\<and> pderiv C = 0)\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"degree (pderiv C * B - C * pderiv B) \\<le> \n            max (degree (pderiv C * B)) (degree (C * pderiv B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv C * B - C * pderiv B)\n    \\<le> max (degree (pderiv C * B)) (degree (C * pderiv B))", "by (rule degree_diff_le_max)"], ["proof (state)\nthis:\n  degree (pderiv C * B - C * pderiv B)\n  \\<le> max (degree (pderiv C * B)) (degree (C * pderiv B))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (pderiv C * B - C * pderiv B)\n  \\<le> max (degree (pderiv C * B)) (degree (C * pderiv B))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"\\<dots> < degree B + degree C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. max (degree (pderiv C * B)) (degree (C * pderiv B))\n    < degree B + degree C", "using degree_pderiv_mult_less[of B C] degree_pderiv_mult_less[of C B] *"], ["proof (prove)\nusing this:\n  pderiv B \\<noteq> 0 \\<Longrightarrow>\n  degree (pderiv B * C) < degree C + degree B\n  pderiv C \\<noteq> 0 \\<Longrightarrow>\n  degree (pderiv C * B) < degree B + degree C\n  pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. max (degree (pderiv C * B)) (degree (C * pderiv B))\n    < degree B + degree C", "by (cases \"pderiv B = 0\"; cases \"pderiv C = 0\") (auto simp add: algebra_simps)"], ["proof (state)\nthis:\n  max (degree (pderiv C * B)) (degree (C * pderiv B)) < degree B + degree C\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  max (degree (pderiv C * B)) (degree (C * pderiv B)) < degree B + degree C\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"degree B + degree C = degree (B * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree B + degree C = degree (B * C)", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree B + degree C = degree (B * C)", "by (subst degree_mult_eq) auto"], ["proof (state)\nthis:\n  degree B + degree C = degree (B * C)\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree B + degree C = degree (B * C)\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"\\<dots> = degree (A * (B * C)) - degree A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (B * C) = degree (A * (B * C)) - degree A", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (B * C) = degree (A * (B * C)) - degree A", "by (subst (2) degree_mult_eq) auto"], ["proof (state)\nthis:\n  degree (B * C) = degree (A * (B * C)) - degree A\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (B * C) = degree (A * (B * C)) - degree A\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"\\<dots> \\<le> degree (A * B * C) - degree (radical (A * B * C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (A * (B * C)) - degree A\n    \\<le> degree (A * B * C) - degree (radical (A * B * C))", "unfolding mult.assoc"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (A * (B * C)) - degree A\n    \\<le> degree (A * (B * C)) - degree (radical (A * (B * C)))", "using assms"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  A + B + C = 0\n  Gcd {A, B, C} = 1\n  degree (radical (A * B * C)) \\<le> degree A\n\ngoal (1 subgoal):\n 1. degree (A * (B * C)) - degree A\n    \\<le> degree (A * (B * C)) - degree (radical (A * (B * C)))", "by (intro diff_le_mono2) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  degree (A * (B * C)) - degree A\n  \\<le> degree (A * B * C) - degree (radical (A * B * C))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (A * (B * C)) - degree A\n  \\<le> degree (A * B * C) - degree (radical (A * B * C))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have \"\\<dots> = degree ((A * B * C) div radical (A * B * C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (A * B * C) - degree (radical (A * B * C)) =\n    degree (A * B * C div radical (A * B * C))", "by (intro degree_div [symmetric]) auto"], ["proof (state)\nthis:\n  degree (A * B * C) - degree (radical (A * B * C)) =\n  degree (A * B * C div radical (A * B * C))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  degree (pderiv C * B - C * pderiv B)\n  < degree (A * B * C div radical (A * B * C))", "have less: \"degree (pderiv C * B - C * pderiv B) <\n                          degree (A * B * C div radical (A * B * C))\""], ["proof (prove)\nusing this:\n  degree (pderiv C * B - C * pderiv B)\n  < degree (A * B * C div radical (A * B * C))\n\ngoal (1 subgoal):\n 1. degree (pderiv C * B - C * pderiv B)\n    < degree (A * B * C div radical (A * B * C))", "by simp"], ["proof (state)\nthis:\n  degree (pderiv C * B - C * pderiv B)\n  < degree (A * B * C div radical (A * B * C))\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "have eq': \"pderiv C * B - C * pderiv B = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pderiv C * B - C * pderiv B = 0", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv C * B - C * pderiv B \\<noteq> 0 \\<Longrightarrow> False", "assume \"pderiv C * B - C * pderiv B \\<noteq> 0\""], ["proof (state)\nthis:\n  pderiv C * B - C * pderiv B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv C * B - C * pderiv B \\<noteq> 0 \\<Longrightarrow> False", "hence \"degree (A * B * C div radical (A * B * C)) \\<le> degree (pderiv C * B - C * pderiv B)\""], ["proof (prove)\nusing this:\n  pderiv C * B - C * pderiv B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (A * B * C div radical (A * B * C))\n    \\<le> degree (pderiv C * B - C * pderiv B)", "using dvd"], ["proof (prove)\nusing this:\n  pderiv C * B - C * pderiv B \\<noteq> 0\n  A * B * C div radical (A * B * C) dvd pderiv C * B - C * pderiv B\n\ngoal (1 subgoal):\n 1. degree (A * B * C div radical (A * B * C))\n    \\<le> degree (pderiv C * B - C * pderiv B)", "by (intro dvd_imp_degree_le) auto"], ["proof (state)\nthis:\n  degree (A * B * C div radical (A * B * C))\n  \\<le> degree (pderiv C * B - C * pderiv B)\n\ngoal (1 subgoal):\n 1. pderiv C * B - C * pderiv B \\<noteq> 0 \\<Longrightarrow> False", "with less"], ["proof (chain)\npicking this:\n  degree (pderiv C * B - C * pderiv B)\n  < degree (A * B * C div radical (A * B * C))\n  degree (A * B * C div radical (A * B * C))\n  \\<le> degree (pderiv C * B - C * pderiv B)", "show False"], ["proof (prove)\nusing this:\n  degree (pderiv C * B - C * pderiv B)\n  < degree (A * B * C div radical (A * B * C))\n  degree (A * B * C div radical (A * B * C))\n  \\<le> degree (pderiv C * B - C * pderiv B)\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv C * B - C * pderiv B = 0\n\ngoal (1 subgoal):\n 1. \\<not> (pderiv B = 0 \\<and> pderiv C = 0) \\<Longrightarrow> False", "from *"], ["proof (chain)\npicking this:\n  pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  pderiv B \\<noteq> 0 \\<or> pderiv C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "proof (elim disjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "assume [simp]: \"pderiv C \\<noteq> 0\""], ["proof (state)\nthis:\n  pderiv C \\<noteq> 0\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "have \"C dvd C * pderiv B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C dvd C * pderiv B", "by simp"], ["proof (state)\nthis:\n  C dvd C * pderiv B\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  C dvd C * pderiv B\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "from eq'"], ["proof (chain)\npicking this:\n  pderiv C * B - C * pderiv B = 0", "have \"\\<dots> = pderiv C * B\""], ["proof (prove)\nusing this:\n  pderiv C * B - C * pderiv B = 0\n\ngoal (1 subgoal):\n 1. C * pderiv B = pderiv C * B", "by simp"], ["proof (state)\nthis:\n  C * pderiv B = pderiv C * B\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  C dvd pderiv C * B", "have \"C dvd pderiv C\""], ["proof (prove)\nusing this:\n  C dvd pderiv C * B\n\ngoal (1 subgoal):\n 1. C dvd pderiv C", "using coprime"], ["proof (prove)\nusing this:\n  C dvd pderiv C * B\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n\ngoal (1 subgoal):\n 1. C dvd pderiv C", "by (subst (asm) coprime_dvd_mult_left_iff) (auto simp: coprime_commute)"], ["proof (state)\nthis:\n  C dvd pderiv C\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "hence \"degree C \\<le> degree (pderiv C)\""], ["proof (prove)\nusing this:\n  C dvd pderiv C\n\ngoal (1 subgoal):\n 1. degree C \\<le> degree (pderiv C)", "by (intro dvd_imp_degree_le) auto"], ["proof (state)\nthis:\n  degree C \\<le> degree (pderiv C)\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree C \\<le> degree (pderiv C)\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "have \"degree (pderiv C) < degree C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv C) < degree C", "by (intro degree_pderiv_less) auto"], ["proof (state)\nthis:\n  degree (pderiv C) < degree C\n\ngoal (2 subgoals):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False\n 2. pderiv C \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree C \\<le> degree (pderiv C)\n  degree (pderiv C) < degree C", "show False"], ["proof (prove)\nusing this:\n  degree C \\<le> degree (pderiv C)\n  degree (pderiv C) < degree C\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "assume [simp]: \"pderiv B \\<noteq> 0\""], ["proof (state)\nthis:\n  pderiv B \\<noteq> 0\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "have \"B dvd B * pderiv C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B dvd B * pderiv C", "by simp"], ["proof (state)\nthis:\n  B dvd B * pderiv C\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  B dvd B * pderiv C\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "from eq'"], ["proof (chain)\npicking this:\n  pderiv C * B - C * pderiv B = 0", "have \"\\<dots> = pderiv B * C\""], ["proof (prove)\nusing this:\n  pderiv C * B - C * pderiv B = 0\n\ngoal (1 subgoal):\n 1. B * pderiv C = pderiv B * C", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  B * pderiv C = pderiv B * C\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  B dvd pderiv B * C", "have \"B dvd pderiv B\""], ["proof (prove)\nusing this:\n  B dvd pderiv B * C\n\ngoal (1 subgoal):\n 1. B dvd pderiv B", "using coprime"], ["proof (prove)\nusing this:\n  B dvd pderiv B * C\n  Gcd {A, B, C} = 1\n  coprime A B\n  coprime A C\n  coprime B C\n\ngoal (1 subgoal):\n 1. B dvd pderiv B", "by (subst (asm) coprime_dvd_mult_left_iff) auto"], ["proof (state)\nthis:\n  B dvd pderiv B\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "hence \"degree B \\<le> degree (pderiv B)\""], ["proof (prove)\nusing this:\n  B dvd pderiv B\n\ngoal (1 subgoal):\n 1. degree B \\<le> degree (pderiv B)", "by (intro dvd_imp_degree_le) auto"], ["proof (state)\nthis:\n  degree B \\<le> degree (pderiv B)\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  degree B \\<le> degree (pderiv B)\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "have \"degree (pderiv B) < degree B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (pderiv B) < degree B", "by (intro degree_pderiv_less) auto"], ["proof (state)\nthis:\n  degree (pderiv B) < degree B\n\ngoal (1 subgoal):\n 1. pderiv B \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  degree B \\<le> degree (pderiv B)\n  degree (pderiv B) < degree B", "show False"], ["proof (prove)\nusing this:\n  degree B \\<le> degree (pderiv B)\n  degree (pderiv B) < degree B\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pderiv B = 0 \\<and> pderiv C = 0\n\ngoal (3 subgoals):\n 1. pderiv A = 0\n 2. pderiv B = 0\n 3. pderiv C = 0", "with eq and nz"], ["proof (chain)\npicking this:\n  A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  pderiv B = 0 \\<and> pderiv C = 0", "show \"pderiv A = 0\" \"pderiv B = 0\" \"pderiv C = 0\""], ["proof (prove)\nusing this:\n  A * pderiv B - pderiv A * B = pderiv C * B - C * pderiv B\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  pderiv B = 0 \\<and> pderiv C = 0\n\ngoal (1 subgoal):\n 1. pderiv A = 0 &&& pderiv B = 0 &&& pderiv C = 0", "by auto"], ["proof (state)\nthis:\n  pderiv A = 0\n  pderiv B = 0\n  pderiv C = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem Mason_Stothers:\n  fixes A B C :: \"'a :: field_gcd poly\"\n  assumes nz: \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\" \"\\<exists>p\\<in>{A,B,C}. pderiv p \\<noteq> 0\" \n      and sum: \"A + B + C = 0\" and coprime: \"Gcd {A, B, C} = 1\" \n    shows \"Max {degree A, degree B, degree C} < degree (radical (A * B * C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "have \"degree A < degree (radical (A * B * C))\"\n    if \"\\<forall>p\\<in>{A,B,C}. p \\<noteq> 0\" \"\\<exists>p\\<in>{A,B,C}. pderiv p \\<noteq> 0\" \"sum_mset {#A,B,C#} = 0\" \"Gcd {A, B, C} = 1\"\n    for A B C :: \"'a poly\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree A < degree (radical (A * B * C))", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> degree A < degree (radical (A * B * C)) \\<Longrightarrow> False", "assume \"\\<not>(degree A < degree (radical (A * B * C)))\""], ["proof (state)\nthis:\n  \\<not> degree A < degree (radical (A * B * C))\n\ngoal (1 subgoal):\n 1. \\<not> degree A < degree (radical (A * B * C)) \\<Longrightarrow> False", "hence \"degree A \\<ge> degree (radical (A * B * C))\""], ["proof (prove)\nusing this:\n  \\<not> degree A < degree (radical (A * B * C))\n\ngoal (1 subgoal):\n 1. degree (radical (A * B * C)) \\<le> degree A", "by simp"], ["proof (state)\nthis:\n  degree (radical (A * B * C)) \\<le> degree A\n\ngoal (1 subgoal):\n 1. \\<not> degree A < degree (radical (A * B * C)) \\<Longrightarrow> False", "with Mason_Stothers_aux[of A B C] that"], ["proof (chain)\npicking this:\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv A = 0\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv B = 0\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv C = 0\n  \\<forall>p\\<in>{A, B, C}. p \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0\n  \\<Sum>\\<^sub># {#A, B, C#} = 0\n  Gcd {A, B, C} = 1\n  degree (radical (A * B * C)) \\<le> degree A", "show False"], ["proof (prove)\nusing this:\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv A = 0\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv B = 0\n  \\<lbrakk>A \\<noteq> 0; B \\<noteq> 0; C \\<noteq> 0; A + B + C = 0;\n   Gcd {A, B, C} = 1; degree (radical (A * B * C)) \\<le> degree A\\<rbrakk>\n  \\<Longrightarrow> pderiv C = 0\n  \\<forall>p\\<in>{A, B, C}. p \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0\n  \\<Sum>\\<^sub># {#A, B, C#} = 0\n  Gcd {A, B, C} = 1\n  degree (radical (A * B * C)) \\<le> degree A\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: add_ac)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<forall>p\\<in>{?A, ?B, ?C}. p \\<noteq> 0;\n   \\<exists>p\\<in>{?A, ?B, ?C}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#?A, ?B, ?C#} = 0; Gcd {?A, ?B, ?C} = 1\\<rbrakk>\n  \\<Longrightarrow> degree ?A < degree (radical (?A * ?B * ?C))\n\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "from this[of A B C] this[of B C A] this[of C A B] assms"], ["proof (chain)\npicking this:\n  \\<lbrakk>\\<forall>p\\<in>{A, B, C}. p \\<noteq> 0;\n   \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#A, B, C#} = 0; Gcd {A, B, C} = 1\\<rbrakk>\n  \\<Longrightarrow> degree A < degree (radical (A * B * C))\n  \\<lbrakk>\\<forall>p\\<in>{B, C, A}. p \\<noteq> 0;\n   \\<exists>p\\<in>{B, C, A}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#B, C, A#} = 0; Gcd {B, C, A} = 1\\<rbrakk>\n  \\<Longrightarrow> degree B < degree (radical (B * C * A))\n  \\<lbrakk>\\<forall>p\\<in>{C, A, B}. p \\<noteq> 0;\n   \\<exists>p\\<in>{C, A, B}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#C, A, B#} = 0; Gcd {C, A, B} = 1\\<rbrakk>\n  \\<Longrightarrow> degree C < degree (radical (C * A * B))\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0\n  A + B + C = 0\n  Gcd {A, B, C} = 1", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>p\\<in>{A, B, C}. p \\<noteq> 0;\n   \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#A, B, C#} = 0; Gcd {A, B, C} = 1\\<rbrakk>\n  \\<Longrightarrow> degree A < degree (radical (A * B * C))\n  \\<lbrakk>\\<forall>p\\<in>{B, C, A}. p \\<noteq> 0;\n   \\<exists>p\\<in>{B, C, A}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#B, C, A#} = 0; Gcd {B, C, A} = 1\\<rbrakk>\n  \\<Longrightarrow> degree B < degree (radical (B * C * A))\n  \\<lbrakk>\\<forall>p\\<in>{C, A, B}. p \\<noteq> 0;\n   \\<exists>p\\<in>{C, A, B}. pderiv p \\<noteq> 0;\n   \\<Sum>\\<^sub># {#C, A, B#} = 0; Gcd {C, A, B} = 1\\<rbrakk>\n  \\<Longrightarrow> degree C < degree (radical (C * A * B))\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0\n  A + B + C = 0\n  Gcd {A, B, C} = 1\n\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "by (simp only: insert_commute mult_ac add_ac) (auto simp: add_ac mult_ac)"], ["proof (state)\nthis:\n  Max {degree A, degree B, degree C} < degree (radical (A * B * C))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The result can be simplified a bit more in fields of characteristic 0:\n\\<close>"], ["", "corollary Mason_Stothers_char_0:\n  fixes A B C :: \"'a :: {field_gcd, field_char_0} poly\"\n  assumes nz: \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\" and deg: \"\\<exists>p\\<in>{A,B,C}. degree p \\<noteq> 0\"\n      and sum: \"A + B + C = 0\" and coprime: \"Gcd {A, B, C} = 1\" \n    shows \"Max {degree A, degree B, degree C} < degree (radical (A * B * C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "from deg"], ["proof (chain)\npicking this:\n  \\<exists>p\\<in>{A, B, C}. degree p \\<noteq> 0", "have \"\\<exists>p\\<in>{A,B,C}. pderiv p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<exists>p\\<in>{A, B, C}. degree p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0", "by (auto simp: pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>{A, B, C}. pderiv p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "from Mason_Stothers[OF assms(1-3) this assms(5-)]"], ["proof (chain)\npicking this:\n  Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "show ?thesis"], ["proof (prove)\nusing this:\n  Max {degree A, degree B, degree C} < degree (radical (A * B * C))\n\ngoal (1 subgoal):\n 1. Max {degree A, degree B, degree C} < degree (radical (A * B * C))", "."], ["proof (state)\nthis:\n  Max {degree A, degree B, degree C} < degree (radical (A * B * C))\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  As a nice corollary, we get a kind of analogue of Fermat's last theorem for polynomials:\n  Given non-zero polynomials $A$, $B$, $C$ with $A ^ n + B ^ n + C ^ n = 0$ on lowest terms, \n  we must either have $n \\leq 2$ or $(A ^ n)' = (B ^ n)' = (C ^ n)' = 0$.\n\n  In the case of a field with characteristic 0, this last possibility is equivalent to \n  $A$, $B$, and $C$ all being constant.\n\\<close>"], ["", "corollary fermat_poly:\n  fixes A B C :: \"'a :: field_gcd poly\"\n  assumes sum: \"A ^ n + B ^ n + C ^ n = 0\" and cop: \"Gcd {A, B, C} = 1\"\n  assumes nz:  \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\"    and deg: \"\\<exists>p\\<in>{A,B,C}. pderiv (p ^ n) \\<noteq> 0\"\n  shows \"n \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> 2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "assume \"\\<not>(n \\<le> 2)\""], ["proof (state)\nthis:\n  \\<not> n \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"n > 2\""], ["proof (prove)\nusing this:\n  \\<not> n \\<le> 2\n\ngoal (1 subgoal):\n 1. 2 < n", "by simp"], ["proof (state)\nthis:\n  2 < n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "have \"Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} < \n          degree (radical (A ^ n * B ^ n * C ^ n))\" (is \"_ < ?d\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)}\n    < degree (radical (A ^ n * B ^ n * C ^ n))", "using assms"], ["proof (prove)\nusing this:\n  A ^ n + B ^ n + C ^ n = 0\n  Gcd {A, B, C} = 1\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv (p ^ n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)}\n    < degree (radical (A ^ n * B ^ n * C ^ n))", "by (intro Mason_Stothers) (auto simp: degree_power_eq gcd_exp)"], ["proof (state)\nthis:\n  Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)}\n  < degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} + 1 \\<le> ?d\""], ["proof (prove)\nusing this:\n  Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)}\n  < degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} + 1\n    \\<le> degree (radical (A ^ n * B ^ n * C ^ n))", "by linarith"], ["proof (state)\nthis:\n  Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} + 1\n  \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"n * degree A + 1 \\<le> ?d\" \"n * degree B + 1 \\<le> ?d\" \"n * degree C + 1 \\<le> ?d\""], ["proof (prove)\nusing this:\n  Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} + 1\n  \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. n * degree A + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n)) &&&\n    n * degree B + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n)) &&&\n    n * degree C + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))", "using assms"], ["proof (prove)\nusing this:\n  Max {degree (A ^ n), degree (B ^ n), degree (C ^ n)} + 1\n  \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  A ^ n + B ^ n + C ^ n = 0\n  Gcd {A, B, C} = 1\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. pderiv (p ^ n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n * degree A + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n)) &&&\n    n * degree B + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n)) &&&\n    n * degree C + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))", "by (simp_all add: degree_power_eq)"], ["proof (state)\nthis:\n  n * degree A + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree B + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree C + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"n * (degree A + degree B + degree C) + 3 \\<le> 3 * ?d\""], ["proof (prove)\nusing this:\n  n * degree A + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree B + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree C + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. n * (degree A + degree B + degree C) + 3\n    \\<le> 3 * degree (radical (A ^ n * B ^ n * C ^ n))", "unfolding ring_distribs"], ["proof (prove)\nusing this:\n  n * degree A + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree B + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n  n * degree C + 1 \\<le> degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. n * degree A + n * degree B + n * degree C + 3\n    \\<le> 3 * degree (radical (A ^ n * B ^ n * C ^ n))", "by linarith"], ["proof (state)\nthis:\n  n * (degree A + degree B + degree C) + 3\n  \\<le> 3 * degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  n * (degree A + degree B + degree C) + 3\n  \\<le> 3 * degree (radical (A ^ n * B ^ n * C ^ n))\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "have \"A ^ n * B ^ n * C ^ n = (A * B * C) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A ^ n * B ^ n * C ^ n = (A * B * C) ^ n", "by (simp add: mult_ac power_mult_distrib)"], ["proof (state)\nthis:\n  A ^ n * B ^ n * C ^ n = (A * B * C) ^ n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  A ^ n * B ^ n * C ^ n = (A * B * C) ^ n\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "have \"radical \\<dots> = radical (A * B * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. radical ((A * B * C) ^ n) = radical (A * B * C)", "using \\<open>n > 2\\<close>"], ["proof (prove)\nusing this:\n  2 < n\n\ngoal (1 subgoal):\n 1. radical ((A * B * C) ^ n) = radical (A * B * C)", "by simp"], ["proof (state)\nthis:\n  radical ((A * B * C) ^ n) = radical (A * B * C)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  radical ((A * B * C) ^ n) = radical (A * B * C)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "have \"degree (radical (A * B * C)) \\<le> degree (A * B * C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (radical (A * B * C)) \\<le> degree (A * B * C)", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (radical (A * B * C)) \\<le> degree (A * B * C)", "by (intro dvd_imp_degree_le) auto"], ["proof (state)\nthis:\n  degree (radical (A * B * C)) \\<le> degree (A * B * C)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  degree (radical (A * B * C)) \\<le> degree (A * B * C)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "have \"\\<dots> = degree A + degree B + degree C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (A * B * C) = degree A + degree B + degree C", "using nz"], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (A * B * C) = degree A + degree B + degree C", "by (simp add: degree_mult_eq)"], ["proof (state)\nthis:\n  degree (A * B * C) = degree A + degree B + degree C\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 3 * x \\<le> 3 * y) \\<Longrightarrow>\n  n * (degree A + degree B + degree C) + 3\n  \\<le> 3 * (degree A + degree B + degree C)", "have \"(3 - n) * (degree A + degree B + degree C) \\<ge> 3\""], ["proof (prove)\nusing this:\n  (\\<And>x y.\n      x \\<le> y \\<Longrightarrow> 3 * x \\<le> 3 * y) \\<Longrightarrow>\n  n * (degree A + degree B + degree C) + 3\n  \\<le> 3 * (degree A + degree B + degree C)\n\ngoal (1 subgoal):\n 1. 3 \\<le> (3 - n) * (degree A + degree B + degree C)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  3 \\<le> (3 - n) * (degree A + degree B + degree C)\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"3 - n \\<noteq> 0\""], ["proof (prove)\nusing this:\n  3 \\<le> (3 - n) * (degree A + degree B + degree C)\n\ngoal (1 subgoal):\n 1. 3 - n \\<noteq> 0", "by (intro notI) auto"], ["proof (state)\nthis:\n  3 - n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "hence \"n < 3\""], ["proof (prove)\nusing this:\n  3 - n \\<noteq> 0\n\ngoal (1 subgoal):\n 1. n < 3", "by simp"], ["proof (state)\nthis:\n  n < 3\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "with \\<open>n > 2\\<close>"], ["proof (chain)\npicking this:\n  2 < n\n  n < 3", "show False"], ["proof (prove)\nusing this:\n  2 < n\n  n < 3\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary fermat_poly_char_0:\n  fixes A B C :: \"'a :: {field_gcd,field_char_0} poly\"\n  assumes sum: \"A ^ n + B ^ n + C ^ n = 0\" and cop: \"Gcd {A, B, C} = 1\"\n  assumes nz:  \"A \\<noteq> 0\" \"B \\<noteq> 0\" \"C \\<noteq> 0\"    and deg: \"\\<exists>p\\<in>{A,B,C}. degree p > 0\"\n  shows \"n \\<le> 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n \\<le> 2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "assume *: \"\\<not>(n \\<le> 2)\""], ["proof (state)\nthis:\n  \\<not> n \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "with nz and deg"], ["proof (chain)\npicking this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. 0 < degree p\n  \\<not> n \\<le> 2", "have \"\\<exists>p\\<in>{A,B,C}. pderiv (p ^ n) \\<noteq> 0\""], ["proof (prove)\nusing this:\n  A \\<noteq> 0\n  B \\<noteq> 0\n  C \\<noteq> 0\n  \\<exists>p\\<in>{A, B, C}. 0 < degree p\n  \\<not> n \\<le> 2\n\ngoal (1 subgoal):\n 1. \\<exists>p\\<in>{A, B, C}. pderiv (p ^ n) \\<noteq> 0", "by (auto simp: pderiv_eq_0_iff degree_power_eq)"], ["proof (state)\nthis:\n  \\<exists>p\\<in>{A, B, C}. pderiv (p ^ n) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> n \\<le> 2 \\<Longrightarrow> False", "from fermat_poly[OF assms(1-5) this] and *"], ["proof (chain)\npicking this:\n  n \\<le> 2\n  \\<not> n \\<le> 2", "show False"], ["proof (prove)\nusing this:\n  n \\<le> 2\n  \\<not> n \\<le> 2\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}