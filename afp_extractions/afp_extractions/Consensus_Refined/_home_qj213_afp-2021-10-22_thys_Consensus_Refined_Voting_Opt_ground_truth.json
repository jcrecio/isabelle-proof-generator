{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Voting_Opt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma opt_no_defection_def:\n  \"opt_no_defection s round_votes =\n    (\\<forall>a Q v. quorum_for Q v (last_vote s) \\<and> a \\<in> Q \\<longrightarrow> round_votes a \\<in> {None, Some v})\"", "lemmas flv_evt_defs = flv_round_def flv_guard_def", "lemmas flv_TS_defs = flv_TS_def flv_init_def flv_trans_def", "lemma process_mru_Max:\n  assumes \n    inv: \"sa \\<in> Vinv1\"\n    and process_mru: \"process_mru (votes sa) p = Some (r, v)\"\n  shows \n    \"votes sa r p = Some v \\<and> (\\<forall>r' > r. votes sa r' p = None)\"", "lemma opt_no_defection_imp_no_defection:\n  assumes\n    conc_guard: \"opt_no_defection sc round_votes\"\n    and R: \"(sa, sc) \\<in> flv_ref_rel\"\n    and ainv: \"sa \\<in> Vinv1\" \"sa \\<in> Vinv2\"\n  shows\n    \"no_defection sa round_votes r\"", "lemma act_ref:\n  assumes\n    inv: \"s \\<in> Vinv1\"\n  shows \n    \"map_option snd o (process_mru ((votes s)(v_state.next_round s := v_f)))\n    = ((map_option snd o (process_mru (votes s))) ++ v_f)\"", "lemma flv_round_refines:\n  \"{flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV}\n    v_round r v_f  d_f, flv_round r v_f d_f\n  {> flv_ref_rel}\"", "lemma Last_Voting_Refines:\n  \"PO_refines (flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV) v_TS flv_TS\""], "translations": [["", "lemma opt_no_defection_def:\n  \"opt_no_defection s round_votes =\n    (\\<forall>a Q v. quorum_for Q v (last_vote s) \\<and> a \\<in> Q \\<longrightarrow> round_votes a \\<in> {None, Some v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_no_defection s round_votes =\n    (\\<forall>a Q v.\n        quorum_for Q v (last_vote s) \\<and> a \\<in> Q \\<longrightarrow>\n        round_votes a \\<in> {None, Some v})", "apply(auto simp add: opt_no_defection_def')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v Q xa y.\n       \\<lbrakk>\\<forall>a Q v.\n                   quorum_for Q v (last_vote s) \\<and>\n                   a \\<in> Q \\<longrightarrow>\n                   round_votes a = None \\<or> round_votes a = Some v;\n        quorum_for Q v (last_vote s); xa \\<in> Q;\n        round_votes xa = Some y\\<rbrakk>\n       \\<Longrightarrow> y = v", "by (metis option.distinct(1) option.sel)"], ["", "definition flv_round :: \"round \\<Rightarrow> (process, val)map \\<Rightarrow>  (process, val)map \\<Rightarrow> (opt_v_state \\<times> opt_v_state) set\" where\n  \"flv_round r r_votes r_decisions = {(s, s').\n     \\<comment> \\<open>guards\\<close>\n     r = next_round s\n     \\<and> opt_no_defection s r_votes\n     \\<and> d_guard r_decisions r_votes\n     \\<and> \\<comment> \\<open>actions\\<close>\n     s' = s\\<lparr> \n       next_round := Suc r\n       , last_vote := last_vote s ++ r_votes\n       , decisions := (decisions s) ++ r_decisions\n     \\<rparr>\n  }\""], ["", "lemmas flv_evt_defs = flv_round_def flv_guard_def"], ["", "definition flv_trans :: \"(opt_v_state \\<times> opt_v_state) set\" where\n  \"flv_trans = (\\<Union>r v_f d_f. flv_round r v_f d_f)\""], ["", "definition flv_TS :: \"opt_v_state TS\" where\n  \"flv_TS = \\<lparr> init = flv_init, trans = flv_trans \\<rparr>\""], ["", "lemmas flv_TS_defs = flv_TS_def flv_init_def flv_trans_def"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition flv_ref_rel :: \"(v_state \\<times> opt_v_state)set\" where\n  \"flv_ref_rel = {(sa, sc).\n    sc = \\<lparr>\n      next_round = v_state.next_round sa\n      , last_vote = map_option snd o (process_mru (votes sa))\n      , decisions = v_state.decisions sa\n    \\<rparr>\n  }\""], ["", "subsubsection \\<open>Guard strengthening\\<close>"], ["", "(******************************************************************************)"], ["", "lemma process_mru_Max:\n  assumes \n    inv: \"sa \\<in> Vinv1\"\n    and process_mru: \"process_mru (votes sa) p = Some (r, v)\"\n  shows \n    \"votes sa r p = Some v \\<and> (\\<forall>r' > r. votes sa r' p = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "from process_mru"], ["proof (chain)\npicking this:\n  process_mru (votes sa) p = Some (r, v)", "have not_empty: \"vote_set (votes sa) {p} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  process_mru (votes sa) p = Some (r, v)\n\ngoal (1 subgoal):\n 1. vote_set (votes sa) {p} \\<noteq> {}", "by(auto simp add: process_mru_def mru_of_set_def option_Max_by_def)"], ["proof (state)\nthis:\n  vote_set (votes sa) {p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "note Max_by_conds = Vinv1_finite_vote_set[OF inv] this"], ["proof (state)\nthis:\n  finite (vote_set (votes sa) ?Q)\n  vote_set (votes sa) {p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "from Max_by_dest[OF Max_by_conds, where f=fst]"], ["proof (chain)\npicking this:\n  Max_by fst (vote_set (votes sa) {p}) \\<in> vote_set (votes sa) {p} \\<and>\n  fst (Max_by fst (vote_set (votes sa) {p})) =\n  Max (fst ` vote_set (votes sa) {p})", "have\n    r: \n      \"(r, v) = Max_by fst (vote_set (votes sa) {p})\" \n      \"votes sa r p = Some v\""], ["proof (prove)\nusing this:\n  Max_by fst (vote_set (votes sa) {p}) \\<in> vote_set (votes sa) {p} \\<and>\n  fst (Max_by fst (vote_set (votes sa) {p})) =\n  Max (fst ` vote_set (votes sa) {p})\n\ngoal (1 subgoal):\n 1. (r, v) = Max_by fst (vote_set (votes sa) {p}) &&& votes sa r p = Some v", "using process_mru"], ["proof (prove)\nusing this:\n  Max_by fst (vote_set (votes sa) {p}) \\<in> vote_set (votes sa) {p} \\<and>\n  fst (Max_by fst (vote_set (votes sa) {p})) =\n  Max (fst ` vote_set (votes sa) {p})\n  process_mru (votes sa) p = Some (r, v)\n\ngoal (1 subgoal):\n 1. (r, v) = Max_by fst (vote_set (votes sa) {p}) &&& votes sa r p = Some v", "by(auto simp add: process_mru_def mru_of_set_def option_Max_by_def vote_set_def)"], ["proof (state)\nthis:\n  (r, v) = Max_by fst (vote_set (votes sa) {p})\n  votes sa r p = Some v\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "have \"\\<forall>r' >r . votes sa r' p = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r'>r. votes sa r' p = None", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r'. r < r' \\<Longrightarrow> votes sa r' p = None", "fix r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r'. r < r' \\<Longrightarrow> votes sa r' p = None", "assume less: \"r < r'\""], ["proof (state)\nthis:\n  r < r'\n\ngoal (1 subgoal):\n 1. \\<And>r'. r < r' \\<Longrightarrow> votes sa r' p = None", "hence \"\\<forall>v. (r', v) \\<notin> vote_set (votes sa) {p}\""], ["proof (prove)\nusing this:\n  r < r'\n\ngoal (1 subgoal):\n 1. \\<forall>v. (r', v) \\<notin> vote_set (votes sa) {p}", "using process_mru"], ["proof (prove)\nusing this:\n  r < r'\n  process_mru (votes sa) p = Some (r, v)\n\ngoal (1 subgoal):\n 1. \\<forall>v. (r', v) \\<notin> vote_set (votes sa) {p}", "by(auto dest!: Max_by_ge[where f=fst, OF Vinv1_finite_vote_set[OF inv]] \n        simp add: process_mru_def mru_of_set_def option_Max_by_def)"], ["proof (state)\nthis:\n  \\<forall>v. (r', v) \\<notin> vote_set (votes sa) {p}\n\ngoal (1 subgoal):\n 1. \\<And>r'. r < r' \\<Longrightarrow> votes sa r' p = None", "thus \"votes sa r' p = None\""], ["proof (prove)\nusing this:\n  \\<forall>v. (r', v) \\<notin> vote_set (votes sa) {p}\n\ngoal (1 subgoal):\n 1. votes sa r' p = None", "by(auto simp add: vote_set_def)"], ["proof (state)\nthis:\n  votes sa r' p = None\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>r'>r. votes sa r' p = None\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r'>r. votes sa r' p = None\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "using r(2)"], ["proof (prove)\nusing this:\n  \\<forall>r'>r. votes sa r' p = None\n  votes sa r p = Some v\n\ngoal (1 subgoal):\n 1. votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)", "by(auto)"], ["proof (state)\nthis:\n  votes sa r p = Some v \\<and> (\\<forall>r'>r. votes sa r' p = None)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opt_no_defection_imp_no_defection:\n  assumes\n    conc_guard: \"opt_no_defection sc round_votes\"\n    and R: \"(sa, sc) \\<in> flv_ref_rel\"\n    and ainv: \"sa \\<in> Vinv1\" \"sa \\<in> Vinv2\"\n  shows\n    \"no_defection sa round_votes r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_defection sa round_votes r", "proof(unfold no_defection_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r' a Q v y.\n       \\<lbrakk>r' < r; round_votes a \\<notin> {}; round_votes a = Some y;\n        quorum_for Q v (votes sa r'); a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> round_votes a = Some v", "fix r' v a Q w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>r' a Q v y.\n       \\<lbrakk>r' < r; round_votes a \\<notin> {}; round_votes a = Some y;\n        quorum_for Q v (votes sa r'); a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> round_votes a = Some v", "assume\n    r'_less: \"r' < r\"\n    and a_votes_w: \"round_votes a = Some w\"\n    and Q: \"quorum_for Q v (votes sa r')\"\n    and a_in_Q: \"a \\<in> Q\""], ["proof (state)\nthis:\n  r' < r\n  round_votes a = Some w\n  quorum_for Q v (votes sa r')\n  a \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>r' a Q v y.\n       \\<lbrakk>r' < r; round_votes a \\<notin> {}; round_votes a = Some y;\n        quorum_for Q v (votes sa r'); a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> round_votes a = Some v", "have \"Q \\<in> Quorum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<in> Quorum", "using Q"], ["proof (prove)\nusing this:\n  quorum_for Q v (votes sa r')\n\ngoal (1 subgoal):\n 1. Q \\<in> Quorum", "by(auto simp add: quorum_for_def)"], ["proof (state)\nthis:\n  Q \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>r' a Q v y.\n       \\<lbrakk>r' < r; round_votes a \\<notin> {}; round_votes a = Some y;\n        quorum_for Q v (votes sa r'); a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> round_votes a = Some v", "hence \"quorum_for Q v (last_vote sc)\""], ["proof (prove)\nusing this:\n  Q \\<in> Quorum\n\ngoal (1 subgoal):\n 1. quorum_for Q v (last_vote sc)", "proof(clarsimp simp add: quorum_for_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "assume \"q \\<in> Q\""], ["proof (state)\nthis:\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "with Q"], ["proof (chain)\npicking this:\n  quorum_for Q v (votes sa r')\n  q \\<in> Q", "have q_r': \"votes sa r' q = Some v\""], ["proof (prove)\nusing this:\n  quorum_for Q v (votes sa r')\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. votes sa r' q = Some v", "by(auto simp add: quorum_for_def)"], ["proof (state)\nthis:\n  votes sa r' q = Some v\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "hence votes: \"vote_set (votes sa) {q} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  votes sa r' q = Some v\n\ngoal (1 subgoal):\n 1. vote_set (votes sa) {q} \\<noteq> {}", "by(auto simp add: vote_set_def)"], ["proof (state)\nthis:\n  vote_set (votes sa) {q} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "then"], ["proof (chain)\npicking this:\n  vote_set (votes sa) {q} \\<noteq> {}", "obtain w where w: \"last_vote sc q = Some w\""], ["proof (prove)\nusing this:\n  vote_set (votes sa) {q} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        last_vote sc q = Some w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R"], ["proof (prove)\nusing this:\n  vote_set (votes sa) {q} \\<noteq> {}\n  (sa, sc) \\<in> flv_ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        last_vote sc q = Some w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: flv_ref_rel_def process_mru_def mru_of_set_def\n        option_Max_by_def)"], ["proof (state)\nthis:\n  last_vote sc q = Some w\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "with R"], ["proof (chain)\npicking this:\n  (sa, sc) \\<in> flv_ref_rel\n  last_vote sc q = Some w", "obtain r_max where \"process_mru (votes sa) q = Some (r_max, w)\""], ["proof (prove)\nusing this:\n  (sa, sc) \\<in> flv_ref_rel\n  last_vote sc q = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>r_max.\n        process_mru (votes sa) q = Some (r_max, w) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: flv_ref_rel_def)"], ["proof (state)\nthis:\n  process_mru (votes sa) q = Some (r_max, w)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "from process_mru_Max[OF ainv(1) this] q_r'"], ["proof (chain)\npicking this:\n  votes sa r_max q = Some w \\<and> (\\<forall>r'>r_max. votes sa r' q = None)\n  votes sa r' q = Some v", "have\n      \"votes sa r_max q = Some w\" \n      \"r' \\<le> r_max\""], ["proof (prove)\nusing this:\n  votes sa r_max q = Some w \\<and> (\\<forall>r'>r_max. votes sa r' q = None)\n  votes sa r' q = Some v\n\ngoal (1 subgoal):\n 1. votes sa r_max q = Some w &&& r' \\<le> r_max", "using q_r'"], ["proof (prove)\nusing this:\n  votes sa r_max q = Some w \\<and> (\\<forall>r'>r_max. votes sa r' q = None)\n  votes sa r' q = Some v\n  votes sa r' q = Some v\n\ngoal (1 subgoal):\n 1. votes sa r_max q = Some w &&& r' \\<le> r_max", "by(auto simp add: not_less[symmetric])"], ["proof (state)\nthis:\n  votes sa r_max q = Some w\n  r' \\<le> r_max\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>Q \\<in> Quorum; p \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> last_vote sc p = Some v", "thus \"last_vote sc q = Some v\""], ["proof (prove)\nusing this:\n  votes sa r_max q = Some w\n  r' \\<le> r_max\n\ngoal (1 subgoal):\n 1. last_vote sc q = Some v", "using ainv(2) Q \\<open>q \\<in> Q\\<close>"], ["proof (prove)\nusing this:\n  votes sa r_max q = Some w\n  r' \\<le> r_max\n  sa \\<in> Vinv2\n  quorum_for Q v (votes sa r')\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. last_vote sc q = Some v", "apply(case_tac \"r_max = r'\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>votes sa r_max q = Some w; r' \\<le> r_max; sa \\<in> Vinv2;\n     quorum_for Q v (votes sa r'); q \\<in> Q; r_max = r'\\<rbrakk>\n    \\<Longrightarrow> last_vote sc q = Some v\n 2. \\<lbrakk>votes sa r_max q = Some w; r' \\<le> r_max; sa \\<in> Vinv2;\n     quorum_for Q v (votes sa r'); q \\<in> Q; r_max \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> last_vote sc q = Some v", "apply(clarsimp simp add: w Vinv2_def no_defection_def q_r' dest: le_neq_implies_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>votes sa r_max q = Some w; r' \\<le> r_max; sa \\<in> Vinv2;\n     quorum_for Q v (votes sa r'); q \\<in> Q; r_max \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> last_vote sc q = Some v", "apply(fastforce simp add: w Vinv2_def no_defection_def q_r' dest!: le_neq_implies_less)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  last_vote sc q = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  quorum_for Q v (last_vote sc)\n\ngoal (1 subgoal):\n 1. \\<And>r' a Q v y.\n       \\<lbrakk>r' < r; round_votes a \\<notin> {}; round_votes a = Some y;\n        quorum_for Q v (votes sa r'); a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> round_votes a = Some v", "thus \"round_votes a = Some v\""], ["proof (prove)\nusing this:\n  quorum_for Q v (last_vote sc)\n\ngoal (1 subgoal):\n 1. round_votes a = Some v", "using conc_guard a_in_Q a_votes_w r'_less"], ["proof (prove)\nusing this:\n  quorum_for Q v (last_vote sc)\n  opt_no_defection sc round_votes\n  a \\<in> Q\n  round_votes a = Some w\n  r' < r\n\ngoal (1 subgoal):\n 1. round_votes a = Some v", "by(fastforce simp add: opt_no_defection_def)"], ["proof (state)\nthis:\n  round_votes a = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Action refinement\\<close>"], ["", "(******************************************************************************)"], ["", "lemma act_ref:\n  assumes\n    inv: \"s \\<in> Vinv1\"\n  shows \n    \"map_option snd o (process_mru ((votes s)(v_state.next_round s := v_f)))\n    = ((map_option snd o (process_mru (votes s))) ++ v_f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option snd \\<circ>\n    process_mru ((votes s)(v_state.next_round s := v_f)) =\n    (map_option snd \\<circ> process_mru (votes s)) ++ v_f", "by(auto simp add: process_mru_map_add[OF inv] map_add_def split: option.split)"], ["", "subsubsection \\<open>The complete refinement proof\\<close>"], ["", "(******************************************************************************)"], ["", "lemma flv_round_refines:\n  \"{flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV}\n    v_round r v_f  d_f, flv_round r v_f d_f\n  {> flv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {flv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2) \\<times>\n     UNIV} v_round r v_f d_f, flv_round r v_f d_f {> flv_ref_rel}", "by(auto simp add: PO_rhoare_defs flv_round_def v_round_def \n    flv_ref_rel_def act_ref\n    intro: opt_no_defection_imp_no_defection)"], ["", "lemma Last_Voting_Refines:\n  \"PO_refines (flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV) v_TS flv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines (flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV)\n     v_TS flv_TS", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {flv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2) \\<times>\n     UNIV} TS.trans v_TS, TS.trans flv_TS {> flv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n 3. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 4. init flv_TS \\<subseteq> flv_ref_rel `` init v_TS\n 5. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 6. init flv_TS \\<subseteq> UNIV", "show \"init flv_TS \\<subseteq> flv_ref_rel `` init v_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init flv_TS \\<subseteq> flv_ref_rel `` init v_TS", "by(auto simp add: flv_TS_defs v_TS_defs flv_ref_rel_def\n      process_mru_def mru_of_set_def vote_set_def option_Max_by_def)"], ["proof (state)\nthis:\n  init flv_TS \\<subseteq> flv_ref_rel `` init v_TS\n\ngoal (5 subgoals):\n 1. {flv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2) \\<times>\n     UNIV} TS.trans v_TS, TS.trans flv_TS {> flv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n 3. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 4. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 5. init flv_TS \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {flv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2) \\<times>\n     UNIV} TS.trans v_TS, TS.trans flv_TS {> flv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n 3. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 4. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 5. init flv_TS \\<subseteq> UNIV", "show \n    \"{flv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2) \\<times> UNIV} trans v_TS, trans flv_TS {> flv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {flv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2) \\<times>\n     UNIV} TS.trans v_TS, TS.trans flv_TS {> flv_ref_rel}", "by(auto simp add: v_TS_defs flv_TS_defs intro!: flv_round_refines)"], ["proof (state)\nthis:\n  {flv_ref_rel \\<inter>\n   (Vinv1 \\<inter> Vinv2) \\<times>\n   UNIV} TS.trans v_TS, TS.trans flv_TS {> flv_ref_rel}\n\ngoal (4 subgoals):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n 2. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 3. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 4. init flv_TS \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n 2. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 3. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 4. init flv_TS \\<subseteq> UNIV", "show\n    \"{Vinv1 \\<inter> Vinv2 \\<inter> Domain (flv_ref_rel \\<inter> UNIV \\<times> UNIV)} \n      trans v_TS \n    {> Vinv1 \\<inter> Vinv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}", "using Vinv1_inductive(2) Vinv2_inductive(2)"], ["proof (prove)\nusing this:\n  {Vinv1} TS.trans v_TS {> Vinv1}\n  {Vinv2 \\<inter> Vinv1} TS.trans v_TS {> Vinv2}\n\ngoal (1 subgoal):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter>\n     Domain\n      (flv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}", "by blast"], ["proof (state)\nthis:\n  {Vinv1 \\<inter> Vinv2 \\<inter>\n   Domain\n    (flv_ref_rel \\<inter>\n     UNIV \\<times> UNIV)} TS.trans v_TS {> Vinv1 \\<inter> Vinv2}\n\ngoal (3 subgoals):\n 1. {UNIV \\<inter>\n     Range\n      (flv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2) \\<times> UNIV)} TS.trans flv_TS {> UNIV}\n 2. init v_TS \\<subseteq> Vinv1 \\<inter> Vinv2\n 3. init flv_TS \\<subseteq> UNIV", "qed(auto intro!: Vinv1_inductive(1) Vinv2_inductive(1))"], ["", "end"], ["", "end"]]}