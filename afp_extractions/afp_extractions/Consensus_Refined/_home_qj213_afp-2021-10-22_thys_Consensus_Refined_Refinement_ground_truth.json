{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Refinement.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma beh_immediate_prefix_closed:\n  \"s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\"", "lemma beh_prefix_closed:\n  \"c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\"", "lemma beh_in_reach [rule_format]:\n  \"b \\<in> beh T \\<Longrightarrow> (\\<forall>s \\<in> set b. s \\<in> reach T)\"", "lemma reach_in_beh:\n  \"s \\<in> reach T \\<Longrightarrow> \\<exists>b \\<in> beh T. s \\<in> set b\"", "lemma reach_equiv_beh_states: \"reach T = (\\<Union>b\\<in>beh T. set b)\"", "lemma beh_consecutive_in_trans:\n  assumes \"b \\<in> beh TS\"\n  and \"Suc i < length b\"\n  and \"s = b ! Suc i\"\n  and \"t = b ! i\"\n  shows \"(s, t) \\<in> trans TS\"", "lemma beh_obs_upd [simp]: \"beh (S(| obs := x |)) = beh S\"", "lemma reach_obs_upd [simp]: \"reach (S(| obs := x |)) = reach S\"", "lemma oreach_equiv_obeh_states: \"oreach S = (\\<Union>b\\<in>obeh S. set b)\"", "lemma obeh_pi_translation:\n  \"(map pi)`(obeh S) = obeh (S(| obs := pi o (obs S) |))\"", "lemma oreach_pi_translation:\n  \"pi`(oreach S) = oreach (S(| obs := pi o (obs S) |))\"", "lemma observableE [elim]:\n  \"\\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk> \\<Longrightarrow> s \\<in> P\"", "lemma observable2_equiv_observable: \"observable2 ob P = observable ob P\"", "lemma observable3_equiv_observable2: \"observable3 ob P = observable2 ob P\"", "lemma observable_id [simp]: \"observable id P\"", "lemma image_vimage_adjoints: \"(ob`P \\<subseteq> Q) = (P \\<subseteq> ob-`Q)\"", "lemma image_r_vimage_l: \"\\<lbrakk> Q \\<subseteq> ob`P; observable ob P \\<rbrakk> \\<Longrightarrow> ob-`Q \\<subseteq> P\"", "lemma vimage_l_image_r: \"\\<lbrakk> ob-`Q \\<subseteq> P; Q \\<subseteq> range ob \\<rbrakk> \\<Longrightarrow> Q \\<subseteq> ob`P\"", "lemma external_from_internal_invariant: \n  \"\\<lbrakk> reach S \\<subseteq> P; (obs S)`P \\<subseteq> Q \\<rbrakk>  \n  \\<Longrightarrow> oreach S \\<subseteq> Q\"", "lemma external_from_internal_invariant_vimage: \n  \"\\<lbrakk> reach S \\<subseteq> P; P \\<subseteq> (obs S)-`Q \\<rbrakk>\n  \\<Longrightarrow> oreach S \\<subseteq> Q\"", "lemma external_to_internal_invariant_vimage: \n  \"\\<lbrakk> oreach S \\<subseteq> Q; (obs S)-`Q \\<subseteq> P \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemma external_to_internal_invariant:\n  \"\\<lbrakk> oreach S \\<subseteq> Q; Q \\<subseteq> (obs S)`P; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemma external_equiv_internal_invariant_vimage: \n  \"\\<lbrakk> P = (obs S)-`Q \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\"", "lemma external_equiv_internal_invariant: \n  \"\\<lbrakk> (obs S)`P = Q; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\"", "lemma implements_refl: \"implements id S S\"", "lemma implements_trans:\n  \"\\<lbrakk> implements pi1 S1 S2; implements pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> implements (pi1 o pi2) S1 S3\"", "lemma implements_oreach:\n  \"implements pi Sa Sc \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> oreach Sa\"", "lemma external_invariant_preservation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> Q\"", "lemma external_invariant_translation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; pi-`Q \\<subseteq> P; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> oreach Sc \\<subseteq> P\"", "lemma internal_invariant_translation:\n  \"\\<lbrakk> reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa; pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\"", "lemmas PO_hoare_defs = PO_hoare_def Image_def", "lemma \"{P} R {> Q} = (\\<forall>s t. s \\<in> P \\<longrightarrow> (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)\"", "lemma hoareD:\n  \"\\<lbrakk> {I} R {>J}; s \\<in> I; (s, s') \\<in> R \\<rbrakk> \\<Longrightarrow> s' \\<in> J\"", "lemma hoare_conseq_left [intro]:\n  \"\\<lbrakk> {P'} R {> Q}; P \\<subseteq> P' \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\"", "lemma hoare_conseq_right:\n  \"\\<lbrakk> {P} R {> Q'}; Q' \\<subseteq> Q \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\"", "lemma hoare_false_left [simp]:\n  \"{{}} R {> Q}\"", "lemma hoare_true_right [simp]:\n  \"{P} R {> UNIV}\"", "lemma hoare_conj_right [intro!]:\n  \"\\<lbrakk> {P} R {> Q1}; {P} R {> Q2} \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}\"", "lemma hoare_stop [simp, intro!]:\n  \"{P} {} {> Q}\"", "lemma hoare_skip [simp, intro!]: \n  \"P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}\"", "lemma hoare_trans_Un [iff]:\n  \"{P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})\"", "lemma hoare_trans_UN [iff]:\n  \"{P} \\<Union> x. R x {> Q} = (\\<forall>x. {P} R x {> Q})\"", "lemma reach_init: \"reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I\"", "lemma reach_trans: \"reach T \\<subseteq> I \\<Longrightarrow> {reach T} trans T {> I}\"", "lemma inv_rule_basic:\n  \"\\<lbrakk> init T \\<subseteq> P; {P} (trans T) {> P} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemma inv_rule_from_INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\"", "lemma INV_rule_from_inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemma inv_rule_incr:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> J} (trans T) {> I}; reach T \\<subseteq> J \\<rbrakk>    \n  \\<Longrightarrow> reach T \\<subseteq> I\"", "lemmas PO_rhoare_defs = PO_rhoare_def relcomp_unfold", "lemma relhoare_conseq_left [intro]:\n  \"\\<lbrakk> {pre'} Ra, Rc {> post}; pre \\<subseteq> pre' \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\"", "lemma relhoare_conseq_right:                    \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"\\<lbrakk> {pre} Ra, Rc {> post'}; post' \\<subseteq> post \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\"", "lemma relhoare_false_left [simp]:               \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"{ {} } Ra, Rc {> post}\"", "lemma relhoare_true_right [simp]:                \\<comment> \\<open>not true in general\\<close>\n  \"{pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)\"", "lemma Domain_rel_comp [intro]:\n  \"Domain pre \\<subseteq> R \\<Longrightarrow> Domain (pre O Rc) \\<subseteq> R\"", "lemma rel_hoare_skip [iff]: \"{R} Id, Id {> R}\"", "lemma relhoare_refl [simp]: \"{Id} R, R {> Id}\"", "lemma rhoare_trans:\n  \"\\<lbrakk> {R1} T1, T2 {> R1}; {R2} T2, T3 {> R2} \\<rbrakk>\n  \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}\"", "lemma relhoare_conj_right_det:                 \n  \"\\<lbrakk> {pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra \\<rbrakk>                           \\<comment> \\<open>only for deterministic \\<open>Ra\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}\"", "lemma relhoare_conj_right_cartesian [intro]:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}\"", "lemma relhoare_concrete_Un [simp]:\n  \"{pre} Ra, Rc1 \\<union> Rc2 {> post} \n   = ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})\"", "lemma relhoare_concrete_UN [simp]:\n  \"{pre} Ra, \\<Union>x. Rc x {> post} = (\\<forall>x. {pre} Ra, Rc x {> post})\"", "lemma relhoare_abstract_Un_left [intro]:\n  \"\\<lbrakk> {pre} Ra1, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\"", "lemma relhoare_abstract_Un_right [intro]:\n  \"\\<lbrakk> {pre} Ra2, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\"", "lemma relhoare_abstract_UN [intro!]:   \\<comment> \\<open>might be too aggressive?\\<close>\n  \"\\<lbrakk> {pre} Ra x, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} \\<Union>x. Ra x, Rc {> post}\"", "lemma refine_basic:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk>\n  \\<Longrightarrow> PO_refines R Ta Tc\"", "lemma refine_init_using_invariants:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> (R \\<inter> I \\<times> J)``(init Ta)\"", "lemma refine_trans_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J} \\<rbrakk>\n  \\<Longrightarrow> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R  \\<inter> I \\<times> J}\"", "lemma refine_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J}; \n     init Tc \\<subseteq> R``(init Ta); \n     init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc\"", "lemma PO_refines_implies_Range_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R\"", "lemma PO_refines_implies_Range_trans:\n  \"PO_refines R Ta Tc \\<Longrightarrow> {Range R} trans Tc {> Range R}\"", "lemma PO_refines_implies_Range_invariant:\n  \"PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R\"", "lemmas hoare_conseq = hoare_conseq_right[OF hoare_conseq_left] for P' R Q'", "lemma PO_refines_implies_R_image_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> R `` (init Ta)\"", "lemma commute_dest:\n  \"\\<lbrakk> R O Tc \\<subseteq> Ta O R; (sa, sc) \\<in> R; (sc, sc') \\<in> Tc \\<rbrakk> \\<Longrightarrow> \\<exists>sa'. (sa, sa') \\<in> Ta \\<and> (sa', sc') \\<in> R\"", "lemma PO_refines_implies_R_image_trans:\n  assumes \"PO_refines R Ta Tc\"\n  shows \"{R `` reach Ta} trans Tc {> R `` reach Ta}\"", "lemma PO_refines_implies_R_image_invariant:\n  assumes \"PO_refines R Ta Tc\"\n  shows \"reach Tc \\<subseteq> R `` reach Ta\"", "lemma abs_INV_init_transfer:\n  assumes\n    \"PO_refines R Ta Tc\"\n    \"init Ta \\<subseteq> I\"\n  shows \"init Tc \\<subseteq> R `` I\"", "lemma abs_INV_trans_transfer:\n  assumes\n    ref: \"PO_refines R Ta Tc\"\n    and abs_hoare: \"{I} trans Ta {> J}\"\n  shows \"{R `` I} trans Tc {> R `` J}\"", "lemma abs_INV_transfer:\n  assumes\n    \"PO_refines R Ta Tc\"\n    \"reach Ta \\<subseteq> I\"\n  shows \"reach Tc \\<subseteq> R `` I\"", "lemma behaviour_refinement:\nassumes \"PO_refines R Ta Tc\" \"bc \\<in> beh Tc\" \nshows \"\\<exists>ba \\<in> beh Ta. (ba, bc) \\<in> seq_lift R\"", "lemma obs_consistent_refl [iff]: \"obs_consistent Id id S S\"", "lemma obs_consistent_trans [intro]: \n  \"\\<lbrakk> obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3 \\<rbrakk>\n  \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 o pi2) S1 S3\"", "lemma obs_consistent_empty: \"obs_consistent {} pi Sa Sc\"", "lemma obs_consistent_conj1 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R \\<inter> R') pi Sa Sc\"", "lemma obs_consistent_conj2 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R' \\<inter> R) pi Sa Sc\"", "lemma obs_consistent_behaviours:\n  \"\\<lbrakk> obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa; (ba, bc) \\<in> seq_lift R\\<rbrakk>\n  \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba\"", "lemmas refines_defs = \n  refines_def PO_refines_def", "lemma refinesI: \n  \"\\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> refines R pi Sa Sc\"", "lemma PO_refines_from_refines: \n  \"refines R pi Sa Sc \\<Longrightarrow> PO_refines R Sa Sc\"", "lemma refinement_reflexive: \"refines Id id S S\"", "lemma refinement_transitive: \n  \"\\<lbrakk> refines R1 pi1 S1 S2; refines R2 pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> refines (R1 O R2) (pi1 o pi2) S1 S3\"", "lemma observable_behaviour_refinement:\n  \"\\<lbrakk> refines R pi Sa Sc; bc \\<in> obeh Sc \\<rbrakk> \\<Longrightarrow> map pi bc \\<in> obeh Sa\"", "theorem refinement_soundness: \n  \"refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc\"", "lemmas Refinement_basic = refine_basic [THEN refinesI]", "lemmas Refinement_using_invariants = refine_using_invariants [THEN refinesI]", "lemmas INV_init_from_Refinement = \n  INV_init_from_refinement [OF PO_refines_from_refines]", "lemmas INV_trans_from_Refinement = \n  INV_trans_from_refinement [OF PO_refines_from_refines]", "lemmas INV_from_Refinement = \n  INV_from_refinement [OF PO_refines_from_refines]"], "translations": [["", "lemma beh_immediate_prefix_closed:\n  \"s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s # b \\<in> beh T \\<Longrightarrow> b \\<in> beh T", "by (erule beh_non_empty, auto)"], ["", "lemma beh_prefix_closed:\n  \"c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c @ b \\<in> beh T \\<Longrightarrow> b \\<in> beh T", "by (induct c, auto dest!: beh_immediate_prefix_closed)"], ["", "text \\<open>States in behaviours are exactly reachable.\\<close>"], ["", "lemma beh_in_reach [rule_format]:\n  \"b \\<in> beh T \\<Longrightarrow> (\\<forall>s \\<in> set b. s \\<in> reach T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<in> beh T \\<Longrightarrow> \\<forall>s\\<in>set b. s \\<in> reach T", "by (erule beh.induct) (auto)"], ["", "lemma reach_in_beh:\n  \"s \\<in> reach T \\<Longrightarrow> \\<exists>b \\<in> beh T. s \\<in> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b", "proof (induction rule: reach.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b\n 2. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "case (r_init s)"], ["proof (state)\nthis:\n  s \\<in> init T\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init T \\<Longrightarrow> \\<exists>b\\<in>beh T. s \\<in> set b\n 2. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> init T\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. s \\<in> set b", "by (auto intro: bexI [where x=\"[s]\"])"], ["proof (state)\nthis:\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "case (r_trans s t)"], ["proof (state)\nthis:\n  (s, t) \\<in> TS.trans T\n  s \\<in> reach T\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<And>s t.\n       \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n        \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "thus ?case"], ["proof (prove)\nusing this:\n  (s, t) \\<in> TS.trans T\n  s \\<in> reach T\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. t \\<in> set b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n     \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "from r_trans(3)"], ["proof (chain)\npicking this:\n  \\<exists>b\\<in>beh T. s \\<in> set b", "obtain b b0 b1 where \"b \\<in> beh T\" \"b = b1 @ s # b0\""], ["proof (prove)\nusing this:\n  \\<exists>b\\<in>beh T. s \\<in> set b\n\ngoal (1 subgoal):\n 1. (\\<And>b b1 b0.\n        \\<lbrakk>b \\<in> beh T; b = b1 @ s # b0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto dest: split_list)"], ["proof (state)\nthis:\n  b \\<in> beh T\n  b = b1 @ s # b0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n     \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "hence \"s # b0 \\<in> beh T\""], ["proof (prove)\nusing this:\n  b \\<in> beh T\n  b = b1 @ s # b0\n\ngoal (1 subgoal):\n 1. s # b0 \\<in> beh T", "by (auto intro: beh_prefix_closed)"], ["proof (state)\nthis:\n  s # b0 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n     \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "hence \"t # s # b0 \\<in> beh T\""], ["proof (prove)\nusing this:\n  s # b0 \\<in> beh T\n\ngoal (1 subgoal):\n 1. t # s # b0 \\<in> beh T", "using \\<open>(s, t) \\<in> trans T\\<close>"], ["proof (prove)\nusing this:\n  s # b0 \\<in> beh T\n  (s, t) \\<in> TS.trans T\n\ngoal (1 subgoal):\n 1. t # s # b0 \\<in> beh T", "by auto"], ["proof (state)\nthis:\n  t # s # b0 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, t) \\<in> TS.trans T; s \\<in> reach T;\n     \\<exists>b\\<in>beh T. s \\<in> set b\\<rbrakk>\n    \\<Longrightarrow> \\<exists>b\\<in>beh T. t \\<in> set b", "thus ?thesis"], ["proof (prove)\nusing this:\n  t # s # b0 \\<in> beh T\n\ngoal (1 subgoal):\n 1. \\<exists>b\\<in>beh T. t \\<in> set b", "by - (rule bexI, auto)"], ["proof (state)\nthis:\n  \\<exists>b\\<in>beh T. t \\<in> set b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>b\\<in>beh T. t \\<in> set b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reach_equiv_beh_states: \"reach T = (\\<Union>b\\<in>beh T. set b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T = \\<Union> (set ` beh T)", "by (auto intro!: reach_in_beh beh_in_reach)"], ["", "text \\<open>Consecutive states in a behavior are connected by the transition relation\\<close>"], ["", "lemma beh_consecutive_in_trans:\n  assumes \"b \\<in> beh TS\"\n  and \"Suc i < length b\"\n  and \"s = b ! Suc i\"\n  and \"t = b ! i\"\n  shows \"(s, t) \\<in> trans TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, t) \\<in> TS.trans TS", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (s, t) \\<in> TS.trans TS", "from assms"], ["proof (chain)\npicking this:\n  b \\<in> beh TS\n  Suc i < length b\n  s = b ! Suc i\n  t = b ! i", "have\n    \"b = take i b @ t # s # drop (Suc (Suc i)) b\""], ["proof (prove)\nusing this:\n  b \\<in> beh TS\n  Suc i < length b\n  s = b ! Suc i\n  t = b ! i\n\ngoal (1 subgoal):\n 1. b = take i b @ t # s # drop (Suc (Suc i)) b", "by(auto simp add: id_take_nth_drop Cons_nth_drop_Suc)"], ["proof (state)\nthis:\n  b = take i b @ t # s # drop (Suc (Suc i)) b\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> TS.trans TS", "thus ?thesis"], ["proof (prove)\nusing this:\n  b = take i b @ t # s # drop (Suc (Suc i)) b\n\ngoal (1 subgoal):\n 1. (s, t) \\<in> TS.trans TS", "by (metis assms(1) beh_non_empty beh_prefix_closed list.distinct(1) list.inject)"], ["proof (state)\nthis:\n  (s, t) \\<in> TS.trans TS\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Specifications, observability, and implementation\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Specifications add an observer function to transition systems.\\<close>"], ["", "record ('s, 'o) spec = \"'s TS\" +\n  obs :: \"'s \\<Rightarrow> 'o\""], ["", "lemma beh_obs_upd [simp]: \"beh (S(| obs := x |)) = beh S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. beh (S\\<lparr>obs := x\\<rparr>) = beh S", "by (safe) (erule beh.induct, auto)+"], ["", "lemma reach_obs_upd [simp]: \"reach (S(| obs := x |)) = reach S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (S\\<lparr>obs := x\\<rparr>) = reach S", "by (safe) (erule reach.induct, auto)+"], ["", "text \\<open>Observable behaviour and reachability.\\<close>"], ["", "definition \n  obeh :: \"('s, 'o) spec \\<Rightarrow> ('o list) set\" where\n  \"obeh S \\<equiv> (map (obs S))`(beh S)\""], ["", "definition \n  oreach :: \"('s, 'o) spec \\<Rightarrow> 'o set\" where \n  \"oreach S \\<equiv> (obs S)`(reach S)\""], ["", "lemma oreach_equiv_obeh_states: \"oreach S = (\\<Union>b\\<in>obeh S. set b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oreach S = \\<Union> (set ` obeh S)", "by (auto simp add: reach_equiv_beh_states oreach_def obeh_def)"], ["", "lemma obeh_pi_translation:\n  \"(map pi)`(obeh S) = obeh (S(| obs := pi o (obs S) |))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map pi ` obeh S = obeh (S\\<lparr>obs := pi \\<circ> obs S\\<rparr>)", "by (simp add: obeh_def image_comp)"], ["", "lemma oreach_pi_translation:\n  \"pi`(oreach S) = oreach (S(| obs := pi o (obs S) |))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pi ` oreach S = oreach (S\\<lparr>obs := pi \\<circ> obs S\\<rparr>)", "by (auto simp add: oreach_def)"], ["", "text \\<open>A predicate $P$ on the states of a specification is \\emph{observable} \nif it cannot distinguish between states yielding the same observation. \nEquivalently, $P$ is observable if it is the inverse image under the \nobservation function of a predicate on observations.\\<close>"], ["", "definition \n  observable :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable ob P \\<equiv> \\<forall>s s'. ob s = ob s' \\<longrightarrow> s' \\<in> P \\<longrightarrow> s \\<in> P\""], ["", "definition \n  observable2 :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable2 ob P \\<equiv> \\<exists>Q. P = ob-`Q\""], ["", "definition \n  observable3 :: \"['s \\<Rightarrow> 'o, 's set] \\<Rightarrow> bool\"\nwhere\n  \"observable3 ob P \\<equiv> ob-`ob`P \\<subseteq> P\"    \\<comment> \\<open>other direction holds trivially\\<close>"], ["", "lemma observableE [elim]:\n  \"\\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk> \\<Longrightarrow> s \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>observable ob P; ob s = ob s'; s' \\<in> P\\<rbrakk>\n    \\<Longrightarrow> s \\<in> P", "by (unfold observable_def) (fast)"], ["", "lemma observable2_equiv_observable: \"observable2 ob P = observable ob P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable2 ob P = observable ob P", "by (unfold observable_def observable2_def) (auto)"], ["", "lemma observable3_equiv_observable2: \"observable3 ob P = observable2 ob P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable3 ob P = observable2 ob P", "by (unfold observable3_def observable2_def) (auto)"], ["", "lemma observable_id [simp]: \"observable id P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. observable id P", "by (simp add: observable_def)"], ["", "text \\<open>The set extension of a function @{term \"ob\"} is the left adjoint of \na Galois connection on the powerset lattices over domain and range of @{term \"ob\"} \nwhere the right adjoint is the inverse image function.\\<close>"], ["", "lemma image_vimage_adjoints: \"(ob`P \\<subseteq> Q) = (P \\<subseteq> ob-`Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ob ` P \\<subseteq> Q) = (P \\<subseteq> ob -` Q)", "by auto"], ["", "declare image_vimage_subset [simp, intro]"], ["", "declare vimage_image_subset [simp, intro]"], ["", "text \\<open>Similar but \"reversed\" (wrt to adjointness) relationships only hold under\nadditional conditions.\\<close>"], ["", "lemma image_r_vimage_l: \"\\<lbrakk> Q \\<subseteq> ob`P; observable ob P \\<rbrakk> \\<Longrightarrow> ob-`Q \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<subseteq> ob ` P; observable ob P\\<rbrakk>\n    \\<Longrightarrow> ob -` Q \\<subseteq> P", "by (auto)"], ["", "lemma vimage_l_image_r: \"\\<lbrakk> ob-`Q \\<subseteq> P; Q \\<subseteq> range ob \\<rbrakk> \\<Longrightarrow> Q \\<subseteq> ob`P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ob -` Q \\<subseteq> P; Q \\<subseteq> range ob\\<rbrakk>\n    \\<Longrightarrow> Q \\<subseteq> ob ` P", "by (drule image_mono [where f=ob], auto)"], ["", "text \\<open>Internal and external invariants\\<close>"], ["", "lemma external_from_internal_invariant: \n  \"\\<lbrakk> reach S \\<subseteq> P; (obs S)`P \\<subseteq> Q \\<rbrakk>  \n  \\<Longrightarrow> oreach S \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach S \\<subseteq> P; obs S ` P \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> oreach S \\<subseteq> Q", "by (auto simp add: oreach_def)"], ["", "lemma external_from_internal_invariant_vimage: \n  \"\\<lbrakk> reach S \\<subseteq> P; P \\<subseteq> (obs S)-`Q \\<rbrakk>\n  \\<Longrightarrow> oreach S \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach S \\<subseteq> P; P \\<subseteq> obs S -` Q\\<rbrakk>\n    \\<Longrightarrow> oreach S \\<subseteq> Q", "by (erule external_from_internal_invariant) (auto)"], ["", "lemma external_to_internal_invariant_vimage: \n  \"\\<lbrakk> oreach S \\<subseteq> Q; (obs S)-`Q \\<subseteq> P \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach S \\<subseteq> Q; obs S -` Q \\<subseteq> P\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (auto simp add: oreach_def)"], ["", "lemma external_to_internal_invariant:\n  \"\\<lbrakk> oreach S \\<subseteq> Q; Q \\<subseteq> (obs S)`P; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach S \\<subseteq> Q; Q \\<subseteq> obs S ` P;\n     observable (obs S) P\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (erule external_to_internal_invariant_vimage) (auto)"], ["", "lemma external_equiv_internal_invariant_vimage: \n  \"\\<lbrakk> P = (obs S)-`Q \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = obs S -` Q \\<Longrightarrow>\n    (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)", "by (fast intro: external_from_internal_invariant_vimage\n                external_to_internal_invariant_vimage \n         del: subsetI)"], ["", "lemma external_equiv_internal_invariant: \n  \"\\<lbrakk> (obs S)`P = Q; observable (obs S) P \\<rbrakk> \n  \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs S ` P = Q; observable (obs S) P\\<rbrakk>\n    \\<Longrightarrow> (oreach S \\<subseteq> Q) = (reach S \\<subseteq> P)", "by (rule external_equiv_internal_invariant_vimage) (auto)"], ["", "text \\<open>Our notion of implementation is inclusion of observable behaviours.\\<close>"], ["", "definition \n  implements :: \"['p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\" where\n  \"implements pi Sa Sc \\<equiv> (map pi)`(obeh Sc) \\<subseteq> obeh Sa\""], ["", "text \\<open>Reflexivity and transitivity\\<close>"], ["", "lemma implements_refl: \"implements id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements id S S", "by (auto simp add: implements_def)"], ["", "lemma implements_trans:\n  \"\\<lbrakk> implements pi1 S1 S2; implements pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> implements (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>implements pi1 S1 S2; implements pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> implements (pi1 \\<circ> pi2) S1 S3", "by (auto simp add: implements_def image_comp del: subsetI\n         dest: image_mono [where f=\"map pi1\"])"], ["", "text \\<open>Preservation of external invariants\\<close>"], ["", "lemma implements_oreach:\n  \"implements pi Sa Sc \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> oreach Sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. implements pi Sa Sc \\<Longrightarrow>\n    pi ` oreach Sc \\<subseteq> oreach Sa", "by (auto simp add: implements_def oreach_equiv_obeh_states dest!: subsetD)"], ["", "lemma external_invariant_preservation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> pi`(oreach Sc) \\<subseteq> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi ` oreach Sc \\<subseteq> Q", "by (rule subset_trans [OF implements_oreach]) (auto)"], ["", "lemma external_invariant_translation:\n  \"\\<lbrakk> oreach Sa \\<subseteq> Q; pi-`Q \\<subseteq> P; implements pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> oreach Sc \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> oreach Sc \\<subseteq> P", "apply (rule subset_trans [OF vimage_image_subset, of pi])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` pi ` oreach Sc \\<subseteq> P", "apply (rule subset_trans [where B=\"pi-`Q\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` pi ` oreach Sc \\<subseteq> pi -` Q\n 2. \\<lbrakk>oreach Sa \\<subseteq> Q; pi -` Q \\<subseteq> P;\n     implements pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> pi -` Q \\<subseteq> P", "apply (intro vimage_mono external_invariant_preservation, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Preservation of internal invariants\\<close>"], ["", "lemma internal_invariant_translation:\n  \"\\<lbrakk> reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa; pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S \\<rbrakk>\n  \\<Longrightarrow> reach S \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>reach Sa \\<subseteq> Pa; Pa \\<subseteq> obs Sa -` Qa;\n     pi -` Qa \\<subseteq> Q; obs S -` Q \\<subseteq> P;\n     implements pi Sa S\\<rbrakk>\n    \\<Longrightarrow> reach S \\<subseteq> P", "by (rule external_from_internal_invariant_vimage [\n      THEN external_invariant_translation, \n      THEN external_to_internal_invariant_vimage]) \n   (assumption+)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>First we define Hoare triples over transition relations and then\nwe derive proof rules to establish invariants.\\<close>"], ["", "subsubsection \\<open>Hoare triples\\<close>"], ["", "(******************************************************************************)"], ["", "definition \n  PO_hoare :: \"['s set, ('s \\<times> 's) set, 's set] \\<Rightarrow> bool\"\n     (\"(3{_} _ {> _})\" [0, 0, 0] 90)\nwhere\n  \"{pre} R {> post} \\<equiv> R``pre \\<subseteq> post\""], ["", "lemmas PO_hoare_defs = PO_hoare_def Image_def"], ["", "lemma \"{P} R {> Q} = (\\<forall>s t. s \\<in> P \\<longrightarrow> (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R {> Q} =\n    (\\<forall>s t.\n        s \\<in> P \\<longrightarrow>\n        (s, t) \\<in> R \\<longrightarrow> t \\<in> Q)", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoareD:\n  \"\\<lbrakk> {I} R {>J}; s \\<in> I; (s, s') \\<in> R \\<rbrakk> \\<Longrightarrow> s' \\<in> J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{I} R {> J}; s \\<in> I; (s, s') \\<in> R\\<rbrakk>\n    \\<Longrightarrow> s' \\<in> J", "by(auto simp add: PO_hoare_def)"], ["", "text \\<open>Some essential facts about Hoare triples.\\<close>"], ["", "lemma hoare_conseq_left [intro]:\n  \"\\<lbrakk> {P'} R {> Q}; P \\<subseteq> P' \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P'} R {> Q}; P \\<subseteq> P'\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_conseq_right:\n  \"\\<lbrakk> {P} R {> Q'}; Q' \\<subseteq> Q \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P} R {> Q'}; Q' \\<subseteq> Q\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_false_left [simp]:\n  \"{{}} R {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{}} R {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_true_right [simp]:\n  \"{P} R {> UNIV}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R {> UNIV}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_conj_right [intro!]:\n  \"\\<lbrakk> {P} R {> Q1}; {P} R {> Q2} \\<rbrakk>\n  \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{P} R {> Q1}; {P} R {> Q2}\\<rbrakk>\n    \\<Longrightarrow> {P} R {> Q1 \\<inter> Q2}", "by (auto simp add: PO_hoare_defs)"], ["", "text \\<open>Special transition relations.\\<close>"], ["", "lemma hoare_stop [simp, intro!]:\n  \"{P} {} {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} {} {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_skip [simp, intro!]: \n  \"P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<subseteq> Q \\<Longrightarrow> {P} Id {> Q}", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_trans_Un [iff]:\n  \"{P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} R1 \\<union> R2 {> Q} = ({P} R1 {> Q} \\<and> {P} R2 {> Q})", "by (auto simp add: PO_hoare_defs)"], ["", "lemma hoare_trans_UN [iff]:\n  \"{P} \\<Union> x. R x {> Q} = (\\<forall>x. {P} R x {> Q})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {P} \\<Union> (range R) {> Q} = (\\<forall>x. {P} R x {> Q})", "by (auto simp add: PO_hoare_defs)"], ["", "subsubsection \\<open>Characterization of reachability\\<close>"], ["", "(******************************************************************************)"], ["", "lemma reach_init: \"reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T \\<subseteq> I \\<Longrightarrow> init T \\<subseteq> I", "by (auto dest: subsetD)"], ["", "lemma reach_trans: \"reach T \\<subseteq> I \\<Longrightarrow> {reach T} trans T {> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach T \\<subseteq> I \\<Longrightarrow> {reach T} TS.trans T {> I}", "by (auto simp add: PO_hoare_defs)"], ["", "text \\<open>Useful consequences.\\<close>"], ["", "corollary init_reach [iff]: \"init T \\<subseteq> reach T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init T \\<subseteq> reach T", "by (rule reach_init, simp)"], ["", "corollary trans_reach [iff]: \"{reach T} trans T {> reach T}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {reach T} TS.trans T {> reach T}", "by (rule reach_trans, simp)"], ["", "subsubsection \\<open>Invariant proof rules\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Basic proof rule for invariants.\\<close>"], ["", "lemma inv_rule_basic:\n  \"\\<lbrakk> init T \\<subseteq> P; {P} (trans T) {> P} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> P; {P} TS.trans T {> P}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "by (safe, erule reach.induct, auto simp add: PO_hoare_def)"], ["", "text \\<open>General invariant proof rule. This rule is complete (set \n@{term \"I = reach T\"}).\\<close>"], ["", "lemma inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "apply (rule subset_trans, auto)              \\<comment> \\<open>strengthen goal\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P; {I} TS.trans T {> I};\n        x \\<in> reach T\\<rbrakk>\n       \\<Longrightarrow> x \\<in> I", "apply (erule reach.induct, auto simp add: PO_hoare_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>The following rule is equivalent to the previous one.\\<close>"], ["", "lemma INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I;\n     {I \\<inter> reach T} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (safe, erule reach.induct, auto simp add: PO_hoare_defs)"], ["", "text \\<open>Proof of equivalence.\\<close>"], ["", "lemma inv_rule_from_INV_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; I \\<subseteq> P; {I} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> P", "apply (rule subset_trans, auto del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; I \\<subseteq> P;\n     {I} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "apply (rule INV_rule, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma INV_rule_from_inv_rule:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> reach T} (trans T) {> I} \\<rbrakk>\n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I;\n     {I \\<inter> reach T} TS.trans T {> I}\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (rule_tac I=\"I \\<inter> reach T\" in inv_rule, auto)"], ["", "text \\<open>Incremental proof rule for invariants using auxiliary invariant(s). \nThis rule might have become obsolete by addition of $INV\\_rule$.\\<close>"], ["", "lemma inv_rule_incr:\n  \"\\<lbrakk> init T \\<subseteq> I; {I \\<inter> J} (trans T) {> I}; reach T \\<subseteq> J \\<rbrakk>    \n  \\<Longrightarrow> reach T \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init T \\<subseteq> I; {I \\<inter> J} TS.trans T {> I};\n     reach T \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> reach T \\<subseteq> I", "by (rule INV_rule, auto)"], ["", "(******************************************************************************)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Our notion of refinement is simulation. We first define a general\nnotion of relational Hoare tuple, which we then use to define the refinement\nproof obligation.  Finally, we show that observation-consistent refinement \nof specifications implies the implementation relation between them.\\<close>"], ["", "subsubsection \\<open>Relational Hoare tuples\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Relational Hoare tuples formalize the following generalized simulation \ndiagram:\n\n\\begin{verbatim}\n                           o -- Ra --> o\n                           |           |\n                          pre         post\n                           |           |\n                           v           V\n                           o -- Rc --> o\n\\end{verbatim}\n\nHere, $Ra$ and $Rc$ are the abstract and concrete transition relations, \nand $pre$ and $post$ are the pre- and post-relations.\n(In the definiton below, the operator @{term \"(O)\"} stands for relational \ncomposition, which is defined as follows: @{thm relcomp_def [no_vars]}.)\\<close>"], ["", "definition\n  PO_rhoare :: \n    \"[('s \\<times> 't) set, ('s \\<times> 's) set, ('t \\<times> 't) set, ('s \\<times> 't) set] \\<Rightarrow> bool\"\n     (\"(4{_} _, _ {> _})\" [0, 0, 0] 90)\nwhere\n  \"{pre} Ra, Rc {> post} \\<equiv> pre O Rc \\<subseteq> Ra O post\""], ["", "lemmas PO_rhoare_defs = PO_rhoare_def relcomp_unfold"], ["", "text \\<open>Facts about relational Hoare tuples.\\<close>"], ["", "lemma relhoare_conseq_left [intro]:\n  \"\\<lbrakk> {pre'} Ra, Rc {> post}; pre \\<subseteq> pre' \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre'} Ra, Rc {> post}; pre \\<subseteq> pre'\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs dest!: subsetD)"], ["", "lemma relhoare_conseq_right:                    \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"\\<lbrakk> {pre} Ra, Rc {> post'}; post' \\<subseteq> post \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre} Ra, Rc {> post'}; post' \\<subseteq> post\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_false_left [simp]:               \\<comment> \\<open>do NOT declare [intro]\\<close>\n  \"{ {} } Ra, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {{}} Ra, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_true_right [simp]:                \\<comment> \\<open>not true in general\\<close>\n  \"{pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, Rc {> UNIV} = (Domain (pre O Rc) \\<subseteq> Domain Ra)", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma Domain_rel_comp [intro]:\n  \"Domain pre \\<subseteq> R \\<Longrightarrow> Domain (pre O Rc) \\<subseteq> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain pre \\<subseteq> R \\<Longrightarrow>\n    Domain (pre O Rc) \\<subseteq> R", "by (auto simp add: Domain_def)"], ["", "lemma rel_hoare_skip [iff]: \"{R} Id, Id {> R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R} Id, Id {> R}", "by (auto simp add: PO_rhoare_def)"], ["", "text \\<open>Reflexivity and transitivity.\\<close>"], ["", "lemma relhoare_refl [simp]: \"{Id} R, R {> Id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Id} R, R {> Id}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma rhoare_trans:\n  \"\\<lbrakk> {R1} T1, T2 {> R1}; {R2} T2, T3 {> R2} \\<rbrakk>\n  \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R1} T1, T2 {> R1}; {R2} T2, T3 {> R2}\\<rbrakk>\n    \\<Longrightarrow> {R1 O R2} T1, T3 {> R1 O R2}", "apply (auto simp add: PO_rhoare_def del: subsetI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O T2 \\<subseteq> T1 O R1;\n     R2 O T3 \\<subseteq> T2 O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (drule subset_refl [THEN relcomp_mono, where r=R1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O T2 \\<subseteq> T1 O R1;\n     R1 O R2 O T3 \\<subseteq> R1 O T2 O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (drule subset_refl [THEN [2] relcomp_mono, where s=R2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R1 O R2 O T3 \\<subseteq> R1 O T2 O R2;\n     (R1 O T2) O R2 \\<subseteq> (T1 O R1) O R2\\<rbrakk>\n    \\<Longrightarrow> (R1 O R2) O T3 \\<subseteq> T1 O R1 O R2", "apply (auto simp add: O_assoc del: subsetI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Conjunction in the post-relation cannot be split in general.  However, \nhere are two useful special cases.  In the first case the abstract transtition \nrelation is deterministic and in the second case one conjunct is a cartesian \nproduct of two state predicates.\\<close>"], ["", "lemma relhoare_conj_right_det:                 \n  \"\\<lbrakk> {pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra \\<rbrakk>                           \\<comment> \\<open>only for deterministic \\<open>Ra\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{pre} Ra, Rc {> post1}; {pre} Ra, Rc {> post2};\n     single_valued Ra\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post1 \\<inter> post2}", "by (auto simp add: PO_rhoare_defs dest: single_valuedD dest!: subsetD)"], ["", "lemma relhoare_conj_right_cartesian [intro]:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk> \n  \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post}\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> post \\<inter> I \\<times> J}", "by (force simp add: PO_rhoare_defs PO_hoare_defs Domain_def Range_def)"], ["", "text \\<open>Separate rule for cartesian products.\\<close>"], ["", "corollary relhoare_cartesian:\n  \"\\<lbrakk> {Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post} \\<rbrakk>                      \\<comment> \\<open>any \\<open>post\\<close>, including \\<open>UNIV\\<close>!\\<close>\n  \\<Longrightarrow> {pre} Ra, Rc {> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{Domain pre} Ra {> I}; {Range pre} Rc {> J};\n     {pre} Ra, Rc {> post}\\<rbrakk>\n    \\<Longrightarrow> {pre} Ra, Rc {> I \\<times> J}", "by (auto intro: relhoare_conseq_right)"], ["", "text \\<open>Unions of transition relations.\\<close>"], ["", "lemma relhoare_concrete_Un [simp]:\n  \"{pre} Ra, Rc1 \\<union> Rc2 {> post} \n   = ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, Rc1 \\<union> Rc2 {> post} =\n    ({pre} Ra, Rc1 {> post} \\<and> {pre} Ra, Rc2 {> post})", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc1}\n                \\<subseteq> {(x, z).\n                             \\<exists>y.\n                                (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        {(x, z). \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc2}\n        \\<subseteq> {(x, z).\n                     \\<exists>y. (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma relhoare_concrete_UN [simp]:\n  \"{pre} Ra, \\<Union>x. Rc x {> post} = (\\<forall>x. {pre} Ra, Rc x {> post})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra, \\<Union> (range Rc) {> post} =\n    (\\<forall>x. {pre} Ra, Rc x {> post})", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y.\n                    (x, y) \\<in> pre \\<and> (\\<exists>x. (y, z) \\<in> Rc x)}\n                \\<subseteq> {(x, z).\n                             \\<exists>y.\n                                (x, y) \\<in> Ra \\<and> (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post\n 2. \\<And>a b y x.\n       \\<lbrakk>\\<forall>x.\n                   {(xa, z).\n                    \\<exists>y. (xa, y) \\<in> pre \\<and> (y, z) \\<in> Rc x}\n                   \\<subseteq> {(x, z).\n                                \\<exists>y.\n                                   (x, y) \\<in> Ra \\<and>\n                                   (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc x\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> Ra \\<and> (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma relhoare_abstract_Un_left [intro]:\n  \"\\<lbrakk> {pre} Ra1, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra1, Rc {> post} \\<Longrightarrow>\n    {pre} Ra1 \\<union> Ra2, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_abstract_Un_right [intro]:\n  \"\\<lbrakk> {pre} Ra2, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} Ra1 \\<union> Ra2, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra2, Rc {> post} \\<Longrightarrow>\n    {pre} Ra1 \\<union> Ra2, Rc {> post}", "by (auto simp add: PO_rhoare_defs)"], ["", "lemma relhoare_abstract_UN [intro!]:   \\<comment> \\<open>might be too aggressive?\\<close>\n  \"\\<lbrakk> {pre} Ra x, Rc {> post} \\<rbrakk>\n  \\<Longrightarrow> {pre} \\<Union>x. Ra x, Rc {> post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {pre} Ra x, Rc {> post} \\<Longrightarrow>\n    {pre} \\<Union> (range Ra), Rc {> post}", "apply (auto simp add: PO_rhoare_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>{(x, z).\n                 \\<exists>y. (x, y) \\<in> pre \\<and> (y, z) \\<in> Rc}\n                \\<subseteq> {(xa, z).\n                             \\<exists>y.\n                                (xa, y) \\<in> Ra x \\<and>\n                                (y, z) \\<in> post};\n        (a, y) \\<in> pre; (y, b) \\<in> Rc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x. (a, y) \\<in> Ra x) \\<and>\n                            (y, b) \\<in> post", "apply (auto dest!: subsetD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsubsection \\<open>Refinement proof obligations\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>A transition system refines another one if the initial states and the\ntransitions are refined. \nInitial state refinement means that for each concrete initial state there is \na related abstract one. Transition refinement means that the simulation \nrelation is preserved (as expressed by a relational Hoare tuple). \n\\<close>"], ["", "definition \n  PO_refines :: \n    \"[('s \\<times> 't) set, ('s, 'a) TS_scheme, ('t, 'b) TS_scheme] \\<Rightarrow> bool\" \nwhere\n  \"PO_refines R Ta Tc \\<equiv> (\n       init Tc \\<subseteq> R``(init Ta)\n     \\<and> {R} (trans Ta), (trans Tc) {> R} \n  )\""], ["", "text \\<open>Basic refinement rule. This is just an introduction rule for the\ndefinition.\\<close>"], ["", "lemma refine_basic:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); {R} (trans Ta), (trans Tc) {> R} \\<rbrakk>\n  \\<Longrightarrow> PO_refines R Ta Tc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init Tc \\<subseteq> R `` init Ta;\n     {R} TS.trans Ta, TS.trans Tc {> R}\\<rbrakk>\n    \\<Longrightarrow> PO_refines R Ta Tc", "by (simp add: PO_refines_def)"], ["", "text \\<open>The following proof rule uses individual invariants @{term \"I\"} \nand @{term \"J\"} of the concrete and abstract systems to strengthen the \nsimulation relation $R$. \n\nThe hypotheses state that these state predicates are indeed invariants.\nNote that the pre-condition of the invariant preservation hypotheses for \n@{term \"I\"} and @{term \"J\"} are strengthened by adding the predicates \n@{term \"Domain (R \\<inter> UNIV \\<times> J)\"} and @{term \"Range (R \\<inter> I \\<times> UNIV)\"}, \nrespectively.  In particular, the latter predicate may be essential, if a \nconcrete invariant depends on the simulation relation and an abstract invariant, \ni.e. to \"transport\" abstract invariants to the concrete system.\\<close>"], ["", "lemma refine_init_using_invariants:\n  \"\\<lbrakk> init Tc \\<subseteq> R``(init Ta); init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> (R \\<inter> I \\<times> J)``(init Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>init Tc \\<subseteq> R `` init Ta; init Ta \\<subseteq> I;\n     init Tc \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> init Tc\n                      \\<subseteq> (R \\<inter> I \\<times> J) `` init Ta", "by (auto simp add: Image_def dest!: bspec subsetD)"], ["", "lemma refine_trans_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J} \\<rbrakk>\n  \\<Longrightarrow> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R  \\<inter> I \\<times> J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R \\<inter> I \\<times> J} TS.trans Ta, TS.trans Tc {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} TS.trans Ta {> I};\n     {J \\<inter>\n      Range (R \\<inter> I \\<times> UNIV)} TS.trans Tc {> J}\\<rbrakk>\n    \\<Longrightarrow> {R \\<inter>\n                       I \\<times>\n                       J} TS.trans\n                           Ta, TS.trans Tc {> R \\<inter> I \\<times> J}", "by (rule relhoare_conj_right_cartesian) (auto)"], ["", "text \\<open>This is our main rule for refinements.\\<close>"], ["", "lemma refine_using_invariants:\n  \"\\<lbrakk> {R \\<inter> I \\<times> J} (trans Ta), (trans Tc) {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} (trans Ta) {> I}; \n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} (trans Tc) {> J}; \n     init Tc \\<subseteq> R``(init Ta); \n     init Ta \\<subseteq> I; init Tc \\<subseteq> J \\<rbrakk>\n  \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>{R \\<inter> I \\<times> J} TS.trans Ta, TS.trans Tc {> R};\n     {I \\<inter> Domain (R \\<inter> UNIV \\<times> J)} TS.trans Ta {> I};\n     {J \\<inter> Range (R \\<inter> I \\<times> UNIV)} TS.trans Tc {> J};\n     init Tc \\<subseteq> R `` init Ta; init Ta \\<subseteq> I;\n     init Tc \\<subseteq> J\\<rbrakk>\n    \\<Longrightarrow> PO_refines (R \\<inter> I \\<times> J) Ta Tc", "by (unfold PO_refines_def)\n   (intro refine_init_using_invariants refine_trans_using_invariants conjI)"], ["", "subsubsection \\<open>Deriving invariants from refinements\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Some invariants can only be proved after the simulation has been \nestablished, because they depend on the simulation relation and some abstract\ninvariants.  Here is a rule to derive invariant theorems from the refinement.\\<close>"], ["", "lemma PO_refines_implies_Range_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> Range R", "by (auto simp add: PO_refines_def)"], ["", "lemma PO_refines_implies_Range_trans:\n  \"PO_refines R Ta Tc \\<Longrightarrow> {Range R} trans Tc {> Range R}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> {Range R} TS.trans Tc {> Range R}", "by (auto simp add: PO_refines_def PO_rhoare_def PO_hoare_def)"], ["", "lemma PO_refines_implies_Range_invariant:\n  \"PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> reach Tc \\<subseteq> Range R", "by (rule INV_rule)\n   (auto intro!: PO_refines_implies_Range_init \n                 PO_refines_implies_Range_trans)"], ["", "text \\<open>The following rules are more useful in proofs.\\<close>"], ["", "corollary INV_init_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> init Tc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> init Tc \\<subseteq> I", "by (drule PO_refines_implies_Range_init, auto)"], ["", "corollary INV_trans_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; K \\<subseteq> Range R; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> {K} trans Tc {> I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; K \\<subseteq> Range R;\n     Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> {K} TS.trans Tc {> I}", "apply (drule PO_refines_implies_Range_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>K \\<subseteq> Range R; Range R \\<subseteq> I;\n     {Range R} TS.trans Tc {> Range R}\\<rbrakk>\n    \\<Longrightarrow> {K} TS.trans Tc {> I}", "apply (auto intro: hoare_conseq_right)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "corollary INV_from_refinement: \n  \"\\<lbrakk> PO_refines R Ta Tc; Range R \\<subseteq> I \\<rbrakk>\n  \\<Longrightarrow> reach Tc \\<subseteq> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Ta Tc; Range R \\<subseteq> I\\<rbrakk>\n    \\<Longrightarrow> reach Tc \\<subseteq> I", "by (drule PO_refines_implies_Range_invariant, fast)"], ["", "subsubsection \\<open>Transfering abstract invariants to concrete systems\\<close>"], ["", "(******************************************************************************)"], ["", "lemmas hoare_conseq = hoare_conseq_right[OF hoare_conseq_left] for P' R Q'"], ["", "lemma PO_refines_implies_R_image_init:\n  \"PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> R `` (init Ta)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> R `` init Ta", "apply(rule subset_trans[where B=\"R `` init Ta\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. PO_refines R Ta Tc \\<Longrightarrow> init Tc \\<subseteq> R `` init Ta\n 2. PO_refines R Ta Tc \\<Longrightarrow>\n    R `` init Ta \\<subseteq> R `` init Ta", "apply (auto simp add: PO_refines_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma commute_dest:\n  \"\\<lbrakk> R O Tc \\<subseteq> Ta O R; (sa, sc) \\<in> R; (sc, sc') \\<in> Tc \\<rbrakk> \\<Longrightarrow> \\<exists>sa'. (sa, sa') \\<in> Ta \\<and> (sa', sc') \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>R O Tc \\<subseteq> Ta O R; (sa, sc) \\<in> R;\n     (sc, sc') \\<in> Tc\\<rbrakk>\n    \\<Longrightarrow> \\<exists>sa'.\n                         (sa, sa') \\<in> Ta \\<and> (sa', sc') \\<in> R", "by(auto)"], ["", "lemma PO_refines_implies_R_image_trans:\n  assumes \"PO_refines R Ta Tc\"\n  shows \"{R `` reach Ta} trans Tc {> R `` reach Ta}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R `` reach Ta} TS.trans Tc {> R `` reach Ta}", "using assms"], ["proof (prove)\nusing this:\n  PO_refines R Ta Tc\n\ngoal (1 subgoal):\n 1. {R `` reach Ta} TS.trans Tc {> R `` reach Ta}", "proof(unfold PO_hoare_def Image_def PO_refines_def PO_rhoare_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>PO_refines R Ta Tc; (xa, x) \\<in> TS.trans Tc;\n        xb \\<in> reach Ta; (xb, xa) \\<in> R;\n        init Tc \\<subseteq> {y. \\<exists>x\\<in>init Ta. (x, y) \\<in> R};\n        R O TS.trans Tc \\<subseteq> TS.trans Ta O R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>reach Ta. (xa, x) \\<in> R", "fix sc sc' sa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>PO_refines R Ta Tc; (xa, x) \\<in> TS.trans Tc;\n        xb \\<in> reach Ta; (xb, xa) \\<in> R;\n        init Tc \\<subseteq> {y. \\<exists>x\\<in>init Ta. (x, y) \\<in> R};\n        R O TS.trans Tc \\<subseteq> TS.trans Ta O R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>reach Ta. (xa, x) \\<in> R", "assume R: \"(sa, sc) \\<in> R\"\n    and step: \"(sc, sc') \\<in> TS.trans Tc\"\n    and sa_reach: \"sa \\<in> reach Ta\"\n    and trans_ref: \"R O trans Tc \\<subseteq> trans Ta O R\""], ["proof (state)\nthis:\n  (sa, sc) \\<in> R\n  (sc, sc') \\<in> TS.trans Tc\n  sa \\<in> reach Ta\n  R O TS.trans Tc \\<subseteq> TS.trans Ta O R\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>PO_refines R Ta Tc; (xa, x) \\<in> TS.trans Tc;\n        xb \\<in> reach Ta; (xb, xa) \\<in> R;\n        init Tc \\<subseteq> {y. \\<exists>x\\<in>init Ta. (x, y) \\<in> R};\n        R O TS.trans Tc \\<subseteq> TS.trans Ta O R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>reach Ta. (xa, x) \\<in> R", "from commute_dest[OF trans_ref R step] sa_reach"], ["proof (chain)\npicking this:\n  \\<exists>sa'. (sa, sa') \\<in> TS.trans Ta \\<and> (sa', sc') \\<in> R\n  sa \\<in> reach Ta", "show \" \\<exists>sa'\\<in>reach Ta. (sa', sc') \\<in> R\""], ["proof (prove)\nusing this:\n  \\<exists>sa'. (sa, sa') \\<in> TS.trans Ta \\<and> (sa', sc') \\<in> R\n  sa \\<in> reach Ta\n\ngoal (1 subgoal):\n 1. \\<exists>sa'\\<in>reach Ta. (sa', sc') \\<in> R", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>sa'\\<in>reach Ta. (sa', sc') \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma PO_refines_implies_R_image_invariant:\n  assumes \"PO_refines R Ta Tc\"\n  shows \"reach Tc \\<subseteq> R `` reach Ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach Tc \\<subseteq> R `` reach Ta", "proof(rule INV_rule)"], ["proof (state)\ngoal (2 subgoals):\n 1. init Tc \\<subseteq> R `` reach Ta\n 2. {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}", "show \"init Tc \\<subseteq> R `` reach Ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init Tc \\<subseteq> R `` reach Ta", "by (rule subset_trans[OF PO_refines_implies_R_image_init, OF assms]) (auto)"], ["proof (state)\nthis:\n  init Tc \\<subseteq> R `` reach Ta\n\ngoal (1 subgoal):\n 1. {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}", "show \"{R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}", "using assms"], ["proof (prove)\nusing this:\n  PO_refines R Ta Tc\n\ngoal (1 subgoal):\n 1. {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}", "by (auto intro!: PO_refines_implies_R_image_trans)"], ["proof (state)\nthis:\n  {R `` reach Ta \\<inter> reach Tc} TS.trans Tc {> R `` reach Ta}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_INV_init_transfer:\n  assumes\n    \"PO_refines R Ta Tc\"\n    \"init Ta \\<subseteq> I\"\n  shows \"init Tc \\<subseteq> R `` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init Tc \\<subseteq> R `` I", "using PO_refines_implies_R_image_init[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  init Tc \\<subseteq> R `` init Ta\n  init Ta \\<subseteq> I\n\ngoal (1 subgoal):\n 1. init Tc \\<subseteq> R `` I", "by(blast elim!: subset_trans intro: Image_mono)"], ["", "lemma abs_INV_trans_transfer:\n  assumes\n    ref: \"PO_refines R Ta Tc\"\n    and abs_hoare: \"{I} trans Ta {> J}\"\n  shows \"{R `` I} trans Tc {> R `` J}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {R `` I} TS.trans Tc {> R `` J}", "proof(unfold PO_hoare_def Image_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> TS.trans Tc; xb \\<in> I;\n        (xb, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>J. (xa, x) \\<in> R", "fix sc sc' sa"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> TS.trans Tc; xb \\<in> I;\n        (xb, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>J. (xa, x) \\<in> R", "assume step: \"(sc, sc') \\<in> trans Tc\" and abs_inv: \"sa \\<in> I\" and R: \"(sa, sc) \\<in> R\""], ["proof (state)\nthis:\n  (sc, sc') \\<in> TS.trans Tc\n  sa \\<in> I\n  (sa, sc) \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> TS.trans Tc; xb \\<in> I;\n        (xb, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>J. (xa, x) \\<in> R", "from ref step and R"], ["proof (chain)\npicking this:\n  PO_refines R Ta Tc\n  (sc, sc') \\<in> TS.trans Tc\n  (sa, sc) \\<in> R", "obtain sa' where \n    abs_step: \"(sa, sa') \\<in> trans Ta\" and R': \"(sa', sc') \\<in> R\""], ["proof (prove)\nusing this:\n  PO_refines R Ta Tc\n  (sc, sc') \\<in> TS.trans Tc\n  (sa, sc) \\<in> R\n\ngoal (1 subgoal):\n 1. (\\<And>sa'.\n        \\<lbrakk>(sa, sa') \\<in> TS.trans Ta; (sa', sc') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: PO_refines_def PO_rhoare_def)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> TS.trans Ta\n  (sa', sc') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> TS.trans Tc; xb \\<in> I;\n        (xb, xa) \\<in> R\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xa\\<in>J. (xa, x) \\<in> R", "with hoareD[OF abs_hoare abs_inv abs_step]"], ["proof (chain)\npicking this:\n  sa' \\<in> J\n  (sa, sa') \\<in> TS.trans Ta\n  (sa', sc') \\<in> R", "show \"\\<exists>sa'\\<in>J. (sa', sc') \\<in> R\""], ["proof (prove)\nusing this:\n  sa' \\<in> J\n  (sa, sa') \\<in> TS.trans Ta\n  (sa', sc') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>sa'\\<in>J. (sa', sc') \\<in> R", "by(blast)"], ["proof (state)\nthis:\n  \\<exists>sa'\\<in>J. (sa', sc') \\<in> R\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_INV_transfer:\n  assumes\n    \"PO_refines R Ta Tc\"\n    \"reach Ta \\<subseteq> I\"\n  shows \"reach Tc \\<subseteq> R `` I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach Tc \\<subseteq> R `` I", "using PO_refines_implies_R_image_invariant[OF assms(1)] assms(2)"], ["proof (prove)\nusing this:\n  reach Tc \\<subseteq> R `` reach Ta\n  reach Ta \\<subseteq> I\n\ngoal (1 subgoal):\n 1. reach Tc \\<subseteq> R `` I", "by(auto)"], ["", "subsubsection \\<open>Refinement of specifications\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Lift relation membership to finite sequences\\<close>"], ["", "inductive_set \n  seq_lift :: \"('s \\<times> 't) set \\<Rightarrow> ('s list \\<times> 't list) set\" \n  for R :: \"('s \\<times> 't) set\"\nwhere\n  sl_nil [iff]: \"([], []) \\<in> seq_lift R\"\n| sl_cons [intro]: \n    \"\\<lbrakk> (xs, ys) \\<in> seq_lift R; (x, y) \\<in> R \\<rbrakk> \\<Longrightarrow> (x#xs, y#ys) \\<in> seq_lift R\""], ["", "inductive_cases sl_cons_right_invert: \"(ba', t # bc) \\<in> seq_lift R\""], ["", "text \\<open>For each concrete behaviour there is a related abstract one.\\<close>"], ["", "lemma behaviour_refinement:\nassumes \"PO_refines R Ta Tc\" \"bc \\<in> beh Tc\" \nshows \"\\<exists>ba \\<in> beh Ta. (ba, bc) \\<in> seq_lift R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, bc) \\<in> seq_lift R", "using assms(2)"], ["proof (prove)\nusing this:\n  bc \\<in> beh Tc\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, bc) \\<in> seq_lift R", "proof (induct rule: beh.induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>ba\\<in>beh Ta. (ba, []) \\<in> seq_lift R\n 2. \\<And>s.\n       s \\<in> init Tc \\<Longrightarrow>\n       \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 3. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "case b_empty"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<exists>ba\\<in>beh Ta. (ba, []) \\<in> seq_lift R\n 2. \\<And>s.\n       s \\<in> init Tc \\<Longrightarrow>\n       \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 3. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, []) \\<in> seq_lift R", "by auto"], ["proof (state)\nthis:\n  \\<exists>ba\\<in>beh Ta. (ba, []) \\<in> seq_lift R\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init Tc \\<Longrightarrow>\n       \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 2. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init Tc \\<Longrightarrow>\n       \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 2. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "case (b_init s)"], ["proof (state)\nthis:\n  s \\<in> init Tc\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> init Tc \\<Longrightarrow>\n       \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n 2. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "thus ?case"], ["proof (prove)\nusing this:\n  s \\<in> init Tc\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R", "using assms(1)"], ["proof (prove)\nusing this:\n  s \\<in> init Tc\n  PO_refines R Ta Tc\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R", "by (auto simp add: PO_refines_def)"], ["proof (state)\nthis:\n  \\<exists>ba\\<in>beh Ta. (ba, [s]) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "case (b_trans s b s')"], ["proof (state)\nthis:\n  s # b \\<in> beh Tc\n  \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R\n  (s, s') \\<in> TS.trans Tc\n\ngoal (1 subgoal):\n 1. \\<And>s b t.\n       \\<lbrakk>s # b \\<in> beh Tc;\n        \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R;\n        (s, t) \\<in> TS.trans Tc\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ba\\<in>beh Ta.\n                            (ba, t # s # b) \\<in> seq_lift R", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "from b_trans(2)"], ["proof (chain)\npicking this:\n  \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R", "obtain t c where \"t # c \\<in> beh Ta\" \"(t, s) \\<in> R\" \"(t # c, s # b) \\<in> seq_lift R\""], ["proof (prove)\nusing this:\n  \\<exists>ba\\<in>beh Ta. (ba, s # b) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. (\\<And>t c.\n        \\<lbrakk>t # c \\<in> beh Ta; (t, s) \\<in> R;\n         (t # c, s # b) \\<in> seq_lift R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: sl_cons_right_invert)"], ["proof (state)\nthis:\n  t # c \\<in> beh Ta\n  (t, s) \\<in> R\n  (t # c, s # b) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "moreover"], ["proof (state)\nthis:\n  t # c \\<in> beh Ta\n  (t, s) \\<in> R\n  (t # c, s # b) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "from \\<open>(t, s) \\<in> R\\<close> \\<open>(s, s') \\<in> TS.trans Tc\\<close> assms(1)"], ["proof (chain)\npicking this:\n  (t, s) \\<in> R\n  (s, s') \\<in> TS.trans Tc\n  PO_refines R Ta Tc", "obtain t' where \"(t, t') \\<in> trans Ta\" \"(t', s') \\<in> R\""], ["proof (prove)\nusing this:\n  (t, s) \\<in> R\n  (s, s') \\<in> TS.trans Tc\n  PO_refines R Ta Tc\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        \\<lbrakk>(t, t') \\<in> TS.trans Ta; (t', s') \\<in> R\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: PO_refines_def PO_rhoare_def)"], ["proof (state)\nthis:\n  (t, t') \\<in> TS.trans Ta\n  (t', s') \\<in> R\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "ultimately"], ["proof (chain)\npicking this:\n  t # c \\<in> beh Ta\n  (t, s) \\<in> R\n  (t # c, s # b) \\<in> seq_lift R\n  (t, t') \\<in> TS.trans Ta\n  (t', s') \\<in> R", "have \"t' # t # c \\<in> beh Ta\" \"(t' # t # c, s' # s # b) \\<in> seq_lift R\""], ["proof (prove)\nusing this:\n  t # c \\<in> beh Ta\n  (t, s) \\<in> R\n  (t # c, s # b) \\<in> seq_lift R\n  (t, t') \\<in> TS.trans Ta\n  (t', s') \\<in> R\n\ngoal (1 subgoal):\n 1. t' # t # c \\<in> beh Ta &&& (t' # t # c, s' # s # b) \\<in> seq_lift R", "by auto"], ["proof (state)\nthis:\n  t' # t # c \\<in> beh Ta\n  (t' # t # c, s' # s # b) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "thus ?thesis"], ["proof (prove)\nusing this:\n  t' # t # c \\<in> beh Ta\n  (t' # t # c, s' # s # b) \\<in> seq_lift R\n\ngoal (1 subgoal):\n 1. \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ba\\<in>beh Ta. (ba, s' # s # b) \\<in> seq_lift R\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Observation consistency of a relation is defined using a mediator \nfunction @{term \"pi\"} to abstract the concrete observation.  This allows us \nto also refine the observables as we move down a refinement branch.\n\\<close>"], ["", "definition \n  obs_consistent :: \n    \"[('s \\<times> 't) set, 'p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\"\nwhere\n  \"obs_consistent R pi Sa Sc \\<equiv> (\\<forall>s t. (s, t) \\<in> R \\<longrightarrow> pi (obs Sc t) = obs Sa s)\""], ["", "lemma obs_consistent_refl [iff]: \"obs_consistent Id id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent Id id S S", "by (simp add: obs_consistent_def)"], ["", "lemma obs_consistent_trans [intro]: \n  \"\\<lbrakk> obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3 \\<rbrakk>\n  \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R1 pi1 S1 S2;\n     obs_consistent R2 pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> obs_consistent (R1 O R2) (pi1 \\<circ> pi2) S1 S3", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_empty: \"obs_consistent {} pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent {} pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_conj1 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R \\<inter> R') pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R pi Sa Sc \\<Longrightarrow>\n    obs_consistent (R \\<inter> R') pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_conj2 [intro]: \n  \"obs_consistent R pi Sa Sc \\<Longrightarrow> obs_consistent (R' \\<inter> R) pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_consistent R pi Sa Sc \\<Longrightarrow>\n    obs_consistent (R' \\<inter> R) pi Sa Sc", "by (auto simp add: obs_consistent_def)"], ["", "lemma obs_consistent_behaviours:\n  \"\\<lbrakk> obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa; (ba, bc) \\<in> seq_lift R\\<rbrakk>\n  \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R pi Sa Sc; bc \\<in> beh Sc; ba \\<in> beh Sa;\n     (ba, bc) \\<in> seq_lift R\\<rbrakk>\n    \\<Longrightarrow> map pi (map (obs Sc) bc) = map (obs Sa) ba", "by (erule seq_lift.induct) (auto simp add: obs_consistent_def)"], ["", "text \\<open>Definition of refinement proof obligations.\\<close>"], ["", "definition \n  refines :: \n    \"[('s \\<times> 't) set, 'p \\<Rightarrow> 'o, ('s, 'o) spec, ('t, 'p) spec] \\<Rightarrow> bool\" \nwhere\n  \"refines R pi Sa Sc \\<equiv> obs_consistent R pi Sa Sc \\<and> PO_refines R Sa Sc\""], ["", "lemmas refines_defs = \n  refines_def PO_refines_def"], ["", "lemma refinesI: \n  \"\\<lbrakk> PO_refines R Sa Sc; obs_consistent R pi Sa Sc \\<rbrakk>\n  \\<Longrightarrow> refines R pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>PO_refines R Sa Sc; obs_consistent R pi Sa Sc\\<rbrakk>\n    \\<Longrightarrow> refines R pi Sa Sc", "by (simp add: refines_def)"], ["", "lemma PO_refines_from_refines: \n  \"refines R pi Sa Sc \\<Longrightarrow> PO_refines R Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R pi Sa Sc \\<Longrightarrow> PO_refines R Sa Sc", "by (simp add: refines_def)"], ["", "text \\<open>Reflexivity and transitivity of refinement.\\<close>"], ["", "lemma refinement_reflexive: \"refines Id id S S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines Id id S S", "by (auto simp add: refines_defs)"], ["", "lemma refinement_transitive: \n  \"\\<lbrakk> refines R1 pi1 S1 S2; refines R2 pi2 S2 S3 \\<rbrakk> \n  \\<Longrightarrow> refines (R1 O R2) (pi1 o pi2) S1 S3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R1 pi1 S1 S2; refines R2 pi2 S2 S3\\<rbrakk>\n    \\<Longrightarrow> refines (R1 O R2) (pi1 \\<circ> pi2) S1 S3", "apply (auto simp add: refines_defs del: subsetI intro: rhoare_trans)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>obs_consistent R1 pi1 S1 S2; obs_consistent R2 pi2 S2 S3;\n     init S2 \\<subseteq> R1 `` init S1;\n     {R1} TS.trans S1, TS.trans S2 {> R1};\n     init S3 \\<subseteq> R2 `` init S2;\n     {R2} TS.trans S2, TS.trans S3 {> R2}\\<rbrakk>\n    \\<Longrightarrow> init S3 \\<subseteq> R2 `` R1 `` init S1", "apply (fastforce dest: Image_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Soundness of refinement for proving implementation\\<close>"], ["", "lemma observable_behaviour_refinement:\n  \"\\<lbrakk> refines R pi Sa Sc; bc \\<in> obeh Sc \\<rbrakk> \\<Longrightarrow> map pi bc \\<in> obeh Sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>refines R pi Sa Sc; bc \\<in> obeh Sc\\<rbrakk>\n    \\<Longrightarrow> map pi bc \\<in> obeh Sa", "by (auto simp add: refines_def obeh_def image_def\n         dest!: behaviour_refinement obs_consistent_behaviours)"], ["", "theorem refinement_soundness: \n  \"refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. refines R pi Sa Sc \\<Longrightarrow> implements pi Sa Sc", "by (auto simp add: implements_def \n         elim!: observable_behaviour_refinement)"], ["", "text \\<open>Extended versions of proof rules including observations\\<close>"], ["", "lemmas Refinement_basic = refine_basic [THEN refinesI]"], ["", "lemmas Refinement_using_invariants = refine_using_invariants [THEN refinesI]"], ["", "lemmas INV_init_from_Refinement = \n  INV_init_from_refinement [OF PO_refines_from_refines]"], ["", "lemmas INV_trans_from_Refinement = \n  INV_trans_from_refinement [OF PO_refines_from_refines]"], ["", "lemmas INV_from_Refinement = \n  INV_from_refinement [OF PO_refines_from_refines]"], ["", "end"]]}