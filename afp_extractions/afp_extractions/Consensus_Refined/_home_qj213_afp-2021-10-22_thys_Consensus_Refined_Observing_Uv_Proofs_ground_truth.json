{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Observing/Uv_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma two_step_step:\n   \"step = two_step\"\n   \"phase = two_phase\"", "lemmas UV_TS_defs = UV_TS_def CHO_to_TS_def UV_Alg_def CHOinitConfig_def\n  UV_initState_def", "lemma step_less_D:\n  \"0 < step r \\<Longrightarrow> step r = Suc 0\"", "lemma UV_trans:\n  \"CSHO_trans_alt UV_sendMsg (\\<lambda>r p st msgs crd st'. UV_nextState r p st msgs st') HOs SHOs crds = \n  UV_trans_step HOs SHOs next0 send0 0\n  \\<union> UV_trans_step HOs SHOs  next1 send1 1\n  \"", "lemmas UV_inv1I = UV_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas UV_inv1E [elim] = UV_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas UV_inv1D = UV_inv1_def [THEN setc_def_to_dest, rule_format]", "lemma UV_inv1_inductive:\n  \"init (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1\"\n  \"{UV_inv1} TS.trans (UV_TS HOs SHOs crds) {> UV_inv1}\"", "lemma UV_inv1_invariant:\n  \"reach (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1\"", "lemma HOs_intersect:\n  \"HOs r p \\<inter> HOs r' q \\<noteq> {}\"", "lemma HOs_nonempty:\n  \"HOs r p \\<noteq> {}\"", "lemma vote_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and inv: \"(r, cfg) \\<in> UV_inv1\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"agreed_vote (cfg' p) = Some v \\<longleftrightarrow> (\\<forall>q \\<in> HOs r p. last_obs (cfg q) = v)\"", "lemma same_new_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and inv: \"(r, cfg) \\<in> UV_inv1\"\n  and step_r: \"two_step r = 0\"\n  obtains v where \"\\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v\"", "lemma x_origin1:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  and last_obs: \"last_obs (cfg' p) = v\"\n  shows \n    \"\\<exists>q. last_obs (cfg q) = v\"", "lemma step0_ref:\n  \"{ref_rel \\<inter> UNIV \\<times> UV_inv1} \\<Union>r S v. tso_round0 r S v, \n    UV_trans_step HOs HOs next0 send0 0 {> ref_rel}\"", "lemma x_origin2:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  and last_obs: \"last_obs (cfg' p) = v\"\n  shows \n    \"(\\<exists>q. last_obs (cfg q) = v) \\<or> (\\<exists>q. agreed_vote (cfg q) = Some v)\"", "lemma decide_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  shows \n    \"D cfg cfg' \\<subseteq> {p. \\<exists>v. decide (cfg' p) = Some v \\<and> (\\<forall>q \\<in> HOs r p. agreed_vote (cfg q) = Some v)}\"", "lemma step1_ref:\n  \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV} \\<Union>r d_f o_f. tso_round1 r d_f o_f, \n    UV_trans_step HOs HOs next1 send1 (Suc 0) {> ref_rel}\"", "lemma UV_Refines_votes:\n  \"PO_refines (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UV_inv1)\n    tso_TS (UV_TS HOs HOs crds)\""], "translations": [["", "lemma two_step_step:\n   \"step = two_step\"\n   \"phase = two_phase\""], ["proof (prove)\ngoal (1 subgoal):\n 1. step = two_step &&& phase = two_phase", "by(auto simp add: step_def two_step_def phase_def two_phase_def)"], ["", "context mono_quorum\nbegin"], ["", "definition UV_Alg :: \"(process, val pstate, val msg)CHOAlgorithm\" where\n  \"UV_Alg = CHOAlgorithm.truncate UV_M\""], ["", "definition UV_TS ::\n  \"(round \\<Rightarrow> process HO) \\<Rightarrow> (round \\<Rightarrow> process HO) \\<Rightarrow> (round \\<Rightarrow> process) \\<Rightarrow> uv_TS_state TS\"\nwhere\n  \"UV_TS HOs SHOs crds = CHO_to_TS UV_Alg HOs SHOs (K o crds)\""], ["", "lemmas UV_TS_defs = UV_TS_def CHO_to_TS_def UV_Alg_def CHOinitConfig_def\n  UV_initState_def"], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "definition UV_trans_step \n  where\n  \"UV_trans_step HOs SHOs nxt_f snd_f stp \\<equiv> \\<Union>r \\<mu>.\n    {((r, cfg), (Suc r, cfg'))|cfg cfg'. step r = stp  \\<and> (\\<forall>p.\n      \\<mu> p \\<in> get_msgs (snd_f r) cfg (HOs r) (SHOs r) p\n      \\<and> nxt_f r p (cfg p) (\\<mu> p) (cfg' p)\n    )}\""], ["", "lemma step_less_D:\n  \"0 < step r \\<Longrightarrow> step r = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < step r \\<Longrightarrow> step r = Suc 0", "by(auto simp add: step_def)"], ["", "lemma UV_trans:\n  \"CSHO_trans_alt UV_sendMsg (\\<lambda>r p st msgs crd st'. UV_nextState r p st msgs st') HOs SHOs crds = \n  UV_trans_step HOs SHOs next0 send0 0\n  \\<union> UV_trans_step HOs SHOs  next1 send1 1\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt UV_sendMsg\n     (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds =\n    UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. CSHO_trans_alt UV_sendMsg\n     (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> UV_trans_step HOs SHOs next0 send0 0 \\<union>\n                UV_trans_step HOs SHOs next1 send1 1\n 2. UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt UV_sendMsg\n                 (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs\n                 SHOs crds", "show \"CSHO_trans_alt UV_sendMsg (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> UV_trans_step HOs SHOs next0 send0 0 \\<union> UV_trans_step HOs SHOs next1 send1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt UV_sendMsg\n     (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> UV_trans_step HOs SHOs next0 send0 0 \\<union>\n                UV_trans_step HOs SHOs next1 send1 1", "by(force simp add: CSHO_trans_alt_def UV_sendMsg_def UV_nextState_def UV_trans_step_def \n    K_def dest!: step_less_D)"], ["proof (state)\nthis:\n  CSHO_trans_alt UV_sendMsg\n   (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds\n  \\<subseteq> UV_trans_step HOs SHOs next0 send0 0 \\<union>\n              UV_trans_step HOs SHOs next1 send1 1\n\ngoal (1 subgoal):\n 1. UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt UV_sendMsg\n                 (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs\n                 SHOs crds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt UV_sendMsg\n                 (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs\n                 SHOs crds", "show \" UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt UV_sendMsg\n        (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs crds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UV_trans_step HOs SHOs next0 send0 0 \\<union>\n    UV_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt UV_sendMsg\n                 (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs\n                 SHOs crds", "by(force simp add: CSHO_trans_alt_def UV_sendMsg_def UV_nextState_def UV_trans_step_def)"], ["proof (state)\nthis:\n  UV_trans_step HOs SHOs next0 send0 0 \\<union>\n  UV_trans_step HOs SHOs next1 send1 1\n  \\<subseteq> CSHO_trans_alt UV_sendMsg\n               (\\<lambda>r p st msgs crd. UV_nextState r p st msgs) HOs SHOs\n               crds\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition UV_inv1\n  :: \"uv_TS_state set\" \nwhere  \n  \"UV_inv1  = {(r, s). \n    two_step r = 0 \\<longrightarrow> (\\<forall>p. agreed_vote (s p) = None)\n  }\""], ["", "lemmas UV_inv1I = UV_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas UV_inv1E [elim] = UV_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas UV_inv1D = UV_inv1_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma UV_inv1_inductive:\n  \"init (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1\"\n  \"{UV_inv1} TS.trans (UV_TS HOs SHOs crds) {> UV_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1 &&&\n    {UV_inv1} TS.trans (UV_TS HOs SHOs crds) {> UV_inv1}", "by(auto simp add: UV_inv1_def UV_TS_defs CHO_trans_alt UV_trans PO_hoare_def \n    UV_HOMachine_def CHOAlgorithm.truncate_def UV_trans_step_def \n    all_conj_distrib two_step_phase_Suc two_step_step next1_def)"], ["", "lemma UV_inv1_invariant:\n  \"reach (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (UV_TS HOs SHOs crds) \\<subseteq> UV_inv1", "by(intro inv_rule_basic UV_inv1_inductive)"], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition ref_rel :: \"(tso_state \\<times> uv_TS_state)set\" where\n  \"ref_rel \\<equiv> {(sa, (r, sc)).\n    r = next_round sa\n    \\<and> (step r = 1 \\<longrightarrow> r_votes sa = agreed_vote o sc)\n    \\<and> (\\<forall>p v. last_obs (sc p) = v \\<longrightarrow> (\\<exists>q. opt_obsv_state.last_obs sa q \\<in> {None, Some v}))\n    \\<and> decisions sa = decide o sc\n  }\""], ["", "(******************************************************************************)"], ["", "text \\<open>Agreement for UV only holds if the communication predicates hold\\<close>"], ["", "context\n  fixes\n    HOs :: \"nat \\<Rightarrow> process \\<Rightarrow> process set\"\n    and rho :: \"nat \\<Rightarrow> process \\<Rightarrow> 'val pstate\"\n  assumes global: \"UV_commGlobal HOs\"\n  and per_rd: \"\\<forall>r. UV_commPerRd (HOs r)\"\n  and run: \"HORun fA rho HOs\"\nbegin"], ["", "(******************************************************************************)"], ["", "lemma HOs_intersect:\n  \"HOs r p \\<inter> HOs r' q \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r p \\<inter> HOs r' q \\<noteq> {}", "using per_rd"], ["proof (prove)\nusing this:\n  \\<forall>r. UV_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. HOs r p \\<inter> HOs r' q \\<noteq> {}", "apply(simp add: UV_commPerRd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r p. HOs r p \\<in> Quorum \\<Longrightarrow>\n    HOs r p \\<inter> HOs r' q \\<noteq> {}", "apply(blast dest: qintersect)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HOs_nonempty:\n  \"HOs r p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r p \\<noteq> {}", "using HOs_intersect"], ["proof (prove)\nusing this:\n  HOs ?r ?p \\<inter> HOs ?r' ?q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. HOs r p \\<noteq> {}", "by blast"], ["", "lemma vote_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and inv: \"(r, cfg) \\<in> UV_inv1\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"agreed_vote (cfg' p) = Some v \\<longleftrightarrow> (\\<forall>q \\<in> HOs r p. last_obs (cfg q) = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (agreed_vote (cfg' p) = Some v) =\n    (\\<forall>q\\<in>HOs r p. pstate.last_obs (cfg q) = v)", "using send[THEN spec, where x=p] step[THEN spec, where x=p] inv step_r HOs_nonempty"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  (r, cfg) \\<in> UV_inv1\n  two_step r = 0\n  HOs ?r ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (agreed_vote (cfg' p) = Some v) =\n    (\\<forall>q\\<in>HOs r p. pstate.last_obs (cfg q) = v)", "by(auto simp add: next0_def get_msgs_benign send0_def msgRcvd_def o_def restrict_map_def)"], ["", "lemma same_new_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and inv: \"(r, cfg) \\<in> UV_inv1\"\n  and step_r: \"two_step r = 0\"\n  obtains v where \"\\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p w.\n           agreed_vote (cfg' p) = Some w \\<longrightarrow>\n           w = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases \"\\<exists>p v. agreed_vote (cfg' p) = Some v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>p v. agreed_vote (cfg' p) = Some v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume asm: \"\\<And>v. \\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<forall>p w.\n     agreed_vote (cfg' p) = Some w \\<longrightarrow>\n     w = ?v3 \\<Longrightarrow>\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "from True"], ["proof (chain)\npicking this:\n  \\<exists>p v. agreed_vote (cfg' p) = Some v", "obtain p v where \"agreed_vote (cfg' p) = Some v\""], ["proof (prove)\nusing this:\n  \\<exists>p v. agreed_vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        agreed_vote (cfg' p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  agreed_vote (cfg' p) = Some v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v\" (is \"?LV(v)\")"], ["proof (prove)\nusing this:\n  agreed_vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v", "using vote_origin[OF send step inv step_r] HOs_intersect"], ["proof (prove)\nusing this:\n  agreed_vote (cfg' p) = Some v\n  (agreed_vote (cfg' ?p) = Some ?v) =\n  (\\<forall>q\\<in>HOs r ?p. pstate.last_obs (cfg q) = ?v)\n  HOs ?r ?p \\<inter> HOs ?r' ?q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v", "by(force)"], ["proof (state)\nthis:\n  \\<forall>p w. agreed_vote (cfg' p) = Some w \\<longrightarrow> w = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "from asm[OF this]"], ["proof (chain)\npicking this:\n  thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   agreed_vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. agreed_vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed(auto)"], ["", "lemma x_origin1:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  and last_obs: \"last_obs (cfg' p) = v\"\n  shows \n    \"\\<exists>q. last_obs (cfg q) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "have \"smallestValRcvd (\\<mu> p) \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\" (is \"smallestValRcvd ?msgs \\<in> ?vals\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. smallestValRcvd (\\<mu> p)\n    \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}", "unfolding smallestValRcvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n    \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}", "proof(rule Min_in)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n 2. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "have \"?vals \\<subseteq> getval ` ((the \\<circ> ?msgs) ` (HOs r p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n    \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p", "using send[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n    \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p", "by (auto simp: image_def get_msgs_benign restrict_map_def send0_def)"], ["proof (state)\nthis:\n  {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n  \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p\n\ngoal (2 subgoals):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n 2. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "thus \"finite ?vals\""], ["proof (prove)\nusing this:\n  {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n  \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p\n\ngoal (1 subgoal):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (Val v)}", "by (auto simp: finite_subset)"], ["proof (state)\nthis:\n  finite {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "from send[THEN spec, where x=p]"], ["proof (chain)\npicking this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p", "show \"?vals \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "using HOs_nonempty[of r p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}", "by (auto simp: image_def get_msgs_benign restrict_map_def send0_def)"], ["proof (state)\nthis:\n  {v. \\<exists>q. \\<mu> p q = Some (Val v)} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smallestValRcvd (\\<mu> p) \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "hence \"v \\<in> ?vals\""], ["proof (prove)\nusing this:\n  smallestValRcvd (\\<mu> p) \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}", "using last_obs step[THEN spec, of p]"], ["proof (prove)\nusing this:\n  smallestValRcvd (\\<mu> p) \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n  pstate.last_obs (cfg' p) = v\n  next0 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}", "by(auto simp add: next0_def all_conj_distrib)"], ["proof (state)\nthis:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (Val v)}\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<exists>q. pstate.last_obs (cfg q) = v", "by(auto simp add: get_msgs_benign send0_def restrict_map_def)"], ["proof (state)\nthis:\n  \\<exists>q. pstate.last_obs (cfg q) = v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step0_ref:\n  \"{ref_rel \\<inter> UNIV \\<times> UV_inv1} \\<Union>r S v. tso_round0 r S v, \n    UV_trans_step HOs HOs next0 send0 0 {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     UNIV \\<times>\n     UV_inv1} \\<Union>r S.\n                 \\<Union>\n                  (range\n                    (tso_round0 r\n                      S)), UV_trans_step HOs HOs next0 send0 0 {> ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs UV_trans_step_def two_step_step all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix sa r cfg \\<mu> cfg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume\n    R: \"(sa, (r, cfg)) \\<in> ref_rel\"\n    and step_r: \"two_step r = 0\" \n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n    and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n    and inv: \"(r, cfg) \\<in> UV_inv1\""], ["proof (state)\nthis:\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  (r, cfg) \\<in> UV_inv1\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "have next_r: \"next_round sa = r\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. opt_obsv_state.next_round sa = r", "by(simp add: ref_rel_def)"], ["proof (state)\nthis:\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from HOs_nonempty send"], ["proof (chain)\npicking this:\n  HOs ?r ?p \\<noteq> {}\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p", "have \"\\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\""], ["proof (prove)\nusing this:\n  HOs ?r ?p \\<noteq> {}\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)", "by(fastforce simp add: get_msgs_benign send0_def msgRcvd_def restrict_map_def)"], ["proof (state)\nthis:\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "with step"], ["proof (chain)\npicking this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)", "have same_dec: \"decide o cfg' = decide o cfg\""], ["proof (prove)\nusing this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. decide \\<circ> cfg' = decide \\<circ> cfg", "apply(simp add: next0_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                (\\<exists>v.\n                    (\\<forall>q\\<in>msgRcvd (\\<mu> p).\n                        \\<mu> p q = Some (Val v)) \\<and>\n                    cfg' p = cfg p\n                    \\<lparr>agreed_vote := Some v,\n                       pstate.last_obs :=\n                         smallestValRcvd (\\<mu> p)\\<rparr>) \\<or>\n                (\\<forall>v.\n                    \\<exists>q\\<in>msgRcvd (\\<mu> p).\n                       \\<mu> p q \\<noteq> Some (Val v)) \\<and>\n                cfg' p = cfg p\n                \\<lparr>pstate.last_obs :=\n                          smallestValRcvd (\\<mu> p)\\<rparr>;\n     \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. decide (cfg' x)) =\n                      (\\<lambda>x. decide (cfg x))", "by (metis pstate.select_convs(3) pstate.surjective pstate.update_convs(1) pstate.update_convs(2))"], ["proof (state)\nthis:\n  decide \\<circ> cfg' = decide \\<circ> cfg\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define S where \"S = {p. \\<exists>v. agreed_vote (cfg' p) = Some v}\""], ["proof (state)\nthis:\n  S = {p. \\<exists>v. agreed_vote (cfg' p) = Some v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from same_new_vote[OF send step inv step_r]"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      \\<forall>p w.\n         agreed_vote (cfg' p) = Some w \\<longrightarrow>\n         w = v \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain v where v: \"\\<forall>p \\<in> S. agreed_vote (cfg' p) = Some v\""], ["proof (prove)\nusing this:\n  (\\<And>v.\n      \\<forall>p w.\n         agreed_vote (cfg' p) = Some w \\<longrightarrow>\n         w = v \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add: S_def) (metis)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence vote_const_map: \"agreed_vote o cfg' = const_map v S\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. agreed_vote \\<circ> cfg' = const_map v S", "by(auto simp add: S_def const_map_def restrict_map_def intro!: ext)"], ["proof (state)\nthis:\n  agreed_vote \\<circ> cfg' = const_map v S\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note x_origin = x_origin1[OF send step step_r]"], ["proof (state)\nthis:\n  pstate.last_obs (cfg' ?p) = ?v \\<Longrightarrow>\n  \\<exists>q. pstate.last_obs (cfg q) = ?v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define sa' where \"sa' = sa\\<lparr> next_round := Suc r, r_votes := const_map v S \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_obsv_state.next_round := Suc r,\n     r_votes := const_map v S\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (opt_obsv_state.last_obs sa) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<in> S \\<longrightarrow>\n       opt_obs_safe (opt_obsv_state.last_obs sa) v", "using vote_origin[OF send step inv step_r] R per_rd[THEN spec, of r] v"], ["proof (prove)\nusing this:\n  (agreed_vote (cfg' ?p) = Some ?v) =\n  (\\<forall>q\\<in>HOs r ?p. pstate.last_obs (cfg q) = ?v)\n  (sa, r, cfg) \\<in> ref_rel\n  UV_commPerRd (HOs r)\n  \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       p \\<in> S \\<longrightarrow>\n       opt_obs_safe (opt_obsv_state.last_obs sa) v", "apply(clarsimp simp add: UV_commPerRd_def opt_obs_safe_def ref_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p v.\n                   (agreed_vote (cfg' p) = Some v) =\n                   (\\<forall>q\\<in>HOs (opt_obsv_state.next_round sa) p.\n                       pstate.last_obs (cfg q) = v);\n        \\<forall>p. HOs (opt_obsv_state.next_round sa) p \\<in> Quorum;\n        \\<forall>p\\<in>S.\n           \\<forall>q\\<in>HOs (opt_obsv_state.next_round sa) p.\n              pstate.last_obs (cfg q) = v;\n        r = opt_obsv_state.next_round sa;\n        step (opt_obsv_state.next_round sa) = Suc 0 \\<longrightarrow>\n        r_votes sa = agreed_vote \\<circ> cfg;\n        \\<forall>p.\n           \\<exists>q.\n              opt_obsv_state.last_obs sa q = None \\<or>\n              opt_obsv_state.last_obs sa q = Some (pstate.last_obs (cfg p));\n        opt_obsv_state.decisions sa = decide \\<circ> cfg; p \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            opt_obsv_state.last_obs sa p = None \\<or>\n                            opt_obsv_state.last_obs sa p = Some v", "by metis"], ["proof (state)\nthis:\n  \\<forall>p.\n     p \\<in> S \\<longrightarrow> opt_obs_safe (opt_obsv_state.last_obs sa) v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence \"(sa, sa') \\<in> tso_round0 r S v\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     p \\<in> S \\<longrightarrow> opt_obs_safe (opt_obsv_state.last_obs sa) v\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round0 r S v", "using next_r step_r v R \n    vote_origin[OF send step inv step_r]"], ["proof (prove)\nusing this:\n  \\<forall>p.\n     p \\<in> S \\<longrightarrow> opt_obs_safe (opt_obsv_state.last_obs sa) v\n  opt_obsv_state.next_round sa = r\n  two_step r = 0\n  \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v\n  (sa, r, cfg) \\<in> ref_rel\n  (agreed_vote (cfg' ?p) = Some ?v) =\n  (\\<forall>q\\<in>HOs r ?p. pstate.last_obs (cfg q) = ?v)\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round0 r S v", "by(auto simp add: tso_round0_def sa'_def all_conj_distrib)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round0 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round0 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"(sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "using step send v R same_dec step_r next_r"], ["proof (prove)\nusing this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v\n  (sa, r, cfg) \\<in> ref_rel\n  decide \\<circ> cfg' = decide \\<circ> cfg\n  two_step r = 0\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "apply(clarsimp simp add: ref_rel_def sa'_def two_step_step two_step_phase_Suc vote_const_map)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_obsv_state.next_round sa) p (cfg p) (\\<mu> p)\n                    (cfg' p);\n        \\<forall>p.\n           \\<mu> p\n           \\<in> get_msgs (send0 (opt_obsv_state.next_round sa)) cfg\n                  (HOs (opt_obsv_state.next_round sa))\n                  (HOs (opt_obsv_state.next_round sa)) p;\n        \\<forall>p\\<in>S. agreed_vote (cfg' p) = Some v;\n        decide \\<circ> cfg' = decide \\<circ> cfg;\n        two_step (opt_obsv_state.next_round sa) = 0;\n        r = opt_obsv_state.next_round sa;\n        \\<forall>p.\n           \\<exists>q.\n              opt_obsv_state.last_obs sa q = None \\<or>\n              opt_obsv_state.last_obs sa q = Some (pstate.last_obs (cfg p));\n        opt_obsv_state.decisions sa = decide \\<circ> cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            opt_obsv_state.last_obs sa q = None \\<or>\n                            opt_obsv_state.last_obs sa q =\n                            Some (pstate.last_obs (cfg' p))", "by (metis x_origin)"], ["proof (state)\nthis:\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; (ab, ba) \\<in> UV_inv1;\n        two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> tso_round0 r S v\n  (sa', Suc r, cfg') \\<in> ref_rel", "show\n    \"\\<exists>sa'. (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and> (sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> tso_round0 r S v\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and>\n       (sa', Suc r, cfg') \\<in> ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and>\n     (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma x_origin2:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  and last_obs: \"last_obs (cfg' p) = v\"\n  shows \n    \"(\\<exists>q. last_obs (cfg q) = v) \\<or> (\\<exists>q. agreed_vote (cfg q) = Some v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "proof(cases \"\\<forall>q \\<in> HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>HOs r p.\n       \\<exists>w. \\<mu> p q = Some (ValVote w None) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)\n 2. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "case True"], ["proof (state)\nthis:\n  \\<forall>q\\<in>HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>HOs r p.\n       \\<exists>w. \\<mu> p q = Some (ValVote w None) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)\n 2. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "hence empty: \"someVoteRcvd (\\<mu> p) = {}\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) = {}", "using send[THEN spec, of p] HOs_nonempty[of r p]"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) = {}", "by(auto simp add: someVoteRcvd_def msgRcvd_def isValVote_def \n      get_msgs_benign send1_def restrict_map_def)"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) = {}\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>HOs r p.\n       \\<exists>w. \\<mu> p q = Some (ValVote w None) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)\n 2. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "have \"smallestValNoVoteRcvd (\\<mu> p) \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\" \n    (is \"smallestValNoVoteRcvd ?msgs \\<in> ?vals\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. smallestValNoVoteRcvd (\\<mu> p)\n    \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}", "unfolding smallestValNoVoteRcvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n    \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}", "proof(rule Min_in)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n 2. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}", "have \"?vals \\<subseteq> getval ` ((the \\<circ> ?msgs) ` (HOs r p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n    \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p", "using send[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n    \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p", "by (auto simp: image_def get_msgs_benign restrict_map_def send0_def)"], ["proof (state)\nthis:\n  {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n  \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p\n\ngoal (2 subgoals):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n 2. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}", "thus \"finite ?vals\""], ["proof (prove)\nusing this:\n  {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n  \\<subseteq> getval ` (the \\<circ> \\<mu> p) ` HOs r p\n\ngoal (1 subgoal):\n 1. finite {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}", "by (auto simp: finite_subset)"], ["proof (state)\nthis:\n  finite {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}", "from send[THEN spec, where x=p] True HOs_nonempty[of r p]"], ["proof (chain)\npicking this:\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>q\\<in>HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\n  HOs r p \\<noteq> {}", "show \"?vals \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>q\\<in>HOs r p. \\<exists>w. \\<mu> p q = Some (ValVote w None)\n  HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}", "by (auto simp: image_def get_msgs_benign restrict_map_def send1_def)"], ["proof (state)\nthis:\n  {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  smallestValNoVoteRcvd (\\<mu> p)\n  \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>HOs r p.\n       \\<exists>w. \\<mu> p q = Some (ValVote w None) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)\n 2. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "hence \"v \\<in> ?vals\""], ["proof (prove)\nusing this:\n  smallestValNoVoteRcvd (\\<mu> p)\n  \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}", "using empty step[THEN spec, of p] last_obs"], ["proof (prove)\nusing this:\n  smallestValNoVoteRcvd (\\<mu> p)\n  \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n  someVoteRcvd (\\<mu> p) = {}\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  pstate.last_obs (cfg' p) = v\n\ngoal (1 subgoal):\n 1. v \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}", "by(auto simp add: next1_def x_update_def)"], ["proof (state)\nthis:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n\ngoal (2 subgoals):\n 1. \\<forall>q\\<in>HOs r p.\n       \\<exists>w. \\<mu> p q = Some (ValVote w None) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)\n 2. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n\ngoal (1 subgoal):\n 1. (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  v \\<in> {v. \\<exists>q. \\<mu> p q = Some (ValVote v None)}\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "by(auto simp add: get_msgs_benign restrict_map_def send1_def)"], ["proof (state)\nthis:\n  (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n  (\\<exists>q. agreed_vote (cfg q) = Some v)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<forall>q\\<in>HOs r p.\n             \\<exists>w. \\<mu> p q = Some (ValVote w None))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "hence \"someVoteRcvd (\\<mu> p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>q\\<in>HOs r p.\n             \\<exists>w. \\<mu> p q = Some (ValVote w None))\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "using send[THEN spec, of p] HOs_nonempty[of r p]"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>q\\<in>HOs r p.\n             \\<exists>w. \\<mu> p q = Some (ValVote w None))\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "by(auto simp add: someVoteRcvd_def msgRcvd_def isValVote_def \n      get_msgs_benign send1_def restrict_map_def)"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "hence \"\\<exists>q \\<in> someVoteRcvd (\\<mu> p). v = the (getvote (the (\\<mu> p q)))\""], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>someVoteRcvd (\\<mu> p).\n       v = the (getvote (the (\\<mu> p q)))", "using step[THEN spec, of p] last_obs"], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  pstate.last_obs (cfg' p) = v\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>someVoteRcvd (\\<mu> p).\n       v = the (getvote (the (\\<mu> p q)))", "by(auto simp add: next1_def x_update_def)"], ["proof (state)\nthis:\n  \\<exists>q\\<in>someVoteRcvd (\\<mu> p). v = the (getvote (the (\\<mu> p q)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>q\\<in>HOs r p.\n               \\<exists>w.\n                  \\<mu> p q = Some (ValVote w None)) \\<Longrightarrow>\n    (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>someVoteRcvd (\\<mu> p). v = the (getvote (the (\\<mu> p q)))\n\ngoal (1 subgoal):\n 1. (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  \\<exists>q\\<in>someVoteRcvd (\\<mu> p). v = the (getvote (the (\\<mu> p q)))\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n    (\\<exists>q. agreed_vote (cfg q) = Some v)", "by(auto simp add: next1_def x_update_def someVoteRcvd_def isValVote_def \n      send1_def get_msgs_benign msgRcvd_def restrict_map_def)"], ["proof (state)\nthis:\n  (\\<exists>q. pstate.last_obs (cfg q) = v) \\<or>\n  (\\<exists>q. agreed_vote (cfg q) = Some v)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition D where\n  \"D cfg cfg' \\<equiv> {p. decide (cfg' p) \\<noteq> decide (cfg p) }\""], ["", "lemma decide_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  shows \n    \"D cfg cfg' \\<subseteq> {p. \\<exists>v. decide (cfg' p) = Some v \\<and> (\\<forall>q \\<in> HOs r p. agreed_vote (cfg q) = Some v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D cfg cfg'\n    \\<subseteq> {p. \\<exists>v.\n                       decide (cfg' p) = Some v \\<and>\n                       (\\<forall>q\\<in>HOs r p.\n                           agreed_vote (cfg q) = Some v)}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. D cfg cfg'\n    \\<subseteq> {p. \\<exists>v.\n                       decide (cfg' p) = Some v \\<and>\n                       (\\<forall>q\\<in>HOs r p.\n                           agreed_vote (cfg q) = Some v)}", "by(fastforce simp add: D_def next1_def get_msgs_benign send1_def msgRcvd_def o_def restrict_map_def\n    x_update_def dec_update_def identicalVoteRcvd_def all_conj_distrib someVoteRcvd_def isValVote_def\n    smallestValNoVoteRcvd_def)"], ["", "lemma step1_ref:\n  \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV} \\<Union>r d_f o_f. tso_round1 r d_f o_f, \n    UV_trans_step HOs HOs next1 send1 (Suc 0) {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} \\<Union>r d_f.\n              \\<Union>\n               (range\n                 (tso_round1 r\n                   d_f)), UV_trans_step HOs HOs next1 send1\n                           (Suc 0) {> ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs UV_trans_step_def two_step_step all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix sa r cfg \\<mu> and cfg' :: \"process \\<Rightarrow> val pstate\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume\n    R: \"(sa, (r, cfg)) \\<in> ref_rel\"\n    and step_r: \"two_step r = Suc 0\" \n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n    and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n    and ainv: \"sa \\<in> TSO_inv1\"\n    and ainv2: \"sa \\<in> TSO_inv2\""], ["proof (state)\nthis:\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  sa \\<in> TSO_inv1\n  sa \\<in> TSO_inv2\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "have next_r: \"next_round sa = r\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. opt_obsv_state.next_round sa = r", "by(simp add: ref_rel_def)"], ["proof (state)\nthis:\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define S where \"S = {p. \\<exists>v. agreed_vote (cfg p) = Some v}\""], ["proof (state)\nthis:\n  S = {p. \\<exists>v. agreed_vote (cfg p) = Some v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "obtain v where v: \"\\<forall>p \\<in> S. agreed_vote (cfg p) = Some v\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. agreed_vote (cfg p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ainv step_r"], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n  sa \\<in> TSO_inv1\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. agreed_vote (cfg p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ref_rel_def TSO_inv1_def S_def two_step_step)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. agreed_vote (cfg p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define Ob where \"Ob = {p. last_obs (cfg' p) = v}\""], ["proof (state)\nthis:\n  Ob = {p. pstate.last_obs (cfg' p) = v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define o_f where \"o_f p = (if S \\<in> Quorum then Some v else None)\" for p :: process"], ["proof (state)\nthis:\n  o_f ?p = (if S \\<in> Quorum then Some v else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define dec_f where \"dec_f p = (if p \\<in> D cfg cfg' then decide (cfg' p) else None)\" for p"], ["proof (state)\nthis:\n  dec_f ?p = (if ?p \\<in> D cfg cfg' then decide (cfg' ?p) else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "{"], ["proof (state)\nthis:\n  dec_f ?p = (if ?p \\<in> D cfg cfg' then decide (cfg' ?p) else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix p w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume \"agreed_vote (cfg p) = Some w\""], ["proof (state)\nthis:\n  agreed_vote (cfg p) = Some w\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence \"w = v\""], ["proof (prove)\nusing this:\n  agreed_vote (cfg p) = Some w\n\ngoal (1 subgoal):\n 1. w = v", "using v"], ["proof (prove)\nusing this:\n  agreed_vote (cfg p) = Some w\n  \\<forall>p\\<in>S. agreed_vote (cfg p) = Some v\n\ngoal (1 subgoal):\n 1. w = v", "by(unfold S_def, auto)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "}"], ["proof (state)\nthis:\n  agreed_vote (cfg ?p5) = Some ?w5 \\<Longrightarrow> ?w5 = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note v'=this"], ["proof (state)\nthis:\n  agreed_vote (cfg ?p5) = Some ?w5 \\<Longrightarrow> ?w5 = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have d_guard: \"d_guard dec_f (agreed_vote \\<circ> cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_guard dec_f (agreed_vote \\<circ> cfg)", "using per_rd[THEN spec, of r]"], ["proof (prove)\nusing this:\n  UV_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. d_guard dec_f (agreed_vote \\<circ> cfg)", "by(fastforce simp add: d_guard_def locked_in_vf_def quorum_for_def dec_f_def\n      UV_commPerRd_def dest!: decide_origin[OF send step step_r, THEN subsetD])"], ["proof (state)\nthis:\n  d_guard dec_f (agreed_vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV", "proof(auto simp add: Ob_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "assume Q: \"dom (agreed_vote \\<circ> cfg) \\<in> Quorum\" (is \"?Q \\<in> Quorum\")"], ["proof (state)\nthis:\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "hence \"?Q \\<inter> HOs r p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum\n\ngoal (1 subgoal):\n 1. dom (agreed_vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}", "using per_rd[THEN spec, of r]"], ["proof (prove)\nusing this:\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum\n  UV_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. dom (agreed_vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}", "by(auto simp add: UV_commPerRd_def dest: qintersect)"], ["proof (state)\nthis:\n  dom (agreed_vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "hence \"someVoteRcvd (\\<mu> p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  dom (agreed_vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  dom (agreed_vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "by(force simp add: someVoteRcvd_def get_msgs_benign msgRcvd_def restrict_map_def \n        isValVote_def send1_def)"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "moreover"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "have \"\\<forall>q \\<in> someVoteRcvd (\\<mu> p). \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n       \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n       \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))", "by(auto simp add: someVoteRcvd_def get_msgs_benign msgRcvd_def restrict_map_def\n        isValVote_def send1_def dest: v')"], ["proof (state)\nthis:\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow>\n       pstate.last_obs (cfg' x) = v", "ultimately"], ["proof (chain)\npicking this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))", "show \"last_obs (cfg' p) = v\""], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))\n\ngoal (1 subgoal):\n 1. pstate.last_obs (cfg' p) = v", "using step[THEN spec, of p]"], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (ValVote x' (Some v))\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. pstate.last_obs (cfg' p) = v", "by(auto simp add: next1_def x_update_def)"], ["proof (state)\nthis:\n  pstate.last_obs (cfg' p) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note Ob_UNIV=this[rule_format]"], ["proof (state)\nthis:\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have obs_guard: \"obs_guard o_f (agreed_vote \\<circ> cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_guard o_f (agreed_vote \\<circ> cfg)", "apply(auto simp add: obs_guard_def o_f_def S_def dom_def\n      dest: v' Ob_UNIV quorum_non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>v. agreed_vote (cfg p) = Some v}\n    \\<in> Quorum \\<Longrightarrow>\n    \\<exists>q.\n       (\\<exists>y. agreed_vote (cfg q) = Some y) \\<and>\n       Some v = agreed_vote (cfg q)", "apply (metis S_def all_not_in_conv  empty_not_quorum v)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  obs_guard o_f (agreed_vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define sa' where \"sa' = sa\\<lparr> \n    next_round := Suc (next_round sa)\n    , decisions := decisions sa ++ dec_f\n    , opt_obsv_state.last_obs := opt_obsv_state.last_obs sa ++ o_f\n    \\<rparr>\"\n\n\n  \\<comment> \\<open>Abstract step\\<close>"], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_obsv_state.next_round := Suc (opt_obsv_state.next_round sa),\n     opt_obsv_state.decisions := opt_obsv_state.decisions sa ++ dec_f,\n     opt_obsv_state.last_obs := opt_obsv_state.last_obs sa ++ o_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have abs_step: \"(sa, sa') \\<in> tso_round1 r dec_f o_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round1 r dec_f o_f", "using next_r step_r R d_guard obs_guard"], ["proof (prove)\nusing this:\n  opt_obsv_state.next_round sa = r\n  two_step r = Suc 0\n  (sa, r, cfg) \\<in> ref_rel\n  d_guard dec_f (agreed_vote \\<circ> cfg)\n  obs_guard o_f (agreed_vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round1 r dec_f o_f", "by(auto simp add: tso_round1_def sa'_def ref_rel_def two_step_step)\n\n  \\<comment> \\<open>Relation preserved\\<close>"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "show \"((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "using step[THEN spec, of p]"], ["proof (prove)\nusing this:\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "by(auto simp add: dec_f_def D_def next1_def dec_update_def map_add_def)"], ["proof (state)\nthis:\n  ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note dec_rel=this[rule_format]"], ["proof (state)\nthis:\n  ((decide \\<circ> cfg) ++ dec_f) ?p = decide (cfg' ?p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. (\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (last_obs (cfg' p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "proof(intro allI impI, cases \"S \\<in> Quorum\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "case True"], ["proof (state)\nthis:\n  S \\<in> Quorum\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "hence \"last_obs (cfg' p) = v\""], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n\ngoal (1 subgoal):\n 1. pstate.last_obs (cfg' p) = v", "using Ob_UNIV"], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n  dom (agreed_vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. pstate.last_obs (cfg' p) = v", "by(auto simp add: S_def Ob_def dom_def)"], ["proof (state)\nthis:\n  pstate.last_obs (cfg' p) = v\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "thus \"(\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (last_obs (cfg' p)))\""], ["proof (prove)\nusing this:\n  pstate.last_obs (cfg' p) = v\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "using True"], ["proof (prove)\nusing this:\n  pstate.last_obs (cfg' p) = v\n  S \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "by(auto simp add: o_f_def)"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n     (opt_obsv_state.last_obs sa ++ o_f) q = Some (pstate.last_obs (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "case False"], ["proof (state)\nthis:\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "hence empty: \"o_f = Map.empty\""], ["proof (prove)\nusing this:\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. o_f = Map.empty", "by(auto simp add: o_f_def)"], ["proof (state)\nthis:\n  o_f = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "note last_obs = x_origin2[OF send step step_r refl, of p]"], ["proof (state)\nthis:\n  (\\<exists>q. pstate.last_obs (cfg q) = pstate.last_obs (cfg' p)) \\<or>\n  (\\<exists>q. agreed_vote (cfg q) = Some (pstate.last_obs (cfg' p)))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "thus \"(\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (last_obs (cfg' p)))\""], ["proof (prove)\nusing this:\n  (\\<exists>q. pstate.last_obs (cfg q) = pstate.last_obs (cfg' p)) \\<or>\n  (\\<exists>q. agreed_vote (cfg q) = Some (pstate.last_obs (cfg' p)))\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "proof(elim disjE exE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       pstate.last_obs (cfg q) = pstate.last_obs (cfg' p) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "fix q"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>q.\n       pstate.last_obs (cfg q) = pstate.last_obs (cfg' p) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "assume \"last_obs (cfg q) = last_obs (cfg' p)\""], ["proof (state)\nthis:\n  pstate.last_obs (cfg q) = pstate.last_obs (cfg' p)\n\ngoal (2 subgoals):\n 1. \\<And>q.\n       pstate.last_obs (cfg q) = pstate.last_obs (cfg' p) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))\n 2. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "from this[symmetric]"], ["proof (chain)\npicking this:\n  pstate.last_obs (cfg' p) = pstate.last_obs (cfg q)", "show ?thesis"], ["proof (prove)\nusing this:\n  pstate.last_obs (cfg' p) = pstate.last_obs (cfg q)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "using R step_r empty"], ["proof (prove)\nusing this:\n  pstate.last_obs (cfg' p) = pstate.last_obs (cfg q)\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n  o_f = Map.empty\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "by(simp add: ref_rel_def two_step_step)"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n     (opt_obsv_state.last_obs sa ++ o_f) q = Some (pstate.last_obs (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "assume \"agreed_vote (cfg q) = Some (last_obs (cfg' p))\""], ["proof (state)\nthis:\n  agreed_vote (cfg q) = Some (pstate.last_obs (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>q.\n       agreed_vote (cfg q) =\n       Some (pstate.last_obs (cfg' p)) \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n          (opt_obsv_state.last_obs sa ++ o_f) q =\n          Some (pstate.last_obs (cfg' p))", "from this[symmetric]"], ["proof (chain)\npicking this:\n  Some (pstate.last_obs (cfg' p)) = agreed_vote (cfg q)", "show ?thesis"], ["proof (prove)\nusing this:\n  Some (pstate.last_obs (cfg' p)) = agreed_vote (cfg q)\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "using R ainv2 step_r empty"], ["proof (prove)\nusing this:\n  Some (pstate.last_obs (cfg' p)) = agreed_vote (cfg q)\n  (sa, r, cfg) \\<in> ref_rel\n  sa \\<in> TSO_inv2\n  two_step r = Suc 0\n  o_f = Map.empty\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n       (opt_obsv_state.last_obs sa ++ o_f) q =\n       Some (pstate.last_obs (cfg' p))", "apply(auto simp add: ref_rel_def two_step_step TSO_inv2_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Some (pstate.last_obs (cfg' p)) = agreed_vote (cfg q);\n     \\<forall>p v.\n        agreed_vote (cfg p) = Some v \\<longrightarrow>\n        (\\<exists>q.\n            opt_obsv_state.last_obs sa q = None \\<or>\n            opt_obsv_state.last_obs sa q = Some v);\n     two_step (opt_obsv_state.next_round sa) = Suc 0; o_f = Map.empty;\n     r = opt_obsv_state.next_round sa; r_votes sa = agreed_vote \\<circ> cfg;\n     \\<forall>p.\n        \\<exists>q.\n           opt_obsv_state.last_obs sa q = None \\<or>\n           opt_obsv_state.last_obs sa q = Some (pstate.last_obs (cfg p));\n     opt_obsv_state.decisions sa = decide \\<circ> cfg\\<rbrakk>\n    \\<Longrightarrow> \\<exists>qa.\n                         opt_obsv_state.last_obs sa qa = None \\<or>\n                         opt_obsv_state.last_obs sa qa = agreed_vote (cfg q)", "by metis"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n     (opt_obsv_state.last_obs sa ++ o_f) q = Some (pstate.last_obs (cfg' p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n     (opt_obsv_state.last_obs sa ++ o_f) q = Some (pstate.last_obs (cfg' p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     \\<exists>q.\n        o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n        (opt_obsv_state.last_obs sa ++ o_f) q =\n        Some (pstate.last_obs (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note obs_rel=this[rule_format]"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \\<or>\n     (opt_obsv_state.last_obs sa ++ o_f) q =\n     Some (pstate.last_obs (cfg' ?p))\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have post_rel: \n    \"(sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "using step send next_r R step_r"], ["proof (prove)\nusing this:\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  opt_obsv_state.next_round sa = r\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "by(auto simp add: sa'_def ref_rel_def two_step_step\n      two_step_phase_Suc dec_rel obs_rel)"], ["proof (state)\nthis:\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from abs_step post_rel"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n  (sa', Suc r, cfg') \\<in> ref_rel", "show\n    \"\\<exists>sa'. (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and> (sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and>\n       (sa', Suc r, cfg') \\<in> ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and>\n     (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UV_Refines_votes:\n  \"PO_refines (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UV_inv1)\n    tso_TS (UV_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines\n     (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UV_inv1) tso_TS\n     (UV_TS HOs HOs crds)", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UV_inv1} TS.trans tso_TS, TS.trans (UV_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times>\n       UV_inv1)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UV_inv1 \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (UV_TS HOs HOs crds) {> UV_inv1}\n 4. init (UV_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\n 5. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 6. init (UV_TS HOs HOs crds) \\<subseteq> UV_inv1", "show \"init (UV_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (UV_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS", "by(auto simp add: UV_TS_defs UV_HOMachine_def CHOAlgorithm.truncate_def \n      tso_TS_defs ref_rel_def tso_init_def Let_def o_def)"], ["proof (state)\nthis:\n  init (UV_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\n\ngoal (5 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UV_inv1} TS.trans tso_TS, TS.trans (UV_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times>\n       UV_inv1)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UV_inv1 \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (UV_TS HOs HOs crds) {> UV_inv1}\n 4. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 5. init (UV_TS HOs HOs crds) \\<subseteq> UV_inv1", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UV_inv1} TS.trans tso_TS, TS.trans (UV_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times>\n       UV_inv1)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UV_inv1 \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (UV_TS HOs HOs crds) {> UV_inv1}\n 4. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 5. init (UV_TS HOs HOs crds) \\<subseteq> UV_inv1", "show \n    \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UV_inv1} TS.trans tso_TS, \n      TS.trans (UV_TS HOs HOs crds) {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UV_inv1} TS.trans tso_TS, TS.trans (UV_TS HOs HOs crds) {> ref_rel}", "apply(simp add: tso_TS_defs UV_TS_defs UV_HOMachine_def CHOAlgorithm.truncate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UV_inv1} ((\\<Union>x xa. \\<Union> (range (tso_round0 x xa))) \\<union>\n               (\\<Union>x xa.\n                   \\<Union>\n                    (range\n                      (tso_round1 x\n                        xa))))\\<^sup>=, CHO_trans\n   \\<lparr>CinitState =\n             \\<lambda>p st crd.\n                agreed_vote st = None \\<and> decide st = None,\n      sendMsg = UV_sendMsg,\n      CnextState =\n        \\<lambda>r p st msgs crd. UV_nextState r p st msgs\\<rparr>\n   HOs HOs (K \\<circ> crds) {> ref_rel}", "apply(auto simp add: CHO_trans_alt UV_trans intro!: step0_ref step1_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {ref_rel \\<inter>\n   (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n   UV_inv1} TS.trans tso_TS, TS.trans (UV_TS HOs HOs crds) {> ref_rel}\n\ngoal (4 subgoals):\n 1. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times>\n       UV_inv1)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 2. {UV_inv1 \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (UV_TS HOs HOs crds) {> UV_inv1}\n 3. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 4. init (UV_TS HOs HOs crds) \\<subseteq> UV_inv1", "qed(auto intro!: TSO_inv1_inductive TSO_inv2_inductive UV_inv1_inductive)"], ["", "end"], ["", "(* HO predicate context *)"], ["", "end"], ["", "(* mono_quorum context *)"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>As the model of the algorithm is taken verbatim from the HO Model AFP, we\n  do not repeat the termination proof here and refer to that AFP entry.\\<close>"], ["", "end"], ["", "(* theory *)"]]}