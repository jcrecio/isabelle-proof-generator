{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Observing/Two_Step_Observing.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas tso_TS_defs = tso_TS_def tso_init_def tso_trans_def", "lemma const_map_equality:\n  \"(const_map v S = const_map v' S') = (S = S' \\<and> (S = {} \\<or> v = v'))\"", "lemma rhoare_skipI:\n  \"\\<lbrakk> \\<And>sa sc sc'. \\<lbrakk> (sa, sc) \\<in> Pre; (sc, sc') \\<in> Tc \\<rbrakk> \\<Longrightarrow> (sa, sc') \\<in> Post \\<rbrakk> \\<Longrightarrow> {Pre} Id, Tc {>Post}\"", "lemma tso_round0_refines:\n  \"{tso_ref_rel} Id, tso_round0 r S v {>tso_ref_rel}\"", "lemma tso_round1_refines:\n  \"{tso_ref_rel} \\<Union>r S v dec_f Ob. olv_round r S v dec_f Ob, tso_round1 r dec_f o_f {>tso_ref_rel}\"", "lemma TS_Observing_Refines:\n  \"PO_refines tso_ref_rel olv_TS tso_TS\"", "lemmas TSO_inv1I = TSO_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas TSO_inv1E [elim] = TSO_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas TSO_inv1D = TSO_inv1_def [THEN setc_def_to_dest, rule_format]", "lemmas TSO_inv2I = TSO_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas TSO_inv2E [elim] = TSO_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas TSO_inv2D = TSO_inv2_def [THEN setc_def_to_dest, rule_format]", "lemma TSO_inv1_inductive:\n  \"init tso_TS \\<subseteq> TSO_inv1\"\n  \"{TSO_inv1} TS.trans tso_TS {> TSO_inv1}\"", "lemma TSO_inv1_invariant:\n  \"reach tso_TS \\<subseteq> TSO_inv1\"", "lemma TSO_inv2_inductive:\n  \"init tso_TS \\<subseteq> TSO_inv2\"\n  \"{TSO_inv2} TS.trans tso_TS {> TSO_inv2}\"", "lemma TSO_inv2_invariant:\n  \"reach tso_TS \\<subseteq> TSO_inv2\""], "translations": [["", "lemmas tso_TS_defs = tso_TS_def tso_init_def tso_trans_def"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition basic_rel :: \"(opt_obsv_state \\<times> tso_state)set\" where\n  \"basic_rel = {(sa, sc).\n    next_round sa = two_phase (next_round sc)\n    \\<and> last_obs sc = last_obs sa\n    \\<and> decisions sc = decisions sa\n  }\""], ["", "definition step0_rel :: \"(opt_obsv_state \\<times> tso_state)set\" where\n  \"step0_rel = basic_rel\""], ["", "definition step1_add_rel :: \"(opt_obsv_state \\<times> tso_state)set\" where\n  \"step1_add_rel = {(sa, sc). \\<exists>S v.\n    r_votes sc = const_map v S\n    \\<and> (S \\<noteq> {} \\<longrightarrow> opt_obs_safe (last_obs sc) v)\n  }\""], ["", "definition step1_rel :: \"(opt_obsv_state \\<times> tso_state)set\" where\n  \"step1_rel = basic_rel \\<inter> step1_add_rel\""], ["", "definition tso_ref_rel :: \"(opt_obsv_state \\<times> tso_state)set\" where\n  \"tso_ref_rel \\<equiv> {(sa, sc).\n    (two_step (next_round sc) = 0 \\<longrightarrow> (sa, sc) \\<in> step0_rel)\n    \\<and> (two_step (next_round sc) = 1 \\<longrightarrow> \n        (sa, sc) \\<in> step1_rel\n        \\<and> (\\<exists>sc' r S v. (sc', sc) \\<in> tso_round0 r S v \\<and> (sa, sc') \\<in> step0_rel))\n  }\""], ["", "lemma const_map_equality:\n  \"(const_map v S = const_map v' S') = (S = S' \\<and> (S = {} \\<or> v = v'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (const_map v S = const_map v' S') =\n    (S = S' \\<and> (S = {} \\<or> v = v'))", "apply(simp add: const_map_def restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x \\<in> S then Some v else None) =\n     (\\<lambda>x. if x \\<in> S' then Some v' else None)) =\n    (S = S' \\<and> (S = {} \\<or> v = v'))", "by (metis equals0D option.distinct(2) option.inject subsetI subset_antisym)"], ["", "lemma rhoare_skipI:\n  \"\\<lbrakk> \\<And>sa sc sc'. \\<lbrakk> (sa, sc) \\<in> Pre; (sc, sc') \\<in> Tc \\<rbrakk> \\<Longrightarrow> (sa, sc') \\<in> Post \\<rbrakk> \\<Longrightarrow> {Pre} Id, Tc {>Post}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>sa sc sc'.\n        \\<lbrakk>(sa, sc) \\<in> Pre; (sc, sc') \\<in> Tc\\<rbrakk>\n        \\<Longrightarrow> (sa, sc') \\<in> Post) \\<Longrightarrow>\n    {Pre} Id, Tc {> Post}", "by(auto simp add: PO_rhoare_defs)"], ["", "lemma tso_round0_refines:\n  \"{tso_ref_rel} Id, tso_round0 r S v {>tso_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {tso_ref_rel} Id, tso_round0 r S v {> tso_ref_rel}", "apply(rule rhoare_skipI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sa sc sc'.\n       \\<lbrakk>(sa, sc) \\<in> tso_ref_rel;\n        (sc, sc') \\<in> tso_round0 r S v\\<rbrakk>\n       \\<Longrightarrow> (sa, sc') \\<in> tso_ref_rel", "apply(auto simp add: tso_ref_rel_def basic_rel_def step1_rel_def \n     step1_add_rel_def  step0_rel_def tso_round0_def const_map_equality conj_disj_distribR\n     ex_disj_distrib two_step_phase_Suc)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma tso_round1_refines:\n  \"{tso_ref_rel} \\<Union>r S v dec_f Ob. olv_round r S v dec_f Ob, tso_round1 r dec_f o_f {>tso_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {tso_ref_rel} \\<Union>r S v dec_f.\n                     \\<Union>\n                      (range\n                        (olv_round r S v\n                          dec_f)), tso_round1 r dec_f o_f {> tso_ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "fix sa sc and sc'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "assume\n    R: \"(sa, sc) \\<in> tso_ref_rel\" \n    and step1: \"(sc, sc') \\<in> tso_round1 r dec_f o_f\""], ["proof (state)\nthis:\n  (sa, sc) \\<in> tso_ref_rel\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "hence step_r: \"two_step r = 1\" and r_next: \"next_round sc = r\""], ["proof (prove)\nusing this:\n  (sa, sc) \\<in> tso_ref_rel\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. two_step r = 1 &&& opt_obsv_state.next_round sc = r", "by (auto simp add: tso_round1_def)"], ["proof (state)\nthis:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "then"], ["proof (chain)\npicking this:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r", "obtain r0 sc0 S0 v0 where \n    R0: \"(sa, sc0) \\<in> step0_rel\" and step0: \"(sc0, sc) \\<in> tso_round0 r0 S0 v0\""], ["proof (prove)\nusing this:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n\ngoal (1 subgoal):\n 1. (\\<And>sc0 r0 S0 v0.\n        \\<lbrakk>(sa, sc0) \\<in> step0_rel;\n         (sc0, sc) \\<in> tso_round0 r0 S0 v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using R"], ["proof (prove)\nusing this:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n  (sa, sc) \\<in> tso_ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>sc0 r0 S0 v0.\n        \\<lbrakk>(sa, sc0) \\<in> step0_rel;\n         (sc0, sc) \\<in> tso_round0 r0 S0 v0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: tso_ref_rel_def)"], ["proof (state)\nthis:\n  (sa, sc0) \\<in> step0_rel\n  (sc0, sc) \\<in> tso_round0 r0 S0 v0\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "from step_r r_next R"], ["proof (chain)\npicking this:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n  (sa, sc) \\<in> tso_ref_rel", "obtain S v where\n    v: \"r_votes sc = const_map v S\"\n    and safe: \"S \\<noteq> {} \\<longrightarrow> opt_obs_safe (last_obs sc) v\""], ["proof (prove)\nusing this:\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n  (sa, sc) \\<in> tso_ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>v S.\n        \\<lbrakk>r_votes sc = const_map v S;\n         S \\<noteq> {} \\<longrightarrow>\n         opt_obs_safe (last_obs sc) v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: tso_ref_rel_def step1_rel_def step1_add_rel_def)"], ["proof (state)\nthis:\n  r_votes sc = const_map v S\n  S \\<noteq> {} \\<longrightarrow> opt_obs_safe (last_obs sc) v\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "define sa' where \"sa' = sa\\<lparr> \n      next_round := Suc (next_round sa)\n      , decisions := decisions sa ++ dec_f\n      , last_obs := last_obs sa ++ const_map v (dom o_f)\n    \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_obsv_state.next_round := Suc (opt_obsv_state.next_round sa),\n     opt_obsv_state.decisions := opt_obsv_state.decisions sa ++ dec_f,\n     last_obs := last_obs sa ++ const_map v (dom o_f)\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "have \"S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV", "using step1 v"], ["proof (prove)\nusing this:\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n  r_votes sc = const_map v S\n\ngoal (1 subgoal):\n 1. S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV", "by(auto simp add: tso_round1_def obs_guard_def const_map_def)"], ["proof (state)\nthis:\n  S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "moreover"], ["proof (state)\nthis:\n  S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "have \"o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}", "using step1 v"], ["proof (prove)\nusing this:\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n  r_votes sc = const_map v S\n\ngoal (1 subgoal):\n 1. o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}", "by(auto simp add: tso_round1_def obs_guard_def dom_const_map)"], ["proof (state)\nthis:\n  o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\n  o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}", "have \n    abs_step: \n    \"(sa, sa') \\<in> olv_round (next_round sa) S v dec_f (dom o_f)\""], ["proof (prove)\nusing this:\n  S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\n  o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> olv_round (opt_obsv_state.next_round sa) S v dec_f (dom o_f)", "using R safe v step_r r_next step1"], ["proof (prove)\nusing this:\n  S \\<in> Quorum \\<longrightarrow> dom o_f = UNIV\n  o_f \\<noteq> Map.empty \\<longrightarrow> S \\<noteq> {}\n  (sa, sc) \\<in> tso_ref_rel\n  S \\<noteq> {} \\<longrightarrow> opt_obs_safe (last_obs sc) v\n  r_votes sc = const_map v S\n  two_step r = 1\n  opt_obsv_state.next_round sc = r\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> olv_round (opt_obsv_state.next_round sa) S v dec_f (dom o_f)", "by(clarsimp simp add: tso_ref_rel_def step1_rel_def basic_rel_def sa'_def \n      olv_round_def tso_round1_def)"], ["proof (state)\nthis:\n  (sa, sa')\n  \\<in> olv_round (opt_obsv_state.next_round sa) S v dec_f (dom o_f)\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "from v"], ["proof (chain)\npicking this:\n  r_votes sc = const_map v S", "have post_rel: \"(sa', sc') \\<in> tso_ref_rel\""], ["proof (prove)\nusing this:\n  r_votes sc = const_map v S\n\ngoal (1 subgoal):\n 1. (sa', sc') \\<in> tso_ref_rel", "using R step1"], ["proof (prove)\nusing this:\n  r_votes sc = const_map v S\n  (sa, sc) \\<in> tso_ref_rel\n  (sc, sc') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. (sa', sc') \\<in> tso_ref_rel", "apply(clarsimp simp add: tso_round0_def tso_round1_def \n      step0_rel_def basic_rel_def  sa'_def tso_ref_rel_def two_step_phase_Suc o_def\n      const_map_is_Some const_map_is_None const_map_equality obs_guard_def \n      intro!: arg_cong2[where f=map_add, OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>sc'a va.\n       \\<lbrakk>S = {} \\<or> va = v;\n        r = Suc (opt_obsv_state.next_round sc'a);\n        d_guard dec_f (const_map v S);\n        \\<forall>p.\n           (\\<forall>va.\n               o_f p = Some va \\<longrightarrow>\n               va = v \\<and> (\\<exists>q. q \\<in> S)) \\<and>\n           (dom (const_map v S) \\<in> Quorum \\<longrightarrow>\n            (\\<exists>q\\<in>dom (const_map v S). o_f p = const_map v S q));\n        sc' = sc'a\n        \\<lparr>r_votes := const_map va S,\n           opt_obsv_state.next_round :=\n             Suc (Suc (opt_obsv_state.next_round sc'a)),\n           opt_obsv_state.decisions := opt_obsv_state.decisions sa ++ dec_f,\n           last_obs := last_obs sa ++ o_f\\<rparr>;\n        (sa, sc'a\n         \\<lparr>opt_obsv_state.next_round :=\n                   Suc (opt_obsv_state.next_round sc'a),\n            r_votes := const_map va S\\<rparr>)\n        \\<in> step1_rel;\n        two_step (opt_obsv_state.next_round sc'a) = 0;\n        S \\<noteq> {} \\<longrightarrow> opt_obs_safe (last_obs sa) va;\n        sc = sc'a\n        \\<lparr>opt_obsv_state.next_round :=\n                  Suc (opt_obsv_state.next_round sc'a),\n           r_votes := const_map va S\\<rparr>;\n        opt_obsv_state.next_round sa =\n        two_phase (opt_obsv_state.next_round sc'a);\n        last_obs sc'a = last_obs sa;\n        opt_obsv_state.decisions sc'a = opt_obsv_state.decisions sa\\<rbrakk>\n       \\<Longrightarrow> o_f = const_map v (dom o_f)", "apply(auto simp add: const_map_def restrict_map_def intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sa', sc') \\<in> tso_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> tso_ref_rel;\n        (y, b) \\<in> tso_round1 r dec_f o_f\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb xc xd.\n                                (a, y) \\<in> olv_round x xa xb xc xd) \\<and>\n                            (y, b) \\<in> tso_ref_rel", "from abs_step post_rel"], ["proof (chain)\npicking this:\n  (sa, sa')\n  \\<in> olv_round (opt_obsv_state.next_round sa) S v dec_f (dom o_f)\n  (sa', sc') \\<in> tso_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>r' S' w dec_f' Ob'. (sa, sa') \\<in> olv_round r' S' w dec_f' Ob') \\<and> (sa', sc') \\<in> tso_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa')\n  \\<in> olv_round (opt_obsv_state.next_round sa) S v dec_f (dom o_f)\n  (sa', sc') \\<in> tso_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r' S' w dec_f' Ob'.\n           (sa, sa') \\<in> olv_round r' S' w dec_f' Ob') \\<and>\n       (sa', sc') \\<in> tso_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r' S' w dec_f' Ob'.\n         (sa, sa') \\<in> olv_round r' S' w dec_f' Ob') \\<and>\n     (sa', sc') \\<in> tso_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma TS_Observing_Refines:\n  \"PO_refines tso_ref_rel olv_TS tso_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines tso_ref_rel olv_TS tso_TS", "apply(auto simp add: PO_refines_def olv_TS_defs tso_TS_defs \n    intro!: tso_round0_refines tso_round1_refines)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lparr>opt_obsv_state.next_round = 0, decisions = Map.empty,\n        last_obs = Map.empty\\<rparr>,\n     \\<lparr>opt_obsv_state.next_round = 0, decisions = Map.empty,\n        last_obs = Map.empty, r_votes = Map.empty\\<rparr>)\n    \\<in> tso_ref_rel", "apply(auto simp add: tso_ref_rel_def step0_rel_def basic_rel_def tso_init_def quorum_for_def \n    dest: empty_not_quorum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition TSO_inv1 where\n  \"TSO_inv1 = {s. two_step (next_round s) = Suc 0 \\<longrightarrow>\n    (\\<exists>v. \\<forall>p w. r_votes s p = Some w \\<longrightarrow> w = v)}\""], ["", "lemmas TSO_inv1I = TSO_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas TSO_inv1E [elim] = TSO_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas TSO_inv1D = TSO_inv1_def [THEN setc_def_to_dest, rule_format]"], ["", "definition TSO_inv2 where\n  \"TSO_inv2 = {s. two_step (next_round s) = Suc 0 \\<longrightarrow>\n    (\\<forall>p v. (r_votes s p = Some v \\<longrightarrow> (\\<exists>q. last_obs s q \\<in> {None, Some v})))}\""], ["", "lemmas TSO_inv2I = TSO_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas TSO_inv2E [elim] = TSO_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas TSO_inv2D = TSO_inv2_def [THEN setc_def_to_dest, rule_format]"], ["", "subsubsection \\<open>Proofs of invariants\\<close>"], ["", "(******************************************************************************)"], ["", "lemma TSO_inv1_inductive:\n  \"init tso_TS \\<subseteq> TSO_inv1\"\n  \"{TSO_inv1} TS.trans tso_TS {> TSO_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init tso_TS \\<subseteq> TSO_inv1 &&&\n    {TSO_inv1} TS.trans tso_TS {> TSO_inv1}", "by(auto simp add: TSO_inv1_def tso_TS_defs PO_hoare_def \n    tso_round0_def tso_round1_def const_map_is_Some two_step_phase_Suc)"], ["", "lemma TSO_inv1_invariant:\n  \"reach tso_TS \\<subseteq> TSO_inv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tso_TS \\<subseteq> TSO_inv1", "by(intro inv_rule_basic TSO_inv1_inductive)"], ["", "lemma TSO_inv2_inductive:\n  \"init tso_TS \\<subseteq> TSO_inv2\"\n  \"{TSO_inv2} TS.trans tso_TS {> TSO_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init tso_TS \\<subseteq> TSO_inv2 &&&\n    {TSO_inv2} TS.trans tso_TS {> TSO_inv2}", "by(auto simp add: TSO_inv2_def tso_TS_defs PO_hoare_def \n    opt_obs_safe_def tso_round0_def tso_round1_def const_map_is_Some two_step_phase_Suc)"], ["", "lemma TSO_inv2_invariant:\n  \"reach tso_TS \\<subseteq> TSO_inv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach tso_TS \\<subseteq> TSO_inv2", "by(intro inv_rule_basic TSO_inv2_inductive)"], ["", "end"], ["", "end"]]}