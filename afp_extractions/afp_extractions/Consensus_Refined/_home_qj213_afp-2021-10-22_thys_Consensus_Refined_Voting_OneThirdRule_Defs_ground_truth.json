{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Voting/OneThirdRule_Defs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma MFR_exists: \"\\<exists>v. MFR msgs v\"", "lemma MFR_in_msgs:\n  assumes HO:\"HOs m p \\<noteq> {}\"\n      and v: \"MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v\"\n             (is \"MFR ?msgs v\")\n  shows \"\\<exists>q \\<in> HOs m p. v = the (?msgs q)\""], "translations": [["", "lemma MFR_exists: \"\\<exists>v. MFR msgs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "let ?cards = \"{ card (HOV msgs v) | v . True }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "let ?mfr = \"Max ?cards\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "have \"\\<forall>v. card (HOV msgs v) \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>v. card (HOV msgs v) \\<le> N", "by (auto intro: card_mono)"], ["proof (state)\nthis:\n  \\<forall>v. card (HOV msgs v) \\<le> N\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "hence \"?cards \\<subseteq> { 0 .. N }\""], ["proof (prove)\nusing this:\n  \\<forall>v. card (HOV msgs v) \\<le> N\n\ngoal (1 subgoal):\n 1. {card (HOV msgs v) |v. True} \\<subseteq> {0..N}", "by auto"], ["proof (state)\nthis:\n  {card (HOV msgs v) |v. True} \\<subseteq> {0..N}\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "hence fin: \"finite ?cards\""], ["proof (prove)\nusing this:\n  {card (HOV msgs v) |v. True} \\<subseteq> {0..N}\n\ngoal (1 subgoal):\n 1. finite {card (HOV msgs v) |v. True}", "by (metis atLeast0AtMost finite_atMost finite_subset)"], ["proof (state)\nthis:\n  finite {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "hence \"?mfr \\<in> ?cards\""], ["proof (prove)\nusing this:\n  finite {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. Max {card (HOV msgs v) |v. True} \\<in> {card (HOV msgs v) |v. True}", "by (rule Max_in) auto"], ["proof (state)\nthis:\n  Max {card (HOV msgs v) |v. True} \\<in> {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "then"], ["proof (chain)\npicking this:\n  Max {card (HOV msgs v) |v. True} \\<in> {card (HOV msgs v) |v. True}", "obtain v where v: \"?mfr = card (HOV msgs v)\""], ["proof (prove)\nusing this:\n  Max {card (HOV msgs v) |v. True} \\<in> {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        Max {card (HOV msgs v) |v. True} =\n        card (HOV msgs v) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Max {card (HOV msgs v) |v. True} = card (HOV msgs v)\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "have \"MFR msgs v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MFR msgs v", "proof (auto simp: MFR_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. card (HOV msgs w) \\<le> card (HOV msgs v)", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>w. card (HOV msgs w) \\<le> card (HOV msgs v)", "from fin"], ["proof (chain)\npicking this:\n  finite {card (HOV msgs v) |v. True}", "have \"card (HOV msgs w) \\<le> ?mfr\""], ["proof (prove)\nusing this:\n  finite {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. card (HOV msgs w) \\<le> Max {card (HOV msgs v) |v. True}", "by (rule Max_ge) auto"], ["proof (state)\nthis:\n  card (HOV msgs w) \\<le> Max {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. \\<And>w. card (HOV msgs w) \\<le> card (HOV msgs v)", "thus \"card (HOV msgs w) \\<le> card (HOV msgs v)\""], ["proof (prove)\nusing this:\n  card (HOV msgs w) \\<le> Max {card (HOV msgs v) |v. True}\n\ngoal (1 subgoal):\n 1. card (HOV msgs w) \\<le> card (HOV msgs v)", "by (unfold v)"], ["proof (state)\nthis:\n  card (HOV msgs w) \\<le> card (HOV msgs v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MFR msgs v\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", "thus ?thesis"], ["proof (prove)\nusing this:\n  MFR msgs v\n\ngoal (1 subgoal):\n 1. \\<exists>v. MFR msgs v", ".."], ["proof (state)\nthis:\n  \\<exists>v. MFR msgs v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Also, if a process has heard from at least one other process,\n  the most frequently received values are among the received messages.\n\\<close>"], ["", "lemma MFR_in_msgs:\n  assumes HO:\"HOs m p \\<noteq> {}\"\n      and v: \"MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v\"\n             (is \"MFR ?msgs v\")\n  shows \"\\<exists>q \\<in> HOs m p. v = the (?msgs q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "from HO"], ["proof (chain)\npicking this:\n  HOs m p \\<noteq> {}", "obtain q where q: \"q \\<in> HOs m p\""], ["proof (prove)\nusing this:\n  HOs m p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q. q \\<in> HOs m p \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> HOs m p\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "with v"], ["proof (chain)\npicking this:\n  MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v\n  q \\<in> HOs m p", "have \"HOV ?msgs (the (?msgs q)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v\n  q \\<in> HOs m p\n\ngoal (1 subgoal):\n 1. HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n     (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)) \\<noteq>\n    {}", "by (auto simp: HOV_def HOrcvdMsgs_def)"], ["proof (state)\nthis:\n  HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n   (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "hence HOp: \"0 < card (HOV ?msgs (the (?msgs q)))\""], ["proof (prove)\nusing this:\n  HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n   (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)) \\<noteq>\n  {}\n\ngoal (1 subgoal):\n 1. 0 < card\n         (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n           (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)))", "by auto"], ["proof (state)\nthis:\n  0 < card\n       (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n         (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "also"], ["proof (state)\nthis:\n  0 < card\n       (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n         (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "from v"], ["proof (chain)\npicking this:\n  MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v", "have \"\\<dots> \\<le> card (HOV ?msgs v)\""], ["proof (prove)\nusing this:\n  MFR (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v\n\ngoal (1 subgoal):\n 1. card\n     (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n       (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)))\n    \\<le> card (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v)", "by (simp add: MFR_def)"], ["proof (state)\nthis:\n  card\n   (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m))\n     (the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)))\n  \\<le> card (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "finally"], ["proof (chain)\npicking this:\n  0 < card (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v)", "have \"HOV ?msgs v \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card (HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v)\n\ngoal (1 subgoal):\n 1. HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  HOV (HOrcvdMsgs OTR_M m p (HOs m p) (rho m)) v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>HOs m p.\n       v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)", "by (auto simp: HOV_def HOrcvdMsgs_def)"], ["proof (state)\nthis:\n  \\<exists>q\\<in>HOs m p. v = the (HOrcvdMsgs OTR_M m p (HOs m p) (rho m) q)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  @{term \"TwoThirds msgs v\"} holds if value \\<open>v\\<close> has been\n  received from more than $2/3$ of all processes.\n\\<close>"], ["", "definition TwoThirds where\n  \"TwoThirds msgs v \\<equiv> (2*N) div 3 < card (HOV msgs v)\""], ["", "text \\<open>\n  The next-state relation of algorithm \\emph{One-Third Rule} for every process\n  is defined as follows:\n  if the process has received values from more than $2/3$ of all processes,\n  the \\<open>last_vote\\<close> field is set to the smallest among the most frequently received\n  values, and the process decides value $v$ if it received $v$ from more than\n  $2/3$ of all processes. If \\<open>p\\<close> hasn't heard from more than $2/3$ of\n  all processes, the state remains unchanged.\n  (Note that \\<open>Some\\<close> is the constructor of the option datatype, whereas\n  \\<open>\\<some>\\<close> is Hilbert's choice operator.)\n  We require the type of values to be linearly ordered so that the minimum\n  is guaranteed to be well-defined.\n\\<close>"], ["", "definition OTR_nextState where\n  \"OTR_nextState r p (st::('val::linorder) pstate) msgs st' \\<equiv> \n   if (2*N) div 3 < card {q. msgs q \\<noteq> None}\n   then st' = \\<lparr> last_vote = Min {v . MFR msgs v},\n          decision = (if (\\<exists>v. TwoThirds msgs v)\n                    then Some (\\<some>v. TwoThirds msgs v)\n                    else decision st) \\<rparr>\n   else st' = st\""], ["", "text \\<open>\n  The message sending function is very simple: at every round, every process\n  sends its current proposal (field \\<open>last_vote\\<close> of its local state) to all \n  processes.\n\\<close>"], ["", "definition OTR_sendMsg where\n  \"OTR_sendMsg r p q st \\<equiv> last_vote st\""], ["", "subsection \\<open>Communication predicate for \\emph{One-Third Rule}\\<close>"], ["", "text \\<open>\n  We now define the communication predicate for the \\emph{One-Third Rule}\n  algorithm to be correct.\n  It requires that, infinitely often, there is a round where all processes\n  receive messages from the same set \\<open>\\<Pi>\\<close> of processes where \\<open>\\<Pi>\\<close>\n  contains more than two thirds of all processes.\n  The ``per-round'' part of the communication predicate is trivial.\n\\<close>"], ["", "definition OTR_commPerRd where\n  \"OTR_commPerRd HOrs \\<equiv> True\""], ["", "definition OTR_commGlobal where\n  \"OTR_commGlobal HOs \\<equiv>\n    \\<forall>r. \\<exists>r0 \\<Pi>. r0 \\<ge> r \\<and> (\\<forall>p. HOs r0 p = \\<Pi>) \\<and> card \\<Pi> > (2*N) div 3\""], ["", "subsection \\<open>The \\emph{One-Third Rule} Heard-Of machine\\<close>"], ["", "text \\<open>\n  We now define the HO machine for the \\emph{One-Third Rule} algorithm\n  by assembling the algorithm definition and its communication-predicate.\n  Because this is an uncoordinated algorithm, the \\<open>crd\\<close> arguments\n  of the initial- and next-state predicates are unused.\n\\<close>"], ["", "definition OTR_HOMachine where\n  \"OTR_HOMachine =\n    \\<lparr> CinitState =  (\\<lambda> p st crd. OTR_initState p st),\n     sendMsg =  OTR_sendMsg,\n     CnextState = (\\<lambda> r p st msgs crd st'. OTR_nextState r p st msgs st'),\n     HOcommPerRd = OTR_commPerRd,\n     HOcommGlobal = OTR_commGlobal \\<rparr>\""], ["", "abbreviation \"OTR_M \\<equiv> OTR_HOMachine::(process, 'val::linorder pstate, 'val) HOMachine\""], ["", "end"]]}