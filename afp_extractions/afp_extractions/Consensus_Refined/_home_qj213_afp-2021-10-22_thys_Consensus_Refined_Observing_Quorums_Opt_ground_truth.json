{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Observing_Quorums_Opt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas olv_TS_defs = olv_TS_def olv_init_def olv_trans_def", "lemma OV_inv2_finite_map_graph:\n   \"s \\<in> OV_inv2 \\<Longrightarrow> finite (map_graph (case_prod (obsv_state.obs s)))\"", "lemma OV_inv2_finite_obs_set:\n   \"s \\<in> OV_inv2 \\<Longrightarrow> finite (vote_set (obsv_state.obs s) Q)\"", "lemma olv_round_refines:\n  \"{olv_ref_rel \\<inter> (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV} obsv_round r S v D Ob, olv_round r S v D Ob {>olv_ref_rel}\"", "lemma OLV_Refines:\n  \"PO_refines (olv_ref_rel \\<inter> (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV) obsv_TS olv_TS\""], "translations": [["", "lemmas olv_TS_defs = olv_TS_def olv_init_def olv_trans_def"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition olv_ref_rel where\n  \"olv_ref_rel \\<equiv> {(sa, sc).\n    next_round sc = v_state.next_round sa\n    \\<and> decisions sc = v_state.decisions sa\n    \\<and> last_obs sc = map_option snd o process_mru (obsv_state.obs sa)\n  }\""], ["", "lemma OV_inv2_finite_map_graph:\n   \"s \\<in> OV_inv2 \\<Longrightarrow> finite (map_graph (case_prod (obsv_state.obs s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> OV_inv2 \\<Longrightarrow>\n    finite (map_graph (\\<lambda>(x, y). obsv_state.obs s x y))", "apply(rule finite_dom_finite_map_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> OV_inv2 \\<Longrightarrow>\n    finite (dom (\\<lambda>(x, y). obsv_state.obs s x y))", "apply(rule finite_subset[where B=\"{0..< v_state.next_round s} \\<times> UNIV\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in> OV_inv2 \\<Longrightarrow>\n    dom (\\<lambda>(x, y). obsv_state.obs s x y)\n    \\<subseteq> {0..<v_state.next_round s} \\<times> UNIV\n 2. s \\<in> OV_inv2 \\<Longrightarrow>\n    finite ({0..<v_state.next_round s} \\<times> UNIV)", "apply(auto simp add: OV_inv2_def dom_def not_le[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OV_inv2_finite_obs_set:\n   \"s \\<in> OV_inv2 \\<Longrightarrow> finite (vote_set (obsv_state.obs s) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> OV_inv2 \\<Longrightarrow> finite (vote_set (obsv_state.obs s) Q)", "apply(drule OV_inv2_finite_map_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (map_graph (\\<lambda>(x, y). obsv_state.obs s x y)) \\<Longrightarrow>\n    finite (vote_set (obsv_state.obs s) Q)", "apply(clarsimp simp add: map_graph_def fun_graph_def vote_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {((a, b), y) |a b y. Some y = obsv_state.obs s a b} \\<Longrightarrow>\n    finite\n     {uu_.\n      \\<exists>a r v.\n         uu_ = (r, v) \\<and> Some v = obsv_state.obs s r a \\<and> a \\<in> Q}", "apply(erule finite_surj[where f=\"\\<lambda>((r, a), v). (r, v)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a r v.\n        uu_ = (r, v) \\<and> Some v = obsv_state.obs s r a \\<and> a \\<in> Q}\n    \\<subseteq> (\\<lambda>((r, a), v). (r, v)) `\n                {((a, b), y) |a b y. Some y = obsv_state.obs s a b}", "by(force simp add: image_def)"], ["", "lemma olv_round_refines:\n  \"{olv_ref_rel \\<inter> (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV} obsv_round r S v D Ob, olv_round r S v D Ob {>olv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {olv_ref_rel \\<inter>\n     (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n     UNIV} obsv_round r S v D Ob, olv_round r S v D Ob {> olv_ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "fix sa :: obsv_state and sc sc'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "assume\n    ainv: \"sa \\<in> OV_inv2\" \"sa \\<in> OV_inv3\" \"sa \\<in> OV_inv4\"\n    and step: \"(sc, sc') \\<in> olv_round r S v D Ob\"\n    and R: \"(sa, sc) \\<in> olv_ref_rel\"\n\n  \\<comment> \\<open>Abstract guard.\\<close>"], ["proof (state)\nthis:\n  sa \\<in> OV_inv2\n  sa \\<in> OV_inv3\n  sa \\<in> OV_inv4\n  (sc, sc') \\<in> olv_round r S v D Ob\n  (sa, sc) \\<in> olv_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "have \"S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v", "proof(rule impI, rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "assume S_nonempty: \"S \\<noteq> {}\" and no_Q: \"\\<not> obs_safe (v_state.next_round sa) sa v\""], ["proof (state)\nthis:\n  S \\<noteq> {}\n  \\<not> obs_safe (v_state.next_round sa) sa v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "from no_Q"], ["proof (chain)\npicking this:\n  \\<not> obs_safe (v_state.next_round sa) sa v", "obtain r_w w where \n      r_w: \"r_w < v_state.next_round sa\"\n      and all_obs: \"\\<forall>p. obsv_state.obs sa r_w p = Some w\"\n      and diff: \"w \\<noteq> v\""], ["proof (prove)\nusing this:\n  \\<not> obs_safe (v_state.next_round sa) sa v\n\ngoal (1 subgoal):\n 1. (\\<And>r_w w.\n        \\<lbrakk>r_w < v_state.next_round sa;\n         \\<forall>p. obsv_state.obs sa r_w p = Some w; w \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ainv(3)[THEN OV_inv4D]"], ["proof (prove)\nusing this:\n  \\<not> obs_safe (v_state.next_round sa) sa v\n  obsv_state.obs sa ?r ?p = Some ?v \\<and>\n  obsv_state.obs sa ?r ?q = Some ?w \\<Longrightarrow>\n  ?w = ?v\n\ngoal (1 subgoal):\n 1. (\\<And>r_w w.\n        \\<lbrakk>r_w < v_state.next_round sa;\n         \\<forall>p. obsv_state.obs sa r_w p = Some w; w \\<noteq> v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: obs_safe_def)  (metis)"], ["proof (state)\nthis:\n  r_w < v_state.next_round sa\n  \\<forall>p. obsv_state.obs sa r_w p = Some w\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "from diff step R"], ["proof (chain)\npicking this:\n  w \\<noteq> v\n  (sc, sc') \\<in> olv_round r S v D Ob\n  (sa, sc) \\<in> olv_ref_rel", "obtain p where \n      p_w: \"S \\<noteq> {} \\<longrightarrow> (map_option snd \\<circ> process_mru (obsv_state.obs sa)) p \\<noteq> Some w\""], ["proof (prove)\nusing this:\n  w \\<noteq> v\n  (sc, sc') \\<in> olv_round r S v D Ob\n  (sa, sc) \\<in> olv_ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        S \\<noteq> {} \\<longrightarrow>\n        (map_option snd \\<circ> process_mru (obsv_state.obs sa)) p \\<noteq>\n        Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: opt_obs_safe_def quorum_for_def olv_round_def  olv_ref_rel_def)  \n       (metis option.distinct(1) option.sel snd_conv)"], ["proof (state)\nthis:\n  S \\<noteq> {} \\<longrightarrow>\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) p \\<noteq> Some w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "from all_obs"], ["proof (chain)\npicking this:\n  \\<forall>p. obsv_state.obs sa r_w p = Some w", "have nempty: \"vote_set (obsv_state.obs sa) {p} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<forall>p. obsv_state.obs sa r_w p = Some w\n\ngoal (1 subgoal):\n 1. vote_set (obsv_state.obs sa) {p} \\<noteq> {}", "by(auto simp add:  vote_set_def)"], ["proof (state)\nthis:\n  vote_set (obsv_state.obs sa) {p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  vote_set (obsv_state.obs sa) {p} \\<noteq> {}", "obtain r_w' w' where w': \"process_mru (obsv_state.obs sa) p = Some (r_w', w')\""], ["proof (prove)\nusing this:\n  vote_set (obsv_state.obs sa) {p} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>r_w' w'.\n        process_mru (obsv_state.obs sa) p =\n        Some (r_w', w') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (simp add: process_mru_def mru_of_set_def) \n        (metis option_Max_by_def surj_pair)"], ["proof (state)\nthis:\n  process_mru (obsv_state.obs sa) p = Some (r_w', w')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "hence max: \"(r_w', w') = Max_by fst (vote_set (obsv_state.obs sa) {p})\""], ["proof (prove)\nusing this:\n  process_mru (obsv_state.obs sa) p = Some (r_w', w')\n\ngoal (1 subgoal):\n 1. (r_w', w') = Max_by fst (vote_set (obsv_state.obs sa) {p})", "by(auto simp add: process_mru_def mru_of_set_def option_Max_by_def)"], ["proof (state)\nthis:\n  (r_w', w') = Max_by fst (vote_set (obsv_state.obs sa) {p})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "hence w'_obs: \"(r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}\""], ["proof (prove)\nusing this:\n  (r_w', w') = Max_by fst (vote_set (obsv_state.obs sa) {p})\n\ngoal (1 subgoal):\n 1. (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}", "using Max_by_in[OF OV_inv2_finite_obs_set[OF ainv(1), of \"{p}\"] nempty]"], ["proof (prove)\nusing this:\n  (r_w', w') = Max_by fst (vote_set (obsv_state.obs sa) {p})\n  Max_by ?f (vote_set (obsv_state.obs sa) {p})\n  \\<in> vote_set (obsv_state.obs sa) {p}\n\ngoal (1 subgoal):\n 1. (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}", "by fastforce"], ["proof (state)\nthis:\n  (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"r_w \\<le> r_w'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r_w \\<le> r_w'", "using all_obs"], ["proof (prove)\nusing this:\n  \\<forall>p. obsv_state.obs sa r_w p = Some w\n\ngoal (1 subgoal):\n 1. r_w \\<le> r_w'", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. obsv_state.obs sa r_w p = Some w \\<Longrightarrow>\n    r_w \\<le> r_w'", "apply(rule Max_by_ge[OF OV_inv2_finite_obs_set[OF ainv(1), of \"{p}\"], of \"(r_w, w)\" fst, \n                            simplified max[symmetric], simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. obsv_state.obs sa r_w p = Some w \\<Longrightarrow>\n    (r_w, w) \\<in> vote_set (obsv_state.obs sa) {p}", "apply(auto simp add: quorum_for_def vote_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r_w \\<le> r_w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  r_w \\<le> r_w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "have \"w' \\<noteq> w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w' \\<noteq> w", "using p_w w' S_nonempty"], ["proof (prove)\nusing this:\n  S \\<noteq> {} \\<longrightarrow>\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) p \\<noteq> Some w\n  process_mru (obsv_state.obs sa) p = Some (r_w', w')\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. w' \\<noteq> w", "by(auto)"], ["proof (state)\nthis:\n  w' \\<noteq> w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  r_w \\<le> r_w'\n  w' \\<noteq> w", "have \"r_w < r_w'\""], ["proof (prove)\nusing this:\n  r_w \\<le> r_w'\n  w' \\<noteq> w\n\ngoal (1 subgoal):\n 1. r_w < r_w'", "using all_obs w'_obs"], ["proof (prove)\nusing this:\n  r_w \\<le> r_w'\n  w' \\<noteq> w\n  \\<forall>p. obsv_state.obs sa r_w p = Some w\n  (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}\n\ngoal (1 subgoal):\n 1. r_w < r_w'", "apply(elim le_neq_implies_less)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>w' \\<noteq> w; \\<forall>p. obsv_state.obs sa r_w p = Some w;\n     (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}\\<rbrakk>\n    \\<Longrightarrow> r_w \\<noteq> r_w'", "apply(auto simp add: quorum_for_def vote_set_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  r_w < r_w'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>S \\<noteq> {};\n     \\<not> obs_safe (v_state.next_round sa) sa v\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  r_w < r_w'\n\ngoal (1 subgoal):\n 1. False", "using ainv(2)[THEN OV_inv3D] w'_obs all_obs \\<open>w' \\<noteq> w\\<close>"], ["proof (prove)\nusing this:\n  r_w < r_w'\n  obsv_state.obs sa ?r ?p = Some ?v \\<Longrightarrow> obs_safe ?r sa ?v\n  (r_w', w') \\<in> vote_set (obsv_state.obs sa) {p}\n  \\<forall>p. obsv_state.obs sa r_w p = Some w\n  w' \\<noteq> w\n\ngoal (1 subgoal):\n 1. False", "by(fastforce simp add: vote_set_def obs_safe_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>Action refinement.\\<close>"], ["proof (state)\nthis:\n  S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "moreover"], ["proof (state)\nthis:\n  S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "have \n    \"(map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++ const_map v Ob =\n      map_option snd \\<circ> process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n    const_map v Ob =\n    map_option snd \\<circ>\n    process_mru\n     ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n    const_map v Ob =\n    map_option snd \\<circ>\n    process_mru\n     ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))", "from \\<open>sa \\<in> OV_inv2\\<close>[THEN OV_inv2D]"], ["proof (chain)\npicking this:\n  v_state.next_round sa \\<le> ?r \\<Longrightarrow>\n  obsv_state.obs sa ?r = Map.empty", "have empty: \"\\<forall>r'\\<ge>v_state.next_round sa. obsv_state.obs sa r' = Map.empty\""], ["proof (prove)\nusing this:\n  v_state.next_round sa \\<le> ?r \\<Longrightarrow>\n  obsv_state.obs sa ?r = Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>r'\\<ge>v_state.next_round sa. obsv_state.obs sa r' = Map.empty", "by simp"], ["proof (state)\nthis:\n  \\<forall>r'\\<ge>v_state.next_round sa. obsv_state.obs sa r' = Map.empty\n\ngoal (1 subgoal):\n 1. (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n    const_map v Ob =\n    map_option snd \\<circ>\n    process_mru\n     ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n    const_map v Ob =\n    map_option snd \\<circ>\n    process_mru\n     ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))", "by(auto simp add: map_add_def const_map_def restrict_map_def process_mru_new_votes[OF empty])"], ["proof (state)\nthis:\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n  const_map v Ob =\n  map_option snd \\<circ>\n  process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n  const_map v Ob =\n  map_option snd \\<circ>\n  process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))\n\ngoal (1 subgoal):\n 1. \\<And>a b y.\n       \\<lbrakk>(a, y) \\<in> olv_ref_rel; a \\<in> OV_inv2; a \\<in> OV_inv3;\n        a \\<in> OV_inv4; (y, b) \\<in> olv_round r S v D Ob\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (a, y) \\<in> obsv_round r S v D Ob \\<and>\n                            (y, b) \\<in> olv_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n  const_map v Ob =\n  map_option snd \\<circ>\n  process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))", "show \"\\<exists>sa'. (sa, sa') \\<in> obsv_round r S v D Ob \\<and> (sa', sc') \\<in> olv_ref_rel\""], ["proof (prove)\nusing this:\n  S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n  const_map v Ob =\n  map_option snd \\<circ>\n  process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (sa, sa') \\<in> obsv_round r S v D Ob \\<and>\n       (sa', sc') \\<in> olv_ref_rel", "using R step"], ["proof (prove)\nusing this:\n  S \\<noteq> {} \\<longrightarrow> obs_safe (v_state.next_round sa) sa v\n  (map_option snd \\<circ> process_mru (obsv_state.obs sa)) ++\n  const_map v Ob =\n  map_option snd \\<circ>\n  process_mru ((obsv_state.obs sa)(v_state.next_round sa := const_map v Ob))\n  (sa, sc) \\<in> olv_ref_rel\n  (sc, sc') \\<in> olv_round r S v D Ob\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (sa, sa') \\<in> obsv_round r S v D Ob \\<and>\n       (sa', sc') \\<in> olv_ref_rel", "by(clarsimp simp add: obsv_round_def olv_round_def olv_ref_rel_def)"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (sa, sa') \\<in> obsv_round r S v D Ob \\<and>\n     (sa', sc') \\<in> olv_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OLV_Refines:\n  \"PO_refines (olv_ref_rel \\<inter> (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV) obsv_TS olv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines\n     (olv_ref_rel \\<inter>\n      (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV)\n     obsv_TS olv_TS", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {olv_ref_rel \\<inter>\n     (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n     UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}\n 2. {OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4 \\<inter>\n     Domain\n      (olv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans obsv_TS {> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (olv_ref_rel \\<inter>\n       (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n       UNIV)} TS.trans olv_TS {> UNIV}\n 4. init olv_TS \\<subseteq> olv_ref_rel `` init obsv_TS\n 5. init obsv_TS \\<subseteq> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4\n 6. init olv_TS \\<subseteq> UNIV", "show \"init olv_TS \\<subseteq> olv_ref_rel `` init obsv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init olv_TS \\<subseteq> olv_ref_rel `` init obsv_TS", "by(auto simp add: obsv_TS_defs olv_TS_defs olv_ref_rel_def process_mru_def mru_of_set_def\n      vote_set_def option_Max_by_def intro!: ext)"], ["proof (state)\nthis:\n  init olv_TS \\<subseteq> olv_ref_rel `` init obsv_TS\n\ngoal (5 subgoals):\n 1. {olv_ref_rel \\<inter>\n     (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n     UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}\n 2. {OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4 \\<inter>\n     Domain\n      (olv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans obsv_TS {> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (olv_ref_rel \\<inter>\n       (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n       UNIV)} TS.trans olv_TS {> UNIV}\n 4. init obsv_TS \\<subseteq> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4\n 5. init olv_TS \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {olv_ref_rel \\<inter>\n     (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n     UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}\n 2. {OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4 \\<inter>\n     Domain\n      (olv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans obsv_TS {> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (olv_ref_rel \\<inter>\n       (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n       UNIV)} TS.trans olv_TS {> UNIV}\n 4. init obsv_TS \\<subseteq> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4\n 5. init olv_TS \\<subseteq> UNIV", "show\n    \"{olv_ref_rel \\<inter> (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times> UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {olv_ref_rel \\<inter>\n     (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n     UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}", "by(auto simp add: PO_refines_def obsv_TS_defs olv_TS_defs \n      intro!: olv_round_refines)"], ["proof (state)\nthis:\n  {olv_ref_rel \\<inter>\n   (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n   UNIV} TS.trans obsv_TS, TS.trans olv_TS {> olv_ref_rel}\n\ngoal (4 subgoals):\n 1. {OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4 \\<inter>\n     Domain\n      (olv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans obsv_TS {> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4}\n 2. {UNIV \\<inter>\n     Range\n      (olv_ref_rel \\<inter>\n       (OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4) \\<times>\n       UNIV)} TS.trans olv_TS {> UNIV}\n 3. init obsv_TS \\<subseteq> OV_inv2 \\<inter> OV_inv3 \\<inter> OV_inv4\n 4. init olv_TS \\<subseteq> UNIV", "qed (auto intro: OV_inv2_inductive OV_inv3_inductive OV_inv4_inductive\n  OV_inv2_inductive(1)[THEN subsetD] OV_inv3_inductive(1)[THEN subsetD] \n  OV_inv4_inductive(1)[THEN subsetD])"], ["", "end"], ["", "end"]]}