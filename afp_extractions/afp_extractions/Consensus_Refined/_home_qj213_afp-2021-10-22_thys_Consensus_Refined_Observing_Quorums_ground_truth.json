{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Observing_Quorums.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas obsv_TS_defs = obsv_TS_def obsv_init_def obsv_trans_def", "lemmas OV_inv1I = OV_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas OV_inv1E [elim] = OV_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas OV_inv1D = OV_inv1_def [THEN setc_def_to_dest, rule_format]", "lemma OV_inv1_obsv_round: \n  \"{OV_inv1} obsv_round r S v d_f Ob {> OV_inv1}\"", "lemma OV_inv1_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv1\" \n  \"{OV_inv1} trans obsv_TS {> OV_inv1}\"", "lemma quorum_for_const_map:\n  \"(quorum_for Q w (const_map v S)) = (Q \\<in> Quorum \\<and> Q \\<subseteq> S \\<and> w = v)\"", "lemma obsv_round_refines:\n  \"{obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1} sv_round r S v dec_f, obsv_round r S v dec_f Ob {> obsv_ref_rel}\"", "lemma Observable_Refines:\n  \"PO_refines (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1) sv_TS obsv_TS\"", "lemmas OV_inv2I = OV_inv2_def [THEN setc_def_to_intro, rule_format]", "lemmas OV_inv2E [elim] = OV_inv2_def [THEN setc_def_to_elim, rule_format]", "lemmas OV_inv2D = OV_inv2_def [THEN setc_def_to_dest, rule_format]", "lemmas OV_inv3I = OV_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas OV_inv3E [elim] = OV_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas OV_inv3D = OV_inv3_def [THEN setc_def_to_dest, rule_format]", "lemmas OV_inv4I = OV_inv4_def [THEN setc_def_to_intro, rule_format]", "lemmas OV_inv4E [elim] = OV_inv4_def [THEN setc_def_to_elim, rule_format]", "lemmas OV_inv4D = OV_inv4_def [THEN setc_def_to_dest, rule_format]", "lemma OV_inv2_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv2\"\n  \"{OV_inv2} trans obsv_TS {> OV_inv2}\"", "lemma SVinv3_inductive:\n  \"init obsv_TS \\<subseteq> SV_inv3\"\n  \"{SV_inv3} trans obsv_TS {> SV_inv3}\"", "lemma OV_inv3_obsv_round: \n  \"{OV_inv3 \\<inter> OV_inv2} obsv_round r S v D Ob {> OV_inv3}\"", "lemma OV_inv3_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv3\"\n  \"{OV_inv3 \\<inter> OV_inv2} trans obsv_TS {> OV_inv3}\"", "lemma OV_inv4_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv4\"\n  \"{OV_inv4} trans obsv_TS {> OV_inv4}\""], "translations": [["", "lemmas obsv_TS_defs = obsv_TS_def obsv_init_def obsv_trans_def"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition OV_inv1 where\n  \"OV_inv1 = {s. \\<forall>r Q v. quorum_for Q v (votes s r) \\<longrightarrow>\n    (\\<forall>Q' \\<in> Quorum. quorum_for Q' v (obs s r))}\""], ["", "lemmas OV_inv1I = OV_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas OV_inv1E [elim] = OV_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas OV_inv1D = OV_inv1_def [THEN setc_def_to_dest, rule_format]"], ["", "subsubsection \\<open>Proofs of invariants\\<close>"], ["", "(******************************************************************************)"], ["", "lemma OV_inv1_obsv_round: \n  \"{OV_inv1} obsv_round r S v d_f Ob {> OV_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OV_inv1} obsv_round r S v d_f Ob {> OV_inv1}", "proof(clarsimp simp add: PO_hoare_defs intro!: OV_inv1I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ra Q va Q' xa.\n       \\<lbrakk>quorum_for Q va (votes x ra); Q' \\<in> Quorum;\n        xa \\<in> OV_inv1; (xa, x) \\<in> obsv_round r S v d_f Ob\\<rbrakk>\n       \\<Longrightarrow> quorum_for Q' va (obsv_state.obs x ra)", "fix v' s s' Q Q' r'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ra Q va Q' xa.\n       \\<lbrakk>quorum_for Q va (votes x ra); Q' \\<in> Quorum;\n        xa \\<in> OV_inv1; (xa, x) \\<in> obsv_round r S v d_f Ob\\<rbrakk>\n       \\<Longrightarrow> quorum_for Q' va (obsv_state.obs x ra)", "assume \n    Q: \"quorum_for Q v' (votes s' r')\"  \n    and inv: \"s \\<in> OV_inv1\"\n    and step: \"(s, s') \\<in> obsv_round r S v d_f Ob\"\n    and quorum: \"Q' \\<in> Quorum\""], ["proof (state)\nthis:\n  quorum_for Q v' (votes s' r')\n  s \\<in> OV_inv1\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  Q' \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>x ra Q va Q' xa.\n       \\<lbrakk>quorum_for Q va (votes x ra); Q' \\<in> Quorum;\n        xa \\<in> OV_inv1; (xa, x) \\<in> obsv_round r S v d_f Ob\\<rbrakk>\n       \\<Longrightarrow> quorum_for Q' va (obsv_state.obs x ra)", "from Q inv[THEN OV_inv1D] step quorum"], ["proof (chain)\npicking this:\n  quorum_for Q v' (votes s' r')\n  \\<lbrakk>quorum_for ?Q ?v (votes s ?r); ?Q' \\<in> Quorum\\<rbrakk>\n  \\<Longrightarrow> quorum_for ?Q' ?v (obsv_state.obs s ?r)\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  Q' \\<in> Quorum", "show \"quorum_for Q' v' (obs s' r')\""], ["proof (prove)\nusing this:\n  quorum_for Q v' (votes s' r')\n  \\<lbrakk>quorum_for ?Q ?v (votes s ?r); ?Q' \\<in> Quorum\\<rbrakk>\n  \\<Longrightarrow> quorum_for ?Q' ?v (obsv_state.obs s ?r)\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  Q' \\<in> Quorum\n\ngoal (1 subgoal):\n 1. quorum_for Q' v' (obsv_state.obs s' r')", "proof(cases \"r'=r\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum; r' = r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')\n 2. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum;\n     r' \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')", "case True"], ["proof (state)\nthis:\n  r' = r\n\ngoal (2 subgoals):\n 1. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum; r' = r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')\n 2. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum;\n     r' \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')", "with step and Q"], ["proof (chain)\npicking this:\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  quorum_for Q v' (votes s' r')\n  r' = r", "have \"S \\<in> Quorum\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  quorum_for Q v' (votes s' r')\n  r' = r\n\ngoal (1 subgoal):\n 1. S \\<in> Quorum", "by(fastforce simp add: obsv_round_def obs_safe_def quorum_for_def const_map_is_Some\n        ball_conj_distrib subset_eq[symmetric] intro: mono_quorum[where Q'=S])"], ["proof (state)\nthis:\n  S \\<in> Quorum\n\ngoal (2 subgoals):\n 1. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum; r' = r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')\n 2. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum;\n     r' \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')", "thus ?thesis"], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n\ngoal (1 subgoal):\n 1. quorum_for Q' v' (obsv_state.obs s' r')", "using step inv[THEN OV_inv1D] Q quorum"], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n  (s, s') \\<in> obsv_round r S v d_f Ob\n  \\<lbrakk>quorum_for ?Q ?v (votes s ?r); ?Q' \\<in> Quorum\\<rbrakk>\n  \\<Longrightarrow> quorum_for ?Q' ?v (obsv_state.obs s ?r)\n  quorum_for Q v' (votes s' r')\n  Q' \\<in> Quorum\n\ngoal (1 subgoal):\n 1. quorum_for Q' v' (obsv_state.obs s' r')", "by(clarsimp simp add: obsv_round_def obs_safe_def quorum_for_def const_map_is_Some\n        ball_conj_distrib subset_eq[symmetric] dest!: quorum_non_empty)"], ["proof (state)\nthis:\n  quorum_for Q' v' (obsv_state.obs s' r')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>quorum_for Q v' (votes s' r');\n     \\<And>Q v r Q'.\n        \\<lbrakk>quorum_for Q v (votes s r); Q' \\<in> Quorum\\<rbrakk>\n        \\<Longrightarrow> quorum_for Q' v (obsv_state.obs s r);\n     (s, s') \\<in> obsv_round r S v d_f Ob; Q' \\<in> Quorum;\n     r' \\<noteq> r\\<rbrakk>\n    \\<Longrightarrow> quorum_for Q' v' (obsv_state.obs s' r')", "qed(clarsimp simp add: obsv_round_def obs_safe_def quorum_for_def)"], ["proof (state)\nthis:\n  quorum_for Q' v' (obsv_state.obs s' r')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OV_inv1_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv1\" \n  \"{OV_inv1} trans obsv_TS {> OV_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> OV_inv1 &&&\n    {OV_inv1} TS.trans obsv_TS {> OV_inv1}", "apply (simp add: obsv_TS_defs OV_inv1_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>Q v.\n       quorum_for Q v Map.empty \\<longrightarrow>\n       (\\<forall>Q'\\<in>Quorum. quorum_for Q' v Map.empty)\n 2. {OV_inv1} TS.trans obsv_TS {> OV_inv1}", "apply (auto simp add: obsv_TS_defs OV_inv1_obsv_round quorum_for_def dest: empty_not_quorum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma quorum_for_const_map:\n  \"(quorum_for Q w (const_map v S)) = (Q \\<in> Quorum \\<and> Q \\<subseteq> S \\<and> w = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_for Q w (const_map v S) =\n    (Q \\<in> Quorum \\<and> Q \\<subseteq> S \\<and> w = v)", "by(auto simp add: quorum_for_def const_map_is_Some dest: quorum_non_empty)"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition obsv_ref_rel where \n  \"obsv_ref_rel \\<equiv> {(sa, sc).\n    sa = v_state.truncate sc\n  }\""], ["", "lemma obsv_round_refines:\n  \"{obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1} sv_round r S v dec_f, obsv_round r S v dec_f Ob {> obsv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {obsv_ref_rel \\<inter>\n     UNIV \\<times>\n     OV_inv1} sv_round r S v\n               dec_f, obsv_round r S v dec_f Ob {> obsv_ref_rel}", "apply(clarsimp simp add: PO_rhoare_defs sv_round_def obsv_round_def safe_def obsv_ref_rel_def \n    v_state.truncate_def obs_safe_def quorum_for_def OV_inv1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y r' Q w.\n       \\<lbrakk>\\<forall>r Q v.\n                   Q \\<in> Quorum \\<and>\n                   (\\<forall>p\\<in>Q.\n                       votes y r p = Some v) \\<longrightarrow>\n                   (\\<forall>Q'\\<in>Quorum.\n                       \\<forall>p\\<in>Q'. obsv_state.obs y r p = Some v);\n        r = next_round y; d_guard dec_f (const_map v S);\n        S \\<in> Quorum \\<longrightarrow> Ob = UNIV; S \\<noteq> {};\n        r' < next_round y; Q \\<in> Quorum;\n        \\<forall>p\\<in>Q. votes y r' p = Some w;\n        \\<forall>r'<next_round y.\n           \\<exists>p.\n              obsv_state.obs y r' p = None \\<or>\n              obsv_state.obs y r' p = Some v\\<rbrakk>\n       \\<Longrightarrow> v = w", "by (metis UNIV_I UNIV_quorum  option.distinct(1) option.inject)"], ["", "lemma Observable_Refines:\n  \"PO_refines (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1) sv_TS obsv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1) sv_TS obsv_TS", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {obsv_ref_rel \\<inter>\n     UNIV \\<times>\n     OV_inv1} TS.trans sv_TS, TS.trans obsv_TS {> obsv_ref_rel}\n 2. {UNIV \\<inter>\n     Domain\n      (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1)} TS.trans sv_TS {> UNIV}\n 3. {OV_inv1 \\<inter>\n     Range\n      (obsv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans obsv_TS {> OV_inv1}\n 4. init obsv_TS \\<subseteq> obsv_ref_rel `` init sv_TS\n 5. init sv_TS \\<subseteq> UNIV\n 6. init obsv_TS \\<subseteq> OV_inv1", "show \"init obsv_TS \\<subseteq> obsv_ref_rel `` init sv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> obsv_ref_rel `` init sv_TS", "by(auto simp add: PO_refines_def sv_TS_defs  obsv_TS_defs  obsv_ref_rel_def \n    v_state.truncate_def)"], ["proof (state)\nthis:\n  init obsv_TS \\<subseteq> obsv_ref_rel `` init sv_TS\n\ngoal (5 subgoals):\n 1. {obsv_ref_rel \\<inter>\n     UNIV \\<times>\n     OV_inv1} TS.trans sv_TS, TS.trans obsv_TS {> obsv_ref_rel}\n 2. {UNIV \\<inter>\n     Domain\n      (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1)} TS.trans sv_TS {> UNIV}\n 3. {OV_inv1 \\<inter>\n     Range\n      (obsv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans obsv_TS {> OV_inv1}\n 4. init sv_TS \\<subseteq> UNIV\n 5. init obsv_TS \\<subseteq> OV_inv1", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {obsv_ref_rel \\<inter>\n     UNIV \\<times>\n     OV_inv1} TS.trans sv_TS, TS.trans obsv_TS {> obsv_ref_rel}\n 2. {UNIV \\<inter>\n     Domain\n      (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1)} TS.trans sv_TS {> UNIV}\n 3. {OV_inv1 \\<inter>\n     Range\n      (obsv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans obsv_TS {> OV_inv1}\n 4. init sv_TS \\<subseteq> UNIV\n 5. init obsv_TS \\<subseteq> OV_inv1", "show \"{obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1} trans sv_TS, trans obsv_TS {> obsv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {obsv_ref_rel \\<inter>\n     UNIV \\<times>\n     OV_inv1} TS.trans sv_TS, TS.trans obsv_TS {> obsv_ref_rel}", "by(auto simp add: PO_refines_def sv_TS_defs  obsv_TS_defs intro!: \n      obsv_round_refines relhoare_refl)"], ["proof (state)\nthis:\n  {obsv_ref_rel \\<inter>\n   UNIV \\<times> OV_inv1} TS.trans sv_TS, TS.trans obsv_TS {> obsv_ref_rel}\n\ngoal (4 subgoals):\n 1. {UNIV \\<inter>\n     Domain\n      (obsv_ref_rel \\<inter> UNIV \\<times> OV_inv1)} TS.trans sv_TS {> UNIV}\n 2. {OV_inv1 \\<inter>\n     Range\n      (obsv_ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans obsv_TS {> OV_inv1}\n 3. init sv_TS \\<subseteq> UNIV\n 4. init obsv_TS \\<subseteq> OV_inv1", "qed(auto intro: OV_inv1_inductive del: subsetI)"], ["", "subsection \\<open>Additional invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition OV_inv2 where\n  \"OV_inv2 = {s. \\<forall>r \\<ge> next_round s. obs s r = Map.empty }\""], ["", "lemmas OV_inv2I = OV_inv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas OV_inv2E [elim] = OV_inv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas OV_inv2D = OV_inv2_def [THEN setc_def_to_dest, rule_format]"], ["", "definition OV_inv3 where\n  \"OV_inv3 = {s. \\<forall>r p v. obs s r p = Some v \\<longrightarrow>\n    obs_safe r s v}\""], ["", "lemmas OV_inv3I = OV_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas OV_inv3E [elim] = OV_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas OV_inv3D = OV_inv3_def [THEN setc_def_to_dest, rule_format]"], ["", "definition OV_inv4 where\n  \"OV_inv4 = {s. \\<forall>r p q v w. obs s r p = Some v \\<and> obs s r q = Some w \\<longrightarrow>\n    w = v}\""], ["", "lemmas OV_inv4I = OV_inv4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas OV_inv4E [elim] = OV_inv4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas OV_inv4D = OV_inv4_def [THEN setc_def_to_dest, rule_format]"], ["", "subsubsection \\<open>Proofs of additional invariants\\<close>"], ["", "(******************************************************************************)"], ["", "lemma OV_inv2_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv2\"\n  \"{OV_inv2} trans obsv_TS {> OV_inv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> OV_inv2 &&&\n    {OV_inv2} TS.trans obsv_TS {> OV_inv2}", "by(auto simp add: PO_hoare_defs OV_inv2_def obsv_TS_defs obsv_round_def const_map_is_Some)"], ["", "lemma SVinv3_inductive:\n  \"init obsv_TS \\<subseteq> SV_inv3\"\n  \"{SV_inv3} trans obsv_TS {> SV_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> SV_inv3 &&&\n    {SV_inv3} TS.trans obsv_TS {> SV_inv3}", "by(auto simp add: PO_hoare_defs SV_inv3_def obsv_TS_defs obsv_round_def const_map_is_Some)"], ["", "lemma OV_inv3_obsv_round: \n  \"{OV_inv3 \\<inter> OV_inv2} obsv_round r S v D Ob {> OV_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {OV_inv3 \\<inter> OV_inv2} obsv_round r S v D Ob {> OV_inv3}", "proof(clarsimp simp add: PO_hoare_defs intro!: OV_inv3I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "fix s s' r_w p w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "assume Assms:\n    \"obs s' r_w p = Some w\" \n    \"s \\<in> OV_inv3\"\n    \"(s, s') \\<in> obsv_round r S v D Ob\"\n    \"s \\<in> OV_inv2\""], ["proof (state)\nthis:\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "hence \"s' \\<in> OV_inv2\""], ["proof (prove)\nusing this:\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. s' \\<in> OV_inv2", "by(force simp add: obsv_TS_defs intro: OV_inv2_inductive(2)[THEN hoareD, OF \\<open>s \\<in> OV_inv2\\<close>])"], ["proof (state)\nthis:\n  s' \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "hence \"r_w \\<le> next_round s'\""], ["proof (prove)\nusing this:\n  s' \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. r_w \\<le> next_round s'", "using Assms"], ["proof (prove)\nusing this:\n  s' \\<in> OV_inv2\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. r_w \\<le> next_round s'", "by(auto simp add: OV_inv2_def intro!: leI)"], ["proof (state)\nthis:\n  r_w \\<le> next_round s'\n\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "hence r_w_le: \"r_w \\<le> next_round s\""], ["proof (prove)\nusing this:\n  r_w \\<le> next_round s'\n\ngoal (1 subgoal):\n 1. r_w \\<le> next_round s", "using Assms"], ["proof (prove)\nusing this:\n  r_w \\<le> next_round s'\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. r_w \\<le> next_round s", "by(auto simp add: obsv_round_def le_Suc_eq)"], ["proof (state)\nthis:\n  r_w \\<le> next_round s\n\ngoal (1 subgoal):\n 1. \\<And>x ra p va xa.\n       \\<lbrakk>obsv_state.obs x ra p = Some va;\n        (xa, x) \\<in> obsv_round r S v D Ob; xa \\<in> OV_inv3;\n        xa \\<in> OV_inv2\\<rbrakk>\n       \\<Longrightarrow> obs_safe ra x va", "show \"obs_safe r_w s' w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_safe r_w s' w", "proof(cases \"r_w = next_round s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. r_w = next_round s \\<Longrightarrow> obs_safe r_w s' w\n 2. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "case True"], ["proof (state)\nthis:\n  r_w = next_round s\n\ngoal (2 subgoals):\n 1. r_w = next_round s \\<Longrightarrow> obs_safe r_w s' w\n 2. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "thus ?thesis"], ["proof (prove)\nusing this:\n  r_w = next_round s\n\ngoal (1 subgoal):\n 1. obs_safe r_w s' w", "using Assms"], ["proof (prove)\nusing this:\n  r_w = next_round s\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. obs_safe r_w s' w", "by(auto simp add: obsv_round_def const_map_is_Some obs_safe_def)"], ["proof (state)\nthis:\n  obs_safe r_w s' w\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "case False"], ["proof (state)\nthis:\n  r_w \\<noteq> next_round s\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "hence \"r_w < next_round s\""], ["proof (prove)\nusing this:\n  r_w \\<noteq> next_round s\n\ngoal (1 subgoal):\n 1. r_w < next_round s", "using r_w_le"], ["proof (prove)\nusing this:\n  r_w \\<noteq> next_round s\n  r_w \\<le> next_round s\n\ngoal (1 subgoal):\n 1. r_w < next_round s", "by(metis less_le)"], ["proof (state)\nthis:\n  r_w < next_round s\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "moreover"], ["proof (state)\nthis:\n  r_w < next_round s\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "have \"\\<forall>r'. r' \\<noteq> next_round s \\<longrightarrow> obs s' r' = obs s r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r'.\n       r' \\<noteq> next_round s \\<longrightarrow>\n       obsv_state.obs s' r' = obsv_state.obs s r'", "using Assms(3)"], ["proof (prove)\nusing this:\n  (s, s') \\<in> obsv_round r S v D Ob\n\ngoal (1 subgoal):\n 1. \\<forall>r'.\n       r' \\<noteq> next_round s \\<longrightarrow>\n       obsv_state.obs s' r' = obsv_state.obs s r'", "by(auto simp add: obsv_round_def)"], ["proof (state)\nthis:\n  \\<forall>r'.\n     r' \\<noteq> next_round s \\<longrightarrow>\n     obsv_state.obs s' r' = obsv_state.obs s r'\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "ultimately"], ["proof (chain)\npicking this:\n  r_w < next_round s\n  \\<forall>r'.\n     r' \\<noteq> next_round s \\<longrightarrow>\n     obsv_state.obs s' r' = obsv_state.obs s r'", "have \n      \"\\<forall>r' \\<le> r_w. obs s' r' = obs s r'\""], ["proof (prove)\nusing this:\n  r_w < next_round s\n  \\<forall>r'.\n     r' \\<noteq> next_round s \\<longrightarrow>\n     obsv_state.obs s' r' = obsv_state.obs s r'\n\ngoal (1 subgoal):\n 1. \\<forall>r'\\<le>r_w. obsv_state.obs s' r' = obsv_state.obs s r'", "by(auto)"], ["proof (state)\nthis:\n  \\<forall>r'\\<le>r_w. obsv_state.obs s' r' = obsv_state.obs s r'\n\ngoal (1 subgoal):\n 1. r_w \\<noteq> next_round s \\<Longrightarrow> obs_safe r_w s' w", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>r'\\<le>r_w. obsv_state.obs s' r' = obsv_state.obs s r'\n\ngoal (1 subgoal):\n 1. obs_safe r_w s' w", "using Assms"], ["proof (prove)\nusing this:\n  \\<forall>r'\\<le>r_w. obsv_state.obs s' r' = obsv_state.obs s r'\n  obsv_state.obs s' r_w p = Some w\n  s \\<in> OV_inv3\n  (s, s') \\<in> obsv_round r S v D Ob\n  s \\<in> OV_inv2\n\ngoal (1 subgoal):\n 1. obs_safe r_w s' w", "by(auto simp add: OV_inv3_def obs_safe_def)"], ["proof (state)\nthis:\n  obs_safe r_w s' w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  obs_safe r_w s' w\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OV_inv3_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv3\"\n  \"{OV_inv3 \\<inter> OV_inv2} trans obsv_TS {> OV_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> OV_inv3 &&&\n    {OV_inv3 \\<inter> OV_inv2} TS.trans obsv_TS {> OV_inv3}", "apply(auto simp add: obsv_TS_def obsv_trans_def intro: OV_inv3_obsv_round)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> obsv_init \\<Longrightarrow> x \\<in> OV_inv3", "apply(auto simp add: obsv_init_def OV_inv3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma OV_inv4_inductive:\n  \"init obsv_TS \\<subseteq> OV_inv4\"\n  \"{OV_inv4} trans obsv_TS {> OV_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init obsv_TS \\<subseteq> OV_inv4 &&&\n    {OV_inv4} TS.trans obsv_TS {> OV_inv4}", "by(auto simp add: PO_hoare_defs OV_inv4_def obsv_TS_defs obsv_round_def const_map_is_Some)"], ["", "end"], ["", "end"]]}