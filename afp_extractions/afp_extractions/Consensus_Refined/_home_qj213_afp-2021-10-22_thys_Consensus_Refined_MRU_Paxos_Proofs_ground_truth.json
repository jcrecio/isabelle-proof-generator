{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/MRU/Paxos_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas Paxos_TS_defs = Paxos_TS_def CHO_to_TS_def Paxos_Alg_def CHOinitConfig_def\n  Paxos_initState_def", "lemma three_step_less_D:\n  \"0 < three_step r \\<Longrightarrow> three_step r = 1 \\<or> three_step r = 2\"", "lemma Paxos_trans:\n  \"CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds) = \n  Paxos_trans_step HOs SHOs crds next0 send0 0\n  \\<union> Paxos_trans_step HOs SHOs crds next1 send1 1\n  \\<union> Paxos_trans_step HOs SHOs crds next2 send2 2\n  \"", "lemma mru_vote_evolution0:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\"", "lemma mru_vote_evolution2:\n  \"\\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\"", "lemma decide_evolution:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"\n  \"\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"", "lemma msgs_mru_vote: \n  assumes\n  \"\\<mu> (coord r) \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) (coord r)\" (is \"\\<mu> ?p \\<in> _\")\n  shows \"((msgs_to_lvs (\\<mu> ?p)) |` HOs r ?p) = (mru_vote o cfg) |` HOs r ?p\"", "lemma step0_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r C. majorities.opt_mru_step0 r C), \n    Paxos_trans_step HOs HOs crds next0 send0 0 {> paxos_ref_rel}\"", "lemma step1_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r S v. majorities.opt_mru_step1 r S v), \n    Paxos_trans_step HOs HOs crds next1 send1 (Suc 0) {> paxos_ref_rel}\"", "lemma step2_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r dec_f. majorities.opt_mru_step2 r dec_f), \n    Paxos_trans_step HOs HOs crds next2 send2 2 {> paxos_ref_rel}\"", "lemma Paxos_Refines_ThreeStep_MRU:\n  \"PO_refines paxos_ref_rel \n    majorities.ts_mru_TS (Paxos_TS HOs HOs crds)\"", "theorem Paxos_termination:\n  assumes run: \"CHORun Paxos_Alg rho HOs crds\"\n      and commR: \"\\<forall>r. CHOcommPerRd Paxos_M r (HOs r) (crds r)\"\n      and commG: \"CHOcommGlobal Paxos_M HOs crds\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], "translations": [["", "lemmas Paxos_TS_defs = Paxos_TS_def CHO_to_TS_def Paxos_Alg_def CHOinitConfig_def\n  Paxos_initState_def"], ["", "definition Paxos_trans_step where\n  \"Paxos_trans_step HOs SHOs crds nxt_f snd_f stp \\<equiv> \\<Union>r \\<mu>.\n    {((r, cfg), (Suc r, cfg'))|cfg cfg'. three_step r = stp  \\<and> (\\<forall>p.\n      \\<mu> p \\<in> get_msgs (snd_f r) cfg (HOs r) (SHOs r) p\n      \\<and> nxt_f r p (cfg p) (\\<mu> p) (crds r) (cfg' p)\n    )}\""], ["", "lemma three_step_less_D:\n  \"0 < three_step r \\<Longrightarrow> three_step r = 1 \\<or> three_step r = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < three_step r \\<Longrightarrow>\n    three_step r = 1 \\<or> three_step r = 2", "by(unfold three_step_def, arith)"], ["", "lemma Paxos_trans:\n  \"CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds) = \n  Paxos_trans_step HOs SHOs crds next0 send0 0\n  \\<union> Paxos_trans_step HOs SHOs crds next1 send1 1\n  \\<union> Paxos_trans_step HOs SHOs crds next2 send2 2\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds) =\n    Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2", "proof(rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n                Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n                Paxos_trans_step HOs SHOs crds next2 send2 2\n 2. Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs\n                 (K \\<circ> crds)", "show \"CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n       Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n       Paxos_trans_step HOs SHOs crds next2 send2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n                Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n                Paxos_trans_step HOs SHOs crds next2 send2 2", "by(force simp add: CSHO_trans_alt_def Paxos_sendMsg_def Paxos_nextState_def \n    Paxos_trans_step_def K_def dest!: three_step_less_D)"], ["proof (state)\nthis:\n  CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds)\n  \\<subseteq> Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n              Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n              Paxos_trans_step HOs SHOs crds next2 send2 2\n\ngoal (1 subgoal):\n 1. Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs\n                 (K \\<circ> crds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs\n                 (K \\<circ> crds)", "show \"Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs (K \\<circ> crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    Paxos_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs\n                 (K \\<circ> crds)", "by(force simp add: CSHO_trans_alt_def Paxos_sendMsg_def Paxos_nextState_def \n    Paxos_trans_step_def K_def)"], ["proof (state)\nthis:\n  Paxos_trans_step HOs SHOs crds next0 send0 0 \\<union>\n  Paxos_trans_step HOs SHOs crds next1 send1 1 \\<union>\n  Paxos_trans_step HOs SHOs crds next2 send2 2\n  \\<subseteq> CSHO_trans_alt Paxos_sendMsg Paxos_nextState HOs SHOs\n               (K \\<circ> crds)\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition coord_vote_to_set :: \"nat \\<Rightarrow> (process \\<Rightarrow> (val pstate)) \\<Rightarrow> val set\" where\n  \"coord_vote_to_set r sc \\<equiv> (let v = pstate.commt (sc (coord r)) in \n      if v = None \n          then {}\n          else {the v})\""], ["", "definition paxos_ref_rel :: \"(three_step_mru_state \\<times> p_TS_state)set\" where\n  \"paxos_ref_rel = {(sa, (r, sc)).\n    opt_mru_state.next_round sa = r\n    \\<and> opt_mru_state.decisions sa = pstate.decide o sc\n    \\<and> opt_mru_state.mru_vote sa = pstate.mru_vote o sc\n    \\<and> (three_step r = Suc 0 \\<longrightarrow> three_step_mru_state.candidates sa = coord_vote_to_set r sc)\n  }\""], ["", "lemma mru_vote_evolution0:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n    pstate.mru_vote \\<circ> s' = pstate.mru_vote \\<circ> s", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       next0 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (pstate.mru_vote \\<circ> s') x = (pstate.mru_vote \\<circ> s) x", "by(auto simp add: next0_def next2_def Let_def)"], ["", "lemma mru_vote_evolution2:\n  \"\\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n    pstate.mru_vote \\<circ> s' = pstate.mru_vote \\<circ> s", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       next2 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (pstate.mru_vote \\<circ> s') x = (pstate.mru_vote \\<circ> s) x", "by(auto simp add: next0_def next2_def Let_def)"], ["", "lemma decide_evolution:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"\n  \"\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n     decide \\<circ> s = decide \\<circ> s') &&&\n    (\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n     decide \\<circ> s = decide \\<circ> s')", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       next0 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (decide \\<circ> s) x = (decide \\<circ> s') x\n 2. \\<And>x.\n       next1 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (decide \\<circ> s) x = (decide \\<circ> s') x", "by(auto simp add: next0_def next1_def Let_def)"], ["", "lemma msgs_mru_vote: \n  assumes\n  \"\\<mu> (coord r) \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) (coord r)\" (is \"\\<mu> ?p \\<in> _\")\n  shows \"((msgs_to_lvs (\\<mu> ?p)) |` HOs r ?p) = (mru_vote o cfg) |` HOs r ?p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs_to_lvs (\\<mu> (coord r)) |` HOs r (coord r) =\n    (pstate.mru_vote \\<circ> cfg) |` HOs r (coord r)", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> (coord r) \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) (coord r)\n\ngoal (1 subgoal):\n 1. msgs_to_lvs (\\<mu> (coord r)) |` HOs r (coord r) =\n    (pstate.mru_vote \\<circ> cfg) |` HOs r (coord r)", "by(auto simp add: get_msgs_benign send0_def restrict_map_def msgs_to_lvs_def\n      mru_vote_to_msg_def map_comp_def intro!: ext split: option.split)"], ["", "lemma step0_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r C. majorities.opt_mru_step0 r C), \n    Paxos_trans_step HOs HOs crds next0 send0 0 {> paxos_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} \\<Union>r.\n                       \\<Union>\n                        (range\n                          (majorities.opt_mru_step0\n                            r)), Paxos_trans_step HOs HOs crds next0 send0\n                                  0 {> paxos_ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs Paxos_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> paxos_ref_rel\"\n    and r: \"three_step r = 0\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "from r"], ["proof (chain)\npicking this:\n  three_step r = 0", "have same_coord: \"coord (Suc r) = coord r\""], ["proof (prove)\nusing this:\n  three_step r = 0\n\ngoal (1 subgoal):\n 1. coord (Suc r) = coord r", "by(auto simp add: three_step_phase_Suc intro: coord_phase)"], ["proof (state)\nthis:\n  coord (Suc r) = coord r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define C where \"C = coord_vote_to_set (Suc r) sc'\""], ["proof (state)\nthis:\n  C = coord_vote_to_set (Suc r) sc'\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have guard: \"\\<forall>cand\\<in>C. \\<exists>Q. majorities.opt_mru_guard (mru_vote \\<circ> sc) Q cand\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cand\\<in>C.\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "fix cand"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "assume cand: \"cand \\<in> C\""], ["proof (state)\nthis:\n  cand \\<in> C\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "hence Some: \"commt (sc' (coord r)) = Some cand\""], ["proof (prove)\nusing this:\n  cand \\<in> C\n\ngoal (1 subgoal):\n 1. commt (sc' (coord r)) = Some cand", "using nxt[THEN spec, where x=\"coord r\"]"], ["proof (prove)\nusing this:\n  cand \\<in> C\n  next0 r (coord r) (sc (coord r)) (\\<mu> (coord r)) (crds r)\n   (sc' (coord r))\n\ngoal (1 subgoal):\n 1. commt (sc' (coord r)) = Some cand", "by(auto simp add: C_def coord_vote_to_set_def Let_def same_coord)"], ["proof (state)\nthis:\n  commt (sc' (coord r)) = Some cand\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "let ?Q = \"HOs r (coord r)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "let ?lvs0 = \"mru_vote o sc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "have \"?Q \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r (coord r) \\<in> majs", "using Some \\<mu>nxt[THEN spec, where x=\"coord r\"]"], ["proof (prove)\nusing this:\n  commt (sc' (coord r)) = Some cand\n  \\<mu> (coord r) \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) (coord r)\n  next0 r (coord r) (sc (coord r)) (\\<mu> (coord r)) (crds r)\n   (sc' (coord r))\n\ngoal (1 subgoal):\n 1. HOs r (coord r) \\<in> majs", "by(auto simp add: Let_def majs_def next0_def same_coord get_msgs_dom)"], ["proof (state)\nthis:\n  HOs r (coord r) \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "moreover"], ["proof (state)\nthis:\n  HOs r (coord r) \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "have\n      \"map_option snd (option_Max_by fst (ran (?lvs |` ?Q))) \\<in> {None, Some cand}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option snd\n     (option_Max_by fst\n       (ran ((pstate.mru_vote \\<circ> sc) |` HOs r (coord r))))\n    \\<in> {None, Some cand}", "using Some nxt[THEN spec, where x=\"coord r\"]\n      msgs_mru_vote[where HOs=HOs and \\<mu>=\\<mu>, OF \\<mu>[THEN spec, where x=\"coord r\"]] \n      get_msgs_dom[OF \\<mu>[THEN spec, of \"coord r\"]]"], ["proof (prove)\nusing this:\n  commt (sc' (coord r)) = Some cand\n  next0 r (coord r) (sc (coord r)) (\\<mu> (coord r)) (crds r)\n   (sc' (coord r))\n  msgs_to_lvs (\\<mu> (coord r)) |` HOs r (coord r) =\n  (pstate.mru_vote \\<circ> sc) |` HOs r (coord r)\n  dom (\\<mu> (coord r)) = HOs r (coord r)\n\ngoal (1 subgoal):\n 1. map_option snd\n     (option_Max_by fst\n       (ran ((pstate.mru_vote \\<circ> sc) |` HOs r (coord r))))\n    \\<in> {None, Some cand}", "by(auto simp add: next0_def Let_def split: option.split_asm)"], ["proof (state)\nthis:\n  map_option snd\n   (option_Max_by fst\n     (ran ((pstate.mru_vote \\<circ> sc) |` HOs r (coord r))))\n  \\<in> {None, Some cand}\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "ultimately"], ["proof (chain)\npicking this:\n  HOs r (coord r) \\<in> majs\n  map_option snd\n   (option_Max_by fst\n     (ran ((pstate.mru_vote \\<circ> sc) |` HOs r (coord r))))\n  \\<in> {None, Some cand}", "have \"majorities.opt_mru_guard ?lvs0 ?Q cand\""], ["proof (prove)\nusing this:\n  HOs r (coord r) \\<in> majs\n  map_option snd\n   (option_Max_by fst\n     (ran ((pstate.mru_vote \\<circ> sc) |` HOs r (coord r))))\n  \\<in> {None, Some cand}\n\ngoal (1 subgoal):\n 1. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r (coord r))\n     cand", "by(auto simp add: majorities.opt_mru_guard_def Let_def majorities.opt_mru_vote_def)"], ["proof (state)\nthis:\n  majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r (coord r))\n   cand\n\ngoal (1 subgoal):\n 1. \\<And>cand.\n       cand \\<in> C \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "thus \"\\<exists>Q. majorities.opt_mru_guard ?lvs0 Q cand\""], ["proof (prove)\nusing this:\n  majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r (coord r))\n   cand\n\ngoal (1 subgoal):\n 1. \\<exists>Q. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cand\\<in>C.\n     \\<exists>Q.\n        majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define sa' where \"sa' = sa\\<lparr>\n      next_round := Suc r,\n      candidates := C\n    \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\\<lparr>opt_mru_state.next_round := Suc r, candidates := C\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step0 r C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step0 r C", "using R r nxt guard"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = 0\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  \\<forall>cand\\<in>C.\n     \\<exists>Q.\n        majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step0 r C", "by(auto simp add: majorities.opt_mru_step0_def sa'_def paxos_ref_rel_def)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> paxos_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "using R nxt"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "apply(auto simp add: sa'_def paxos_ref_rel_def intro!:\n      mru_vote_evolution0[OF nxt, symmetric] decide_evolution(1)[OF nxt])"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        three_step (opt_mru_state.next_round sa) \\<noteq> Suc 0;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> coord_vote_to_set\n                                  (Suc (opt_mru_state.next_round sa)) sc'\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        three_step (opt_mru_state.next_round sa) \\<noteq> Suc 0;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> coord_vote_to_set (Suc (opt_mru_state.next_round sa))\n                 sc'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        candidates sa = coord_vote_to_set (opt_mru_state.next_round sa) sc;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> coord_vote_to_set\n                                  (Suc (opt_mru_state.next_round sa)) sc'\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        candidates sa = coord_vote_to_set (opt_mru_state.next_round sa) sc;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> coord_vote_to_set (Suc (opt_mru_state.next_round sa))\n                 sc'\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C", "apply(auto simp add: Let_def C_def o_def intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n  (sa', Suc r, sc') \\<in> paxos_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \n        \\<and> (sa', Suc r, sc') \\<in> paxos_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \\<and>\n       (sa', Suc r, sc') \\<in> paxos_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \\<and>\n     (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step1_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r S v. majorities.opt_mru_step1 r S v), \n    Paxos_trans_step HOs HOs crds next1 send1 (Suc 0) {> paxos_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} \\<Union>r S.\n                       \\<Union>\n                        (range\n                          (majorities.opt_mru_step1 r\n                            S)), Paxos_trans_step HOs HOs crds next1 send1\n                                  (Suc 0) {> paxos_ref_rel}", "proof(clarsimp  simp add: PO_rhoare_defs Paxos_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> paxos_ref_rel\"\n    and r: \"three_step r = Suc 0\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = Suc 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define v where \"v = the (commt (sc (coord r)))\""], ["proof (state)\nthis:\n  v = the (commt (sc (coord r)))\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define S where \"S = {p. coord r \\<in> HOs r p \\<and> commt (sc (coord r)) \\<noteq> None}\""], ["proof (state)\nthis:\n  S = {p. coord r \\<in> HOs r p \\<and> commt (sc (coord r)) \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define sa' where \"sa' = sa\\<lparr> next_round := Suc r, \n    opt_mru_state.mru_vote := opt_mru_state.mru_vote sa ++ const_map (three_phase r, v) S\n  \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_mru_state.next_round := Suc r,\n     opt_mru_state.mru_vote :=\n       opt_mru_state.mru_vote sa ++ const_map (three_phase r, v) S\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step1 r S v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step1 r S v", "using r R"], ["proof (prove)\nusing this:\n  three_step r = Suc 0\n  (sa, r, sc) \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step1 r S v", "by(clarsimp simp add: majorities.opt_mru_step1_def sa'_def  S_def v_def \n      coord_vote_to_set_def paxos_ref_rel_def)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> paxos_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "using r R"], ["proof (prove)\nusing this:\n  three_step r = Suc 0\n  (sa, r, sc) \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = Suc 0; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa', Suc r, sc') \\<in> paxos_ref_rel", "have \"mru_vote o sc' = ((mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.mru_vote \\<circ> sc' =\n    (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S", "proof(rule ext, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pstate.mru_vote (sc' x) =\n       ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pstate.mru_vote (sc' x) =\n       ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) x", "show \"mru_vote (sc' p) = ((mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.mru_vote (sc' p) =\n    ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p", "using \\<mu>nxt[THEN spec, of p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n  next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. pstate.mru_vote (sc' p) =\n    ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p", "by(auto simp add: get_msgs_benign next1_def send1_def S_def v_def map_add_def \n          const_map_is_None const_map_is_Some restrict_map_def isVote_def split: option.split)"], ["proof (state)\nthis:\n  pstate.mru_vote (sc' p) =\n  ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = Suc 0; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa', Suc r, sc') \\<in> paxos_ref_rel", "thus ?thesis"], ["proof (prove)\nusing this:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "using R r nxt"], ["proof (prove)\nusing this:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = Suc 0\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "by(force simp add: paxos_ref_rel_def sa'_def three_step_Suc intro: decide_evolution)"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n  (sa', Suc r, sc') \\<in> paxos_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>r S v. (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \n        \\<and> (sa', Suc r, sc') \\<in> paxos_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r S v.\n           (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \\<and>\n       (sa', Suc r, sc') \\<in> paxos_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r S v. (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \\<and>\n     (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step2_ref:\n  \"{paxos_ref_rel} \n    (\\<Union>r dec_f. majorities.opt_mru_step2 r dec_f), \n    Paxos_trans_step HOs HOs crds next2 send2 2 {> paxos_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} \\<Union>r.\n                       \\<Union>\n                        (range\n                          (majorities.opt_mru_step2\n                            r)), Paxos_trans_step HOs HOs crds next2 send2\n                                  2 {> paxos_ref_rel}", "proof(clarsimp  simp add: PO_rhoare_defs Paxos_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> paxos_ref_rel\"\n    and r: \"three_step r = 2\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = 2\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define dec_f\n    where \"dec_f p = (if decide (sc' p) \\<noteq> decide (sc p) then decide (sc' p) else None)\" for p"], ["proof (state)\nthis:\n  dec_f ?p =\n  (if decide (sc' ?p) \\<noteq> decide (sc ?p) then decide (sc' ?p)\n   else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have dec_f: \"(decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ((decide \\<circ> sc) ++ dec_f) x = (decide \\<circ> sc') x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ((decide \\<circ> sc) ++ dec_f) x = (decide \\<circ> sc') x", "show \"((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p", "using nxt[THEN spec, of p]"], ["proof (prove)\nusing this:\n  next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p", "by(auto simp add: map_add_def dec_f_def next2_def split: option.split intro!: ext)"], ["proof (state)\nthis:\n  ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "define sa' where \"sa' = sa\\<lparr>\n    next_round := Suc r,\n    decisions := decisions sa ++ dec_f\n  \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_mru_state.next_round := Suc r,\n     opt_mru_state.decisions := opt_mru_state.decisions sa ++ dec_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> paxos_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "using R r nxt"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = 2\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> paxos_ref_rel", "by(auto simp add: paxos_ref_rel_def sa'_def dec_f three_step_Suc \n      mru_vote_evolution2[OF nxt])"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "using r R"], ["proof (prove)\nusing this:\n  three_step r = 2\n  (sa, r, sc) \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "define sc_r_votes where \"sc_r_votes p = (if (\\<exists>v. mru_vote (sc p) = Some (three_phase r, v))\n        then map_option snd (mru_vote (sc p))\n        else None)\" for p"], ["proof (state)\nthis:\n  sc_r_votes ?p =\n  (if \\<exists>v. pstate.mru_vote (sc ?p) = Some (three_phase r, v)\n   then map_option snd (pstate.mru_vote (sc ?p)) else None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "have sc_r_votes: \"sc_r_votes = majorities.r_votes sa r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_r_votes = majorities.r_votes sa r", "using R r"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> paxos_ref_rel\n  three_step r = 2\n\ngoal (1 subgoal):\n 1. sc_r_votes = majorities.r_votes sa r", "by(auto simp add: paxos_ref_rel_def sc_r_votes_def majorities.r_votes_def intro!: ext)"], ["proof (state)\nthis:\n  sc_r_votes = majorities.r_votes sa r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "have \"majorities.step2_d_guard dec_f sc_r_votes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. majorities.step2_d_guard dec_f sc_r_votes", "proof(clarsimp simp add: majorities.step2_d_guard_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "assume d_f_p: \"dec_f p = Some v\""], ["proof (state)\nthis:\n  dec_f p = Some v\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "let ?Qv = \"votes_rcvd (\\<mu> p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "have Qv: \"card ?Qv > N div 2\" \n        \"v = the_rcvd_vote (\\<mu> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N div 2 < card (votes_rcvd (\\<mu> p)) &&& v = the_rcvd_vote (\\<mu> p)", "using nxt[THEN spec, of p] d_f_p"], ["proof (prove)\nusing this:\n  next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  dec_f p = Some v\n\ngoal (1 subgoal):\n 1. N div 2 < card (votes_rcvd (\\<mu> p)) &&& v = the_rcvd_vote (\\<mu> p)", "by(auto simp add: next2_def dec_f_def)"], ["proof (state)\nthis:\n  N div 2 < card (votes_rcvd (\\<mu> p))\n  v = the_rcvd_vote (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "hence \"v \\<in> snd ` votes_rcvd (\\<mu> p)\""], ["proof (prove)\nusing this:\n  N div 2 < card (votes_rcvd (\\<mu> p))\n  v = the_rcvd_vote (\\<mu> p)\n\ngoal (1 subgoal):\n 1. v \\<in> snd ` votes_rcvd (\\<mu> p)", "by(fastforce simp add: the_rcvd_vote_def ex_in_conv[symmetric]\n          dest!: card_gt_0_iff[THEN iffD1, OF le_less_trans[OF le0]] elim!: imageI intro: someI)"], ["proof (state)\nthis:\n  v \\<in> snd ` votes_rcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "moreover"], ["proof (state)\nthis:\n  v \\<in> snd ` votes_rcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "have \"?Qv = map_graph (sc_r_votes) \\<inter> (HOs r p \\<times> UNIV)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. votes_rcvd (\\<mu> p) =\n    map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV", "using \\<mu>[THEN spec, of p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. votes_rcvd (\\<mu> p) =\n    map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV", "by(auto simp add: get_msgs_benign send2_def restrict_map_def votes_rcvd_def\n          sc_r_votes_def image_def split: option.split_asm)"], ["proof (state)\nthis:\n  votes_rcvd (\\<mu> p) = map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> snd ` votes_rcvd (\\<mu> p)\n  votes_rcvd (\\<mu> p) = map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV", "show \"v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs\""], ["proof (prove)\nusing this:\n  v \\<in> snd ` votes_rcvd (\\<mu> p)\n  votes_rcvd (\\<mu> p) = map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV\n\ngoal (1 subgoal):\n 1. v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "using Qv(1)"], ["proof (prove)\nusing this:\n  v \\<in> snd ` votes_rcvd (\\<mu> p)\n  votes_rcvd (\\<mu> p) = map_graph sc_r_votes \\<inter> HOs r p \\<times> UNIV\n  N div 2 < card (votes_rcvd (\\<mu> p))\n\ngoal (1 subgoal):\n 1. v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "by(auto simp add: majs_def inj_on_def map_graph_def fun_graph_def sc_r_votes_def\n          the_rcvd_vote_def majs_def intro: ranI\n          elim!: less_le_trans intro!: card_inj_on_le[where f=fst])"], ["proof (state)\nthis:\n  v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  majorities.step2_d_guard dec_f sc_r_votes\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> paxos_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "thus ?thesis"], ["proof (prove)\nusing this:\n  majorities.step2_d_guard dec_f sc_r_votes\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "using r R"], ["proof (prove)\nusing this:\n  majorities.step2_d_guard dec_f sc_r_votes\n  three_step r = 2\n  (sa, r, sc) \\<in> paxos_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "by(auto simp add: majorities.opt_mru_step2_def sa'_def paxos_ref_rel_def sc_r_votes)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> paxos_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> paxos_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "show \n    \"\\<exists>sa'. (\\<exists>r dec_f. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \n        \\<and> (sa', Suc r, sc') \\<in> paxos_ref_rel\""], ["proof (prove)\nusing this:\n  (sa', Suc r, sc') \\<in> paxos_ref_rel\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r dec_f.\n           (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \\<and>\n       (sa', Suc r, sc') \\<in> paxos_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r dec_f.\n         (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \\<and>\n     (sa', Suc r, sc') \\<in> paxos_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Paxos_Refines_ThreeStep_MRU:\n  \"PO_refines paxos_ref_rel \n    majorities.ts_mru_TS (Paxos_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines paxos_ref_rel majorities.ts_mru_TS (Paxos_TS HOs HOs crds)", "proof(rule refine_basic)"], ["proof (state)\ngoal (2 subgoals):\n 1. init (Paxos_TS HOs HOs crds)\n    \\<subseteq> paxos_ref_rel `` init majorities.ts_mru_TS\n 2. {paxos_ref_rel} TS.trans\n                     majorities.ts_mru_TS, TS.trans\n      (Paxos_TS HOs HOs crds) {> paxos_ref_rel}", "show \"init (Paxos_TS HOs HOs crds) \\<subseteq> paxos_ref_rel `` init majorities.ts_mru_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (Paxos_TS HOs HOs crds)\n    \\<subseteq> paxos_ref_rel `` init majorities.ts_mru_TS", "by(auto simp add: Paxos_TS_defs majorities.ts_mru_TS_def paxos_ref_rel_def \n      majorities.ts_mru_init_def)"], ["proof (state)\nthis:\n  init (Paxos_TS HOs HOs crds)\n  \\<subseteq> paxos_ref_rel `` init majorities.ts_mru_TS\n\ngoal (1 subgoal):\n 1. {paxos_ref_rel} TS.trans\n                     majorities.ts_mru_TS, TS.trans\n      (Paxos_TS HOs HOs crds) {> paxos_ref_rel}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} TS.trans\n                     majorities.ts_mru_TS, TS.trans\n      (Paxos_TS HOs HOs crds) {> paxos_ref_rel}", "show \n    \"{paxos_ref_rel} TS.trans majorities.ts_mru_TS, \n      TS.trans (Paxos_TS HOs HOs crds) {> paxos_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} TS.trans\n                     majorities.ts_mru_TS, TS.trans\n      (Paxos_TS HOs HOs crds) {> paxos_ref_rel}", "apply(simp add: majorities.ts_mru_TS_defs Paxos_TS_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {paxos_ref_rel} ((\\<Union>x.\n                         \\<Union>\n                          (range (majorities.opt_mru_step0 x))) \\<union>\n                     (\\<Union>x xa.\n                         \\<Union>\n                          (range (majorities.opt_mru_step1 x xa))) \\<union>\n                     (\\<Union>x.\n                         \\<Union>\n                          (range\n                            (majorities.opt_mru_step2\n                              x))))\\<^sup>=, CHO_trans\n        \\<lparr>CinitState = Paxos_initState, sendMsg = Paxos_sendMsg,\n           CnextState = Paxos_nextState\\<rparr>\n        HOs HOs (K \\<circ> crds) {> paxos_ref_rel}", "apply(auto simp add: CHO_trans_alt Paxos_trans intro!: step0_ref step1_ref step2_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {paxos_ref_rel} TS.trans\n                   majorities.ts_mru_TS, TS.trans\n    (Paxos_TS HOs HOs crds) {> paxos_ref_rel}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "theorem Paxos_termination:\n  assumes run: \"CHORun Paxos_Alg rho HOs crds\"\n      and commR: \"\\<forall>r. CHOcommPerRd Paxos_M r (HOs r) (crds r)\"\n      and commG: \"CHOcommGlobal Paxos_M HOs crds\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commG"], ["proof (chain)\npicking this:\n  CHOcommGlobal Paxos_M HOs crds", "obtain ph c where \n    HOs:\n       \"coord (nr_steps*ph) = c\n         \\<and> card (HOs (nr_steps*ph) c) > N div 2\n         \\<and> (\\<forall>p. c \\<in> HOs (nr_steps*ph+1) p)\n         \\<and> (\\<forall>p. card (HOs (nr_steps*ph+2) p) > N div 2)\""], ["proof (prove)\nusing this:\n  CHOcommGlobal Paxos_M HOs crds\n\ngoal (1 subgoal):\n 1. (\\<And>ph c.\n        coord (3 * ph) = c \\<and>\n        N div 2 < card (HOs (3 * ph) c) \\<and>\n        (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n        (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: Paxos_CHOMachine_def Paxos_commGlobal_def)\n\n  \\<comment> \\<open>The tedious bit: obtain three consecutive rounds linked by send/next functions\\<close>"], ["proof (state)\nthis:\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r0 where \"r0 = nr_steps * ph\""], ["proof (state)\nthis:\n  r0 = 3 * ph\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg0 where \"cfg0 = rho r0\""], ["proof (state)\nthis:\n  cfg0 = rho r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r1 where \"r1 = Suc r0\""], ["proof (state)\nthis:\n  r1 = Suc r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg1 where \"cfg1 = rho r1\""], ["proof (state)\nthis:\n  cfg1 = rho r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r2 where \"r2 = Suc r1\""], ["proof (state)\nthis:\n  r2 = Suc r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg2 where \"cfg2 = rho r2\""], ["proof (state)\nthis:\n  cfg2 = rho r2\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg3 where \"cfg3 = rho (Suc r2)\""], ["proof (state)\nthis:\n  cfg3 = rho (Suc r2)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from   \n    run[simplified CHORun_def, THEN CSHORun_step, THEN spec, where x=\"r0\"] \n    run[simplified CHORun_def, THEN CSHORun_step, THEN spec, where x=\"r1\"]\n    run[simplified CHORun_def, THEN CSHORun_step, THEN spec, where x=\"r2\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState Paxos_Alg r0 p (rho r0 p) (\\<mu> p) (crds (Suc r0) p)\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState Paxos_Alg r1 p (rho r1 p) (\\<mu> p) (crds (Suc r1) p)\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState Paxos_Alg r2 p (rho r2 p) (\\<mu> p) (crds (Suc r2) p)\n         (rho (Suc r2) p)", "obtain \\<mu>0 \\<mu>1 \\<mu>2 where\n    send0: \"\\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\"\n    and three_step0: \"\\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) (crds (Suc r0) p) (cfg1 p)\"\n    and send1: \"\\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\"\n    and three_step1: \"\\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (crds (Suc r1) p) (cfg2 p)\"\n    and send2: \"\\<forall>p. \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\"\n    and three_step2: \"\\<forall>p. next2 r2 p (cfg2 p) (\\<mu>2 p) (crds (Suc r2) p) (cfg3 p)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState Paxos_Alg r0 p (rho r0 p) (\\<mu> p) (crds (Suc r0) p)\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState Paxos_Alg r1 p (rho r1 p) (\\<mu> p) (crds (Suc r1) p)\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg Paxos_Alg r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState Paxos_Alg r2 p (rho r2 p) (\\<mu> p) (crds (Suc r2) p)\n         (rho (Suc r2) p)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>0 \\<mu>1 \\<mu>2.\n        \\<lbrakk>\\<forall>p.\n                    \\<mu>0 p\n                    \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p;\n         \\<forall>p.\n            next0 r0 p (cfg0 p) (\\<mu>0 p) (crds (Suc r0) p) (cfg1 p);\n         \\<forall>p.\n            \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p;\n         \\<forall>p.\n            next1 r1 p (cfg1 p) (\\<mu>1 p) (crds (Suc r1) p) (cfg2 p);\n         \\<forall>p.\n            \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p;\n         \\<forall>p.\n            next2 r2 p (cfg2 p) (\\<mu>2 p) (crds (Suc r2) p)\n             (cfg3 p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp add: Paxos_Alg_def three_step_def Paxos_nextState_def Paxos_sendMsg_def all_conj_distrib\n      r0_def r1_def r2_def\n      cfg0_def cfg1_def cfg2_def cfg3_def mod_Suc\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n    \n  \\<comment> \\<open>The proof: the coordinator hears enough messages in r0 and thus selects a value.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\n  \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) (crds (Suc r0) p) (cfg1 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (crds (Suc r1) p) (cfg2 p)\n  \\<forall>p. \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\n  \\<forall>p. next2 r2 p (cfg2 p) (\\<mu>2 p) (crds (Suc r2) p) (cfg3 p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from HOs three_step0[THEN spec, of c] send0[THEN spec, of c]"], ["proof (chain)\npicking this:\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))\n  next0 r0 c (cfg0 c) (\\<mu>0 c) (crds (Suc r0) c) (cfg1 c)\n  \\<mu>0 c \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) c", "have \n    \"commt (cfg1 c) \\<noteq> None\""], ["proof (prove)\nusing this:\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))\n  next0 r0 c (cfg0 c) (\\<mu>0 c) (crds (Suc r0) c) (cfg1 c)\n  \\<mu>0 c \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) c\n\ngoal (1 subgoal):\n 1. commt (cfg1 c) \\<noteq> None", "by(auto simp add: next0_def Let_def r0_def get_msgs_dom)"], ["proof (state)\nthis:\n  commt (cfg1 c) \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "then"], ["proof (chain)\npicking this:\n  commt (cfg1 c) \\<noteq> None", "obtain dec_v where dec_v: \"commt (cfg1 c) = Some dec_v\""], ["proof (prove)\nusing this:\n  commt (cfg1 c) \\<noteq> None\n\ngoal (1 subgoal):\n 1. (\\<And>dec_v.\n        commt (cfg1 c) = Some dec_v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis option.collapse)"], ["proof (state)\nthis:\n  commt (cfg1 c) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have step_r0: \"three_step r0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. three_step r0 = 0", "by(auto simp add: r0_def three_step_def)"], ["proof (state)\nthis:\n  three_step r0 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence same_coord: \n    \"coord r1 = coord r0\"\n    \"coord r2 = coord r0\""], ["proof (prove)\nusing this:\n  three_step r0 = 0\n\ngoal (1 subgoal):\n 1. coord r1 = coord r0 &&& coord r2 = coord r0", "by(auto simp add: three_step_phase_Suc r2_def r1_def r0_def intro!: coord_phase)\n\n  \\<comment> \\<open>All processes hear from the coordinator, and thus set their vote to @{term dec_v}.\\<close>"], ["proof (state)\nthis:\n  coord r1 = coord r0\n  coord r2 = coord r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence all_vote: \"\\<forall>p. mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\""], ["proof (prove)\nusing this:\n  coord r1 = coord r0\n  coord r2 = coord r0\n\ngoal (1 subgoal):\n 1. \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "using HOs three_step1 send1 step_r0 dec_v"], ["proof (prove)\nusing this:\n  coord r1 = coord r0\n  coord r2 = coord r0\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (crds (Suc r1) p) (cfg2 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n  three_step r0 = 0\n  commt (cfg1 c) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "by(auto simp add: next1_def Let_def get_msgs_benign send1_def restrict_map_def isVote_def\n      r2_def r1_def r0_def[symmetric] same_coord[simplified r2_def r1_def] three_step_phase_Suc)\n\n  \\<comment> \\<open>And finally, everybody will also decide @{term dec_v}.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have all_decide: \"\\<forall>p. decide (cfg3 p) = Some dec_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. decide (cfg3 p) = Some dec_v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "have \"votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}", "using send2[THEN spec, where x=p] all_vote"], ["proof (prove)\nusing this:\n  \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\n  \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\n\ngoal (1 subgoal):\n 1. votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}", "by(auto simp add: send2_def get_msgs_benign votes_rcvd_def restrict_map_def image_def o_def)"], ["proof (state)\nthis:\n  votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "moreover"], ["proof (state)\nthis:\n  votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "from HOs"], ["proof (chain)\npicking this:\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))", "have \"N div 2 < card (HOs r2 p)\""], ["proof (prove)\nusing this:\n  coord (3 * ph) = c \\<and>\n  N div 2 < card (HOs (3 * ph) c) \\<and>\n  (\\<forall>p. c \\<in> HOs (3 * ph + 1) p) \\<and>\n  (\\<forall>p. N div 2 < card (HOs (3 * ph + 2) p))\n\ngoal (1 subgoal):\n 1. N div 2 < card (HOs r2 p)", "by(auto simp add: r2_def r1_def r0_def)"], ["proof (state)\nthis:\n  N div 2 < card (HOs r2 p)\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "moreover"], ["proof (state)\nthis:\n  N div 2 < card (HOs r2 p)\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "then"], ["proof (chain)\npicking this:\n  N div 2 < card (HOs r2 p)", "have \"HOs r2 p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  N div 2 < card (HOs r2 p)\n\ngoal (1 subgoal):\n 1. HOs r2 p \\<noteq> {}", "by (metis card.empty less_nat_zero_code)"], ["proof (state)\nthis:\n  HOs r2 p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "ultimately"], ["proof (chain)\npicking this:\n  votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\n  N div 2 < card (HOs r2 p)\n  HOs r2 p \\<noteq> {}", "show \"decide (cfg3 p) = Some dec_v\""], ["proof (prove)\nusing this:\n  votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\n  N div 2 < card (HOs r2 p)\n  HOs r2 p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. decide (cfg3 p) = Some dec_v", "using three_step2[THEN spec, where x=p] send2[THEN spec, where x=p] all_vote"], ["proof (prove)\nusing this:\n  votes_rcvd (\\<mu>2 p) = HOs r2 p \\<times> {dec_v}\n  N div 2 < card (HOs r2 p)\n  HOs r2 p \\<noteq> {}\n  next2 r2 p (cfg2 p) (\\<mu>2 p) (crds (Suc r2) p) (cfg3 p)\n  \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\n  \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\n\ngoal (1 subgoal):\n 1. decide (cfg3 p) = Some dec_v", "by(auto simp add: next2_def send2_def Let_def get_msgs_benign \n        the_rcvd_vote_def restrict_map_def image_def o_def)"], ["proof (state)\nthis:\n  decide (cfg3 p) = Some dec_v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. decide (cfg3 p) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p. decide (cfg3 p) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by(auto simp add: cfg3_def)"], ["proof (state)\nthis:\n  \\<exists>r v. decide (rho r p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}