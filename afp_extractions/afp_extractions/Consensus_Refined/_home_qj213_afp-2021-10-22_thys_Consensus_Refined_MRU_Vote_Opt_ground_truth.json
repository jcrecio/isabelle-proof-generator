{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/MRU_Vote_Opt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas lv_evt_defs = opt_mru_round_def opt_mru_guard_def", "lemmas mru_opt_TS_defs = mru_opt_TS_def opt_mru_init_def mru_opt_trans_def", "lemma vote_set_as_Union:\n  \"vote_set vs Q = (\\<Union>a\\<in>(Q \\<inter> voters vs). vote_set vs {a})\"", "lemma empty_ran:\n  \"(ran f = {}) = (\\<forall>x. f x = None)\"", "lemma empty_ran_restrict:\n  \"(ran (f |` A) = {}) = (\\<forall>x \\<in> A. f x = None)\"", "lemma option_Max_by_eqI:\n  \"\\<lbrakk> (S = {}) \\<longleftrightarrow> (S' = {}); S \\<noteq> {} \\<and> S' \\<noteq> {} \\<Longrightarrow> Max_by f S = Max_by g S' \\<rbrakk> \n  \\<Longrightarrow>  option_Max_by f S = option_Max_by g S'\"", "lemma ran_process_mru_only_voters:\n  \"ran (process_mru vs |` Q) = ran (process_mru vs |` (Q \\<inter> voters vs))\"", "lemma SV_inv3_inj_on_fst_vote_set:\n  \"s \\<in> SV_inv3 \\<Longrightarrow> inj_on fst (vote_set (votes s) Q)\"", "lemma opt_mru_vote_mru_of_set:\n  assumes\n    inv1: \"s \\<in> Vinv1\"\n    and inv3: \"s \\<in> SV_inv3\"\n  defines \"vs \\<equiv> votes s\"\n  shows\n    \"opt_mru_vote (process_mru vs) Q = mru_of_set vs Q\"", "lemma opt_mru_guard_imp_mru_guard:\n  assumes invs:\n    \"s \\<in> Vinv1\" \"s \\<in> SV_inv3\"\n    and c_guard: \"opt_mru_guard (process_mru (votes s)) Q v\"\n  shows \"mru_guard s Q v\"", "lemma act_ref:\n  assumes\n    \"s \\<in> Vinv1\"\n  shows \n    \"process_mru (votes s) ++ const_map (v_state.next_round s, v) S \n    = process_mru ((votes s)(v_state.next_round s := const_map v S))\"", "lemma opt_mru_guard_imp_Quorum:\n  \"opt_mru_guard vs Q v \\<Longrightarrow> Q \\<in> Quorum\"", "lemma opt_mru_round_refines:\n  \"{lv_ref_rel \\<inter> (Vinv1 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times> UNIV} \n    sv_round r S v d_f, opt_mru_round r Q S v d_f \n  {> lv_ref_rel}\"", "lemma Opt_MRU_Vote_Refines:\n  \"PO_refines (lv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times> UNIV) sv_TS mru_opt_TS\"", "lemma OMRU_inv1_inductive:\n  \"init mru_opt_TS \\<subseteq> OMRU_inv1\"\n  \"{OMRU_inv1} trans mru_opt_TS {> OMRU_inv1}\"", "lemmas OMRU_inv1I = OMRU_inv1_def [THEN setc_def_to_intro, rule_format]", "lemmas OMRU_inv1E [elim] = OMRU_inv1_def [THEN setc_def_to_elim, rule_format]", "lemmas OMRU_inv1D = OMRU_inv1_def [THEN setc_def_to_dest, rule_format]"], "translations": [["", "lemmas lv_evt_defs = opt_mru_round_def opt_mru_guard_def"], ["", "definition mru_opt_trans :: \"(opt_mru_state \\<times> opt_mru_state) set\" where\n  \"mru_opt_trans = (\\<Union>r Q S v D. opt_mru_round r Q S v D) \\<union> Id\""], ["", "definition mru_opt_TS :: \"opt_mru_state TS\" where\n  \"mru_opt_TS = \\<lparr> init = opt_mru_init, trans = mru_opt_trans \\<rparr>\""], ["", "lemmas mru_opt_TS_defs = mru_opt_TS_def opt_mru_init_def mru_opt_trans_def"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition lv_ref_rel :: \"(v_state \\<times> opt_mru_state)set\" where\n  \"lv_ref_rel = {(sa, sc).\n    sc = \\<lparr>\n      next_round = v_state.next_round sa\n      , mru_vote = process_mru (votes sa)\n      , decisions = v_state.decisions sa\n    \\<rparr>\n  }\""], ["", "subsubsection \\<open>The concrete guard implies the abstract guard\\<close>"], ["", "(******************************************************************************)"], ["", "definition voters :: \"(round \\<Rightarrow> (process, val)map) \\<Rightarrow> process set\" where\n  \"voters vs = {a|a r v. ((r, a), v) \\<in> map_graph (case_prod vs)}\""], ["", "lemma vote_set_as_Union:\n  \"vote_set vs Q = (\\<Union>a\\<in>(Q \\<inter> voters vs). vote_set vs {a})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vote_set vs Q = (\\<Union>a\\<in>Q \\<inter> voters vs. vote_set vs {a})", "by(auto simp add: vote_set_def voters_def)"], ["", "lemma empty_ran:\n  \"(ran f = {}) = (\\<forall>x. f x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ran f = {}) = (\\<forall>x. f x = None)", "apply(auto simp add: ran_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<forall>x a. f a \\<noteq> Some x \\<Longrightarrow> f x = None", "by (metis option.collapse)"], ["", "lemma empty_ran_restrict:\n  \"(ran (f |` A) = {}) = (\\<forall>x \\<in> A. f x = None)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ran (f |` A) = {}) = (\\<forall>x\\<in>A. f x = None)", "by(auto simp add: empty_ran restrict_map_def)"], ["", "lemma option_Max_by_eqI:\n  \"\\<lbrakk> (S = {}) \\<longleftrightarrow> (S' = {}); S \\<noteq> {} \\<and> S' \\<noteq> {} \\<Longrightarrow> Max_by f S = Max_by g S' \\<rbrakk> \n  \\<Longrightarrow>  option_Max_by f S = option_Max_by g S'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(S = {}) = (S' = {});\n     S \\<noteq> {} \\<and> S' \\<noteq> {} \\<Longrightarrow>\n     Max_by f S = Max_by g S'\\<rbrakk>\n    \\<Longrightarrow> option_Max_by f S = option_Max_by g S'", "by(auto simp add: option_Max_by_def)"], ["", "lemma ran_process_mru_only_voters:\n  \"ran (process_mru vs |` Q) = ran (process_mru vs |` (Q \\<inter> voters vs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (process_mru vs |` Q) =\n    ran (process_mru vs |` (Q \\<inter> voters vs))", "by(auto simp add: ran_def restrict_map_def voters_def process_mru_def \n    mru_of_set_def option_Max_by_def vote_set_def)"], ["", "lemma SV_inv3_inj_on_fst_vote_set:\n  \"s \\<in> SV_inv3 \\<Longrightarrow> inj_on fst (vote_set (votes s) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> SV_inv3 \\<Longrightarrow> inj_on fst (vote_set (votes s) Q)", "by(clarsimp simp add: SV_inv3_def inj_on_def vote_set_def)"], ["", "lemma opt_mru_vote_mru_of_set:\n  assumes\n    inv1: \"s \\<in> Vinv1\"\n    and inv3: \"s \\<in> SV_inv3\"\n  defines \"vs \\<equiv> votes s\"\n  shows\n    \"opt_mru_vote (process_mru vs) Q = mru_of_set vs Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_mru_vote (process_mru vs) Q = mru_of_set vs Q", "proof(simp add: opt_mru_vote_def mru_of_set_def, intro option_Max_by_eqI, clarsimp_all)"], ["proof (state)\ngoal (2 subgoals):\n 1. (ran (process_mru vs |` Q) = {}) = (vote_set vs Q = {})\n 2. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "show \"(ran (process_mru vs |` Q) = {}) = (vote_set vs Q = {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ran (process_mru vs |` Q) = {}) = (vote_set vs Q = {})", "apply(clarsimp simp add: empty_ran_restrict process_mru_def mru_of_set_def option_Max_by_def \n      vote_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>Q. \\<forall>a. vs a x = None) =\n    (\\<forall>a b aa. vs a aa = Some b \\<longrightarrow> aa \\<notin> Q)", "by (metis option.collapse option.distinct(1))"], ["proof (state)\nthis:\n  (ran (process_mru vs |` Q) = {}) = (vote_set vs Q = {})\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "assume nempty: \"ran (process_mru vs |` Q) \\<noteq> {}\" \"vote_set vs Q \\<noteq> {}\""], ["proof (state)\nthis:\n  ran (process_mru vs |` Q) \\<noteq> {}\n  vote_set vs Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "hence nempty': \"Q \\<inter> voters vs \\<noteq> {}\""], ["proof (prove)\nusing this:\n  ran (process_mru vs |` Q) \\<noteq> {}\n  vote_set vs Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Q \\<inter> voters vs \\<noteq> {}", "by(auto simp add: vote_set_def voters_def)"], ["proof (state)\nthis:\n  Q \\<inter> voters vs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "have nempty'': \"{} \\<notin> (\\<lambda>a. vote_set vs {a}) ` (Q \\<inter> voters vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {} \\<notin> (\\<lambda>a. vote_set vs {a}) ` (Q \\<inter> voters vs)", "by(auto simp add: vote_set_def voters_def)"], ["proof (state)\nthis:\n  {} \\<notin> (\\<lambda>a. vote_set vs {a}) ` (Q \\<inter> voters vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "note fin=Vinv1_finite_vote_set[OF inv1]"], ["proof (state)\nthis:\n  finite (vote_set (votes s) ?Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "have ran_eq: \n    \"ran (process_mru vs |` Q) = Max_by fst ` (\\<lambda>a. \\<Union>a\\<in>{a} \\<inter> voters vs. vote_set vs {a}) ` (Q \\<inter> voters vs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (process_mru vs |` Q) =\n    Max_by fst `\n    (\\<lambda>a. \\<Union>a\\<in>{a} \\<inter> voters vs. vote_set vs {a}) `\n    (Q \\<inter> voters vs)", "apply(subst ran_process_mru_only_voters)"], ["proof (prove)\ngoal (1 subgoal):\n 1. ran (process_mru vs |` (Q \\<inter> voters vs)) =\n    Max_by fst `\n    (\\<lambda>a. \\<Union>a\\<in>{a} \\<inter> voters vs. vote_set vs {a}) `\n    (Q \\<inter> voters vs)", "apply(auto simp add: image_def process_mru_def ran_def restrict_map_def mru_of_set_def option_Max_by_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b xa.\n       \\<lbrakk>(a, b) = Max_by fst (vote_set vs {xa}); xa \\<in> Q;\n        xa \\<in> voters vs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a.\n                            (vote_set vs {a} = {} \\<longrightarrow>\n                             (a \\<in> Q \\<longrightarrow>\n                              a \\<notin> voters vs) \\<and>\n                             a \\<in> Q \\<and> a \\<in> voters vs) \\<and>\n                            (vote_set vs {a} \\<noteq> {} \\<longrightarrow>\n                             (a \\<in> Q \\<and>\n                              a \\<in> voters vs \\<longrightarrow>\n                              Max_by fst (vote_set vs {a}) =\n                              Max_by fst (vote_set vs {xa})) \\<and>\n                             a \\<in> Q \\<and> a \\<in> voters vs)", "by (metis (erased, lifting) Set.set_insert image_eqI insertI1 insert_inter_insert nempty'')"], ["proof (state)\nthis:\n  ran (process_mru vs |` Q) =\n  Max_by fst `\n  (\\<lambda>a. \\<Union>a\\<in>{a} \\<inter> voters vs. vote_set vs {a}) `\n  (Q \\<inter> voters vs)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "note inj=inv3[THEN SV_inv3_inj_on_fst_vote_set]"], ["proof (state)\nthis:\n  inj_on fst (vote_set (votes s) ?Q)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (process_mru vs |` Q) \\<noteq> {};\n     vote_set vs Q \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> Max_by fst (ran (process_mru vs |` Q)) =\n                      Max_by fst (vote_set vs Q)", "show \"Max_by fst (ran (process_mru vs |` Q)) = Max_by fst (vote_set vs Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_by fst (ran (process_mru vs |` Q)) = Max_by fst (vote_set vs Q)", "apply(subst vs_def \n      Max_by_UNION_distrib[OF fin vote_set_as_Union nempty'[simplified vs_def] \n        nempty''[simplified vs_def] inj])+"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_by fst (ran (process_mru (votes s) |` Q)) =\n    Max_by fst\n     (Max_by fst `\n      (\\<lambda>a. vote_set (votes s) {a}) ` (Q \\<inter> voters (votes s)))", "apply(subst vote_set_as_Union)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Max_by fst (ran (process_mru (votes s) |` Q)) =\n    Max_by fst\n     (Max_by fst `\n      (\\<lambda>a.\n          \\<Union>a\\<in>{a} \\<inter> voters (votes s).\n             vote_set (votes s) {a}) `\n      (Q \\<inter> voters (votes s)))", "by(metis ran_eq vs_def)"], ["proof (state)\nthis:\n  Max_by fst (ran (process_mru vs |` Q)) = Max_by fst (vote_set vs Q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma opt_mru_guard_imp_mru_guard:\n  assumes invs:\n    \"s \\<in> Vinv1\" \"s \\<in> SV_inv3\"\n    and c_guard: \"opt_mru_guard (process_mru (votes s)) Q v\"\n  shows \"mru_guard s Q v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mru_guard s Q v", "using c_guard"], ["proof (prove)\nusing this:\n  opt_mru_guard (process_mru (votes s)) Q v\n\ngoal (1 subgoal):\n 1. mru_guard s Q v", "by(simp add: opt_mru_vote_mru_of_set[OF invs] opt_mru_guard_def mru_guard_def Let_def)"], ["", "subsubsection \\<open>The concrete action refines the abstract action\\<close>"], ["", "(******************************************************************************)"], ["", "lemma act_ref:\n  assumes\n    \"s \\<in> Vinv1\"\n  shows \n    \"process_mru (votes s) ++ const_map (v_state.next_round s, v) S \n    = process_mru ((votes s)(v_state.next_round s := const_map v S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_mru (votes s) ++ const_map (v_state.next_round s, v) S =\n    process_mru ((votes s)(v_state.next_round s := const_map v S))", "by(auto simp add: process_mru_map_add[OF assms(1)] map_add_def const_map_def \n      restrict_map_def\n      split:option.split)"], ["", "subsubsection \\<open>The complete refinement\\<close>"], ["", "(******************************************************************************)"], ["", "lemma opt_mru_guard_imp_Quorum:\n  \"opt_mru_guard vs Q v \\<Longrightarrow> Q \\<in> Quorum\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_mru_guard vs Q v \\<Longrightarrow> Q \\<in> Quorum", "by (simp add: opt_mru_guard_def Let_def)"], ["", "lemma opt_mru_round_refines:\n  \"{lv_ref_rel \\<inter> (Vinv1 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times> UNIV} \n    sv_round r S v d_f, opt_mru_round r Q S v d_f \n  {> lv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {lv_ref_rel \\<inter>\n     (Vinv1 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n     UNIV} sv_round r S v d_f, opt_mru_round r Q S v d_f {> lv_ref_rel}", "apply(clarsimp simp add: PO_rhoare_defs lv_ref_rel_def opt_mru_round_def sv_round_def \n    act_ref del: disjCI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>a \\<in> Vinv1; a \\<in> SV_inv3; a \\<in> SV_inv4;\n        r = v_state.next_round a; d_guard d_f (const_map v S);\n        S \\<noteq> {}; opt_mru_guard (process_mru (votes a)) Q v\\<rbrakk>\n       \\<Longrightarrow> safe a (v_state.next_round a) v", "apply(auto intro!: opt_mru_guard_imp_mru_guard[where Q=Q]  mru_vote_implies_safe[where Q=Q]\n    dest: opt_mru_guard_imp_Quorum)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Opt_MRU_Vote_Refines:\n  \"PO_refines (lv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times> UNIV) sv_TS mru_opt_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines\n     (lv_ref_rel \\<inter>\n      (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n      UNIV)\n     sv_TS mru_opt_TS", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {lv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n     UNIV} TS.trans sv_TS, TS.trans mru_opt_TS {> lv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 4. init mru_opt_TS \\<subseteq> lv_ref_rel `` init sv_TS\n 5. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 6. init mru_opt_TS \\<subseteq> UNIV", "show \"init mru_opt_TS \\<subseteq> lv_ref_rel `` init sv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init mru_opt_TS \\<subseteq> lv_ref_rel `` init sv_TS", "by(auto simp add: mru_opt_TS_defs sv_TS_defs lv_ref_rel_def\n      process_mru_def mru_of_set_def vote_set_def option_Max_by_def)"], ["proof (state)\nthis:\n  init mru_opt_TS \\<subseteq> lv_ref_rel `` init sv_TS\n\ngoal (5 subgoals):\n 1. {lv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n     UNIV} TS.trans sv_TS, TS.trans mru_opt_TS {> lv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 4. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 5. init mru_opt_TS \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {lv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n     UNIV} TS.trans sv_TS, TS.trans mru_opt_TS {> lv_ref_rel}\n 2. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}\n 3. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 4. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 5. init mru_opt_TS \\<subseteq> UNIV", "show \n    \"{lv_ref_rel \\<inter> (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times> UNIV} trans sv_TS, trans mru_opt_TS {> lv_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {lv_ref_rel \\<inter>\n     (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n     UNIV} TS.trans sv_TS, TS.trans mru_opt_TS {> lv_ref_rel}", "by(auto simp add: sv_TS_defs mru_opt_TS_defs intro!: opt_mru_round_refines)"], ["proof (state)\nthis:\n  {lv_ref_rel \\<inter>\n   (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n   UNIV} TS.trans sv_TS, TS.trans mru_opt_TS {> lv_ref_rel}\n\ngoal (4 subgoals):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}\n 2. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 3. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 4. init mru_opt_TS \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}\n 2. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 3. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 4. init mru_opt_TS \\<subseteq> UNIV", "show\n    \"{Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter> Domain (lv_ref_rel \\<inter> UNIV \\<times> UNIV)} \n      trans sv_TS \n    {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}", "using SV_inv1_inductive(2) SV_inv2_inductive(2) SV_inv3_inductive(2) SV_inv4_inductive(2)"], ["proof (prove)\nusing this:\n  {Vinv1} TS.trans sv_TS {> Vinv1}\n  {Vinv2 \\<inter> Vinv1} TS.trans sv_TS {> Vinv2}\n  {SV_inv3} TS.trans sv_TS {> SV_inv3}\n  {SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} TS.trans sv_TS {> SV_inv4}\n\ngoal (1 subgoal):\n 1. {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n     Domain\n      (lv_ref_rel \\<inter>\n       UNIV \\<times>\n       UNIV)} TS.trans\n               sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                        SV_inv4}", "by blast"], ["proof (state)\nthis:\n  {Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4 \\<inter>\n   Domain\n    (lv_ref_rel \\<inter>\n     UNIV \\<times>\n     UNIV)} TS.trans\n             sv_TS {> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter>\n                      SV_inv4}\n\ngoal (3 subgoals):\n 1. {UNIV \\<inter>\n     Range\n      (lv_ref_rel \\<inter>\n       (Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4) \\<times>\n       UNIV)} TS.trans mru_opt_TS {> UNIV}\n 2. init sv_TS\n    \\<subseteq> Vinv1 \\<inter> Vinv2 \\<inter> SV_inv3 \\<inter> SV_inv4\n 3. init mru_opt_TS \\<subseteq> UNIV", "qed(auto intro!: SV_inv1_inductive(1) SV_inv2_inductive(1) SV_inv3_inductive(1) SV_inv4_inductive(1))"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition OMRU_inv1 :: \"opt_mru_state set\" where\n  \"OMRU_inv1 = {s. \\<forall>p. (case mru_vote s p of\n      Some (r, _) \\<Rightarrow> r < next_round s\n      | None \\<Rightarrow> True)\n  }\""], ["", "lemma OMRU_inv1_inductive:\n  \"init mru_opt_TS \\<subseteq> OMRU_inv1\"\n  \"{OMRU_inv1} trans mru_opt_TS {> OMRU_inv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init mru_opt_TS \\<subseteq> OMRU_inv1 &&&\n    {OMRU_inv1} TS.trans mru_opt_TS {> OMRU_inv1}", "by(fastforce simp add: mru_opt_TS_def opt_mru_init_def PO_hoare_def OMRU_inv1_def mru_opt_trans_def \n    opt_mru_round_def const_map_is_Some less_Suc_eq\n    split: option.split_asm option.split)+"], ["", "lemmas OMRU_inv1I = OMRU_inv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas OMRU_inv1E [elim] = OMRU_inv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas OMRU_inv1D = OMRU_inv1_def [THEN setc_def_to_dest, rule_format]"], ["", "end"], ["", "end"]]}