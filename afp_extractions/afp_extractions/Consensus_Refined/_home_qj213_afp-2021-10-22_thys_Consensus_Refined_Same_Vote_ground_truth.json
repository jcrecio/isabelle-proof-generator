{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Same_Vote.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma safe_def:\n  \"safe s r v =\n    (\\<forall>r' < r. \\<forall>Q w. quorum_for Q w (votes s r')  \\<longrightarrow> v = w)\"", "lemmas sv_TS_defs = sv_TS_def v_init_def sv_trans_def", "lemma safe_imp_no_defection:\n  \"safe s (next_round s) v \\<Longrightarrow> no_defection s (const_map v S) (next_round s)\"", "lemma const_map_quorum_locked:\n  \"S \\<in> Quorum \\<Longrightarrow> locked_in_vf (const_map v S) v\"", "lemma sv_round_refines:\n  \"{Id} v_round r (const_map v S) r_decisions, sv_round r S v r_decisions {> Id}\"", "lemma Same_Vote_Refines:\n  \"PO_refines Id v_TS sv_TS\"", "lemmas SV_inv3I = SV_inv3_def [THEN setc_def_to_intro, rule_format]", "lemmas SV_inv3E [elim] = SV_inv3_def [THEN setc_def_to_elim, rule_format]", "lemmas SV_inv3D = SV_inv3_def [THEN setc_def_to_dest, rule_format]", "lemma SV_inv3_v_round: \n  \"{SV_inv3} sv_round r S v D {> SV_inv3}\"", "lemmas SV_inv3_event_pres = SV_inv3_v_round", "lemma SV_inv3_inductive:\n  \"init sv_TS \\<subseteq> SV_inv3\" \n  \"{SV_inv3} trans sv_TS {> SV_inv3}\"", "lemma SV_inv3_invariant: \"reach sv_TS \\<subseteq> SV_inv3\"", "lemma SV_inv1_inductive:\n  \"init sv_TS \\<subseteq> Vinv1\"\n  \"{Vinv1} trans sv_TS {> Vinv1}\"", "lemma SV_inv1_invariant:\n  \"reach sv_TS \\<subseteq> Vinv1\"", "lemma SV_inv2_inductive:\n  \"init sv_TS \\<subseteq> Vinv2\"\n  \"{Vinv2 \\<inter> Vinv1} trans sv_TS {> Vinv2}\"", "lemma SV_inv2_invariant:\n  \"reach sv_TS \\<subseteq> Vinv2\"", "lemmas SV_inv4I = SV_inv4_def [THEN setc_def_to_intro, rule_format]", "lemmas SV_inv4E [elim] = SV_inv4_def [THEN setc_def_to_elim, rule_format]", "lemmas SV_inv4D = SV_inv4_def [THEN setc_def_to_dest, rule_format]", "lemma SV_inv4_sv_round: \n  \"{SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} sv_round r S v D {> SV_inv4}\"", "lemmas SV_inv4_event_pres = SV_inv4_sv_round", "lemma SV_inv4_inductive:\n  \"init sv_TS \\<subseteq> SV_inv4\" \n  \"{SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} trans sv_TS {> SV_inv4}\"", "lemma SV_inv4_invariant: \"reach sv_TS \\<subseteq> SV_inv4\""], "translations": [["", "lemma safe_def:\n  \"safe s r v =\n    (\\<forall>r' < r. \\<forall>Q w. quorum_for Q w (votes s r')  \\<longrightarrow> v = w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe s r v =\n    (\\<forall>r'<r.\n        \\<forall>Q w. quorum_for Q w (votes s r') \\<longrightarrow> v = w)", "by(auto simp add: safe_def' quorum_for_def' Ball_def)"], ["", "definition sv_round :: \"round \\<Rightarrow> process set \\<Rightarrow> val \\<Rightarrow> (process, val)map \\<Rightarrow> (v_state \\<times> v_state) set\" where\n  \"sv_round r S v r_decisions = {(s, s').\n     \\<comment> \\<open>guards\\<close>\n     r = next_round s\n     \\<and> (S \\<noteq> {} \\<longrightarrow> safe s r v)\n     \\<and> d_guard r_decisions (const_map v S)\n     \\<and> \\<comment> \\<open>actions\\<close>\n     s' = s\\<lparr> \n       next_round := Suc r\n       , votes := (votes s)(r := const_map v S)\n       , decisions := (decisions s ++ r_decisions)\n     \\<rparr>\n  }\""], ["", "definition sv_trans :: \"(v_state \\<times> v_state) set\" where\n  \"sv_trans = (\\<Union>r S v D. sv_round r S v D) \\<union> Id\""], ["", "definition sv_TS :: \"v_state TS\" where\n  \"sv_TS = \\<lparr> init = v_init, trans = sv_trans \\<rparr>\""], ["", "lemmas sv_TS_defs = sv_TS_def v_init_def sv_trans_def"], ["", "subsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "lemma safe_imp_no_defection:\n  \"safe s (next_round s) v \\<Longrightarrow> no_defection s (const_map v S) (next_round s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. safe s (next_round s) v \\<Longrightarrow>\n    no_defection s (const_map v S) (next_round s)", "by(auto simp add: safe_def no_defection_def restrict_map_def const_map_def)"], ["", "lemma const_map_quorum_locked:\n  \"S \\<in> Quorum \\<Longrightarrow> locked_in_vf (const_map v S) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<in> Quorum \\<Longrightarrow> locked_in_vf (const_map v S) v", "by(auto simp add: locked_in_vf_def const_map_def quorum_for_def)"], ["", "lemma sv_round_refines:\n  \"{Id} v_round r (const_map v S) r_decisions, sv_round r S v r_decisions {> Id}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Id} v_round r (const_map v S)\n          r_decisions, sv_round r S v r_decisions {> Id}", "by(auto simp add: PO_rhoare_defs sv_round_def v_round_def  no_defection_empty\n    dest!: safe_imp_no_defection const_map_quorum_locked)"], ["", "lemma Same_Vote_Refines:\n  \"PO_refines Id v_TS sv_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines Id v_TS sv_TS", "by(auto simp add: PO_refines_def sv_TS_def sv_trans_def v_TS_defs intro!: \n    sv_round_refines relhoare_refl)"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "definition SV_inv3 where\n  \"SV_inv3 = {s. \\<forall>r a b v w. \n    votes s r a = Some v \\<and> votes s r b = Some w \\<longrightarrow> v = w\n  }\""], ["", "lemmas SV_inv3I = SV_inv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas SV_inv3E [elim] = SV_inv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas SV_inv3D = SV_inv3_def [THEN setc_def_to_dest, rule_format]"], ["", "subsubsection \\<open>Proof of invariants\\<close>"], ["", "(******************************************************************************)"], ["", "lemma SV_inv3_v_round: \n  \"{SV_inv3} sv_round r S v D {> SV_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SV_inv3} sv_round r S v D {> SV_inv3}", "apply(clarsimp simp add: PO_hoare_defs intro!: SV_inv3I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ra a b va w xa.\n       \\<lbrakk>xa \\<in> SV_inv3; (xa, x) \\<in> sv_round r S v D;\n        votes x ra a = Some va; votes x ra b = Some w\\<rbrakk>\n       \\<Longrightarrow> va = w", "apply(force simp add: sv_round_def const_map_def restrict_map_def SV_inv3_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas SV_inv3_event_pres = SV_inv3_v_round"], ["", "lemma SV_inv3_inductive:\n  \"init sv_TS \\<subseteq> SV_inv3\" \n  \"{SV_inv3} trans sv_TS {> SV_inv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init sv_TS \\<subseteq> SV_inv3 &&& {SV_inv3} TS.trans sv_TS {> SV_inv3}", "apply (simp add: sv_TS_defs SV_inv3_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {SV_inv3} TS.trans sv_TS {> SV_inv3}", "by (auto simp add: sv_TS_defs SV_inv3_event_pres)"], ["", "lemma SV_inv3_invariant: \"reach sv_TS \\<subseteq> SV_inv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach sv_TS \\<subseteq> SV_inv3", "by (auto intro!: inv_rule_basic SV_inv3_inductive del: subsetI)"], ["", "text \\<open>\n\nThis is a different characterization of @{term safe}, due to Lampson~\\cite{lampson_abcds_2001}:\n  @{term \"safe' s r v = (\\<forall>r'< r. (\\<exists>Q \\<in> Quorum. \\<forall>a \\<in> Q. \\<forall>w. votes s r' a = Some w \\<longrightarrow> w = v))\"}\n\nIt is, however, strictly stronger than our characterization, since we do not at this point assume\nthe \"completeness\" of our quorum system (for any set S, either S or the complement of S is a\nquorum), and the following is thus not provable: @{term \"s \\<in> SV_inv3 \\<Longrightarrow> safe' s = safe s\"}.\n\n\\<close>"], ["", "subsubsection \\<open>Transfer of abstract invariants\\<close>"], ["", "(******************************************************************************)"], ["", "lemma SV_inv1_inductive:\n  \"init sv_TS \\<subseteq> Vinv1\"\n  \"{Vinv1} trans sv_TS {> Vinv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init sv_TS \\<subseteq> Vinv1 &&& {Vinv1} TS.trans sv_TS {> Vinv1}", "apply(rule abs_INV_init_transfer[OF Same_Vote_Refines Vinv1_inductive(1), simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv1} TS.trans sv_TS {> Vinv1}", "apply(rule abs_INV_trans_transfer[OF Same_Vote_Refines Vinv1_inductive(2), simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SV_inv1_invariant:\n  \"reach sv_TS \\<subseteq> Vinv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach sv_TS \\<subseteq> Vinv1", "by(rule abs_INV_transfer[OF Same_Vote_Refines Vinv1_invariant, simplified])"], ["", "lemma SV_inv2_inductive:\n  \"init sv_TS \\<subseteq> Vinv2\"\n  \"{Vinv2 \\<inter> Vinv1} trans sv_TS {> Vinv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init sv_TS \\<subseteq> Vinv2 &&&\n    {Vinv2 \\<inter> Vinv1} TS.trans sv_TS {> Vinv2}", "apply(rule abs_INV_init_transfer[OF Same_Vote_Refines Vinv2_inductive(1), simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv2 \\<inter> Vinv1} TS.trans sv_TS {> Vinv2}", "apply(rule abs_INV_trans_transfer[OF Same_Vote_Refines Vinv2_inductive(2), simplified])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma SV_inv2_invariant:\n  \"reach sv_TS \\<subseteq> Vinv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach sv_TS \\<subseteq> Vinv2", "by(rule abs_INV_transfer[OF Same_Vote_Refines Vinv2_invariant, simplified])"], ["", "subsubsection \\<open>Additional invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>With Same Voting, the voted values are safe in the next round.\\<close>"], ["", "definition SV_inv4 :: \"v_state set\" where\n  \"SV_inv4 = {s. \\<forall>v a r. votes s r a = Some v \\<longrightarrow> safe s (Suc r) v }\""], ["", "lemmas SV_inv4I = SV_inv4_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas SV_inv4E [elim] = SV_inv4_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas SV_inv4D = SV_inv4_def [THEN setc_def_to_dest, rule_format]"], ["", "lemma SV_inv4_sv_round: \n  \"{SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} sv_round r S v D {> SV_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} sv_round r S v D {> SV_inv4}", "proof(clarsimp simp add: PO_hoare_defs intro!: SV_inv4I)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x va a ra xa.\n       \\<lbrakk>votes x ra a = Some va; (xa, x) \\<in> sv_round r S v D;\n        xa \\<in> SV_inv4; xa \\<in> Vinv1; xa \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> safe x (Suc ra) va", "fix s v' a r' s'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x va a ra xa.\n       \\<lbrakk>votes x ra a = Some va; (xa, x) \\<in> sv_round r S v D;\n        xa \\<in> SV_inv4; xa \\<in> Vinv1; xa \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> safe x (Suc ra) va", "assume \n    step: \"(s, s') \\<in> sv_round r S v D\"\n    and invs: \"s \\<in> SV_inv4\" \"s \\<in> Vinv1\" \"s \\<in> Vinv2\"\n    and vote: \"votes s' r' a = Some v'\""], ["proof (state)\nthis:\n  (s, s') \\<in> sv_round r S v D\n  s \\<in> SV_inv4\n  s \\<in> Vinv1\n  s \\<in> Vinv2\n  votes s' r' a = Some v'\n\ngoal (1 subgoal):\n 1. \\<And>x va a ra xa.\n       \\<lbrakk>votes x ra a = Some va; (xa, x) \\<in> sv_round r S v D;\n        xa \\<in> SV_inv4; xa \\<in> Vinv1; xa \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> safe x (Suc ra) va", "thus \"safe s' (Suc r') v'\""], ["proof (prove)\nusing this:\n  (s, s') \\<in> sv_round r S v D\n  s \\<in> SV_inv4\n  s \\<in> Vinv1\n  s \\<in> Vinv2\n  votes s' r' a = Some v'\n\ngoal (1 subgoal):\n 1. safe s' (Suc r') v'", "proof(cases \"r=r'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r = r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'\n 2. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'", "case True"], ["proof (state)\nthis:\n  r = r'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r = r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'\n 2. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'", "moreover"], ["proof (state)\nthis:\n  r = r'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r = r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'\n 2. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'", "hence safe: \"safe s' r' v'\""], ["proof (prove)\nusing this:\n  r = r'\n\ngoal (1 subgoal):\n 1. safe s' r' v'", "using step vote"], ["proof (prove)\nusing this:\n  r = r'\n  (s, s') \\<in> sv_round r S v D\n  votes s' r' a = Some v'\n\ngoal (1 subgoal):\n 1. safe s' r' v'", "by(force simp add: sv_round_def const_map_is_Some safe_def quorum_for_def)"], ["proof (state)\nthis:\n  safe s' r' v'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r = r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'\n 2. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'", "ultimately"], ["proof (chain)\npicking this:\n  r = r'\n  safe s' r' v'", "show ?thesis"], ["proof (prove)\nusing this:\n  r = r'\n  safe s' r' v'\n\ngoal (1 subgoal):\n 1. safe s' (Suc r') v'", "using step vote"], ["proof (prove)\nusing this:\n  r = r'\n  safe s' r' v'\n  (s, s') \\<in> sv_round r S v D\n  votes s' r' a = Some v'\n\ngoal (1 subgoal):\n 1. safe s' (Suc r') v'", "by(force simp add: safe_def less_Suc_eq sv_round_def quorum_for_def const_map_is_Some \n        dest: quorum_non_empty)"], ["proof (state)\nthis:\n  safe s' (Suc r') v'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(s, s') \\<in> sv_round r S v D; s \\<in> SV_inv4; s \\<in> Vinv1;\n     s \\<in> Vinv2; votes s' r' a = Some v'; r \\<noteq> r'\\<rbrakk>\n    \\<Longrightarrow> safe s' (Suc r') v'", "qed(clarsimp simp add: sv_round_def safe_def Vinv2_def Vinv1_def  SV_inv4_def\n      intro: Quorum_not_empty)"], ["proof (state)\nthis:\n  safe s' (Suc r') v'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas SV_inv4_event_pres = SV_inv4_sv_round"], ["", "lemma SV_inv4_inductive:\n  \"init sv_TS \\<subseteq> SV_inv4\" \n  \"{SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} trans sv_TS {> SV_inv4}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init sv_TS \\<subseteq> SV_inv4 &&&\n    {SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} TS.trans sv_TS {> SV_inv4}", "apply(simp add: sv_TS_defs SV_inv4_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {SV_inv4 \\<inter> (Vinv1 \\<inter> Vinv2)} TS.trans sv_TS {> SV_inv4}", "by (auto simp add: sv_TS_defs SV_inv4_event_pres)"], ["", "lemma SV_inv4_invariant: \"reach sv_TS \\<subseteq> SV_inv4\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach sv_TS \\<subseteq> SV_inv4", "by (rule inv_rule_incr)\n  (auto intro: SV_inv4_inductive SV_inv2_invariant SV_inv1_invariant del: subsetI)"], ["", "end"], ["", "(* context quorum_process *)"], ["", "end"]]}