{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Voting.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma quorum_for_def:\n  \"quorum_for Q v v_f = (Q \\<in> Quorum \\<and> (\\<forall>p \\<in> Q. v_f p = Some v))\"", "lemma no_defection_def:\n  \"no_defection s round_votes r =\n    (\\<forall>r' < r. \\<forall>a Q v. quorum_for Q v (votes s r') \\<and> a \\<in> Q \\<longrightarrow> round_votes a \\<in> {None, Some v})\"", "lemmas v_evt_defs = v_round_def", "lemmas v_TS_defs = v_TS_def v_init_def v_trans_def", "lemmas Vinv1I = Vinv1_def [THEN setc_def_to_intro, rule_format]", "lemmas Vinv1E [elim] = Vinv1_def [THEN setc_def_to_elim, rule_format]", "lemmas Vinv1D = Vinv1_def [THEN setc_def_to_dest, rule_format]", "lemmas Vinv2I = Vinv2_def [THEN setc_def_to_intro, rule_format]", "lemmas Vinv2E [elim] = Vinv2_def [THEN setc_def_to_elim, rule_format]", "lemmas Vinv2D = Vinv2_def [THEN setc_def_to_dest, rule_format]", "lemmas Vinv3I = Vinv3_def [THEN setc_def_to_intro, rule_format]", "lemmas Vinv3E [elim] = Vinv3_def [THEN setc_def_to_elim, rule_format]", "lemmas Vinv3D = Vinv3_def [THEN setc_def_to_dest, rule_format]", "lemma Vinv1_v_round: \n  \"{Vinv1} v_round r v_f d_f {> Vinv1}\"", "lemmas Vinv1_event_pres = Vinv1_v_round", "lemma Vinv1_inductive:\n  \"init v_TS \\<subseteq> Vinv1\"\n  \"{Vinv1} trans v_TS {> Vinv1}\"", "lemma Vinv1_invariant: \"reach v_TS \\<subseteq> Vinv1\"", "lemma Vinv1_finite_map_graph:\n   \"s \\<in> Vinv1 \\<Longrightarrow> finite (map_graph (case_prod (votes s)))\"", "lemma Vinv1_finite_vote_set:\n   \"s \\<in> Vinv1 \\<Longrightarrow> finite (vote_set (votes s) Q)\"", "lemma process_mru_map_add:\n  assumes\n    \"s \\<in> Vinv1\"\n  shows \n    \"process_mru ((votes s)(next_round s := v_f)) = \n    (process_mru (votes s) ++ (\\<lambda>p. map_option (Pair (next_round s)) (v_f p)))\"", "lemma no_defection_empty:\n  \"no_defection s Map.empty r'\"", "lemma no_defection_preserved:\nassumes\n  \"s \\<in> Vinv1\"\n  \"r = next_round s\"\n  \"no_defection s v_f r\"\n  \"no_defection s (votes s r') r'\"\n  \"votes s' = (votes s)(r := v_f)\"\nshows \n  \"no_defection s' (votes s' r') r'\"", "lemma Vinv2_v_round: \n  \"{Vinv2 \\<inter> Vinv1} v_round r v_f d_f {> Vinv2}\"", "lemmas Vinv2_event_pres = Vinv2_v_round", "lemma Vinv2_inductive:\n  \"init v_TS \\<subseteq> Vinv2\"\n  \"{Vinv2 \\<inter> Vinv1} trans v_TS {> Vinv2}\"", "lemma Vinv2_invariant: \"reach v_TS \\<subseteq> Vinv2\"", "lemma locked_preserved:\nassumes\n  \"s \\<in> Vinv1\"\n  \"r = next_round s\"\n  \"votes s' = (votes s)(r := v_f)\"\nshows \n  \"locked s \\<subseteq> locked s'\"", "lemma Vinv3_v_round: \n  \"{Vinv3 \\<inter> Vinv1} v_round r v_f d_f {> Vinv3}\"", "lemmas Vinv3_event_pres = Vinv3_v_round", "lemma Vinv3_inductive:\n  \"init v_TS \\<subseteq> Vinv3\"\n  \"{Vinv3 \\<inter> Vinv1} trans v_TS {> Vinv3}\"", "lemma Vinv3_invariant: \"reach v_TS \\<subseteq> Vinv3\"", "lemma locked_in_vf_same:\n  \"\\<lbrakk> locked_in_vf v_f v; locked_in_vf v_f w \\<rbrakk> \\<Longrightarrow> v = w\"", "theorem locked_in_different:\nassumes\n  \"s \\<in> Vinv2\"\n  \"locked_in s r1 v\"\n  \"locked_in s r2 w\"\n  \"r1 < r2\"\nshows\n  \"v = w\"", "theorem locked_unique: \nassumes \n  \"s \\<in> Vinv2\"\n  \"v \\<in> locked s\" \"w \\<in> locked s\"\nshows \n  \"v = w\"", "lemma stable_decision:\n  assumes beh: \"tr \\<in> beh v_TS\"\n  and len: \"i < length tr\"\n  and s: \"s = nth tr i\"\n  and t: \"t = nth tr (i - j)\"\n  and dec: \n    \"decisions s p = Some v\"\n  shows\n    \"decisions t p = Some v\"", "lemma Voting_agreement:\n  assumes beh: \"tr \\<in> beh v_TS\"\n  and len: \"i < length tr\"\n  and s: \"s = nth tr i\"\n  and t: \"t = nth tr (i - j)\"\n  and dec: \n    \"decisions s p = Some v\"\n    \"decisions t q = Some w\"\n  shows \"w = v\""], "translations": [["", "lemma quorum_for_def:\n  \"quorum_for Q v v_f = (Q \\<in> Quorum \\<and> (\\<forall>p \\<in> Q. v_f p = Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_for Q v v_f =\n    (Q \\<in> Quorum \\<and> (\\<forall>p\\<in>Q. v_f p = Some v))", "by(auto simp add: quorum_for_def' image_def dest: quorum_non_empty)"], ["", "definition locked_in_vf :: \"(process, val)map \\<Rightarrow> val \\<Rightarrow> bool\" where\n  \"locked_in_vf v_f v \\<equiv> \\<exists>Q. quorum_for Q v v_f\""], ["", "definition locked_in :: \"v_state \\<Rightarrow> round \\<Rightarrow> val \\<Rightarrow> bool\" where\n  \"locked_in s r v = locked_in_vf (votes s r) v\""], ["", "definition d_guard :: \"(process \\<Rightarrow> val option) \\<Rightarrow> (process \\<Rightarrow> val option) \\<Rightarrow> bool\" where\n  \"d_guard r_decisions r_votes \\<equiv> \\<forall>p v.\n    r_decisions p = Some v \\<longrightarrow> locked_in_vf r_votes v\""], ["", "definition no_defection :: \"v_state \\<Rightarrow> (process, val)map \\<Rightarrow> round \\<Rightarrow> bool\" where\n  no_defection_def':\n  \"no_defection s r_votes r \\<equiv> \n    \\<forall>r' < r. \\<forall>Q \\<in> Quorum. \\<forall>v. (votes s r') ` Q = {Some v} \\<longrightarrow> r_votes ` Q \\<subseteq> {None, Some v}\""], ["", "text \\<open>The following definition of @{term no_defection} is easier to reason about in Isabelle.\\<close>"], ["", "lemma no_defection_def:\n  \"no_defection s round_votes r =\n    (\\<forall>r' < r. \\<forall>a Q v. quorum_for Q v (votes s r') \\<and> a \\<in> Q \\<longrightarrow> round_votes a \\<in> {None, Some v})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_defection s round_votes r =\n    (\\<forall>r'<r.\n        \\<forall>a Q v.\n           quorum_for Q v (votes s r') \\<and> a \\<in> Q \\<longrightarrow>\n           round_votes a \\<in> {None, Some v})", "apply(auto simp add: no_defection_def' Ball_def quorum_for_def')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>r' a Q v.\n       \\<lbrakk>\\<forall>r'<r.\n                   \\<forall>x.\n                      x \\<in> Quorum \\<longrightarrow>\n                      (\\<forall>v.\n                          votes s r' ` x = {Some v} \\<longrightarrow>\n                          round_votes ` x \\<subseteq> {None, Some v});\n        r' < r; Q \\<in> Quorum; votes s r' ` Q = {Some v}; a \\<in> Q;\n        round_votes a \\<noteq> Some v\\<rbrakk>\n       \\<Longrightarrow> round_votes a = None\n 2. \\<And>r' x v xb y.\n       \\<lbrakk>\\<forall>r'<r.\n                   \\<forall>a Q v.\n                      Q \\<in> Quorum \\<and>\n                      votes s r' ` Q = {Some v} \\<and>\n                      a \\<in> Q \\<longrightarrow>\n                      round_votes a = None \\<or> round_votes a = Some v;\n        r' < r; x \\<in> Quorum; votes s r' ` x = {Some v}; xb \\<in> x;\n        round_votes xb = Some y\\<rbrakk>\n       \\<Longrightarrow> y = v", "apply(blast)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r' x v xb y.\n       \\<lbrakk>\\<forall>r'<r.\n                   \\<forall>a Q v.\n                      Q \\<in> Quorum \\<and>\n                      votes s r' ` Q = {Some v} \\<and>\n                      a \\<in> Q \\<longrightarrow>\n                      round_votes a = None \\<or> round_votes a = Some v;\n        r' < r; x \\<in> Quorum; votes s r' ` x = {Some v}; xb \\<in> x;\n        round_votes xb = Some y\\<rbrakk>\n       \\<Longrightarrow> y = v", "by (metis option.discI option.inject)"], ["", "definition locked :: \"v_state \\<Rightarrow> val set\" where\n  \"locked s = {v. \\<exists>r. locked_in s r v}\""], ["", "text \\<open>The sole system event.\\<close>"], ["", "definition v_round :: \"round \\<Rightarrow> (process, val)map \\<Rightarrow> (process, val)map \\<Rightarrow> (v_state \\<times> v_state) set\" where\n  \"v_round r r_votes r_decisions = {(s, s').\n     \\<comment> \\<open>guards\\<close>\n     r = next_round s\n     \\<and> no_defection s r_votes r\n     \\<and> d_guard r_decisions r_votes\n     \\<and> \\<comment> \\<open>actions\\<close>\n     s' = s\\<lparr> \n       next_round := Suc r,\n       votes := (votes s)(r := r_votes),\n       decisions := (decisions s) ++ r_decisions\n     \\<rparr>\n  }\""], ["", "lemmas v_evt_defs = v_round_def"], ["", "definition v_trans :: \"(v_state \\<times> v_state) set\" where\n  \"v_trans = (\\<Union>r v_f d_f. v_round r v_f d_f) \\<union> Id\""], ["", "definition v_TS :: \"v_state TS\" where\n  \"v_TS = \\<lparr> init = v_init, trans = v_trans \\<rparr>\""], ["", "lemmas v_TS_defs = v_TS_def v_init_def v_trans_def"], ["", "subsection \\<open>Invariants\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The only rounds where votes could have been cast are the ones \n  preceding the next round.\\<close>"], ["", "definition Vinv1 where\n  \"Vinv1 = {s. \\<forall>r. next_round s \\<le> r \\<longrightarrow> votes s r = Map.empty }\""], ["", "lemmas Vinv1I = Vinv1_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas Vinv1E [elim] = Vinv1_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas Vinv1D = Vinv1_def [THEN setc_def_to_dest, rule_format]"], ["", "text \\<open>The votes cast must respect the @{term no_defection} property.\\<close>"], ["", "definition Vinv2 where\n  \"Vinv2 = {s. \\<forall>r. no_defection s (votes s r) r }\""], ["", "lemmas Vinv2I = Vinv2_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas Vinv2E [elim] = Vinv2_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas Vinv2D = Vinv2_def [THEN setc_def_to_dest, rule_format]"], ["", "definition Vinv3 where\n  \"Vinv3 = {s. ran (decisions s) \\<subseteq> locked s}\""], ["", "lemmas Vinv3I = Vinv3_def [THEN setc_def_to_intro, rule_format]"], ["", "lemmas Vinv3E [elim] = Vinv3_def [THEN setc_def_to_elim, rule_format]"], ["", "lemmas Vinv3D = Vinv3_def [THEN setc_def_to_dest, rule_format]"], ["", "subsubsection \\<open>Proofs of invariants\\<close>"], ["", "(******************************************************************************)\n\n(*************************)"], ["", "lemma Vinv1_v_round: \n  \"{Vinv1} v_round r v_f d_f {> Vinv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv1} v_round r v_f d_f {> Vinv1}", "by(auto simp add: PO_hoare_defs v_round_def intro!: Vinv1I)"], ["", "lemmas Vinv1_event_pres = Vinv1_v_round"], ["", "lemma Vinv1_inductive:\n  \"init v_TS \\<subseteq> Vinv1\"\n  \"{Vinv1} trans v_TS {> Vinv1}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init v_TS \\<subseteq> Vinv1 &&& {Vinv1} TS.trans v_TS {> Vinv1}", "apply (simp add: v_TS_defs Vinv1_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv1} TS.trans v_TS {> Vinv1}", "by (auto simp add: v_TS_defs Vinv1_event_pres)"], ["", "lemma Vinv1_invariant: \"reach v_TS \\<subseteq> Vinv1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach v_TS \\<subseteq> Vinv1", "by (rule inv_rule_basic, auto intro!: Vinv1_inductive)"], ["", "text \\<open>The following two lemmas will be useful later, when we\n  start taking votes with the maximum timestamp.\\<close>"], ["", "lemma Vinv1_finite_map_graph:\n   \"s \\<in> Vinv1 \\<Longrightarrow> finite (map_graph (case_prod (votes s)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> Vinv1 \\<Longrightarrow>\n    finite (map_graph (\\<lambda>(x, y). votes s x y))", "apply(rule finite_dom_finite_map_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> Vinv1 \\<Longrightarrow>\n    finite (dom (\\<lambda>(x, y). votes s x y))", "apply(rule finite_subset[where B=\"{0..< v_state.next_round s} \\<times> UNIV\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. s \\<in> Vinv1 \\<Longrightarrow>\n    dom (\\<lambda>(x, y). votes s x y)\n    \\<subseteq> {0..<next_round s} \\<times> UNIV\n 2. s \\<in> Vinv1 \\<Longrightarrow>\n    finite ({0..<next_round s} \\<times> UNIV)", "apply(auto simp add: Vinv1_def dom_def not_le[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Vinv1_finite_vote_set:\n   \"s \\<in> Vinv1 \\<Longrightarrow> finite (vote_set (votes s) Q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> Vinv1 \\<Longrightarrow> finite (vote_set (votes s) Q)", "apply(drule Vinv1_finite_map_graph)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (map_graph (\\<lambda>(x, y). votes s x y)) \\<Longrightarrow>\n    finite (vote_set (votes s) Q)", "apply(clarsimp simp add: map_graph_def fun_graph_def vote_set_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {((a, b), y) |a b y. Some y = votes s a b} \\<Longrightarrow>\n    finite\n     {uu_.\n      \\<exists>a r v.\n         uu_ = (r, v) \\<and> Some v = votes s r a \\<and> a \\<in> Q}", "apply(erule finite_surj[where f=\"\\<lambda>((r, a), v). (r, v)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. {uu_.\n     \\<exists>a r v.\n        uu_ = (r, v) \\<and> Some v = votes s r a \\<and> a \\<in> Q}\n    \\<subseteq> (\\<lambda>((r, a), v). (r, v)) `\n                {((a, b), y) |a b y. Some y = votes s a b}", "by(force simp add: image_def)"], ["", "lemma process_mru_map_add:\n  assumes\n    \"s \\<in> Vinv1\"\n  shows \n    \"process_mru ((votes s)(next_round s := v_f)) = \n    (process_mru (votes s) ++ (\\<lambda>p. map_option (Pair (next_round s)) (v_f p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. process_mru ((votes s)(next_round s := v_f)) =\n    process_mru (votes s) ++\n    (\\<lambda>p. map_option (Pair (next_round s)) (v_f p))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. process_mru ((votes s)(next_round s := v_f)) =\n    process_mru (votes s) ++\n    (\\<lambda>p. map_option (Pair (next_round s)) (v_f p))", "from assms[THEN Vinv1D]"], ["proof (chain)\npicking this:\n  next_round s \\<le> ?r \\<Longrightarrow> votes s ?r = Map.empty", "have empty: \"\\<forall>r' \\<ge> next_round s. votes s r' = Map.empty\""], ["proof (prove)\nusing this:\n  next_round s \\<le> ?r \\<Longrightarrow> votes s ?r = Map.empty\n\ngoal (1 subgoal):\n 1. \\<forall>r'\\<ge>next_round s. votes s r' = Map.empty", "by simp"], ["proof (state)\nthis:\n  \\<forall>r'\\<ge>next_round s. votes s r' = Map.empty\n\ngoal (1 subgoal):\n 1. process_mru ((votes s)(next_round s := v_f)) =\n    process_mru (votes s) ++\n    (\\<lambda>p. map_option (Pair (next_round s)) (v_f p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. process_mru ((votes s)(next_round s := v_f)) =\n    process_mru (votes s) ++\n    (\\<lambda>p. map_option (Pair (next_round s)) (v_f p))", "by(auto  simp add: process_mru_new_votes[OF empty] map_add_def split: option.split)"], ["proof (state)\nthis:\n  process_mru ((votes s)(next_round s := v_f)) =\n  process_mru (votes s) ++\n  (\\<lambda>p. map_option (Pair (next_round s)) (v_f p))\n\ngoal:\nNo subgoals!", "qed"], ["", "(*************************)"], ["", "lemma no_defection_empty:\n  \"no_defection s Map.empty r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_defection s Map.empty r'", "by(auto simp add: no_defection_def)"], ["", "lemma no_defection_preserved:\nassumes\n  \"s \\<in> Vinv1\"\n  \"r = next_round s\"\n  \"no_defection s v_f r\"\n  \"no_defection s (votes s r') r'\"\n  \"votes s' = (votes s)(r := v_f)\"\nshows \n  \"no_defection s' (votes s' r') r'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_defection s' (votes s' r') r'", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> Vinv1\n  r = next_round s\n  no_defection s v_f r\n  no_defection s (votes s r') r'\n  votes s' = (votes s)(r := v_f)\n\ngoal (1 subgoal):\n 1. no_defection s' (votes s' r') r'", "by(force simp add: no_defection_def)"], ["", "(********)"], ["", "lemma Vinv2_v_round: \n  \"{Vinv2 \\<inter> Vinv1} v_round r v_f d_f {> Vinv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv2 \\<inter> Vinv1} v_round r v_f d_f {> Vinv2}", "apply(auto simp add: PO_hoare_defs intro!: Vinv2I)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ra xa.\n       \\<lbrakk>(xa, x) \\<in> v_round r v_f d_f; xa \\<in> Vinv2;\n        xa \\<in> Vinv1\\<rbrakk>\n       \\<Longrightarrow> no_defection x (votes x ra) ra", "apply(rename_tac s' r' s)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>s' r' s.\n       \\<lbrakk>(s, s') \\<in> v_round r v_f d_f; s \\<in> Vinv2;\n        s \\<in> Vinv1\\<rbrakk>\n       \\<Longrightarrow> no_defection s' (votes s' r') r'", "apply(erule no_defection_preserved)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>s' r' s.\n       \\<lbrakk>(s, s') \\<in> v_round r v_f d_f; s \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> ?r5 s' r' s = next_round s\n 2. \\<And>s' r' s.\n       \\<lbrakk>(s, s') \\<in> v_round r v_f d_f; s \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> no_defection s (?v_f5 s' r' s) (?r5 s' r' s)\n 3. \\<And>s' r' s.\n       \\<lbrakk>(s, s') \\<in> v_round r v_f d_f; s \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> no_defection s (votes s r') r'\n 4. \\<And>s' r' s.\n       \\<lbrakk>(s, s') \\<in> v_round r v_f d_f; s \\<in> Vinv2\\<rbrakk>\n       \\<Longrightarrow> votes s' = (votes s)(?r5 s' r' s := ?v_f5 s' r' s)", "apply(auto simp add: v_round_def intro!: v_state.equality)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas Vinv2_event_pres = Vinv2_v_round"], ["", "lemma Vinv2_inductive:\n  \"init v_TS \\<subseteq> Vinv2\"\n  \"{Vinv2 \\<inter> Vinv1} trans v_TS {> Vinv2}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init v_TS \\<subseteq> Vinv2 &&&\n    {Vinv2 \\<inter> Vinv1} TS.trans v_TS {> Vinv2}", "apply(simp add: v_TS_defs Vinv2_def no_defection_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv2 \\<inter> Vinv1} TS.trans v_TS {> Vinv2}", "by (auto simp add: v_TS_defs Vinv2_event_pres)"], ["", "lemma Vinv2_invariant: \"reach v_TS \\<subseteq> Vinv2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach v_TS \\<subseteq> Vinv2", "by (rule inv_rule_incr, auto intro: Vinv2_inductive Vinv1_invariant del: subsetI)"], ["", "(*************************)"], ["", "lemma locked_preserved:\nassumes\n  \"s \\<in> Vinv1\"\n  \"r = next_round s\"\n  \"votes s' = (votes s)(r := v_f)\"\nshows \n  \"locked s \\<subseteq> locked s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locked s \\<subseteq> locked s'", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> Vinv1\n  r = next_round s\n  votes s' = (votes s)(r := v_f)\n\ngoal (1 subgoal):\n 1. locked s \\<subseteq> locked s'", "apply(auto simp add: locked_def locked_in_def locked_in_vf_def quorum_for_def dest!: Vinv1D)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x ra Q.\n       \\<lbrakk>r = next_round s; votes s' = (votes s)(next_round s := v_f);\n        Q \\<in> Quorum; \\<forall>p\\<in>Q. votes s ra p = Some x;\n        votes s (next_round s) = Map.empty\\<rbrakk>\n       \\<Longrightarrow> \\<exists>r.\n                            (r = next_round s \\<longrightarrow>\n                             (\\<exists>Q.\n                                 Q \\<in> Quorum \\<and>\n                                 (\\<forall>p\\<in>Q. v_f p = Some x))) \\<and>\n                            (r \\<noteq> next_round s \\<longrightarrow>\n                             (\\<exists>Q.\n                                 Q \\<in> Quorum \\<and>\n                                 (\\<forall>p\\<in>Q. votes s r p = Some x)))", "by (metis option.distinct(1))"], ["", "(*************************)"], ["", "lemma Vinv3_v_round: \n  \"{Vinv3 \\<inter> Vinv1} v_round r v_f d_f {> Vinv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv3 \\<inter> Vinv1} v_round r v_f d_f {> Vinv3}", "proof(clarsimp simp add: PO_hoare_defs, intro Vinv3I, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> v_round r v_f d_f; xa \\<in> Vinv3;\n        xa \\<in> Vinv1; xb \\<in> ran (decisions x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> locked x", "fix s s' v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> v_round r v_f d_f; xa \\<in> Vinv3;\n        xa \\<in> Vinv1; xb \\<in> ran (decisions x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> locked x", "assume step: \"(s, s') \\<in> v_round r v_f d_f\" and inv3: \"s \\<in> Vinv3\" and inv1: \"s \\<in> Vinv1\"\n  and dec: \"v \\<in> ran (decisions s')\""], ["proof (state)\nthis:\n  (s, s') \\<in> v_round r v_f d_f\n  s \\<in> Vinv3\n  s \\<in> Vinv1\n  v \\<in> ran (decisions s')\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> v_round r v_f d_f; xa \\<in> Vinv3;\n        xa \\<in> Vinv1; xb \\<in> ran (decisions x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> locked x", "have \"locked s \\<subseteq> locked s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locked s \\<subseteq> locked s'", "using step"], ["proof (prove)\nusing this:\n  (s, s') \\<in> v_round r v_f d_f\n\ngoal (1 subgoal):\n 1. locked s \\<subseteq> locked s'", "by(intro locked_preserved[OF inv1, where s'=s']) (auto simp add: v_round_def)"], ["proof (state)\nthis:\n  locked s \\<subseteq> locked s'\n\ngoal (1 subgoal):\n 1. \\<And>x xa xb.\n       \\<lbrakk>(xa, x) \\<in> v_round r v_f d_f; xa \\<in> Vinv3;\n        xa \\<in> Vinv1; xb \\<in> ran (decisions x)\\<rbrakk>\n       \\<Longrightarrow> xb \\<in> locked x", "with Vinv3D[OF inv3] step dec"], ["proof (chain)\npicking this:\n  ran (decisions s) \\<subseteq> locked s\n  (s, s') \\<in> v_round r v_f d_f\n  v \\<in> ran (decisions s')\n  locked s \\<subseteq> locked s'", "show \"v \\<in> locked s'\""], ["proof (prove)\nusing this:\n  ran (decisions s) \\<subseteq> locked s\n  (s, s') \\<in> v_round r v_f d_f\n  v \\<in> ran (decisions s')\n  locked s \\<subseteq> locked s'\n\ngoal (1 subgoal):\n 1. v \\<in> locked s'", "apply(auto simp add: v_round_def dest!: ran_map_addD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ran (decisions s) \\<subseteq> locked s;\n     locked s\n     \\<subseteq> locked\n                  (s\\<lparr>next_round := Suc (next_round s),\n                       votes := (votes s)(next_round s := v_f),\n                       decisions := decisions s ++ d_f\\<rparr>);\n     r = next_round s; no_defection s v_f (next_round s); d_guard d_f v_f;\n     s' = s\n     \\<lparr>next_round := Suc (next_round s),\n        votes := (votes s)(next_round s := v_f),\n        decisions := decisions s ++ d_f\\<rparr>;\n     v \\<in> ran d_f\\<rbrakk>\n    \\<Longrightarrow> v \\<in> locked\n                               (s\\<lparr>next_round := Suc (next_round s),\n                                    votes := (votes s)(next_round s := v_f),\n                                    decisions := decisions s ++ d_f\\<rparr>)", "apply(auto simp add: locked_def locked_in_def d_guard_def ran_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  v \\<in> locked s'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas Vinv3_event_pres = Vinv3_v_round"], ["", "lemma Vinv3_inductive:\n  \"init v_TS \\<subseteq> Vinv3\"\n  \"{Vinv3 \\<inter> Vinv1} trans v_TS {> Vinv3}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init v_TS \\<subseteq> Vinv3 &&&\n    {Vinv3 \\<inter> Vinv1} TS.trans v_TS {> Vinv3}", "apply(simp add: v_TS_defs Vinv3_def no_defection_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {Vinv3 \\<inter> Vinv1} TS.trans v_TS {> Vinv3}", "by (auto simp add: v_TS_defs Vinv3_event_pres)"], ["", "lemma Vinv3_invariant: \"reach v_TS \\<subseteq> Vinv3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach v_TS \\<subseteq> Vinv3", "by (rule inv_rule_incr, auto intro: Vinv3_inductive Vinv1_invariant del: subsetI)"], ["", "subsection \\<open>Agreement and stability\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Only a singe value can be locked within the votes for one round.\\<close>"], ["", "lemma locked_in_vf_same:\n  \"\\<lbrakk> locked_in_vf v_f v; locked_in_vf v_f w \\<rbrakk> \\<Longrightarrow> v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>locked_in_vf v_f v; locked_in_vf v_f w\\<rbrakk>\n    \\<Longrightarrow> v = w", "using qintersect"], ["proof (prove)\nusing this:\n  \\<lbrakk>?Q \\<in> Quorum; ?Q' \\<in> Quorum\\<rbrakk>\n  \\<Longrightarrow> ?Q \\<inter> ?Q' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>locked_in_vf v_f v; locked_in_vf v_f w\\<rbrakk>\n    \\<Longrightarrow> v = w", "apply(auto simp add: locked_in_vf_def quorum_for_def image_iff)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Q Qa.\n       \\<lbrakk>\\<And>Q Q'.\n                   \\<lbrakk>Q \\<in> Quorum; Q' \\<in> Quorum\\<rbrakk>\n                   \\<Longrightarrow> Q \\<inter> Q' \\<noteq> {};\n        Q \\<in> Quorum; \\<forall>p\\<in>Q. v_f p = Some v; Qa \\<in> Quorum;\n        \\<forall>p\\<in>Qa. v_f p = Some w\\<rbrakk>\n       \\<Longrightarrow> v = w", "by (metis Int_iff all_not_in_conv option.inject)"], ["", "text \\<open>In any reachable state, no two different values can be locked in\n  different rounds.\\<close>"], ["", "theorem locked_in_different:\nassumes\n  \"s \\<in> Vinv2\"\n  \"locked_in s r1 v\"\n  \"locked_in s r2 w\"\n  \"r1 < r2\"\nshows\n  \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof- \n  \\<comment> \\<open>To be locked, @{term v} and @{term w} must each have received votes from a quorum.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from assms(2-3)"], ["proof (chain)\npicking this:\n  locked_in s r1 v\n  locked_in s r2 w", "obtain Q1 Q2 \n  where Q12: \"Q1 \\<in> Quorum\" \"Q2 \\<in> Quorum\" \"quorum_for Q1 v (votes s r1)\" \"quorum_for Q2 w (votes s r2)\""], ["proof (prove)\nusing this:\n  locked_in s r1 v\n  locked_in s r2 w\n\ngoal (1 subgoal):\n 1. (\\<And>Q1 Q2.\n        \\<lbrakk>Q1 \\<in> Quorum; Q2 \\<in> Quorum;\n         quorum_for Q1 v (votes s r1); quorum_for Q2 w (votes s r2)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: locked_in_def locked_in_vf_def quorum_for_def)\n  \\<comment> \\<open>By the quorum intersection property, some process from @{term Q1} voted for @{term w}:\\<close>"], ["proof (state)\nthis:\n  Q1 \\<in> Quorum\n  Q2 \\<in> Quorum\n  quorum_for Q1 v (votes s r1)\n  quorum_for Q2 w (votes s r2)\n\ngoal (1 subgoal):\n 1. v = w", "then"], ["proof (chain)\npicking this:\n  Q1 \\<in> Quorum\n  Q2 \\<in> Quorum\n  quorum_for Q1 v (votes s r1)\n  quorum_for Q2 w (votes s r2)", "obtain a where \"a \\<in> Q1\" \"votes s r2 a = Some w\""], ["proof (prove)\nusing this:\n  Q1 \\<in> Quorum\n  Q2 \\<in> Quorum\n  quorum_for Q1 v (votes s r1)\n  quorum_for Q2 w (votes s r2)\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> Q1; votes s r2 a = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using qintersect[OF \\<open>Q1 \\<in> Quorum\\<close> \\<open>Q2 \\<in> Quorum\\<close>]"], ["proof (prove)\nusing this:\n  Q1 \\<in> Quorum\n  Q2 \\<in> Quorum\n  quorum_for Q1 v (votes s r1)\n  quorum_for Q2 w (votes s r2)\n  Q1 \\<inter> Q2 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>a \\<in> Q1; votes s r2 a = Some w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: quorum_for_def)\n  \\<comment> \\<open>But from @{term Vinv2} we conclude that @{term a} could not have defected by voting\n        @{term w}, so @{term ?thesis}:\\<close>"], ["proof (state)\nthis:\n  a \\<in> Q1\n  votes s r2 a = Some w\n\ngoal (1 subgoal):\n 1. v = w", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> Q1\n  votes s r2 a = Some w\n\ngoal (1 subgoal):\n 1. v = w", "using \\<open>s \\<in> Vinv2\\<close> \\<open>quorum_for Q1 v (votes s r1)\\<close> \\<open>r1 < r2\\<close>"], ["proof (prove)\nusing this:\n  a \\<in> Q1\n  votes s r2 a = Some w\n  s \\<in> Vinv2\n  quorum_for Q1 v (votes s r1)\n  r1 < r2\n\ngoal (1 subgoal):\n 1. v = w", "by(fastforce simp add: Vinv2_def no_defection_def quorum_for_def')"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>It is simple to extend the previous theorem to any two (not necessarily different) rounds.\\<close>"], ["", "theorem locked_unique: \nassumes \n  \"s \\<in> Vinv2\"\n  \"v \\<in> locked s\" \"w \\<in> locked s\"\nshows \n  \"v = w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = w", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v = w", "from assms(2-3)"], ["proof (chain)\npicking this:\n  v \\<in> locked s\n  w \\<in> locked s", "obtain r1 r2 where quoIn: \"locked_in s r1 v\" \"locked_in s r2 w\""], ["proof (prove)\nusing this:\n  v \\<in> locked s\n  w \\<in> locked s\n\ngoal (1 subgoal):\n 1. (\\<And>r1 r2.\n        \\<lbrakk>locked_in s r1 v; locked_in s r2 w\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp add: locked_def)"], ["proof (state)\nthis:\n  locked_in s r1 v\n  locked_in s r2 w\n\ngoal (1 subgoal):\n 1. v = w", "have \"r1 < r2 \\<or> r1 = r2 \\<or> r2 < r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r1 < r2 \\<or> r1 = r2 \\<or> r2 < r1", "by (rule linorder_less_linear)"], ["proof (state)\nthis:\n  r1 < r2 \\<or> r1 = r2 \\<or> r2 < r1\n\ngoal (1 subgoal):\n 1. v = w", "thus ?thesis"], ["proof (prove)\nusing this:\n  r1 < r2 \\<or> r1 = r2 \\<or> r2 < r1\n\ngoal (1 subgoal):\n 1. v = w", "proof (elim disjE)"], ["proof (state)\ngoal (3 subgoals):\n 1. r1 < r2 \\<Longrightarrow> v = w\n 2. r1 = r2 \\<Longrightarrow> v = w\n 3. r2 < r1 \\<Longrightarrow> v = w", "assume \"r1 = r2\""], ["proof (state)\nthis:\n  r1 = r2\n\ngoal (3 subgoals):\n 1. r1 < r2 \\<Longrightarrow> v = w\n 2. r1 = r2 \\<Longrightarrow> v = w\n 3. r2 < r1 \\<Longrightarrow> v = w", "with quoIn"], ["proof (chain)\npicking this:\n  locked_in s r1 v\n  locked_in s r2 w\n  r1 = r2", "show ?thesis"], ["proof (prove)\nusing this:\n  locked_in s r1 v\n  locked_in s r2 w\n  r1 = r2\n\ngoal (1 subgoal):\n 1. v = w", "by(simp add: locked_in_def locked_in_vf_same)"], ["proof (state)\nthis:\n  v = w\n\ngoal (2 subgoals):\n 1. r1 < r2 \\<Longrightarrow> v = w\n 2. r2 < r1 \\<Longrightarrow> v = w", "qed(auto intro: locked_in_different[OF \\<open>s \\<in> Vinv2\\<close>] quoIn sym)"], ["proof (state)\nthis:\n  v = w\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We now prove that decisions are stable; once a process makes a decision, it never\n  changes it, and it does not go back to an undecided state. Note that behaviors grow at \n  the front; hence @{term \"tr ! (i-j)\"} is later in the trace than @{term \"tr ! i\"}.\\<close>"], ["", "lemma stable_decision:\n  assumes beh: \"tr \\<in> beh v_TS\"\n  and len: \"i < length tr\"\n  and s: \"s = nth tr i\"\n  and t: \"t = nth tr (i - j)\"\n  and dec: \n    \"decisions s p = Some v\"\n  shows\n    \"decisions t p = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisions t p = Some v", "proof-\n  \\<comment> \\<open>First, we show that the both @{term s} and @{term t} respect the invariants.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. decisions t p = Some v", "have reach: \"s \\<in> reach v_TS\" \"t \\<in> reach v_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach v_TS &&& t \\<in> reach v_TS", "using beh s t len"], ["proof (prove)\nusing this:\n  tr \\<in> beh v_TS\n  s = tr ! i\n  t = tr ! (i - j)\n  i < length tr\n\ngoal (1 subgoal):\n 1. s \\<in> reach v_TS &&& t \\<in> reach v_TS", "apply(simp_all add: reach_equiv_beh_states)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>tr \\<in> beh v_TS; s = tr ! i; t = tr ! (i - j);\n     i < length tr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>beh v_TS. tr ! i \\<in> set x\n 2. \\<lbrakk>tr \\<in> beh v_TS; s = tr ! i; t = tr ! (i - j);\n     i < length tr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>beh v_TS. tr ! (i - j) \\<in> set x", "apply (metis len nth_mem)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tr \\<in> beh v_TS; s = tr ! i; t = tr ! (i - j);\n     i < length tr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>beh v_TS. tr ! (i - j) \\<in> set x", "apply (metis less_imp_diff_less nth_mem)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  s \\<in> reach v_TS\n  t \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "hence invs2: \"s \\<in> Vinv2\" and invs3: \"s \\<in> Vinv3\""], ["proof (prove)\nusing this:\n  s \\<in> reach v_TS\n  t \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. s \\<in> Vinv2 &&& s \\<in> Vinv3", "by(blast dest: Vinv2_invariant[THEN subsetD] Vinv3_invariant[THEN subsetD])+"], ["proof (state)\nthis:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. decisions t p = Some v", "using t"], ["proof (prove)\nusing this:\n  t = tr ! (i - j)\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "proof(induction j arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   t = tr ! (i - j) \\<Longrightarrow>\n                   decisions t p = Some v;\n        t = tr ! (i - Suc j)\\<rbrakk>\n       \\<Longrightarrow> decisions t p = Some v", "case (Suc j)"], ["proof (state)\nthis:\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (2 subgoals):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   t = tr ! (i - j) \\<Longrightarrow>\n                   decisions t p = Some v;\n        t = tr ! (i - Suc j)\\<rbrakk>\n       \\<Longrightarrow> decisions t p = Some v", "hence dec_j: \"decisions (tr ! (i - j)) p = Some v\""], ["proof (prove)\nusing this:\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (1 subgoal):\n 1. decisions (tr ! (i - j)) p = Some v", "by simp"], ["proof (state)\nthis:\n  decisions (tr ! (i - j)) p = Some v\n\ngoal (2 subgoals):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   t = tr ! (i - j) \\<Longrightarrow>\n                   decisions t p = Some v;\n        t = tr ! (i - Suc j)\\<rbrakk>\n       \\<Longrightarrow> decisions t p = Some v", "thus \"decisions t p = Some v\""], ["proof (prove)\nusing this:\n  decisions (tr ! (i - j)) p = Some v\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "using Suc\n    \\<comment> \\<open>As @{term \"(-)\"} is a total function on naturals, we perform a case distinction;\n          if @{term \"i < j\"}, the induction step is trivial.\\<close>"], ["proof (prove)\nusing this:\n  decisions (tr ! (i - j)) p = Some v\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "proof(cases \"i \\<le> j\") \n      \\<comment> \\<open>The non-trivial case.\\<close>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "define t' where \"t' = tr ! (i - j)\"\n      \\<comment> \\<open>Both @{term t} and @{term t'} are reachable, thus respect the invariants, and\n        they are related by the transition relation.\\<close>"], ["proof (state)\nthis:\n  t' = tr ! (i - j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "hence \"t' \\<in> reach v_TS\" \"t \\<in> reach v_TS\""], ["proof (prove)\nusing this:\n  t' = tr ! (i - j)\n\ngoal (1 subgoal):\n 1. t' \\<in> reach v_TS &&& t \\<in> reach v_TS", "using beh len Suc"], ["proof (prove)\nusing this:\n  t' = tr ! (i - j)\n  tr \\<in> beh v_TS\n  i < length tr\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (1 subgoal):\n 1. t' \\<in> reach v_TS &&& t \\<in> reach v_TS", "by (metis beh_in_reach less_imp_diff_less nth_mem)+"], ["proof (state)\nthis:\n  t' \\<in> reach v_TS\n  t \\<in> reach v_TS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "hence invs: \"t' \\<in> Vinv1\" \"t' \\<in> Vinv3\" \"t \\<in> Vinv2\" \"t \\<in> Vinv3\""], ["proof (prove)\nusing this:\n  t' \\<in> reach v_TS\n  t \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. (t' \\<in> Vinv1 &&& t' \\<in> Vinv3) &&& t \\<in> Vinv2 &&& t \\<in> Vinv3", "by(blast dest: Vinv1_invariant[THEN subsetD] Vinv2_invariant[THEN subsetD] \n          Vinv3_invariant[THEN subsetD])+"], ["proof (state)\nthis:\n  t' \\<in> Vinv1\n  t' \\<in> Vinv3\n  t \\<in> Vinv2\n  t \\<in> Vinv3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "hence locked_v: \"v \\<in> locked t'\""], ["proof (prove)\nusing this:\n  t' \\<in> Vinv1\n  t' \\<in> Vinv3\n  t \\<in> Vinv2\n  t \\<in> Vinv3\n\ngoal (1 subgoal):\n 1. v \\<in> locked t'", "using Suc"], ["proof (prove)\nusing this:\n  t' \\<in> Vinv1\n  t' \\<in> Vinv3\n  t \\<in> Vinv2\n  t \\<in> Vinv3\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (1 subgoal):\n 1. v \\<in> locked t'", "by(auto simp add: t'_def intro: ranI)"], ["proof (state)\nthis:\n  v \\<in> locked t'\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "have \"i - j = Suc (i - (Suc j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i - j = Suc (i - Suc j)", "using False"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> j\n\ngoal (1 subgoal):\n 1. i - j = Suc (i - Suc j)", "by simp"], ["proof (state)\nthis:\n  i - j = Suc (i - Suc j)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "hence trans: \"(t', t) \\<in> trans v_TS\""], ["proof (prove)\nusing this:\n  i - j = Suc (i - Suc j)\n\ngoal (1 subgoal):\n 1. (t', t) \\<in> TS.trans v_TS", "using beh len Suc"], ["proof (prove)\nusing this:\n  i - j = Suc (i - Suc j)\n  tr \\<in> beh v_TS\n  i < length tr\n  ?t = tr ! (i - j) \\<Longrightarrow> decisions ?t p = Some v\n  t = tr ! (i - Suc j)\n\ngoal (1 subgoal):\n 1. (t', t) \\<in> TS.trans v_TS", "by(auto simp add: t'_def intro!: beh_consecutive_in_trans)\n      \\<comment> \\<open>Thus @{term v} also remains locked in @{term t}, and @{term p} does not \n        revoke, nor change its decision.\\<close>"], ["proof (state)\nthis:\n  (t', t) \\<in> TS.trans v_TS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "hence locked_v_t: \"v \\<in> locked t\""], ["proof (prove)\nusing this:\n  (t', t) \\<in> TS.trans v_TS\n\ngoal (1 subgoal):\n 1. v \\<in> locked t", "using locked_v"], ["proof (prove)\nusing this:\n  (t', t) \\<in> TS.trans v_TS\n  v \\<in> locked t'\n\ngoal (1 subgoal):\n 1. v \\<in> locked t", "by(auto simp add: v_TS_defs v_round_def\n          intro: locked_preserved[OF invs(1), THEN subsetD, OF _ _ locked_v])"], ["proof (state)\nthis:\n  v \\<in> locked t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "from trans"], ["proof (chain)\npicking this:\n  (t', t) \\<in> TS.trans v_TS", "obtain w where \"decisions t p = Some w\""], ["proof (prove)\nusing this:\n  (t', t) \\<in> TS.trans v_TS\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        decisions t p = Some w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dec_j"], ["proof (prove)\nusing this:\n  (t', t) \\<in> TS.trans v_TS\n  decisions (tr ! (i - j)) p = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>w.\n        decisions t p = Some w \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce simp add: t'_def v_TS_defs v_round_def \n          split: option.split option.split_asm)"], ["proof (state)\nthis:\n  decisions t p = Some w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v\n 2. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "thus ?thesis"], ["proof (prove)\nusing this:\n  decisions t p = Some w\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "using invs(4)[THEN Vinv3D] locked_v_t locked_unique[OF invs(3)]"], ["proof (prove)\nusing this:\n  decisions t p = Some w\n  ran (decisions t) \\<subseteq> locked t\n  v \\<in> locked t\n  \\<lbrakk>?v \\<in> locked t; ?w \\<in> locked t\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "by (metis contra_subsetD ranI)"], ["proof (state)\nthis:\n  decisions t p = Some v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>decisions (tr ! (i - j)) p = Some v;\n     \\<And>t. t = tr ! (i - j) \\<Longrightarrow> decisions t p = Some v;\n     t = tr ! (i - Suc j); i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> decisions t p = Some v", "qed(auto)"], ["proof (state)\nthis:\n  decisions t p = Some v\n\ngoal (1 subgoal):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v", "case 0"], ["proof (state)\nthis:\n  t = tr ! (i - 0)\n\ngoal (1 subgoal):\n 1. \\<And>t. t = tr ! (i - 0) \\<Longrightarrow> decisions t p = Some v", "thus \"decisions t p = Some v\""], ["proof (prove)\nusing this:\n  t = tr ! (i - 0)\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "using assms"], ["proof (prove)\nusing this:\n  t = tr ! (i - 0)\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - j)\n  decisions s p = Some v\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "by auto"], ["proof (state)\nthis:\n  decisions t p = Some v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  decisions t p = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally, we prove that the Voting model ensures agreement. Without a loss \n  of generality, we assume that \\<open>t\\<close> preceeds \\<open>s\\<close> in the trace.\\<close>"], ["", "lemma Voting_agreement:\n  assumes beh: \"tr \\<in> beh v_TS\"\n  and len: \"i < length tr\"\n  and s: \"s = nth tr i\"\n  and t: \"t = nth tr (i - j)\"\n  and dec: \n    \"decisions s p = Some v\"\n    \"decisions t q = Some w\"\n  shows \"w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w = v", "proof-\n  \\<comment> \\<open>Again, we first prove that the invariants hold for @{term s}.\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. w = v", "have reach: \"s \\<in> reach v_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s \\<in> reach v_TS", "using beh s t len"], ["proof (prove)\nusing this:\n  tr \\<in> beh v_TS\n  s = tr ! i\n  t = tr ! (i - j)\n  i < length tr\n\ngoal (1 subgoal):\n 1. s \\<in> reach v_TS", "apply(simp_all add: reach_equiv_beh_states)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>tr \\<in> beh v_TS; s = tr ! i; t = tr ! (i - j);\n     i < length tr\\<rbrakk>\n    \\<Longrightarrow> \\<exists>x\\<in>beh v_TS. tr ! i \\<in> set x", "by (metis nth_mem)"], ["proof (state)\nthis:\n  s \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. w = v", "hence invs2: \"s \\<in> Vinv2\" and invs3: \"s \\<in> Vinv3\""], ["proof (prove)\nusing this:\n  s \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. s \\<in> Vinv2 &&& s \\<in> Vinv3", "by(blast dest: Vinv2_invariant[THEN subsetD] Vinv3_invariant[THEN subsetD])+\n\n  \\<comment> \\<open>We now proceed to prove the thesis by induction.\\<close>"], ["proof (state)\nthis:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n\ngoal (1 subgoal):\n 1. w = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n\ngoal (1 subgoal):\n 1. w = v", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - j)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. w = v", "proof(induction j arbitrary: t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n        i < length tr; s = tr ! i; t = tr ! (i - 0); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "case 0"], ["proof (state)\nthis:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - 0)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n        i < length tr; s = tr ! i; t = tr ! (i - 0); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "hence\n      \"v \\<in> locked (tr ! i)\"\n      \"w \\<in> locked (tr ! i)\""], ["proof (prove)\nusing this:\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - 0)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. v \\<in> locked (tr ! i) &&& w \\<in> locked (tr ! i)", "by(auto intro: ranI)"], ["proof (state)\nthis:\n  v \\<in> locked (tr ! i)\n  w \\<in> locked (tr ! i)\n\ngoal (2 subgoals):\n 1. \\<And>t.\n       \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n        i < length tr; s = tr ! i; t = tr ! (i - 0); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v\n 2. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> locked (tr ! i)\n  w \\<in> locked (tr ! i)\n\ngoal (1 subgoal):\n 1. w = v", "using invs2"], ["proof (prove)\nusing this:\n  v \\<in> locked (tr ! i)\n  w \\<in> locked (tr ! i)\n  s \\<in> Vinv2\n\ngoal (1 subgoal):\n 1. w = v", "using assms 0"], ["proof (prove)\nusing this:\n  v \\<in> locked (tr ! i)\n  w \\<in> locked (tr ! i)\n  s \\<in> Vinv2\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - j)\n  decisions s p = Some v\n  decisions t q = Some w\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - 0)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. w = v", "by(auto dest: locked_unique)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "case (Suc j)"], ["proof (state)\nthis:\n  \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n   s = tr ! i; ?t = tr ! (i - j); decisions s p = Some v;\n   decisions ?t q = Some w\\<rbrakk>\n  \\<Longrightarrow> w = v\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - Suc j)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. \\<And>j t.\n       \\<lbrakk>\\<And>t.\n                   \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                    i < length tr; s = tr ! i; t = tr ! (i - j);\n                    decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                   \\<Longrightarrow> w = v;\n        s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n        s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n        decisions t q = Some w\\<rbrakk>\n       \\<Longrightarrow> w = v", "thus ?thesis\n    \\<comment> \\<open>Again, the totality of @{term \"(-)\"} makes the claim trivial if @{term \"i < j\"}.\\<close>"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n   s = tr ! i; ?t = tr ! (i - j); decisions s p = Some v;\n   decisions ?t q = Some w\\<rbrakk>\n  \\<Longrightarrow> w = v\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - Suc j)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. w = v", "proof(cases \"i \\<le> j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "case False\n      \\<comment> \\<open>In the non-trivial case, the proof follows from the decision stability theorem \n        and the uniqueness of locked values.\\<close>"], ["proof (state)\nthis:\n  \\<not> i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "have dec_t: \"decisions t p = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decisions t p = Some v", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n   s = tr ! i; ?t = tr ! (i - j); decisions s p = Some v;\n   decisions ?t q = Some w\\<rbrakk>\n  \\<Longrightarrow> w = v\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - Suc j)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. decisions t p = Some v", "by(auto intro: stable_decision[OF beh len s ])"], ["proof (state)\nthis:\n  decisions t p = Some v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "have \"t \\<in> reach v_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> reach v_TS", "using beh len Suc"], ["proof (prove)\nusing this:\n  tr \\<in> beh v_TS\n  i < length tr\n  \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n   s = tr ! i; ?t = tr ! (i - j); decisions s p = Some v;\n   decisions ?t q = Some w\\<rbrakk>\n  \\<Longrightarrow> w = v\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - Suc j)\n  decisions s p = Some v\n  decisions t q = Some w\n\ngoal (1 subgoal):\n 1. t \\<in> reach v_TS", "by (metis beh_in_reach less_imp_diff_less nth_mem)"], ["proof (state)\nthis:\n  t \\<in> reach v_TS\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "hence invs: \"t \\<in> Vinv2\" \"t \\<in> Vinv3\""], ["proof (prove)\nusing this:\n  t \\<in> reach v_TS\n\ngoal (1 subgoal):\n 1. t \\<in> Vinv2 &&& t \\<in> Vinv3", "by(blast dest: Vinv2_invariant[THEN subsetD] Vinv3_invariant[THEN subsetD])+"], ["proof (state)\nthis:\n  t \\<in> Vinv2\n  t \\<in> Vinv3\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "from dec_t"], ["proof (chain)\npicking this:\n  decisions t p = Some v", "have \"v \\<in> locked t\""], ["proof (prove)\nusing this:\n  decisions t p = Some v\n\ngoal (1 subgoal):\n 1. v \\<in> locked t", "using invs(2)"], ["proof (prove)\nusing this:\n  decisions t p = Some v\n  t \\<in> Vinv3\n\ngoal (1 subgoal):\n 1. v \\<in> locked t", "by(auto intro: ranI)"], ["proof (state)\nthis:\n  v \\<in> locked t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "moreover"], ["proof (state)\nthis:\n  v \\<in> locked t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "have locked_w_t: \"w \\<in> locked t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. w \\<in> locked t", "using Suc \\<open>t \\<in> Vinv3\\<close>[THEN Vinv3D]"], ["proof (prove)\nusing this:\n  \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n   s = tr ! i; ?t = tr ! (i - j); decisions s p = Some v;\n   decisions ?t q = Some w\\<rbrakk>\n  \\<Longrightarrow> w = v\n  s \\<in> Vinv2\n  s \\<in> Vinv3\n  tr \\<in> beh v_TS\n  i < length tr\n  s = tr ! i\n  t = tr ! (i - Suc j)\n  decisions s p = Some v\n  decisions t q = Some w\n  ran (decisions t) \\<subseteq> locked t\n\ngoal (1 subgoal):\n 1. w \\<in> locked t", "by(auto intro: ranI)"], ["proof (state)\nthis:\n  w \\<in> locked t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v\n 2. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; \\<not> i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "ultimately"], ["proof (chain)\npicking this:\n  v \\<in> locked t\n  w \\<in> locked t", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<in> locked t\n  w \\<in> locked t\n\ngoal (1 subgoal):\n 1. w = v", "using locked_unique[OF \\<open>t \\<in> Vinv2\\<close>]"], ["proof (prove)\nusing this:\n  v \\<in> locked t\n  w \\<in> locked t\n  \\<lbrakk>?v \\<in> locked t; ?w \\<in> locked t\\<rbrakk>\n  \\<Longrightarrow> ?v = ?w\n\ngoal (1 subgoal):\n 1. w = v", "by blast"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>t.\n                \\<lbrakk>s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS;\n                 i < length tr; s = tr ! i; t = tr ! (i - j);\n                 decisions s p = Some v; decisions t q = Some w\\<rbrakk>\n                \\<Longrightarrow> w = v;\n     s \\<in> Vinv2; s \\<in> Vinv3; tr \\<in> beh v_TS; i < length tr;\n     s = tr ! i; t = tr ! (i - Suc j); decisions s p = Some v;\n     decisions t q = Some w; i \\<le> j\\<rbrakk>\n    \\<Longrightarrow> w = v", "qed(auto)"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  w = v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context quorum *)"], ["", "end"]]}