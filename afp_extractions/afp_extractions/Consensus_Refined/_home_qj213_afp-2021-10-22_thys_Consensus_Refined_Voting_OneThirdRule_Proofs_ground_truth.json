{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Voting/OneThirdRule_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemma card_Compl:\n  fixes S :: \"('a :: finite) set\"\n  shows \"card (-S) = card (UNIV :: 'a set) - card S\"", "lemma m_mult_div_Suc_m:\n  \"n > 0 \\<Longrightarrow> m * n div Suc m < n\"", "lemma card_Un_le:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card (A \\<union> B) \\<le> card A + card B\"", "lemma qintersect_card:\n  assumes \"Q \\<in> majs\" \"Q' \\<in> majs\"\n  shows \"card (Q \\<inter> Q') > card (Q \\<inter> -Q')\"", "lemmas OTR_TS_defs = OTR_TS_def CHO_to_TS_def OTR_Alg_def CHOinitConfig_def\n  OTR_initState_def", "lemma decide_origin:\n  assumes \n    send: \"\\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\"\n    and new_dec: \"decision (sc' p) \\<noteq> decision (sc p)\"\n  shows\n    \"\\<exists>v. decision (sc' p) = Some v \\<and> {q. last_vote (sc q) = v} \\<in> majs\"", "lemma MFR_in_msgs:\n  assumes HO:\"dom msgs \\<noteq> {}\"\n      and v: \"MFR msgs v\"\n  shows \"\\<exists>q \\<in> dom msgs. v = the (msgs q)\"", "lemma step_ref:\n  \"{otr_ref_rel} \n      (\\<Union>r v_f d_f. majorities.flv_round r v_f d_f), \n      OTR_trans_step HOs \n    {> otr_ref_rel}\"", "lemma OTR_Refines_LV_VOting:\n  \"PO_refines (otr_ref_rel) \n    majorities.flv_TS (OTR_TS HOs HOs crds)\""], "translations": [["", "lemma card_Compl:\n  fixes S :: \"('a :: finite) set\"\n  shows \"card (-S) = card (UNIV :: 'a set) - card S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (- S) = card UNIV - card S", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (- S) = card UNIV - card S", "have \"card S + card (-S) = card (UNIV :: 'a set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card S + card (- S) = card UNIV", "by(rule card_Un_disjoint[of S \"-S\", simplified Compl_partition, symmetric])\n      (auto)"], ["proof (state)\nthis:\n  card S + card (- S) = card UNIV\n\ngoal (1 subgoal):\n 1. card (- S) = card UNIV - card S", "thus ?thesis"], ["proof (prove)\nusing this:\n  card S + card (- S) = card UNIV\n\ngoal (1 subgoal):\n 1. card (- S) = card UNIV - card S", "by simp"], ["proof (state)\nthis:\n  card (- S) = card UNIV - card S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma m_mult_div_Suc_m:\n  \"n > 0 \\<Longrightarrow> m * n div Suc m < n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow> m * n div Suc m < n", "by (simp add: less_mult_imp_div_less)"], ["", "interpretation majorities: quorum_process majs"], ["proof (prove)\ngoal (1 subgoal):\n 1. quorum_process OneThirdRule_Proofs.majs", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q Q'.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        Q' \\<in> OneThirdRule_Proofs.majs\\<rbrakk>\n       \\<Longrightarrow> Q \\<inter> Q' \\<noteq> {}\n 2. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "fix Q Q'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Q Q'.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        Q' \\<in> OneThirdRule_Proofs.majs\\<rbrakk>\n       \\<Longrightarrow> Q \\<inter> Q' \\<noteq> {}\n 2. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "assume \"Q \\<in> majs\" \"Q' \\<in> majs\""], ["proof (state)\nthis:\n  Q \\<in> OneThirdRule_Proofs.majs\n  Q' \\<in> OneThirdRule_Proofs.majs\n\ngoal (2 subgoals):\n 1. \\<And>Q Q'.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        Q' \\<in> OneThirdRule_Proofs.majs\\<rbrakk>\n       \\<Longrightarrow> Q \\<inter> Q' \\<noteq> {}\n 2. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "hence \"(4 * N) div 3 < card Q + card Q'\""], ["proof (prove)\nusing this:\n  Q \\<in> OneThirdRule_Proofs.majs\n  Q' \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. 4 * N div 3 < card Q + card Q'", "by(auto simp add: majs_def)"], ["proof (state)\nthis:\n  4 * N div 3 < card Q + card Q'\n\ngoal (2 subgoals):\n 1. \\<And>Q Q'.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        Q' \\<in> OneThirdRule_Proofs.majs\\<rbrakk>\n       \\<Longrightarrow> Q \\<inter> Q' \\<noteq> {}\n 2. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "thus \"Q \\<inter> Q' \\<noteq> {}\""], ["proof (prove)\nusing this:\n  4 * N div 3 < card Q + card Q'\n\ngoal (1 subgoal):\n 1. Q \\<inter> Q' \\<noteq> {}", "apply (intro majorities_intersect)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 4 * N div 3 < card Q + card Q' \\<Longrightarrow> N < card Q + card Q'", "apply(auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  Q \\<inter> Q' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "have \"N > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < N", "by auto"], ["proof (state)\nthis:\n  0 < N\n\ngoal (1 subgoal):\n 1. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "have \"2 * N div 3 < N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * N div 3 < N", "by(simp only: eval_nat_numeral m_mult_div_Suc_m[OF \\<open>N > 0\\<close>])"], ["proof (state)\nthis:\n  2 * N div 3 < N\n\ngoal (1 subgoal):\n 1. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "thus \"\\<exists>Q. Q \\<in> majs\""], ["proof (prove)\nusing this:\n  2 * N div 3 < N\n\ngoal (1 subgoal):\n 1. \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs", "apply(rule_tac x=UNIV in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * N div 3 < N \\<Longrightarrow> UNIV \\<in> OneThirdRule_Proofs.majs", "apply(auto simp add: majs_def intro!: div_less_dividend)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<exists>Q. Q \\<in> OneThirdRule_Proofs.majs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma card_Un_le:\n  \"\\<lbrakk> finite A; finite B \\<rbrakk> \\<Longrightarrow> card (A \\<union> B) \\<le> card A + card B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>finite A; finite B\\<rbrakk>\n    \\<Longrightarrow> card (A \\<union> B) \\<le> card A + card B", "by(simp only: card_Un_Int)"], ["", "lemma qintersect_card:\n  assumes \"Q \\<in> majs\" \"Q' \\<in> majs\"\n  shows \"card (Q \\<inter> Q') > card (Q \\<inter> -Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "have \"card (Q \\<inter> -Q') \\<le> card (-Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') \\<le> card (- Q')", "by(auto intro!: card_mono)"], ["proof (state)\nthis:\n  card (Q \\<inter> - Q') \\<le> card (- Q')\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "also"], ["proof (state)\nthis:\n  card (Q \\<inter> - Q') \\<le> card (- Q')\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "have \"... < N - (card (-Q) + card (-Q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "have sum: \"N < card Q + card Q'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N < card Q + card Q'", "using assms"], ["proof (prove)\nusing this:\n  Q \\<in> OneThirdRule_Proofs.majs\n  Q' \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. N < card Q + card Q'", "by(auto simp add: majs_def)"], ["proof (state)\nthis:\n  N < card Q + card Q'\n\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "have le_N: \"card Q \\<le> N\" \"card Q' \\<le> N\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card Q \\<le> N &&& card Q' \\<le> N", "by (auto intro!: card_mono)"], ["proof (state)\nthis:\n  card Q \\<le> N\n  card Q' \\<le> N\n\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "using assms sum"], ["proof (prove)\nusing this:\n  Q \\<in> OneThirdRule_Proofs.majs\n  Q' \\<in> OneThirdRule_Proofs.majs\n  N < card Q + card Q'\n\ngoal (1 subgoal):\n 1. card (- Q') < N - (card (- Q) + card (- Q'))", "apply(simp add: card_Compl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n     Q' \\<in> OneThirdRule_Proofs.majs; N < card Q + card Q'\\<rbrakk>\n    \\<Longrightarrow> N - card Q' < N - (N - card Q + (N - card Q'))", "apply(intro diff_less_mono2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n     Q' \\<in> OneThirdRule_Proofs.majs; N < card Q + card Q'\\<rbrakk>\n    \\<Longrightarrow> N - card Q + (N - card Q') < card Q'\n 2. \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n     Q' \\<in> OneThirdRule_Proofs.majs; N < card Q + card Q'\\<rbrakk>\n    \\<Longrightarrow> N - card Q + (N - card Q') < N", "apply(auto simp add: majs_def card_Compl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * N div 3 < card Q; 2 * N div 3 < card Q';\n     N < card Q + card Q'\\<rbrakk>\n    \\<Longrightarrow> N - card Q + (N - card Q') < N", "apply(simp add: diff_add_assoc2[symmetric, OF le_N(1)] add_diff_assoc[OF le_N(2)])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * N div 3 < card Q; 2 * N div 3 < card Q';\n     N < card Q + card Q'\\<rbrakk>\n    \\<Longrightarrow> N + N - (card Q + card Q') < N", "by (metis add_mono le_N(1) le_N(2) less_diff_conv2 nat_add_left_cancel_less)"], ["proof (state)\nthis:\n  card (- Q') < N - (card (- Q) + card (- Q'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card (- Q') < N - (card (- Q) + card (- Q'))\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "also"], ["proof (state)\nthis:\n  card (- Q') < N - (card (- Q) + card (- Q'))\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "have \"... \\<le> card (Q \\<inter> Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')", "have \"N - (card (-Q) + card (-Q')) \\<le> card (-(-Q \\<union> -Q'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> card (- (- Q \\<union> - Q'))", "apply(simp only: card_Compl[where S=\"-Q \\<union> -Q'\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> N - card (- Q \\<union> - Q')", "apply(auto intro!: diff_le_mono2 card_Un_le)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  N - (card (- Q) + card (- Q')) \\<le> card (- (- Q \\<union> - Q'))\n\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')", "thus ?thesis"], ["proof (prove)\nusing this:\n  N - (card (- Q) + card (- Q')) \\<le> card (- (- Q \\<union> - Q'))\n\ngoal (1 subgoal):\n 1. N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')", "by(auto)"], ["proof (state)\nthis:\n  N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  N - (card (- Q) + card (- Q')) \\<le> card (Q \\<inter> Q')\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "finally"], ["proof (chain)\npicking this:\n  card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "show ?thesis"], ["proof (prove)\nusing this:\n  card (Q \\<inter> - Q') < card (Q \\<inter> Q')\n\ngoal (1 subgoal):\n 1. card (Q \\<inter> - Q') < card (Q \\<inter> Q')", "."], ["proof (state)\nthis:\n  card (Q \\<inter> - Q') < card (Q \\<inter> Q')\n\ngoal:\nNo subgoals!", "qed"], ["", "axiomatization where val_linorder: \n  (* \"class.finite TYPE(process)\" *)\n  \"OFCLASS(val, linorder_class)\""], ["", "instance val :: linorder"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(val, linorder_class)", "by (rule val_linorder)"], ["", "type_synonym p_TS_state = \"(nat \\<times> (process \\<Rightarrow> (val pstate)))\""], ["", "definition K where\n  \"K y \\<equiv> \\<lambda>x. y\""], ["", "definition OTR_Alg where\n  \"OTR_Alg =\n    \\<lparr> CinitState =  (\\<lambda> p st crd. OTR_initState p st),\n     sendMsg =  OTR_sendMsg,\n     CnextState = (\\<lambda> r p st msgs crd st'. OTR_nextState r p st msgs st')\n   \\<rparr>\""], ["", "definition OTR_TS ::\n  \"(round \\<Rightarrow> process HO)\n  \\<Rightarrow> (round \\<Rightarrow> process HO)\n  \\<Rightarrow> (round \\<Rightarrow> process)\n  \\<Rightarrow> p_TS_state TS\"\nwhere\n  \"OTR_TS HOs SHOs crds = CHO_to_TS OTR_Alg HOs SHOs (K o crds)\""], ["", "lemmas OTR_TS_defs = OTR_TS_def CHO_to_TS_def OTR_Alg_def CHOinitConfig_def\n  OTR_initState_def"], ["", "definition\n  \"OTR_trans_step HOs \\<equiv> \\<Union>r \\<mu>.\n   {((r, cfg), Suc r, cfg')|cfg cfg'.\n    (\\<forall>p. \\<mu> p \\<in> get_msgs (OTR_sendMsg r) cfg (HOs r) (HOs r) p) \\<and>\n    (\\<forall>p. OTR_nextState r p (cfg p) (\\<mu> p) (cfg' p))}\""], ["", "definition CSHOnextConfig where\n  \"CSHOnextConfig A r cfg HO SHO coord cfg' \\<equiv>\n   \\<forall>p. \\<exists>\\<mu> \\<in> SHOmsgVectors A r p cfg (HO p) (SHO p).\n          CnextState A r p (cfg p) \\<mu> (coord p) (cfg' p)\""], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition otr_ref_rel :: \"(opt_v_state \\<times> p_TS_state)set\" where\n  \"otr_ref_rel =  {(sa, (r, sc)).\n    r = next_round sa\n    \\<and> (\\<forall>p. decisions sa p = decision (sc p))\n    \\<and> majorities.opt_no_defection sa (Some o last_vote o sc)\n  }\""], ["", "lemma decide_origin:\n  assumes \n    send: \"\\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\"\n    and new_dec: \"decision (sc' p) \\<noteq> decision (sc p)\"\n  shows\n    \"\\<exists>v. decision (sc' p) = Some v \\<and> {q. last_vote (sc q) = v} \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decision (sc' p) = Some v \\<and>\n       {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decision (sc' p) = Some v \\<and>\n       {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "from new_dec and nxt"], ["proof (chain)\npicking this:\n  decision (sc' p) \\<noteq> decision (sc p)\n  OTR_nextState r p (sc p) (\\<mu> p) (sc' p)", "obtain v where \n    p_dec_v: \"decision (sc' p) = Some v\" \n    and two_thirds_v: \"TwoThirds (\\<mu> p) v\""], ["proof (prove)\nusing this:\n  decision (sc' p) \\<noteq> decision (sc p)\n  OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<lbrakk>decision (sc' p) = Some v; TwoThirds (\\<mu> p) v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp add: OTR_nextState_def split: if_split_asm)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v.\n       \\<lbrakk>\\<And>v.\n                   \\<lbrakk>(if Ex (TwoThirds (\\<mu> p))\n                             then Some (Eps (TwoThirds (\\<mu> p)))\n                             else decision (sc p)) =\n                            Some v;\n                    TwoThirds (\\<mu> p) v\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        2 * N div 3 < card {q. \\<exists>y. \\<mu> p q = Some y};\n        TwoThirds (\\<mu> p) x;\n        Some (Eps (TwoThirds (\\<mu> p))) \\<noteq> decision (sc p);\n        TwoThirds (\\<mu> p) v;\n        sc' p =\n        \\<lparr>pstate.last_vote = Min {v. MFR (\\<mu> p) v},\n           decision = Some (SOME v. TwoThirds (\\<mu> p) v)\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> thesis", "by (metis exE_some)"], ["proof (state)\nthis:\n  decision (sc' p) = Some v\n  TwoThirds (\\<mu> p) v\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decision (sc' p) = Some v \\<and>\n       {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "then"], ["proof (chain)\npicking this:\n  decision (sc' p) = Some v\n  TwoThirds (\\<mu> p) v", "have \"2 * N div 3 < card {q. last_vote (sc q) = v}\""], ["proof (prove)\nusing this:\n  decision (sc' p) = Some v\n  TwoThirds (\\<mu> p) v\n\ngoal (1 subgoal):\n 1. 2 * N div 3 < card {q. pstate.last_vote (sc q) = v}", "using send"], ["proof (prove)\nusing this:\n  decision (sc' p) = Some v\n  TwoThirds (\\<mu> p) v\n  \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. 2 * N div 3 < card {q. pstate.last_vote (sc q) = v}", "by(auto simp add: get_msgs_benign OTR_sendMsg_def TwoThirds_def HOV_def \n      restrict_map_def elim!: less_le_trans intro!: card_mono)"], ["proof (state)\nthis:\n  2 * N div 3 < card {q. pstate.last_vote (sc q) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decision (sc' p) = Some v \\<and>\n       {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "with p_dec_v"], ["proof (chain)\npicking this:\n  decision (sc' p) = Some v\n  2 * N div 3 < card {q. pstate.last_vote (sc q) = v}", "show ?thesis"], ["proof (prove)\nusing this:\n  decision (sc' p) = Some v\n  2 * N div 3 < card {q. pstate.last_vote (sc q) = v}\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decision (sc' p) = Some v \\<and>\n       {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "by (auto simp add: majs_def)"], ["proof (state)\nthis:\n  \\<exists>v.\n     decision (sc' p) = Some v \\<and>\n     {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MFR_in_msgs:\n  assumes HO:\"dom msgs \\<noteq> {}\"\n      and v: \"MFR msgs v\"\n  shows \"\\<exists>q \\<in> dom msgs. v = the (msgs q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "from HO"], ["proof (chain)\npicking this:\n  dom msgs \\<noteq> {}", "obtain q where q: \"q \\<in> dom msgs\""], ["proof (prove)\nusing this:\n  dom msgs \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q. q \\<in> dom msgs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> dom msgs\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "with v"], ["proof (chain)\npicking this:\n  MFR msgs v\n  q \\<in> dom msgs", "have \"HOV msgs (the (msgs q)) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  MFR msgs v\n  q \\<in> dom msgs\n\ngoal (1 subgoal):\n 1. HOV msgs (the (msgs q)) \\<noteq> {}", "by (auto simp: HOV_def )"], ["proof (state)\nthis:\n  HOV msgs (the (msgs q)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "hence HOp: \"0 < card (HOV msgs (the (msgs q)))\""], ["proof (prove)\nusing this:\n  HOV msgs (the (msgs q)) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < card (HOV msgs (the (msgs q)))", "by auto"], ["proof (state)\nthis:\n  0 < card (HOV msgs (the (msgs q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "also"], ["proof (state)\nthis:\n  0 < card (HOV msgs (the (msgs q)))\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "from v"], ["proof (chain)\npicking this:\n  MFR msgs v", "have \"\\<dots> \\<le> card (HOV msgs v)\""], ["proof (prove)\nusing this:\n  MFR msgs v\n\ngoal (1 subgoal):\n 1. card (HOV msgs (the (msgs q))) \\<le> card (HOV msgs v)", "by (simp add: MFR_def)"], ["proof (state)\nthis:\n  card (HOV msgs (the (msgs q))) \\<le> card (HOV msgs v)\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "finally"], ["proof (chain)\npicking this:\n  0 < card (HOV msgs v)", "have \"HOV msgs v \\<noteq> {}\""], ["proof (prove)\nusing this:\n  0 < card (HOV msgs v)\n\ngoal (1 subgoal):\n 1. HOV msgs v \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  HOV msgs v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "thus ?thesis"], ["proof (prove)\nusing this:\n  HOV msgs v \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q\\<in>dom msgs. v = the (msgs q)", "by (force simp: HOV_def)"], ["proof (state)\nthis:\n  \\<exists>q\\<in>dom msgs. v = the (msgs q)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_ref:\n  \"{otr_ref_rel} \n      (\\<Union>r v_f d_f. majorities.flv_round r v_f d_f), \n      OTR_trans_step HOs \n    {> otr_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {otr_ref_rel} \\<Union>r v_f.\n                     \\<Union>\n                      (range\n                        (OneThirdRule_Proofs.majorities.flv_round r\n                          v_f)), OTR_trans_step HOs {> otr_ref_rel}", "proof(simp add: PO_rhoare_defs OTR_trans_step_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "fix sa r sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "assume\n    R: \"(sa, r, sc) \\<in> otr_ref_rel\"\n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"\\<forall>p. OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> otr_ref_rel\n  \\<forall>p. \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\n  \\<forall>p. OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "note step=send nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\n  \\<forall>p. OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "define d_f\n    where \"d_f p = (if decision (sc' p) \\<noteq> decision (sc p) then decision (sc' p) else None)\" for p"], ["proof (state)\nthis:\n  d_f ?p =\n  (if decision (sc' ?p) \\<noteq> decision (sc ?p) then decision (sc' ?p)\n   else None)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "define sa' where \"sa' = \\<lparr> \n    opt_v_state.next_round = Suc r\n    , opt_v_state.last_vote = opt_v_state.last_vote sa ++ (Some o last_vote o sc) \n    , opt_v_state.decisions = opt_v_state.decisions sa ++ d_f\n    \\<rparr>\""], ["proof (state)\nthis:\n  sa' =\n  \\<lparr>opt_v_state.next_round = Suc r,\n     last_vote =\n       opt_v_state.last_vote sa ++\n       (Some \\<circ> pstate.last_vote \\<circ> sc),\n     decisions = opt_v_state.decisions sa ++ d_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "have \"majorities.d_guard d_f (Some o last_vote o sc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OneThirdRule_Proofs.majorities.d_guard d_f\n     (Some \\<circ> pstate.last_vote \\<circ> sc)", "proof(clarsimp simp add: majorities.d_guard_def d_f_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decision (sc p);\n        decision (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> OneThirdRule_Proofs.majorities.locked_in_vf\n                          (Some \\<circ> pstate.last_vote \\<circ> sc) v", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decision (sc p);\n        decision (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> OneThirdRule_Proofs.majorities.locked_in_vf\n                          (Some \\<circ> pstate.last_vote \\<circ> sc) v", "assume\n      \"Some v \\<noteq> decision (sc p)\" \n      \"decision (sc' p) = Some v\""], ["proof (state)\nthis:\n  Some v \\<noteq> decision (sc p)\n  decision (sc' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decision (sc p);\n        decision (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> OneThirdRule_Proofs.majorities.locked_in_vf\n                          (Some \\<circ> pstate.last_vote \\<circ> sc) v", "from this and \n      decide_origin[where \\<mu>=\\<mu> and HOs=HOs and sc'=sc', OF send[THEN spec, of p] nxt[THEN spec, of p]]"], ["proof (chain)\npicking this:\n  Some v \\<noteq> decision (sc p)\n  decision (sc' p) = Some v\n  decision (sc' p) \\<noteq> decision (sc p) \\<Longrightarrow>\n  \\<exists>v.\n     decision (sc' p) = Some v \\<and>\n     {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "show \"quorum_process.locked_in_vf majs (Some \\<circ> last_vote \\<circ> sc) v\""], ["proof (prove)\nusing this:\n  Some v \\<noteq> decision (sc p)\n  decision (sc' p) = Some v\n  decision (sc' p) \\<noteq> decision (sc p) \\<Longrightarrow>\n  \\<exists>v.\n     decision (sc' p) = Some v \\<and>\n     {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. OneThirdRule_Proofs.majorities.locked_in_vf\n     (Some \\<circ> pstate.last_vote \\<circ> sc) v", "by(auto simp add: majorities.locked_in_vf_def majorities.quorum_for_def)"], ["proof (state)\nthis:\n  OneThirdRule_Proofs.majorities.locked_in_vf\n   (Some \\<circ> pstate.last_vote \\<circ> sc) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OneThirdRule_Proofs.majorities.d_guard d_f\n   (Some \\<circ> pstate.last_vote \\<circ> sc)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "hence\n    \"(sa, sa') \\<in> majorities.flv_round r (Some o last_vote o sc) d_f\""], ["proof (prove)\nusing this:\n  OneThirdRule_Proofs.majorities.d_guard d_f\n   (Some \\<circ> pstate.last_vote \\<circ> sc)\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> OneThirdRule_Proofs.majorities.flv_round r\n           (Some \\<circ> pstate.last_vote \\<circ> sc) d_f", "using R"], ["proof (prove)\nusing this:\n  OneThirdRule_Proofs.majorities.d_guard d_f\n   (Some \\<circ> pstate.last_vote \\<circ> sc)\n  (sa, r, sc) \\<in> otr_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> OneThirdRule_Proofs.majorities.flv_round r\n           (Some \\<circ> pstate.last_vote \\<circ> sc) d_f", "by(auto simp add: majorities.flv_round_def otr_ref_rel_def sa'_def)"], ["proof (state)\nthis:\n  (sa, sa')\n  \\<in> OneThirdRule_Proofs.majorities.flv_round r\n         (Some \\<circ> pstate.last_vote \\<circ> sc) d_f\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa')\n  \\<in> OneThirdRule_Proofs.majorities.flv_round r\n         (Some \\<circ> pstate.last_vote \\<circ> sc) d_f\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "have \"(sa', Suc r, sc') \\<in> otr_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> otr_ref_rel", "proof(unfold otr_ref_rel_def, safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. \\<And>p. opt_v_state.decisions sa' p = decision (sc' p)\n 3. OneThirdRule_Proofs.majorities.opt_no_defection sa'\n     (Some \\<circ> pstate.last_vote \\<circ> sc')", "fix p"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. \\<And>p. opt_v_state.decisions sa' p = decision (sc' p)\n 3. OneThirdRule_Proofs.majorities.opt_no_defection sa'\n     (Some \\<circ> pstate.last_vote \\<circ> sc')", "show \"opt_v_state.decisions sa' p = decision (sc' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_v_state.decisions sa' p = decision (sc' p)", "using R nxt[THEN spec, of p]"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> otr_ref_rel\n  OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. opt_v_state.decisions sa' p = decision (sc' p)", "by(auto simp add: otr_ref_rel_def sa'_def map_add_def d_f_def OTR_nextState_def\n        split: option.split)"], ["proof (state)\nthis:\n  opt_v_state.decisions sa' p = decision (sc' p)\n\ngoal (2 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. OneThirdRule_Proofs.majorities.opt_no_defection sa'\n     (Some \\<circ> pstate.last_vote \\<circ> sc')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. OneThirdRule_Proofs.majorities.opt_no_defection sa'\n     (Some \\<circ> pstate.last_vote \\<circ> sc')", "show \"quorum_process.opt_no_defection majs sa' (Some \\<circ> last_vote \\<circ> sc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. OneThirdRule_Proofs.majorities.opt_no_defection sa'\n     (Some \\<circ> pstate.last_vote \\<circ> sc')", "proof(clarsimp simp add: sa'_def majorities.opt_no_defection_def map_add_def majorities.quorum_for_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        \\<forall>p\\<in>Q. pstate.last_vote (sc p) = v; a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> pstate.last_vote (sc' a) = v", "fix Q p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        \\<forall>p\\<in>Q. pstate.last_vote (sc p) = v; a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> pstate.last_vote (sc' a) = v", "assume Q: \"Q \\<in> majs\" and Q_v: \"\\<forall>q \\<in> Q. last_vote (sc q) = v\" and p_Q: \"p \\<in> Q\""], ["proof (state)\nthis:\n  Q \\<in> OneThirdRule_Proofs.majs\n  \\<forall>q\\<in>Q. pstate.last_vote (sc q) = v\n  p \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        \\<forall>p\\<in>Q. pstate.last_vote (sc p) = v; a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> pstate.last_vote (sc' a) = v", "hence old: \"last_vote (sc p) = v\""], ["proof (prove)\nusing this:\n  Q \\<in> OneThirdRule_Proofs.majs\n  \\<forall>q\\<in>Q. pstate.last_vote (sc q) = v\n  p \\<in> Q\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc p) = v", "by simp"], ["proof (state)\nthis:\n  pstate.last_vote (sc p) = v\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        \\<forall>p\\<in>Q. pstate.last_vote (sc p) = v; a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> pstate.last_vote (sc' a) = v", "have v_maj: \"{q. last_vote (sc q) = v} \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "using Q Q_v"], ["proof (prove)\nusing this:\n  Q \\<in> OneThirdRule_Proofs.majs\n  \\<forall>q\\<in>Q. pstate.last_vote (sc q) = v\n\ngoal (1 subgoal):\n 1. {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs", "apply(simp add: majs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>2 * N div 3 < card Q;\n     \\<forall>q\\<in>Q. pstate.last_vote (sc q) = v\\<rbrakk>\n    \\<Longrightarrow> 2 * N div 3 < card {q. pstate.last_vote (sc q) = v}", "apply(erule less_le_trans, rule card_mono, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q. pstate.last_vote (sc q) = v} \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> OneThirdRule_Proofs.majs;\n        \\<forall>p\\<in>Q. pstate.last_vote (sc p) = v; a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> pstate.last_vote (sc' a) = v", "show \"last_vote (sc' p) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) = v", "proof(rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "assume new: \"last_vote (sc' p) \\<noteq> v\""], ["proof (state)\nthis:\n  pstate.last_vote (sc' p) \\<noteq> v\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "let ?w = \"last_vote (sc' p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "have \n          w_MFR: \"?w = Min {z. MFR (\\<mu> p) z}\" (is \"?w = Min ?MFRs\") and dom_maj: \"dom (\\<mu> p) \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) = Min {z. MFR (\\<mu> p) z} &&&\n    dom (\\<mu> p) \\<in> OneThirdRule_Proofs.majs", "using old new nxt[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  pstate.last_vote (sc p) = v\n  pstate.last_vote (sc' p) \\<noteq> v\n  OTR_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) = Min {z. MFR (\\<mu> p) z} &&&\n    dom (\\<mu> p) \\<in> OneThirdRule_Proofs.majs", "by(auto simp add: OTR_nextState_def majs_def dom_def split: if_split_asm)"], ["proof (state)\nthis:\n  pstate.last_vote (sc' p) = Min {z. MFR (\\<mu> p) z}\n  dom (\\<mu> p) \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "from dom_maj"], ["proof (chain)\npicking this:\n  dom (\\<mu> p) \\<in> OneThirdRule_Proofs.majs", "have not_empty: \"dom (\\<mu> p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  dom (\\<mu> p) \\<in> OneThirdRule_Proofs.majs\n\ngoal (1 subgoal):\n 1. dom (\\<mu> p) \\<noteq> {}", "by(elim majorities.quorum_non_empty)"], ["proof (state)\nthis:\n  dom (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "from MFR_exists"], ["proof (chain)\npicking this:\n  \\<exists>v. MFR ?msgs v", "obtain mfr_v where mfr_v: \"mfr_v \\<in> ?MFRs\""], ["proof (prove)\nusing this:\n  \\<exists>v. MFR ?msgs v\n\ngoal (1 subgoal):\n 1. (\\<And>mfr_v.\n        mfr_v \\<in> {z. MFR (\\<mu> p) z} \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  mfr_v \\<in> {z. MFR (\\<mu> p) z}\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "from not_empty"], ["proof (chain)\npicking this:\n  dom (\\<mu> p) \\<noteq> {}", "obtain q z where \"\\<mu> p q = Some z\""], ["proof (prove)\nusing this:\n  dom (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q z.\n        \\<mu> p q = Some z \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(fastforce)"], ["proof (state)\nthis:\n  \\<mu> p q = Some z\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "hence \"0 < card (HOV (\\<mu> p) (the (\\<mu> p q)))\""], ["proof (prove)\nusing this:\n  \\<mu> p q = Some z\n\ngoal (1 subgoal):\n 1. 0 < card (HOV (\\<mu> p) (the (\\<mu> p q)))", "by(auto simp add: HOV_def)"], ["proof (state)\nthis:\n  0 < card (HOV (\\<mu> p) (the (\\<mu> p q)))\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "have \"?w \\<in> {z. MFR (\\<mu> p) z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<in> {z. MFR (\\<mu> p) z}", "proof(unfold w_MFR, rule Min_in)"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (Collect (MFR (\\<mu> p)))\n 2. Collect (MFR (\\<mu> p)) \\<noteq> {}", "have \"?MFRs \\<subseteq> (the o (\\<mu> p)) ` (dom (\\<mu> p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {z. MFR (\\<mu> p) z} \\<subseteq> (the \\<circ> \\<mu> p) ` dom (\\<mu> p)", "using not_empty"], ["proof (prove)\nusing this:\n  dom (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. {z. MFR (\\<mu> p) z} \\<subseteq> (the \\<circ> \\<mu> p) ` dom (\\<mu> p)", "by(auto simp: image_def intro: MFR_in_msgs)"], ["proof (state)\nthis:\n  {z. MFR (\\<mu> p) z} \\<subseteq> (the \\<circ> \\<mu> p) ` dom (\\<mu> p)\n\ngoal (2 subgoals):\n 1. finite (Collect (MFR (\\<mu> p)))\n 2. Collect (MFR (\\<mu> p)) \\<noteq> {}", "thus \"finite ?MFRs\""], ["proof (prove)\nusing this:\n  {z. MFR (\\<mu> p) z} \\<subseteq> (the \\<circ> \\<mu> p) ` dom (\\<mu> p)\n\ngoal (1 subgoal):\n 1. finite {z. MFR (\\<mu> p) z}", "by (auto elim: finite_subset)"], ["proof (state)\nthis:\n  finite {z. MFR (\\<mu> p) z}\n\ngoal (1 subgoal):\n 1. Collect (MFR (\\<mu> p)) \\<noteq> {}", "qed(auto simp add: MFR_exists)"], ["proof (state)\nthis:\n  pstate.last_vote (sc' p) \\<in> {z. MFR (\\<mu> p) z}\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "hence card_HOV: \"card (HOV (\\<mu> p) v) \\<le> card (HOV (\\<mu> p) ?w)\""], ["proof (prove)\nusing this:\n  pstate.last_vote (sc' p) \\<in> {z. MFR (\\<mu> p) z}\n\ngoal (1 subgoal):\n 1. card (HOV (\\<mu> p) v)\n    \\<le> card (HOV (\\<mu> p) (pstate.last_vote (sc' p)))", "by(auto simp add: MFR_def)"], ["proof (state)\nthis:\n  card (HOV (\\<mu> p) v)\n  \\<le> card (HOV (\\<mu> p) (pstate.last_vote (sc' p)))\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "have \"dom (\\<mu> p) = HOs r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<mu> p) = HOs r p", "using send[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. dom (\\<mu> p) = HOs r p", "by(auto simp add: get_msgs_def)"], ["proof (state)\nthis:\n  dom (\\<mu> p) = HOs r p\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "from this[symmetric]"], ["proof (chain)\npicking this:\n  HOs r p = dom (\\<mu> p)", "have \"\\<forall>v'. HOV (\\<mu> p) v' = {q. last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)\""], ["proof (prove)\nusing this:\n  HOs r p = dom (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<forall>v'.\n       HOV (\\<mu> p) v' =\n       {q. pstate.last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)", "using send[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  HOs r p = dom (\\<mu> p)\n  \\<mu> p \\<in> get_msgs (OTR_sendMsg r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>v'.\n       HOV (\\<mu> p) v' =\n       {q. pstate.last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)", "by(fastforce simp add: HOV_def get_msgs_benign OTR_sendMsg_def restrict_map_def)"], ["proof (state)\nthis:\n  \\<forall>v'.\n     HOV (\\<mu> p) v' =\n     {q. pstate.last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "hence card_le1: \"card ({q. last_vote (sc q) = v} \\<inter> dom (\\<mu> p)) \\<le> card ({q. last_vote (sc q) = ?w} \\<inter> dom (\\<mu> p))\""], ["proof (prove)\nusing this:\n  \\<forall>v'.\n     HOV (\\<mu> p) v' =\n     {q. pstate.last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)\n\ngoal (1 subgoal):\n 1. card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n    \\<le> card\n           ({q. pstate.last_vote (sc q) = pstate.last_vote (sc' p)} \\<inter>\n            dom (\\<mu> p))", "using card_HOV"], ["proof (prove)\nusing this:\n  \\<forall>v'.\n     HOV (\\<mu> p) v' =\n     {q. pstate.last_vote (sc q) = v'} \\<inter> dom (\\<mu> p)\n  card (HOV (\\<mu> p) v)\n  \\<le> card (HOV (\\<mu> p) (pstate.last_vote (sc' p)))\n\ngoal (1 subgoal):\n 1. card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n    \\<le> card\n           ({q. pstate.last_vote (sc q) = pstate.last_vote (sc' p)} \\<inter>\n            dom (\\<mu> p))", "by(simp)"], ["proof (state)\nthis:\n  card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n  \\<le> card\n         ({q. pstate.last_vote (sc q) = pstate.last_vote (sc' p)} \\<inter>\n          dom (\\<mu> p))\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "have \n          \"card ({q. last_vote (sc q) = v} \\<inter> dom (\\<mu> p)) \\<le> card ({q. last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n    \\<le> card\n           ({q. pstate.last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))", "apply(rule le_trans[OF card_le1], rule card_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. finite ({q. pstate.last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))\n 2. {q. pstate.last_vote (sc q) = pstate.last_vote (sc' p)} \\<inter>\n    dom (\\<mu> p)\n    \\<subseteq> {q. pstate.last_vote (sc q) \\<noteq> v} \\<inter>\n                dom (\\<mu> p)", "apply(auto simp add: new[symmetric])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n  \\<le> card\n         ({q. pstate.last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))\n\ngoal (1 subgoal):\n 1. pstate.last_vote (sc' p) \\<noteq> v \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n  \\<le> card\n         ({q. pstate.last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))\n\ngoal (1 subgoal):\n 1. False", "using qintersect_card[OF dom_maj v_maj]"], ["proof (prove)\nusing this:\n  card ({q. pstate.last_vote (sc q) = v} \\<inter> dom (\\<mu> p))\n  \\<le> card\n         ({q. pstate.last_vote (sc q) \\<noteq> v} \\<inter> dom (\\<mu> p))\n  card (dom (\\<mu> p) \\<inter> - {q. pstate.last_vote (sc q) = v})\n  < card (dom (\\<mu> p) \\<inter> {q. pstate.last_vote (sc q) = v})\n\ngoal (1 subgoal):\n 1. False", "by(simp add: Int_commute Collect_neg_eq)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pstate.last_vote (sc' p) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  OneThirdRule_Proofs.majorities.opt_no_defection sa'\n   (Some \\<circ> pstate.last_vote \\<circ> sc')\n\ngoal (1 subgoal):\n 1. Suc r = opt_v_state.next_round sa'", "qed(auto simp add: sa'_def)"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> otr_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> otr_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (OTR_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. OTR_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> OneThirdRule_Proofs.majorities.flv_round\n x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> otr_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa')\n  \\<in> OneThirdRule_Proofs.majorities.flv_round r\n         (Some \\<circ> pstate.last_vote \\<circ> sc) d_f\n  (sa', Suc r, sc') \\<in> otr_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>ra v_f d_f. (sa, sa') \\<in> quorum_process.flv_round majs ra v_f d_f) \n    \\<and> (sa', Suc r, sc') \\<in> otr_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa')\n  \\<in> OneThirdRule_Proofs.majorities.flv_round r\n         (Some \\<circ> pstate.last_vote \\<circ> sc) d_f\n  (sa', Suc r, sc') \\<in> otr_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>ra v_f d_f.\n           (sa, sa')\n           \\<in> OneThirdRule_Proofs.majorities.flv_round ra v_f d_f) \\<and>\n       (sa', Suc r, sc') \\<in> otr_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>ra v_f d_f.\n         (sa, sa')\n         \\<in> OneThirdRule_Proofs.majorities.flv_round ra v_f d_f) \\<and>\n     (sa', Suc r, sc') \\<in> otr_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma OTR_Refines_LV_VOting:\n  \"PO_refines (otr_ref_rel) \n    majorities.flv_TS (OTR_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines otr_ref_rel OneThirdRule_Proofs.majorities.flv_TS\n     (OTR_TS HOs HOs crds)", "proof(rule refine_basic)"], ["proof (state)\ngoal (2 subgoals):\n 1. init (OTR_TS HOs HOs crds)\n    \\<subseteq> otr_ref_rel `` init OneThirdRule_Proofs.majorities.flv_TS\n 2. {otr_ref_rel} TS.trans\n                   OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                     (OTR_TS HOs HOs crds) {> otr_ref_rel}", "show \"init (OTR_TS HOs HOs crds) \\<subseteq> otr_ref_rel `` init (quorum_process.flv_TS majs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (OTR_TS HOs HOs crds)\n    \\<subseteq> otr_ref_rel `` init OneThirdRule_Proofs.majorities.flv_TS", "by(auto simp add: OTR_TS_def CHO_to_TS_def OTR_Alg_def CHOinitConfig_def OTR_initState_def\n      majorities.flv_TS_def flv_init_def majorities.opt_no_defection_def majorities.quorum_for_def'\n      otr_ref_rel_def)"], ["proof (state)\nthis:\n  init (OTR_TS HOs HOs crds)\n  \\<subseteq> otr_ref_rel `` init OneThirdRule_Proofs.majorities.flv_TS\n\ngoal (1 subgoal):\n 1. {otr_ref_rel} TS.trans\n                   OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                     (OTR_TS HOs HOs crds) {> otr_ref_rel}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {otr_ref_rel} TS.trans\n                   OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                     (OTR_TS HOs HOs crds) {> otr_ref_rel}", "show \n    \"{otr_ref_rel} TS.trans (quorum_process.flv_TS majs), TS.trans (OTR_TS HOs HOs crds) {> otr_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {otr_ref_rel} TS.trans\n                   OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                     (OTR_TS HOs HOs crds) {> otr_ref_rel}", "using step_ref"], ["proof (prove)\nusing this:\n  {otr_ref_rel} \\<Union>r v_f.\n                   \\<Union>\n                    (range\n                      (OneThirdRule_Proofs.majorities.flv_round r\n                        v_f)), OTR_trans_step ?HOs {> otr_ref_rel}\n\ngoal (1 subgoal):\n 1. {otr_ref_rel} TS.trans\n                   OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                     (OTR_TS HOs HOs crds) {> otr_ref_rel}", "by(simp add: majorities.flv_TS_defs OTR_TS_def CHO_to_TS_def OTR_Alg_def \n      CSHO_trans_alt_def CHO_trans_alt OTR_trans_step_def)"], ["proof (state)\nthis:\n  {otr_ref_rel} TS.trans\n                 OneThirdRule_Proofs.majorities.flv_TS, TS.trans\n                   (OTR_TS HOs HOs crds) {> otr_ref_rel}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The termination proof for the algorithm is already given in the Heard-Of Model AFP\n  entry, and we do not repeat it here.\\<close>"], ["", "end"]]}