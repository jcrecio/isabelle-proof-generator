{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Observing/BenOr_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas BenOr_TS_defs = BenOr_TS_def CHO_to_TS_def BenOr_Alg_def CHOinitConfig_def\n  BenOr_initState_def", "lemma two_step_less_D:\n  \"0 < two_step r \\<Longrightarrow> two_step r = Suc 0\"", "lemma BenOr_trans:\n  \"CSHO_trans_alt BenOr_sendMsg (\\<lambda>r p st msgs crd st'. BenOr_nextState r p st msgs st') HOs SHOs crds = \n  BenOr_trans_step HOs SHOs next0 send0 0\n  \\<union> BenOr_trans_step HOs SHOs  next1 send1 1\n  \"", "lemma HOs_intersect:\n  \"HOs r p \\<inter> HOs r' q \\<noteq> {}\"", "lemma HOs_nonempty:\n  \"HOs r p \\<noteq> {}\"", "lemma vote_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"vote (cfg' p) = Some v \\<longleftrightarrow> (\\<forall>q \\<in> HOs r p. x (cfg q) = v)\"", "lemma same_new_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  obtains v where \"\\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v\"", "lemma no_x_change:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"x (cfg' p) = x (cfg p)\"", "lemma no_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows\n    \"no_vote_diff cfg' p\"", "lemma step0_ref:\n  \"{ref_rel} \\<Union>r S v. tso_round0 r S v, \n    BenOr_trans_step HOs HOs next0 send0 0 {> ref_rel}\"", "lemma decide_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  shows \n    \"D cfg cfg' \\<subseteq> {p. \\<exists>v. decide (cfg' p) = Some v \\<and> (\\<forall>q \\<in> HOs r p. vote (cfg q) = Some v)}\"", "lemma step1_ref:\n  \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV} \\<Union>r d_f o_f. tso_round1 r d_f o_f, \n    BenOr_trans_step HOs HOs next1 send1 (Suc 0) {> ref_rel}\"", "lemma BenOr_Refines_Two_Step_Obs:\n  \"PO_refines (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV)\n    tso_TS (BenOr_TS HOs HOs crds)\"", "theorem BenOr_termination:\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], "translations": [["", "lemmas BenOr_TS_defs = BenOr_TS_def CHO_to_TS_def BenOr_Alg_def CHOinitConfig_def\n  BenOr_initState_def"], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "definition BenOr_trans_step \n  where\n  \"BenOr_trans_step HOs SHOs nxt_f snd_f stp \\<equiv> \\<Union>r \\<mu>.\n    {((r, cfg), (Suc r, cfg'))|cfg cfg'. two_step r = stp  \\<and> (\\<forall>p.\n      \\<mu> p \\<in> get_msgs (snd_f r) cfg (HOs r) (SHOs r) p\n      \\<and> nxt_f r p (cfg p) (\\<mu> p) (cfg' p)\n    )}\""], ["", "lemma two_step_less_D:\n  \"0 < two_step r \\<Longrightarrow> two_step r = Suc 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < two_step r \\<Longrightarrow> two_step r = Suc 0", "by(auto simp add: two_step_def)"], ["", "lemma BenOr_trans:\n  \"CSHO_trans_alt BenOr_sendMsg (\\<lambda>r p st msgs crd st'. BenOr_nextState r p st msgs st') HOs SHOs crds = \n  BenOr_trans_step HOs SHOs next0 send0 0\n  \\<union> BenOr_trans_step HOs SHOs  next1 send1 1\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt BenOr_sendMsg\n     (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds =\n    BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. CSHO_trans_alt BenOr_sendMsg\n     (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n                BenOr_trans_step HOs SHOs next1 send1 1\n 2. BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n                 (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs\n                 SHOs crds", "show \"CSHO_trans_alt BenOr_sendMsg (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> BenOr_trans_step HOs SHOs next0 send0 0 \\<union> BenOr_trans_step HOs SHOs next1 send1 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt BenOr_sendMsg\n     (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds\n    \\<subseteq> BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n                BenOr_trans_step HOs SHOs next1 send1 1", "by(force simp add: CSHO_trans_alt_def BenOr_sendMsg_def BenOr_nextState_def BenOr_trans_step_def \n    K_def dest!: two_step_less_D)"], ["proof (state)\nthis:\n  CSHO_trans_alt BenOr_sendMsg\n   (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds\n  \\<subseteq> BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n              BenOr_trans_step HOs SHOs next1 send1 1\n\ngoal (1 subgoal):\n 1. BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n                 (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs\n                 SHOs crds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n                 (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs\n                 SHOs crds", "show \" BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n        (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs SHOs crds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n    BenOr_trans_step HOs SHOs next1 send1 1\n    \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n                 (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs\n                 SHOs crds", "by(force simp add: CSHO_trans_alt_def BenOr_sendMsg_def BenOr_nextState_def BenOr_trans_step_def)"], ["proof (state)\nthis:\n  BenOr_trans_step HOs SHOs next0 send0 0 \\<union>\n  BenOr_trans_step HOs SHOs next1 send1 1\n  \\<subseteq> CSHO_trans_alt BenOr_sendMsg\n               (\\<lambda>r p st msgs crd. BenOr_nextState r p st msgs) HOs\n               SHOs crds\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \"BenOr_A = CHOAlgorithm.truncate BenOr_M\""], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>Agreement for BenOr only holds if the communication predicates hold\\<close>"], ["", "context\n  fixes\n    HOs :: \"nat \\<Rightarrow> process \\<Rightarrow> process set\"\n    and rho :: \"nat \\<Rightarrow> process \\<Rightarrow> val pstate\"\n  assumes comm_global: \"BenOr_commGlobal HOs\"\n  and per_rd: \"\\<forall>r. BenOr_commPerRd (HOs r)\"\n  and run: \"HORun BenOr_A rho HOs\"\nbegin"], ["", "(******************************************************************************)"], ["", "definition no_vote_diff where\n  \"no_vote_diff sc p \\<equiv> vote (sc p) = None \\<longrightarrow>\n            (\\<exists>q q'. x (sc q) \\<noteq> x (sc q'))\""], ["", "definition ref_rel :: \"(tso_state \\<times> ben_or_TS_state)set\" where\n  \"ref_rel \\<equiv> {(sa, (r, sc)).\n    r = next_round sa\n    \\<and> (two_step r = 1 \\<longrightarrow> r_votes sa = vote o sc)\n    \\<and> (two_step r = 1 \\<longrightarrow> (\\<forall>p. no_vote_diff sc p))\n    \\<and> (\\<forall>p v. x (sc p) = v \\<longrightarrow> (\\<exists>q. last_obs sa q \\<in> {None, Some v}))\n    \\<and> decisions sa = decide o sc\n  }\""], ["", "lemma HOs_intersect:\n  \"HOs r p \\<inter> HOs r' q \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r p \\<inter> HOs r' q \\<noteq> {}", "using per_rd"], ["proof (prove)\nusing this:\n  \\<forall>r. BenOr_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. HOs r p \\<inter> HOs r' q \\<noteq> {}", "apply(simp add: BenOr_commPerRd_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>r p. HOs r p \\<in> Quorum \\<Longrightarrow>\n    HOs r p \\<inter> HOs r' q \\<noteq> {}", "apply(blast dest: qintersect)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma HOs_nonempty:\n  \"HOs r p \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r p \\<noteq> {}", "using HOs_intersect"], ["proof (prove)\nusing this:\n  HOs ?r ?p \\<inter> HOs ?r' ?q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. HOs r p \\<noteq> {}", "by blast"], ["", "lemma vote_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"vote (cfg' p) = Some v \\<longleftrightarrow> (\\<forall>q \\<in> HOs r p. x (cfg q) = v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (vote (cfg' p) = Some v) = (\\<forall>q\\<in>HOs r p. x (cfg q) = v)", "using send[THEN spec, where x=p] step[THEN spec, where x=p] step_r HOs_nonempty"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  two_step r = 0\n  HOs ?r ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (vote (cfg' p) = Some v) = (\\<forall>q\\<in>HOs r p. x (cfg q) = v)", "by(auto simp add: next0_def get_msgs_benign send0_def msgRcvd_def o_def restrict_map_def)"], ["", "lemma same_new_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  obtains v where \"\\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p w.\n           vote (cfg' p) = Some w \\<longrightarrow> w = v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases \"\\<exists>p v. vote (cfg' p) = Some v\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "case True"], ["proof (state)\nthis:\n  \\<exists>p v. vote (cfg' p) = Some v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume asm: \"\\<And>v. \\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<forall>p w.\n     vote (cfg' p) = Some w \\<longrightarrow> w = ?v2 \\<Longrightarrow>\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "from True"], ["proof (chain)\npicking this:\n  \\<exists>p v. vote (cfg' p) = Some v", "obtain p v where \"vote (cfg' p) = Some v\""], ["proof (prove)\nusing this:\n  \\<exists>p v. vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>p v.\n        vote (cfg' p) = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  vote (cfg' p) = Some v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v\" (is \"?LV(v)\")"], ["proof (prove)\nusing this:\n  vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v", "using vote_origin[OF send step step_r] HOs_intersect"], ["proof (prove)\nusing this:\n  vote (cfg' p) = Some v\n  (vote (cfg' ?p) = Some ?v) = (\\<forall>q\\<in>HOs r ?p. x (cfg q) = ?v)\n  HOs ?r ?p \\<inter> HOs ?r' ?q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v", "by(force)"], ["proof (state)\nthis:\n  \\<forall>p w. vote (cfg' p) = Some w \\<longrightarrow> w = v\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<exists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "from asm[OF this]"], ["proof (chain)\npicking this:\n  thesis", "show ?thesis"], ["proof (prove)\nusing this:\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "."], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p w.\n                   vote (cfg' p) = Some w \\<longrightarrow>\n                   w = v \\<Longrightarrow>\n                thesis;\n     \\<nexists>p v. vote (cfg' p) = Some v\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed(auto)"], ["", "lemma no_x_change:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows \n    \"x (cfg' p) = x (cfg p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (cfg' p) = x (cfg p)", "using send[THEN spec, where x=p] step[THEN spec, where x=p] step_r HOs_nonempty"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  two_step r = 0\n  HOs ?r ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. x (cfg' p) = x (cfg p)", "by(auto simp add: next0_def get_msgs_benign send0_def msgRcvd_def o_def restrict_map_def)"], ["", "lemma no_vote:\n  assumes \n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = 0\"\n  shows\n    \"no_vote_diff cfg' p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_vote_diff cfg' p", "unfolding no_vote_diff_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vote (cfg' p) = None \\<longrightarrow>\n    (\\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q'))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. vote (cfg' p) = None \\<Longrightarrow>\n    \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')", "assume\n    \"vote (cfg' p) = None\""], ["proof (state)\nthis:\n  vote (cfg' p) = None\n\ngoal (1 subgoal):\n 1. vote (cfg' p) = None \\<Longrightarrow>\n    \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')", "hence \"(\\<exists>q q'. x (cfg q) \\<noteq> x (cfg q'))\""], ["proof (prove)\nusing this:\n  vote (cfg' p) = None\n\ngoal (1 subgoal):\n 1. \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')", "using send[THEN spec, where x=p] step[THEN spec, where x=p] step_r HOs_nonempty"], ["proof (prove)\nusing this:\n  vote (cfg' p) = None\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  two_step r = 0\n  HOs ?r ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')", "apply(clarsimp simp add: next0_def get_msgs_benign send0_def msgRcvd_def o_def restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>v.\n                \\<exists>q.\n                   (q \\<in> HOs r p \\<longrightarrow>\n                    x (cfg q) \\<noteq> v) \\<and>\n                   q \\<in> HOs r p;\n     \\<mu> p =\n     (\\<lambda>xa.\n         if xa \\<in> HOs r p then Some (Val (x (cfg xa))) else None);\n     two_step r = 0; \\<And>r p. HOs r p \\<noteq> {};\n     cfg' p = vote_update Map.empty (cfg p)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')", "by metis"], ["proof (state)\nthis:\n  \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')\n\ngoal (1 subgoal):\n 1. vote (cfg' p) = None \\<Longrightarrow>\n    \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')", "thus \"(\\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q'))\""], ["proof (prove)\nusing this:\n  \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')\n\ngoal (1 subgoal):\n 1. \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')", "using no_x_change[OF send step step_r]"], ["proof (prove)\nusing this:\n  \\<exists>q q'. x (cfg q) \\<noteq> x (cfg q')\n  x (cfg' ?p) = x (cfg ?p)\n\ngoal (1 subgoal):\n 1. \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')", "by(simp)"], ["proof (state)\nthis:\n  \\<exists>q q'. x (cfg' q) \\<noteq> x (cfg' q')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step0_ref:\n  \"{ref_rel} \\<Union>r S v. tso_round0 r S v, \n    BenOr_trans_step HOs HOs next0 send0 0 {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel} \\<Union>r S.\n                 \\<Union>\n                  (range\n                    (tso_round0 r\n                      S)), BenOr_trans_step HOs HOs next0 send0\n                            0 {> ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs BenOr_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix sa r cfg \\<mu> cfg'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume\n    R: \"(sa, (r, cfg)) \\<in> ref_rel\"\n    and step_r: \"two_step r = 0\" \n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n    and step: \"\\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\""], ["proof (state)\nthis:\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "have next_r: \"next_round sa = r\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. opt_obsv_state.next_round sa = r", "by(simp add: ref_rel_def)"], ["proof (state)\nthis:\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from HOs_nonempty send"], ["proof (chain)\npicking this:\n  HOs ?r ?p \\<noteq> {}\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p", "have \"\\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\""], ["proof (prove)\nusing this:\n  HOs ?r ?p \\<noteq> {}\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)", "by(fastforce simp add: get_msgs_benign send0_def msgRcvd_def restrict_map_def)"], ["proof (state)\nthis:\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "with step"], ["proof (chain)\npicking this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)", "have same_dec: \"decide o cfg' = decide o cfg\""], ["proof (prove)\nusing this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\n\ngoal (1 subgoal):\n 1. decide \\<circ> cfg' = decide \\<circ> cfg", "apply(simp add: next0_def o_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>p.\n                (\\<exists>v.\n                    (\\<forall>q\\<in>msgRcvd (\\<mu> p).\n                        \\<mu> p q = Some (Val v)) \\<and>\n                    cfg' p = cfg p\\<lparr>vote := Some v\\<rparr>) \\<or>\n                (\\<forall>v.\n                    \\<exists>q\\<in>msgRcvd (\\<mu> p).\n                       \\<mu> p q \\<noteq> Some (Val v)) \\<and>\n                cfg' p = vote_update Map.empty (cfg p);\n     \\<forall>p. \\<exists>q. q \\<in> msgRcvd (\\<mu> p)\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>x. decide (cfg' x)) =\n                      (\\<lambda>x. decide (cfg x))", "by (metis pstate.select_convs(3) pstate.surjective pstate.update_convs(2))"], ["proof (state)\nthis:\n  decide \\<circ> cfg' = decide \\<circ> cfg\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define S where \"S = {p. \\<exists>v. vote (cfg' p) = Some v}\""], ["proof (state)\nthis:\n  S = {p. \\<exists>v. vote (cfg' p) = Some v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from same_new_vote[OF send step step_r]"], ["proof (chain)\npicking this:\n  (\\<And>v.\n      \\<forall>p w.\n         vote (cfg' p) = Some w \\<longrightarrow> w = v \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain v where v: \"\\<forall>p \\<in> S. vote (cfg' p) = Some v\""], ["proof (prove)\nusing this:\n  (\\<And>v.\n      \\<forall>p w.\n         vote (cfg' p) = Some w \\<longrightarrow> w = v \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. vote (cfg' p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(simp add: S_def) (metis)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence vote_const_map: \"vote o cfg' = const_map v S\""], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S. vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. vote \\<circ> cfg' = const_map v S", "by(auto simp add: S_def const_map_def restrict_map_def intro!: ext)"], ["proof (state)\nthis:\n  vote \\<circ> cfg' = const_map v S\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define sa' where \"sa' = sa\\<lparr> next_round := Suc r, r_votes := const_map v S \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_obsv_state.next_round := Suc r,\n     r_votes := const_map v S\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v", "using vote_origin[OF send step step_r] R per_rd[THEN spec, of r] v"], ["proof (prove)\nusing this:\n  (vote (cfg' ?p) = Some ?v) = (\\<forall>q\\<in>HOs r ?p. x (cfg q) = ?v)\n  (sa, r, cfg) \\<in> ref_rel\n  BenOr_commPerRd (HOs r)\n  \\<forall>p\\<in>S. vote (cfg' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v", "apply(clarsimp simp add: BenOr_commPerRd_def opt_obs_safe_def ref_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<And>p v.\n                   (vote (cfg' p) = Some v) =\n                   (\\<forall>q\\<in>HOs (opt_obsv_state.next_round sa) p.\n                       x (cfg q) = v);\n        \\<forall>p. HOs (opt_obsv_state.next_round sa) p \\<in> Quorum;\n        \\<forall>p\\<in>S.\n           \\<forall>q\\<in>HOs (opt_obsv_state.next_round sa) p.\n              x (cfg q) = v;\n        r = opt_obsv_state.next_round sa;\n        two_step (opt_obsv_state.next_round sa) = Suc 0 \\<longrightarrow>\n        r_votes sa = vote \\<circ> cfg;\n        two_step (opt_obsv_state.next_round sa) = Suc 0 \\<longrightarrow>\n        All (no_vote_diff cfg);\n        \\<forall>p.\n           \\<exists>q.\n              last_obs sa q = None \\<or> last_obs sa q = Some (x (cfg p));\n        opt_obsv_state.decisions sa = decide \\<circ> cfg; p \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p.\n                            last_obs sa p = None \\<or>\n                            last_obs sa p = Some v", "by metis"], ["proof (state)\nthis:\n  \\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence \"(sa, sa') \\<in> tso_round0 r S v\""], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round0 r S v", "using next_r step_r v R \n    vote_origin[OF send step step_r]"], ["proof (prove)\nusing this:\n  \\<forall>p. p \\<in> S \\<longrightarrow> opt_obs_safe (last_obs sa) v\n  opt_obsv_state.next_round sa = r\n  two_step r = 0\n  \\<forall>p\\<in>S. vote (cfg' p) = Some v\n  (sa, r, cfg) \\<in> ref_rel\n  (vote (cfg' ?p) = Some ?v) = (\\<forall>q\\<in>HOs r ?p. x (cfg q) = ?v)\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round0 r S v", "by(auto simp add: tso_round0_def sa'_def all_conj_distrib)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round0 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round0 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"(sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "using step send v R same_dec step_r next_r"], ["proof (prove)\nusing this:\n  \\<forall>p. next0 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n  \\<forall>p\\<in>S. vote (cfg' p) = Some v\n  (sa, r, cfg) \\<in> ref_rel\n  decide \\<circ> cfg' = decide \\<circ> cfg\n  two_step r = 0\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "apply(auto simp add: ref_rel_def sa'_def  two_step_phase_Suc vote_const_map next0_def\n      all_conj_distrib no_vote[OF send step step_r])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p.\n                   (\\<exists>v.\n                       (\\<forall>q\\<in>msgRcvd (\\<mu> p).\n                           \\<mu> p q = Some (Val v)) \\<and>\n                       cfg' p = cfg p\\<lparr>vote := Some v\\<rparr>) \\<or>\n                   (\\<forall>v.\n                       \\<exists>q\\<in>msgRcvd (\\<mu> p).\n                          \\<mu> p q \\<noteq> Some (Val v)) \\<and>\n                   cfg' p = vote_update Map.empty (cfg p);\n        \\<forall>p.\n           \\<mu> p\n           \\<in> get_msgs (send0 (opt_obsv_state.next_round sa)) cfg\n                  (HOs (opt_obsv_state.next_round sa))\n                  (HOs (opt_obsv_state.next_round sa)) p;\n        \\<forall>p\\<in>S. vote (cfg' p) = Some v;\n        decide \\<circ> cfg' = decide \\<circ> cfg;\n        two_step (opt_obsv_state.next_round sa) = 0;\n        r = opt_obsv_state.next_round sa;\n        \\<forall>p.\n           \\<exists>q.\n              last_obs sa q = None \\<or> last_obs sa q = Some (x (cfg p));\n        opt_obsv_state.decisions sa = decide \\<circ> cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            last_obs sa q = None \\<or>\n                            last_obs sa q = Some (x (cfg' p))", "by (metis pstate.select_convs(1) pstate.surjective pstate.update_convs(2))"], ["proof (state)\nthis:\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; two_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round0 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> tso_round0 r S v\n  (sa', Suc r, cfg') \\<in> ref_rel", "show\n    \"\\<exists>sa'. (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and> (sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> tso_round0 r S v\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and>\n       (sa', Suc r, cfg') \\<in> ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r S v. (sa, sa') \\<in> tso_round0 r S v) \\<and>\n     (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "definition D where\n  \"D cfg cfg' \\<equiv> {p. decide (cfg' p) \\<noteq> decide (cfg p) }\""], ["", "lemma decide_origin:\n  assumes\n  send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n  and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n  and step_r: \"two_step r = Suc 0\"\n  shows \n    \"D cfg cfg' \\<subseteq> {p. \\<exists>v. decide (cfg' p) = Some v \\<and> (\\<forall>q \\<in> HOs r p. vote (cfg q) = Some v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D cfg cfg'\n    \\<subseteq> {p. \\<exists>v.\n                       decide (cfg' p) = Some v \\<and>\n                       (\\<forall>q\\<in>HOs r p. vote (cfg q) = Some v)}", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. D cfg cfg'\n    \\<subseteq> {p. \\<exists>v.\n                       decide (cfg' p) = Some v \\<and>\n                       (\\<forall>q\\<in>HOs r p. vote (cfg q) = Some v)}", "by(fastforce simp add: D_def next1_def get_msgs_benign send1_def msgRcvd_def o_def restrict_map_def\n    x_update_def dec_update_def identicalVoteRcvd_def all_conj_distrib someVoteRcvd_def isVote_def)"], ["", "lemma step1_ref:\n  \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV} \\<Union>r d_f o_f. tso_round1 r d_f o_f, \n    BenOr_trans_step HOs HOs next1 send1 (Suc 0) {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} \\<Union>r d_f.\n              \\<Union>\n               (range\n                 (tso_round1 r\n                   d_f)), BenOr_trans_step HOs HOs next1 send1\n                           (Suc 0) {> ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs BenOr_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix sa r cfg \\<mu> and cfg' :: \"process \\<Rightarrow> val pstate\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume\n    R: \"(sa, (r, cfg)) \\<in> ref_rel\"\n    and step_r: \"two_step r = Suc 0\" \n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\"\n    and step: \"\\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\"\n    and ainv: \"sa \\<in> TSO_inv1\"\n    and ainv2: \"sa \\<in> TSO_inv2\""], ["proof (state)\nthis:\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  sa \\<in> TSO_inv1\n  sa \\<in> TSO_inv2\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "have next_r: \"next_round sa = r\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. opt_obsv_state.next_round sa = r", "by(simp add: ref_rel_def)"], ["proof (state)\nthis:\n  opt_obsv_state.next_round sa = r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define S where \"S = {p. \\<exists>v. vote (cfg p) = Some v}\""], ["proof (state)\nthis:\n  S = {p. \\<exists>v. vote (cfg p) = Some v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from R"], ["proof (chain)\npicking this:\n  (sa, r, cfg) \\<in> ref_rel", "obtain v where v: \"\\<forall>p \\<in> S. vote (cfg p) = Some v\""], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. vote (cfg p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ainv step_r"], ["proof (prove)\nusing this:\n  (sa, r, cfg) \\<in> ref_rel\n  sa \\<in> TSO_inv1\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S. vote (cfg p) = Some v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ref_rel_def TSO_inv1_def S_def)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. vote (cfg p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define Ob where \"Ob = {p. x (cfg' p) = v}\""], ["proof (state)\nthis:\n  Ob = {p. x (cfg' p) = v}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define o_f where \"o_f p = (if S \\<in> Quorum then Some v else None)\" for p :: process"], ["proof (state)\nthis:\n  o_f ?p = (if S \\<in> Quorum then Some v else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define dec_f where \"dec_f p = (if p \\<in> D cfg cfg' then decide (cfg' p) else None)\" for p"], ["proof (state)\nthis:\n  dec_f ?p = (if ?p \\<in> D cfg cfg' then decide (cfg' ?p) else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "{"], ["proof (state)\nthis:\n  dec_f ?p = (if ?p \\<in> D cfg cfg' then decide (cfg' ?p) else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "fix p w"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "assume \"vote (cfg p) = Some w\""], ["proof (state)\nthis:\n  vote (cfg p) = Some w\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "hence \"w = v\""], ["proof (prove)\nusing this:\n  vote (cfg p) = Some w\n\ngoal (1 subgoal):\n 1. w = v", "using v"], ["proof (prove)\nusing this:\n  vote (cfg p) = Some w\n  \\<forall>p\\<in>S. vote (cfg p) = Some v\n\ngoal (1 subgoal):\n 1. w = v", "by(unfold S_def, auto)"], ["proof (state)\nthis:\n  w = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "}"], ["proof (state)\nthis:\n  vote (cfg ?p4) = Some ?w4 \\<Longrightarrow> ?w4 = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note v'=this"], ["proof (state)\nthis:\n  vote (cfg ?p4) = Some ?w4 \\<Longrightarrow> ?w4 = v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have d_guard: \"d_guard dec_f (vote \\<circ> cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d_guard dec_f (vote \\<circ> cfg)", "using per_rd[THEN spec, of r]"], ["proof (prove)\nusing this:\n  BenOr_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. d_guard dec_f (vote \\<circ> cfg)", "by(fastforce simp add: d_guard_def locked_in_vf_def quorum_for_def dec_f_def\n      BenOr_commPerRd_def dest!: decide_origin[OF send step step_r, THEN subsetD])"], ["proof (state)\nthis:\n  d_guard dec_f (vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"dom (vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV", "proof(auto simp add: Ob_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "assume Q: \"dom (vote \\<circ> cfg) \\<in> Quorum\" (is \"?Q \\<in> Quorum\")"], ["proof (state)\nthis:\n  dom (vote \\<circ> cfg) \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "hence \"?Q \\<inter> HOs r p \\<noteq> {}\""], ["proof (prove)\nusing this:\n  dom (vote \\<circ> cfg) \\<in> Quorum\n\ngoal (1 subgoal):\n 1. dom (vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}", "using per_rd[THEN spec, of r]"], ["proof (prove)\nusing this:\n  dom (vote \\<circ> cfg) \\<in> Quorum\n  BenOr_commPerRd (HOs r)\n\ngoal (1 subgoal):\n 1. dom (vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}", "by(auto simp add: BenOr_commPerRd_def dest: qintersect)"], ["proof (state)\nthis:\n  dom (vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "hence \"someVoteRcvd (\\<mu> p) \\<noteq> {}\""], ["proof (prove)\nusing this:\n  dom (vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  dom (vote \\<circ> cfg) \\<inter> HOs r p \\<noteq> {}\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. someVoteRcvd (\\<mu> p) \\<noteq> {}", "by(force simp add: someVoteRcvd_def get_msgs_benign msgRcvd_def restrict_map_def \n        isVote_def send1_def)"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "moreover"], ["proof (state)\nthis:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "have \"\\<forall>q \\<in> someVoteRcvd (\\<mu> p). \\<exists>x'. \\<mu> p q = Some (Vote (Some v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n       \\<exists>x'. \\<mu> p q = Some (Vote (Some v))", "using send[THEN spec, of p]"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n       \\<exists>x'. \\<mu> p q = Some (Vote (Some v))", "by(auto simp add: someVoteRcvd_def get_msgs_benign msgRcvd_def restrict_map_def\n        isVote_def send1_def dest: v')"], ["proof (state)\nthis:\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> x (cfg' xa) = v", "ultimately"], ["proof (chain)\npicking this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (Vote (Some v))", "show \"x (cfg' p) = v\""], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (Vote (Some v))\n\ngoal (1 subgoal):\n 1. x (cfg' p) = v", "using step[THEN spec, of p]"], ["proof (prove)\nusing this:\n  someVoteRcvd (\\<mu> p) \\<noteq> {}\n  \\<forall>q\\<in>someVoteRcvd (\\<mu> p).\n     \\<exists>x'. \\<mu> p q = Some (Vote (Some v))\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. x (cfg' p) = v", "by(auto simp add: next1_def x_update_def)"], ["proof (state)\nthis:\n  x (cfg' p) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom (vote \\<circ> cfg) \\<in> Quorum \\<longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note Ob_UNIV=this[rule_format]"], ["proof (state)\nthis:\n  dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have obs_guard: \"obs_guard o_f (vote \\<circ> cfg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. obs_guard o_f (vote \\<circ> cfg)", "apply(auto simp add: obs_guard_def o_f_def S_def dom_def\n      dest: v' Ob_UNIV quorum_non_empty)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {p. \\<exists>v. vote (cfg p) = Some v} \\<in> Quorum \\<Longrightarrow>\n    \\<exists>q.\n       (\\<exists>y. vote (cfg q) = Some y) \\<and> Some v = vote (cfg q)", "apply (metis S_def all_not_in_conv  empty_not_quorum v)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  obs_guard o_f (vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "define sa' where \"sa' = sa\\<lparr> \n    next_round := Suc (next_round sa)\n    , decisions := decisions sa ++ dec_f\n    , last_obs := last_obs sa ++ o_f\n    \\<rparr>\"\n\n  \\<comment> \\<open>Abstract step\\<close>"], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_obsv_state.next_round := Suc (opt_obsv_state.next_round sa),\n     opt_obsv_state.decisions := opt_obsv_state.decisions sa ++ dec_f,\n     last_obs := last_obs sa ++ o_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have abs_step: \"(sa, sa') \\<in> tso_round1 r dec_f o_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round1 r dec_f o_f", "using next_r step_r R d_guard obs_guard"], ["proof (prove)\nusing this:\n  opt_obsv_state.next_round sa = r\n  two_step r = Suc 0\n  (sa, r, cfg) \\<in> ref_rel\n  d_guard dec_f (vote \\<circ> cfg)\n  obs_guard o_f (vote \\<circ> cfg)\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> tso_round1 r dec_f o_f", "by(auto simp add: tso_round1_def sa'_def ref_rel_def)\n\n  \\<comment> \\<open>Relation preserved\\<close>"], ["proof (state)\nthis:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "show \"((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "using step[THEN spec, of p]"], ["proof (prove)\nusing this:\n  next1 r p (cfg p) (\\<mu> p) (cfg' p)\n\ngoal (1 subgoal):\n 1. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)", "by(auto simp add: dec_f_def D_def next1_def dec_update_def map_add_def)"], ["proof (state)\nthis:\n  ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. ((decide \\<circ> cfg) ++ dec_f) p = decide (cfg' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note dec_rel=this[rule_format]"], ["proof (state)\nthis:\n  ((decide \\<circ> cfg) ++ dec_f) ?p = decide (cfg' ?p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have \"\\<forall>p. (\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (x (cfg' p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "proof(intro allI impI, cases \"S \\<in> Quorum\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "fix p"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "case True"], ["proof (state)\nthis:\n  S \\<in> Quorum\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "hence \"x (cfg' p) = v\""], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n\ngoal (1 subgoal):\n 1. x (cfg' p) = v", "using Ob_UNIV"], ["proof (prove)\nusing this:\n  S \\<in> Quorum\n  dom (vote \\<circ> cfg) \\<in> Quorum \\<Longrightarrow> Ob = UNIV\n\ngoal (1 subgoal):\n 1. x (cfg' p) = v", "by(auto simp add: S_def Ob_def dom_def)"], ["proof (state)\nthis:\n  x (cfg' p) = v\n\ngoal (2 subgoals):\n 1. \\<And>p.\n       S \\<in> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))\n 2. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "thus \"(\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (x (cfg' p)))\""], ["proof (prove)\nusing this:\n  x (cfg' p) = v\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> last_obs sa q = None \\<or>\n       (last_obs sa ++ o_f) q = Some (x (cfg' p))", "using True"], ["proof (prove)\nusing this:\n  x (cfg' p) = v\n  S \\<in> Quorum\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> last_obs sa q = None \\<or>\n       (last_obs sa ++ o_f) q = Some (x (cfg' p))", "by(auto simp add: o_f_def)"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> last_obs sa q = None \\<or>\n     (last_obs sa ++ o_f) q = Some (x (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "case False"], ["proof (state)\nthis:\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "hence empty: \"o_f = Map.empty\""], ["proof (prove)\nusing this:\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. o_f = Map.empty", "by(auto simp add: o_f_def)"], ["proof (state)\nthis:\n  o_f = Map.empty\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "from False"], ["proof (chain)\npicking this:\n  S \\<notin> Quorum", "have \"S \\<noteq> UNIV\""], ["proof (prove)\nusing this:\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. S \\<noteq> UNIV", "using UNIV_quorum"], ["proof (prove)\nusing this:\n  S \\<notin> Quorum\n  UNIV \\<in> Quorum\n\ngoal (1 subgoal):\n 1. S \\<noteq> UNIV", "by auto"], ["proof (state)\nthis:\n  S \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "then"], ["proof (chain)\npicking this:\n  S \\<noteq> UNIV", "obtain q where q: \"vote (cfg q) = None\""], ["proof (prove)\nusing this:\n  S \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        vote (cfg q) = None \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  S \\<noteq> UNIV\n  S \\<notin> Quorum\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        vote (cfg q) = None \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: o_f_def S_def)"], ["proof (state)\nthis:\n  vote (cfg q) = None\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "then"], ["proof (chain)\npicking this:\n  vote (cfg q) = None", "obtain q1 q2 where \n      \"x (cfg q1) \\<noteq> x (cfg q2)\""], ["proof (prove)\nusing this:\n  vote (cfg q) = None\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        x (cfg q1) \\<noteq> x (cfg q2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using R step_r"], ["proof (prove)\nusing this:\n  vote (cfg q) = None\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. (\\<And>q1 q2.\n        x (cfg q1) \\<noteq> x (cfg q2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: ref_rel_def no_vote_diff_def)"], ["proof (state)\nthis:\n  x (cfg q1) \\<noteq> x (cfg q2)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "then"], ["proof (chain)\npicking this:\n  x (cfg q1) \\<noteq> x (cfg q2)", "obtain q1' q2' where\n      \"x (cfg q1') = val0\"\n      \"x (cfg q2') = val1\""], ["proof (prove)\nusing this:\n  x (cfg q1) \\<noteq> x (cfg q2)\n\ngoal (1 subgoal):\n 1. (\\<And>q1' q2'.\n        \\<lbrakk>x (cfg q1') = val0; x (cfg q2') = val1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (poly_guards_query) val_exhaust)"], ["proof (state)\nthis:\n  x (cfg q1') = val0\n  x (cfg q2') = val1\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "hence \"\\<forall>v. \\<exists>q. opt_obsv_state.last_obs sa q \\<in> {None, Some v}\""], ["proof (prove)\nusing this:\n  x (cfg q1') = val0\n  x (cfg q2') = val1\n\ngoal (1 subgoal):\n 1. \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}", "using R step_r"], ["proof (prove)\nusing this:\n  x (cfg q1') = val0\n  x (cfg q2') = val1\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}", "apply(auto simp add: ref_rel_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>v.\n       \\<lbrakk>x (cfg q1') = val0; x (cfg q2') = val1;\n        two_step (opt_obsv_state.next_round sa) = Suc 0;\n        r = opt_obsv_state.next_round sa; r_votes sa = vote \\<circ> cfg;\n        All (no_vote_diff cfg);\n        \\<forall>p.\n           \\<exists>q.\n              last_obs sa q = None \\<or> last_obs sa q = Some (x (cfg p));\n        opt_obsv_state.decisions sa = decide \\<circ> cfg\\<rbrakk>\n       \\<Longrightarrow> \\<exists>q.\n                            last_obs sa q = None \\<or>\n                            last_obs sa q = Some v", "by (metis (poly_guards_query) val_exhaust)"], ["proof (state)\nthis:\n  \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "(* note x = x_origin2[OF send step step_r refl, of p] *)"], ["proof (state)\nthis:\n  \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       S \\<notin> Quorum \\<Longrightarrow>\n       \\<exists>q.\n          o_f q = None \\<and> last_obs sa q = None \\<or>\n          (last_obs sa ++ o_f) q = Some (x (cfg' p))", "thus \"(\\<exists>q. o_f q = None \\<and> opt_obsv_state.last_obs sa q = None \n        \\<or> (opt_obsv_state.last_obs sa ++ o_f) q = Some (x (cfg' p)))\""], ["proof (prove)\nusing this:\n  \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> last_obs sa q = None \\<or>\n       (last_obs sa ++ o_f) q = Some (x (cfg' p))", "using empty"], ["proof (prove)\nusing this:\n  \\<forall>v. \\<exists>q. last_obs sa q \\<in> {None, Some v}\n  o_f = Map.empty\n\ngoal (1 subgoal):\n 1. \\<exists>q.\n       o_f q = None \\<and> last_obs sa q = None \\<or>\n       (last_obs sa ++ o_f) q = Some (x (cfg' p))", "by(auto)"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> last_obs sa q = None \\<or>\n     (last_obs sa ++ o_f) q = Some (x (cfg' p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p.\n     \\<exists>q.\n        o_f q = None \\<and> last_obs sa q = None \\<or>\n        (last_obs sa ++ o_f) q = Some (x (cfg' p))\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "note obs_rel=this[rule_format]"], ["proof (state)\nthis:\n  \\<exists>q.\n     o_f q = None \\<and> last_obs sa q = None \\<or>\n     (last_obs sa ++ o_f) q = Some (x (cfg' ?p))\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "have post_rel: \n    \"(sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "using step send next_r R step_r"], ["proof (prove)\nusing this:\n  \\<forall>p. next1 r p (cfg p) (\\<mu> p) (cfg' p)\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) cfg (HOs r) (HOs r) p\n  opt_obsv_state.next_round sa = r\n  (sa, r, cfg) \\<in> ref_rel\n  two_step r = Suc 0\n\ngoal (1 subgoal):\n 1. (sa', Suc r, cfg') \\<in> ref_rel", "by(auto simp add: sa'_def ref_rel_def \n      two_step_phase_Suc dec_rel obs_rel)"], ["proof (state)\nthis:\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ref_rel; a \\<in> TSO_inv1;\n        a \\<in> TSO_inv2; two_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y) \\<in> tso_round1 x xa xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ref_rel", "from abs_step post_rel"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n  (sa', Suc r, cfg') \\<in> ref_rel", "show\n    \"\\<exists>sa'. (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and> (sa', Suc r, cfg') \\<in> ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> tso_round1 r dec_f o_f\n  (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and>\n       (sa', Suc r, cfg') \\<in> ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r d_f o_f. (sa, sa') \\<in> tso_round1 r d_f o_f) \\<and>\n     (sa', Suc r, cfg') \\<in> ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma BenOr_Refines_Two_Step_Obs:\n  \"PO_refines (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV)\n    tso_TS (BenOr_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines (ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV)\n     tso_TS (BenOr_TS HOs HOs crds)", "proof(rule refine_using_invariants)"], ["proof (state)\ngoal (6 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} TS.trans tso_TS, TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UNIV \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (BenOr_TS HOs HOs crds) {> UNIV}\n 4. init (BenOr_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\n 5. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 6. init (BenOr_TS HOs HOs crds) \\<subseteq> UNIV", "show \"init (BenOr_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (BenOr_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS", "by(auto simp add: BenOr_TS_defs BenOr_HOMachine_def CHOAlgorithm.truncate_def \n      tso_TS_defs ref_rel_def tso_init_def Let_def o_def)"], ["proof (state)\nthis:\n  init (BenOr_TS HOs HOs crds) \\<subseteq> ref_rel `` init tso_TS\n\ngoal (5 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} TS.trans tso_TS, TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UNIV \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (BenOr_TS HOs HOs crds) {> UNIV}\n 4. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 5. init (BenOr_TS HOs HOs crds) \\<subseteq> UNIV", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} TS.trans tso_TS, TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}\n 2. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 3. {UNIV \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (BenOr_TS HOs HOs crds) {> UNIV}\n 4. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 5. init (BenOr_TS HOs HOs crds) \\<subseteq> UNIV", "show \n    \"{ref_rel \\<inter> (TSO_inv1 \\<inter> TSO_inv2) \\<times> UNIV} TS.trans tso_TS, \n      TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} TS.trans tso_TS, TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}", "apply(simp add: tso_TS_defs BenOr_TS_defs BenOr_HOMachine_def CHOAlgorithm.truncate_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {ref_rel \\<inter>\n     (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n     UNIV} ((\\<Union>x xa. \\<Union> (range (tso_round0 x xa))) \\<union>\n            (\\<Union>x xa.\n                \\<Union>\n                 (range\n                   (tso_round1 x\n                     xa))))\\<^sup>=, CHO_trans\n\\<lparr>CinitState =\n          \\<lambda>p st crd. vote st = None \\<and> decide st = None,\n   sendMsg = BenOr_sendMsg,\n   CnextState =\n     \\<lambda>r p st msgs crd. BenOr_nextState r p st msgs\\<rparr>\nHOs HOs (K \\<circ> crds) {> ref_rel}", "apply(auto simp add: CHO_trans_alt BenOr_trans intro!: step0_ref step1_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {ref_rel \\<inter>\n   (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n   UNIV} TS.trans tso_TS, TS.trans (BenOr_TS HOs HOs crds) {> ref_rel}\n\ngoal (4 subgoals):\n 1. {TSO_inv1 \\<inter> TSO_inv2 \\<inter>\n     Domain\n      (ref_rel \\<inter>\n       UNIV \\<times> UNIV)} TS.trans tso_TS {> TSO_inv1 \\<inter> TSO_inv2}\n 2. {UNIV \\<inter>\n     Range\n      (ref_rel \\<inter>\n       (TSO_inv1 \\<inter> TSO_inv2) \\<times>\n       UNIV)} TS.trans (BenOr_TS HOs HOs crds) {> UNIV}\n 3. init tso_TS \\<subseteq> TSO_inv1 \\<inter> TSO_inv2\n 4. init (BenOr_TS HOs HOs crds) \\<subseteq> UNIV", "qed(auto intro!: TSO_inv1_inductive TSO_inv2_inductive)"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The full termination proof for Ben-Or is probabilistic, and depends on the state\nof the processes, and a \"favorable\" coin toss, where \"favorable\" is relative to this state.\nAs this termination pre-condition is state-dependent, we cannot capture it in an HO \npredicate.\n\nInstead, we prove a variant of the argument, where we assume that there exists a \nround where all the processes hear from the same set of other processes, and all toss the \nsame coin.\n\\<close>"], ["", "theorem BenOr_termination:\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from comm_global"], ["proof (chain)\npicking this:\n  BenOr_commGlobal HOs", "obtain r1 where r1: \n    \"\\<forall>q. HOs r1 p = HOs r1 q\"\n    \"\\<forall>q. (coin r1 p :: val) = coin r1 q\"\n    \"two_step r1 = 1\""], ["proof (prove)\nusing this:\n  BenOr_commGlobal HOs\n\ngoal (1 subgoal):\n 1. (\\<And>r1.\n        \\<lbrakk>\\<forall>q. HOs r1 p = HOs r1 q;\n         \\<forall>q. coin r1 p = coin r1 q; two_step r1 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(simp add: BenOr_commGlobal_def all_conj_distrib, blast)"], ["proof (state)\nthis:\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from r1"], ["proof (chain)\npicking this:\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1", "obtain r0 where r1_def: \"r1 = Suc r0\" and step_r0: \"two_step r0 = 0\""], ["proof (prove)\nusing this:\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>r0.\n        \\<lbrakk>r1 = Suc r0; two_step r0 = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases r1) (auto simp add: two_step_phase_Suc two_step_def mod_Suc)"], ["proof (state)\nthis:\n  r1 = Suc r0\n  two_step r0 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg0 where \"cfg0 = rho r0\""], ["proof (state)\nthis:\n  cfg0 = rho r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg1 where \"cfg1 = rho r1\""], ["proof (state)\nthis:\n  cfg1 = rho r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r2 where \"r2 = Suc r1\""], ["proof (state)\nthis:\n  r2 = Suc r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg2 where \"cfg2 = rho r2\""], ["proof (state)\nthis:\n  cfg2 = rho r2\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r3 where \"r3 = Suc r2\""], ["proof (state)\nthis:\n  r3 = Suc r2\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg3 where \"cfg3 = rho r3\""], ["proof (state)\nthis:\n  cfg3 = rho r3\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg4 where \"cfg4 = rho (Suc r3)\""], ["proof (state)\nthis:\n  cfg4 = rho (Suc r3)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have step_r2: \"two_step r2 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. two_step r2 = 0", "using r1"], ["proof (prove)\nusing this:\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n\ngoal (1 subgoal):\n 1. two_step r2 = 0", "by(auto simp add: r2_def two_step_phase_Suc)"], ["proof (state)\nthis:\n  two_step r2 = 0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from\n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r0\"]\n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r1\"]\n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r2\"] \n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r3\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState BenOr_A r0 p (rho r0 p) (\\<mu> p) undefined\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState BenOr_A r1 p (rho r1 p) (\\<mu> p) undefined\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState BenOr_A r2 p (rho r2 p) (\\<mu> p) undefined\n         (rho (Suc r2) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r3) (rho r3) (HOs r3) (HOs r3)\n               p \\<and>\n        CnextState BenOr_A r3 p (rho r3 p) (\\<mu> p) undefined\n         (rho (Suc r3) p)", "obtain \\<mu>0 \\<mu>1 \\<mu>2 \\<mu>3 where\n    send0: \"\\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\"\n    and step0: \"\\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) (cfg1 p)\"\n    and send1: \"\\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\"\n    and step1: \"\\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (cfg2 p)\"\n    and send2: \"\\<forall>p. \\<mu>2 p \\<in> get_msgs (send0 r2) cfg2 (HOs r2) (HOs r2) p\"\n    and step2: \"\\<forall>p. next0 r2 p (cfg2 p) (\\<mu>2 p) (cfg3 p)\"\n    and send3: \"\\<forall>p. \\<mu>3 p \\<in> get_msgs (send1 r3) cfg3 (HOs r3) (HOs r3) p\"\n    and step3: \"\\<forall>p. next1 r3 p (cfg3 p) (\\<mu>3 p) (cfg4 p)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState BenOr_A r0 p (rho r0 p) (\\<mu> p) undefined\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState BenOr_A r1 p (rho r1 p) (\\<mu> p) undefined\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState BenOr_A r2 p (rho r2 p) (\\<mu> p) undefined\n         (rho (Suc r2) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg BenOr_A r3) (rho r3) (HOs r3) (HOs r3)\n               p \\<and>\n        CnextState BenOr_A r3 p (rho r3 p) (\\<mu> p) undefined\n         (rho (Suc r3) p)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>0 \\<mu>1 \\<mu>2 \\<mu>3.\n        \\<lbrakk>\\<forall>p.\n                    \\<mu>0 p\n                    \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p;\n         \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) (cfg1 p);\n         \\<forall>p.\n            \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p;\n         \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (cfg2 p);\n         \\<forall>p.\n            \\<mu>2 p \\<in> get_msgs (send0 r2) cfg2 (HOs r2) (HOs r2) p;\n         \\<forall>p. next0 r2 p (cfg2 p) (\\<mu>2 p) (cfg3 p);\n         \\<forall>p.\n            \\<mu>3 p \\<in> get_msgs (send1 r3) cfg3 (HOs r3) (HOs r3) p;\n         \\<forall>p. next1 r3 p (cfg3 p) (\\<mu>3 p) (cfg4 p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: BenOr_A_def BenOr_HOMachine_def \n      two_step_phase_Suc BenOr_nextState_def BenOr_sendMsg_def all_conj_distrib\n      CHOAlgorithm.truncate_def step_r0 r1_def r2_def r3_def\n      cfg0_def cfg1_def cfg2_def cfg3_def cfg4_def \n      )"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\n  \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) (cfg1 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (cfg2 p)\n  \\<forall>p. \\<mu>2 p \\<in> get_msgs (send0 r2) cfg2 (HOs r2) (HOs r2) p\n  \\<forall>p. next0 r2 p (cfg2 p) (\\<mu>2 p) (cfg3 p)\n  \\<forall>p. \\<mu>3 p \\<in> get_msgs (send1 r3) cfg3 (HOs r3) (HOs r3) p\n  \\<forall>p. next1 r3 p (cfg3 p) (\\<mu>3 p) (cfg4 p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "let ?v = \"x (cfg2 p)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from per_rd r1"], ["proof (chain)\npicking this:\n  \\<forall>r. BenOr_commPerRd (HOs r)\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1", "have xs: \"\\<forall>q. x (cfg2 q) = ?v\""], ["proof (prove)\nusing this:\n  \\<forall>r. BenOr_commPerRd (HOs r)\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n\ngoal (1 subgoal):\n 1. \\<forall>q. x (cfg2 q) = x (cfg2 p)", "proof(cases \"\\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)\n 2. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "case True"], ["proof (state)\nthis:\n  \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)\n 2. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "then"], ["proof (chain)\npicking this:\n  \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w", "obtain q w where q_w: \"q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\""], ["proof (prove)\nusing this:\n  \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (1 subgoal):\n 1. (\\<And>q w.\n        q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)\n 2. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "then"], ["proof (chain)\npicking this:\n  q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w", "have \"\\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}\""], ["proof (prove)\nusing this:\n  q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (1 subgoal):\n 1. \\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}", "using  same_new_vote[OF send0 step0 step_r0]"], ["proof (prove)\nusing this:\n  q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n  (\\<And>v.\n      \\<forall>p w.\n         vote (cfg1 p) = Some w \\<longrightarrow> w = v \\<Longrightarrow>\n      ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}", "by (metis insert_iff not_None_eq)"], ["proof (state)\nthis:\n  \\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)\n 2. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "hence \"\\<forall>q'. x (cfg2 q') = w\""], ["proof (prove)\nusing this:\n  \\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}\n\ngoal (1 subgoal):\n 1. \\<forall>q'. x (cfg2 q') = w", "using step1 send1 q_w"], ["proof (prove)\nusing this:\n  \\<forall>q'. vote (cfg1 q') \\<in> {None, Some w}\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (cfg2 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n  q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (1 subgoal):\n 1. \\<forall>q'. x (cfg2 q') = w", "apply(auto simp add: next1_def all_conj_distrib dec_update_def x_update_def\n        get_msgs_benign send1_def isVote_def msgRcvd_def identicalVoteRcvd_def \n        someVoteRcvd_def restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q'.\n       \\<lbrakk>\\<forall>p.\n                   (\\<exists>v.\n                       (\\<forall>q.\n                           q \\<in> HOs r1 p \\<longrightarrow>\n                           vote (cfg1 q) = Some v) \\<and>\n                       decide (cfg2 p) = Some v) \\<or>\n                   (\\<forall>v.\n                       \\<exists>q.\n                          (q \\<in> HOs r1 p \\<longrightarrow>\n                           vote (cfg1 q) \\<noteq> Some v) \\<and>\n                          q \\<in> HOs r1 p) \\<and>\n                   decide (cfg2 p) = decide (cfg1 p);\n        \\<forall>p.\n           \\<mu>1 p =\n           (\\<lambda>x.\n               if x \\<in> HOs r1 p\n               then (Some \\<circ> (\\<lambda>q. Vote (vote (cfg1 q)))) x\n               else None);\n        \\<forall>q'. vote (cfg1 q') = None \\<or> vote (cfg1 q') = Some w;\n        q \\<in> HOs r1 p; vote (cfg1 q) = Some w;\n        \\<forall>p. vote (cfg2 p) = None;\n        \\<forall>p.\n           (\\<exists>q.\n               (q \\<in> HOs r1 p \\<longrightarrow>\n                (\\<exists>y. vote (cfg1 q) = Some y) \\<and>\n                x (cfg2 p) = the (vote (cfg1 q))) \\<and>\n               q \\<in> HOs r1 p) \\<or>\n           (\\<forall>x.\n               x \\<in> HOs r1 p \\<longrightarrow>\n               vote (cfg1 x) = None) \\<and>\n           x (cfg2 p) = coin r1 p\\<rbrakk>\n       \\<Longrightarrow> x (cfg2 q') = w", "by (metis (erased, hide_lams) option.distinct(2) option.sel r1(1))"], ["proof (state)\nthis:\n  \\<forall>q'. x (cfg2 q') = w\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<exists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)\n 2. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q'. x (cfg2 q') = w\n\ngoal (1 subgoal):\n 1. \\<forall>q. x (cfg2 q) = x (cfg2 p)", "by auto"], ["proof (state)\nthis:\n  \\<forall>q. x (cfg2 q) = x (cfg2 p)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "case False"], ["proof (state)\nthis:\n  \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "hence \"\\<forall>q'. x (cfg2 q') = coin r1 q'\""], ["proof (prove)\nusing this:\n  \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n\ngoal (1 subgoal):\n 1. \\<forall>q'. x (cfg2 q') = coin r1 q'", "using r1 step1 send1"], ["proof (prove)\nusing this:\n  \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) (cfg2 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n\ngoal (1 subgoal):\n 1. \\<forall>q'. x (cfg2 q') = coin r1 q'", "apply(auto simp add: next1_def all_conj_distrib dec_update_def x_update_def\n        get_msgs_benign send1_def isVote_def msgRcvd_def identicalVoteRcvd_def \n        someVoteRcvd_def restrict_map_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>q'.\n       \\<lbrakk>\\<forall>p.\n                   (\\<exists>v.\n                       (\\<forall>q.\n                           q \\<in> HOs r1 p \\<longrightarrow>\n                           vote (cfg1 q) = Some v) \\<and>\n                       decide (cfg2 p) = Some v) \\<or>\n                   (\\<forall>v.\n                       \\<exists>q.\n                          (q \\<in> HOs r1 p \\<longrightarrow>\n                           vote (cfg1 q) \\<noteq> Some v) \\<and>\n                          q \\<in> HOs r1 p) \\<and>\n                   decide (cfg2 p) = decide (cfg1 p);\n        \\<forall>p.\n           \\<mu>1 p =\n           (\\<lambda>x.\n               if x \\<in> HOs r1 p\n               then (Some \\<circ> (\\<lambda>q. Vote (vote (cfg1 q)))) x\n               else None);\n        \\<forall>q. q \\<in> HOs r1 p \\<longrightarrow> vote (cfg1 q) = None;\n        \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n        two_step r1 = Suc 0; \\<forall>p. vote (cfg2 p) = None;\n        \\<forall>p.\n           (\\<exists>q.\n               (q \\<in> HOs r1 p \\<longrightarrow>\n                (\\<exists>y. vote (cfg1 q) = Some y) \\<and>\n                x (cfg2 p) = the (vote (cfg1 q))) \\<and>\n               q \\<in> HOs r1 p) \\<or>\n           (\\<forall>x.\n               x \\<in> HOs r1 p \\<longrightarrow>\n               vote (cfg1 x) = None) \\<and>\n           x (cfg2 p) = coin r1 p\\<rbrakk>\n       \\<Longrightarrow> x (cfg2 q') = coin r1 q'", "by (metis False)"], ["proof (state)\nthis:\n  \\<forall>q'. x (cfg2 q') = coin r1 q'\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>r. BenOr_commPerRd (HOs r);\n     \\<forall>q. HOs r1 p = HOs r1 q; \\<forall>q. coin r1 p = coin r1 q;\n     two_step r1 = 1;\n     \\<nexists>q w. q \\<in> HOs r1 p \\<and> vote (cfg1 q) = Some w\\<rbrakk>\n    \\<Longrightarrow> \\<forall>q. x (cfg2 q) = x (cfg2 p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>q'. x (cfg2 q') = coin r1 q'\n\ngoal (1 subgoal):\n 1. \\<forall>q. x (cfg2 q) = x (cfg2 p)", "using r1"], ["proof (prove)\nusing this:\n  \\<forall>q'. x (cfg2 q') = coin r1 q'\n  \\<forall>q. HOs r1 p = HOs r1 q\n  \\<forall>q. coin r1 p = coin r1 q\n  two_step r1 = 1\n\ngoal (1 subgoal):\n 1. \\<forall>q. x (cfg2 q) = x (cfg2 p)", "by(metis)"], ["proof (state)\nthis:\n  \\<forall>q. x (cfg2 q) = x (cfg2 p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>q. x (cfg2 q) = x (cfg2 p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence \"\\<forall>q. vote (cfg3 q) = Some ?v\""], ["proof (prove)\nusing this:\n  \\<forall>q. x (cfg2 q) = x (cfg2 p)\n\ngoal (1 subgoal):\n 1. \\<forall>q. vote (cfg3 q) = Some (x (cfg2 p))", "by(simp add: vote_origin[OF send2 step2 step_r2])"], ["proof (state)\nthis:\n  \\<forall>q. vote (cfg3 q) = Some (x (cfg2 p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence \"decide (cfg4 p) = Some ?v\""], ["proof (prove)\nusing this:\n  \\<forall>q. vote (cfg3 q) = Some (x (cfg2 p))\n\ngoal (1 subgoal):\n 1. decide (cfg4 p) = Some (x (cfg2 p))", "using send3[THEN spec, of p] step3[THEN spec, of p] HOs_nonempty"], ["proof (prove)\nusing this:\n  \\<forall>q. vote (cfg3 q) = Some (x (cfg2 p))\n  \\<mu>3 p \\<in> get_msgs (send1 r3) cfg3 (HOs r3) (HOs r3) p\n  next1 r3 p (cfg3 p) (\\<mu>3 p) (cfg4 p)\n  HOs ?r ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. decide (cfg4 p) = Some (x (cfg2 p))", "by(auto simp add: next1_def send1_def get_msgs_benign dec_update_def\n      restrict_map_def identicalVoteRcvd_def msgRcvd_def isVote_def)"], ["proof (state)\nthis:\n  decide (cfg4 p) = Some (x (cfg2 p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "thus ?thesis"], ["proof (prove)\nusing this:\n  decide (cfg4 p) = Some (x (cfg2 p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by(auto simp add: cfg4_def)"], ["proof (state)\nthis:\n  \\<exists>r v. decide (rho r p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* HO predicate context *)"], ["", "end"], ["", "(* mono_quorum context *)"], ["", "end"], ["", "(* theory *)"]]}