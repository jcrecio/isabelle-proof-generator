{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/Voting/Ate_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas Ate_TS_defs = Ate_TS_def CHO_to_TS_def Ate_Alg_def CHOinitConfig_def\n  Ate_initState_def", "lemma decide_origin:\n  assumes \n    send: \"\\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\"\n    and new_dec: \"decide (sc' p) \\<noteq> decide (sc p)\"\n  shows\n    \"\\<exists>v. decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> majs\"", "lemma other_values_received:\n  assumes nxt: \"Ate_nextState  r q (sc q) \\<mu>q ((sc') q)\"\n  and muq: \"\\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\"\n  and vsent: \"card {qq. sendMsg Ate_M r qq q (sc qq) = v} > E - \\<alpha>\"\n             (is \"card ?vsent > _\")\n  shows \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\"", "lemma mostOftenRcvd_v:\n  assumes nxt: \"Ate_nextState  r q (sc q) \\<mu>q ((sc') q)\"\n  and muq: \"\\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\"\n  and threshold_T: \"card {qq. \\<mu>q qq \\<noteq> None} > T\"\n  and threshold_E: \"card {qq. sendMsg Ate_M r qq q (sc qq) = v} > E - \\<alpha>\"\n  shows \"mostOftenRcvd \\<mu>q = {v}\"", "lemma step_ref:\n  \"{ate_ref_rel} \n      (\\<Union>r v_f d_f. majorities.flv_round r v_f d_f), \n      Ate_trans_step HOs \n    {> ate_ref_rel}\"", "lemma Ate_Refines_LV_VOting:\n  \"PO_refines (ate_ref_rel) \n    majorities.flv_TS (Ate_TS HOs HOs crds)\""], "translations": [["", "lemmas Ate_TS_defs = Ate_TS_def CHO_to_TS_def Ate_Alg_def CHOinitConfig_def\n  Ate_initState_def"], ["", "definition\n  \"Ate_trans_step HOs \\<equiv> \\<Union>r \\<mu>.\n   {((r, cfg), Suc r, cfg')|cfg cfg'.\n    (\\<forall>p. \\<mu> p \\<in> get_msgs (Ate_sendMsg r) cfg (HOs r) (HOs r) p) \\<and>\n    (\\<forall>p. Ate_nextState r p (cfg p) (\\<mu> p) (cfg' p))}\""], ["", "definition CSHOnextConfig where\n  \"CSHOnextConfig A r cfg HO SHO coord cfg' \\<equiv>\n   \\<forall>p. \\<exists>\\<mu> \\<in> SHOmsgVectors A r p cfg (HO p) (SHO p).\n          CnextState A r p (cfg p) \\<mu> (coord p) (cfg' p)\""], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition ate_ref_rel :: \"(opt_v_state \\<times> p_TS_state)set\" where\n  \"ate_ref_rel =  {(sa, (r, sc)).\n    r = next_round sa\n    \\<and> (\\<forall>p. decisions sa p = Ate_Defs.decide (sc p))\n    \\<and> majorities.opt_no_defection sa (Some o x o sc)\n  }\""], ["", "lemma decide_origin:\n  assumes \n    send: \"\\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\"\n    and new_dec: \"decide (sc' p) \\<noteq> decide (sc p)\"\n  shows\n    \"\\<exists>v. decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> local.majs", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\n  Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n  decide (sc' p) \\<noteq> decide (sc p)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> local.majs", "by(auto simp add: get_msgs_benign Ate_sendMsg_def Ate_nextState_def\n    majs_def restrict_map_def elim!: order.strict_trans2 intro!: card_mono)"], ["", "lemma other_values_received:\n  assumes nxt: \"Ate_nextState  r q (sc q) \\<mu>q ((sc') q)\"\n  and muq: \"\\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\"\n  and vsent: \"card {qq. sendMsg Ate_M r qq q (sc qq) = v} > E - \\<alpha>\"\n             (is \"card ?vsent > _\")\n  shows \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "from nxt muq"], ["proof (chain)\npicking this:\n  Ate_nextState r q (sc q) \\<mu>q (sc' q)\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q", "have \"({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) - (HOs r q - HOs r q)\n        \\<subseteq>  {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\"\n    (is \"?notvrcvd - ?aho \\<subseteq> ?notvsent\")"], ["proof (prove)\nusing this:\n  Ate_nextState r q (sc q) \\<mu>q (sc' q)\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q)\n    \\<subseteq> {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}", "unfolding get_msgs_def SHOmsgVectors_def Ate_SHOMachine_def"], ["proof (prove)\nusing this:\n  Ate_nextState r q (sc q) \\<mu>q (sc' q)\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> HOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (Ate_sendMsg r qa q (sc qa)))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q)\n    \\<subseteq> {qq.\n                 sendMsg\n                  \\<lparr>CinitState =\n                            \\<lambda>p st crd. Ate_initState p st,\n                     sendMsg = Ate_sendMsg,\n                     CnextState =\n                       \\<lambda>r p st msgs crd. Ate_nextState r p st msgs,\n                     SHOcommPerRd = Ate_commPerRd,\n                     SHOcommGlobal = Ate_commGlobal\\<rparr>\n                  r qq q (sc qq) \\<noteq>\n                 v}", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q)\n  \\<subseteq> {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "hence \"card ?notvsent \\<ge> card (?notvrcvd - ?aho)\"\n    and \"card (?notvrcvd - ?aho) \\<ge> card ?notvrcvd - card ?aho\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q)\n  \\<subseteq> {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n\ngoal (1 subgoal):\n 1. card\n     ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n      (HOs r q - HOs r q))\n    \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} &&&\n    card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n    card (HOs r q - HOs r q)\n    \\<le> card\n           ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n            (HOs r q - HOs r q))", "by (auto simp: card_mono diff_card_le_card_Diff)"], ["proof (state)\nthis:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - HOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - HOs r q))\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "moreover"], ["proof (state)\nthis:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - HOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - HOs r q))\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "have 1: \"card ?notvsent + card ?vsent = card (?notvsent \\<union> ?vsent)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} +\n    card {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n    card\n     ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n      {qq. sendMsg Ate_M r qq q (sc qq) = v})", "by (subst card_Un_Int) auto"], ["proof (state)\nthis:\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v})\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "have \"?notvsent \\<union> ?vsent = (UNIV::process set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n    UNIV", "by auto"], ["proof (state)\nthis:\n  {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n  {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n  UNIV\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "hence \"card (?notvsent \\<union> ?vsent) = N\""], ["proof (prove)\nusing this:\n  {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n  {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n  UNIV\n\ngoal (1 subgoal):\n 1. card\n     ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n      {qq. sendMsg Ate_M r qq q (sc qq) = v}) =\n    N", "by simp"], ["proof (state)\nthis:\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v}) =\n  N\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "with 1 vsent"], ["proof (chain)\npicking this:\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v})\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (sc qq) = v}\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v}) =\n  N", "have \"card ?notvsent \\<le>  N - (E + 1 - \\<alpha>)\""], ["proof (prove)\nusing this:\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} +\n  card {qq. sendMsg Ate_M r qq q (sc qq) = v} =\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v})\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (sc qq) = v}\n  card\n   ({qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v} \\<union>\n    {qq. sendMsg Ate_M r qq q (sc qq) = v}) =\n  N\n\ngoal (1 subgoal):\n 1. card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n    \\<le> N - (E + 1 - \\<alpha>)", "by auto"], ["proof (state)\nthis:\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "ultimately"], ["proof (chain)\npicking this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - HOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - HOs r q))\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)", "show ?thesis"], ["proof (prove)\nusing this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - HOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - HOs r q))\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "using EltN Egta"], ["proof (prove)\nusing this:\n  card\n   ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q - (HOs r q - HOs r q))\n  \\<le> card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) -\n  card (HOs r q - HOs r q)\n  \\<le> card\n         ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q -\n          (HOs r q - HOs r q))\n  card {qq. sendMsg Ate_M r qq q (sc qq) \\<noteq> v}\n  \\<le> N - (E + 1 - \\<alpha>)\n  E < N\n  \\<alpha> < E\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "by auto"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  If more than \\<open>E - \\<alpha>\\<close> processes send a value \\<open>v\\<close> to some\n  process \\<open>q\\<close> at some round \\<open>r\\<close>, and if \\<open>q\\<close> receives more than\n  \\<open>T\\<close> messages in \\<open>r\\<close>, then \\<open>v\\<close> is the most frequently\n  received value by \\<open>q\\<close> in \\<open>r\\<close>.\n\\<close>"], ["", "lemma mostOftenRcvd_v:\n  assumes nxt: \"Ate_nextState  r q (sc q) \\<mu>q ((sc') q)\"\n  and muq: \"\\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\"\n  and threshold_T: \"card {qq. \\<mu>q qq \\<noteq> None} > T\"\n  and threshold_E: \"card {qq. sendMsg Ate_M r qq q (sc qq) = v} > E - \\<alpha>\"\n  shows \"mostOftenRcvd \\<mu>q = {v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "from muq"], ["proof (chain)\npicking this:\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q", "have hodef:\"HOs r q = {qq. \\<mu>q qq \\<noteq> None}\""], ["proof (prove)\nusing this:\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\n\ngoal (1 subgoal):\n 1. HOs r q = {qq. \\<mu>q qq \\<noteq> None}", "unfolding get_msgs_def SHOmsgVectors_def"], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> HOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (Ate_sendMsg r qa q (sc qa)))}\n\ngoal (1 subgoal):\n 1. HOs r q = {qq. \\<mu>q qq \\<noteq> None}", "by auto"], ["proof (state)\nthis:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "from nxt muq threshold_E"], ["proof (chain)\npicking this:\n  Ate_nextState r q (sc q) \\<mu>q (sc' q)\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (sc qq) = v}", "have \"card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) \\<le> N + 2*\\<alpha> - E\"\n    (is \"card ?heardnotv \\<le> _\")"], ["proof (prove)\nusing this:\n  Ate_nextState r q (sc q) \\<mu>q (sc' q)\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq q (sc qq) = v}\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    \\<le> N + 2 * \\<alpha> - E", "by (rule other_values_received)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "moreover"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "have \"card ?heardnotv \\<ge> T + 1 - card {qq. \\<mu>q qq = Some v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "from muq"], ["proof (chain)\npicking this:\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q", "have \"?heardnotv = (HOs r q) - {qq. \\<mu>q qq = Some v}\"\n      and \"{qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\""], ["proof (prove)\nusing this:\n  \\<mu>q \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) q\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n    HOs r q - {qq. \\<mu>q qq = Some v} &&&\n    {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q", "unfolding SHOmsgVectors_def get_msgs_def"], ["proof (prove)\nusing this:\n  \\<mu>q\n  \\<in> {\\<mu>.\n         (\\<forall>qa. (qa \\<in> HOs r q) = (\\<mu> qa \\<noteq> None)) \\<and>\n         (\\<forall>qa.\n             qa \\<in> HOs r q \\<inter> HOs r q \\<longrightarrow>\n             \\<mu> qa = Some (Ate_sendMsg r qa q (sc qa)))}\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n    HOs r q - {qq. \\<mu>q qq = Some v} &&&\n    {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n  HOs r q - {qq. \\<mu>q qq = Some v}\n  {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "hence \"card ?heardnotv = card (HOs r q) - card {qq. \\<mu>q qq = Some v}\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q =\n  HOs r q - {qq. \\<mu>q qq = Some v}\n  {qq. \\<mu>q qq = Some v} \\<subseteq> HOs r q\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n    card (HOs r q) - card {qq. \\<mu>q qq = Some v}", "by (auto simp: card_Diff_subset)"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "with hodef threshold_T"], ["proof (chain)\npicking this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}", "show ?thesis"], ["proof (prove)\nusing this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  T < card {qq. \\<mu>q qq \\<noteq> None}\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q) =\n  card (HOs r q) - card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. T + 1 - card {qq. \\<mu>q qq = Some v}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "by auto"], ["proof (state)\nthis:\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "ultimately"], ["proof (chain)\npicking this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "have \"card {qq. \\<mu>q qq = Some v} > card ?heardnotv\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    < card {qq. \\<mu>q qq = Some v}", "using TNaE"], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  \\<le> N + 2 * \\<alpha> - E\n  T + 1 - card {qq. \\<mu>q qq = Some v}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  2 * (N + 2 * \\<alpha> - E) \\<le> T\n\ngoal (1 subgoal):\n 1. card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n    < card {qq. \\<mu>q qq = Some v}", "by auto"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "moreover"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "{"], ["proof (state)\nthis:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "fix w"], ["proof (state)\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "assume w: \"w \\<noteq> v\""], ["proof (state)\nthis:\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "with hodef"], ["proof (chain)\npicking this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  w \\<noteq> v", "have \"{qq. \\<mu>q qq = Some w} \\<subseteq> ?heardnotv\""], ["proof (prove)\nusing this:\n  HOs r q = {qq. \\<mu>q qq \\<noteq> None}\n  w \\<noteq> v\n\ngoal (1 subgoal):\n 1. {qq. \\<mu>q qq = Some w}\n    \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q", "by auto"], ["proof (state)\nthis:\n  {qq. \\<mu>q qq = Some w}\n  \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "hence \"card {qq. \\<mu>q qq = Some w} \\<le> card ?heardnotv\""], ["proof (prove)\nusing this:\n  {qq. \\<mu>q qq = Some w}\n  \\<subseteq> {qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q\n\ngoal (1 subgoal):\n 1. card {qq. \\<mu>q qq = Some w}\n    \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "by (auto simp: card_mono)"], ["proof (state)\nthis:\n  card {qq. \\<mu>q qq = Some w}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "}"], ["proof (state)\nthis:\n  ?w9 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w9}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "ultimately"], ["proof (chain)\npicking this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n  ?w9 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w9}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)", "have \"{w. card {qq. \\<mu>q qq = Some w} \\<ge> card {qq. \\<mu>q qq = Some v}} = {v}\""], ["proof (prove)\nusing this:\n  card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n  < card {qq. \\<mu>q qq = Some v}\n  ?w9 \\<noteq> v \\<Longrightarrow>\n  card {qq. \\<mu>q qq = Some ?w9}\n  \\<le> card ({qq. \\<mu>q qq \\<noteq> Some v} \\<inter> HOs r q)\n\ngoal (1 subgoal):\n 1. {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n    {v}", "by force"], ["proof (state)\nthis:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "thus ?thesis"], ["proof (prove)\nusing this:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. mostOftenRcvd \\<mu>q = {v}", "unfolding mostOftenRcvd_def"], ["proof (prove)\nusing this:\n  {w. card {qq. \\<mu>q qq = Some v} \\<le> card {qq. \\<mu>q qq = Some w}} =\n  {v}\n\ngoal (1 subgoal):\n 1. {v. \\<forall>w.\n           card {qq. \\<mu>q qq = Some w}\n           \\<le> card {qq. \\<mu>q qq = Some v}} =\n    {v}", "by auto"], ["proof (state)\nthis:\n  mostOftenRcvd \\<mu>q = {v}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step_ref:\n  \"{ate_ref_rel} \n      (\\<Union>r v_f d_f. majorities.flv_round r v_f d_f), \n      Ate_trans_step HOs \n    {> ate_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ate_ref_rel} \\<Union>r v_f.\n                     \\<Union>\n                      (range\n                        (local.majorities.flv_round r\n                          v_f)), Ate_trans_step HOs {> ate_ref_rel}", "proof(simp add: PO_rhoare_defs Ate_trans_step_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "fix sa r sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "assume\n    R: \"(sa, r, sc) \\<in> ate_ref_rel\"\n    and send: \"\\<forall>p. \\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\"\n    and nxt: \"\\<forall>p. Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> ate_ref_rel\n  \\<forall>p. \\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\n  \\<forall>p. Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "note step=send nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (Ate_sendMsg r) sc (HOs r) (HOs r) p\n  \\<forall>p. Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "define d_f\n    where \"d_f p = (if decide (sc' p) \\<noteq> decide (sc p) then decide (sc' p) else None)\" for p"], ["proof (state)\nthis:\n  d_f ?p =\n  (if decide (sc' ?p) \\<noteq> decide (sc ?p) then decide (sc' ?p)\n   else None)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "define sa' where \"sa' = \\<lparr> \n    opt_v_state.next_round = Suc r\n    , opt_v_state.last_vote = opt_v_state.last_vote sa ++ (Some o x o sc) \n    , opt_v_state.decisions = opt_v_state.decisions sa ++ d_f\n    \\<rparr>\""], ["proof (state)\nthis:\n  sa' =\n  \\<lparr>opt_v_state.next_round = Suc r,\n     last_vote = last_vote sa ++ (Some \\<circ> x \\<circ> sc),\n     decisions = opt_v_state.decisions sa ++ d_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "have \"majorities.d_guard d_f (Some o x o sc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.majorities.d_guard d_f (Some \\<circ> x \\<circ> sc)", "proof(clarsimp simp add: majorities.d_guard_def d_f_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decide (sc p);\n        decide (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> local.majorities.locked_in_vf\n                          (Some \\<circ> x \\<circ> sc) v", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decide (sc p);\n        decide (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> local.majorities.locked_in_vf\n                          (Some \\<circ> x \\<circ> sc) v", "assume\n      \"Some v \\<noteq> decide (sc p)\" \n      \"decide (sc' p) = Some v\""], ["proof (state)\nthis:\n  Some v \\<noteq> decide (sc p)\n  decide (sc' p) = Some v\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       \\<lbrakk>Some v \\<noteq> decide (sc p);\n        decide (sc' p) = Some v\\<rbrakk>\n       \\<Longrightarrow> local.majorities.locked_in_vf\n                          (Some \\<circ> x \\<circ> sc) v", "from this and \n      decide_origin[where \\<mu>=\\<mu> and HOs=HOs and sc'=sc', OF send[THEN spec, of p] nxt[THEN spec, of p]]"], ["proof (chain)\npicking this:\n  Some v \\<noteq> decide (sc p)\n  decide (sc' p) = Some v\n  decide (sc' p) \\<noteq> decide (sc p) \\<Longrightarrow>\n  \\<exists>v.\n     decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> local.majs", "show \"quorum_process.locked_in_vf majs (Some \\<circ> x \\<circ> sc) v\""], ["proof (prove)\nusing this:\n  Some v \\<noteq> decide (sc p)\n  decide (sc' p) = Some v\n  decide (sc' p) \\<noteq> decide (sc p) \\<Longrightarrow>\n  \\<exists>v.\n     decide (sc' p) = Some v \\<and> {q. x (sc q) = v} \\<in> local.majs\n\ngoal (1 subgoal):\n 1. local.majorities.locked_in_vf (Some \\<circ> x \\<circ> sc) v", "by(auto simp add: majorities.locked_in_vf_def majorities.quorum_for_def)"], ["proof (state)\nthis:\n  local.majorities.locked_in_vf (Some \\<circ> x \\<circ> sc) v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.majorities.d_guard d_f (Some \\<circ> x \\<circ> sc)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "hence\n    \"(sa, sa') \\<in> majorities.flv_round r (Some o x o sc) d_f\""], ["proof (prove)\nusing this:\n  local.majorities.d_guard d_f (Some \\<circ> x \\<circ> sc)\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f", "using R"], ["proof (prove)\nusing this:\n  local.majorities.d_guard d_f (Some \\<circ> x \\<circ> sc)\n  (sa, r, sc) \\<in> ate_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa')\n    \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f", "by(auto simp add: majorities.flv_round_def ate_ref_rel_def sa'_def)"], ["proof (state)\nthis:\n  (sa, sa')\n  \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa')\n  \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "have \"(sa', Suc r, sc') \\<in> ate_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> ate_ref_rel", "proof(unfold ate_ref_rel_def, safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. \\<And>p. opt_v_state.decisions sa' p = decide (sc' p)\n 3. local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')", "fix p"], ["proof (state)\ngoal (3 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. \\<And>p. opt_v_state.decisions sa' p = decide (sc' p)\n 3. local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')", "show \"opt_v_state.decisions sa' p = decide (sc' p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. opt_v_state.decisions sa' p = decide (sc' p)", "using R nxt[THEN spec, of p]"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> ate_ref_rel\n  Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n\ngoal (1 subgoal):\n 1. opt_v_state.decisions sa' p = decide (sc' p)", "by(auto simp add: ate_ref_rel_def sa'_def map_add_def d_f_def Ate_nextState_def\n        split: option.split)"], ["proof (state)\nthis:\n  opt_v_state.decisions sa' p = decide (sc' p)\n\ngoal (2 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. Suc r = opt_v_state.next_round sa'\n 2. local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')", "show \"quorum_process.opt_no_defection majs sa' (Some \\<circ> x \\<circ> sc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')", "proof(clarsimp simp add: sa'_def majorities.opt_no_defection_def map_add_def majorities.quorum_for_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> local.majs; \\<forall>p\\<in>Q. x (sc p) = v;\n        a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> x (sc' a) = v", "fix Q p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> local.majs; \\<forall>p\\<in>Q. x (sc p) = v;\n        a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> x (sc' a) = v", "assume Q: \"Q \\<in> majs\" and Q_v: \"\\<forall>q \\<in> Q. x (sc q) = v\" and p_Q: \"p \\<in> Q\""], ["proof (state)\nthis:\n  Q \\<in> local.majs\n  \\<forall>q\\<in>Q. x (sc q) = v\n  p \\<in> Q\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> local.majs; \\<forall>p\\<in>Q. x (sc p) = v;\n        a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> x (sc' a) = v", "hence old: \"x (sc p) = v\""], ["proof (prove)\nusing this:\n  Q \\<in> local.majs\n  \\<forall>q\\<in>Q. x (sc q) = v\n  p \\<in> Q\n\ngoal (1 subgoal):\n 1. x (sc p) = v", "by simp"], ["proof (state)\nthis:\n  x (sc p) = v\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> local.majs; \\<forall>p\\<in>Q. x (sc p) = v;\n        a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> x (sc' a) = v", "have v_maj: \"{q. x (sc q) = v} \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. x (sc q) = v} \\<in> local.majs", "using Q Q_v"], ["proof (prove)\nusing this:\n  Q \\<in> local.majs\n  \\<forall>q\\<in>Q. x (sc q) = v\n\ngoal (1 subgoal):\n 1. {q. x (sc q) = v} \\<in> local.majs", "apply(simp add: majs_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>E < card Q; \\<forall>q\\<in>Q. x (sc q) = v\\<rbrakk>\n    \\<Longrightarrow> E < card {q. x (sc q) = v}", "apply(erule less_le_trans, rule card_mono, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {q. x (sc q) = v} \\<in> local.majs\n\ngoal (1 subgoal):\n 1. \\<And>a Q v.\n       \\<lbrakk>Q \\<in> local.majs; \\<forall>p\\<in>Q. x (sc p) = v;\n        a \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> x (sc' a) = v", "show \"x (sc' p) = v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x (sc' p) = v", "proof(cases \"T < card {qq. \\<mu> p qq \\<noteq> None}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow> x (sc' p) = v\n 2. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "case True"], ["proof (state)\nthis:\n  T < card {qq. \\<mu> p qq \\<noteq> None}\n\ngoal (2 subgoals):\n 1. T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow> x (sc' p) = v\n 2. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "have\n          \"E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (sc qq) = v}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (sc qq) = v}", "using v_maj"], ["proof (prove)\nusing this:\n  {q. x (sc q) = v} \\<in> local.majs\n\ngoal (1 subgoal):\n 1. E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (sc qq) = v}", "by(auto simp add: Ate_SHOMachine_def Ate_sendMsg_def majs_def)"], ["proof (state)\nthis:\n  E - \\<alpha> < card {qq. sendMsg Ate_M r qq p (sc qq) = v}\n\ngoal (2 subgoals):\n 1. T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow> x (sc' p) = v\n 2. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "from mostOftenRcvd_v[where HOs=HOs and sc=sc and sc'=sc', \n          OF nxt[THEN spec, of p] send[THEN spec, of p] True this]"], ["proof (chain)\npicking this:\n  mostOftenRcvd (\\<mu> p) = {v}", "show ?thesis"], ["proof (prove)\nusing this:\n  mostOftenRcvd (\\<mu> p) = {v}\n\ngoal (1 subgoal):\n 1. x (sc' p) = v", "using nxt[THEN spec, of p] old"], ["proof (prove)\nusing this:\n  mostOftenRcvd (\\<mu> p) = {v}\n  Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n  x (sc p) = v\n\ngoal (1 subgoal):\n 1. x (sc' p) = v", "by(clarsimp simp add: Ate_nextState_def)"], ["proof (state)\nthis:\n  x (sc' p) = v\n\ngoal (1 subgoal):\n 1. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "case False"], ["proof (state)\nthis:\n  \\<not> T < card {qq. \\<mu> p qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. \\<not> T < card {qq. \\<mu> p qq \\<noteq> None} \\<Longrightarrow>\n    x (sc' p) = v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> T < card {qq. \\<mu> p qq \\<noteq> None}\n\ngoal (1 subgoal):\n 1. x (sc' p) = v", "using nxt[THEN spec, of p] old"], ["proof (prove)\nusing this:\n  \\<not> T < card {qq. \\<mu> p qq \\<noteq> None}\n  Ate_nextState r p (sc p) (\\<mu> p) (sc' p)\n  x (sc p) = v\n\ngoal (1 subgoal):\n 1. x (sc' p) = v", "by(clarsimp simp add: Ate_nextState_def)"], ["proof (state)\nthis:\n  x (sc' p) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x (sc' p) = v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.majorities.opt_no_defection sa' (Some \\<circ> x \\<circ> sc')\n\ngoal (1 subgoal):\n 1. Suc r = opt_v_state.next_round sa'", "qed(auto simp add: sa'_def)"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> ate_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a aa b ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> ate_ref_rel;\n        \\<forall>p.\n           x p \\<in> get_msgs (Ate_sendMsg ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. Ate_nextState ab p (ba p) (x p) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> local.majorities.flv_round x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> ate_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa')\n  \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f\n  (sa', Suc r, sc') \\<in> ate_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>ra v_f d_f. (sa, sa') \\<in> quorum_process.flv_round majs ra v_f d_f) \n    \\<and> (sa', Suc r, sc') \\<in> ate_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa')\n  \\<in> local.majorities.flv_round r (Some \\<circ> x \\<circ> sc) d_f\n  (sa', Suc r, sc') \\<in> ate_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>ra v_f d_f.\n           (sa, sa') \\<in> local.majorities.flv_round ra v_f d_f) \\<and>\n       (sa', Suc r, sc') \\<in> ate_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>ra v_f d_f.\n         (sa, sa') \\<in> local.majorities.flv_round ra v_f d_f) \\<and>\n     (sa', Suc r, sc') \\<in> ate_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Ate_Refines_LV_VOting:\n  \"PO_refines (ate_ref_rel) \n    majorities.flv_TS (Ate_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines ate_ref_rel local.majorities.flv_TS (Ate_TS HOs HOs crds)", "proof(rule refine_basic)"], ["proof (state)\ngoal (2 subgoals):\n 1. init (Ate_TS HOs HOs crds)\n    \\<subseteq> ate_ref_rel `` init local.majorities.flv_TS\n 2. {ate_ref_rel} TS.trans\n                   local.majorities.flv_TS, TS.trans\n       (Ate_TS HOs HOs crds) {> ate_ref_rel}", "show \"init (Ate_TS HOs HOs crds) \\<subseteq> ate_ref_rel `` init (quorum_process.flv_TS majs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (Ate_TS HOs HOs crds)\n    \\<subseteq> ate_ref_rel `` init local.majorities.flv_TS", "by(auto simp add: Ate_TS_def CHO_to_TS_def Ate_Alg_def CHOinitConfig_def Ate_initState_def\n      majorities.flv_TS_def flv_init_def majorities.opt_no_defection_def majorities.quorum_for_def'\n      ate_ref_rel_def)"], ["proof (state)\nthis:\n  init (Ate_TS HOs HOs crds)\n  \\<subseteq> ate_ref_rel `` init local.majorities.flv_TS\n\ngoal (1 subgoal):\n 1. {ate_ref_rel} TS.trans\n                   local.majorities.flv_TS, TS.trans\n       (Ate_TS HOs HOs crds) {> ate_ref_rel}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {ate_ref_rel} TS.trans\n                   local.majorities.flv_TS, TS.trans\n       (Ate_TS HOs HOs crds) {> ate_ref_rel}", "show \n    \"{ate_ref_rel} TS.trans (quorum_process.flv_TS majs), TS.trans (Ate_TS HOs HOs crds) {> ate_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {ate_ref_rel} TS.trans\n                   local.majorities.flv_TS, TS.trans\n       (Ate_TS HOs HOs crds) {> ate_ref_rel}", "using step_ref"], ["proof (prove)\nusing this:\n  {ate_ref_rel} \\<Union>r v_f.\n                   \\<Union>\n                    (range\n                      (local.majorities.flv_round r\n                        v_f)), Ate_trans_step ?HOs {> ate_ref_rel}\n\ngoal (1 subgoal):\n 1. {ate_ref_rel} TS.trans\n                   local.majorities.flv_TS, TS.trans\n       (Ate_TS HOs HOs crds) {> ate_ref_rel}", "by(simp add: majorities.flv_TS_defs Ate_TS_def CHO_to_TS_def Ate_Alg_def \n      CSHO_trans_alt_def CHO_trans_alt Ate_trans_step_def)"], ["proof (state)\nthis:\n  {ate_ref_rel} TS.trans\n                 local.majorities.flv_TS, TS.trans\n     (Ate_TS HOs HOs crds) {> ate_ref_rel}\n\ngoal:\nNo subgoals!", "qed"], ["", "end   \\<comment> \\<open>context @{text \"ate_parameters\"}\\<close>"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "text \\<open>The termination proof for the algorithm is already given in the Heard-Of Model AFP\n  entry, and we do not repeat it here.\\<close>"], ["", "end"], ["", "(* theory AteProof *)"]]}