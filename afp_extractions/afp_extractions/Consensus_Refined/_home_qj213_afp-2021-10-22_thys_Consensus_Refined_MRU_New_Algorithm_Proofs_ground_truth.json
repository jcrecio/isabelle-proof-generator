{"file_name": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined/MRU/New_Algorithm_Proofs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Consensus_Refined", "problem_names": ["lemmas New_Algo_TS_defs = New_Algo_TS_def CHO_to_TS_def New_Algo_Alg_def CHOinitConfig_def\n  NA_initState_def", "lemma three_step_less_D:\n  \"0 < three_step r \\<Longrightarrow> three_step r = 1 \\<or> three_step r = 2\"", "lemma New_Algo_trans:\n  \"CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds) = \n  New_Algo_trans_step HOs SHOs crds next0 send0 0\n  \\<union> New_Algo_trans_step HOs SHOs crds next1 send1 1\n  \\<union> New_Algo_trans_step HOs SHOs crds next2 send2 2\n  \"", "lemma mru_vote_evolution0:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\"", "lemma mru_vote_evolution2:\n  \"\\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\"", "lemma decide_evolution:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"\n  \"\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"", "lemma msgs_mru_vote: \n  assumes\n  \"\\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  shows \"((msgs_to_lvs (\\<mu> p)) |` HOs r p) = (mru_vote o cfg) |` HOs r p\"", "lemma step0_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r C. majorities.opt_mru_step0 r C), \n    New_Algo_trans_step HOs HOs crds next0 send0 0 {> new_algo_ref_rel}\"", "lemma step1_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r S v. majorities.opt_mru_step1 r S v), \n    New_Algo_trans_step HOs HOs crds next1 send1 (Suc 0) {> new_algo_ref_rel}\"", "lemma step2_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r dec_f. majorities.opt_mru_step2 r dec_f), \n    New_Algo_trans_step HOs HOs crds next2 send2 2 {> new_algo_ref_rel}\"", "lemma New_Algo_Refines_votes:\n  \"PO_refines new_algo_ref_rel\n    majorities.ts_mru_TS (New_Algo_TS HOs HOs crds)\"", "theorem New_Algo_termination:\n  assumes run: \"HORun New_Algo_Alg rho HOs\"\n      and commR: \"\\<forall>r. HOcommPerRd New_Algo_M (HOs r)\"\n      and commG: \"HOcommGlobal New_Algo_M HOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], "translations": [["", "lemmas New_Algo_TS_defs = New_Algo_TS_def CHO_to_TS_def New_Algo_Alg_def CHOinitConfig_def\n  NA_initState_def"], ["", "definition New_Algo_trans_step where\n  \"New_Algo_trans_step HOs SHOs crds nxt_f snd_f stp \\<equiv> \\<Union>r \\<mu>.\n    {((r, cfg), (Suc r, cfg'))|cfg cfg'. three_step r = stp  \\<and> (\\<forall>p.\n      \\<mu> p \\<in> get_msgs (snd_f r) cfg (HOs r) (SHOs r) p\n      \\<and> nxt_f r p (cfg p) (\\<mu> p) (crds r) (cfg' p)\n    )}\""], ["", "lemma three_step_less_D:\n  \"0 < three_step r \\<Longrightarrow> three_step r = 1 \\<or> three_step r = 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < three_step r \\<Longrightarrow>\n    three_step r = 1 \\<or> three_step r = 2", "by(unfold three_step_def, arith)"], ["", "lemma New_Algo_trans:\n  \"CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds) = \n  New_Algo_trans_step HOs SHOs crds next0 send0 0\n  \\<union> New_Algo_trans_step HOs SHOs crds next1 send1 1\n  \\<union> New_Algo_trans_step HOs SHOs crds next2 send2 2\n  \""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds) =\n    New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2", "proof(rule equalityI)"], ["proof (state)\ngoal (2 subgoals):\n 1. CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n                New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n                New_Algo_trans_step HOs SHOs crds next2 send2 2\n 2. New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs\n                 (K \\<circ> crds)", "show \"CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n       New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n       New_Algo_trans_step HOs SHOs crds next2 send2 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds)\n    \\<subseteq> New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n                New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n                New_Algo_trans_step HOs SHOs crds next2 send2 2", "by(force simp add: CSHO_trans_alt_def NA_sendMsg_def NA_nextState_def \n    New_Algo_trans_step_def K_def dest!: three_step_less_D)"], ["proof (state)\nthis:\n  CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds)\n  \\<subseteq> New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n              New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n              New_Algo_trans_step HOs SHOs crds next2 send2 2\n\ngoal (1 subgoal):\n 1. New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs\n                 (K \\<circ> crds)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs\n                 (K \\<circ> crds)", "show \"New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs (K \\<circ> crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n    New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n    New_Algo_trans_step HOs SHOs crds next2 send2 2\n    \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs\n                 (K \\<circ> crds)", "by(force simp add: CSHO_trans_alt_def NA_sendMsg_def NA_nextState_def \n    New_Algo_trans_step_def K_def)"], ["proof (state)\nthis:\n  New_Algo_trans_step HOs SHOs crds next0 send0 0 \\<union>\n  New_Algo_trans_step HOs SHOs crds next1 send1 1 \\<union>\n  New_Algo_trans_step HOs SHOs crds next2 send2 2\n  \\<subseteq> CSHO_trans_alt NA_sendMsg NA_nextState HOs SHOs\n               (K \\<circ> crds)\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym rHO = \"nat \\<Rightarrow> process HO\""], ["", "subsubsection \\<open>Refinement\\<close>"], ["", "(******************************************************************************)"], ["", "definition new_algo_ref_rel :: \"(three_step_mru_state \\<times> p_TS_state)set\" where\n  \"new_algo_ref_rel = {(sa, (r, sc)).\n    opt_mru_state.next_round sa = r\n    \\<and> opt_mru_state.decisions sa = pstate.decide o sc\n    \\<and> opt_mru_state.mru_vote sa = pstate.mru_vote o sc\n    \\<and> (three_step r = Suc 0 \\<longrightarrow> three_step_mru_state.candidates sa = ran (prop_vote o sc))\n  }\""], ["", "text \\<open>\n  Different types seem to be derived for the two \\<open>mru_vote_evolution\\<close> lemmas,\n  so we state them separately.\\<close>"], ["", "lemma mru_vote_evolution0:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n    pstate.mru_vote \\<circ> s' = pstate.mru_vote \\<circ> s", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       next0 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (pstate.mru_vote \\<circ> s') x = (pstate.mru_vote \\<circ> s) x", "by(auto simp add: next0_def next2_def Let_def)"], ["", "lemma mru_vote_evolution2:\n  \"\\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> mru_vote o s' = mru_vote o s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. next2 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n    pstate.mru_vote \\<circ> s' = pstate.mru_vote \\<circ> s", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       next2 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (pstate.mru_vote \\<circ> s') x = (pstate.mru_vote \\<circ> s) x", "by(auto simp add: next0_def next2_def Let_def)"], ["", "lemma decide_evolution:\n  \"\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\"\n  \"\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow> decide o s = decide o s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>p. next0 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n     decide \\<circ> s = decide \\<circ> s') &&&\n    (\\<forall>p. next1 r p (s p) (msgs p) (crd p) (s' p) \\<Longrightarrow>\n     decide \\<circ> s = decide \\<circ> s')", "apply(rule_tac[!] ext, rename_tac x, erule_tac[!] x=x in allE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       next0 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (decide \\<circ> s) x = (decide \\<circ> s') x\n 2. \\<And>x.\n       next1 r x (s x) (msgs x) (crd x) (s' x) \\<Longrightarrow>\n       (decide \\<circ> s) x = (decide \\<circ> s') x", "by(auto simp add: next0_def next1_def Let_def)"], ["", "lemma msgs_mru_vote: \n  assumes\n  \"\\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\"\n  shows \"((msgs_to_lvs (\\<mu> p)) |` HOs r p) = (mru_vote o cfg) |` HOs r p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. msgs_to_lvs (\\<mu> p) |` HOs r p =\n    (pstate.mru_vote \\<circ> cfg) |` HOs r p", "using assms"], ["proof (prove)\nusing this:\n  \\<mu> p \\<in> get_msgs (send0 r) cfg (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. msgs_to_lvs (\\<mu> p) |` HOs r p =\n    (pstate.mru_vote \\<circ> cfg) |` HOs r p", "by(auto simp add: get_msgs_benign send0_def restrict_map_def msgs_to_lvs_def\n      map_comp_def intro!: ext split: option.split)"], ["", "lemma step0_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r C. majorities.opt_mru_step0 r C), \n    New_Algo_trans_step HOs HOs crds next0 send0 0 {> new_algo_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} \\<Union>r.\n                          \\<Union>\n                           (range\n                             (majorities.opt_mru_step0\n                               r)), New_Algo_trans_step HOs HOs crds next0\n                                     send0 0 {> new_algo_ref_rel}", "proof(clarsimp simp add: PO_rhoare_defs New_Algo_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> new_algo_ref_rel\"\n    and r: \"three_step r = 0\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have r_phase_step: \"nr_steps * three_phase r = r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 3 * three_phase r = r", "using r three_phase_step[of r]"], ["proof (prove)\nusing this:\n  three_step r = 0\n  three_phase r * 3 + three_step r = r\n\ngoal (1 subgoal):\n 1. 3 * three_phase r = r", "by(auto)"], ["proof (state)\nthis:\n  3 * three_phase r = r\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define C where \"C = ran (prop_vote o sc')\""], ["proof (state)\nthis:\n  C = ran (prop_vote \\<circ> sc')\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have guard: \"\\<forall>cand\\<in>C. \\<exists>Q. majorities.opt_mru_guard (mru_vote \\<circ> sc) Q cand\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>cand\\<in>C.\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "proof(simp add: C_def ran_def, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "fix p cand"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "assume Some: \"prop_vote (sc' p) = Some cand\""], ["proof (state)\nthis:\n  prop_vote (sc' p) = Some cand\n\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "let ?Q = \"HOs r p\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "let ?lvs0 = \"mru_vote o sc\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "have \"?Q \\<in> majs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HOs r p \\<in> majs", "using Some \\<mu>nxt[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  prop_vote (sc' p) = Some cand\n  \\<mu> p \\<in> get_msgs (send0 r) sc (HOs r) (HOs r) p\n  next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. HOs r p \\<in> majs", "by(auto simp add: Let_def majs_def next0_def get_msgs_dom)"], ["proof (state)\nthis:\n  HOs r p \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "moreover"], ["proof (state)\nthis:\n  HOs r p \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "have\n      \"map_option snd (option_Max_by fst (ran (?lvs |` ?Q))) \\<in> {None, Some cand}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_option snd\n     (option_Max_by fst (ran ((pstate.mru_vote \\<circ> sc) |` HOs r p)))\n    \\<in> {None, Some cand}", "using Some nxt[THEN spec, where x=p]\n      msgs_mru_vote[where HOs=HOs and \\<mu>=\\<mu>, OF \\<mu>[THEN spec, of p]]\n      get_msgs_dom[OF \\<mu>[THEN spec, of p]]"], ["proof (prove)\nusing this:\n  prop_vote (sc' p) = Some cand\n  next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  msgs_to_lvs (\\<mu> p) |` HOs r p = (pstate.mru_vote \\<circ> sc) |` HOs r p\n  dom (\\<mu> p) = HOs r p\n\ngoal (1 subgoal):\n 1. map_option snd\n     (option_Max_by fst (ran ((pstate.mru_vote \\<circ> sc) |` HOs r p)))\n    \\<in> {None, Some cand}", "by(auto simp add: next0_def Let_def split: option.split_asm)"], ["proof (state)\nthis:\n  map_option snd\n   (option_Max_by fst (ran ((pstate.mru_vote \\<circ> sc) |` HOs r p)))\n  \\<in> {None, Some cand}\n\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "ultimately"], ["proof (chain)\npicking this:\n  HOs r p \\<in> majs\n  map_option snd\n   (option_Max_by fst (ran ((pstate.mru_vote \\<circ> sc) |` HOs r p)))\n  \\<in> {None, Some cand}", "have \"majorities.opt_mru_guard ?lvs0 ?Q cand\""], ["proof (prove)\nusing this:\n  HOs r p \\<in> majs\n  map_option snd\n   (option_Max_by fst (ran ((pstate.mru_vote \\<circ> sc) |` HOs r p)))\n  \\<in> {None, Some cand}\n\ngoal (1 subgoal):\n 1. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r p) cand", "by(auto simp add: majorities.opt_mru_guard_def Let_def majorities.opt_mru_vote_def)"], ["proof (state)\nthis:\n  majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r p) cand\n\ngoal (1 subgoal):\n 1. \\<And>cand a.\n       prop_vote (sc' a) = Some cand \\<Longrightarrow>\n       \\<exists>Q.\n          majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "thus \"\\<exists>Q. majorities.opt_mru_guard ?lvs0 Q cand\""], ["proof (prove)\nusing this:\n  majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) (HOs r p) cand\n\ngoal (1 subgoal):\n 1. \\<exists>Q. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q. majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>cand\\<in>C.\n     \\<exists>Q.\n        majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define sa' where \"sa' = sa\\<lparr>\n      next_round := Suc r,\n      candidates := C\n    \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\\<lparr>opt_mru_state.next_round := Suc r, candidates := C\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step0 r C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step0 r C", "using R r nxt guard"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = 0\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  \\<forall>cand\\<in>C.\n     \\<exists>Q.\n        majorities.opt_mru_guard (pstate.mru_vote \\<circ> sc) Q cand\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step0 r C", "by(auto simp add: majorities.opt_mru_step0_def sa'_def new_algo_ref_rel_def)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> new_algo_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "using R nxt"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  \\<forall>p. next0 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "apply(auto simp add: sa'_def new_algo_ref_rel_def intro!:\n      mru_vote_evolution0[OF nxt, symmetric] decide_evolution(1)[OF nxt]\n    )"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        three_step (opt_mru_state.next_round sa) \\<noteq> Suc 0;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran (prop_vote \\<circ> sc')\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        three_step (opt_mru_state.next_round sa) \\<noteq> Suc 0;\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> ran (prop_vote \\<circ> sc')\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        candidates sa = ran (prop_vote \\<circ> sc);\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> C\\<rbrakk>\n       \\<Longrightarrow> x \\<in> ran (prop_vote \\<circ> sc')\n 4. \\<And>x.\n       \\<lbrakk>\\<forall>p.\n                   next0 (opt_mru_state.next_round sa) p (sc p) (\\<mu> p)\n                    (crds (opt_mru_state.next_round sa)) (sc' p);\n        r = opt_mru_state.next_round sa;\n        opt_mru_state.decisions sa = decide \\<circ> sc;\n        opt_mru_state.mru_vote sa = pstate.mru_vote \\<circ> sc;\n        candidates sa = ran (prop_vote \\<circ> sc);\n        three_step (Suc (opt_mru_state.next_round sa)) = Suc 0;\n        x \\<in> ran (prop_vote \\<circ> sc')\\<rbrakk>\n       \\<Longrightarrow> x \\<in> C", "apply(auto simp add: Let_def C_def o_def intro!: ext)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 0;\n        \\<forall>p. x p \\<in> get_msgs (send0 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next0 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step0 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \n        \\<and> (sa', Suc r, sc') \\<in> new_algo_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> majorities.opt_mru_step0 r C\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \\<and>\n       (sa', Suc r, sc') \\<in> new_algo_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r C. (sa, sa') \\<in> majorities.opt_mru_step0 r C) \\<and>\n     (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step1_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r S v. majorities.opt_mru_step1 r S v), \n    New_Algo_trans_step HOs HOs crds next1 send1 (Suc 0) {> new_algo_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} \\<Union>r S.\n                          \\<Union>\n                           (range\n                             (majorities.opt_mru_step1 r\n                               S)), New_Algo_trans_step HOs HOs crds next1\n                                     send1 (Suc 0) {> new_algo_ref_rel}", "proof(clarsimp  simp add: PO_rhoare_defs New_Algo_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> new_algo_ref_rel\"\n    and r: \"three_step r = Suc 0\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = Suc 0\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define S where \"S = {p. mru_vote (sc' p) \\<noteq> mru_vote (sc p)}\""], ["proof (state)\nthis:\n  S = {p. pstate.mru_vote (sc' p) \\<noteq> pstate.mru_vote (sc p)}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have S: \"S \\<subseteq> {p. \\<exists>Q v. Q \\<subseteq> HOs r p\n      \\<and> (\\<forall>q \\<in> Q. prop_vote (sc q) = Some v)\n      \\<and> Q \\<in> majs\n      \\<and> (mru_vote (sc' p) = Some (three_phase r, v))\n    }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S \\<subseteq> {p. \\<exists>Q v.\n                         Q \\<subseteq> HOs r p \\<and>\n                         (\\<forall>q\\<in>Q.\n                             prop_vote (sc q) = Some v) \\<and>\n                         Q \\<in> majs \\<and>\n                         pstate.mru_vote (sc' p) = Some (three_phase r, v)}", "proof(safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>Q v.\n          Q \\<subseteq> HOs r x \\<and>\n          (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n          Q \\<in> majs \\<and>\n          pstate.mru_vote (sc' x) = Some (three_phase r, v)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>Q v.\n          Q \\<subseteq> HOs r x \\<and>\n          (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n          Q \\<in> majs \\<and>\n          pstate.mru_vote (sc' x) = Some (three_phase r, v)", "assume \"p \\<in> S\""], ["proof (state)\nthis:\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>Q v.\n          Q \\<subseteq> HOs r x \\<and>\n          (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n          Q \\<in> majs \\<and>\n          pstate.mru_vote (sc' x) = Some (three_phase r, v)", "then"], ["proof (chain)\npicking this:\n  p \\<in> S", "obtain Q v \n      where \n      \"\\<forall>q \\<in> Q. \\<mu> p q = Some (PreVote v)\"\n      and maj_Q: \"Q \\<in> majs\"\n      and Q_HOs: \"Q \\<subseteq> dom (\\<mu> p)\"\n      and lv: \"mru_vote (sc' p) = Some (three_phase r, v)\" (is \"?LV v\")"], ["proof (prove)\nusing this:\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>Q v.\n        \\<lbrakk>\\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v);\n         Q \\<in> majs; Q \\<subseteq> dom (\\<mu> p);\n         pstate.mru_vote (sc' p) = Some (three_phase r, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nxt[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  p \\<in> S\n  next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (\\<And>Q v.\n        \\<lbrakk>\\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v);\n         Q \\<in> majs; Q \\<subseteq> dom (\\<mu> p);\n         pstate.mru_vote (sc' p) = Some (three_phase r, v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(clarsimp simp add: next1_def Let_def S_def majs_def Q_prevotes_v_def)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v)\n  Q \\<in> majs\n  Q \\<subseteq> dom (\\<mu> p)\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>Q v.\n          Q \\<subseteq> HOs r x \\<and>\n          (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n          Q \\<in> majs \\<and>\n          pstate.mru_vote (sc' x) = Some (three_phase r, v)", "then"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v)\n  Q \\<in> majs\n  Q \\<subseteq> dom (\\<mu> p)\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)", "have \n      \"\\<forall>q \\<in> Q. prop_vote (sc q) = Some v\" (is \"?P Q v\")\n      \"Q \\<subseteq> HOs r p\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v)\n  Q \\<in> majs\n  Q \\<subseteq> dom (\\<mu> p)\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>Q. prop_vote (sc q) = Some v &&& Q \\<subseteq> HOs r p", "using \\<mu>[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (PreVote v)\n  Q \\<in> majs\n  Q \\<subseteq> dom (\\<mu> p)\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)\n  \\<mu> p \\<in> get_msgs (send1 r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>Q. prop_vote (sc q) = Some v &&& Q \\<subseteq> HOs r p", "by(auto simp add: get_msgs_benign send1_def restrict_map_def split: option.split_asm)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<subseteq> HOs r p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> S \\<Longrightarrow>\n       \\<exists>Q v.\n          Q \\<subseteq> HOs r x \\<and>\n          (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n          Q \\<in> majs \\<and>\n          pstate.mru_vote (sc' x) = Some (three_phase r, v)", "with maj_Q and lv"], ["proof (chain)\npicking this:\n  Q \\<in> majs\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<subseteq> HOs r p", "show \"\\<exists>Q v. Q \\<subseteq> HOs r p \\<and> ?P Q v \\<and> Q \\<in> majs \\<and> ?LV v\""], ["proof (prove)\nusing this:\n  Q \\<in> majs\n  pstate.mru_vote (sc' p) = Some (three_phase r, v)\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<subseteq> HOs r p\n\ngoal (1 subgoal):\n 1. \\<exists>Q v.\n       Q \\<subseteq> HOs r p \\<and>\n       (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n       Q \\<in> majs \\<and> pstate.mru_vote (sc' p) = Some (three_phase r, v)", "by blast"], ["proof (state)\nthis:\n  \\<exists>Q v.\n     Q \\<subseteq> HOs r p \\<and>\n     (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n     Q \\<in> majs \\<and> pstate.mru_vote (sc' p) = Some (three_phase r, v)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S \\<subseteq> {p. \\<exists>Q v.\n                       Q \\<subseteq> HOs r p \\<and>\n                       (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n                       Q \\<in> majs \\<and>\n                       pstate.mru_vote (sc' p) = Some (three_phase r, v)}\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "obtain v where \n    v: \"\\<forall>p \\<in> S. mru_vote (sc' p) = Some (three_phase r, v) \\<and> v \\<in> ran (prop_vote o sc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<forall>p\\<in>S.\n           pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n           v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof(cases \"S = {}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "case False"], ["proof (state)\nthis:\n  S \\<noteq> {}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "assume asm: \n      \"\\<And>v. \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and> v \\<in> ran (prop_vote o sc)  \n        \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, ?v) \\<and>\n     ?v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n  thesis\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "from False"], ["proof (chain)\npicking this:\n  S \\<noteq> {}", "obtain p where \"p \\<in> S\""], ["proof (prove)\nusing this:\n  S \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>p. p \\<in> S \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  p \\<in> S\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "with S nxt"], ["proof (chain)\npicking this:\n  S \\<subseteq> {p. \\<exists>Q v.\n                       Q \\<subseteq> HOs r p \\<and>\n                       (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n                       Q \\<in> majs \\<and>\n                       pstate.mru_vote (sc' p) = Some (three_phase r, v)}\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  p \\<in> S", "obtain Q v \n      where prop_vote: \"(\\<forall>q \\<in> Q. prop_vote (sc q) = Some v)\" and maj_Q: \"Q \\<in> majs\""], ["proof (prove)\nusing this:\n  S \\<subseteq> {p. \\<exists>Q v.\n                       Q \\<subseteq> HOs r p \\<and>\n                       (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n                       Q \\<in> majs \\<and>\n                       pstate.mru_vote (sc' p) = Some (three_phase r, v)}\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  p \\<in> S\n\ngoal (1 subgoal):\n 1. (\\<And>Q v.\n        \\<lbrakk>\\<forall>q\\<in>Q. prop_vote (sc q) = Some v;\n         Q \\<in> majs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<in> majs\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "hence \"\\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)\" (is \"?LV(v)\")"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)", "using S"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<in> majs\n  S \\<subseteq> {p. \\<exists>Q v.\n                       Q \\<subseteq> HOs r p \\<and>\n                       (\\<forall>q\\<in>Q. prop_vote (sc q) = Some v) \\<and>\n                       Q \\<in> majs \\<and>\n                       pstate.mru_vote (sc' p) = Some (three_phase r, v)}\n\ngoal (1 subgoal):\n 1. \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)", "by(fastforce dest!: subsetD dest: majorities.qintersect)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis\n 2. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S \\<noteq> {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "with asm prop_vote maj_Q"], ["proof (chain)\npicking this:\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, ?v) \\<and>\n     ?v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n  thesis\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<in> majs\n  \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)", "show thesis"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, ?v) \\<and>\n     ?v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n  thesis\n  \\<forall>q\\<in>Q. prop_vote (sc q) = Some v\n  Q \\<in> majs\n  \\<forall>p\\<in>S. pstate.mru_vote (sc' p) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis all_not_in_conv comp_eq_dest_lhs majorities.empty_not_quorum ranI)"], ["proof (state)\nthis:\n  thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>v.\n                \\<forall>p\\<in>S.\n                   pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n                   v \\<in> ran (prop_vote \\<circ> sc) \\<Longrightarrow>\n                thesis;\n     S = {}\\<rbrakk>\n    \\<Longrightarrow> thesis", "qed(auto)"], ["proof (state)\nthis:\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n     v \\<in> ran (prop_vote \\<circ> sc)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define sa' where \"sa' = sa\\<lparr> next_round := Suc r, \n    opt_mru_state.mru_vote := opt_mru_state.mru_vote sa ++ const_map (three_phase r, v) S\n  \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_mru_state.next_round := Suc r,\n     opt_mru_state.mru_vote :=\n       opt_mru_state.mru_vote sa ++ const_map (three_phase r, v) S\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step1 r S v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step1 r S v", "using r R v"], ["proof (prove)\nusing this:\n  three_step r = Suc 0\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n     v \\<in> ran (prop_vote \\<circ> sc)\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step1 r S v", "by(clarsimp simp add: majorities.opt_mru_step1_def sa'_def \n      new_algo_ref_rel_def ball_conj_distrib)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> new_algo_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "using r R"], ["proof (prove)\nusing this:\n  three_step r = Suc 0\n  (sa, r, sc) \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = Suc 0;\n     (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa', Suc r, sc') \\<in> new_algo_ref_rel", "have \"mru_vote o sc' = ((mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.mru_vote \\<circ> sc' =\n    (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S", "proof(rule ext, simp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pstate.mru_vote (sc' x) =\n       ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       pstate.mru_vote (sc' x) =\n       ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) x", "show \"mru_vote (sc' p) = ((mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pstate.mru_vote (sc' p) =\n    ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p", "using v"], ["proof (prove)\nusing this:\n  \\<forall>p\\<in>S.\n     pstate.mru_vote (sc' p) = Some (three_phase r, v) \\<and>\n     v \\<in> ran (prop_vote \\<circ> sc)\n\ngoal (1 subgoal):\n 1. pstate.mru_vote (sc' p) =\n    ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p", "by(auto simp add: S_def map_add_def const_map_is_None const_map_is_Some split: option.split)"], ["proof (state)\nthis:\n  pstate.mru_vote (sc' p) =\n  ((pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S) p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = Suc 0;\n     (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa', Suc r, sc') \\<in> new_algo_ref_rel", "thus ?thesis"], ["proof (prove)\nusing this:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "using R r nxt"], ["proof (prove)\nusing this:\n  pstate.mru_vote \\<circ> sc' =\n  (pstate.mru_vote \\<circ> sc) ++ const_map (three_phase r, v) S\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = Suc 0\n  \\<forall>p. next1 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "by(force simp add: new_algo_ref_rel_def sa'_def three_step_Suc intro: decide_evolution)"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = Suc 0;\n        \\<forall>p. x p \\<in> get_msgs (send1 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next1 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa xb.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step1 x xa\n xb) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel", "show \n    \"\\<exists>sa'. (\\<exists>r S v. (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \n        \\<and> (sa', Suc r, sc') \\<in> new_algo_ref_rel\""], ["proof (prove)\nusing this:\n  (sa, sa') \\<in> majorities.opt_mru_step1 r S v\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r S v.\n           (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \\<and>\n       (sa', Suc r, sc') \\<in> new_algo_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r S v. (sa, sa') \\<in> majorities.opt_mru_step1 r S v) \\<and>\n     (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma step2_ref:\n  \"{new_algo_ref_rel} \n    (\\<Union>r dec_f. majorities.opt_mru_step2 r dec_f), \n    New_Algo_trans_step HOs HOs crds next2 send2 2 {> new_algo_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} \\<Union>r.\n                          \\<Union>\n                           (range\n                             (majorities.opt_mru_step2\n                               r)), New_Algo_trans_step HOs HOs crds next2\n                                     send2 2 {> new_algo_ref_rel}", "proof(clarsimp  simp add: PO_rhoare_defs New_Algo_trans_step_def all_conj_distrib)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "fix r sa sc sc' \\<mu>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "assume R: \"(sa, (r, sc)) \\<in> new_algo_ref_rel\"\n    and r: \"three_step r = 2\"\n    and \\<mu>: \"\\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\"\n        and nxt: \"\\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\""], ["proof (state)\nthis:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = 2\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "note \\<mu>nxt = \\<mu> nxt"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define dec_f\n    where \"dec_f p = (if decide (sc' p) \\<noteq> decide (sc p) then decide (sc' p) else None)\" for p"], ["proof (state)\nthis:\n  dec_f ?p =\n  (if decide (sc' ?p) \\<noteq> decide (sc ?p) then decide (sc' ?p)\n   else None)\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have dec_f: \"(decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ((decide \\<circ> sc) ++ dec_f) x = (decide \\<circ> sc') x", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. ((decide \\<circ> sc) ++ dec_f) x = (decide \\<circ> sc') x", "show \"((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p", "using nxt[THEN spec, of p]"], ["proof (prove)\nusing this:\n  next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p", "by(auto simp add: map_add_def dec_f_def next2_def Let_def split: option.split intro!: ext)"], ["proof (state)\nthis:\n  ((decide \\<circ> sc) ++ dec_f) p = (decide \\<circ> sc') p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (decide \\<circ> sc) ++ dec_f = decide \\<circ> sc'\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "define sa' where \"sa' = sa\\<lparr>\n    next_round := Suc r,\n    decisions := decisions sa ++ dec_f\n  \\<rparr>\""], ["proof (state)\nthis:\n  sa' = sa\n  \\<lparr>opt_mru_state.next_round := Suc r,\n     opt_mru_state.decisions := opt_mru_state.decisions sa ++ dec_f\\<rparr>\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa', (Suc r, sc')) \\<in> new_algo_ref_rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "using R r nxt"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = 2\n  \\<forall>p. next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n\ngoal (1 subgoal):\n 1. (sa', Suc r, sc') \\<in> new_algo_ref_rel", "by(auto simp add: new_algo_ref_rel_def sa'_def dec_f three_step_Suc \n      mru_vote_evolution2[OF nxt])"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "moreover"], ["proof (state)\nthis:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "have \"(sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "using r R"], ["proof (prove)\nusing this:\n  three_step r = 2\n  (sa, r, sc) \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "define sc_r_votes where \"sc_r_votes p = (if (\\<exists>v. mru_vote (sc p) = Some (three_phase r, v))\n        then map_option snd (mru_vote (sc p))\n        else None)\" for p"], ["proof (state)\nthis:\n  sc_r_votes ?p =\n  (if \\<exists>v. pstate.mru_vote (sc ?p) = Some (three_phase r, v)\n   then map_option snd (pstate.mru_vote (sc ?p)) else None)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "have sc_r_votes: \"sc_r_votes = majorities.r_votes sa r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sc_r_votes = majorities.r_votes sa r", "using R r"], ["proof (prove)\nusing this:\n  (sa, r, sc) \\<in> new_algo_ref_rel\n  three_step r = 2\n\ngoal (1 subgoal):\n 1. sc_r_votes = majorities.r_votes sa r", "by(auto simp add: new_algo_ref_rel_def sc_r_votes_def majorities.r_votes_def intro!: ext)"], ["proof (state)\nthis:\n  sc_r_votes = majorities.r_votes sa r\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "have \"majorities.step2_d_guard dec_f sc_r_votes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. majorities.step2_d_guard dec_f sc_r_votes", "proof(clarsimp simp add: majorities.step2_d_guard_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "fix p v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "assume d_f_p: \"dec_f p = Some v\""], ["proof (state)\nthis:\n  dec_f p = Some v\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "then"], ["proof (chain)\npicking this:\n  dec_f p = Some v", "obtain Q where Q: \n        \"Q \\<in> majs\"\n        and vote: \"Q \\<subseteq> HOs r p\" \"\\<forall>q\\<in>Q. \\<mu> p q = Some (Vote v)\""], ["proof (prove)\nusing this:\n  dec_f p = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>Q \\<in> majs; Q \\<subseteq> HOs r p;\n         \\<forall>q\\<in>Q. \\<mu> p q = Some (Vote v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using nxt[THEN spec, of p] d_f_p"], ["proof (prove)\nusing this:\n  dec_f p = Some v\n  next2 r p (sc p) (\\<mu> p) (crds r) (sc' p)\n  dec_f p = Some v\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>Q \\<in> majs; Q \\<subseteq> HOs r p;\n         \\<forall>q\\<in>Q. \\<mu> p q = Some (Vote v)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: next2_def dec_f_def Q'_votes_v_def Let_def majs_def)"], ["proof (state)\nthis:\n  Q \\<in> majs\n  Q \\<subseteq> HOs r p\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (Vote v)\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "have mru_vote: \"\\<forall>q\\<in>Q. mru_vote (sc q) = Some (three_phase r, v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>Q. pstate.mru_vote (sc q) = Some (three_phase r, v)", "using vote \\<mu>[THEN spec, of p]"], ["proof (prove)\nusing this:\n  Q \\<subseteq> HOs r p\n  \\<forall>q\\<in>Q. \\<mu> p q = Some (Vote v)\n  \\<mu> p \\<in> get_msgs (send2 r) sc (HOs r) (HOs r) p\n\ngoal (1 subgoal):\n 1. \\<forall>q\\<in>Q. pstate.mru_vote (sc q) = Some (three_phase r, v)", "by(fastforce simp add: get_msgs_benign send2_def sc_r_votes_def restrict_map_def \n          split: option.split_asm if_split_asm)"], ["proof (state)\nthis:\n  \\<forall>q\\<in>Q. pstate.mru_vote (sc q) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "hence \"dom sc_r_votes \\<in> majs\""], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>Q. pstate.mru_vote (sc q) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. dom sc_r_votes \\<in> majs", "by(auto intro!:  majorities.mono_quorum[OF Q] simp add: sc_r_votes_def)"], ["proof (state)\nthis:\n  dom sc_r_votes \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "moreover"], ["proof (state)\nthis:\n  dom sc_r_votes \\<in> majs\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "have \"v \\<in> ran sc_r_votes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<in> ran sc_r_votes", "using Q[THEN majorities.quorum_non_empty] mru_vote"], ["proof (prove)\nusing this:\n  Q \\<noteq> {}\n  \\<forall>q\\<in>Q. pstate.mru_vote (sc q) = Some (three_phase r, v)\n\ngoal (1 subgoal):\n 1. v \\<in> ran sc_r_votes", "by(force simp add: sc_r_votes_def ex_in_conv[symmetric] intro: ranI)"], ["proof (state)\nthis:\n  v \\<in> ran sc_r_votes\n\ngoal (1 subgoal):\n 1. \\<And>p v.\n       dec_f p = Some v \\<Longrightarrow>\n       v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "ultimately"], ["proof (chain)\npicking this:\n  dom sc_r_votes \\<in> majs\n  v \\<in> ran sc_r_votes", "show \"v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs\""], ["proof (prove)\nusing this:\n  dom sc_r_votes \\<in> majs\n  v \\<in> ran sc_r_votes\n\ngoal (1 subgoal):\n 1. v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs", "by blast"], ["proof (state)\nthis:\n  v \\<in> ran sc_r_votes \\<and> dom sc_r_votes \\<in> majs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  majorities.step2_d_guard dec_f sc_r_votes\n\ngoal (1 subgoal):\n 1. \\<lbrakk>three_step r = 2; (sa, r, sc) \\<in> new_algo_ref_rel\\<rbrakk>\n    \\<Longrightarrow> (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "thus ?thesis"], ["proof (prove)\nusing this:\n  majorities.step2_d_guard dec_f sc_r_votes\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "using r R"], ["proof (prove)\nusing this:\n  majorities.step2_d_guard dec_f sc_r_votes\n  three_step r = 2\n  (sa, r, sc) \\<in> new_algo_ref_rel\n\ngoal (1 subgoal):\n 1. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "by(auto simp add: majorities.opt_mru_step2_def sa'_def new_algo_ref_rel_def sc_r_votes)"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal (1 subgoal):\n 1. \\<And>a ab ba x cfg'.\n       \\<lbrakk>(a, ab, ba) \\<in> new_algo_ref_rel; three_step ab = 2;\n        \\<forall>p. x p \\<in> get_msgs (send2 ab) ba (HOs ab) (HOs ab) p;\n        \\<forall>p. next2 ab p (ba p) (x p) (crds ab) (cfg' p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (\\<exists>x xa.\n                                (a, y)\n                                \\<in> majorities.opt_mru_step2 x xa) \\<and>\n                            (y, Suc ab, cfg') \\<in> new_algo_ref_rel", "ultimately"], ["proof (chain)\npicking this:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f", "show \n    \"\\<exists>sa'. (\\<exists>r dec_f. (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \n        \\<and> (sa', Suc r, sc') \\<in> new_algo_ref_rel\""], ["proof (prove)\nusing this:\n  (sa', Suc r, sc') \\<in> new_algo_ref_rel\n  (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f\n\ngoal (1 subgoal):\n 1. \\<exists>sa'.\n       (\\<exists>r dec_f.\n           (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \\<and>\n       (sa', Suc r, sc') \\<in> new_algo_ref_rel", "by blast"], ["proof (state)\nthis:\n  \\<exists>sa'.\n     (\\<exists>r dec_f.\n         (sa, sa') \\<in> majorities.opt_mru_step2 r dec_f) \\<and>\n     (sa', Suc r, sc') \\<in> new_algo_ref_rel\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma New_Algo_Refines_votes:\n  \"PO_refines new_algo_ref_rel\n    majorities.ts_mru_TS (New_Algo_TS HOs HOs crds)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. PO_refines new_algo_ref_rel majorities.ts_mru_TS\n     (New_Algo_TS HOs HOs crds)", "proof(rule refine_basic)"], ["proof (state)\ngoal (2 subgoals):\n 1. init (New_Algo_TS HOs HOs crds)\n    \\<subseteq> new_algo_ref_rel `` init majorities.ts_mru_TS\n 2. {new_algo_ref_rel} TS.trans\n                        majorities.ts_mru_TS, TS.trans\n         (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}", "show \"init (New_Algo_TS HOs HOs crds) \\<subseteq> new_algo_ref_rel `` init majorities.ts_mru_TS\""], ["proof (prove)\ngoal (1 subgoal):\n 1. init (New_Algo_TS HOs HOs crds)\n    \\<subseteq> new_algo_ref_rel `` init majorities.ts_mru_TS", "by(auto simp add: New_Algo_TS_defs majorities.ts_mru_TS_defs new_algo_ref_rel_def)"], ["proof (state)\nthis:\n  init (New_Algo_TS HOs HOs crds)\n  \\<subseteq> new_algo_ref_rel `` init majorities.ts_mru_TS\n\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} TS.trans\n                        majorities.ts_mru_TS, TS.trans\n         (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} TS.trans\n                        majorities.ts_mru_TS, TS.trans\n         (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}", "show \n    \"{new_algo_ref_rel} TS.trans majorities.ts_mru_TS, \n      TS.trans (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} TS.trans\n                        majorities.ts_mru_TS, TS.trans\n         (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}", "apply(simp add: majorities.ts_mru_TS_defs New_Algo_TS_defs)"], ["proof (prove)\ngoal (1 subgoal):\n 1. {new_algo_ref_rel} ((\\<Union>x.\n                            \\<Union>\n                             (range (majorities.opt_mru_step0 x))) \\<union>\n                        (\\<Union>x xa.\n                            \\<Union>\n                             (range\n                               (majorities.opt_mru_step1 x xa))) \\<union>\n                        (\\<Union>x.\n                            \\<Union>\n                             (range\n                               (majorities.opt_mru_step2\n                                 x))))\\<^sup>=, CHO_trans\n           \\<lparr>CinitState = NA_initState, sendMsg = NA_sendMsg,\n              CnextState = NA_nextState\\<rparr>\n           HOs HOs (K \\<circ> crds) {> new_algo_ref_rel}", "apply(auto simp add: CHO_trans_alt New_Algo_trans intro!: step0_ref step1_ref step2_ref)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  {new_algo_ref_rel} TS.trans\n                      majorities.ts_mru_TS, TS.trans\n       (New_Algo_TS HOs HOs crds) {> new_algo_ref_rel}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Termination\\<close>"], ["", "(******************************************************************************)"], ["", "theorem New_Algo_termination:\n  assumes run: \"HORun New_Algo_Alg rho HOs\"\n      and commR: \"\\<forall>r. HOcommPerRd New_Algo_M (HOs r)\"\n      and commG: \"HOcommGlobal New_Algo_M HOs\"\n  shows \"\\<exists>r v. decide (rho r p) = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from commG"], ["proof (chain)\npicking this:\n  HOcommGlobal New_Algo_M HOs", "obtain ph where \n    HOs: \"\\<forall>i \\<in> {0..2}. \n      (\\<forall>p. card (HOs (nr_steps*ph+i) p) > N div 2)\n      \\<and> (\\<forall>p q. HOs (nr_steps*ph+i) p = HOs (nr_steps*ph) q)\""], ["proof (prove)\nusing this:\n  HOcommGlobal New_Algo_M HOs\n\ngoal (1 subgoal):\n 1. (\\<And>ph.\n        \\<forall>i\\<in>{0..2}.\n           (\\<forall>p. N div 2 < card (HOs (3 * ph + i) p)) \\<and>\n           (\\<forall>p q.\n               HOs (3 * ph + i) p = HOs (3 * ph) q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: New_Algo_HOMachine_def NA_commGlobal_def)\n\n  \\<comment> \\<open>The tedious bit: obtain four consecutive rounds linked by send/next functions\\<close>"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{0..2}.\n     (\\<forall>p. N div 2 < card (HOs (3 * ph + i) p)) \\<and>\n     (\\<forall>p q. HOs (3 * ph + i) p = HOs (3 * ph) q)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r0 where \"r0 = nr_steps * ph\""], ["proof (state)\nthis:\n  r0 = 3 * ph\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg0 where \"cfg0 = rho r0\""], ["proof (state)\nthis:\n  cfg0 = rho r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r1 where \"r1 = Suc r0\""], ["proof (state)\nthis:\n  r1 = Suc r0\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg1 where \"cfg1 = rho r1\""], ["proof (state)\nthis:\n  cfg1 = rho r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define r2 where \"r2 = Suc r1\""], ["proof (state)\nthis:\n  r2 = Suc r1\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg2 where \"cfg2 = rho r2\""], ["proof (state)\nthis:\n  cfg2 = rho r2\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "define cfg3 where \"cfg3 = rho (Suc r2)\""], ["proof (state)\nthis:\n  cfg3 = rho (Suc r2)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from \n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r0\"] \n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r1\"]\n    run[simplified HORun_def SHORun_def, THEN CSHORun_step, THEN spec, where x=\"r2\"]"], ["proof (chain)\npicking this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState New_Algo_Alg r0 p (rho r0 p) (\\<mu> p) undefined\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState New_Algo_Alg r1 p (rho r1 p) (\\<mu> p) undefined\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState New_Algo_Alg r2 p (rho r2 p) (\\<mu> p) undefined\n         (rho (Suc r2) p)", "obtain \\<mu>0 \\<mu>1 \\<mu>2 where\n    send0: \"\\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\"\n    and three_step0: \"\\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\"\n    and send1: \"\\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\"\n    and three_step1: \"\\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) undefined (cfg2 p)\"\n    and send2: \"\\<forall>p. \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\"\n    and three_step2: \"\\<forall>p. next2 r2 p (cfg2 p) (\\<mu>2 p) undefined (cfg3 p)\""], ["proof (prove)\nusing this:\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r0) (rho r0) (HOs r0) (HOs r0)\n               p \\<and>\n        CnextState New_Algo_Alg r0 p (rho r0 p) (\\<mu> p) undefined\n         (rho (Suc r0) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r1) (rho r1) (HOs r1) (HOs r1)\n               p \\<and>\n        CnextState New_Algo_Alg r1 p (rho r1 p) (\\<mu> p) undefined\n         (rho (Suc r1) p)\n  \\<exists>\\<mu>.\n     \\<forall>p.\n        \\<mu> p\n        \\<in> get_msgs (sendMsg New_Algo_Alg r2) (rho r2) (HOs r2) (HOs r2)\n               p \\<and>\n        CnextState New_Algo_Alg r2 p (rho r2 p) (\\<mu> p) undefined\n         (rho (Suc r2) p)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<mu>0 \\<mu>1 \\<mu>2.\n        \\<lbrakk>\\<forall>p.\n                    \\<mu>0 p\n                    \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p;\n         \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p);\n         \\<forall>p.\n            \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p;\n         \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) undefined (cfg2 p);\n         \\<forall>p.\n            \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p;\n         \\<forall>p.\n            next2 r2 p (cfg2 p) (\\<mu>2 p) undefined (cfg3 p)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "apply(auto simp add: New_Algo_Alg_def three_step_def NA_nextState_def NA_sendMsg_def all_conj_distrib\n      r0_def r1_def r2_def\n      cfg0_def cfg1_def cfg2_def cfg3_def mod_Suc\n      )"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>The proof: everybody hears the same messages (non-empty!) in r0...\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\n  \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n  \\<forall>p. next1 r1 p (cfg1 p) (\\<mu>1 p) undefined (cfg2 p)\n  \\<forall>p. \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\n  \\<forall>p. next2 r2 p (cfg2 p) (\\<mu>2 p) undefined (cfg3 p)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from HOs[THEN bspec, where x=0, simplified] send0"], ["proof (chain)\npicking this:\n  (\\<forall>p. N div 2 < card (HOs (3 * ph) p)) \\<and>\n  (\\<forall>p q. HOs (3 * ph) p = HOs (3 * ph) q)\n  \\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p", "have \n    \"\\<forall>p q. \\<mu>0 p = \\<mu>0 q\" \"\\<forall>p. N div 2 < card (dom (\\<mu>0 p))\""], ["proof (prove)\nusing this:\n  (\\<forall>p. N div 2 < card (HOs (3 * ph) p)) \\<and>\n  (\\<forall>p q. HOs (3 * ph) p = HOs (3 * ph) q)\n  \\<forall>p. \\<mu>0 p \\<in> get_msgs (send0 r0) cfg0 (HOs r0) (HOs r0) p\n\ngoal (1 subgoal):\n 1. \\<forall>p q. \\<mu>0 p = \\<mu>0 q &&&\n    \\<forall>p. N div 2 < card (dom (\\<mu>0 p))", "apply(auto simp add: get_msgs_benign send0_def r1_def r0_def dom_def restrict_map_def intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q xa.\n       \\<lbrakk>\\<forall>p.\n                   \\<mu>0 p =\n                   (\\<lambda>xa.\n                       if xa \\<in> HOs (3 * ph) p\n                       then (Some \\<circ>\n                             (\\<lambda>q.\n                                 MruVote (pstate.mru_vote (cfg0 q))\n                                  (x (cfg0 q))))\n                             xa\n                       else None);\n        \\<forall>p. N div 2 < card (HOs (3 * ph) p);\n        \\<forall>p q. HOs (3 * ph) p = HOs (3 * ph) q;\n        xa \\<in> HOs (3 * ph) p\\<rbrakk>\n       \\<Longrightarrow> xa \\<in> HOs (3 * ph) q\n 2. \\<And>p q xa.\n       \\<lbrakk>\\<forall>p.\n                   \\<mu>0 p =\n                   (\\<lambda>xa.\n                       if xa \\<in> HOs (3 * ph) p\n                       then (Some \\<circ>\n                             (\\<lambda>q.\n                                 MruVote (pstate.mru_vote (cfg0 q))\n                                  (x (cfg0 q))))\n                             xa\n                       else None);\n        \\<forall>p. N div 2 < card (HOs (3 * ph) p);\n        \\<forall>p q. HOs (3 * ph) p = HOs (3 * ph) q;\n        xa \\<notin> HOs (3 * ph) p; xa \\<in> HOs (3 * ph) q\\<rbrakk>\n       \\<Longrightarrow> False", "apply(blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>...hence everybody sets @{term prop_vote} to the same value...\\<close>"], ["proof (state)\nthis:\n  \\<forall>p q. \\<mu>0 p = \\<mu>0 q\n  \\<forall>p. N div 2 < card (dom (\\<mu>0 p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "hence same_prevote: \n    \"\\<forall>p. prop_vote (cfg1 p) \\<noteq> None\"\n    \"\\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)\""], ["proof (prove)\nusing this:\n  \\<forall>p q. \\<mu>0 p = \\<mu>0 q\n  \\<forall>p. N div 2 < card (dom (\\<mu>0 p))\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_vote (cfg1 p) \\<noteq> None &&&\n    \\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)", "using three_step0"], ["proof (prove)\nusing this:\n  \\<forall>p q. \\<mu>0 p = \\<mu>0 q\n  \\<forall>p. N div 2 < card (dom (\\<mu>0 p))\n  \\<forall>p. next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\n\ngoal (1 subgoal):\n 1. \\<forall>p. prop_vote (cfg1 p) \\<noteq> None &&&\n    \\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)", "apply(auto simp add: next1_def Let_def all_conj_distrib intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p.\n       \\<lbrakk>\\<forall>p q. \\<mu>0 p = \\<mu>0 q;\n        \\<forall>p. N div 2 < card (dom (\\<mu>0 p));\n        \\<forall>p.\n           next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. prop_vote (cfg1 p) = Some y\n 2. \\<And>p q.\n       \\<lbrakk>\\<forall>p q. \\<mu>0 p = \\<mu>0 q;\n        \\<forall>p. N div 2 < card (dom (\\<mu>0 p));\n        \\<forall>p.\n           next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\\<rbrakk>\n       \\<Longrightarrow> prop_vote (cfg1 p) = prop_vote (cfg1 q)", "apply(clarsimp simp add: next0_def all_conj_distrib Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>p q. \\<mu>0 p = \\<mu>0 q;\n        \\<forall>p. N div 2 < card (dom (\\<mu>0 p));\n        \\<forall>p.\n           next0 r0 p (cfg0 p) (\\<mu>0 p) undefined (cfg1 p)\\<rbrakk>\n       \\<Longrightarrow> prop_vote (cfg1 p) = prop_vote (cfg1 q)", "apply(clarsimp simp add: next0_def all_conj_distrib Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p q.\n       \\<lbrakk>\\<forall>p q. \\<mu>0 p = \\<mu>0 q;\n        \\<forall>p. N div 2 < card (dom (\\<mu>0 p));\n        \\<forall>p.\n           \\<mu>0 p = Map.empty \\<longrightarrow>\n           cfg1 p = cfg0 p\n           \\<lparr>prop_vote :=\n                     Some\n                      (case option_Max_by fst {} of\n                       None \\<Rightarrow> x (cfg0 p)\n                       | Some x \\<Rightarrow> snd x)\\<rparr>;\n        \\<forall>p.\n           \\<mu>0 p = Map.empty \\<or>\n           cfg1 p = cfg0 p\n           \\<lparr>prop_vote :=\n                     Some\n                      (case option_Max_by fst\n                             (ran (msgs_to_lvs (\\<mu>0 p) |`\n                                   dom (\\<mu>0 p))) of\n                       None \\<Rightarrow> smallest_proposal (\\<mu>0 p)\n                       | Some x \\<Rightarrow> snd x)\\<rparr>\\<rbrakk>\n       \\<Longrightarrow> (\\<mu>0 p = Map.empty \\<longrightarrow>\n                          (\\<mu>0 q = Map.empty \\<longrightarrow>\n                           (case option_Max_by fst {} of\n                            None \\<Rightarrow> x (cfg0 p)\n                            | Some x \\<Rightarrow> snd x) =\n                           (case option_Max_by fst {} of\n                            None \\<Rightarrow> x (cfg0 q)\n                            | Some x \\<Rightarrow> snd x)) \\<and>\n                          (\\<mu>0 q \\<noteq> Map.empty \\<longrightarrow>\n                           (case option_Max_by fst {} of\n                            None \\<Rightarrow> x (cfg0 p)\n                            | Some x \\<Rightarrow> snd x) =\n                           (case option_Max_by fst\n                                  (ran (msgs_to_lvs (\\<mu>0 q) |`\n  dom (\\<mu>0 q))) of\n                            None \\<Rightarrow> smallest_proposal (\\<mu>0 q)\n                            | Some x \\<Rightarrow> snd x))) \\<and>\n                         (\\<mu>0 p \\<noteq> Map.empty \\<longrightarrow>\n                          (\\<mu>0 q = Map.empty \\<longrightarrow>\n                           (case option_Max_by fst\n                                  (ran (msgs_to_lvs (\\<mu>0 p) |`\n  dom (\\<mu>0 p))) of\n                            None \\<Rightarrow> smallest_proposal (\\<mu>0 p)\n                            | Some x \\<Rightarrow> snd x) =\n                           (case option_Max_by fst {} of\n                            None \\<Rightarrow> x (cfg0 q)\n                            | Some x \\<Rightarrow> snd x)) \\<and>\n                          (\\<mu>0 q \\<noteq> Map.empty \\<longrightarrow>\n                           (case option_Max_by fst\n                                  (ran (msgs_to_lvs (\\<mu>0 p) |`\n  dom (\\<mu>0 p))) of\n                            None \\<Rightarrow> smallest_proposal (\\<mu>0 p)\n                            | Some x \\<Rightarrow> snd x) =\n                           (case option_Max_by fst\n                                  (ran (msgs_to_lvs (\\<mu>0 q) |`\n  dom (\\<mu>0 q))) of\n                            None \\<Rightarrow> smallest_proposal (\\<mu>0 q)\n                            | Some x \\<Rightarrow> snd x)))", "by (metis (full_types) dom_eq_empty_conv empty_iff majoritiesE')\n\n  \\<comment> \\<open>...which will become our decision value.\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. prop_vote (cfg1 p) \\<noteq> None\n  \\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "then"], ["proof (chain)\npicking this:\n  \\<forall>p. prop_vote (cfg1 p) \\<noteq> None\n  \\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)", "obtain dec_v where dec_v: \"\\<forall>p. prop_vote (cfg1 p) = Some dec_v\""], ["proof (prove)\nusing this:\n  \\<forall>p. prop_vote (cfg1 p) \\<noteq> None\n  \\<forall>p q. prop_vote (cfg1 p) = prop_vote (cfg1 q)\n\ngoal (1 subgoal):\n 1. (\\<And>dec_v.\n        \\<forall>p. prop_vote (cfg1 p) = Some dec_v \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis option.collapse)\n\n  \\<comment> \\<open>...and since everybody hears from majority in r1...\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. prop_vote (cfg1 p) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "from HOs[THEN bspec, where x=\"Suc 0\", simplified] send1"], ["proof (chain)\npicking this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p", "have \"\\<forall>p q. \\<mu>1 p = \\<mu>1 q\" \"\\<forall>p. N div 2 < card (dom (\\<mu>1 p))\""], ["proof (prove)\nusing this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q)\n  \\<forall>p. \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n\ngoal (1 subgoal):\n 1. \\<forall>p q. \\<mu>1 p = \\<mu>1 q &&&\n    \\<forall>p. N div 2 < card (dom (\\<mu>1 p))", "apply(auto simp add: get_msgs_benign send1_def r1_def r0_def dom_def restrict_map_def intro!: ext)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>p q x.\n       \\<lbrakk>\\<forall>p.\n                   \\<mu>1 p =\n                   (\\<lambda>x.\n                       if x \\<in> HOs (Suc (3 * ph)) p\n                       then (Some \\<circ>\n                             (\\<lambda>q.\n                                 case prop_vote (cfg1 q) of\n                                 None \\<Rightarrow> Null\n                                 | Some x \\<Rightarrow> PreVote x))\n                             x\n                       else None);\n        \\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p);\n        \\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q;\n        x \\<in> HOs (Suc (3 * ph)) p\\<rbrakk>\n       \\<Longrightarrow> x \\<in> HOs (Suc (3 * ph)) q\n 2. \\<And>p q x.\n       \\<lbrakk>\\<forall>p.\n                   \\<mu>1 p =\n                   (\\<lambda>x.\n                       if x \\<in> HOs (Suc (3 * ph)) p\n                       then (Some \\<circ>\n                             (\\<lambda>q.\n                                 case prop_vote (cfg1 q) of\n                                 None \\<Rightarrow> Null\n                                 | Some x \\<Rightarrow> PreVote x))\n                             x\n                       else None);\n        \\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p);\n        \\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q;\n        x \\<notin> HOs (Suc (3 * ph)) p;\n        x \\<in> HOs (Suc (3 * ph)) q\\<rbrakk>\n       \\<Longrightarrow> False", "apply(blast)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done\n\n  \\<comment> \\<open>and since everybody casts a pre-vote for @{term dec_v}, everybody will vote @{term dec_v}\\<close>"], ["proof (state)\nthis:\n  \\<forall>p q. \\<mu>1 p = \\<mu>1 q\n  \\<forall>p. N div 2 < card (dom (\\<mu>1 p))\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have all_vote: \"\\<forall>p. mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "have r0_step: \"three_step r0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. three_step r0 = 0", "by(auto simp add: r0_def three_step_def)"], ["proof (state)\nthis:\n  three_step r0 = 0\n\ngoal (1 subgoal):\n 1. \\<And>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "from HOs[THEN bspec, where x=\"Suc 0\", simplified]"], ["proof (chain)\npicking this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q)", "obtain Q where Q: \"N div 2 < card Q\" \"Q \\<subseteq> HOs r1 p\""], ["proof (prove)\nusing this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (3 * ph)) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (3 * ph)) p = HOs (3 * ph) q)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>N div 2 < card Q; Q \\<subseteq> HOs r1 p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: r1_def r0_def)"], ["proof (state)\nthis:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r1 p\n\ngoal (1 subgoal):\n 1. \\<And>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "hence \"Q_prevotes_v (\\<mu>1 p) Q dec_v\""], ["proof (prove)\nusing this:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r1 p\n\ngoal (1 subgoal):\n 1. Q_prevotes_v (\\<mu>1 p) Q dec_v", "using dec_v send1[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r1 p\n  \\<forall>p. prop_vote (cfg1 p) = Some dec_v\n  \\<mu>1 p \\<in> get_msgs (send1 r1) cfg1 (HOs r1) (HOs r1) p\n\ngoal (1 subgoal):\n 1. Q_prevotes_v (\\<mu>1 p) Q dec_v", "by(auto simp add: Q_prevotes_v_def get_msgs_benign restrict_map_def send1_def)"], ["proof (state)\nthis:\n  Q_prevotes_v (\\<mu>1 p) Q dec_v\n\ngoal (1 subgoal):\n 1. \\<And>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "thus \"mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\""], ["proof (prove)\nusing this:\n  Q_prevotes_v (\\<mu>1 p) Q dec_v\n\ngoal (1 subgoal):\n 1. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "using \n      three_step1[THEN spec, where x=p] r0_step"], ["proof (prove)\nusing this:\n  Q_prevotes_v (\\<mu>1 p) Q dec_v\n  next1 r1 p (cfg1 p) (\\<mu>1 p) undefined (cfg2 p)\n  three_step r0 = 0\n\ngoal (1 subgoal):\n 1. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)", "by(auto simp add: next1_def r2_def r1_def three_step_phase_Suc)"], ["proof (state)\nthis:\n  pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\n\ngoal:\nNo subgoals!", "qed\n\n  \\<comment> \\<open>And finally, everybody will also decide @{term dec_v}\\<close>"], ["proof (state)\nthis:\n  \\<forall>p. pstate.mru_vote (cfg2 p) = Some (three_phase r2, dec_v)\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "have all_decide: \"\\<forall>p. decide (cfg3 p) = Some dec_v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p. decide (cfg3 p) = Some dec_v", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "from HOs[THEN bspec, where x=\"Suc (Suc 0)\", simplified]"], ["proof (chain)\npicking this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (Suc (3 * ph))) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (Suc (3 * ph))) p = HOs (3 * ph) q)", "obtain Q where Q: \"N div 2 < card Q\" \"Q \\<subseteq> HOs r2 p\""], ["proof (prove)\nusing this:\n  (\\<forall>p. N div 2 < card (HOs (Suc (Suc (3 * ph))) p)) \\<and>\n  (\\<forall>p q. HOs (Suc (Suc (3 * ph))) p = HOs (3 * ph) q)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>N div 2 < card Q; Q \\<subseteq> HOs r2 p\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by(auto simp add: r2_def r1_def r0_def)"], ["proof (state)\nthis:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r2 p\n\ngoal (1 subgoal):\n 1. \\<And>p. decide (cfg3 p) = Some dec_v", "thus \"decide (cfg3 p) = Some dec_v\""], ["proof (prove)\nusing this:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r2 p\n\ngoal (1 subgoal):\n 1. decide (cfg3 p) = Some dec_v", "using three_step2[THEN spec, where x=p] send2[THEN spec, where x=p]"], ["proof (prove)\nusing this:\n  N div 2 < card Q\n  Q \\<subseteq> HOs r2 p\n  next2 r2 p (cfg2 p) (\\<mu>2 p) undefined (cfg3 p)\n  \\<mu>2 p \\<in> get_msgs (send2 r2) cfg2 (HOs r2) (HOs r2) p\n\ngoal (1 subgoal):\n 1. decide (cfg3 p) = Some dec_v", "by(auto simp add: next2_def send2_def Let_def)"], ["proof (state)\nthis:\n  decide (cfg3 p) = Some dec_v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>p. decide (cfg3 p) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>p. decide (cfg3 p) = Some dec_v\n\ngoal (1 subgoal):\n 1. \\<exists>r v. decide (rho r p) = Some v", "by(auto simp add: cfg3_def)"], ["proof (state)\nthis:\n  \\<exists>r v. decide (rho r p) = Some v\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}