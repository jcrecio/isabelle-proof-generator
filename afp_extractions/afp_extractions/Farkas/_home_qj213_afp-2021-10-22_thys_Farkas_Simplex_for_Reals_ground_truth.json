{"file_name": "/home/qj213/afp-2021-10-22/thys/Farkas/Simplex_for_Reals.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Farkas", "problem_names": ["lemma of_rat_val_eval: \"p \\<lbrace>of_rat_val v\\<rbrace> = of_rat (p \\<lbrace>v\\<rbrace>)\"", "lemma of_rat_val_constraint: \"of_rat_val v \\<Turnstile>\\<^sub>c c \\<longleftrightarrow> v \\<Turnstile>\\<^sub>c c\"", "lemma of_rat_val_constraints: \"of_rat_val v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<longleftrightarrow> v \\<Turnstile>\\<^sub>c\\<^sub>s cs\"", "lemma sat_scale_rat_real: assumes \"(v :: real valuation) \\<Turnstile>\\<^sub>c c\"\n  shows \"v \\<Turnstile>\\<^sub>c (r *R c)\"", "lemma lec_of_constraint_real: \n  assumes \"is_le c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint c)) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>c c)\"", "lemma of_rat_lec_add: \"of_rat_lec (c + d) = of_rat_lec c + of_rat_lec d\"", "lemma of_rat_lec_zero: \"of_rat_lec 0 = 0\"", "lemma of_rat_lec_sum: \"of_rat_lec (sum_list c) = sum_list (map of_rat_lec c)\"", "lemma rat_real_conversion: assumes \"finite cs\" \n  shows \"(\\<exists> v :: rat valuation. v \\<Turnstile>\\<^sub>c\\<^sub>s cs) \\<longleftrightarrow> (\\<exists> v :: real valuation. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs)\"", "lemma simplex_index_real:\n  \"simplex_index cs = Unsat I \\<Longrightarrow> set I \\<subseteq> fst ` set cs \\<and> \\<not> (\\<exists> v. (set I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set cs) \\<and> \n     (distinct_indices cs \\<longrightarrow> (\\<forall> J \\<subset> set I. (\\<exists> v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs)))\" \\<comment> \\<open>minimal unsat core over the reals\\<close>\n  \"simplex_index cs = Sat v \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s (snd ` set cs)\" \\<comment> \\<open>satisfying assingment\\<close>", "lemma simplex_real:\n  \"simplex cs = Unsat I \\<Longrightarrow> \\<not> (\\<exists> v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s set cs)\" \\<comment> \\<open>unsat of original constraints over the reals\\<close>\n  \"simplex cs = Unsat I \\<Longrightarrow> set I \\<subseteq> {0..<length cs} \\<and> \\<not> (\\<exists> v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s {cs ! i | i. i \\<in> set I})\n    \\<and> (\\<forall>J\\<subset>set I. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\" \\<comment> \\<open>minimal unsat core over reals\\<close>\n  \"simplex cs = Sat v \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs\"  \\<comment> \\<open>satisfying assignment over the rationals\\<close>", "lemma minimal_unsat_core_real_conv: \"minimal_unsat_core_real I ics = minimal_unsat_core I ics\"", "lemmas incremental_simplex_real = \n  init_simplex\n  assert_simplex_ok\n  assert_simplex_unsat[folded minimal_unsat_core_real_conv]\n  assert_all_simplex_ok\n  assert_all_simplex_unsat[folded minimal_unsat_core_real_conv]\n  check_simplex_ok\n  check_simplex_unsat[folded minimal_unsat_core_real_conv]\n  solution_simplex\n  backtrack_simplex\n  checked_invariant_simplex"], "translations": [["", "lemma of_rat_val_eval: \"p \\<lbrace>of_rat_val v\\<rbrace> = of_rat (p \\<lbrace>v\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<lbrace> of_rat_val v \\<rbrace> = real_of_rat p \\<lbrace> v \\<rbrace>", "unfolding of_rat_val_def linear_poly_sum of_rat_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>vars p. coeff p x *R real_of_rat (v x)) =\n    (\\<Sum>a\\<in>vars p. real_of_rat (coeff p a *R v a))", "by (rule sum.cong, auto simp: of_rat_mult)"], ["", "lemma of_rat_val_constraint: \"of_rat_val v \\<Turnstile>\\<^sub>c c \\<longleftrightarrow> v \\<Turnstile>\\<^sub>c c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_val v \\<Turnstile>\\<^sub>c c = v \\<Turnstile>\\<^sub>c c", "by (cases c, auto simp: of_rat_val_eval of_rat_less of_rat_less_eq)"], ["", "lemma of_rat_val_constraints: \"of_rat_val v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<longleftrightarrow> v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_val v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs =\n    v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "using of_rat_val_constraint"], ["proof (prove)\nusing this:\n  of_rat_val ?v \\<Turnstile>\\<^sub>c ?c = ?v \\<Turnstile>\\<^sub>c ?c\n\ngoal (1 subgoal):\n 1. of_rat_val v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs =\n    v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "by auto"], ["", "lemma sat_scale_rat_real: assumes \"(v :: real valuation) \\<Turnstile>\\<^sub>c c\"\n  shows \"v \\<Turnstile>\\<^sub>c (r *R c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "have \"r < 0 \\<or> r = 0 \\<or> r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < 0 \\<or> r = 0 \\<or> 0 < r", "by auto"], ["proof (state)\nthis:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "then"], ["proof (chain)\npicking this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r", "show ?thesis"], ["proof (prove)\nusing this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "using assms"], ["proof (prove)\nusing this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "by (cases c, simp_all add: right_diff_distrib \n        valuate_minus valuate_scaleRat scaleRat_leq1 scaleRat_leq2 valuate_zero\n        of_rat_less of_rat_mult)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal:\nNo subgoals!", "qed"], ["", "fun of_rat_lec :: \"rat le_constraint \\<Rightarrow> real le_constraint\" where\n  \"of_rat_lec (Le_Constraint r p c) = Le_Constraint r p (of_rat c)\""], ["", "lemma lec_of_constraint_real: \n  assumes \"is_le c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint c)) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>c c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint c) =\n    v \\<Turnstile>\\<^sub>c c", "using assms"], ["proof (prove)\nusing this:\n  is_le c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint c) =\n    v \\<Turnstile>\\<^sub>c c", "by (cases c, auto)"], ["", "lemma of_rat_lec_add: \"of_rat_lec (c + d) = of_rat_lec c + of_rat_lec d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_lec (c + d) = of_rat_lec c + of_rat_lec d", "by (cases c; cases d, auto simp: of_rat_add)"], ["", "lemma of_rat_lec_zero: \"of_rat_lec 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_lec 0 = 0", "unfolding zero_le_constraint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_lec (Le_Constraint Leq_Rel 0 0) = Le_Constraint Leq_Rel 0 0", "by simp"], ["", "lemma of_rat_lec_sum: \"of_rat_lec (sum_list c) = sum_list (map of_rat_lec c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_lec (sum_list c) = sum_list (map of_rat_lec c)", "by (induct c, auto simp: of_rat_lec_zero of_rat_lec_add)"], ["", "text \\<open>This is the main lemma: a finite set of linear constraints is \n  satisfiable over Q if and only if it is satisfiable over R.\\<close>"], ["", "lemma rat_real_conversion: assumes \"finite cs\" \n  shows \"(\\<exists> v :: rat valuation. v \\<Turnstile>\\<^sub>c\\<^sub>s cs) \\<longleftrightarrow> (\\<exists> v :: real valuation. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs) =\n    (\\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n 2. \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "show \"\\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs", "using of_rat_val_constraint"], ["proof (prove)\nusing this:\n  of_rat_val ?v \\<Turnstile>\\<^sub>c ?c = ?v \\<Turnstile>\\<^sub>c ?c\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs", "by auto"], ["proof (state)\nthis:\n  \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n  \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "assume \"\\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\""], ["proof (state)\nthis:\n  \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs", "obtain v where *: \"v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n    \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "show \"\\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "assume \"\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from farkas_coefficients[OF assms] this"], ["proof (chain)\npicking this:\n  (\\<exists>C. farkas_coefficients cs C) =\n  (\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "obtain C where \"farkas_coefficients cs C\""], ["proof (prove)\nusing this:\n  (\\<exists>C. farkas_coefficients cs C) =\n  (\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        farkas_coefficients cs C \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  farkas_coefficients cs C\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from this[unfolded farkas_coefficients_def]"], ["proof (chain)\npicking this:\n  \\<exists>d rel.\n     (\\<forall>(r, c)\\<in>set C.\n         c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n     Le_Constraint rel 0 d \\<and>\n     (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0)", "obtain d rel where\n      isleq: \"(\\<forall>(r,c) \\<in> set C. c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0)\" and\n      leq: \"(\\<Sum> (r,c) \\<leftarrow> C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d\" and\n      choice: \"rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\""], ["proof (prove)\nusing this:\n  \\<exists>d rel.\n     (\\<forall>(r, c)\\<in>set C.\n         c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n     Le_Constraint rel 0 d \\<and>\n     (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>rel d.\n        \\<lbrakk>\\<forall>(r, c)\\<in>set C.\n                    c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n         Le_Constraint rel 0 d;\n         rel = Lt_Rel \\<and> d \\<le> 0 \\<or>\n         rel = Leq_Rel \\<and> d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n  Le_Constraint rel 0 d\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n  Le_Constraint rel 0 d\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "fix r c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "assume c: \"(r,c) \\<in> set C\""], ["proof (state)\nthis:\n  (r, c) \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from c * isleq"], ["proof (chain)\npicking this:\n  (r, c) \\<in> set C\n  v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0", "have \"v \\<Turnstile>\\<^sub>c c\""], ["proof (prove)\nusing this:\n  (r, c) \\<in> set C\n  v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s cs\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c c", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "hence v: \"v \\<Turnstile>\\<^sub>c (r *R c)\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "by (rule sat_scale_rat_real)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from c isleq"], ["proof (chain)\npicking this:\n  (r, c) \\<in> set C\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0", "have \"is_le (r *R c)\""], ["proof (prove)\nusing this:\n  (r, c) \\<in> set C\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_le (r *R c)", "by auto"], ["proof (state)\nthis:\n  is_le (r *R c)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from lec_of_constraint_real[OF this] v"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (r *R c)) =\n  ?v \\<Turnstile>\\<^sub>c (r *R c)\n  v \\<Turnstile>\\<^sub>c (r *R c)", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (r *R c))\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (r *R c)) =\n  ?v \\<Turnstile>\\<^sub>c (r *R c)\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (r *R c))", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (r *R c))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (?r2, ?c2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (?r2 *R ?c2))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "note v = this"], ["proof (state)\nthis:\n  (?r2, ?c2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e of_rat_lec (lec_of_constraint (?r2 *R ?c2))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "have \"Le_Constraint rel 0 (of_rat d) = of_rat_lec (\\<Sum> (r,c) \\<leftarrow> C. lec_of_constraint (r *R c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint rel 0 (real_of_rat d) =\n    of_rat_lec (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c))", "unfolding leq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint rel 0 (real_of_rat d) = of_rat_lec (Le_Constraint rel 0 d)", "by simp"], ["proof (state)\nthis:\n  Le_Constraint rel 0 (real_of_rat d) =\n  of_rat_lec (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  Le_Constraint rel 0 (real_of_rat d) =\n  of_rat_lec (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum> (r,c) \\<leftarrow> C. of_rat_lec (lec_of_constraint (r *R c)))\" (is \"_ = ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat_lec (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n    (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))", "unfolding of_rat_lec_sum map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. of_rat_lec\n                            (case x of\n                             (r, c) \\<Rightarrow>\n                               lec_of_constraint (r *R c))) =\n    (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))", "by (rule arg_cong[of _ _ sum_list], auto)"], ["proof (state)\nthis:\n  of_rat_lec (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n  (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  Le_Constraint rel 0 (real_of_rat d) =\n  (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))", "have leq: \"Le_Constraint rel 0 (of_rat d) = ?sum\""], ["proof (prove)\nusing this:\n  Le_Constraint rel 0 (real_of_rat d) =\n  (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))\n\ngoal (1 subgoal):\n 1. Le_Constraint rel 0 (real_of_rat d) =\n    (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))", "by simp"], ["proof (state)\nthis:\n  Le_Constraint rel 0 (real_of_rat d) =\n  (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 (of_rat d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 (real_of_rat d)", "unfolding leq"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e\n    (\\<Sum>(r, c)\\<leftarrow>C. of_rat_lec (lec_of_constraint (r *R c)))", "by (rule satisfies_sumlist_le_constraints, insert v, auto)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 (real_of_rat d)\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "with choice"], ["proof (chain)\npicking this:\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 (real_of_rat d)", "show False"], ["proof (prove)\nusing this:\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 (real_of_rat d)\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: linear_poly_sum)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The main result of simplex, now using unsatisfiability over the reals.\\<close>"], ["", "fun i_satisfies_cs_real (infixl \"\\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s\" 100) where\n  \"(I,v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s cs \\<longleftrightarrow> v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s Simplex.restrict_to I cs\""], ["", "lemma simplex_index_real:\n  \"simplex_index cs = Unsat I \\<Longrightarrow> set I \\<subseteq> fst ` set cs \\<and> \\<not> (\\<exists> v. (set I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set cs) \\<and> \n     (distinct_indices cs \\<longrightarrow> (\\<forall> J \\<subset> set I. (\\<exists> v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs)))\" \\<comment> \\<open>minimal unsat core over the reals\\<close>\n  \"simplex_index cs = Sat v \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s (snd ` set cs)\" \\<comment> \\<open>satisfying assingment\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (simplex_index cs = Inl I \\<Longrightarrow>\n     set I \\<subseteq> fst ` set cs \\<and>\n     (\\<nexists>v.\n         (set I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s\n         set cs) \\<and>\n     (distinct_indices cs \\<longrightarrow>\n      (\\<forall>J\\<subset>set I.\n          \\<exists>v.\n             (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs))) &&&\n    (simplex_index cs = Inr v \\<Longrightarrow>\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s (snd ` set cs))", "using simplex_index(1)[of cs I] simplex_index(2)[of cs v] \n    rat_real_conversion[of \"Simplex.restrict_to (set I) (set cs)\"]"], ["proof (prove)\nusing this:\n  simplex_index cs = Inl I \\<Longrightarrow>\n  set I \\<subseteq> fst ` set cs \\<and>\n  (\\<nexists>v.\n      (set I, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs) \\<and>\n  (distinct_indices cs \\<longrightarrow>\n   (\\<forall>J\\<subset>set I.\n       \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs))\n  simplex_index cs = Inr v \\<Longrightarrow>\n  \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s (snd ` set cs)\n  finite (snd ` (set cs \\<inter> set I \\<times> UNIV)) \\<Longrightarrow>\n  (\\<exists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      (snd ` (set cs \\<inter> set I \\<times> UNIV))) =\n  (\\<exists>v.\n      v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n      (snd ` (set cs \\<inter> set I \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. (simplex_index cs = Inl I \\<Longrightarrow>\n     set I \\<subseteq> fst ` set cs \\<and>\n     (\\<nexists>v.\n         (set I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s\n         set cs) \\<and>\n     (distinct_indices cs \\<longrightarrow>\n      (\\<forall>J\\<subset>set I.\n          \\<exists>v.\n             (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set cs))) &&&\n    (simplex_index cs = Inr v \\<Longrightarrow>\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s (snd ` set cs))", "by auto"], ["", "lemma simplex_real:\n  \"simplex cs = Unsat I \\<Longrightarrow> \\<not> (\\<exists> v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s set cs)\" \\<comment> \\<open>unsat of original constraints over the reals\\<close>\n  \"simplex cs = Unsat I \\<Longrightarrow> set I \\<subseteq> {0..<length cs} \\<and> \\<not> (\\<exists> v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s {cs ! i | i. i \\<in> set I})\n    \\<and> (\\<forall>J\\<subset>set I. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\" \\<comment> \\<open>minimal unsat core over reals\\<close>\n  \"simplex cs = Sat v \\<Longrightarrow> \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs\"  \\<comment> \\<open>satisfying assignment over the rationals\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (simplex cs = Inl I \\<Longrightarrow>\n     \\<nexists>v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s set cs) &&&\n    (simplex cs = Inl I \\<Longrightarrow>\n     set I \\<subseteq> {0..<length cs} \\<and>\n     (\\<nexists>v.\n         v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n         {cs ! i |i. i \\<in> set I}) \\<and>\n     (\\<forall>J\\<subset>set I.\n         \\<exists>v.\n            v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})) &&&\n    (simplex cs = Inr v \\<Longrightarrow>\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs)", "proof (intro simplex(1)[unfolded rat_real_conversion[OF finite_set]])"], ["proof (state)\ngoal (3 subgoals):\n 1. simplex cs = Inl I \\<Longrightarrow> simplex cs = Inl ?I\n 2. simplex cs = Inl I \\<Longrightarrow>\n    set I \\<subseteq> {0..<length cs} \\<and>\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n        {cs ! i |i. i \\<in> set I}) \\<and>\n    (\\<forall>J\\<subset>set I.\n        \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\n 3. simplex cs = Inr v \\<Longrightarrow>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "assume unsat: \"simplex cs = Inl I\""], ["proof (state)\nthis:\n  simplex cs = Inl I\n\ngoal (3 subgoals):\n 1. simplex cs = Inl I \\<Longrightarrow> simplex cs = Inl ?I\n 2. simplex cs = Inl I \\<Longrightarrow>\n    set I \\<subseteq> {0..<length cs} \\<and>\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n        {cs ! i |i. i \\<in> set I}) \\<and>\n    (\\<forall>J\\<subset>set I.\n        \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\n 3. simplex cs = Inr v \\<Longrightarrow>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "have \"finite {cs ! i |i. i \\<in> set I}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {cs ! i |i. i \\<in> set I}", "by auto"], ["proof (state)\nthis:\n  finite {cs ! i |i. i \\<in> set I}\n\ngoal (3 subgoals):\n 1. simplex cs = Inl I \\<Longrightarrow> simplex cs = Inl ?I\n 2. simplex cs = Inl I \\<Longrightarrow>\n    set I \\<subseteq> {0..<length cs} \\<and>\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n        {cs ! i |i. i \\<in> set I}) \\<and>\n    (\\<forall>J\\<subset>set I.\n        \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\n 3. simplex cs = Inr v \\<Longrightarrow>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "from simplex(2)[OF unsat, unfolded rat_real_conversion[OF this]]"], ["proof (chain)\npicking this:\n  set I \\<subseteq> {0..<length cs} \\<and>\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n      {cs ! i |i. i \\<in> set I}) \\<and>\n  (\\<forall>J\\<subset>set I.\n      \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})", "show \"set I \\<subseteq> {0..<length cs} \\<and> \\<not> (\\<exists> v. v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s {cs ! i | i. i \\<in> set I})\n    \\<and> (\\<forall>J\\<subset>set I. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\""], ["proof (prove)\nusing this:\n  set I \\<subseteq> {0..<length cs} \\<and>\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n      {cs ! i |i. i \\<in> set I}) \\<and>\n  (\\<forall>J\\<subset>set I.\n      \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\n\ngoal (1 subgoal):\n 1. set I \\<subseteq> {0..<length cs} \\<and>\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n        {cs ! i |i. i \\<in> set I}) \\<and>\n    (\\<forall>J\\<subset>set I.\n        \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})", "by auto"], ["proof (state)\nthis:\n  set I \\<subseteq> {0..<length cs} \\<and>\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n      {cs ! i |i. i \\<in> set I}) \\<and>\n  (\\<forall>J\\<subset>set I.\n      \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s {cs ! i |i. i \\<in> J})\n\ngoal (2 subgoals):\n 1. simplex cs = Inl I \\<Longrightarrow> simplex cs = Inl ?I\n 2. simplex cs = Inr v \\<Longrightarrow>\n    \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s set cs", "qed (insert simplex(3), auto)"], ["", "text \\<open>Define notion of minimal unsat core over the reals:\n  the subset has to be unsat over the reals, and every proper subset has\n  to be satisfiable over the rational numbers.\\<close>"], ["", "definition minimal_unsat_core_real :: \"'i set \\<Rightarrow> 'i i_constraint list \\<Rightarrow> bool\" where\n  \"minimal_unsat_core_real I ics  = ((I \\<subseteq> fst ` set ics) \\<and> (\\<not> (\\<exists> v. (I,v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set ics))\n     \\<and> (distinct_indices ics \\<longrightarrow> (\\<forall> J. J \\<subset> I \\<longrightarrow> (\\<exists> v. (J,v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))))\""], ["", "text \\<open>Because of equi-satisfiability the two notions of minimal unsat cores coincide.\\<close>"], ["", "lemma minimal_unsat_core_real_conv: \"minimal_unsat_core_real I ics = minimal_unsat_core I ics\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_real I ics = minimal_unsat_core I ics", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. minimal_unsat_core_real I ics \\<Longrightarrow> minimal_unsat_core I ics\n 2. minimal_unsat_core I ics \\<Longrightarrow> minimal_unsat_core_real I ics", "show \"minimal_unsat_core_real I ics \\<Longrightarrow> minimal_unsat_core I ics\""], ["proof (prove)\ngoal (1 subgoal):\n 1. minimal_unsat_core_real I ics \\<Longrightarrow> minimal_unsat_core I ics", "unfolding minimal_unsat_core_real_def minimal_unsat_core_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v.\n            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n            set ics)) \\<Longrightarrow>\n    I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))", "using of_rat_val_constraint"], ["proof (prove)\nusing this:\n  of_rat_val ?v \\<Turnstile>\\<^sub>c ?c = ?v \\<Turnstile>\\<^sub>c ?c\n\ngoal (1 subgoal):\n 1. I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v.\n            (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s\n            set ics)) \\<Longrightarrow>\n    I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))", "by simp metis"], ["proof (state)\nthis:\n  minimal_unsat_core_real I ics \\<Longrightarrow> minimal_unsat_core I ics\n\ngoal (1 subgoal):\n 1. minimal_unsat_core I ics \\<Longrightarrow> minimal_unsat_core_real I ics", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. minimal_unsat_core I ics \\<Longrightarrow> minimal_unsat_core_real I ics", "assume \"minimal_unsat_core I ics\""], ["proof (state)\nthis:\n  minimal_unsat_core I ics\n\ngoal (1 subgoal):\n 1. minimal_unsat_core I ics \\<Longrightarrow> minimal_unsat_core_real I ics", "thus \"minimal_unsat_core_real I ics\""], ["proof (prove)\nusing this:\n  minimal_unsat_core I ics\n\ngoal (1 subgoal):\n 1. minimal_unsat_core_real I ics", "unfolding minimal_unsat_core_real_def minimal_unsat_core_def"], ["proof (prove)\nusing this:\n  I \\<subseteq> fst ` set ics \\<and>\n  (\\<nexists>v. (I, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n  (distinct_indices ics \\<longrightarrow>\n   (\\<forall>J\\<subset>I.\n       \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))\n\ngoal (1 subgoal):\n 1. I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))", "using rat_real_conversion[of \"Simplex.restrict_to I (set ics)\"]"], ["proof (prove)\nusing this:\n  I \\<subseteq> fst ` set ics \\<and>\n  (\\<nexists>v. (I, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n  (distinct_indices ics \\<longrightarrow>\n   (\\<forall>J\\<subset>I.\n       \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))\n  finite (snd ` (set ics \\<inter> I \\<times> UNIV)) \\<Longrightarrow>\n  (\\<exists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      (snd ` (set ics \\<inter> I \\<times> UNIV))) =\n  (\\<exists>v.\n      v \\<Turnstile>\\<^sub>r\\<^sub>c\\<^sub>s\n      (snd ` (set ics \\<inter> I \\<times> UNIV)))\n\ngoal (1 subgoal):\n 1. I \\<subseteq> fst ` set ics \\<and>\n    (\\<nexists>v.\n        (I, v) \\<Turnstile>\\<^sub>r\\<^sub>i\\<^sub>c\\<^sub>s set ics) \\<and>\n    (distinct_indices ics \\<longrightarrow>\n     (\\<forall>J\\<subset>I.\n         \\<exists>v. (J, v) \\<Turnstile>\\<^sub>i\\<^sub>c\\<^sub>s set ics))", "by auto"], ["proof (state)\nthis:\n  minimal_unsat_core_real I ics\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Easy consequence: The incremental simplex algorithm is also sound wrt. \n  minimal-unsat-cores over the reals.\\<close>"], ["", "lemmas incremental_simplex_real = \n  init_simplex\n  assert_simplex_ok\n  assert_simplex_unsat[folded minimal_unsat_core_real_conv]\n  assert_all_simplex_ok\n  assert_all_simplex_unsat[folded minimal_unsat_core_real_conv]\n  check_simplex_ok\n  check_simplex_unsat[folded minimal_unsat_core_real_conv]\n  solution_simplex\n  backtrack_simplex\n  checked_invariant_simplex"], ["", "end"]]}