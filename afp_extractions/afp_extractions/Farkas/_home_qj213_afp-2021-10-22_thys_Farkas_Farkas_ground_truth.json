{"file_name": "/home/qj213/afp-2021-10-22/thys/Farkas/Farkas.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Farkas", "problem_names": ["lemma Leq_Rel_0: \"Leq_Rel = 0\"", "lemma satisfies_zero_le_constraint: \"v \\<Turnstile>\\<^sub>l\\<^sub>e 0\"", "lemma satisfies_sum_le_constraints:\n  assumes \"v \\<Turnstile>\\<^sub>l\\<^sub>e c\" \"v \\<Turnstile>\\<^sub>l\\<^sub>e d\"\n  shows \"v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)\"", "lemma satisfies_sumlist_le_constraints:\n  assumes \"\\<And> c. c \\<in> set (cs :: 'a :: lrv le_constraint list) \\<Longrightarrow> v \\<Turnstile>\\<^sub>l\\<^sub>e c\"\n  shows \"v \\<Turnstile>\\<^sub>l\\<^sub>e sum_list cs\"", "lemma sum_list_lec:\n  \"sum_list ls = Le_Constraint \n    (sum_list (map lec_rel ls)) \n    (sum_list (map lec_poly ls)) \n    (sum_list (map lec_const ls))\"", "lemma sum_list_Leq_Rel: \"((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) \\<longleftrightarrow> (\\<forall> x \\<in> set C. lec_rel (f x) = Leq_Rel)\"", "lemma sat_scale_rat_ns: assumes \"v \\<Turnstile>\\<^sub>n\\<^sub>s ns\"\n  shows \"v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)\"", "lemma scaleRat_scaleRat_ns_constraint: assumes \"a \\<noteq> 0 \\<Longrightarrow> b \\<noteq> 0\" \n  shows \"a *R (b *R (c :: 'a :: lrv ns_constraint)) = (a * b) *R c\"", "lemma lec_of_nsc: \n  assumes \"is_leq_ns c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc c) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>n\\<^sub>s c)\"", "lemma nsc_of_atom: \"v \\<Turnstile>\\<^sub>n\\<^sub>s nsc_of_atom a \\<longleftrightarrow> v \\<Turnstile>\\<^sub>a a\"", "lemma farkas_check: \n  assumes check: \"check s' = s\" and U: \"\\<U> s\" \"\\<not> \\<U> s'\"\n    and inv: \"\\<nabla> s'\" \"\\<triangle> (\\<T> s')\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\" \"\\<diamond> s'\" \n    and index: \"index_valid as s'\" \n  shows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C\"", "lemma farkas_assert_bound: assumes inv: \"\\<not> \\<U> s\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\" \"\\<triangle> (\\<T> s)\" \"\\<nabla> s\" \"\\<diamond> s\"\n  and index: \"index_valid as s\" \n  and U: \"\\<U> (assert_bound ia s)\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` (insert ia as)) (\\<T> s) C\"", "lemma farkas_coefficients_atoms_tableau_mono: assumes \"as \\<subseteq> bs\" \n  shows \"farkas_coefficients_atoms_tableau as t C \\<Longrightarrow> farkas_coefficients_atoms_tableau bs t C\"", "lemma farkas_assert_bound_loop: assumes \"\\<U> (assert_bound_loop as (init t))\" \n  and norm: \"\\<triangle> t\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` set as) t C\"", "lemma farkas_assert_all_state: assumes U: \"\\<U> (assert_all_state t as)\" \n  and norm: \"\\<triangle> t\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` set as) t C\"", "lemma farkas_coefficients_atoms_tableau_unsat: \n  assumes \"farkas_coefficients_atoms_tableau as t C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\"", "lemma farkas_coefficients_atoms_tableau: assumes norm: \"\\<triangle> t\"\n  and fin: \"finite as\"\nshows \"(\\<exists> C. farkas_coefficients_atoms_tableau as t C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as)\"", "lemma farkas_coefficients_ns_unsat: \n  assumes \"farkas_coefficients_ns ns C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\"", "lemma subst_poly_0[simp]: \"subst_poly \\<sigma> 0 = 0\"", "lemma valuate_subst_poly: \"(subst_poly \\<sigma> p) \\<lbrace> v \\<rbrace> = (p \\<lbrace> (\\<lambda> x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>)) \\<rbrace>)\"", "lemma subst_poly_add: \"subst_poly \\<sigma> (p + q) = subst_poly \\<sigma> p + subst_poly \\<sigma> q\"", "lemma subst_poly_lec_0[simp]: \"subst_poly_lec \\<sigma> 0 = 0\"", "lemma subst_poly_lec_add: \"subst_poly_lec \\<sigma> (c1 + c2) = subst_poly_lec \\<sigma> c1 + subst_poly_lec \\<sigma> c2\"", "lemma subst_poly_lec_sum_list: \"subst_poly_lec \\<sigma> (sum_list ps) = sum_list (map (subst_poly_lec \\<sigma>) ps)\"", "lemma subst_poly_lp_monom[simp]: \"subst_poly \\<sigma> (lp_monom r x) = r *R \\<sigma> x\"", "lemma subst_poly_scaleRat: \"subst_poly \\<sigma> (r *R p) = r *R (subst_poly \\<sigma> p)\"", "lemma Tableau_is_monom_preprocess':\n  assumes \"(x, p) \\<in> set (Tableau (preprocess' cs start))\"\n  shows \"\\<not> is_monom p\"", "lemma preprocess'_atoms_to_constraints': assumes \"preprocess' cs start = S\" \n  shows \"set (Atoms S) \\<subseteq> {(i,qdelta_constraint_to_atom c v) | i c v. (i,c) \\<in> set cs \\<and> \n     (\\<not> is_monom (poly c) \\<longrightarrow> Poly_Mapping S (poly c) = Some v)}\"", "lemma monom_of_atom_coeff:\n  assumes \"is_monom (poly ns)\" \"a = qdelta_constraint_to_atom ns v\"\n  shows \"(monom_coeff (poly ns)) *R nsc_of_atom a = ns\"", "lemma preprocess'_atoms_to_constraints: assumes S: \"preprocess' cs start = S\" \n  and start: \"start = start_fresh_variable cs\" \n  and ns: \"ns = (case a of Leq v c \\<Rightarrow> LEQ_ns q c | Geq v c \\<Rightarrow> GEQ_ns q c)\" \n  and \"a \\<in> snd ` set (Atoms S)\" \nshows \"(atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow> (\\<exists> r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs))\n    \\<and>  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow> ns \\<in> snd ` set cs)\"", "lemma farkas_coefficients_preprocess': \n  assumes pp: \"preprocess' cs (start_fresh_variable cs) = S\" and\n    ft: \"farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\"\n  shows \"\\<exists> C. farkas_coefficients_ns (snd ` set cs) C\"", "lemma preprocess'_unsat_indexD: \"i \\<in> set (UnsatIndices (preprocess' ns j)) \\<Longrightarrow> \n  \\<exists> c. poly c = 0 \\<and> \\<not> zero_satisfies c \\<and> (i,c) \\<in> set ns\"", "lemma preprocess'_unsat_index_farkas_coefficients_ns: \n  assumes \"i \\<in> set (UnsatIndices (preprocess' ns j))\" \n  shows \"\\<exists> C. farkas_coefficients_ns (snd ` set ns) C\"", "lemma farkas_coefficients_ns: assumes \"finite (ns :: QDelta ns_constraint set)\" \n  shows \"(\\<exists> C. farkas_coefficients_ns ns C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns)\"", "lemma lec_of_constraint: \n  assumes \"is_le c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e (lec_of_constraint c)) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>c c)\"", "lemma sat_scale_rat: assumes \"(v :: rat valuation) \\<Turnstile>\\<^sub>c c\"\n  shows \"v \\<Turnstile>\\<^sub>c (r *R c)\"", "lemma farkas_coefficients_unsat: \n  assumes \"farkas_coefficients cs C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\"", "lemma compatible_cs_0_0: \"compatible_cs 0 0\"", "lemma compatible_cs_plus: \"compatible_cs c1 d1 \\<Longrightarrow> compatible_cs c2 d2 \\<Longrightarrow> compatible_cs (c1 + c2) (d1 + d2)\"", "lemma unsat_farkas_coefficients: assumes \"\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\" \n  and fin: \"finite cs\" \nshows \"\\<exists> C. farkas_coefficients cs C\"", "lemma farkas_coefficients: assumes \"finite cs\" \n  shows \"(\\<exists> C. farkas_coefficients cs C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)\"", "lemma Farkas'_Lemma_Delta_Rationals: fixes cs :: \"QDelta le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\" \n    (is \"?lhs = ?rhs\")", "theorem Motzkin's_transposition_theorem: fixes cs :: \"rat le_constraint set\"\n  assumes fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const rel. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) \n               = Le_Constraint rel 0 const\n         \\<and> (rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0))\" \n    (is \"?lhs = ?rhs\")", "lemma Farkas'_Lemma: fixes cs :: \"rat le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\" \n    (is \"_ = ?rhs\")", "lemma sum_list_map_filter_sum: fixes f :: \"'a \\<Rightarrow> 'b :: comm_monoid_add\" \n  shows \"sum_list (map f (filter g xs)) + sum_list (map f (filter (Not o g) xs)) = sum_list (map f xs)\"", "lemma Farkas'_Lemma_set_sum: fixes cs :: \"rat le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> c \\<in> cs. C c \\<ge> 0)\n         \\<and> (\\<Sum> c \\<in> cs. Leqc ((C c) *R lec_poly c) ((C c) *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\"", "lemma Farkas'_Lemma_indexed: fixes c :: \"nat \\<Rightarrow> rat le_constraint\"\n  assumes only_non_strict: \"lec_rel ` c ` Is \\<subseteq> {Leq_Rel}\"  \n  and fin: \"finite Is\" \n  shows \"(\\<nexists> v. \\<forall> i \\<in> Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> i \\<in> Is. C i \\<ge> 0)\n         \\<and> (\\<Sum> i \\<in> Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const\n         \\<and> const < 0)\""], "translations": [["", "lemma Leq_Rel_0: \"Leq_Rel = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Leq_Rel = 0", "unfolding zero_le_rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Leq_Rel = Leq_Rel", "by simp"], ["", "datatype 'a le_constraint = Le_Constraint (lec_rel: le_rel) (lec_poly: linear_poly) (lec_const: 'a)"], ["", "abbreviation (input) \"Leqc \\<equiv> Le_Constraint Leq_Rel\""], ["", "instantiation le_constraint :: (lrv) comm_monoid_add begin"], ["", "fun plus_le_constraint :: \"'a le_constraint \\<Rightarrow> 'a le_constraint \\<Rightarrow> 'a le_constraint\" where\n  \"plus_le_constraint (Le_Constraint r1 p1 c1) (Le_Constraint r2 p2 c2) = \n    (Le_Constraint (r1 + r2) (p1 + p2) (c1 + c2))\""], ["", "definition zero_le_constraint :: \"'a le_constraint\" where\n  \"zero_le_constraint = Leqc 0 0\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a le_constraint, comm_monoid_add_class)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "fix a b c :: \"'a le_constraint\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a\n 3. \\<And>a. 0 + a = a", "show \"0 + a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 + a = a", "by (cases a, auto simp: zero_le_constraint_def Leq_Rel_0)"], ["proof (state)\nthis:\n  0 + a = a\n\ngoal (2 subgoals):\n 1. \\<And>a b c. a + b + c = a + (b + c)\n 2. \\<And>a b. a + b = b + a", "show \"a + b = b + a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b = b + a", "by (cases a; cases b, auto simp: ac_simps)"], ["proof (state)\nthis:\n  a + b = b + a\n\ngoal (1 subgoal):\n 1. \\<And>a b c. a + b + c = a + (b + c)", "show \"a + b + c = a + (b + c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a + b + c = a + (b + c)", "by (cases a; cases b; cases c, auto simp: ac_simps)"], ["proof (state)\nthis:\n  a + b + c = a + (b + c)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "primrec satisfiable_le_constraint :: \"'a::lrv valuation \\<Rightarrow> 'a le_constraint \\<Rightarrow> bool\" (infixl \"\\<Turnstile>\\<^sub>l\\<^sub>e\" 100) where\n  \"(v \\<Turnstile>\\<^sub>l\\<^sub>e (Le_Constraint rel l r)) \\<longleftrightarrow> (rel_of rel (l\\<lbrace>v\\<rbrace>) r)\""], ["", "lemma satisfies_zero_le_constraint: \"v \\<Turnstile>\\<^sub>l\\<^sub>e 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e 0", "by (simp add: valuate_zero zero_le_constraint_def)"], ["", "lemma satisfies_sum_le_constraints:\n  assumes \"v \\<Turnstile>\\<^sub>l\\<^sub>e c\" \"v \\<Turnstile>\\<^sub>l\\<^sub>e d\"\n  shows \"v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "obtain lc rc ld rd rel1 rel2 where cd: \"c = Le_Constraint rel1 lc rc\" \"d = Le_Constraint rel2 ld rd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rel1 lc rc rel2 ld rd.\n        \\<lbrakk>c = Le_Constraint rel1 lc rc;\n         d = Le_Constraint rel2 ld rd\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases c; cases d, auto)"], ["proof (state)\nthis:\n  c = Le_Constraint rel1 lc rc\n  d = Le_Constraint rel2 ld rd\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "have 1: \"rel_of rel1 (lc\\<lbrace>v\\<rbrace>) rc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_of rel1 lc \\<lbrace> v \\<rbrace> rc", "using assms cd"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e c\n  v \\<Turnstile>\\<^sub>l\\<^sub>e d\n  c = Le_Constraint rel1 lc rc\n  d = Le_Constraint rel2 ld rd\n\ngoal (1 subgoal):\n 1. rel_of rel1 lc \\<lbrace> v \\<rbrace> rc", "by auto"], ["proof (state)\nthis:\n  rel_of rel1 lc \\<lbrace> v \\<rbrace> rc\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "have 2: \"rel_of rel2 (ld\\<lbrace>v\\<rbrace>) rd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel_of rel2 ld \\<lbrace> v \\<rbrace> rd", "using assms cd"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e c\n  v \\<Turnstile>\\<^sub>l\\<^sub>e d\n  c = Le_Constraint rel1 lc rc\n  d = Le_Constraint rel2 ld rd\n\ngoal (1 subgoal):\n 1. rel_of rel2 ld \\<lbrace> v \\<rbrace> rd", "by auto"], ["proof (state)\nthis:\n  rel_of rel2 ld \\<lbrace> v \\<rbrace> rd\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "from 1"], ["proof (chain)\npicking this:\n  rel_of rel1 lc \\<lbrace> v \\<rbrace> rc", "have le1: \"lc\\<lbrace>v\\<rbrace> \\<le> rc\""], ["proof (prove)\nusing this:\n  rel_of rel1 lc \\<lbrace> v \\<rbrace> rc\n\ngoal (1 subgoal):\n 1. lc \\<lbrace> v \\<rbrace> \\<le> rc", "by (cases rel1, auto)"], ["proof (state)\nthis:\n  lc \\<lbrace> v \\<rbrace> \\<le> rc\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "from 2"], ["proof (chain)\npicking this:\n  rel_of rel2 ld \\<lbrace> v \\<rbrace> rd", "have le2: \"ld\\<lbrace>v\\<rbrace> \\<le> rd\""], ["proof (prove)\nusing this:\n  rel_of rel2 ld \\<lbrace> v \\<rbrace> rd\n\ngoal (1 subgoal):\n 1. ld \\<lbrace> v \\<rbrace> \\<le> rd", "by (cases rel2, auto)"], ["proof (state)\nthis:\n  ld \\<lbrace> v \\<rbrace> \\<le> rd\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "from 1 2 le1 le2"], ["proof (chain)\npicking this:\n  rel_of rel1 lc \\<lbrace> v \\<rbrace> rc\n  rel_of rel2 ld \\<lbrace> v \\<rbrace> rd\n  lc \\<lbrace> v \\<rbrace> \\<le> rc\n  ld \\<lbrace> v \\<rbrace> \\<le> rd", "have \"rel_of (rel1 + rel2) ((lc\\<lbrace>v\\<rbrace>) + (ld\\<lbrace>v\\<rbrace>)) (rc + rd)\""], ["proof (prove)\nusing this:\n  rel_of rel1 lc \\<lbrace> v \\<rbrace> rc\n  rel_of rel2 ld \\<lbrace> v \\<rbrace> rd\n  lc \\<lbrace> v \\<rbrace> \\<le> rc\n  ld \\<lbrace> v \\<rbrace> \\<le> rd\n\ngoal (1 subgoal):\n 1. rel_of (rel1 + rel2)\n     (lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>) (rc + rd)", "apply (cases rel1; cases rel2; simp add: add_mono)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>ld \\<lbrace> v \\<rbrace> < rd; rel1 = Leq_Rel; rel2 = Lt_Rel;\n     lc \\<lbrace> v \\<rbrace> \\<le> rc;\n     ld \\<lbrace> v \\<rbrace> \\<le> rd\\<rbrakk>\n    \\<Longrightarrow> lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>\n                      < rc + rd\n 2. \\<lbrakk>lc \\<lbrace> v \\<rbrace> < rc; rel1 = Lt_Rel; rel2 = Leq_Rel;\n     lc \\<lbrace> v \\<rbrace> \\<le> rc;\n     ld \\<lbrace> v \\<rbrace> \\<le> rd\\<rbrakk>\n    \\<Longrightarrow> lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>\n                      < rc + rd\n 3. \\<lbrakk>lc \\<lbrace> v \\<rbrace> < rc; ld \\<lbrace> v \\<rbrace> < rd;\n     rel1 = Lt_Rel; rel2 = Lt_Rel; lc \\<lbrace> v \\<rbrace> \\<le> rc;\n     ld \\<lbrace> v \\<rbrace> \\<le> rd\\<rbrakk>\n    \\<Longrightarrow> lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>\n                      < rc + rd", "by (metis add.commute le_less_trans order.strict_iff_order plus_less)+"], ["proof (state)\nthis:\n  rel_of (rel1 + rel2) (lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>)\n   (rc + rd)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  rel_of (rel1 + rel2) (lc \\<lbrace> v \\<rbrace> + ld \\<lbrace> v \\<rbrace>)\n   (rc + rd)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)", "by (auto simp: cd valuate_add)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e (c + d)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma satisfies_sumlist_le_constraints:\n  assumes \"\\<And> c. c \\<in> set (cs :: 'a :: lrv le_constraint list) \\<Longrightarrow> v \\<Turnstile>\\<^sub>l\\<^sub>e c\"\n  shows \"v \\<Turnstile>\\<^sub>l\\<^sub>e sum_list cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e sum_list cs", "using assms"], ["proof (prove)\nusing this:\n  ?c \\<in> set cs \\<Longrightarrow> v \\<Turnstile>\\<^sub>l\\<^sub>e ?c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e sum_list cs", "by (induct cs, auto intro: satisfies_zero_le_constraint satisfies_sum_le_constraints)"], ["", "lemma sum_list_lec:\n  \"sum_list ls = Le_Constraint \n    (sum_list (map lec_rel ls)) \n    (sum_list (map lec_poly ls)) \n    (sum_list (map lec_const ls))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list ls =\n    Le_Constraint (sum_list (map lec_rel ls)) (sum_list (map lec_poly ls))\n     (sum_list (map lec_const ls))", "proof (induct ls)"], ["proof (state)\ngoal (2 subgoals):\n 1. sum_list [] =\n    Le_Constraint (sum_list (map lec_rel [])) (sum_list (map lec_poly []))\n     (sum_list (map lec_const []))\n 2. \\<And>a ls.\n       sum_list ls =\n       Le_Constraint (sum_list (map lec_rel ls))\n        (sum_list (map lec_poly ls))\n        (sum_list (map lec_const ls)) \\<Longrightarrow>\n       sum_list (a # ls) =\n       Le_Constraint (sum_list (map lec_rel (a # ls)))\n        (sum_list (map lec_poly (a # ls)))\n        (sum_list (map lec_const (a # ls)))", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. sum_list [] =\n    Le_Constraint (sum_list (map lec_rel [])) (sum_list (map lec_poly []))\n     (sum_list (map lec_const []))\n 2. \\<And>a ls.\n       sum_list ls =\n       Le_Constraint (sum_list (map lec_rel ls))\n        (sum_list (map lec_poly ls))\n        (sum_list (map lec_const ls)) \\<Longrightarrow>\n       sum_list (a # ls) =\n       Le_Constraint (sum_list (map lec_rel (a # ls)))\n        (sum_list (map lec_poly (a # ls)))\n        (sum_list (map lec_const (a # ls)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list [] =\n    Le_Constraint (sum_list (map lec_rel [])) (sum_list (map lec_poly []))\n     (sum_list (map lec_const []))", "by (auto simp: zero_le_constraint_def Leq_Rel_0)"], ["proof (state)\nthis:\n  sum_list [] =\n  Le_Constraint (sum_list (map lec_rel [])) (sum_list (map lec_poly []))\n   (sum_list (map lec_const []))\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       sum_list ls =\n       Le_Constraint (sum_list (map lec_rel ls))\n        (sum_list (map lec_poly ls))\n        (sum_list (map lec_const ls)) \\<Longrightarrow>\n       sum_list (a # ls) =\n       Le_Constraint (sum_list (map lec_rel (a # ls)))\n        (sum_list (map lec_poly (a # ls)))\n        (sum_list (map lec_const (a # ls)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       sum_list ls =\n       Le_Constraint (sum_list (map lec_rel ls))\n        (sum_list (map lec_poly ls))\n        (sum_list (map lec_const ls)) \\<Longrightarrow>\n       sum_list (a # ls) =\n       Le_Constraint (sum_list (map lec_rel (a # ls)))\n        (sum_list (map lec_poly (a # ls)))\n        (sum_list (map lec_const (a # ls)))", "case (Cons l ls)"], ["proof (state)\nthis:\n  sum_list ls =\n  Le_Constraint (sum_list (map lec_rel ls)) (sum_list (map lec_poly ls))\n   (sum_list (map lec_const ls))\n\ngoal (1 subgoal):\n 1. \\<And>a ls.\n       sum_list ls =\n       Le_Constraint (sum_list (map lec_rel ls))\n        (sum_list (map lec_poly ls))\n        (sum_list (map lec_const ls)) \\<Longrightarrow>\n       sum_list (a # ls) =\n       Le_Constraint (sum_list (map lec_rel (a # ls)))\n        (sum_list (map lec_poly (a # ls)))\n        (sum_list (map lec_const (a # ls)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (l # ls) =\n    Le_Constraint (sum_list (map lec_rel (l # ls)))\n     (sum_list (map lec_poly (l # ls))) (sum_list (map lec_const (l # ls)))", "by (cases l, auto simp: Cons)"], ["proof (state)\nthis:\n  sum_list (l # ls) =\n  Le_Constraint (sum_list (map lec_rel (l # ls)))\n   (sum_list (map lec_poly (l # ls))) (sum_list (map lec_const (l # ls)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_list_Leq_Rel: \"((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) \\<longleftrightarrow> (\\<forall> x \\<in> set C. lec_rel (f x) = Leq_Rel)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set C. lec_rel (f x) = Leq_Rel)", "proof (induct C)"], ["proof (state)\ngoal (2 subgoals):\n 1. ((\\<Sum>x\\<leftarrow>[]. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set []. lec_rel (f x) = Leq_Rel)\n 2. \\<And>a C.\n       ((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) =\n       (\\<forall>x\\<in>set C. lec_rel (f x) = Leq_Rel) \\<Longrightarrow>\n       ((\\<Sum>x\\<leftarrow>a # C. lec_rel (f x)) = Leq_Rel) =\n       (\\<forall>x\\<in>set (a # C). lec_rel (f x) = Leq_Rel)", "case (Cons c C)"], ["proof (state)\nthis:\n  ((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) =\n  (\\<forall>x\\<in>set C. lec_rel (f x) = Leq_Rel)\n\ngoal (2 subgoals):\n 1. ((\\<Sum>x\\<leftarrow>[]. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set []. lec_rel (f x) = Leq_Rel)\n 2. \\<And>a C.\n       ((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) =\n       (\\<forall>x\\<in>set C. lec_rel (f x) = Leq_Rel) \\<Longrightarrow>\n       ((\\<Sum>x\\<leftarrow>a # C. lec_rel (f x)) = Leq_Rel) =\n       (\\<forall>x\\<in>set (a # C). lec_rel (f x) = Leq_Rel)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "proof (cases \"lec_rel (f c)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. lec_rel (f c) = Leq_Rel \\<Longrightarrow>\n    ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)\n 2. lec_rel (f c) = Lt_Rel \\<Longrightarrow>\n    ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "case Leq_Rel"], ["proof (state)\nthis:\n  lec_rel (f c) = Leq_Rel\n\ngoal (2 subgoals):\n 1. lec_rel (f c) = Leq_Rel \\<Longrightarrow>\n    ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)\n 2. lec_rel (f c) = Lt_Rel \\<Longrightarrow>\n    ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "using Cons"], ["proof (prove)\nusing this:\n  ((\\<Sum>x\\<leftarrow>C. lec_rel (f x)) = Leq_Rel) =\n  (\\<forall>x\\<in>set C. lec_rel (f x) = Leq_Rel)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "by (simp add: Leq_Rel Leq_Rel_0)"], ["proof (state)\nthis:\n  ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n  (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)\n\ngoal (1 subgoal):\n 1. lec_rel (f c) = Lt_Rel \\<Longrightarrow>\n    ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)", "qed simp"], ["proof (state)\nthis:\n  ((\\<Sum>x\\<leftarrow>c # C. lec_rel (f x)) = Leq_Rel) =\n  (\\<forall>x\\<in>set (c # C). lec_rel (f x) = Leq_Rel)\n\ngoal (1 subgoal):\n 1. ((\\<Sum>x\\<leftarrow>[]. lec_rel (f x)) = Leq_Rel) =\n    (\\<forall>x\\<in>set []. lec_rel (f x) = Leq_Rel)", "qed (simp add: Leq_Rel_0)"], ["", "subsection \\<open>Farkas' Lemma on Layer 4\\<close>"], ["", "text \\<open>On layer 4 the algorithm works on a state containing a tableau, atoms (or bounds), \n  an assignment and a satisfiability flag. Only non-strict inequalities appear at this level.\n  In order to even state a variant of Farkas' Lemma on layer 4, we \n  need conversions from atoms to non-strict constraints and then further\n  to linear inequalities of type @{type le_constraint}. \n  The latter conversion is a partial operation, since non-strict constraints\n  of type @{type ns_constraint} permit greater-or-equal constraints, whereas @{type le_constraint}\n  allows only less-or-equal.\\<close>"], ["", "text \\<open>The advantage of first going via @{type ns_constraint} is that this type permits a multiplication\n  with arbitrary rational numbers (the direction of the inequality must be flipped when\n  multiplying by a negative number, which is not possible with @{type le_constraint}).\\<close>"], ["", "instantiation ns_constraint :: (scaleRat) scaleRat\nbegin"], ["", "fun scaleRat_ns_constraint :: \"rat \\<Rightarrow> 'a ns_constraint \\<Rightarrow> 'a ns_constraint\" where\n  \"scaleRat_ns_constraint r (LEQ_ns p c) = \n    (if (r < 0) then GEQ_ns (r *R p) (r *R c) else LEQ_ns (r *R p) (r *R c))\"\n| \"scaleRat_ns_constraint r (GEQ_ns p c) = \n    (if (r > 0) then GEQ_ns (r *R p) (r *R c) else LEQ_ns (r *R p) (r *R c))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS('a ns_constraint, scaleRat_class)", ".."], ["", "end"], ["", "lemma sat_scale_rat_ns: assumes \"v \\<Turnstile>\\<^sub>n\\<^sub>s ns\"\n  shows \"v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)", "have \"f < 0 | f = 0 | f > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f < 0 \\<or> f = 0 \\<or> 0 < f", "by auto"], ["proof (state)\nthis:\n  f < 0 \\<or> f = 0 \\<or> 0 < f\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)", "then"], ["proof (chain)\npicking this:\n  f < 0 \\<or> f = 0 \\<or> 0 < f", "show ?thesis"], ["proof (prove)\nusing this:\n  f < 0 \\<or> f = 0 \\<or> 0 < f\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)", "using assms"], ["proof (prove)\nusing this:\n  f < 0 \\<or> f = 0 \\<or> 0 < f\n  v \\<Turnstile>\\<^sub>n\\<^sub>s ns\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)", "by (cases ns, auto simp: valuate_scaleRat scaleRat_leq1 scaleRat_leq2)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (f *R ns)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma scaleRat_scaleRat_ns_constraint: assumes \"a \\<noteq> 0 \\<Longrightarrow> b \\<noteq> 0\" \n  shows \"a *R (b *R (c :: 'a :: lrv ns_constraint)) = (a * b) *R c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "have \"b > 0 \\<or> b < 0 \\<or> b = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b \\<or> b < 0 \\<or> b = 0", "by linarith"], ["proof (state)\nthis:\n  0 < b \\<or> b < 0 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "moreover"], ["proof (state)\nthis:\n  0 < b \\<or> b < 0 \\<or> b = 0\n\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "have \"a > 0 \\<or> a < 0 \\<or> a = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < a \\<or> a < 0 \\<or> a = 0", "by linarith"], ["proof (state)\nthis:\n  0 < a \\<or> a < 0 \\<or> a = 0\n\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "ultimately"], ["proof (chain)\npicking this:\n  0 < b \\<or> b < 0 \\<or> b = 0\n  0 < a \\<or> a < 0 \\<or> a = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  0 < b \\<or> b < 0 \\<or> b = 0\n  0 < a \\<or> a < 0 \\<or> a = 0\n\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "using assms"], ["proof (prove)\nusing this:\n  0 < b \\<or> b < 0 \\<or> b = 0\n  0 < a \\<or> a < 0 \\<or> a = 0\n  a \\<noteq> 0 \\<Longrightarrow> b \\<noteq> 0\n\ngoal (1 subgoal):\n 1. a *R b *R c = (a * b) *R c", "by (elim disjE; cases c, auto simp add: not_le not_less\n        mult_neg_pos mult_neg_neg mult_nonpos_nonneg mult_nonpos_nonpos mult_nonneg_nonpos mult_pos_neg)"], ["proof (state)\nthis:\n  a *R b *R c = (a * b) *R c\n\ngoal:\nNo subgoals!", "qed"], ["", "fun lec_of_nsc where\n  \"lec_of_nsc (LEQ_ns p c) = (Leqc p c)\""], ["", "fun is_leq_ns where\n  \"is_leq_ns (LEQ_ns p c) = True\"\n| \"is_leq_ns (GEQ_ns p c) = False\""], ["", "lemma lec_of_nsc: \n  assumes \"is_leq_ns c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc c) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>n\\<^sub>s c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc c =\n    v \\<Turnstile>\\<^sub>n\\<^sub>s c", "using assms"], ["proof (prove)\nusing this:\n  is_leq_ns c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc c =\n    v \\<Turnstile>\\<^sub>n\\<^sub>s c", "by (cases c, auto)"], ["", "fun nsc_of_atom where\n  \"nsc_of_atom (Leq var b) = LEQ_ns (lp_monom 1 var) b\"\n| \"nsc_of_atom (Geq var b) = GEQ_ns (lp_monom 1 var) b\""], ["", "lemma nsc_of_atom: \"v \\<Turnstile>\\<^sub>n\\<^sub>s nsc_of_atom a \\<longleftrightarrow> v \\<Turnstile>\\<^sub>a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s nsc_of_atom a = v \\<Turnstile>\\<^sub>a a", "by (cases a, auto)"], ["", "text \\<open>We say that $C$ is a list of Farkas coefficients \\emph{for a given tableau $t$ and atom set $as$}, if\n  it is a list of pairs $(r,a)$ such that $a \\in as$, $r$ is non-zero, $r \\cdot a$ is a\n  `less-than-or-equal'-constraint, and the linear combination\n  of inequalities must result in an inequality of the form $p \\leq c$, where $c < 0$ and $t \\models\n  p = 0$.\\<close>"], ["", "definition farkas_coefficients_atoms_tableau where \n  \"farkas_coefficients_atoms_tableau (as :: 'a :: lrv atom set) t C = (\\<exists> p c. \n    (\\<forall>(r,a) \\<in> set C. a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n    (\\<Sum>(r,a) \\<leftarrow> C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c \\<and>\n    c < 0 \\<and>\n    (\\<forall> v :: 'a valuation. v \\<Turnstile>\\<^sub>t t \\<longrightarrow>(p\\<lbrace>v\\<rbrace> = 0)))\""], ["", "text \\<open>We first prove that if the check-function detects a conflict, then \n  Farkas coefficients do exist for the tableau and atom set for which the\n  conflict is detected.\\<close>"], ["", "definition bound_atoms :: \"('i, 'a) state \\<Rightarrow> 'a atom set\" (\"\\<B>\\<^sub>A\") where\n  \"bound_atoms s = (\\<lambda>(v,x). Geq v x) ` (set_of_map (\\<B>\\<^sub>l s)) \\<union> \n                   (\\<lambda>(v,x). Leq v x) ` (set_of_map (\\<B>\\<^sub>u s))\""], ["", "context PivotUpdateMinVars\nbegin"], ["", "lemma farkas_check: \n  assumes check: \"check s' = s\" and U: \"\\<U> s\" \"\\<not> \\<U> s'\"\n    and inv: \"\\<nabla> s'\" \"\\<triangle> (\\<T> s')\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s'\" \"\\<diamond> s'\" \n    and index: \"index_valid as s'\" \n  shows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "let ?Q = \"\\<lambda> s f p c C. set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n    distinct C \\<and>\n    (\\<forall>a \\<in> set C. is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and> f (atom_var a) \\<noteq> 0) \\<and>\n    (\\<Sum>a \\<leftarrow> C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) = Leqc p c \\<and>\n    c < 0 \\<and>\n    (\\<forall> v :: 'a valuation. v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>(p\\<lbrace>v\\<rbrace> = 0))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "let ?P = \"\\<lambda> s. \\<U> s \\<longrightarrow> (\\<exists> f p c C. ?Q s f p c C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "have \"?P (check s')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<U> (check s') \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A (check s') \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> (check s') \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))", "proof (induct rule: check_induct''[OF inv, of ?P])"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "case (3 s x\\<^sub>i dir I)"], ["proof (state)\nthis:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have dir: \"dir = Positive \\<or> dir = Negative\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dir = Positive \\<or> dir = Negative", "by fact"], ["proof (state)\nthis:\n  dir = Positive \\<or> dir = Negative\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?eq = \"(eq_for_lvar (\\<T> s) x\\<^sub>i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define X\\<^sub>j where \"X\\<^sub>j = rvars_eq ?eq\""], ["proof (state)\nthis:\n  X\\<^sub>j = rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define XL\\<^sub>j where \"XL\\<^sub>j = Abstract_Linear_Poly.vars_list (rhs ?eq)\""], ["proof (state)\nthis:\n  XL\\<^sub>j =\n  Abstract_Linear_Poly.vars_list (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have [simp]: \"set XL\\<^sub>j = X\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set XL\\<^sub>j = X\\<^sub>j", "unfolding XL\\<^sub>j_def X\\<^sub>j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Abstract_Linear_Poly.vars_list\n          (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))) =\n    rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)", "using set_vars_list"], ["proof (prove)\nusing this:\n  set (Abstract_Linear_Poly.vars_list ?lp) = vars ?lp\n\ngoal (1 subgoal):\n 1. set (Abstract_Linear_Poly.vars_list\n          (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))) =\n    rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)", "by blast"], ["proof (state)\nthis:\n  set XL\\<^sub>j = X\\<^sub>j\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have XL\\<^sub>j_distinct: \"distinct XL\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct XL\\<^sub>j", "unfolding XL\\<^sub>j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (Abstract_Linear_Poly.vars_list (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)))", "using distinct_vars_list"], ["proof (prove)\nusing this:\n  distinct (Abstract_Linear_Poly.vars_list ?p)\n\ngoal (1 subgoal):\n 1. distinct\n     (Abstract_Linear_Poly.vars_list (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)))", "by simp"], ["proof (state)\nthis:\n  distinct XL\\<^sub>j\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define A where \"A = coeff (rhs ?eq)\""], ["proof (state)\nthis:\n  A = coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have bounds_id: \"\\<B>\\<^sub>A (set_unsat I s) = \\<B>\\<^sub>A s\" \"\\<B>\\<^sub>u (set_unsat I s) = \\<B>\\<^sub>u s\" \"\\<B>\\<^sub>l (set_unsat I s) = \\<B>\\<^sub>l s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sub>A (set_unsat I s) = \\<B>\\<^sub>A s &&&\n    \\<B>\\<^sub>u (set_unsat I s) = \\<B>\\<^sub>u s &&&\n    \\<B>\\<^sub>l (set_unsat I s) = \\<B>\\<^sub>l s", "by (auto simp: boundsl_def boundsu_def bound_atoms_def)"], ["proof (state)\nthis:\n  \\<B>\\<^sub>A (set_unsat I s) = \\<B>\\<^sub>A s\n  \\<B>\\<^sub>u (set_unsat I s) = \\<B>\\<^sub>u s\n  \\<B>\\<^sub>l (set_unsat I s) = \\<B>\\<^sub>l s\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have t_id: \"\\<T> (set_unsat I s) = \\<T> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (set_unsat I s) = \\<T> s", "by simp"], ["proof (state)\nthis:\n  \\<T> (set_unsat I s) = \\<T> s\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have u_id: \"\\<U> (set_unsat I s) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<U> (set_unsat I s) = True", "by simp"], ["proof (state)\nthis:\n  \\<U> (set_unsat I s) = True\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?p = \"rhs ?eq - lp_monom 1 x\\<^sub>i\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have p_eval_zero: \"?p \\<lbrace> v \\<rbrace> = 0\" if \"v \\<Turnstile>\\<^sub>t \\<T> s\" for v :: \"'a valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "have eqT: \"?eq \\<in> set (\\<T> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_for_lvar (\\<T> s) x\\<^sub>i \\<in> set (\\<T> s)", "by (simp add: 3(7) eq_for_lvar local.min_lvar_not_in_bounds_lvars)"], ["proof (state)\nthis:\n  eq_for_lvar (\\<T> s) x\\<^sub>i \\<in> set (\\<T> s)\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "have \"v \\<Turnstile>\\<^sub>e ?eq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>e eq_for_lvar (\\<T> s) x\\<^sub>i", "using that eqT satisfies_tableau_def"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t \\<T> s\n  eq_for_lvar (\\<T> s) x\\<^sub>i \\<in> set (\\<T> s)\n  ?v \\<Turnstile>\\<^sub>t ?t \\<equiv>\n  \\<forall>e\\<in>set ?t. ?v \\<Turnstile>\\<^sub>e e\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>e eq_for_lvar (\\<T> s) x\\<^sub>i", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>e eq_for_lvar (\\<T> s) x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>e eq_for_lvar (\\<T> s) x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "have \"?eq = (lhs ?eq, rhs ?eq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq_for_lvar (\\<T> s) x\\<^sub>i =\n    (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i),\n     rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "by (cases ?eq, auto)"], ["proof (state)\nthis:\n  eq_for_lvar (\\<T> s) x\\<^sub>i =\n  (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i),\n   rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "also"], ["proof (state)\nthis:\n  eq_for_lvar (\\<T> s) x\\<^sub>i =\n  (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i),\n   rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "have \"lhs ?eq = x\\<^sub>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lhs (eq_for_lvar (\\<T> s) x\\<^sub>i) = x\\<^sub>i", "by (simp add: 3(7) eq_for_lvar local.min_lvar_not_in_bounds_lvars)"], ["proof (state)\nthis:\n  lhs (eq_for_lvar (\\<T> s) x\\<^sub>i) = x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "finally"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "have \"v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs ?eq)\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "."], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "show ?thesis"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>e (x\\<^sub>i, rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n    (0::'a)", "by (auto simp: satisfies_eq_iff valuate_minus)"], ["proof (state)\nthis:\n  rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n  lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n  (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?v2 \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow>\n  rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n  lp_monom 1 x\\<^sub>i \\<lbrace> ?v2 \\<rbrace> =\n  (0::'a)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have Xj_rvars: \"X\\<^sub>j \\<subseteq> rvars (\\<T> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X\\<^sub>j \\<subseteq> rvars (\\<T> s)", "unfolding X\\<^sub>j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<subseteq> rvars (\\<T> s)", "using 3 min_lvar_not_in_bounds_lvars rvars_of_lvar_rvars"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n  min_lvar_not_in_bounds ?s = Some ?x\\<^sub>i \\<longrightarrow>\n  ?x\\<^sub>i \\<in> lvars (\\<T> ?s)\n  ?x \\<in> lvars ?t \\<Longrightarrow>\n  rvars_eq (eq_for_lvar ?t ?x) \\<subseteq> rvars ?t\n\ngoal (1 subgoal):\n 1. rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<subseteq> rvars (\\<T> s)", "by blast"], ["proof (state)\nthis:\n  X\\<^sub>j \\<subseteq> rvars (\\<T> s)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have xi_lvars: \"x\\<^sub>i \\<in> lvars (\\<T> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x\\<^sub>i \\<in> lvars (\\<T> s)", "using 3 min_lvar_not_in_bounds_lvars rvars_of_lvar_rvars"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n  min_lvar_not_in_bounds ?s = Some ?x\\<^sub>i \\<longrightarrow>\n  ?x\\<^sub>i \\<in> lvars (\\<T> ?s)\n  ?x \\<in> lvars ?t \\<Longrightarrow>\n  rvars_eq (eq_for_lvar ?t ?x) \\<subseteq> rvars ?t\n\ngoal (1 subgoal):\n 1. x\\<^sub>i \\<in> lvars (\\<T> s)", "by blast"], ["proof (state)\nthis:\n  x\\<^sub>i \\<in> lvars (\\<T> s)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have \"lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}", "using 3 normalized_tableau_def"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n  \\<triangle> ?t \\<equiv>\n  distinct (map lhs ?t) \\<and>\n  lvars ?t \\<inter> rvars ?t = {} \\<and> 0 \\<notin> rhs ` set ?t\n\ngoal (1 subgoal):\n 1. lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}", "by auto"], ["proof (state)\nthis:\n  lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "with xi_lvars Xj_rvars"], ["proof (chain)\npicking this:\n  x\\<^sub>i \\<in> lvars (\\<T> s)\n  X\\<^sub>j \\<subseteq> rvars (\\<T> s)\n  lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}", "have xi_Xj: \"x\\<^sub>i \\<notin> X\\<^sub>j\""], ["proof (prove)\nusing this:\n  x\\<^sub>i \\<in> lvars (\\<T> s)\n  X\\<^sub>j \\<subseteq> rvars (\\<T> s)\n  lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {}\n\ngoal (1 subgoal):\n 1. x\\<^sub>i \\<notin> X\\<^sub>j", "by blast"], ["proof (state)\nthis:\n  x\\<^sub>i \\<notin> X\\<^sub>j\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have rhs_eval_xi: \"(rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) \\<lbrace>\\<langle>\\<V> s\\<rangle>\\<rbrace> = \\<langle>\\<V> s\\<rangle> x\\<^sub>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "have *: \"(rhs eq) \\<lbrace> v \\<rbrace> = v (lhs eq)\" if \"v \\<Turnstile>\\<^sub>e eq\" for v :: \"'a valuation\" and eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs eq \\<lbrace> v \\<rbrace> = v (lhs eq)", "using satisfies_eq_def that"], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>e ?eq \\<equiv>\n  ?v (lhs ?eq) = rhs ?eq \\<lbrace> ?v \\<rbrace>\n  v \\<Turnstile>\\<^sub>e eq\n\ngoal (1 subgoal):\n 1. rhs eq \\<lbrace> v \\<rbrace> = v (lhs eq)", "by metis"], ["proof (state)\nthis:\n  ?v2 \\<Turnstile>\\<^sub>e ?eq2 \\<Longrightarrow>\n  rhs ?eq2 \\<lbrace> ?v2 \\<rbrace> = ?v2 (lhs ?eq2)\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "moreover"], ["proof (state)\nthis:\n  ?v2 \\<Turnstile>\\<^sub>e ?eq2 \\<Longrightarrow>\n  rhs ?eq2 \\<lbrace> ?v2 \\<rbrace> = ?v2 (lhs ?eq2)\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "have \"\\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e eq_for_lvar (\\<T> s) x\\<^sub>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n    eq_for_lvar (\\<T> s) x\\<^sub>i", "using 3 satisfies_tableau_def eq_for_lvar curr_val_satisfies_no_lhs_def xi_lvars"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n  ?v \\<Turnstile>\\<^sub>t ?t \\<equiv>\n  \\<forall>e\\<in>set ?t. ?v \\<Turnstile>\\<^sub>e e\n  ?x \\<in> lvars ?t \\<Longrightarrow>\n  eq_for_lvar ?t ?x \\<in> set ?t \\<and> lhs (eq_for_lvar ?t ?x) = ?x\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s ?s \\<equiv>\n  \\<langle>\\<V> ?s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> ?s \\<and>\n  \\<langle>\\<V> ?s\\<rangle> \\<Turnstile>\\<^sub>b \\<B> ?s \\<parallel>\n  - lvars (\\<T> ?s)\n  x\\<^sub>i \\<in> lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n    eq_for_lvar (\\<T> s) x\\<^sub>i", "by blast"], ["proof (state)\nthis:\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n  eq_for_lvar (\\<T> s) x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "ultimately"], ["proof (chain)\npicking this:\n  ?v2 \\<Turnstile>\\<^sub>e ?eq2 \\<Longrightarrow>\n  rhs ?eq2 \\<lbrace> ?v2 \\<rbrace> = ?v2 (lhs ?eq2)\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n  eq_for_lvar (\\<T> s) x\\<^sub>i", "show ?thesis"], ["proof (prove)\nusing this:\n  ?v2 \\<Turnstile>\\<^sub>e ?eq2 \\<Longrightarrow>\n  rhs ?eq2 \\<lbrace> ?v2 \\<rbrace> = ?v2 (lhs ?eq2)\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n  eq_for_lvar (\\<T> s) x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "using eq_for_lvar xi_lvars"], ["proof (prove)\nusing this:\n  ?v2 \\<Turnstile>\\<^sub>e ?eq2 \\<Longrightarrow>\n  rhs ?eq2 \\<lbrace> ?v2 \\<rbrace> = ?v2 (lhs ?eq2)\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>e\n  eq_for_lvar (\\<T> s) x\\<^sub>i\n  ?x \\<in> lvars ?t \\<Longrightarrow>\n  eq_for_lvar ?t ?x \\<in> set ?t \\<and> lhs (eq_for_lvar ?t ?x) = ?x\n  x\\<^sub>i \\<in> lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "by simp"], ["proof (state)\nthis:\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?\\<B>\\<^sub>l = \"Direction.LB dir\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?\\<B>\\<^sub>u = \"Direction.UB dir\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?lt = \"Direction.lt dir\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?le = \"Simplex.le ?lt\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?Geq = \"Direction.GE dir\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?Leq = \"Direction.LE dir\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have 0: \"(if A x < 0 then ?\\<B>\\<^sub>l s x = Some (\\<langle>\\<V> s\\<rangle> x) else ?\\<B>\\<^sub>u s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and> A x \\<noteq> 0\"\n      if x: \"x \\<in> X\\<^sub>j\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "have \"Some (\\<langle>\\<V> s\\<rangle> x) = (?\\<B>\\<^sub>l s x)\" if \"A x < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "have cmp: \"\\<not> \\<rhd>\\<^sub>l\\<^sub>b ?lt (\\<langle>\\<V> s\\<rangle> x) (?\\<B>\\<^sub>l s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)", "using x that dir min_rvar_incdec_eq_None[OF 3(9)]"], ["proof (prove)\nusing this:\n  x \\<in> X\\<^sub>j\n  A x < 0\n  dir = Positive \\<or> dir = Negative\n  (\\<forall>x\\<in>rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i).\n      \\<not> (0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x \\<and>\n              \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x) \\<or>\n              coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0 \\<and>\n              \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x))) \\<and>\n  set I =\n  {Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))} \\<union>\n  {Direction.LI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0} \\<union>\n  {Direction.UI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x} \\<and>\n  (dir = Positive \\<or> dir = Negative \\<longrightarrow>\n   Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n   \\<in> indices_state s \\<longrightarrow>\n   set I \\<subseteq> indices_state s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)", "unfolding X\\<^sub>j_def A_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)\n  coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0\n  dir = Positive \\<or> dir = Negative\n  (\\<forall>x\\<in>rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i).\n      \\<not> (0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x \\<and>\n              \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x) \\<or>\n              coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0 \\<and>\n              \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x))) \\<and>\n  set I =\n  {Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))} \\<union>\n  {Direction.LI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0} \\<union>\n  {Direction.UI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x} \\<and>\n  (dir = Positive \\<or> dir = Negative \\<longrightarrow>\n   Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n   \\<in> indices_state s \\<longrightarrow>\n   set I \\<subseteq> indices_state s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)", "obtain c where c: \"?\\<B>\\<^sub>l s x = Some c\""], ["proof (prove)\nusing this:\n  \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        Direction.LB dir s x = Some c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?\\<B>\\<^sub>l s x\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  Direction.LB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "also"], ["proof (state)\nthis:\n  Direction.LB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "have \"c = \\<langle>\\<V> s\\<rangle> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"x \\<in> rvars (\\<T> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rvars (\\<T> s)", "using that x Xj_rvars"], ["proof (prove)\nusing this:\n  A x < 0\n  x \\<in> X\\<^sub>j\n  X\\<^sub>j \\<subseteq> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. x \\<in> rvars (\\<T> s)", "by blast"], ["proof (state)\nthis:\n  x \\<in> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "then"], ["proof (chain)\npicking this:\n  x \\<in> rvars (\\<T> s)", "have \"x \\<in> (- lvars (\\<T> s))\""], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "using 3"], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "unfolding normalized_tableau_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  distinct (map lhs (\\<T> s)) \\<and>\n  lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {} \\<and>\n  0 \\<notin> rhs ` set (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "by auto"], ["proof (state)\nthis:\n  x \\<in> - lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "moreover"], ["proof (state)\nthis:\n  x \\<in> - lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"\\<forall>x\\<in>(- lvars (\\<T> s)). in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B>\\<^sub>l s, \\<B>\\<^sub>u s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "using 3"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "unfolding curr_val_satisfies_no_lhs_def"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s \\<and>\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s \\<parallel>\n  - lvars (\\<T> s)\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "by (simp add: satisfies_bounds_set.simps)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - lvars (\\<T> s)\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "have \"in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B>\\<^sub>l s, \\<B>\\<^sub>u s)\""], ["proof (prove)\nusing this:\n  x \\<in> - lvars (\\<T> s)\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "by blast"], ["proof (state)\nthis:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "moreover"], ["proof (state)\nthis:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"?le (\\<langle>\\<V> s\\<rangle> x) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n    \\<langle>\\<V> s\\<rangle> x = c", "using cmp c dir"], ["proof (prove)\nusing this:\n  \\<not> \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x)\n  Direction.LB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n    \\<langle>\\<V> s\\<rangle> x = c", "unfolding bound_compare_defs"], ["proof (prove)\nusing this:\n  \\<not> (case Direction.LB dir s x of None \\<Rightarrow> True\n          | Some b' \\<Rightarrow>\n              Direction.lt dir b' (\\<langle>\\<V> s\\<rangle> x))\n  Direction.LB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n    \\<langle>\\<V> s\\<rangle> x = c", "by auto"], ["proof (state)\nthis:\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n  \\<langle>\\<V> s\\<rangle> x = c\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "ultimately"], ["proof (chain)\npicking this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n  \\<langle>\\<V> s\\<rangle> x = c", "show ?thesis"], ["proof (prove)\nusing this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n  \\<langle>\\<V> s\\<rangle> x = c\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "using c dir"], ["proof (prove)\nusing this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) c \\<or>\n  \\<langle>\\<V> s\\<rangle> x = c\n  Direction.LB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "by auto"], ["proof (state)\nthis:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "then"], ["proof (chain)\npicking this:\n  c = \\<langle>\\<V> s\\<rangle> x", "show ?thesis"], ["proof (prove)\nusing this:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "using c"], ["proof (prove)\nusing this:\n  c = \\<langle>\\<V> s\\<rangle> x\n  Direction.LB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x", "by simp"], ["proof (state)\nthis:\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  A x < 0 \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  A x < 0 \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "have \"Some (\\<langle>\\<V> s\\<rangle> x) = (?\\<B>\\<^sub>u s x)\" if \"0 < A x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "have cmp: \"\\<not> \\<lhd>\\<^sub>u\\<^sub>b ?lt (\\<langle>\\<V> s\\<rangle> x) (?\\<B>\\<^sub>u s x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)", "using x that min_rvar_incdec_eq_None[OF 3(9)]"], ["proof (prove)\nusing this:\n  x \\<in> X\\<^sub>j\n  0 < A x\n  (\\<forall>x\\<in>rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i).\n      \\<not> (0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x \\<and>\n              \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x) \\<or>\n              coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0 \\<and>\n              \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x))) \\<and>\n  set I =\n  {Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))} \\<union>\n  {Direction.LI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0} \\<union>\n  {Direction.UI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x} \\<and>\n  (dir = Positive \\<or> dir = Negative \\<longrightarrow>\n   Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n   \\<in> indices_state s \\<longrightarrow>\n   set I \\<subseteq> indices_state s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)", "unfolding X\\<^sub>j_def A_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)\n  0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x\n  (\\<forall>x\\<in>rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i).\n      \\<not> (0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x \\<and>\n              \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x) \\<or>\n              coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0 \\<and>\n              \\<rhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n               (\\<langle>\\<V> s\\<rangle> x) (Direction.LB dir s x))) \\<and>\n  set I =\n  {Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))} \\<union>\n  {Direction.LI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x < 0} \\<union>\n  {Direction.UI dir s x |x.\n   x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i) \\<and>\n   0 < coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x} \\<and>\n  (dir = Positive \\<or> dir = Negative \\<longrightarrow>\n   Direction.LI dir s (lhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n   \\<in> indices_state s \\<longrightarrow>\n   set I \\<subseteq> indices_state s)\n\ngoal (1 subgoal):\n 1. \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n            (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)", "by auto"], ["proof (state)\nthis:\n  \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "then"], ["proof (chain)\npicking this:\n  \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)", "obtain c where c: \"?\\<B>\\<^sub>u s x = Some c\""], ["proof (prove)\nusing this:\n  \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        Direction.UB dir s x = Some c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?\\<B>\\<^sub>u s x\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  Direction.UB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "also"], ["proof (state)\nthis:\n  Direction.UB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "have \"c = \\<langle>\\<V> s\\<rangle> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"x \\<in> rvars (\\<T> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> rvars (\\<T> s)", "using that x Xj_rvars"], ["proof (prove)\nusing this:\n  0 < A x\n  x \\<in> X\\<^sub>j\n  X\\<^sub>j \\<subseteq> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. x \\<in> rvars (\\<T> s)", "by blast"], ["proof (state)\nthis:\n  x \\<in> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "then"], ["proof (chain)\npicking this:\n  x \\<in> rvars (\\<T> s)", "have \"x \\<in> (- lvars (\\<T> s))\""], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "using 3"], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "unfolding normalized_tableau_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars (\\<T> s)\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  distinct (map lhs (\\<T> s)) \\<and>\n  lvars (\\<T> s) \\<inter> rvars (\\<T> s) = {} \\<and>\n  0 \\<notin> rhs ` set (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. x \\<in> - lvars (\\<T> s)", "by auto"], ["proof (state)\nthis:\n  x \\<in> - lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "moreover"], ["proof (state)\nthis:\n  x \\<in> - lvars (\\<T> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"\\<forall>x\\<in>(- lvars (\\<T> s)). in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B>\\<^sub>l s, \\<B>\\<^sub>u s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "using 3"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "unfolding curr_val_satisfies_no_lhs_def"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s \\<and>\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>b \\<B> s \\<parallel>\n  - lvars (\\<T> s)\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>- lvars (\\<T> s).\n       in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "by (simp add: satisfies_bounds_set.simps)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> - lvars (\\<T> s)\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "have \"in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B>\\<^sub>l s, \\<B>\\<^sub>u s)\""], ["proof (prove)\nusing this:\n  x \\<in> - lvars (\\<T> s)\n  \\<forall>x\\<in>- lvars (\\<T> s).\n     in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)", "by blast"], ["proof (state)\nthis:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "moreover"], ["proof (state)\nthis:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "have \"?le c (\\<langle>\\<V> s\\<rangle> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n    c = \\<langle>\\<V> s\\<rangle> x", "using cmp c dir"], ["proof (prove)\nusing this:\n  \\<not> \\<lhd>\\<^sub>u\\<^sub>b (Direction.lt dir)\n          (\\<langle>\\<V> s\\<rangle> x) (Direction.UB dir s x)\n  Direction.UB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n    c = \\<langle>\\<V> s\\<rangle> x", "unfolding bound_compare_defs"], ["proof (prove)\nusing this:\n  \\<not> (case Direction.UB dir s x of None \\<Rightarrow> True\n          | Some b' \\<Rightarrow>\n              Direction.lt dir (\\<langle>\\<V> s\\<rangle> x) b')\n  Direction.UB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n    c = \\<langle>\\<V> s\\<rangle> x", "by auto"], ["proof (state)\nthis:\n  Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "ultimately"], ["proof (chain)\npicking this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n  c = \\<langle>\\<V> s\\<rangle> x", "show ?thesis"], ["proof (prove)\nusing this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "using c dir"], ["proof (prove)\nusing this:\n  in_bounds x \\<langle>\\<V> s\\<rangle> (\\<B> s)\n  Direction.lt dir c (\\<langle>\\<V> s\\<rangle> x) \\<or>\n  c = \\<langle>\\<V> s\\<rangle> x\n  Direction.UB dir s x = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. c = \\<langle>\\<V> s\\<rangle> x", "by auto"], ["proof (state)\nthis:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "then"], ["proof (chain)\npicking this:\n  c = \\<langle>\\<V> s\\<rangle> x", "show ?thesis"], ["proof (prove)\nusing this:\n  c = \\<langle>\\<V> s\\<rangle> x\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "using c"], ["proof (prove)\nusing this:\n  c = \\<langle>\\<V> s\\<rangle> x\n  Direction.UB dir s x = Some c\n\ngoal (1 subgoal):\n 1. Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x", "by simp"], ["proof (state)\nthis:\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < A x \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "moreover"], ["proof (state)\nthis:\n  0 < A x \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "have \"A x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A x \\<noteq> 0", "using that coeff_zero"], ["proof (prove)\nusing this:\n  x \\<in> X\\<^sub>j\n  (coeff ?p ?x \\<noteq> 0) = (?x \\<in> vars ?p)\n\ngoal (1 subgoal):\n 1. A x \\<noteq> 0", "unfolding A_def X\\<^sub>j_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i)\n  (coeff ?p ?x \\<noteq> 0) = (?x \\<in> vars ?p)\n\ngoal (1 subgoal):\n 1. coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  A x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "ultimately"], ["proof (chain)\npicking this:\n  A x < 0 \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n  0 < A x \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n  A x \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  A x < 0 \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n  0 < A x \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n  A x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  A x < 0 \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.LB dir s x\n  0 < A x \\<Longrightarrow>\n  Some (\\<langle>\\<V> s\\<rangle> x) = Direction.UB dir s x\n  A x \\<noteq> 0\n  x \\<in> X\\<^sub>j\n\ngoal (1 subgoal):\n 1. (if A x < 0\n     then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n     else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n    A x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  (if A x < 0 then Direction.LB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)\n   else Direction.UB dir s x = Some (\\<langle>\\<V> s\\<rangle> x)) \\<and>\n  A x \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "have l_Ba: \"l \\<in> \\<B>\\<^sub>A s\" if \"l \\<in> {?Geq x\\<^sub>i (the (?\\<B>\\<^sub>l s x\\<^sub>i))}\" for l"], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "from that"], ["proof (chain)\npicking this:\n  l \\<in> {Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))}", "have l: \"l = ?Geq x\\<^sub>i (the (?\\<B>\\<^sub>l s x\\<^sub>i))\""], ["proof (prove)\nusing this:\n  l \\<in> {Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))}\n\ngoal (1 subgoal):\n 1. l = Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))", "by simp"], ["proof (state)\nthis:\n  l = Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))\n\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "from 3(8)"], ["proof (chain)\npicking this:\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)", "obtain c where bl': \"?\\<B>\\<^sub>l s x\\<^sub>i = Some c\""], ["proof (prove)\nusing this:\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        Direction.LB dir s x\\<^sub>i = Some c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?\\<B>\\<^sub>l s x\\<^sub>i\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  Direction.LB dir s x\\<^sub>i = Some c\n\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "hence bl: \"(x\\<^sub>i, c) \\<in> set_of_map (?\\<B>\\<^sub>l s)\""], ["proof (prove)\nusing this:\n  Direction.LB dir s x\\<^sub>i = Some c\n\ngoal (1 subgoal):\n 1. (x\\<^sub>i, c) \\<in> set_of_map (Direction.LB dir s)", "unfolding set_of_map_def"], ["proof (prove)\nusing this:\n  Direction.LB dir s x\\<^sub>i = Some c\n\ngoal (1 subgoal):\n 1. (x\\<^sub>i, c) \\<in> {(k, v) |k v. Direction.LB dir s k = Some v}", "by auto"], ["proof (state)\nthis:\n  (x\\<^sub>i, c) \\<in> set_of_map (Direction.LB dir s)\n\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "show \"l \\<in> \\<B>\\<^sub>A s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<in> \\<B>\\<^sub>A s", "unfolding l bound_atoms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))\n    \\<in> (\\<lambda>(x, y). Geq x y) ` set_of_map (\\<B>\\<^sub>l s) \\<union>\n          (\\<lambda>(x, y). Leq x y) ` set_of_map (\\<B>\\<^sub>u s)", "using bl bl' dir"], ["proof (prove)\nusing this:\n  (x\\<^sub>i, c) \\<in> set_of_map (Direction.LB dir s)\n  Direction.LB dir s x\\<^sub>i = Some c\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))\n    \\<in> (\\<lambda>(x, y). Geq x y) ` set_of_map (\\<B>\\<^sub>l s) \\<union>\n          (\\<lambda>(x, y). Leq x y) ` set_of_map (\\<B>\\<^sub>u s)", "by auto"], ["proof (state)\nthis:\n  l \\<in> \\<B>\\<^sub>A s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?l2\n  \\<in> {Direction.GE dir x\\<^sub>i\n          (the (Direction.LB dir s x\\<^sub>i))} \\<Longrightarrow>\n  ?l2 \\<in> \\<B>\\<^sub>A s\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?negA = \"filter (\\<lambda> x. A x < 0) XL\\<^sub>j\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?posA = \"filter (\\<lambda> x. \\<not> A x < 0) XL\\<^sub>j\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define neg where \"neg = (if dir = Positive then (\\<lambda> x :: rat. x) else uminus)\""], ["proof (state)\nthis:\n  neg = (if dir = Positive then \\<lambda>x. x else uminus)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define negP where \"negP = (if dir = Positive then (\\<lambda> x :: linear_poly. x) else uminus)\""], ["proof (state)\nthis:\n  negP = (if dir = Positive then \\<lambda>x. x else uminus)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define nega where \"nega = (if dir = Positive then (\\<lambda> x :: 'a. x) else uminus)\""], ["proof (state)\nthis:\n  nega = (if dir = Positive then \\<lambda>x. x else uminus)\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "from dir"], ["proof (chain)\npicking this:\n  dir = Positive \\<or> dir = Negative", "have dirn: \"dir = Positive \\<and> neg = (\\<lambda> x. x) \\<and> negP = (\\<lambda> x. x) \\<and> nega = (\\<lambda> x. x)\n      \\<or> dir = Negative \\<and> neg = uminus \\<and> negP = uminus \\<and> nega = uminus\""], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. dir = Positive \\<and>\n    neg = (\\<lambda>x. x) \\<and>\n    negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n    dir = Negative \\<and>\n    neg = uminus \\<and> negP = uminus \\<and> nega = uminus", "unfolding neg_def negP_def nega_def"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. dir = Positive \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) =\n    (\\<lambda>x. x) \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) =\n    (\\<lambda>x. x) \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) =\n    (\\<lambda>x. x) \\<or>\n    dir = Negative \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) = uminus \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) = uminus \\<and>\n    (if dir = Positive then \\<lambda>x. x else uminus) = uminus", "by auto"], ["proof (state)\nthis:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define C where \"C = map (\\<lambda>x. ?Geq x (the (?\\<B>\\<^sub>l s x))) ?negA \n                        @ map (\\<lambda> x. ?Leq x (the (?\\<B>\\<^sub>u s x)))  ?posA\n                        @ [?Geq x\\<^sub>i (the (?\\<B>\\<^sub>l s x\\<^sub>i))]\""], ["proof (state)\nthis:\n  C =\n  map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n   (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n  map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n   (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n  [Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))]\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define f where \"f = (\\<lambda>x. if x = x\\<^sub>i then neg (-1) else neg (A x))\""], ["proof (state)\nthis:\n  f = (\\<lambda>x. if x = x\\<^sub>i then neg (- 1) else neg (A x))\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "define c where \"c = (\\<Sum>x\\<leftarrow>C. lec_const (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))\""], ["proof (state)\nthis:\n  c =\n  (\\<Sum>x\\<leftarrow>C. lec_const\n                          (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))\n\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "let ?q = \"negP ?p\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))\n 3. \\<And>s x\\<^sub>i dir I.\n       \\<lbrakk>dir = Positive \\<or> dir = Negative; \\<nabla> s;\n        \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = Some x\\<^sub>i;\n        \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n         (\\<langle>\\<V> s\\<rangle> x\\<^sub>i)\n         (Direction.LB dir s x\\<^sub>i);\n        min_rvar_incdec dir s x\\<^sub>i = Inl I\\<rbrakk>\n       \\<Longrightarrow> \\<U> (set_unsat I s) \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C\n                             \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> (set_unsat I s) \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<U> (set_unsat I s) \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> (set_unsat I s) \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))", "unfolding bounds_id t_id u_id"], ["proof (prove)\ngoal (1 subgoal):\n 1. True \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))", "proof (intro exI impI conjI allI)"], ["proof (state)\ngoal (6 subgoals):\n 1. True \\<Longrightarrow> set ?C4 \\<subseteq> \\<B>\\<^sub>A s\n 2. True \\<Longrightarrow> distinct ?C4\n 3. True \\<Longrightarrow>\n    \\<forall>a\\<in>set ?C4.\n       is_leq_ns (?f1 (atom_var a) *R nsc_of_atom a) \\<and>\n       ?f1 (atom_var a) \\<noteq> 0\n 4. True \\<Longrightarrow>\n    (\\<Sum>a\\<leftarrow>?C4. lec_of_nsc\n                              (?f1 (atom_var a) *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel ?p2 ?c3\n 5. True \\<Longrightarrow> ?c3 < (0::'a)\n 6. \\<And>v.\n       \\<lbrakk>True; v \\<Turnstile>\\<^sub>t \\<T> s\\<rbrakk>\n       \\<Longrightarrow> ?p2 \\<lbrace> v \\<rbrace> = (0::'a)", "show \"v \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow> ?q \\<lbrace> v \\<rbrace> = 0\" for v :: \"'a valuation\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow>\n    negP\n     (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n      lp_monom 1 x\\<^sub>i) \\<lbrace> v \\<rbrace> =\n    (0::'a)", "using dirn p_eval_zero[of v]"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  v \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow>\n  rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n  lp_monom 1 x\\<^sub>i \\<lbrace> v \\<rbrace> =\n  (0::'a)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow>\n    negP\n     (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n      lp_monom 1 x\\<^sub>i) \\<lbrace> v \\<rbrace> =\n    (0::'a)", "by (auto simp: valuate_minus)"], ["proof (state)\nthis:\n  ?v2 \\<Turnstile>\\<^sub>t \\<T> s \\<Longrightarrow>\n  negP\n   (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) -\n    lp_monom 1 x\\<^sub>i) \\<lbrace> ?v2 \\<rbrace> =\n  (0::'a)\n\ngoal (5 subgoals):\n 1. True \\<Longrightarrow> set ?C4 \\<subseteq> \\<B>\\<^sub>A s\n 2. True \\<Longrightarrow> distinct ?C4\n 3. True \\<Longrightarrow>\n    \\<forall>a\\<in>set ?C4.\n       is_leq_ns (?f1 (atom_var a) *R nsc_of_atom a) \\<and>\n       ?f1 (atom_var a) \\<noteq> 0\n 4. True \\<Longrightarrow>\n    (\\<Sum>a\\<leftarrow>?C4. lec_of_nsc\n                              (?f1 (atom_var a) *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel\n     (negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i))\n     ?c3\n 5. True \\<Longrightarrow> ?c3 < (0::'a)", "show \"set C \\<subseteq> \\<B>\\<^sub>A s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set C \\<subseteq> \\<B>\\<^sub>A s", "unfolding C_def set_append set_map set_filter list.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x))) `\n    {x \\<in> set XL\\<^sub>j. A x < 0} \\<union>\n    ((\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x))) `\n     {x \\<in> set XL\\<^sub>j. \\<not> A x < 0} \\<union>\n     {Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))})\n    \\<subseteq> \\<B>\\<^sub>A s", "using 0 l_Ba dir"], ["proof (prove)\nusing this:\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n  ?l2\n  \\<in> {Direction.GE dir x\\<^sub>i\n          (the (Direction.LB dir s x\\<^sub>i))} \\<Longrightarrow>\n  ?l2 \\<in> \\<B>\\<^sub>A s\n  dir = Positive \\<or> dir = Negative\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x))) `\n    {x \\<in> set XL\\<^sub>j. A x < 0} \\<union>\n    ((\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x))) `\n     {x \\<in> set XL\\<^sub>j. \\<not> A x < 0} \\<union>\n     {Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))})\n    \\<subseteq> \\<B>\\<^sub>A s", "by (intro Un_least subsetI) (force simp: bound_atoms_def set_of_map_def)+"], ["proof (state)\nthis:\n  set C \\<subseteq> \\<B>\\<^sub>A s\n\ngoal (4 subgoals):\n 1. True \\<Longrightarrow> distinct C\n 2. True \\<Longrightarrow>\n    \\<forall>a\\<in>set C.\n       is_leq_ns (?f1 (atom_var a) *R nsc_of_atom a) \\<and>\n       ?f1 (atom_var a) \\<noteq> 0\n 3. True \\<Longrightarrow>\n    (\\<Sum>a\\<leftarrow>C. lec_of_nsc (?f1 (atom_var a) *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel\n     (negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i))\n     ?c3\n 4. True \\<Longrightarrow> ?c3 < (0::'a)", "show is_leq: \"\\<forall>a\\<in>set C. is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and> f (atom_var a) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set C.\n       is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n       f (atom_var a) \\<noteq> 0", "using dirn xi_Xj 0"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  x\\<^sub>i \\<notin> X\\<^sub>j\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set C.\n       is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n       f (atom_var a) \\<noteq> 0", "unfolding C_def f_def"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  x\\<^sub>i \\<notin> X\\<^sub>j\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>set (map (\\<lambda>x.\n                                Direction.GE dir x\n                                 (the (Direction.LB dir s x)))\n                         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n                        map (\\<lambda>x.\n                                Direction.LE dir x\n                                 (the (Direction.UB dir s x)))\n                         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n                        [Direction.GE dir x\\<^sub>i\n                          (the (Direction.LB dir s x\\<^sub>i))]).\n       is_leq_ns\n        ((if atom_var a = x\\<^sub>i then neg (- 1)\n          else neg (A (atom_var a))) *R\n         nsc_of_atom a) \\<and>\n       (if atom_var a = x\\<^sub>i then neg (- 1)\n        else neg (A (atom_var a))) \\<noteq>\n       0", "by (elim disjE, auto)"], ["proof (state)\nthis:\n  \\<forall>a\\<in>set C.\n     is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n     f (atom_var a) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. True \\<Longrightarrow> distinct C\n 2. True \\<Longrightarrow>\n    (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel\n     (negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i))\n     ?c3\n 3. True \\<Longrightarrow> ?c3 < (0::'a)", "show \"(\\<Sum>a \\<leftarrow> C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) = Leqc ?q c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel\n     (negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)) c", "unfolding sum_list_lec le_constraint.simps map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel \\<and>\n    (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP\n     (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i) \\<and>\n    (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "proof (intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "define scale_poly :: \"'a atom \\<Rightarrow> linear_poly\" where \n          \"scale_poly = (\\<lambda>x. lec_poly (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))\""], ["proof (state)\nthis:\n  scale_poly =\n  (\\<lambda>x. lec_poly (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "have \"(\\<Sum>x\\<leftarrow>C. scale_poly x) =\n            (\\<Sum>x\\<leftarrow>?negA. scale_poly (?Geq x (the (?\\<B>\\<^sub>l s x))))\n          + (\\<Sum>x\\<leftarrow>?posA. scale_poly (?Leq x (the (?\\<B>\\<^sub>u s x))))\n          - negP (lp_monom 1 x\\<^sub>i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map scale_poly C) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.GE dir x (the (Direction.LB dir s x)))) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.LE dir x (the (Direction.UB dir s x)))) -\n    negP (lp_monom 1 x\\<^sub>i)", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_poly\n       (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n        map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n        [Direction.GE dir x\\<^sub>i\n          (the (Direction.LB dir s x\\<^sub>i))])) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.GE dir x (the (Direction.LB dir s x)))) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.LE dir x (the (Direction.UB dir s x)))) -\n    negP (lp_monom 1 x\\<^sub>i)", "using dirn"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_poly\n       (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n        map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n        [Direction.GE dir x\\<^sub>i\n          (the (Direction.LB dir s x\\<^sub>i))])) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.GE dir x (the (Direction.LB dir s x)))) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.LE dir x (the (Direction.UB dir s x)))) -\n    negP (lp_monom 1 x\\<^sub>i)", "by (auto simp add: comp_def scale_poly_def f_def)"], ["proof (state)\nthis:\n  sum_list (map scale_poly C) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.GE dir x\n(the (Direction.LB dir s x)))) +\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.LE dir x\n(the (Direction.UB dir s x)))) -\n  negP (lp_monom 1 x\\<^sub>i)\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "also"], ["proof (state)\nthis:\n  sum_list (map scale_poly C) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.GE dir x\n(the (Direction.LB dir s x)))) +\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.LE dir x\n(the (Direction.UB dir s x)))) -\n  negP (lp_monom 1 x\\<^sub>i)\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "have \"(\\<Sum>x\\<leftarrow>?negA. scale_poly (?Geq x (the (?\\<B>\\<^sub>l s x))))\n          =  (\\<Sum>x\\<leftarrow> ?negA. negP (A x *R lp_monom 1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.GE dir x (the (Direction.LB dir s x)))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "unfolding scale_poly_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. lec_poly\n(lec_of_nsc\n  ((if atom_var (Direction.GE dir x (the (Direction.LB dir s x))) =\n       x\\<^sub>i\n    then neg (- 1)\n    else neg (A (atom_var\n                  (Direction.GE dir x (the (Direction.LB dir s x)))))) *R\n   nsc_of_atom (Direction.GE dir x (the (Direction.LB dir s x)))))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "using dirn xi_Xj"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  x\\<^sub>i \\<notin> X\\<^sub>j\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. lec_poly\n(lec_of_nsc\n  ((if atom_var (Direction.GE dir x (the (Direction.LB dir s x))) =\n       x\\<^sub>i\n    then neg (- 1)\n    else neg (A (atom_var\n                  (Direction.GE dir x (the (Direction.LB dir s x)))))) *R\n   nsc_of_atom (Direction.GE dir x (the (Direction.LB dir s x)))))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "by (subst map_cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.GE dir x\n(the (Direction.LB dir s x)))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.GE dir x\n(the (Direction.LB dir s x)))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "have \"(\\<Sum>x\\<leftarrow>?posA. scale_poly (?Leq x (the (?\\<B>\\<^sub>u s x))))\n          =  (\\<Sum>x\\<leftarrow> ?posA. negP (A x *R lp_monom 1 x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. scale_poly\n(Direction.LE dir x (the (Direction.UB dir s x)))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "unfolding scale_poly_def f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. lec_poly\n(lec_of_nsc\n  ((if atom_var (Direction.LE dir x (the (Direction.UB dir s x))) =\n       x\\<^sub>i\n    then neg (- 1)\n    else neg (A (atom_var\n                  (Direction.LE dir x (the (Direction.UB dir s x)))))) *R\n   nsc_of_atom (Direction.LE dir x (the (Direction.UB dir s x)))))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "using dirn xi_Xj"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  x\\<^sub>i \\<notin> X\\<^sub>j\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. lec_poly\n(lec_of_nsc\n  ((if atom_var (Direction.LE dir x (the (Direction.UB dir s x))) =\n       x\\<^sub>i\n    then neg (- 1)\n    else neg (A (atom_var\n                  (Direction.LE dir x (the (Direction.UB dir s x)))))) *R\n   nsc_of_atom (Direction.LE dir x (the (Direction.UB dir s x)))))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x))", "by (subst map_cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.LE dir x\n(the (Direction.UB dir s x)))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. scale_poly\n                                    (Direction.LE dir x\n(the (Direction.UB dir s x)))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "have \"(\\<Sum>x\\<leftarrow> ?negA. negP (A x *R lp_monom 1 x)) +\n              (\\<Sum>x\\<leftarrow> ?posA. negP (A x *R lp_monom 1 x))\n             = negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x)) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x)) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "using dirn XL\\<^sub>j_distinct coeff_zero"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  distinct XL\\<^sub>j\n  (coeff ?p ?x \\<noteq> 0) = (?x \\<in> vars ?p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x)) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. negP (A x *R lp_monom 1 x)) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))", "by (elim disjE; intro poly_eqI, auto intro!: poly_eqI simp add: coeff_sum_list A_def X\\<^sub>j_def \n              uminus_sum_list_map[unfolded o_def, symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x)) +\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. negP (A x *R lp_monom 1 x)) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i))\n\ngoal (3 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n 3. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "finally"], ["proof (chain)\npicking this:\n  sum_list (map scale_poly C) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) - negP (lp_monom 1 x\\<^sub>i)", "show \"(\\<Sum>x\\<leftarrow>C. lec_poly (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) = ?q\""], ["proof (prove)\nusing this:\n  sum_list (map scale_poly C) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) - negP (lp_monom 1 x\\<^sub>i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)", "unfolding scale_poly_def"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<leftarrow>C. lec_poly\n                          (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) - negP (lp_monom 1 x\\<^sub>i)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)", "using dirn"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<leftarrow>C. lec_poly\n                          (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) - negP (lp_monom 1 x\\<^sub>i)\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_poly\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C. lec_poly\n                          (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) =\n  negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)\n\ngoal (2 subgoals):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel\n 2. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "show \"(\\<Sum>x\\<leftarrow>C. lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) = Leq_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_rel\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    Leq_Rel", "unfolding sum_list_Leq_Rel"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set C.\n       lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)) = Leq_Rel", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)) = Leq_Rel", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)) = Leq_Rel", "assume c: \"c \\<in> set C\""], ["proof (state)\nthis:\n  c \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       lec_rel (lec_of_nsc (f (atom_var x) *R nsc_of_atom x)) = Leq_Rel", "show \"lec_rel (lec_of_nsc (f (atom_var c) *R nsc_of_atom c)) = Leq_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_rel (lec_of_nsc (f (atom_var c) *R nsc_of_atom c)) = Leq_Rel", "using is_leq[rule_format, OF c]"], ["proof (prove)\nusing this:\n  is_leq_ns (f (atom_var c) *R nsc_of_atom c) \\<and>\n  f (atom_var c) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. lec_rel (lec_of_nsc (f (atom_var c) *R nsc_of_atom c)) = Leq_Rel", "by (cases \"f (atom_var c) *R nsc_of_atom c\", auto)"], ["proof (state)\nthis:\n  lec_rel (lec_of_nsc (f (atom_var c) *R nsc_of_atom c)) = Leq_Rel\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C. lec_rel\n                          (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))) =\n  Leq_Rel\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. lec_const\n                            (lec_of_nsc\n                              (f (atom_var x) *R nsc_of_atom x))) =\n    c", "qed (simp add: c_def)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel\n   (negP (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i) - lp_monom 1 x\\<^sub>i)) c\n\ngoal (2 subgoals):\n 1. True \\<Longrightarrow> distinct C\n 2. True \\<Longrightarrow> c < (0::'a)", "show \"c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c < (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. c < (0::'a)", "define scale_const_f :: \"'a atom \\<Rightarrow> 'a\" where\n          \"scale_const_f x = lec_const (lec_of_nsc (f (atom_var x) *R nsc_of_atom x))\" for x"], ["proof (state)\nthis:\n  scale_const_f ?x =\n  lec_const (lec_of_nsc (f (atom_var ?x) *R nsc_of_atom ?x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "obtain d where bl': \"?\\<B>\\<^sub>l s x\\<^sub>i = Some d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        Direction.LB dir s x\\<^sub>i = Some d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 3"], ["proof (prove)\nusing this:\n  dir = Positive \\<or> dir = Negative\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        Direction.LB dir s x\\<^sub>i = Some d \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"?\\<B>\\<^sub>l s x\\<^sub>i\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  Direction.LB dir s x\\<^sub>i = Some d\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"c = (\\<Sum>x\\<leftarrow>map (\\<lambda>x. ?Geq x (the (?\\<B>\\<^sub>l s x))) ?negA. scale_const_f x)\n                     + (\\<Sum>x\\<leftarrow> map (\\<lambda>x. ?Leq x (the (?\\<B>\\<^sub>u s x))) ?posA. scale_const_f x) \n                   - nega d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c =\n    sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) +\n    sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) -\n    nega d", "unfolding c_def C_def f_def scale_const_f_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.GE dir x\n                                 (the (Direction.LB dir s x)))\n                         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n                        map (\\<lambda>x.\n                                Direction.LE dir x\n                                 (the (Direction.UB dir s x)))\n                         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n                        [Direction.GE dir x\\<^sub>i\n                          (the (Direction.LB dir s\n                                 x\\<^sub>i))]. lec_const\n          (lec_of_nsc\n            ((if atom_var x = x\\<^sub>i then neg (- 1)\n              else neg (A (atom_var x))) *R\n             nsc_of_atom x))) =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.GE dir x\n                                 (the (Direction.LB dir s x)))\n                         (filter (\\<lambda>x. A x < 0)\n                           XL\\<^sub>j). lec_const\n   (lec_of_nsc\n     ((if atom_var x = x\\<^sub>i then neg (- 1)\n       else neg (A (atom_var x))) *R\n      nsc_of_atom x))) +\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.LE dir x\n                                 (the (Direction.UB dir s x)))\n                         (filter (\\<lambda>x. \\<not> A x < 0)\n                           XL\\<^sub>j). lec_const\n   (lec_of_nsc\n     ((if atom_var x = x\\<^sub>i then neg (- 1)\n       else neg (A (atom_var x))) *R\n      nsc_of_atom x))) -\n    nega d", "using dirn rhs_eval_xi bl'"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n  Direction.LB dir s x\\<^sub>i = Some d\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.GE dir x\n                                 (the (Direction.LB dir s x)))\n                         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n                        map (\\<lambda>x.\n                                Direction.LE dir x\n                                 (the (Direction.UB dir s x)))\n                         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n                        [Direction.GE dir x\\<^sub>i\n                          (the (Direction.LB dir s\n                                 x\\<^sub>i))]. lec_const\n          (lec_of_nsc\n            ((if atom_var x = x\\<^sub>i then neg (- 1)\n              else neg (A (atom_var x))) *R\n             nsc_of_atom x))) =\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.GE dir x\n                                 (the (Direction.LB dir s x)))\n                         (filter (\\<lambda>x. A x < 0)\n                           XL\\<^sub>j). lec_const\n   (lec_of_nsc\n     ((if atom_var x = x\\<^sub>i then neg (- 1)\n       else neg (A (atom_var x))) *R\n      nsc_of_atom x))) +\n    (\\<Sum>x\\<leftarrow>map (\\<lambda>x.\n                                Direction.LE dir x\n                                 (the (Direction.UB dir s x)))\n                         (filter (\\<lambda>x. \\<not> A x < 0)\n                           XL\\<^sub>j). lec_const\n   (lec_of_nsc\n     ((if atom_var x = x\\<^sub>i then neg (- 1)\n       else neg (A (atom_var x))) *R\n      nsc_of_atom x))) -\n    nega d", "by auto"], ["proof (state)\nthis:\n  c =\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) +\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) -\n  nega d\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  c =\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) +\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) -\n  nega d\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"(\\<Sum>x\\<leftarrow>map (\\<lambda>x. ?Geq x (the (?\\<B>\\<^sub>l s x))) ?negA. scale_const_f x) =\n              (\\<Sum>x\\<leftarrow> ?negA. nega (A x *R the (?\\<B>\\<^sub>l s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.LB dir s x)))", "using xi_Xj dirn"], ["proof (prove)\nusing this:\n  x\\<^sub>i \\<notin> X\\<^sub>j\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n         (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.LB dir s x)))", "by (subst map_cong) (auto simp add: f_def scale_const_f_def)"], ["proof (state)\nthis:\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega (A x *R the (Direction.LB dir s x)))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega (A x *R the (Direction.LB dir s x)))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"\\<dots> = (\\<Sum>x\\<leftarrow>?negA. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.LB dir s x))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x))", "using 0"], ["proof (prove)\nusing this:\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.LB dir s x))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x))", "by (subst map_cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R the (Direction.LB dir s x))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R the (Direction.LB dir s x))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"(\\<Sum>x\\<leftarrow>map (\\<lambda>x. ?Leq x (the (?\\<B>\\<^sub>u s x))) ?posA. scale_const_f x) =\n              (\\<Sum>x\\<leftarrow> ?posA. nega (A x *R the (?\\<B>\\<^sub>u s x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.UB dir s x)))", "using xi_Xj dirn"], ["proof (prove)\nusing this:\n  x\\<^sub>i \\<notin> X\\<^sub>j\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. sum_list\n     (map scale_const_f\n       (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n         (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.UB dir s x)))", "by (subst map_cong) (auto simp add: f_def scale_const_f_def)"], ["proof (state)\nthis:\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R the (Direction.UB dir s x)))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  sum_list\n   (map scale_const_f\n     (map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R the (Direction.UB dir s x)))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"\\<dots> = (\\<Sum>x\\<leftarrow> ?posA. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.UB dir s x))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x))", "using 0"], ["proof (prove)\nusing this:\n  ?x2 \\<in> X\\<^sub>j \\<Longrightarrow>\n  (if A ?x2 < 0\n   then Direction.LB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)\n   else Direction.UB dir s ?x2 = Some (\\<langle>\\<V> s\\<rangle> ?x2)) \\<and>\n  A ?x2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R the (Direction.UB dir s x))) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x))", "by (subst map_cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R the (Direction.UB dir s x))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R the (Direction.UB dir s x))) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"(\\<Sum>x\\<leftarrow>?negA. nega (A x *R \\<langle>\\<V> s\\<rangle> x)) + (\\<Sum>x\\<leftarrow>?posA. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n             = (\\<Sum>x\\<leftarrow>?negA @ ?posA. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x)) +\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x)) =\n    (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                        filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x))", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) +\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                      filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) +\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                      filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"\\<dots> = (\\<Sum>x\\<in> X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                        filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x)) =\n    (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))", "using XL\\<^sub>j_distinct"], ["proof (prove)\nusing this:\n  distinct XL\\<^sub>j\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                        filter (\\<lambda>x. \\<not> A x < 0)\n                         XL\\<^sub>j. nega\n(A x *R \\<langle>\\<V> s\\<rangle> x)) =\n    (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))", "by (subst sum_list_distinct_conv_sum_set) (auto intro!: sum.cong)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                      filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>filter (\\<lambda>x. A x < 0) XL\\<^sub>j @\n                      filter (\\<lambda>x. \\<not> A x < 0)\n                       XL\\<^sub>j. nega\n                                    (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x))\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"\\<dots> = nega (\\<Sum>x\\<in> X\\<^sub>j. (A x *R \\<langle>\\<V> s\\<rangle> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n    nega (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x)", "using dirn"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n    nega (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x)", "by (auto simp: sum_negf)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  nega (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x)\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X\\<^sub>j. nega (A x *R \\<langle>\\<V> s\\<rangle> x)) =\n  nega (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x)\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"(\\<Sum>x\\<in> X\\<^sub>j. (A x *R \\<langle>\\<V> s\\<rangle> x)) = ((rhs ?eq) \\<lbrace>\\<langle>\\<V> s\\<rangle>\\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x) =\n    rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace>", "unfolding A_def X\\<^sub>j_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>rvars_eq (eq_for_lvar (\\<T> s) x\\<^sub>i).\n       coeff (rhs (eq_for_lvar (\\<T> s) x\\<^sub>i)) x *R\n       \\<langle>\\<V> s\\<rangle> x) =\n    rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace>", "by (subst linear_poly_sum) (auto simp add: sum_negf)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x) =\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X\\<^sub>j. A x *R \\<langle>\\<V> s\\<rangle> x) =\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace>\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"\\<dots> = \\<langle>\\<V> s\\<rangle> x\\<^sub>i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "using rhs_eval_xi"], ["proof (prove)\nusing this:\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n\ngoal (1 subgoal):\n 1. rhs (eq_for_lvar (\\<T> s)\n          x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n    \\<langle>\\<V> s\\<rangle> x\\<^sub>i", "by blast"], ["proof (state)\nthis:\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "also"], ["proof (state)\nthis:\n  rhs (eq_for_lvar (\\<T> s)\n        x\\<^sub>i) \\<lbrace> \\<langle>\\<V> s\\<rangle> \\<rbrace> =\n  \\<langle>\\<V> s\\<rangle> x\\<^sub>i\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "have \"nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)", "have \"?lt (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d", "using dirn 3(2-) bl'"], ["proof (prove)\nusing this:\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n  \\<nabla> s\n  \\<triangle> (\\<T> s)\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<diamond> s\n  \\<not> \\<U> s\n  min_lvar_not_in_bounds s = Some x\\<^sub>i\n  \\<lhd>\\<^sub>l\\<^sub>b (Direction.lt dir)\n   (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) (Direction.LB dir s x\\<^sub>i)\n  min_rvar_incdec dir s x\\<^sub>i = Inl I\n  Direction.LB dir s x\\<^sub>i = Some d\n\ngoal (1 subgoal):\n 1. Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d", "by (elim disjE, auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d\n\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d\n\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)", "using dirn"], ["proof (prove)\nusing this:\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)", "unfolding minus_lt[symmetric]"], ["proof (prove)\nusing this:\n  Direction.lt dir (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) d\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) < nega d", "by auto"], ["proof (state)\nthis:\n  nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  nega (\\<langle>\\<V> s\\<rangle> x\\<^sub>i) - nega d < (0::'a)\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "finally"], ["proof (chain)\npicking this:\n  c < (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. c < (0::'a)", "."], ["proof (state)\nthis:\n  c < (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. True \\<Longrightarrow> distinct C", "show \"distinct C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct C", "unfolding C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n      map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n      [Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))])", "using XL\\<^sub>j_distinct xi_Xj dirn"], ["proof (prove)\nusing this:\n  distinct XL\\<^sub>j\n  x\\<^sub>i \\<notin> X\\<^sub>j\n  dir = Positive \\<and>\n  neg = (\\<lambda>x. x) \\<and>\n  negP = (\\<lambda>x. x) \\<and> nega = (\\<lambda>x. x) \\<or>\n  dir = Negative \\<and>\n  neg = uminus \\<and> negP = uminus \\<and> nega = uminus\n\ngoal (1 subgoal):\n 1. distinct\n     (map (\\<lambda>x. Direction.GE dir x (the (Direction.LB dir s x)))\n       (filter (\\<lambda>x. A x < 0) XL\\<^sub>j) @\n      map (\\<lambda>x. Direction.LE dir x (the (Direction.UB dir s x)))\n       (filter (\\<lambda>x. \\<not> A x < 0) XL\\<^sub>j) @\n      [Direction.GE dir x\\<^sub>i (the (Direction.LB dir s x\\<^sub>i))])", "by (auto simp add: inj_on_def distinct_map)"], ["proof (state)\nthis:\n  distinct C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<U> (set_unsat I s) \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A (set_unsat I s) \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> (set_unsat I s) \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))\n\ngoal (2 subgoals):\n 1. \\<U> s' \\<Longrightarrow>\n    \\<U> s' \\<longrightarrow>\n    (\\<exists>f p c C.\n        set C \\<subseteq> \\<B>\\<^sub>A s' \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)))\n 2. \\<And>s.\n       \\<lbrakk>\\<nabla> s; \\<triangle> (\\<T> s);\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<diamond> s; \\<not> \\<U> s;\n        min_lvar_not_in_bounds s = None\\<rbrakk>\n       \\<Longrightarrow> \\<U> s \\<longrightarrow>\n                         (\\<exists>f p c C.\n                             set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n                             distinct C \\<and>\n                             (\\<forall>a\\<in>set C.\n                                 is_leq_ns\n                                  (f (atom_var a) *R nsc_of_atom a) \\<and>\n                                 f (atom_var a) \\<noteq> 0) \\<and>\n                             (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n               (f (atom_var a) *R nsc_of_atom a)) =\n                             Le_Constraint Leq_Rel p c \\<and>\n                             c < (0::'a) \\<and>\n                             (\\<forall>v.\n                                 v \\<Turnstile>\\<^sub>t\n                                 \\<T> s \\<longrightarrow>\n                                 p \\<lbrace> v \\<rbrace> = (0::'a)))", "qed (insert U, blast+)"], ["proof (state)\nthis:\n  \\<U> (check s') \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A (check s') \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> (check s') \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "then"], ["proof (chain)\npicking this:\n  \\<U> (check s') \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A (check s') \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> (check s') \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))", "obtain f p c C where Qs: \"?Q s f p c C\""], ["proof (prove)\nusing this:\n  \\<U> (check s') \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A (check s') \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> (check s') \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))\n\ngoal (1 subgoal):\n 1. (\\<And>C f p c.\n        set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using U"], ["proof (prove)\nusing this:\n  \\<U> (check s') \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A (check s') \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> (check s') \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))\n  \\<U> s\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. (\\<And>C f p c.\n        set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding check"], ["proof (prove)\nusing this:\n  \\<U> s \\<longrightarrow>\n  (\\<exists>f p c C.\n      set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n      distinct C \\<and>\n      (\\<forall>a\\<in>set C.\n          is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n          f (atom_var a) \\<noteq> 0) \\<and>\n      (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::'a)))\n  \\<U> s\n  \\<not> \\<U> s'\n\ngoal (1 subgoal):\n 1. (\\<And>C f p c.\n        set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n        distinct C \\<and>\n        (\\<forall>a\\<in>set C.\n            is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n            f (atom_var a) \\<noteq> 0) \\<and>\n        (\\<Sum>a\\<leftarrow>C. lec_of_nsc\n                                (f (atom_var a) *R nsc_of_atom a)) =\n        Le_Constraint Leq_Rel p c \\<and>\n        c < (0::'a) \\<and>\n        (\\<forall>v.\n            v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n            p \\<lbrace> v \\<rbrace> = (0::'a)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n  distinct C \\<and>\n  (\\<forall>a\\<in>set C.\n      is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n      f (atom_var a) \\<noteq> 0) \\<and>\n  (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c \\<and>\n  c < (0::'a) \\<and>\n  (\\<forall>v.\n      v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n      p \\<lbrace> v \\<rbrace> = (0::'a))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "from index[folded check_tableau_index_valid[OF U(2) inv(3,4,2,1)]] check"], ["proof (chain)\npicking this:\n  index_valid as (check s')\n  check s' = s", "have index: \"index_valid as s\""], ["proof (prove)\nusing this:\n  index_valid as (check s')\n  check s' = s\n\ngoal (1 subgoal):\n 1. index_valid as s", "by auto"], ["proof (state)\nthis:\n  index_valid as s\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "from check_tableau_equiv[OF U(2) inv(3,4,2,1), unfolded check]"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s' = ?v \\<Turnstile>\\<^sub>t \\<T> s", "have id: \"v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t \\<T> s'\" for v :: \"'a valuation\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>t \\<T> s' = ?v \\<Turnstile>\\<^sub>t \\<T> s\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>t \\<T> s = v \\<Turnstile>\\<^sub>t \\<T> s'", "by auto"], ["proof (state)\nthis:\n  ?v2 \\<Turnstile>\\<^sub>t \\<T> s = ?v2 \\<Turnstile>\\<^sub>t \\<T> s'\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "let ?C = \"map (\\<lambda> a. (f (atom_var a), a)) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "have \"set C \\<subseteq> \\<B>\\<^sub>A s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set C \\<subseteq> \\<B>\\<^sub>A s", "using Qs"], ["proof (prove)\nusing this:\n  set C \\<subseteq> \\<B>\\<^sub>A s \\<and>\n  distinct C \\<and>\n  (\\<forall>a\\<in>set C.\n      is_leq_ns (f (atom_var a) *R nsc_of_atom a) \\<and>\n      f (atom_var a) \\<noteq> 0) \\<and>\n  (\\<Sum>a\\<leftarrow>C. lec_of_nsc (f (atom_var a) *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c \\<and>\n  c < (0::'a) \\<and>\n  (\\<forall>v.\n      v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n      p \\<lbrace> v \\<rbrace> = (0::'a))\n\ngoal (1 subgoal):\n 1. set C \\<subseteq> \\<B>\\<^sub>A s", "by blast"], ["proof (state)\nthis:\n  set C \\<subseteq> \\<B>\\<^sub>A s\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "also"], ["proof (state)\nthis:\n  set C \\<subseteq> \\<B>\\<^sub>A s\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "have \"\\<dots> \\<subseteq> snd ` as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<B>\\<^sub>A s \\<subseteq> snd ` as", "using index"], ["proof (prove)\nusing this:\n  index_valid as s\n\ngoal (1 subgoal):\n 1. \\<B>\\<^sub>A s \\<subseteq> snd ` as", "unfolding bound_atoms_def index_valid_def set_of_map_def boundsl_def boundsu_def o_def"], ["proof (prove)\nusing this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n\ngoal (1 subgoal):\n 1. (\\<lambda>(x, y). Geq x y) `\n    {(k, v) |k v.\n     map_option snd (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) k) =\n     Some v} \\<union>\n    (\\<lambda>(x, y). Leq x y) `\n    {(k, v) |k v.\n     map_option snd (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) k) = Some v}\n    \\<subseteq> snd ` as", "by force"], ["proof (state)\nthis:\n  \\<B>\\<^sub>A s \\<subseteq> snd ` as\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "finally"], ["proof (chain)\npicking this:\n  set C \\<subseteq> snd ` as", "have sub: \"snd ` set ?C \\<subseteq> snd ` as\""], ["proof (prove)\nusing this:\n  set C \\<subseteq> snd ` as\n\ngoal (1 subgoal):\n 1. snd ` set (map (\\<lambda>a. (f (atom_var a), a)) C) \\<subseteq> snd ` as", "by force"], ["proof (state)\nthis:\n  snd ` set (map (\\<lambda>a. (f (atom_var a), a)) C) \\<subseteq> snd ` as\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C", "unfolding farkas_coefficients_atoms_tableau_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C p c.\n       (\\<forall>(r, a)\\<in>set C.\n           a \\<in> snd ` as \\<and>\n           is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n       Le_Constraint Leq_Rel p c \\<and>\n       c < (0::'a) \\<and>\n       (\\<forall>v.\n           v \\<Turnstile>\\<^sub>t \\<T> s' \\<longrightarrow>\n           p \\<lbrace> v \\<rbrace> = (0::'a))", "by (intro exI[of _ p] exI[of _ c] exI[of _ ?C] conjI,\n        insert Qs[unfolded id] sub, (force simp: o_def)+)"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s') C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Next, we show that a conflict found by the assert-bound function also gives rise to\n  Farkas coefficients.\\<close>"], ["", "context Update\nbegin"], ["", "lemma farkas_assert_bound: assumes inv: \"\\<not> \\<U> s\" \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\" \"\\<triangle> (\\<T> s)\" \"\\<nabla> s\" \"\\<diamond> s\"\n  and index: \"index_valid as s\" \n  and U: \"\\<U> (assert_bound ia s)\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` (insert ia as)) (\\<T> s) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "obtain i a where ia[simp]: \"ia = (i,a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i a. ia = (i, a) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  ia = (i, a)\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "let ?A = \"snd ` insert ia as\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "have \"\\<exists> x c d. Leq x c \\<in> ?A \\<and> Geq x d \\<in> ?A \\<and> c < d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x c d.\n       Leq x c \\<in> snd ` insert ia as \\<and>\n       Geq x d \\<in> snd ` insert ia as \\<and> c < d", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "case (Geq x d)"], ["proof (state)\nthis:\n  a = Geq x d\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "let ?s = \"update\\<B>\\<I> (Direction.UBI_upd (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n                        i x d s\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have id: \"\\<U> ?s = \\<U> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<U>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s) =\n    \\<U> s", "by auto"], ["proof (state)\nthis:\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s) =\n  \\<U> s\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have norm: \"\\<triangle> (\\<T> ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<triangle>\n     (\\<T>\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n             \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n         i x d s))", "using inv"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n\ngoal (1 subgoal):\n 1. \\<triangle>\n     (\\<T>\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n             \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n         i x d s))", "by auto"], ["proof (state)\nthis:\n  \\<triangle>\n   (\\<T>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s))\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have val: \"\\<nabla> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)", "using inv(4)"], ["proof (prove)\nusing this:\n  \\<nabla> s\n\ngoal (1 subgoal):\n 1. \\<nabla>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)", "unfolding tableau_valuated_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>tvars (\\<T> s). Mapping.lookup (\\<V> s) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>tvars\n                     (\\<T>\n                       (update\\<B>\\<I>\n                         (Direction.UBI_upd\n                           (Direction (\\<lambda>x y. y < x)\n                             \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>i\\<^sub>l\n                             \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n                             \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq\n                             Leq (\\<le>)))\n                         i x d s)).\n       Mapping.lookup\n        (\\<V>\n          (update\\<B>\\<I>\n            (Direction.UBI_upd\n              (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n                \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n                \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n            i x d s))\n        xa \\<noteq>\n       None", "by simp"], ["proof (state)\nthis:\n  \\<nabla>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have idd: \"x \\<notin> lvars (\\<T> ?s) \\<Longrightarrow> \\<U> (update x d ?s) = \\<U> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> lvars\n                (\\<T>\n                  (update\\<B>\\<I>\n                    (Direction.UBI_upd\n                      (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n                        \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l\n                        \\<I>\\<^sub>u \\<I>\\<^sub>l\n                        \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n                    i x d s)) \\<Longrightarrow>\n    \\<U>\n     (update x d\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n             \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n         i x d s)) =\n    \\<U>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)", "by (rule update_unsat_id[OF norm val])"], ["proof (state)\nthis:\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l\n                      \\<I>\\<^sub>u \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update\n                      Geq Leq (\\<le>)))\n                  i x d s)) \\<Longrightarrow>\n  \\<U>\n   (update x d\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from U[unfolded ia Geq] inv(1) id idd"], ["proof (chain)\npicking this:\n  \\<U> (assert_bound (i, Geq x d) s)\n  \\<not> \\<U> s\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s) =\n  \\<U> s\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l\n                      \\<I>\\<^sub>u \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update\n                      Geq Leq (\\<le>)))\n                  i x d s)) \\<Longrightarrow>\n  \\<U>\n   (update x d\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s)", "have \"\\<lhd>\\<^sub>l\\<^sub>b (\\<lambda>x y. y < x) d (\\<B>\\<^sub>u s x)\""], ["proof (prove)\nusing this:\n  \\<U> (assert_bound (i, Geq x d) s)\n  \\<not> \\<U> s\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s) =\n  \\<U> s\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l\n                      \\<I>\\<^sub>u \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update\n                      Geq Leq (\\<le>)))\n                  i x d s)) \\<Longrightarrow>\n  \\<U>\n   (update x d\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n           \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n       i x d s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (\\<lambda>x y. y < x) \\<B>\\<^sub>i\\<^sub>u\n         \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>u \\<B>\\<^sub>l \\<I>\\<^sub>u\n         \\<I>\\<^sub>l \\<B>\\<^sub>i\\<^sub>l_update Geq Leq (\\<le>)))\n     i x d s)\n\ngoal (1 subgoal):\n 1. \\<lhd>\\<^sub>l\\<^sub>b (\\<lambda>x y. y < x) d (\\<B>\\<^sub>u s x)", "by (auto split: if_splits simp: Let_def)"], ["proof (state)\nthis:\n  \\<lhd>\\<^sub>l\\<^sub>b (\\<lambda>x y. y < x) d (\\<B>\\<^sub>u s x)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "then"], ["proof (chain)\npicking this:\n  \\<lhd>\\<^sub>l\\<^sub>b (\\<lambda>x y. y < x) d (\\<B>\\<^sub>u s x)", "obtain c where Bu: \"\\<B>\\<^sub>u s x = Some c\" and lt: \"c < d\""], ["proof (prove)\nusing this:\n  \\<lhd>\\<^sub>l\\<^sub>b (\\<lambda>x y. y < x) d (\\<B>\\<^sub>u s x)\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>\\<B>\\<^sub>u s x = Some c; c < d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"\\<B>\\<^sub>u s x\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  \\<B>\\<^sub>u s x = Some c\n  c < d\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from Bu"], ["proof (chain)\npicking this:\n  \\<B>\\<^sub>u s x = Some c", "obtain j where \"Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x = Some (j,c)\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>u s x = Some c\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n        Some (j, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding boundsu_def"], ["proof (prove)\nusing this:\n  (map_option snd \\<circ> Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s)) x =\n  Some c\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n        Some (j, c) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x = Some (j, c)\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "with index[unfolded index_valid_def]"], ["proof (chain)\npicking this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x = Some (j, c)", "have \"(j, Leq x c) \\<in> as\""], ["proof (prove)\nusing this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x = Some (j, c)\n\ngoal (1 subgoal):\n 1. (j, Leq x c) \\<in> as", "by auto"], ["proof (state)\nthis:\n  (j, Leq x c) \\<in> as\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "hence xc: \"Leq x c \\<in> ?A\""], ["proof (prove)\nusing this:\n  (j, Leq x c) \\<in> as\n\ngoal (1 subgoal):\n 1. Leq x c \\<in> snd ` insert ia as", "by force"], ["proof (state)\nthis:\n  Leq x c \\<in> snd ` insert ia as\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have xd: \"Geq x d \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Geq x d \\<in> snd ` insert ia as", "unfolding ia Geq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Geq x d \\<in> snd ` insert (i, Geq x d) as", "by force"], ["proof (state)\nthis:\n  Geq x d \\<in> snd ` insert ia as\n\ngoal (2 subgoals):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d\n 2. \\<And>x21 x22.\n       a = Geq x21 x22 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from xc xd lt"], ["proof (chain)\npicking this:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n  c < d", "show ?thesis"], ["proof (prove)\nusing this:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n  c < d\n\ngoal (1 subgoal):\n 1. \\<exists>x c d.\n       Leq x c \\<in> snd ` insert ia as \\<and>\n       Geq x d \\<in> snd ` insert ia as \\<and> c < d", "by auto"], ["proof (state)\nthis:\n  \\<exists>x c d.\n     Leq x c \\<in> snd ` insert ia as \\<and>\n     Geq x d \\<in> snd ` insert ia as \\<and> c < d\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "case (Leq x c)"], ["proof (state)\nthis:\n  a = Leq x c\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "let ?s = \"update\\<B>\\<I> (Direction.UBI_upd (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<ge>))) i x c s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have id: \"\\<U> ?s = \\<U> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<U>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s) =\n    \\<U> s", "by auto"], ["proof (state)\nthis:\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s) =\n  \\<U> s\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have norm: \"\\<triangle> (\\<T> ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<triangle>\n     (\\<T>\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n         i x c s))", "using inv"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n\ngoal (1 subgoal):\n 1. \\<triangle>\n     (\\<T>\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n         i x c s))", "by auto"], ["proof (state)\nthis:\n  \\<triangle>\n   (\\<T>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s))\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have val: \"\\<nabla> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nabla>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)", "using inv(4)"], ["proof (prove)\nusing this:\n  \\<nabla> s\n\ngoal (1 subgoal):\n 1. \\<nabla>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)", "unfolding tableau_valuated_def"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>tvars (\\<T> s). Mapping.lookup (\\<V> s) x \\<noteq> None\n\ngoal (1 subgoal):\n 1. \\<forall>xa\\<in>tvars\n                     (\\<T>\n                       (update\\<B>\\<I>\n                         (Direction.UBI_upd\n                           (Direction (<) \\<B>\\<^sub>i\\<^sub>l\n                             \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l \\<B>\\<^sub>u\n                             \\<I>\\<^sub>l \\<I>\\<^sub>u\n                             \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                             (\\<lambda>x y. y \\<le> x)))\n                         i x c s)).\n       Mapping.lookup\n        (\\<V>\n          (update\\<B>\\<I>\n            (Direction.UBI_upd\n              (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n                \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n                \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                (\\<lambda>x y. y \\<le> x)))\n            i x c s))\n        xa \\<noteq>\n       None", "by simp"], ["proof (state)\nthis:\n  \\<nabla>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s)\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have idd: \"x \\<notin> lvars (\\<T> ?s) \\<Longrightarrow> \\<U> (update x c ?s) = \\<U> ?s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> lvars\n                (\\<T>\n                  (update\\<B>\\<I>\n                    (Direction.UBI_upd\n                      (Direction (<) \\<B>\\<^sub>i\\<^sub>l\n                        \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l \\<B>\\<^sub>u\n                        \\<I>\\<^sub>l \\<I>\\<^sub>u\n                        \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                        (\\<lambda>x y. y \\<le> x)))\n                    i x c s)) \\<Longrightarrow>\n    \\<U>\n     (update x c\n       (update\\<B>\\<I>\n         (Direction.UBI_upd\n           (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n             \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n             \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n         i x c s)) =\n    \\<U>\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)", "by (rule update_unsat_id[OF norm val])"], ["proof (state)\nthis:\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                      (\\<lambda>x y. y \\<le> x)))\n                  i x c s)) \\<Longrightarrow>\n  \\<U>\n   (update x c\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s)\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from U[unfolded ia Leq] inv(1) id idd"], ["proof (chain)\npicking this:\n  \\<U> (assert_bound (i, Leq x c) s)\n  \\<not> \\<U> s\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s) =\n  \\<U> s\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                      (\\<lambda>x y. y \\<le> x)))\n                  i x c s)) \\<Longrightarrow>\n  \\<U>\n   (update x c\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s)", "have \"\\<lhd>\\<^sub>l\\<^sub>b (<) c (\\<B>\\<^sub>l s x)\""], ["proof (prove)\nusing this:\n  \\<U> (assert_bound (i, Leq x c) s)\n  \\<not> \\<U> s\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s) =\n  \\<U> s\n  x \\<notin> lvars\n              (\\<T>\n                (update\\<B>\\<I>\n                  (Direction.UBI_upd\n                    (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n                      \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n                      \\<B>\\<^sub>i\\<^sub>u_update Leq Geq\n                      (\\<lambda>x y. y \\<le> x)))\n                  i x c s)) \\<Longrightarrow>\n  \\<U>\n   (update x c\n     (update\\<B>\\<I>\n       (Direction.UBI_upd\n         (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u\n           \\<B>\\<^sub>l \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u\n           \\<B>\\<^sub>i\\<^sub>u_update Leq Geq (\\<lambda>x y. y \\<le> x)))\n       i x c s)) =\n  \\<U>\n   (update\\<B>\\<I>\n     (Direction.UBI_upd\n       (Direction (<) \\<B>\\<^sub>i\\<^sub>l \\<B>\\<^sub>i\\<^sub>u \\<B>\\<^sub>l\n         \\<B>\\<^sub>u \\<I>\\<^sub>l \\<I>\\<^sub>u \\<B>\\<^sub>i\\<^sub>u_update\n         Leq Geq (\\<lambda>x y. y \\<le> x)))\n     i x c s)\n\ngoal (1 subgoal):\n 1. \\<lhd>\\<^sub>l\\<^sub>b (<) c (\\<B>\\<^sub>l s x)", "by (auto split: if_splits simp: Let_def)"], ["proof (state)\nthis:\n  \\<lhd>\\<^sub>l\\<^sub>b (<) c (\\<B>\\<^sub>l s x)\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "then"], ["proof (chain)\npicking this:\n  \\<lhd>\\<^sub>l\\<^sub>b (<) c (\\<B>\\<^sub>l s x)", "obtain d where Bl: \"\\<B>\\<^sub>l s x = Some d\" and lt: \"c < d\""], ["proof (prove)\nusing this:\n  \\<lhd>\\<^sub>l\\<^sub>b (<) c (\\<B>\\<^sub>l s x)\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<B>\\<^sub>l s x = Some d; c < d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases \"\\<B>\\<^sub>l s x\", auto simp: bound_compare_defs)"], ["proof (state)\nthis:\n  \\<B>\\<^sub>l s x = Some d\n  c < d\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from Bl"], ["proof (chain)\npicking this:\n  \\<B>\\<^sub>l s x = Some d", "obtain j where \"Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x = Some (j,d)\""], ["proof (prove)\nusing this:\n  \\<B>\\<^sub>l s x = Some d\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n        Some (j, d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding boundsl_def"], ["proof (prove)\nusing this:\n  (map_option snd \\<circ> Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s)) x =\n  Some d\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n        Some (j, d) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x = Some (j, d)\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "with index[unfolded index_valid_def]"], ["proof (chain)\npicking this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x = Some (j, d)", "have \"(j, Geq x d) \\<in> as\""], ["proof (prove)\nusing this:\n  \\<forall>x b i.\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Geq x b) \\<in> as) \\<and>\n     (Mapping.lookup (\\<B>\\<^sub>i\\<^sub>u s) x =\n      Some (i, b) \\<longrightarrow>\n      (i, Leq x b) \\<in> as)\n  Mapping.lookup (\\<B>\\<^sub>i\\<^sub>l s) x = Some (j, d)\n\ngoal (1 subgoal):\n 1. (j, Geq x d) \\<in> as", "by auto"], ["proof (state)\nthis:\n  (j, Geq x d) \\<in> as\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "hence xd: \"Geq x d \\<in> ?A\""], ["proof (prove)\nusing this:\n  (j, Geq x d) \\<in> as\n\ngoal (1 subgoal):\n 1. Geq x d \\<in> snd ` insert ia as", "by force"], ["proof (state)\nthis:\n  Geq x d \\<in> snd ` insert ia as\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "have xc: \"Leq x c \\<in> ?A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Leq x c \\<in> snd ` insert ia as", "unfolding ia Leq"], ["proof (prove)\ngoal (1 subgoal):\n 1. Leq x c \\<in> snd ` insert (i, Leq x c) as", "by force"], ["proof (state)\nthis:\n  Leq x c \\<in> snd ` insert ia as\n\ngoal (1 subgoal):\n 1. \\<And>x11 x12.\n       a = Leq x11 x12 \\<Longrightarrow>\n       \\<exists>x c d.\n          Leq x c \\<in> snd ` insert ia as \\<and>\n          Geq x d \\<in> snd ` insert ia as \\<and> c < d", "from xc xd lt"], ["proof (chain)\npicking this:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n  c < d", "show ?thesis"], ["proof (prove)\nusing this:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n  c < d\n\ngoal (1 subgoal):\n 1. \\<exists>x c d.\n       Leq x c \\<in> snd ` insert ia as \\<and>\n       Geq x d \\<in> snd ` insert ia as \\<and> c < d", "by auto"], ["proof (state)\nthis:\n  \\<exists>x c d.\n     Leq x c \\<in> snd ` insert ia as \\<and>\n     Geq x d \\<in> snd ` insert ia as \\<and> c < d\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x c d.\n     Leq x c \\<in> snd ` insert ia as \\<and>\n     Geq x d \\<in> snd ` insert ia as \\<and> c < d\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "then"], ["proof (chain)\npicking this:\n  \\<exists>x c d.\n     Leq x c \\<in> snd ` insert ia as \\<and>\n     Geq x d \\<in> snd ` insert ia as \\<and> c < d", "obtain x c d where c: \"Leq x c \\<in> ?A\" and d: \"Geq x d \\<in> ?A\" and cd: \"c < d\""], ["proof (prove)\nusing this:\n  \\<exists>x c d.\n     Leq x c \\<in> snd ` insert ia as \\<and>\n     Geq x d \\<in> snd ` insert ia as \\<and> c < d\n\ngoal (1 subgoal):\n 1. (\\<And>x c d.\n        \\<lbrakk>Leq x c \\<in> snd ` insert ia as;\n         Geq x d \\<in> snd ` insert ia as; c < d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n  c < d\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C", "unfolding farkas_coefficients_atoms_tableau_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C p c.\n       (\\<forall>(r, a)\\<in>set C.\n           a \\<in> snd ` insert ia as \\<and>\n           is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n       Le_Constraint Leq_Rel p c \\<and>\n       c < (0::'a) \\<and>\n       (\\<forall>v.\n           v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n           p \\<lbrace> v \\<rbrace> = (0::'a))", "proof (intro exI conjI allI)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>(r, a)\\<in>set ?C.\n       a \\<in> snd ` insert ia as \\<and>\n       is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n 2. (\\<Sum>(r, a)\\<leftarrow>?C. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel ?p1 ?c2\n 3. ?c2 < (0::'a)\n 4. \\<And>v.\n       v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n       ?p1 \\<lbrace> v \\<rbrace> = (0::'a)", "let ?C = \"[(-1, Geq x d), (1,Leq x c)]\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<forall>(r, a)\\<in>set ?C.\n       a \\<in> snd ` insert ia as \\<and>\n       is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n 2. (\\<Sum>(r, a)\\<leftarrow>?C. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel ?p1 ?c2\n 3. ?c2 < (0::'a)\n 4. \\<And>v.\n       v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n       ?p1 \\<lbrace> v \\<rbrace> = (0::'a)", "show \"\\<forall>(r,a)\\<in>set ?C. a \\<in> ?A \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(r, a)\\<in>set [(- 1, Geq x d), (1, Leq x c)].\n       a \\<in> snd ` insert ia as \\<and>\n       is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0", "using c d"], ["proof (prove)\nusing this:\n  Leq x c \\<in> snd ` insert ia as\n  Geq x d \\<in> snd ` insert ia as\n\ngoal (1 subgoal):\n 1. \\<forall>(r, a)\\<in>set [(- 1, Geq x d), (1, Leq x c)].\n       a \\<in> snd ` insert ia as \\<and>\n       is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>(r, a)\\<in>set [(- 1, Geq x d), (1, Leq x c)].\n     a \\<in> snd ` insert ia as \\<and>\n     is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n\ngoal (3 subgoals):\n 1. (\\<Sum>(r,\n        a)\\<leftarrow>[(- 1, Geq x d),\n                       (1, Leq x c)]. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel ?p1 ?c2\n 2. ?c2 < (0::'a)\n 3. \\<And>v.\n       v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n       ?p1 \\<lbrace> v \\<rbrace> = (0::'a)", "show \"c - d < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c - d < (0::'a)", "using cd"], ["proof (prove)\nusing this:\n  c < d\n\ngoal (1 subgoal):\n 1. c - d < (0::'a)", "using minus_lt"], ["proof (prove)\nusing this:\n  c < d\n  (?a < ?b) = (?a - ?b < (0::?'a))\n\ngoal (1 subgoal):\n 1. c - d < (0::'a)", "by auto"], ["proof (state)\nthis:\n  c - d < (0::'a)\n\ngoal (2 subgoals):\n 1. (\\<Sum>(r,\n        a)\\<leftarrow>[(- 1, Geq x d),\n                       (1, Leq x c)]. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel ?p1 (c - d)\n 2. \\<And>v.\n       v \\<Turnstile>\\<^sub>t \\<T> s \\<longrightarrow>\n       ?p1 \\<lbrace> v \\<rbrace> = (0::'a)", "qed (auto simp: valuate_zero)"], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients_atoms_tableau (snd ` insert ia as) (\\<T> s) C\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>Moreover, we prove that all other steps of the simplex algorithm on layer~4, such as pivoting,\n  asserting bounds without conflict, etc., preserve Farkas coefficients.\\<close>"], ["", "lemma farkas_coefficients_atoms_tableau_mono: assumes \"as \\<subseteq> bs\" \n  shows \"farkas_coefficients_atoms_tableau as t C \\<Longrightarrow> farkas_coefficients_atoms_tableau bs t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    farkas_coefficients_atoms_tableau bs t C", "using assms"], ["proof (prove)\nusing this:\n  as \\<subseteq> bs\n\ngoal (1 subgoal):\n 1. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    farkas_coefficients_atoms_tableau bs t C", "unfolding farkas_coefficients_atoms_tableau_def"], ["proof (prove)\nusing this:\n  as \\<subseteq> bs\n\ngoal (1 subgoal):\n 1. \\<exists>p c.\n       (\\<forall>(r, a)\\<in>set C.\n           a \\<in> as \\<and>\n           is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n       Le_Constraint Leq_Rel p c \\<and>\n       c < (0::'a) \\<and>\n       (\\<forall>v.\n           v \\<Turnstile>\\<^sub>t t \\<longrightarrow>\n           p \\<lbrace> v \\<rbrace> = (0::'a)) \\<Longrightarrow>\n    \\<exists>p c.\n       (\\<forall>(r, a)\\<in>set C.\n           a \\<in> bs \\<and>\n           is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n       Le_Constraint Leq_Rel p c \\<and>\n       c < (0::'a) \\<and>\n       (\\<forall>v.\n           v \\<Turnstile>\\<^sub>t t \\<longrightarrow>\n           p \\<lbrace> v \\<rbrace> = (0::'a))", "by force"], ["", "locale AssertAllState''' = AssertAllState'' init ass_bnd chk + Update update + \n  PivotUpdateMinVars eq_idx_for_lvar min_lvar_not_in_bounds min_rvar_incdec_eq pivot_and_update\n  for init and ass_bnd :: \"'i \\<times> 'a :: lrv atom \\<Rightarrow> _\" and chk :: \"('i, 'a) state \\<Rightarrow> ('i, 'a) state\" and update :: \"nat \\<Rightarrow> 'a :: lrv \\<Rightarrow> ('i, 'a) state \\<Rightarrow> ('i, 'a) state\" \n    and eq_idx_for_lvar :: \"tableau \\<Rightarrow> var \\<Rightarrow> nat\" and\n    min_lvar_not_in_bounds :: \"('i,'a::lrv) state \\<Rightarrow> var option\" and\n    min_rvar_incdec_eq :: \"('i,'a) Direction \\<Rightarrow> ('i,'a) state \\<Rightarrow> eq \\<Rightarrow> 'i list + var\" and\n    pivot_and_update :: \"var \\<Rightarrow> var \\<Rightarrow> 'a \\<Rightarrow> ('i,'a) state \\<Rightarrow> ('i,'a) state\"\n    + assumes ass_bnd: \"ass_bnd = Update.assert_bound update\" and\n    chk: \"chk = PivotUpdateMinVars.check eq_idx_for_lvar min_lvar_not_in_bounds min_rvar_incdec_eq pivot_and_update\""], ["", "context AssertAllState'''\nbegin"], ["", "lemma farkas_assert_bound_loop: assumes \"\\<U> (assert_bound_loop as (init t))\" \n  and norm: \"\\<triangle> t\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` set as) t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "let ?P = \"\\<lambda> as s. \\<U> s \\<longrightarrow> (\\<exists> C. farkas_coefficients_atoms_tableau (snd ` as) (\\<T> s) C)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "let ?s = \"assert_bound_loop as (init t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "have \"\\<not> \\<U> (init t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<U> (init t)", "by (rule init_unsat_flag)"], ["proof (state)\nthis:\n  \\<not> \\<U> (init t)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "have \"\\<T> (assert_bound_loop as (init t)) = t \\<and> \n    (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow> (\\<exists> C. farkas_coefficients_atoms_tableau (snd ` set as) (\\<T> (init t)) C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (assert_bound_loop as (init t)) = t \\<and>\n    (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` set as) (\\<T> (init t))\n          C))", "proof (rule AssertAllState''Induct[OF norm], unfold ass_bnd, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n 2. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 3. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n 2. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 3. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "have \"\\<not> \\<U> (init t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<U> (init t)", "by (rule init_unsat_flag)"], ["proof (state)\nthis:\n  \\<not> \\<U> (init t)\n\ngoal (3 subgoals):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n 2. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 3. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "moreover"], ["proof (state)\nthis:\n  \\<not> \\<U> (init t)\n\ngoal (3 subgoals):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n 2. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 3. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "have \"\\<T> (init t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (init t) = t", "by (rule init_tableau_id)"], ["proof (state)\nthis:\n  \\<T> (init t) = t\n\ngoal (3 subgoals):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n 2. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 3. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> \\<U> (init t)\n  \\<T> (init t) = t", "show ?case"], ["proof (prove)\nusing this:\n  \\<not> \\<U> (init t)\n  \\<T> (init t) = t\n\ngoal (1 subgoal):\n 1. \\<T> (init t) = t \\<and>\n    (\\<U> (init t) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))", "by auto"], ["proof (state)\nthis:\n  \\<T> (init t) = t \\<and>\n  (\\<U> (init t) \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` {}) (\\<T> (init t)) C))\n\ngoal (2 subgoals):\n 1. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 2. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 2. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "case (2 as bs s)"], ["proof (state)\nthis:\n  as \\<subseteq> bs\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t)) C))\n\ngoal (2 subgoals):\n 1. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 2. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "hence \"snd ` as \\<subseteq> snd ` bs\""], ["proof (prove)\nusing this:\n  as \\<subseteq> bs\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t)) C))\n\ngoal (1 subgoal):\n 1. snd ` as \\<subseteq> snd ` bs", "by auto"], ["proof (state)\nthis:\n  snd ` as \\<subseteq> snd ` bs\n\ngoal (2 subgoals):\n 1. \\<And>as bs ta.\n       \\<lbrakk>as \\<subseteq> bs;\n        \\<T> ta = t \\<and>\n        (\\<U> ta \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t))\n              C))\\<rbrakk>\n       \\<Longrightarrow> \\<T> ta = t \\<and>\n                         (\\<U> ta \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau (snd ` bs)\n                               (\\<T> (init t)) C))\n 2. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "from farkas_coefficients_atoms_tableau_mono[OF this] 2(2)"], ["proof (chain)\npicking this:\n  farkas_coefficients_atoms_tableau (snd ` as) ?t ?C \\<Longrightarrow>\n  farkas_coefficients_atoms_tableau (snd ` bs) ?t ?C\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t)) C))", "show ?case"], ["proof (prove)\nusing this:\n  farkas_coefficients_atoms_tableau (snd ` as) ?t ?C \\<Longrightarrow>\n  farkas_coefficients_atoms_tableau (snd ` bs) ?t ?C\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` as) (\\<T> (init t)) C))\n\ngoal (1 subgoal):\n 1. \\<T> s = t \\<and>\n    (\\<U> s \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` bs) (\\<T> (init t)) C))", "by auto"], ["proof (state)\nthis:\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` bs) (\\<T> (init t)) C))\n\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "case (3 s a ats)"], ["proof (state)\nthis:\n  \\<not> \\<U> s\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` set ats) (\\<T> (init t)) C))\n  index_valid (set ats) s\n\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "let ?s = \"assert_bound a s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "have tab: \"\\<T> ?s = \\<T> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (assert_bound a s) = \\<T> s", "unfolding ass_bnd"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (assert_bound a s) = \\<T> s", "by (rule assert_bound_nolhs_tableau_id, insert 3, auto)"], ["proof (state)\nthis:\n  \\<T> (assert_bound a s) = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "have t: \"t = \\<T> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = \\<T> s", "using 3"], ["proof (prove)\nusing this:\n  \\<not> \\<U> s\n  \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s\n  \\<triangle> (\\<T> s)\n  \\<nabla> s\n  \\<diamond> s\n  \\<T> s = t \\<and>\n  (\\<U> s \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` set ats) (\\<T> (init t)) C))\n  index_valid (set ats) s\n\ngoal (1 subgoal):\n 1. t = \\<T> s", "by simp"], ["proof (state)\nthis:\n  t = \\<T> s\n\ngoal (1 subgoal):\n 1. \\<And>s a ats.\n       \\<lbrakk>\\<not> \\<U> s;\n        \\<langle>\\<V> s\\<rangle> \\<Turnstile>\\<^sub>t \\<T> s;\n        \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s s;\n        \\<triangle> (\\<T> s); \\<nabla> s; \\<diamond> s;\n        \\<T> s = t \\<and>\n        (\\<U> s \\<longrightarrow>\n         (\\<exists>C.\n             farkas_coefficients_atoms_tableau (snd ` set ats)\n              (\\<T> (init t)) C));\n        index_valid (set ats) s\\<rbrakk>\n       \\<Longrightarrow> \\<T> (assert_bound a s) = t \\<and>\n                         (\\<U> (assert_bound a s) \\<longrightarrow>\n                          (\\<exists>C.\n                              farkas_coefficients_atoms_tableau\n                               (snd ` insert a (set ats)) (\\<T> (init t))\n                               C))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (assert_bound a s) = t \\<and>\n    (\\<U> (assert_bound a s) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n          (\\<T> (init t)) C))", "unfolding t tab"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> s = \\<T> s \\<and>\n    (\\<U> (assert_bound a s) \\<longrightarrow>\n     (\\<exists>C.\n         farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n          (\\<T> (init (\\<T> s))) C))", "proof (intro conjI impI refl)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<U> (assert_bound a s) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n        (\\<T> (init (\\<T> s))) C", "assume \"\\<U> ?s\""], ["proof (state)\nthis:\n  \\<U> (assert_bound a s)\n\ngoal (1 subgoal):\n 1. \\<U> (assert_bound a s) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n        (\\<T> (init (\\<T> s))) C", "from farkas_assert_bound[OF 3(1,3-6,8) this]"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) (\\<T> s) C", "show \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) (\\<T> (init (\\<T> s))) C\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) (\\<T> s) C\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n        (\\<T> (init (\\<T> s))) C", "unfolding t[symmetric] init_tableau_id"], ["proof (prove)\nusing this:\n  \\<exists>C.\n     farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) t C\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert a (set ats)) t C", "."], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n      (\\<T> (init (\\<T> s))) C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T> (assert_bound a s) = t \\<and>\n  (\\<U> (assert_bound a s) \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` insert a (set ats))\n        (\\<T> (init t)) C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T> (assert_bound_loop as (init t)) = t \\<and>\n  (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` set as) (\\<T> (init t)) C))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound_loop as (init t)) = t \\<and>\n  (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow>\n   (\\<exists>C.\n       farkas_coefficients_atoms_tableau (snd ` set as) (\\<T> (init t)) C))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "unfolding init_tableau_id"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound_loop as (init t)) = t \\<and>\n  (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow>\n   (\\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "using assms"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound_loop as (init t)) = t \\<and>\n  (\\<U> (assert_bound_loop as (init t)) \\<longrightarrow>\n   (\\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C))\n  \\<U> (assert_bound_loop as (init t))\n  \\<triangle> t\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "by blast"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now we get to the main result for layer~4: If the main algorithm returns unsat,\n  then there are Farkas coefficients for the tableau and atom set that were given as\n  input for this layer.\\<close>"], ["", "lemma farkas_assert_all_state: assumes U: \"\\<U> (assert_all_state t as)\" \n  and norm: \"\\<triangle> t\" \nshows \"\\<exists> C. farkas_coefficients_atoms_tableau (snd ` set as) t C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "let ?s = \"assert_bound_loop as (init t)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "proof (cases \"\\<U> (assert_bound_loop as (init t))\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n 2. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "case True"], ["proof (state)\nthis:\n  \\<U> (assert_bound_loop as (init t))\n\ngoal (2 subgoals):\n 1. \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n 2. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "from farkas_assert_bound_loop[OF this norm]"], ["proof (chain)\npicking this:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "by auto"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "case False"], ["proof (state)\nthis:\n  \\<not> \\<U> (assert_bound_loop as (init t))\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "from AssertAllState''_tableau_id[OF norm]"], ["proof (chain)\npicking this:\n  \\<T> (assert_bound_loop ?ats (init t)) = \\<T> (init t)", "have T: \"\\<T> ?s = t\""], ["proof (prove)\nusing this:\n  \\<T> (assert_bound_loop ?ats (init t)) = \\<T> (init t)\n\ngoal (1 subgoal):\n 1. \\<T> (assert_bound_loop as (init t)) = t", "unfolding init_tableau_id"], ["proof (prove)\nusing this:\n  \\<T> (assert_bound_loop ?ats (init t)) = t\n\ngoal (1 subgoal):\n 1. \\<T> (assert_bound_loop as (init t)) = t", "."], ["proof (state)\nthis:\n  \\<T> (assert_bound_loop as (init t)) = t\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "from U"], ["proof (chain)\npicking this:\n  \\<U> (assert_all_state t as)", "have U: \"\\<U> (check ?s)\""], ["proof (prove)\nusing this:\n  \\<U> (assert_all_state t as)\n\ngoal (1 subgoal):\n 1. \\<U> (check (assert_bound_loop as (init t)))", "unfolding chk[symmetric]"], ["proof (prove)\nusing this:\n  \\<U> (assert_all_state t as)\n\ngoal (1 subgoal):\n 1. \\<U> (chk (assert_bound_loop as (init t)))", "by simp"], ["proof (state)\nthis:\n  \\<U> (check (assert_bound_loop as (init t)))\n\ngoal (1 subgoal):\n 1. \\<not> \\<U> (assert_bound_loop as (init t)) \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C", "proof (rule farkas_check[OF refl U False, unfolded T, OF _ norm])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<nabla> (assert_bound_loop as (init t))\n 2. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n     (assert_bound_loop as (init t))\n 3. \\<diamond> (assert_bound_loop as (init t))\n 4. index_valid (set as) (assert_bound_loop as (init t))", "from AssertAllState''_precond[OF norm, unfolded Let_def] False"], ["proof (chain)\npicking this:\n  \\<triangle> (\\<T> (assert_bound_loop ?ats (init t))) \\<and>\n  \\<nabla> (assert_bound_loop ?ats (init t)) \\<and>\n  (\\<not> \\<U> (assert_bound_loop ?ats (init t)) \\<longrightarrow>\n   \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n    (assert_bound_loop ?ats (init t)) \\<and>\n   \\<diamond> (assert_bound_loop ?ats (init t)))\n  \\<not> \\<U> (assert_bound_loop as (init t))", "show \"\\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s ?s\" \"\\<diamond> ?s\" \"\\<nabla> ?s\""], ["proof (prove)\nusing this:\n  \\<triangle> (\\<T> (assert_bound_loop ?ats (init t))) \\<and>\n  \\<nabla> (assert_bound_loop ?ats (init t)) \\<and>\n  (\\<not> \\<U> (assert_bound_loop ?ats (init t)) \\<longrightarrow>\n   \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n    (assert_bound_loop ?ats (init t)) \\<and>\n   \\<diamond> (assert_bound_loop ?ats (init t)))\n  \\<not> \\<U> (assert_bound_loop as (init t))\n\ngoal (1 subgoal):\n 1. \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n     (assert_bound_loop as (init t)) &&&\n    \\<diamond> (assert_bound_loop as (init t)) &&&\n    \\<nabla> (assert_bound_loop as (init t))", "by blast+"], ["proof (state)\nthis:\n  \\<Turnstile>\\<^sub>n\\<^sub>o\\<^sub>l\\<^sub>h\\<^sub>s\n   (assert_bound_loop as (init t))\n  \\<diamond> (assert_bound_loop as (init t))\n  \\<nabla> (assert_bound_loop as (init t))\n\ngoal (1 subgoal):\n 1. index_valid (set as) (assert_bound_loop as (init t))", "from AssertAllState''_index_valid[OF norm]"], ["proof (chain)\npicking this:\n  index_valid (set ?ats) (assert_bound_loop ?ats (init t))", "show \"index_valid (set as) ?s\""], ["proof (prove)\nusing this:\n  index_valid (set ?ats) (assert_bound_loop ?ats (init t))\n\ngoal (1 subgoal):\n 1. index_valid (set as) (assert_bound_loop as (init t))", "."], ["proof (state)\nthis:\n  index_valid (set as) (assert_bound_loop as (init t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau (snd ` set as) t C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Farkas' Lemma on Layer 3\\<close>"], ["", "text \\<open>There is only a small difference between layers 3 and 4, namely that there is no \n  simplex algorithm (@{const assert_all_state}) on layer 3, but just a tableau and atoms.\\<close>"], ["", "text \\<open>Hence, one task is to link the unsatisfiability flag \n  on layer 4 with unsatisfiability of the original tableau and atoms (layer 3). This can\n  be done via the existing soundness results of the simplex algorithm.\n  Moreover, we give an easy proof that the existence of Farkas coefficients for a tableau and \n  set of atoms implies unsatisfiability.\\<close>"], ["", "end"], ["", "lemma farkas_coefficients_atoms_tableau_unsat: \n  assumes \"farkas_coefficients_atoms_tableau as t C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "assume \"\\<exists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\""], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as", "obtain v where *: \"v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<Turnstile>\\<^sub>t t \\<and>\n        v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as", "obtain p c where isleq: \"(\\<forall>(r,a) \\<in> set C. a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0)\"\n    and leq: \"(\\<Sum>(r,a) \\<leftarrow> C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c\" \n    and cltz: \"c < 0\"\n    and p0: \"p\\<lbrace>v\\<rbrace> = 0\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (1 subgoal):\n 1. (\\<And>p c.\n        \\<lbrakk>\\<forall>(r, a)\\<in>set C.\n                    a \\<in> as \\<and>\n                    is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n         Le_Constraint Leq_Rel p c;\n         c < (0::'a); p \\<lbrace> v \\<rbrace> = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms farkas_coefficients_atoms_tableau_def"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n  farkas_coefficients_atoms_tableau as t C\n  farkas_coefficients_atoms_tableau ?as ?t ?C =\n  (\\<exists>p c.\n      (\\<forall>(r, a)\\<in>set ?C.\n          a \\<in> ?as \\<and>\n          is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n      (\\<Sum>(r, a)\\<leftarrow>?C. lec_of_nsc (r *R nsc_of_atom a)) =\n      Le_Constraint Leq_Rel p c \\<and>\n      c < (0::?'a) \\<and>\n      (\\<forall>v.\n          v \\<Turnstile>\\<^sub>t ?t \\<longrightarrow>\n          p \\<lbrace> v \\<rbrace> = (0::?'a)))\n\ngoal (1 subgoal):\n 1. (\\<And>p c.\n        \\<lbrakk>\\<forall>(r, a)\\<in>set C.\n                    a \\<in> as \\<and>\n                    is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n         Le_Constraint Leq_Rel p c;\n         c < (0::'a); p \\<lbrace> v \\<rbrace> = (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(r, a)\\<in>set C.\n     a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < (0::'a)\n  p \\<lbrace> v \\<rbrace> = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "have fa: \"\\<forall>(r,a) \\<in> set C. v \\<Turnstile>\\<^sub>a a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a", "using * isleq leq\n      satisfies_atom_set_def"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n  \\<forall>(r, a)\\<in>set C.\n     a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  ?v \\<Turnstile>\\<^sub>a\\<^sub>s ?as \\<equiv>\n  \\<forall>a\\<in>?as. ?v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a", "by force"], ["proof (state)\nthis:\n  \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "fix r a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "assume a: \"(r,a) \\<in> set C\""], ["proof (state)\nthis:\n  (r, a) \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "from a fa"], ["proof (chain)\npicking this:\n  (r, a) \\<in> set C\n  \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a", "have va: \"v \\<Turnstile>\\<^sub>a a\""], ["proof (prove)\nusing this:\n  (r, a) \\<in> set C\n  \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>a a", "unfolding satisfies_atom_set_def"], ["proof (prove)\nusing this:\n  (r, a) \\<in> set C\n  \\<forall>(r, a)\\<in>set C. v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>a a", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "hence v: \"v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>a a\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)", "by (auto simp: nsc_of_atom sat_scale_rat_ns)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "from a isleq"], ["proof (chain)\npicking this:\n  (r, a) \\<in> set C\n  \\<forall>(r, a)\\<in>set C.\n     a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0", "have \"is_leq_ns (r *R nsc_of_atom a)\""], ["proof (prove)\nusing this:\n  (r, a) \\<in> set C\n  \\<forall>(r, a)\\<in>set C.\n     a \\<in> as \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_leq_ns (r *R nsc_of_atom a)", "by auto"], ["proof (state)\nthis:\n  is_leq_ns (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "from lec_of_nsc[OF this] v"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (r *R nsc_of_atom a) =\n  ?v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (r *R nsc_of_atom a)\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (r *R nsc_of_atom a) =\n  ?v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (r *R nsc_of_atom a)", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  (?r2, ?a2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (?r2 *R nsc_of_atom ?a2)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "note v = this"], ["proof (state)\nthis:\n  (?r2, ?a2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (?r2 *R nsc_of_atom ?a2)\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e Leqc p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel p c", "unfolding leq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e\n    (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a))", "by (rule satisfies_sumlist_le_constraints, insert v, auto)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel p c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel p c", "have \"0 \\<le> c\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel p c\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c", "using p0"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel p c\n  p \\<lbrace> v \\<rbrace> = (0::'a)\n\ngoal (1 subgoal):\n 1. (0::'a) \\<le> c", "by auto"], ["proof (state)\nthis:\n  (0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  (0::'a) \\<le> c", "show False"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> c\n\ngoal (1 subgoal):\n 1. False", "using cltz"], ["proof (prove)\nusing this:\n  (0::'a) \\<le> c\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next is the main result for layer~3: a tableau and a finite set of atoms are unsatisfiable\n  if and only if there is a list of Farkas coefficients for the set of atoms and the tableau.\\<close>"], ["", "lemma farkas_coefficients_atoms_tableau: assumes norm: \"\\<triangle> t\"\n  and fin: \"finite as\"\nshows \"(\\<exists> C. farkas_coefficients_atoms_tableau as t C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C. farkas_coefficients_atoms_tableau as t C) =\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "from finite_list[OF fin]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = as", "obtain bs where as: \"as = set bs\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = as\n\ngoal (1 subgoal):\n 1. (\\<And>bs. as = set bs \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  as = set bs\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "assume unsat: \"\\<nexists> v. v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\""], ["proof (state)\nthis:\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "let ?as = \"map (\\<lambda> x. ((),x)) bs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "interpret AssertAllState''' init_state assert_bound_code check_code update_code\n    eq_idx_for_lvar min_lvar_not_in_bounds min_rvar_incdec_eq pivot_and_update_code"], ["proof (prove)\ngoal (1 subgoal):\n 1. AssertAllState''' init_state assert_bound_code check_code update_code\n     eq_idx_for_lvar min_lvar_not_in_bounds min_rvar_incdec_eq\n     pivot_and_update_code", "by (unfold_locales, auto simp: assert_bound_code_def check_code_def)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "let ?call = \"assert_all t ?as\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "have id: \"snd ` set ?as = as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) bs) = as", "unfolding as"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) bs) = set bs", "by force"], ["proof (state)\nthis:\n  snd ` set (map (Pair ()) bs) = as\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "from assert_all_sat[OF norm, of ?as, unfolded id] unsat"], ["proof (chain)\npicking this:\n  assert_all t (map (Pair ()) bs) = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s as\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as", "obtain I where \"?call = Inl I\""], ["proof (prove)\nusing this:\n  assert_all t (map (Pair ()) bs) = Inr ?v \\<Longrightarrow>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>t t \\<and>\n  \\<langle>?v\\<rangle> \\<Turnstile>\\<^sub>a\\<^sub>s as\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n\ngoal (1 subgoal):\n 1. (\\<And>I.\n        assert_all t (map (Pair ()) bs) = Inl I \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?call, auto)"], ["proof (state)\nthis:\n  assert_all t (map (Pair ()) bs) = Inl I\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "from this[unfolded assert_all_def Let_def]"], ["proof (chain)\npicking this:\n  (if \\<U>\n       (AssertAllState''.assert_all_state init_state assert_bound_code\n         check_code t (map (Pair ()) bs))\n   then Inl (the (\\<U>\\<^sub>c\n                   (AssertAllState''.assert_all_state init_state\n                     assert_bound_code check_code t (map (Pair ()) bs))))\n   else Inr (\\<V>\n              (AssertAllState''.assert_all_state init_state\n                assert_bound_code check_code t (map (Pair ()) bs)))) =\n  Inl I", "have \"\\<U> (assert_all_state_code t ?as)\""], ["proof (prove)\nusing this:\n  (if \\<U>\n       (AssertAllState''.assert_all_state init_state assert_bound_code\n         check_code t (map (Pair ()) bs))\n   then Inl (the (\\<U>\\<^sub>c\n                   (AssertAllState''.assert_all_state init_state\n                     assert_bound_code check_code t (map (Pair ()) bs))))\n   else Inr (\\<V>\n              (AssertAllState''.assert_all_state init_state\n                assert_bound_code check_code t (map (Pair ()) bs)))) =\n  Inl I\n\ngoal (1 subgoal):\n 1. \\<U> (assert_all_state_code t (map (Pair ()) bs))", "by (auto split: if_splits simp: assert_all_state_code_def)"], ["proof (state)\nthis:\n  \\<U> (assert_all_state_code t (map (Pair ()) bs))\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and>\n       v \\<Turnstile>\\<^sub>a\\<^sub>s as \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_atoms_tableau as t C", "from farkas_assert_all_state[OF this[unfolded assert_all_state_code_def] norm, unfolded id]"], ["proof (chain)\npicking this:\n  \\<exists>C. farkas_coefficients_atoms_tableau as t C", "show \"\\<exists> C. farkas_coefficients_atoms_tableau as t C\""], ["proof (prove)\nusing this:\n  \\<exists>C. farkas_coefficients_atoms_tableau as t C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C", "."], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_atoms_tableau as t C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_atoms_tableau as t C \\<Longrightarrow>\n    \\<nexists>v.\n       v \\<Turnstile>\\<^sub>t t \\<and> v \\<Turnstile>\\<^sub>a\\<^sub>s as", "qed (insert farkas_coefficients_atoms_tableau_unsat, auto)"], ["", "subsection \\<open>Farkas' Lemma on Layer 2\\<close>"], ["", "text \\<open>The main difference between layers 2 and 3 is the introduction of slack-variables in layer 3\n  via the preprocess-function. Our task here is to show that Farkas coefficients at layer 3 (where \n  slack-variables are used) can be converted into Farkas coefficients for layer 2 (before the\n  preprocessing).\\<close>"], ["", "text \\<open>We also need to adapt the previos notion of Farkas coefficients, which was used in \n  @{const farkas_coefficients_atoms_tableau}, for layer~2. At layer 3, Farkas coefficients\n  are the coefficients in a linear combination of atoms that evaluates to an inequality of\n  the form $p \\leq c$, where $p$ is a linear polynomial, $c < 0$, and $t \\models p = 0$ holds.\n  At layer 2, the atoms are replaced by non-strict constraints where the left-hand side is a\n  polynomial in the original variables, but the corresponding linear combination (with Farkas\n  coefficients) evaluates directly to the inequality $0 \\leq c$, with $c < 0$. The implication\n  $t \\models p = 0$ is no longer possible in this layer, since there is no tableau $t$, nor is it\n  needed, since $p$ is $0$. Thus, the statement defining Farkas coefficients must be changed\n  accordingly.\\<close>"], ["", "definition farkas_coefficients_ns where \n  \"farkas_coefficients_ns ns C = (\\<exists> c.\n    (\\<forall>(r, n) \\<in> set C. n \\<in> ns \\<and> is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n    (\\<Sum>(r, n) \\<leftarrow> C. lec_of_nsc (r *R n)) = Leqc 0 c \\<and>\n    c < 0)\""], ["", "text \\<open>The easy part is to prove that Farkas coefficients imply unsatisfiability.\\<close>"], ["", "lemma farkas_coefficients_ns_unsat: \n  assumes \"farkas_coefficients_ns ns C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "assume \"\\<exists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\""], ["proof (state)\nthis:\n  \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns", "obtain v where *: \"v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\""], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "obtain c where\n    isleq: \"(\\<forall>(a,n) \\<in> set C. n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0)\" and\n    leq: \"(\\<Sum>(a,n) \\<leftarrow> C. lec_of_nsc (a *R n)) = Leqc 0 c\" and\n    cltz: \"c < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>\\<forall>(a, n)\\<in>set C.\n                    n \\<in> ns \\<and>\n                    is_leq_ns (a *R n) \\<and> a \\<noteq> 0;\n         (\\<Sum>(a, n)\\<leftarrow>C. lec_of_nsc (a *R n)) =\n         Le_Constraint Leq_Rel 0 c;\n         c < (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms farkas_coefficients_ns_def"], ["proof (prove)\nusing this:\n  farkas_coefficients_ns ns C\n  farkas_coefficients_ns ?ns ?C =\n  (\\<exists>c.\n      (\\<forall>(r, n)\\<in>set ?C.\n          n \\<in> ?ns \\<and> is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n      (\\<Sum>(r, n)\\<leftarrow>?C. lec_of_nsc (r *R n)) =\n      Le_Constraint Leq_Rel 0 c \\<and>\n      c < (0::?'a))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>\\<forall>(a, n)\\<in>set C.\n                    n \\<in> ns \\<and>\n                    is_leq_ns (a *R n) \\<and> a \\<noteq> 0;\n         (\\<Sum>(a, n)\\<leftarrow>C. lec_of_nsc (a *R n)) =\n         Le_Constraint Leq_Rel 0 c;\n         c < (0::'a)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n  (\\<Sum>(a, n)\\<leftarrow>C. lec_of_nsc (a *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "{"], ["proof (state)\nthis:\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n  (\\<Sum>(a, n)\\<leftarrow>C. lec_of_nsc (a *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "fix a n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "assume n: \"(a,n) \\<in> set C\""], ["proof (state)\nthis:\n  (a, n) \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "from n * isleq"], ["proof (chain)\npicking this:\n  (a, n) \\<in> set C\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0", "have \"v \\<Turnstile>\\<^sub>n\\<^sub>s n\""], ["proof (prove)\nusing this:\n  (a, n) \\<in> set C\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s n", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s n\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "hence v: \"v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s n\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)", "by (rule sat_scale_rat_ns)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "from n isleq"], ["proof (chain)\npicking this:\n  (a, n) \\<in> set C\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0", "have \"is_leq_ns (a *R n)\""], ["proof (prove)\nusing this:\n  (a, n) \\<in> set C\n  \\<forall>(a, n)\\<in>set C.\n     n \\<in> ns \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_leq_ns (a *R n)", "by auto"], ["proof (state)\nthis:\n  is_leq_ns (a *R n)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "from lec_of_nsc[OF this] v"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (a *R n) =\n  ?v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (a *R n)\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (a *R n) =\n  ?v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)\n  v \\<Turnstile>\\<^sub>n\\<^sub>s (a *R n)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (a *R n)", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (a *R n)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "}"], ["proof (state)\nthis:\n  (?a2, ?n2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (?a2 *R ?n2)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "note v = this"], ["proof (state)\nthis:\n  (?a2, ?n2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_nsc (?a2 *R ?n2)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e Leqc 0 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel 0 c", "unfolding leq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e\n    (\\<Sum>(a, n)\\<leftarrow>C. lec_of_nsc (a *R n))", "by (rule satisfies_sumlist_le_constraints, insert v, auto)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel 0 c", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. False", "using cltz"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint Leq_Rel 0 c\n  c < (0::'a)\n\ngoal (1 subgoal):\n 1. False", "by (metis leD satisfiable_le_constraint.simps valuate_zero rel_of.simps(1))"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In order to eliminate the need for a tableau, we require the notion of an arbitrary substitution\n  on polynomials, where all variables can be replaced at once. The existing simplex formalization \n  provides only a function to replace one variable at a time.\\<close>"], ["", "definition subst_poly :: \"(var \\<Rightarrow> linear_poly) \\<Rightarrow> linear_poly \\<Rightarrow> linear_poly\" where\n  \"subst_poly \\<sigma> p = (\\<Sum> x \\<in> vars p. coeff p x *R \\<sigma> x)\""], ["", "lemma subst_poly_0[simp]: \"subst_poly \\<sigma> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> 0 = 0", "unfolding subst_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>vars 0. coeff 0 x *R \\<sigma> x) = 0", "by simp"], ["", "lemma valuate_subst_poly: \"(subst_poly \\<sigma> p) \\<lbrace> v \\<rbrace> = (p \\<lbrace> (\\<lambda> x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>)) \\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> =\n    p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "by (subst (2) linear_poly_sum, unfold subst_poly_def valuate_sum valuate_scaleRat, simp)"], ["", "lemma subst_poly_add: \"subst_poly \\<sigma> (p + q) = subst_poly \\<sigma> p + subst_poly \\<sigma> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> (p + q) =\n    subst_poly \\<sigma> p + subst_poly \\<sigma> q", "by (rule linear_poly_eqI, unfold valuate_add valuate_subst_poly, simp)"], ["", "fun subst_poly_lec :: \"(var \\<Rightarrow> linear_poly) \\<Rightarrow> 'a le_constraint \\<Rightarrow> 'a le_constraint\" where\n  \"subst_poly_lec \\<sigma> (Le_Constraint rel p c) = Le_Constraint rel (subst_poly \\<sigma> p) c\""], ["", "lemma subst_poly_lec_0[simp]: \"subst_poly_lec \\<sigma> 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> 0 = 0", "unfolding zero_le_constraint_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (Le_Constraint Leq_Rel 0 (0::'a)) =\n    Le_Constraint Leq_Rel 0 (0::'a)", "by simp"], ["", "lemma subst_poly_lec_add: \"subst_poly_lec \\<sigma> (c1 + c2) = subst_poly_lec \\<sigma> c1 + subst_poly_lec \\<sigma> c2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (c1 + c2) =\n    subst_poly_lec \\<sigma> c1 + subst_poly_lec \\<sigma> c2", "by (cases c1; cases c2, auto simp: subst_poly_add)"], ["", "lemma subst_poly_lec_sum_list: \"subst_poly_lec \\<sigma> (sum_list ps) = sum_list (map (subst_poly_lec \\<sigma>) ps)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (sum_list ps) =\n    sum_list (map (subst_poly_lec \\<sigma>) ps)", "by (induct ps, auto simp: subst_poly_lec_add)"], ["", "lemma subst_poly_lp_monom[simp]: \"subst_poly \\<sigma> (lp_monom r x) = r *R \\<sigma> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> (lp_monom r x) = r *R \\<sigma> x", "unfolding subst_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>xa\\<in>vars (lp_monom r x).\n       coeff (lp_monom r x) xa *R \\<sigma> xa) =\n    r *R \\<sigma> x", "by (simp add: vars_lp_monom)"], ["", "lemma subst_poly_scaleRat: \"subst_poly \\<sigma> (r *R p) = r *R (subst_poly \\<sigma> p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> (r *R p) = r *R subst_poly \\<sigma> p", "by (rule linear_poly_eqI, unfold valuate_scaleRat valuate_subst_poly, simp)"], ["", "text \\<open>We need several auxiliary properties of the preprocess-function which are not present\n  in the simplex formalization.\\<close>"], ["", "lemma Tableau_is_monom_preprocess':\n  assumes \"(x, p) \\<in> set (Tableau (preprocess' cs start))\"\n  shows \"\\<not> is_monom p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> is_monom p", "using assms"], ["proof (prove)\nusing this:\n  (x, p) \\<in> set (Tableau (preprocess' cs start))\n\ngoal (1 subgoal):\n 1. \\<not> is_monom p", "by(induction cs start rule: preprocess'.induct)\n    (auto simp add: Let_def split: if_splits option.splits)"], ["", "lemma preprocess'_atoms_to_constraints': assumes \"preprocess' cs start = S\" \n  shows \"set (Atoms S) \\<subseteq> {(i,qdelta_constraint_to_atom c v) | i c v. (i,c) \\<in> set cs \\<and> \n     (\\<not> is_monom (poly c) \\<longrightarrow> Poly_Mapping S (poly c) = Some v)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Atoms S)\n    \\<subseteq> {(i, qdelta_constraint_to_atom c v) |i c v.\n                 (i, c) \\<in> set cs \\<and>\n                 (\\<not> is_monom (poly c) \\<longrightarrow>\n                  Poly_Mapping S (poly c) = Some v)}", "unfolding assms(1)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (Atoms (preprocess' cs start))\n    \\<subseteq> {(i, qdelta_constraint_to_atom c v) |i c v.\n                 (i, c) \\<in> set cs \\<and>\n                 (\\<not> is_monom (poly c) \\<longrightarrow>\n                  Poly_Mapping (preprocess' cs start) (poly c) = Some v)}", "by (induct cs start rule: preprocess'.induct, auto simp: Let_def split: option.splits, force+)"], ["", "lemma monom_of_atom_coeff:\n  assumes \"is_monom (poly ns)\" \"a = qdelta_constraint_to_atom ns v\"\n  shows \"(monom_coeff (poly ns)) *R nsc_of_atom a = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_coeff (poly ns) *R nsc_of_atom a = ns", "using assms is_monom_monom_coeff_not_zero"], ["proof (prove)\nusing this:\n  is_monom (poly ns)\n  a = qdelta_constraint_to_atom ns v\n  is_monom ?l \\<Longrightarrow> monom_coeff ?l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. monom_coeff (poly ns) *R nsc_of_atom a = ns", "by(cases a; cases ns)\n    (auto split: atom.split ns_constraint.split simp add: monom_poly_assemble field_simps)"], ["", "text \\<open>The next lemma provides the functionality that is required to convert an\n  atom back to a non-strict constraint, i.e., it is a kind of inverse of the preprocess-function.\\<close>"], ["", "lemma preprocess'_atoms_to_constraints: assumes S: \"preprocess' cs start = S\" \n  and start: \"start = start_fresh_variable cs\" \n  and ns: \"ns = (case a of Leq v c \\<Rightarrow> LEQ_ns q c | Geq v c \\<Rightarrow> GEQ_ns q c)\" \n  and \"a \\<in> snd ` set (Atoms S)\" \nshows \"(atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow> (\\<exists> r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs))\n    \\<and>  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow> ns \\<in> snd ` set cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "let ?S = \"preprocess' cs start\""], ["proof (state)\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from assms(4)"], ["proof (chain)\npicking this:\n  a \\<in> snd ` set (Atoms S)", "obtain i where ia: \"(i,a) \\<in> set (Atoms S)\""], ["proof (prove)\nusing this:\n  a \\<in> snd ` set (Atoms S)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        (i, a) \\<in> set (Atoms S) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (i, a) \\<in> set (Atoms S)\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "with preprocess'_atoms_to_constraints'[OF assms(1)]"], ["proof (chain)\npicking this:\n  set (Atoms S)\n  \\<subseteq> {(i, qdelta_constraint_to_atom c v) |i c v.\n               (i, c) \\<in> set cs \\<and>\n               (\\<not> is_monom (poly c) \\<longrightarrow>\n                Poly_Mapping S (poly c) = Some v)}\n  (i, a) \\<in> set (Atoms S)", "obtain c v \n    where a: \"a = qdelta_constraint_to_atom c v\" and c: \"(i,c) \\<in> set cs\" \n      and nmonom: \"\\<not> is_monom (poly c) \\<Longrightarrow> Poly_Mapping S (poly c) = Some v\""], ["proof (prove)\nusing this:\n  set (Atoms S)\n  \\<subseteq> {(i, qdelta_constraint_to_atom c v) |i c v.\n               (i, c) \\<in> set cs \\<and>\n               (\\<not> is_monom (poly c) \\<longrightarrow>\n                Poly_Mapping S (poly c) = Some v)}\n  (i, a) \\<in> set (Atoms S)\n\ngoal (1 subgoal):\n 1. (\\<And>c v.\n        \\<lbrakk>a = qdelta_constraint_to_atom c v; (i, c) \\<in> set cs;\n         \\<not> is_monom (poly c) \\<Longrightarrow>\n         Poly_Mapping S (poly c) = Some v\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = qdelta_constraint_to_atom c v\n  (i, c) \\<in> set cs\n  \\<not> is_monom (poly c) \\<Longrightarrow>\n  Poly_Mapping S (poly c) = Some v\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence c': \"c \\<in> snd ` set cs\""], ["proof (prove)\nusing this:\n  a = qdelta_constraint_to_atom c v\n  (i, c) \\<in> set cs\n  \\<not> is_monom (poly c) \\<Longrightarrow>\n  Poly_Mapping S (poly c) = Some v\n\ngoal (1 subgoal):\n 1. c \\<in> snd ` set cs", "by force"], ["proof (state)\nthis:\n  c \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "let ?p = \"poly c\""], ["proof (state)\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "proof (cases \"is_monom ?p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "case True"], ["proof (state)\nthis:\n  is_monom (poly c)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence av: \"atom_var a = monom_var ?p\""], ["proof (prove)\nusing this:\n  is_monom (poly c)\n\ngoal (1 subgoal):\n 1. atom_var a = monom_var (poly c)", "unfolding a"], ["proof (prove)\nusing this:\n  is_monom (poly c)\n\ngoal (1 subgoal):\n 1. atom_var (qdelta_constraint_to_atom c v) = monom_var (poly c)", "by (cases c, auto)"], ["proof (state)\nthis:\n  atom_var a = monom_var (poly c)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from Tableau_is_monom_preprocess'[of _ ?p cs start] True"], ["proof (chain)\npicking this:\n  (?x, poly c) \\<in> set (Tableau (preprocess' cs start)) \\<Longrightarrow>\n  \\<not> is_monom (poly c)\n  is_monom (poly c)", "have \"(x, ?p) \\<notin> set (Tableau ?S)\" for x"], ["proof (prove)\nusing this:\n  (?x, poly c) \\<in> set (Tableau (preprocess' cs start)) \\<Longrightarrow>\n  \\<not> is_monom (poly c)\n  is_monom (poly c)\n\ngoal (1 subgoal):\n 1. (x, poly c) \\<notin> set (Tableau (preprocess' cs start))", "by blast"], ["proof (state)\nthis:\n  (?x, poly c) \\<notin> set (Tableau (preprocess' cs start))\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "{"], ["proof (state)\nthis:\n  (?x, poly c) \\<notin> set (Tableau (preprocess' cs start))\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "assume \"(atom_var a, q) \\<in> set (Tableau S)\""], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence \"(monom_var ?p, q) \\<in> set (Tableau S)\""], ["proof (prove)\nusing this:\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. (monom_var (poly c), q) \\<in> set (Tableau S)", "unfolding av"], ["proof (prove)\nusing this:\n  (monom_var (poly c), q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. (monom_var (poly c), q) \\<in> set (Tableau S)", "by simp"], ["proof (state)\nthis:\n  (monom_var (poly c), q) \\<in> set (Tableau S)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence \"monom_var ?p \\<in> lvars (Tableau S)\""], ["proof (prove)\nusing this:\n  (monom_var (poly c), q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. monom_var (poly c) \\<in> lvars (Tableau S)", "unfolding lvars_def"], ["proof (prove)\nusing this:\n  (monom_var (poly c), q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. monom_var (poly c) \\<in> set (map lhs (Tableau S))", "by force"], ["proof (state)\nthis:\n  monom_var (poly c) \\<in> lvars (Tableau S)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from lvars_tableau_ge_start[rule_format, OF this[folded S]]"], ["proof (chain)\npicking this:\n  start \\<le> monom_var (poly c)", "have \"monom_var ?p \\<ge> start\""], ["proof (prove)\nusing this:\n  start \\<le> monom_var (poly c)\n\ngoal (1 subgoal):\n 1. start \\<le> monom_var (poly c)", "unfolding S"], ["proof (prove)\nusing this:\n  start \\<le> monom_var (poly c)\n\ngoal (1 subgoal):\n 1. start \\<le> monom_var (poly c)", "."], ["proof (state)\nthis:\n  start \\<le> monom_var (poly c)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "moreover"], ["proof (state)\nthis:\n  start \\<le> monom_var (poly c)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "have \"monom_var ?p \\<in> vars_constraints (map snd cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monom_var (poly c) \\<in> vars_constraints (map snd cs)", "using True c"], ["proof (prove)\nusing this:\n  is_monom (poly c)\n  (i, c) \\<in> set cs\n\ngoal (1 subgoal):\n 1. monom_var (poly c) \\<in> vars_constraints (map snd cs)", "by (auto intro!: bexI[of _ \"(i,c)\"] simp: monom_var_in_vars)"], ["proof (state)\nthis:\n  monom_var (poly c) \\<in> vars_constraints (map snd cs)\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "ultimately"], ["proof (chain)\npicking this:\n  start \\<le> monom_var (poly c)\n  monom_var (poly c) \\<in> vars_constraints (map snd cs)", "have False"], ["proof (prove)\nusing this:\n  start \\<le> monom_var (poly c)\n  monom_var (poly c) \\<in> vars_constraints (map snd cs)\n\ngoal (1 subgoal):\n 1. False", "using start_fresh_variable_fresh[of cs, folded start]"], ["proof (prove)\nusing this:\n  start \\<le> monom_var (poly c)\n  monom_var (poly c) \\<in> vars_constraints (map snd cs)\n  \\<forall>var\\<in>vars_constraints (map snd cs). var < start\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "}"], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "moreover"], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from monom_of_atom_coeff[OF True a] True"], ["proof (chain)\npicking this:\n  monom_coeff (poly c) *R nsc_of_atom a = c\n  is_monom (poly c)", "have \"\\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c\""], ["proof (prove)\nusing this:\n  monom_coeff (poly c) *R nsc_of_atom a = c\n  is_monom (poly c)\n\ngoal (1 subgoal):\n 1. \\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c", "by (intro exI[of _ \"monom_coeff ?p\"], auto, cases a, auto)"], ["proof (state)\nthis:\n  \\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c\n\ngoal (2 subgoals):\n 1. is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)\n 2. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "ultimately"], ["proof (chain)\npicking this:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow> False\n  \\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c", "show ?thesis"], ["proof (prove)\nusing this:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow> False\n  \\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "using c'"], ["proof (prove)\nusing this:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow> False\n  \\<exists>r. r \\<noteq> 0 \\<and> r *R nsc_of_atom a = c\n  c \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "by auto"], ["proof (state)\nthis:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n   ns \\<in> snd ` set cs)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "case False"], ["proof (state)\nthis:\n  \\<not> is_monom (poly c)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence av: \"atom_var a = v\""], ["proof (prove)\nusing this:\n  \\<not> is_monom (poly c)\n\ngoal (1 subgoal):\n 1. atom_var a = v", "unfolding a"], ["proof (prove)\nusing this:\n  \\<not> is_monom (poly c)\n\ngoal (1 subgoal):\n 1. atom_var (qdelta_constraint_to_atom c v) = v", "by (cases c, auto)"], ["proof (state)\nthis:\n  atom_var a = v\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from nmonom[OF False]"], ["proof (chain)\npicking this:\n  Poly_Mapping S (poly c) = Some v", "have \"Poly_Mapping S ?p = Some v\""], ["proof (prove)\nusing this:\n  Poly_Mapping S (poly c) = Some v\n\ngoal (1 subgoal):\n 1. Poly_Mapping S (poly c) = Some v", "."], ["proof (state)\nthis:\n  Poly_Mapping S (poly c) = Some v\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from preprocess'_Tableau_Poly_Mapping_Some[OF this[folded S]]"], ["proof (chain)\npicking this:\n  linear_poly_to_eq (poly c) v \\<in> set (Tableau (preprocess' cs start))", "have tab: \"(atom_var a, ?p) \\<in> set (Tableau (preprocess' cs start))\""], ["proof (prove)\nusing this:\n  linear_poly_to_eq (poly c) v \\<in> set (Tableau (preprocess' cs start))\n\ngoal (1 subgoal):\n 1. (atom_var a, poly c) \\<in> set (Tableau (preprocess' cs start))", "unfolding av"], ["proof (prove)\nusing this:\n  linear_poly_to_eq (poly c) v \\<in> set (Tableau (preprocess' cs start))\n\ngoal (1 subgoal):\n 1. (v, poly c) \\<in> set (Tableau (preprocess' cs start))", "by simp"], ["proof (state)\nthis:\n  (atom_var a, poly c) \\<in> set (Tableau (preprocess' cs start))\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence \"atom_var a \\<in> fst ` set (Tableau S)\""], ["proof (prove)\nusing this:\n  (atom_var a, poly c) \\<in> set (Tableau (preprocess' cs start))\n\ngoal (1 subgoal):\n 1. atom_var a \\<in> fst ` set (Tableau S)", "unfolding S"], ["proof (prove)\nusing this:\n  (atom_var a, poly c) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. atom_var a \\<in> fst ` set (Tableau S)", "by force"], ["proof (state)\nthis:\n  atom_var a \\<in> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "moreover"], ["proof (state)\nthis:\n  atom_var a \\<in> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "{"], ["proof (state)\nthis:\n  atom_var a \\<in> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "assume \"(atom_var a, q) \\<in> set (Tableau S)\""], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "from tab this"], ["proof (chain)\npicking this:\n  (atom_var a, poly c) \\<in> set (Tableau (preprocess' cs start))\n  (atom_var a, q) \\<in> set (Tableau S)", "have qp: \"q = ?p\""], ["proof (prove)\nusing this:\n  (atom_var a, poly c) \\<in> set (Tableau (preprocess' cs start))\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. q = poly c", "unfolding S"], ["proof (prove)\nusing this:\n  (atom_var a, poly c) \\<in> set (Tableau S)\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. q = poly c", "using lvars_distinct[of cs start, unfolded S lhs_def]"], ["proof (prove)\nusing this:\n  (atom_var a, poly c) \\<in> set (Tableau S)\n  (atom_var a, q) \\<in> set (Tableau S)\n  distinct\n   (map (\\<lambda>uu. case uu of (l, r) \\<Rightarrow> l) (Tableau S))\n\ngoal (1 subgoal):\n 1. q = poly c", "by (simp add: case_prod_beta' eq_key_imp_eq_value)"], ["proof (state)\nthis:\n  q = poly c\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "have \"ns = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns = c", "unfolding ns qp"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case a of Leq v x \\<Rightarrow> LEQ_ns (poly c) x\n     | Geq v x \\<Rightarrow> GEQ_ns (poly c) x) =\n    c", "using av a False"], ["proof (prove)\nusing this:\n  atom_var a = v\n  a = qdelta_constraint_to_atom c v\n  \\<not> is_monom (poly c)\n\ngoal (1 subgoal):\n 1. (case a of Leq v x \\<Rightarrow> LEQ_ns (poly c) x\n     | Geq v x \\<Rightarrow> GEQ_ns (poly c) x) =\n    c", "by (cases c, auto)"], ["proof (state)\nthis:\n  ns = c\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "hence \"ns \\<in> snd ` set cs\""], ["proof (prove)\nusing this:\n  ns = c\n\ngoal (1 subgoal):\n 1. ns \\<in> snd ` set cs", "using c'"], ["proof (prove)\nusing this:\n  ns = c\n  c \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. ns \\<in> snd ` set cs", "by blast"], ["proof (state)\nthis:\n  ns \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "}"], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow>\n  ns \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. \\<not> is_monom (poly c) \\<Longrightarrow>\n    (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "ultimately"], ["proof (chain)\npicking this:\n  atom_var a \\<in> fst ` set (Tableau S)\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow>\n  ns \\<in> snd ` set cs", "show ?thesis"], ["proof (prove)\nusing this:\n  atom_var a \\<in> fst ` set (Tableau S)\n  (atom_var a, q) \\<in> set (Tableau S) \\<Longrightarrow>\n  ns \\<in> snd ` set cs\n\ngoal (1 subgoal):\n 1. (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n     (\\<exists>r.\n         r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n    ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n     ns \\<in> snd ` set cs)", "by blast"], ["proof (state)\nthis:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n   ns \\<in> snd ` set cs)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n   ns \\<in> snd ` set cs)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Next follows the major technical lemma of this part, \n  namely that Farkas coefficients on layer~3 for preprocessed constraints can\n  be converted into Farkas coefficients on layer~2.\\<close>"], ["", "lemma farkas_coefficients_preprocess': \n  assumes pp: \"preprocess' cs (start_fresh_variable cs) = S\" and\n    ft: \"farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\"\n  shows \"\\<exists> C. farkas_coefficients_ns (snd ` set cs) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "note ft[unfolded farkas_coefficients_atoms_tableau_def]"], ["proof (state)\nthis:\n  \\<exists>p c.\n     (\\<forall>(r, a)\\<in>set C.\n         a \\<in> snd ` set (Atoms S) \\<and>\n         is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n     Le_Constraint Leq_Rel p c \\<and>\n     c < 0 \\<and>\n     (\\<forall>v.\n         v \\<Turnstile>\\<^sub>t Tableau S \\<longrightarrow>\n         p \\<lbrace> v \\<rbrace> = 0)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "obtain p c where 0: \"\\<forall> (r,a) \\<in> set C. a \\<in> snd ` set (Atoms S) \\<and> is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\"\n    \"(\\<Sum>(r,a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) = Leqc p c\"\n    \"c < 0\"\n    \"\\<And>v :: QDelta valuation. v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow> p \\<lbrace> v \\<rbrace> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p c.\n        \\<lbrakk>\\<forall>(r, a)\\<in>set C.\n                    a \\<in> snd ` set (Atoms S) \\<and>\n                    is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n         Le_Constraint Leq_Rel p c;\n         c < 0;\n         \\<And>v.\n            v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n            p \\<lbrace> v \\<rbrace> = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ft"], ["proof (prove)\nusing this:\n  farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\n\ngoal (1 subgoal):\n 1. (\\<And>p c.\n        \\<lbrakk>\\<forall>(r, a)\\<in>set C.\n                    a \\<in> snd ` set (Atoms S) \\<and>\n                    is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n         Le_Constraint Leq_Rel p c;\n         c < 0;\n         \\<And>v.\n            v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n            p \\<lbrace> v \\<rbrace> = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding farkas_coefficients_atoms_tableau_def"], ["proof (prove)\nusing this:\n  \\<exists>p c.\n     (\\<forall>(r, a)\\<in>set C.\n         a \\<in> snd ` set (Atoms S) \\<and>\n         is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n     Le_Constraint Leq_Rel p c \\<and>\n     c < 0 \\<and>\n     (\\<forall>v.\n         v \\<Turnstile>\\<^sub>t Tableau S \\<longrightarrow>\n         p \\<lbrace> v \\<rbrace> = 0)\n\ngoal (1 subgoal):\n 1. (\\<And>p c.\n        \\<lbrakk>\\<forall>(r, a)\\<in>set C.\n                    a \\<in> snd ` set (Atoms S) \\<and>\n                    is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n         Le_Constraint Leq_Rel p c;\n         c < 0;\n         \\<And>v.\n            v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n            p \\<lbrace> v \\<rbrace> = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(r, a)\\<in>set C.\n     a \\<in> snd ` set (Atoms S) \\<and>\n     is_leq_ns (r *R nsc_of_atom a) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "note 0 = 0(1)[rule_format, of \"(a, b)\" for a b, unfolded split] 0(2-)"], ["proof (state)\nthis:\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "let ?T = \"Tableau S\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "define \\<sigma> :: \"var \\<Rightarrow> linear_poly\" where \"\\<sigma> = (\\<lambda> x. case map_of ?T x of Some p \\<Rightarrow> p | None \\<Rightarrow> lp_monom 1 x)\""], ["proof (state)\nthis:\n  \\<sigma> =\n  (\\<lambda>x.\n      case map_of (Tableau S) x of None \\<Rightarrow> lp_monom 1 x\n      | Some p \\<Rightarrow> p)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "let ?P = \"(\\<lambda>r a s ns. ns \\<in> (snd ` set cs) \\<and> is_leq_ns (s *R ns) \\<and> s \\<noteq> 0 \\<and>\n      subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) = lec_of_nsc (s *R ns))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"\\<exists>s ns. ?P r a s ns\" if ra: \"(r,a) \\<in> set C\" for r a"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "have a: \"a \\<in> snd ` set (Atoms S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> snd ` set (Atoms S)", "using ra 0"], ["proof (prove)\nusing this:\n  (r, a) \\<in> set C\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. a \\<in> snd ` set (Atoms S)", "by force"], ["proof (state)\nthis:\n  a \\<in> snd ` set (Atoms S)\n\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "from 0 ra"], ["proof (chain)\npicking this:\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n  (r, a) \\<in> set C", "have is_leq: \"is_leq_ns (r *R nsc_of_atom a)\" and r0: \"r \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n  (r, a) \\<in> set C\n\ngoal (1 subgoal):\n 1. is_leq_ns (r *R nsc_of_atom a) &&& r \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  is_leq_ns (r *R nsc_of_atom a)\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "let ?x = \"atom_var a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "proof (cases \"map_of ?T ?x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "case (Some q)"], ["proof (state)\nthis:\n  map_of (Tableau S) (atom_var a) = Some q\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "hence \\<sigma>: \"\\<sigma> ?x = q\""], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = Some q\n\ngoal (1 subgoal):\n 1. \\<sigma> (atom_var a) = q", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = Some q\n\ngoal (1 subgoal):\n 1. (case map_of (Tableau S) (atom_var a) of\n     None \\<Rightarrow> lp_monom 1 (atom_var a) | Some p \\<Rightarrow> p) =\n    q", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (atom_var a) = q\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "from Some"], ["proof (chain)\npicking this:\n  map_of (Tableau S) (atom_var a) = Some q", "have xqT: \"(?x, q) \\<in> set ?T\""], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = Some q\n\ngoal (1 subgoal):\n 1. (atom_var a, q) \\<in> set (Tableau S)", "by (rule map_of_SomeD)"], ["proof (state)\nthis:\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "define ns where \"ns = (case a of Leq v c \\<Rightarrow> LEQ_ns q c\n                                     | Geq v c \\<Rightarrow> GEQ_ns q c)\""], ["proof (state)\nthis:\n  ns =\n  (case a of Leq v c \\<Rightarrow> LEQ_ns q c\n   | Geq v c \\<Rightarrow> GEQ_ns q c)\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "from preprocess'_atoms_to_constraints[OF pp refl ns_def a] xqT"], ["proof (chain)\npicking this:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n   ns \\<in> snd ` set cs)\n  (atom_var a, q) \\<in> set (Tableau S)", "have ns_mem: \"ns \\<in> snd ` set cs\""], ["proof (prove)\nusing this:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, q) \\<in> set (Tableau S) \\<longrightarrow>\n   ns \\<in> snd ` set cs)\n  (atom_var a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. ns \\<in> snd ` set cs", "by blast"], ["proof (state)\nthis:\n  ns \\<in> snd ` set cs\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "have id: \"subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a))\n               = lec_of_nsc (r *R ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n    lec_of_nsc (r *R ns)", "using is_leq \\<sigma>"], ["proof (prove)\nusing this:\n  is_leq_ns (r *R nsc_of_atom a)\n  \\<sigma> (atom_var a) = q\n\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n    lec_of_nsc (r *R ns)", "by (cases a, auto simp: ns_def subst_poly_scaleRat)"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R ns)\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "from id is_leq \\<sigma>"], ["proof (chain)\npicking this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R ns)\n  is_leq_ns (r *R nsc_of_atom a)\n  \\<sigma> (atom_var a) = q", "have is_leq: \"is_leq_ns (r *R ns)\""], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R ns)\n  is_leq_ns (r *R nsc_of_atom a)\n  \\<sigma> (atom_var a) = q\n\ngoal (1 subgoal):\n 1. is_leq_ns (r *R ns)", "by (cases a, auto simp: ns_def)"], ["proof (state)\nthis:\n  is_leq_ns (r *R ns)\n\ngoal (2 subgoals):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)\n 2. \\<And>aa.\n       map_of (Tableau S) (atom_var a) = Some aa \\<Longrightarrow>\n       \\<exists>s ns.\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n          lec_of_nsc (s *R ns)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "by (intro exI[of _ r] exI[of _ ns] conjI ns_mem id is_leq conjI r0)"], ["proof (state)\nthis:\n  \\<exists>s ns.\n     ns \\<in> snd ` set cs \\<and>\n     is_leq_ns (s *R ns) \\<and>\n     s \\<noteq> 0 \\<and>\n     subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n     lec_of_nsc (s *R ns)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "case None"], ["proof (state)\nthis:\n  map_of (Tableau S) (atom_var a) = None\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "hence \"?x \\<notin> fst ` set ?T\""], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = None\n\ngoal (1 subgoal):\n 1. atom_var a \\<notin> fst ` set (Tableau S)", "by (meson map_of_eq_None_iff)"], ["proof (state)\nthis:\n  atom_var a \\<notin> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "from preprocess'_atoms_to_constraints[OF pp refl refl a] this"], ["proof (chain)\npicking this:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, ?q) \\<in> set (Tableau S) \\<longrightarrow>\n   (case a of Leq v c \\<Rightarrow> LEQ_ns ?q c\n    | Geq v c \\<Rightarrow> GEQ_ns ?q c)\n   \\<in> snd ` set cs)\n  atom_var a \\<notin> fst ` set (Tableau S)", "obtain rr where rr: \"rr *R nsc_of_atom a \\<in> (snd ` set cs)\" and rr0: \"rr \\<noteq> 0\""], ["proof (prove)\nusing this:\n  (atom_var a \\<notin> fst ` set (Tableau S) \\<longrightarrow>\n   (\\<exists>r.\n       r \\<noteq> 0 \\<and> r *R nsc_of_atom a \\<in> snd ` set cs)) \\<and>\n  ((atom_var a, ?q) \\<in> set (Tableau S) \\<longrightarrow>\n   (case a of Leq v c \\<Rightarrow> LEQ_ns ?q c\n    | Geq v c \\<Rightarrow> GEQ_ns ?q c)\n   \\<in> snd ` set cs)\n  atom_var a \\<notin> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. (\\<And>rr.\n        \\<lbrakk>rr *R nsc_of_atom a \\<in> snd ` set cs;\n         rr \\<noteq> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  rr *R nsc_of_atom a \\<in> snd ` set cs\n  rr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "from None"], ["proof (chain)\npicking this:\n  map_of (Tableau S) (atom_var a) = None", "have \\<sigma>: \"\\<sigma> ?x = lp_monom 1 ?x\""], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = None\n\ngoal (1 subgoal):\n 1. \\<sigma> (atom_var a) = lp_monom 1 (atom_var a)", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  map_of (Tableau S) (atom_var a) = None\n\ngoal (1 subgoal):\n 1. (case map_of (Tableau S) (atom_var a) of\n     None \\<Rightarrow> lp_monom 1 (atom_var a) | Some p \\<Rightarrow> p) =\n    lp_monom 1 (atom_var a)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (atom_var a) = lp_monom 1 (atom_var a)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "define ns where \"ns = rr *R nsc_of_atom a\""], ["proof (state)\nthis:\n  ns = rr *R nsc_of_atom a\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "define s where \"s = r / rr\""], ["proof (state)\nthis:\n  s = r / rr\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "from rr0 r0"], ["proof (chain)\npicking this:\n  rr \\<noteq> 0\n  r \\<noteq> 0", "have s0: \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rr \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. s \\<noteq> 0", "unfolding s_def"], ["proof (prove)\nusing this:\n  rr \\<noteq> 0\n  r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r / rr \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "from is_leq \\<sigma>"], ["proof (chain)\npicking this:\n  is_leq_ns (r *R nsc_of_atom a)\n  \\<sigma> (atom_var a) = lp_monom 1 (atom_var a)", "have \"subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) \n        = lec_of_nsc (r *R nsc_of_atom a)\""], ["proof (prove)\nusing this:\n  is_leq_ns (r *R nsc_of_atom a)\n  \\<sigma> (atom_var a) = lp_monom 1 (atom_var a)\n\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n    lec_of_nsc (r *R nsc_of_atom a)", "by (cases a, auto simp: subst_poly_scaleRat)"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "moreover"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "have \"r *R nsc_of_atom a = s *R ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r *R nsc_of_atom a = s *R ns", "unfolding ns_def s_def\n          scaleRat_scaleRat_ns_constraint[OF rr0]"], ["proof (prove)\ngoal (1 subgoal):\n 1. r *R nsc_of_atom a = (r / rr * rr) *R nsc_of_atom a", "using rr0"], ["proof (prove)\nusing this:\n  rr \\<noteq> 0\n\ngoal (1 subgoal):\n 1. r *R nsc_of_atom a = (r / rr * rr) *R nsc_of_atom a", "by simp"], ["proof (state)\nthis:\n  r *R nsc_of_atom a = s *R ns\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "ultimately"], ["proof (chain)\npicking this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R nsc_of_atom a)\n  r *R nsc_of_atom a = s *R ns", "have \"subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a))\n            = lec_of_nsc (s *R ns)\" \"is_leq_ns (s *R ns)\""], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R nsc_of_atom a)\n  r *R nsc_of_atom a = s *R ns\n\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n    lec_of_nsc (s *R ns) &&&\n    is_leq_ns (s *R ns)", "using is_leq"], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (r *R nsc_of_atom a)\n  r *R nsc_of_atom a = s *R ns\n  is_leq_ns (r *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n    lec_of_nsc (s *R ns) &&&\n    is_leq_ns (s *R ns)", "by auto"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (s *R ns)\n  is_leq_ns (s *R ns)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) (atom_var a) = None \\<Longrightarrow>\n    \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "then"], ["proof (chain)\npicking this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (s *R ns)\n  is_leq_ns (s *R ns)", "show ?thesis"], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (s *R ns)\n  is_leq_ns (s *R ns)\n\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "unfolding ns_def"], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (s *R rr *R nsc_of_atom a)\n  is_leq_ns (s *R rr *R nsc_of_atom a)\n\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "using rr s0"], ["proof (prove)\nusing this:\n  subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n  lec_of_nsc (s *R rr *R nsc_of_atom a)\n  is_leq_ns (s *R rr *R nsc_of_atom a)\n  rr *R nsc_of_atom a \\<in> snd ` set cs\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>s ns.\n       ns \\<in> snd ` set cs \\<and>\n       is_leq_ns (s *R ns) \\<and>\n       s \\<noteq> 0 \\<and>\n       subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n       lec_of_nsc (s *R ns)", "by blast"], ["proof (state)\nthis:\n  \\<exists>s ns.\n     ns \\<in> snd ` set cs \\<and>\n     is_leq_ns (s *R ns) \\<and>\n     s \\<noteq> 0 \\<and>\n     subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n     lec_of_nsc (s *R ns)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s ns.\n     ns \\<in> snd ` set cs \\<and>\n     is_leq_ns (s *R ns) \\<and>\n     s \\<noteq> 0 \\<and>\n     subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n     lec_of_nsc (s *R ns)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  \\<exists>s ns.\n     ns \\<in> snd ` set cs \\<and>\n     is_leq_ns (s *R ns) \\<and>\n     s \\<noteq> 0 \\<and>\n     subst_poly_lec \\<sigma> (lec_of_nsc (?r *R nsc_of_atom ?a)) =\n     lec_of_nsc (s *R ns)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "hence \"\\<forall> ra. \\<exists> s ns. (fst ra, snd ra) \\<in> set C \\<longrightarrow> ?P (fst ra) (snd ra) s ns\""], ["proof (prove)\nusing this:\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  \\<exists>s ns.\n     ns \\<in> snd ` set cs \\<and>\n     is_leq_ns (s *R ns) \\<and>\n     s \\<noteq> 0 \\<and>\n     subst_poly_lec \\<sigma> (lec_of_nsc (?r *R nsc_of_atom ?a)) =\n     lec_of_nsc (s *R ns)\n\ngoal (1 subgoal):\n 1. \\<forall>ra.\n       \\<exists>s ns.\n          (fst ra, snd ra) \\<in> set C \\<longrightarrow>\n          ns \\<in> snd ` set cs \\<and>\n          is_leq_ns (s *R ns) \\<and>\n          s \\<noteq> 0 \\<and>\n          subst_poly_lec \\<sigma>\n           (lec_of_nsc (fst ra *R nsc_of_atom (snd ra))) =\n          lec_of_nsc (s *R ns)", "by blast"], ["proof (state)\nthis:\n  \\<forall>ra.\n     \\<exists>s ns.\n        (fst ra, snd ra) \\<in> set C \\<longrightarrow>\n        ns \\<in> snd ` set cs \\<and>\n        is_leq_ns (s *R ns) \\<and>\n        s \\<noteq> 0 \\<and>\n        subst_poly_lec \\<sigma>\n         (lec_of_nsc (fst ra *R nsc_of_atom (snd ra))) =\n        lec_of_nsc (s *R ns)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        \\<exists>ns.\n           (fst x, snd x) \\<in> set C \\<longrightarrow>\n           ns \\<in> snd ` set cs \\<and>\n           is_leq_ns (f x *R ns) \\<and>\n           f x \\<noteq> 0 \\<and>\n           subst_poly_lec \\<sigma>\n            (lec_of_nsc (fst x *R nsc_of_atom (snd x))) =\n           lec_of_nsc (f x *R ns)", "obtain s where s: \"\\<forall> ra. \\<exists> ns. (fst ra, snd ra) \\<in> set C \\<longrightarrow> ?P (fst ra) (snd ra) (s ra) ns\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        \\<exists>ns.\n           (fst x, snd x) \\<in> set C \\<longrightarrow>\n           ns \\<in> snd ` set cs \\<and>\n           is_leq_ns (f x *R ns) \\<and>\n           f x \\<noteq> 0 \\<and>\n           subst_poly_lec \\<sigma>\n            (lec_of_nsc (fst x *R nsc_of_atom (snd x))) =\n           lec_of_nsc (f x *R ns)\n\ngoal (1 subgoal):\n 1. (\\<And>s.\n        \\<forall>ra.\n           \\<exists>ns.\n              (fst ra, snd ra) \\<in> set C \\<longrightarrow>\n              ns \\<in> snd ` set cs \\<and>\n              is_leq_ns (s ra *R ns) \\<and>\n              s ra \\<noteq> 0 \\<and>\n              subst_poly_lec \\<sigma>\n               (lec_of_nsc (fst ra *R nsc_of_atom (snd ra))) =\n              lec_of_nsc (s ra *R ns) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>ra.\n     \\<exists>ns.\n        (fst ra, snd ra) \\<in> set C \\<longrightarrow>\n        ns \\<in> snd ` set cs \\<and>\n        is_leq_ns (s ra *R ns) \\<and>\n        s ra \\<noteq> 0 \\<and>\n        subst_poly_lec \\<sigma>\n         (lec_of_nsc (fst ra *R nsc_of_atom (snd ra))) =\n        lec_of_nsc (s ra *R ns)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "from choice[OF this]"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<forall>x.\n        (fst x, snd x) \\<in> set C \\<longrightarrow>\n        f x \\<in> snd ` set cs \\<and>\n        is_leq_ns (s x *R f x) \\<and>\n        s x \\<noteq> 0 \\<and>\n        subst_poly_lec \\<sigma>\n         (lec_of_nsc (fst x *R nsc_of_atom (snd x))) =\n        lec_of_nsc (s x *R f x)", "obtain ns where ns: \"\\<And> r a. (r,a) \\<in> set C \\<Longrightarrow> ?P r a (s (r,a)) (ns (r,a))\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>x.\n        (fst x, snd x) \\<in> set C \\<longrightarrow>\n        f x \\<in> snd ` set cs \\<and>\n        is_leq_ns (s x *R f x) \\<and>\n        s x \\<noteq> 0 \\<and>\n        subst_poly_lec \\<sigma>\n         (lec_of_nsc (fst x *R nsc_of_atom (snd x))) =\n        lec_of_nsc (s x *R f x)\n\ngoal (1 subgoal):\n 1. (\\<And>ns.\n        (\\<And>r a.\n            (r, a) \\<in> set C \\<Longrightarrow>\n            ns (r, a) \\<in> snd ` set cs \\<and>\n            is_leq_ns (s (r, a) *R ns (r, a)) \\<and>\n            s (r, a) \\<noteq> 0 \\<and>\n            subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)) =\n            lec_of_nsc (s (r, a) *R ns (r, a))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  ns (?r, ?a) \\<in> snd ` set cs \\<and>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a)) \\<and>\n  s (?r, ?a) \\<noteq> 0 \\<and>\n  subst_poly_lec \\<sigma> (lec_of_nsc (?r *R nsc_of_atom ?a)) =\n  lec_of_nsc (s (?r, ?a) *R ns (?r, ?a))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "define NC where \"NC = map (\\<lambda>(r,a). (s (r,a), ns (r,a))) C\""], ["proof (state)\nthis:\n  NC = map (\\<lambda>(r, a). (s (r, a), ns (r, a))) C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"(\\<Sum>(s, ns)\\<leftarrow>map (\\<lambda>(r,a). (s (r,a), ns (r,a))) C'. lec_of_nsc (s *R ns)) =\n        (\\<Sum>(r, a)\\<leftarrow>C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))\"\n    if \"set C' \\<subseteq> set C\" for C'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(s,\n        ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                        C'. lec_of_nsc (s *R ns)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))", "using that"], ["proof (prove)\nusing this:\n  set C' \\<subseteq> set C\n\ngoal (1 subgoal):\n 1. (\\<Sum>(s,\n        ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                        C'. lec_of_nsc (s *R ns)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))", "proof (induction C')"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set C \\<Longrightarrow>\n    (\\<Sum>(s,\n        ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                        []. lec_of_nsc (s *R ns)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>[]. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))\n 2. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set C\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set C \\<Longrightarrow>\n    (\\<Sum>(s,\n        ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                        []. lec_of_nsc (s *R ns)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>[]. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))\n 2. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "then"], ["proof (chain)\npicking this:\n  set [] \\<subseteq> set C", "show ?case"], ["proof (prove)\nusing this:\n  set [] \\<subseteq> set C\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                                case a of\n                                (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                         []. case a of\n                             (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n    (\\<Sum>a\\<leftarrow>[]. case a of\n                            (r, a) \\<Rightarrow>\n                              subst_poly_lec \\<sigma>\n                               (lec_of_nsc (r *R nsc_of_atom a)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       []. case a of\n                           (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  (\\<Sum>a\\<leftarrow>[]. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "case (Cons a C')"], ["proof (state)\nthis:\n  set C' \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C'. case a of\n                           (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  (\\<Sum>a\\<leftarrow>C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n  set (a # C') \\<subseteq> set C\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "have \"(\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) = \n          lec_of_nsc (s a *R ns a) + (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) =\n    lec_of_nsc (s a *R ns a) +\n    (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) =\n  lec_of_nsc (s a *R ns a) +\n  (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) =\n  lec_of_nsc (s a *R ns a) +\n  (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "have \"(\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x)) = (\\<Sum>(r, a)\\<leftarrow>C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))", "using Cons"], ["proof (prove)\nusing this:\n  set C' \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C'. case a of\n                           (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  (\\<Sum>a\\<leftarrow>C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n  set (a # C') \\<subseteq> set C\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x)) =\n    (\\<Sum>(r,\n        a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                           (lec_of_nsc (r *R nsc_of_atom a)))", "by (auto simp add: case_prod_beta' comp_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x)) =\n  (\\<Sum>(r,\n      a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                         (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C'. lec_of_nsc (s x *R ns x)) =\n  (\\<Sum>(r,\n      a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n                         (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "have \"lec_of_nsc (s a *R ns a) = subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_of_nsc (s a *R ns a) =\n    subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lec_of_nsc (s a *R ns a) =\n    subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))", "have \"a \\<in> set C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<in> set C", "using Cons"], ["proof (prove)\nusing this:\n  set C' \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C'. case a of\n                           (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  (\\<Sum>a\\<leftarrow>C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n  set (a # C') \\<subseteq> set C\n\ngoal (1 subgoal):\n 1. a \\<in> set C", "by simp"], ["proof (state)\nthis:\n  a \\<in> set C\n\ngoal (1 subgoal):\n 1. lec_of_nsc (s a *R ns a) =\n    subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))", "then"], ["proof (chain)\npicking this:\n  a \\<in> set C", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<in> set C\n\ngoal (1 subgoal):\n 1. lec_of_nsc (s a *R ns a) =\n    subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))", "using ns"], ["proof (prove)\nusing this:\n  a \\<in> set C\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  ns (?r, ?a) \\<in> snd ` set cs \\<and>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a)) \\<and>\n  s (?r, ?a) \\<noteq> 0 \\<and>\n  subst_poly_lec \\<sigma> (lec_of_nsc (?r *R nsc_of_atom ?a)) =\n  lec_of_nsc (s (?r, ?a) *R ns (?r, ?a))\n\ngoal (1 subgoal):\n 1. lec_of_nsc (s a *R ns a) =\n    subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))", "by auto"], ["proof (state)\nthis:\n  lec_of_nsc (s a *R ns a) =\n  subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lec_of_nsc (s a *R ns a) =\n  subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a)))\n\ngoal (1 subgoal):\n 1. \\<And>a C'.\n       \\<lbrakk>set C' \\<subseteq> set C \\<Longrightarrow>\n                (\\<Sum>(s,\n                    ns)\\<leftarrow>map (\\<lambda>(r, a).\n     (s (r, a), ns (r, a)))\n                                    C'. lec_of_nsc (s *R ns)) =\n                (\\<Sum>(r,\n                    a)\\<leftarrow>C'. subst_poly_lec \\<sigma>\n (lec_of_nsc (r *R nsc_of_atom a)));\n        set (a # C') \\<subseteq> set C\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>(s,\n                             ns)\\<leftarrow>map\n       (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n       (a # C'). lec_of_nsc (s *R ns)) =\n                         (\\<Sum>(r,\n                             a)\\<leftarrow>a #\n     C'. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) =\n  subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a))) +\n  (\\<Sum>a\\<leftarrow>C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<leftarrow>a # C'. lec_of_nsc (s x *R ns x)) =\n  subst_poly_lec \\<sigma> (lec_of_nsc (fst a *R nsc_of_atom (snd a))) +\n  (\\<Sum>a\\<leftarrow>C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                                case a of\n                                (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                         (a #\n                          C'). case a of\n                               (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n    (\\<Sum>a\\<leftarrow>a #\n                        C'. case a of\n                            (r, a) \\<Rightarrow>\n                              subst_poly_lec \\<sigma>\n                               (lec_of_nsc (r *R nsc_of_atom a)))", "by (auto simp add: case_prod_beta' comp_def)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       (a #\n                        C'). case a of\n                             (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  (\\<Sum>a\\<leftarrow>a #\n                      C'. case a of\n                          (r, a) \\<Rightarrow>\n                            subst_poly_lec \\<sigma>\n                             (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set ?C' \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>(s,\n      ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                      ?C'. lec_of_nsc (s *R ns)) =\n  (\\<Sum>(r,\n      a)\\<leftarrow>?C'. subst_poly_lec \\<sigma>\n                          (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "also"], ["proof (state)\nthis:\n  set ?C' \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>(s,\n      ns)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                      ?C'. lec_of_nsc (s *R ns)) =\n  (\\<Sum>(r,\n      a)\\<leftarrow>?C'. subst_poly_lec \\<sigma>\n                          (lec_of_nsc (r *R nsc_of_atom a)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"(\\<Sum>(r, a)\\<leftarrow>C. subst_poly_lec \\<sigma> (lec_of_nsc (r *R nsc_of_atom a)))\n             = subst_poly_lec \\<sigma> (\\<Sum>(r, a)\\<leftarrow>C. (lec_of_nsc (r *R nsc_of_atom a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        a)\\<leftarrow>C. subst_poly_lec \\<sigma>\n                          (lec_of_nsc (r *R nsc_of_atom a))) =\n    subst_poly_lec \\<sigma>\n     (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a))", "by (auto simp add: subst_poly_lec_sum_list case_prod_beta' comp_def)"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      a)\\<leftarrow>C. subst_poly_lec \\<sigma>\n                        (lec_of_nsc (r *R nsc_of_atom a))) =\n  subst_poly_lec \\<sigma>\n   (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "also"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      a)\\<leftarrow>C. subst_poly_lec \\<sigma>\n                        (lec_of_nsc (r *R nsc_of_atom a))) =\n  subst_poly_lec \\<sigma>\n   (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"(\\<Sum>(r, a)\\<leftarrow>C. (lec_of_nsc (r *R nsc_of_atom a))) = Leqc p c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel p c", "using 0"], ["proof (prove)\nusing this:\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n    Le_Constraint Leq_Rel p c", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "also"], ["proof (state)\nthis:\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"subst_poly_lec \\<sigma> (Leqc p c) = Leqc (subst_poly \\<sigma> p) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly_lec \\<sigma> (Le_Constraint Leq_Rel p c) =\n    Le_Constraint Leq_Rel (subst_poly \\<sigma> p) c", "by simp"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (Le_Constraint Leq_Rel p c) =\n  Le_Constraint Leq_Rel (subst_poly \\<sigma> p) c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "also"], ["proof (state)\nthis:\n  subst_poly_lec \\<sigma> (Le_Constraint Leq_Rel p c) =\n  Le_Constraint Leq_Rel (subst_poly \\<sigma> p) c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"subst_poly \\<sigma> p = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> p = 0", "proof (rule all_valuate_zero)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = (0::?'a)", "fix v :: \"QDelta valuation\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>v. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = (0::?'a)", "have \"(subst_poly \\<sigma> p) \\<lbrace> v \\<rbrace> = (p \\<lbrace> \\<lambda>x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>) \\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> =\n    p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "by (rule valuate_subst_poly)"], ["proof (state)\nthis:\n  subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> =\n  p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>v. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = (0::?'a)", "also"], ["proof (state)\nthis:\n  subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> =\n  p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>v. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = (0::?'a)", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace> = 0", "proof (rule 0(4))"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace>) \\<Turnstile>\\<^sub>t\n    Tableau S", "have \"(\\<sigma> a) \\<lbrace> v \\<rbrace> = (q \\<lbrace> \\<lambda>x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>) \\<rbrace>)\" if \"(a, q) \\<in> set (Tableau S)\" for a q"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "have \"distinct (map fst ?T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst (Tableau S))", "using normalized_tableau_preprocess' assms"], ["proof (prove)\nusing this:\n  \\<triangle> (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))\n  preprocess' cs (start_fresh_variable cs) = S\n  farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\n\ngoal (1 subgoal):\n 1. distinct (map fst (Tableau S))", "unfolding normalized_tableau_def lhs_def"], ["proof (prove)\nusing this:\n  distinct\n   (map (\\<lambda>uu. case uu of (l, r) \\<Rightarrow> l)\n     (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))) \\<and>\n  lvars (Tableau (preprocess' ?cs (start_fresh_variable ?cs))) \\<inter>\n  rvars (Tableau (preprocess' ?cs (start_fresh_variable ?cs))) =\n  {} \\<and>\n  0 \\<notin> rhs `\n             set (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))\n  preprocess' cs (start_fresh_variable cs) = S\n  farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\n\ngoal (1 subgoal):\n 1. distinct (map fst (Tableau S))", "by (auto simp add: case_prod_beta')"], ["proof (state)\nthis:\n  distinct (map fst (Tableau S))\n\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "then"], ["proof (chain)\npicking this:\n  distinct (map fst (Tableau S))", "have 0: \"\\<sigma> a = q\""], ["proof (prove)\nusing this:\n  distinct (map fst (Tableau S))\n\ngoal (1 subgoal):\n 1. \\<sigma> a = q", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  distinct (map fst (Tableau S))\n\ngoal (1 subgoal):\n 1. (case map_of (Tableau S) a of None \\<Rightarrow> lp_monom 1 a\n     | Some p \\<Rightarrow> p) =\n    q", "using that"], ["proof (prove)\nusing this:\n  distinct (map fst (Tableau S))\n  (a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. (case map_of (Tableau S) a of None \\<Rightarrow> lp_monom 1 a\n     | Some p \\<Rightarrow> p) =\n    q", "by auto"], ["proof (state)\nthis:\n  \\<sigma> a = q\n\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "have \"q \\<lbrace> v \\<rbrace> = (q \\<lbrace> \\<lambda>x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>) \\<rbrace>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "have \"vars q \\<subseteq> rvars ?T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars q \\<subseteq> rvars (Tableau S)", "unfolding rvars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars q \\<subseteq> \\<Union> (set (map rvars_eq (Tableau S)))", "using that"], ["proof (prove)\nusing this:\n  (a, q) \\<in> set (Tableau S)\n\ngoal (1 subgoal):\n 1. vars q \\<subseteq> \\<Union> (set (map rvars_eq (Tableau S)))", "by force"], ["proof (state)\nthis:\n  vars q \\<subseteq> rvars (Tableau S)\n\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "moreover"], ["proof (state)\nthis:\n  vars q \\<subseteq> rvars (Tableau S)\n\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "have \"(\\<sigma> x) \\<lbrace> v \\<rbrace> = v x\" if \"x \\<in> rvars ?T\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "have \"x \\<notin> lvars (Tableau S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> lvars (Tableau S)", "using that normalized_tableau_preprocess' assms"], ["proof (prove)\nusing this:\n  x \\<in> rvars (Tableau S)\n  \\<triangle> (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))\n  preprocess' cs (start_fresh_variable cs) = S\n  farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\n\ngoal (1 subgoal):\n 1. x \\<notin> lvars (Tableau S)", "unfolding normalized_tableau_def"], ["proof (prove)\nusing this:\n  x \\<in> rvars (Tableau S)\n  distinct\n   (map lhs (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))) \\<and>\n  lvars (Tableau (preprocess' ?cs (start_fresh_variable ?cs))) \\<inter>\n  rvars (Tableau (preprocess' ?cs (start_fresh_variable ?cs))) =\n  {} \\<and>\n  0 \\<notin> rhs `\n             set (Tableau (preprocess' ?cs (start_fresh_variable ?cs)))\n  preprocess' cs (start_fresh_variable cs) = S\n  farkas_coefficients_atoms_tableau (snd ` set (Atoms S)) (Tableau S) C\n\ngoal (1 subgoal):\n 1. x \\<notin> lvars (Tableau S)", "by blast"], ["proof (state)\nthis:\n  x \\<notin> lvars (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> lvars (Tableau S)", "have \"x \\<notin> fst ` set (Tableau S)\""], ["proof (prove)\nusing this:\n  x \\<notin> lvars (Tableau S)\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set (Tableau S)", "unfolding lvars_def"], ["proof (prove)\nusing this:\n  x \\<notin> set (map lhs (Tableau S))\n\ngoal (1 subgoal):\n 1. x \\<notin> fst ` set (Tableau S)", "by force"], ["proof (state)\nthis:\n  x \\<notin> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> fst ` set (Tableau S)", "have \"map_of ?T x = None\""], ["proof (prove)\nusing this:\n  x \\<notin> fst ` set (Tableau S)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) x = None", "using map_of_eq_None_iff"], ["proof (prove)\nusing this:\n  x \\<notin> fst ` set (Tableau S)\n  (map_of ?xys ?x = None) = (?x \\<notin> fst ` set ?xys)\n\ngoal (1 subgoal):\n 1. map_of (Tableau S) x = None", "by metis"], ["proof (state)\nthis:\n  map_of (Tableau S) x = None\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "then"], ["proof (chain)\npicking this:\n  map_of (Tableau S) x = None", "have \"\\<sigma> x = lp_monom 1 x\""], ["proof (prove)\nusing this:\n  map_of (Tableau S) x = None\n\ngoal (1 subgoal):\n 1. \\<sigma> x = lp_monom 1 x", "unfolding \\<sigma>_def"], ["proof (prove)\nusing this:\n  map_of (Tableau S) x = None\n\ngoal (1 subgoal):\n 1. (case map_of (Tableau S) x of None \\<Rightarrow> lp_monom 1 x\n     | Some p \\<Rightarrow> p) =\n    lp_monom 1 x", "by auto"], ["proof (state)\nthis:\n  \\<sigma> x = lp_monom 1 x\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "also"], ["proof (state)\nthis:\n  \\<sigma> x = lp_monom 1 x\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "have \"(lp_monom 1 x) \\<lbrace> v \\<rbrace> = v x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lp_monom 1 x \\<lbrace> v \\<rbrace> = v x", "by auto"], ["proof (state)\nthis:\n  lp_monom 1 x \\<lbrace> v \\<rbrace> = v x\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma> x \\<lbrace> v \\<rbrace> = v x\n\ngoal (1 subgoal):\n 1. \\<sigma> x \\<lbrace> v \\<rbrace> = v x", "."], ["proof (state)\nthis:\n  \\<sigma> x \\<lbrace> v \\<rbrace> = v x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> rvars (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?x \\<lbrace> v \\<rbrace> = v ?x\n\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  vars q \\<subseteq> rvars (Tableau S)\n  ?x \\<in> rvars (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?x \\<lbrace> v \\<rbrace> = v ?x", "show ?thesis"], ["proof (prove)\nusing this:\n  vars q \\<subseteq> rvars (Tableau S)\n  ?x \\<in> rvars (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?x \\<lbrace> v \\<rbrace> = v ?x\n\ngoal (1 subgoal):\n 1. q \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "by (auto intro!: valuate_depend)"], ["proof (state)\nthis:\n  q \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "then"], ["proof (chain)\npicking this:\n  q \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  q \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "using 0"], ["proof (prove)\nusing this:\n  q \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n  \\<sigma> a = q\n\ngoal (1 subgoal):\n 1. \\<sigma> a \\<lbrace> v \\<rbrace> =\n    q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "by blast"], ["proof (state)\nthis:\n  \\<sigma> a \\<lbrace> v \\<rbrace> =\n  q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (?a, ?q) \\<in> set (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?a \\<lbrace> v \\<rbrace> =\n  ?q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace>) \\<Turnstile>\\<^sub>t\n    Tableau S", "then"], ["proof (chain)\npicking this:\n  (?a, ?q) \\<in> set (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?a \\<lbrace> v \\<rbrace> =\n  ?q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>", "show \"(\\<lambda>x. ((\\<sigma> x) \\<lbrace> v \\<rbrace>)) \\<Turnstile>\\<^sub>t ?T\""], ["proof (prove)\nusing this:\n  (?a, ?q) \\<in> set (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?a \\<lbrace> v \\<rbrace> =\n  ?q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace>) \\<Turnstile>\\<^sub>t\n    Tableau S", "using 0"], ["proof (prove)\nusing this:\n  (?a, ?q) \\<in> set (Tableau S) \\<Longrightarrow>\n  \\<sigma> ?a \\<lbrace> v \\<rbrace> =\n  ?q \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace>\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace>) \\<Turnstile>\\<^sub>t\n    Tableau S", "by (auto simp add: satisfies_tableau_def satisfies_eq_def)"], ["proof (state)\nthis:\n  (\\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace>) \\<Turnstile>\\<^sub>t\n  Tableau S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p \\<lbrace> \\<lambda>x. \\<sigma> x \\<lbrace> v \\<rbrace> \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. \\<And>v. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = (0::?'a)", "finally"], ["proof (chain)\npicking this:\n  subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = 0", "show \"(subst_poly \\<sigma> p) \\<lbrace> v \\<rbrace> = 0\""], ["proof (prove)\nusing this:\n  subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = 0", "."], ["proof (state)\nthis:\n  subst_poly \\<sigma> p \\<lbrace> v \\<rbrace> = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst_poly \\<sigma> p = 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "finally"], ["proof (chain)\npicking this:\n  set C \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C. case a of\n                          (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  Le_Constraint Leq_Rel 0 c", "have \"(\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) = Le_Constraint Leq_Rel 0 c\""], ["proof (prove)\nusing this:\n  set C \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C. case a of\n                          (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. (\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) =\n    Le_Constraint Leq_Rel 0 c", "unfolding NC_def"], ["proof (prove)\nusing this:\n  set C \\<subseteq> set C \\<Longrightarrow>\n  (\\<Sum>a\\<leftarrow>map (\\<lambda>a.\n                              case a of\n                              (r, a) \\<Rightarrow> (s (r, a), ns (r, a)))\n                       C. case a of\n                          (s, ns) \\<Rightarrow> lec_of_nsc (s *R ns)) =\n  Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. (\\<Sum>(s,\n        n)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                       C. lec_of_nsc (s *R n)) =\n    Le_Constraint Leq_Rel 0 c", "by blast"], ["proof (state)\nthis:\n  (\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "have \"ns (r,a) \\<in> snd ` set cs\" \"is_leq_ns (s (r, a) *R ns (r, a))\" \"s (r, a) \\<noteq> 0\" if \"(r, a) \\<in> set C\" for r a"], ["proof (prove)\ngoal (1 subgoal):\n 1. ns (r, a) \\<in> snd ` set cs &&&\n    is_leq_ns (s (r, a) *R ns (r, a)) &&& s (r, a) \\<noteq> 0", "using ns that"], ["proof (prove)\nusing this:\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  ns (?r, ?a) \\<in> snd ` set cs \\<and>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a)) \\<and>\n  s (?r, ?a) \\<noteq> 0 \\<and>\n  subst_poly_lec \\<sigma> (lec_of_nsc (?r *R nsc_of_atom ?a)) =\n  lec_of_nsc (s (?r, ?a) *R ns (?r, ?a))\n  (r, a) \\<in> set C\n\ngoal (1 subgoal):\n 1. ns (r, a) \\<in> snd ` set cs &&&\n    is_leq_ns (s (r, a) *R ns (r, a)) &&& s (r, a) \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  (?r, ?a) \\<in> set C \\<Longrightarrow> ns (?r, ?a) \\<in> snd ` set cs\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a))\n  (?r, ?a) \\<in> set C \\<Longrightarrow> s (?r, ?a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  (?r, ?a) \\<in> set C \\<Longrightarrow> ns (?r, ?a) \\<in> snd ` set cs\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a))\n  (?r, ?a) \\<in> set C \\<Longrightarrow> s (?r, ?a) \\<noteq> 0", "have \"farkas_coefficients_ns (snd ` set cs) NC\""], ["proof (prove)\nusing this:\n  (\\<Sum>(s, n)\\<leftarrow>NC. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  (?r, ?a) \\<in> set C \\<Longrightarrow> ns (?r, ?a) \\<in> snd ` set cs\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a))\n  (?r, ?a) \\<in> set C \\<Longrightarrow> s (?r, ?a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. farkas_coefficients_ns (snd ` set cs) NC", "unfolding farkas_coefficients_ns_def NC_def"], ["proof (prove)\nusing this:\n  (\\<Sum>(s,\n      n)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                     C. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  (?r, ?a) \\<in> set C \\<Longrightarrow> ns (?r, ?a) \\<in> snd ` set cs\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a))\n  (?r, ?a) \\<in> set C \\<Longrightarrow> s (?r, ?a) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<forall>(r, n)\n                 \\<in>set (map (\\<lambda>(r, a). (s (r, a), ns (r, a))) C).\n           n \\<in> snd ` set cs \\<and>\n           is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r,\n           n)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                          C. lec_of_nsc (r *R n)) =\n       Le_Constraint Leq_Rel 0 c \\<and>\n       c < 0", "using 0"], ["proof (prove)\nusing this:\n  (\\<Sum>(s,\n      n)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                     C. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 c\n  (?r, ?a) \\<in> set C \\<Longrightarrow> ns (?r, ?a) \\<in> snd ` set cs\n  (?r, ?a) \\<in> set C \\<Longrightarrow>\n  is_leq_ns (s (?r, ?a) *R ns (?r, ?a))\n  (?r, ?a) \\<in> set C \\<Longrightarrow> s (?r, ?a) \\<noteq> 0\n  (?a2, ?b2) \\<in> set C \\<Longrightarrow>\n  ?b2 \\<in> snd ` set (Atoms S) \\<and>\n  is_leq_ns (?a2 *R nsc_of_atom ?b2) \\<and> ?a2 \\<noteq> 0\n  (\\<Sum>(r, a)\\<leftarrow>C. lec_of_nsc (r *R nsc_of_atom a)) =\n  Le_Constraint Leq_Rel p c\n  c < 0\n  ?v \\<Turnstile>\\<^sub>t Tableau S \\<Longrightarrow>\n  p \\<lbrace> ?v \\<rbrace> = 0\n\ngoal (1 subgoal):\n 1. \\<exists>c.\n       (\\<forall>(r, n)\n                 \\<in>set (map (\\<lambda>(r, a). (s (r, a), ns (r, a))) C).\n           n \\<in> snd ` set cs \\<and>\n           is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r,\n           n)\\<leftarrow>map (\\<lambda>(r, a). (s (r, a), ns (r, a)))\n                          C. lec_of_nsc (r *R n)) =\n       Le_Constraint Leq_Rel 0 c \\<and>\n       c < 0", "by force"], ["proof (state)\nthis:\n  farkas_coefficients_ns (snd ` set cs) NC\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "then"], ["proof (chain)\npicking this:\n  farkas_coefficients_ns (snd ` set cs) NC", "show ?thesis"], ["proof (prove)\nusing this:\n  farkas_coefficients_ns (snd ` set cs) NC\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set cs) C", "by blast"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns (snd ` set cs) C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma preprocess'_unsat_indexD: \"i \\<in> set (UnsatIndices (preprocess' ns j)) \\<Longrightarrow> \n  \\<exists> c. poly c = 0 \\<and> \\<not> zero_satisfies c \\<and> (i,c) \\<in> set ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> set (UnsatIndices (preprocess' ns j)) \\<Longrightarrow>\n    \\<exists>c.\n       poly c = 0 \\<and> \\<not> zero_satisfies c \\<and> (i, c) \\<in> set ns", "by (induct ns j rule: preprocess'.induct, auto simp: Let_def split: if_splits option.splits)"], ["", "lemma preprocess'_unsat_index_farkas_coefficients_ns: \n  assumes \"i \\<in> set (UnsatIndices (preprocess' ns j))\" \n  shows \"\\<exists> C. farkas_coefficients_ns (snd ` set ns) C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "from preprocess'_unsat_indexD[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     poly c = 0 \\<and> \\<not> zero_satisfies c \\<and> (i, c) \\<in> set ns", "obtain c where contr: \"poly c = 0\" \"\\<not> zero_satisfies c\" and mem: \"(i,c) \\<in> set ns\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     poly c = 0 \\<and> \\<not> zero_satisfies c \\<and> (i, c) \\<in> set ns\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>poly c = 0; \\<not> zero_satisfies c;\n         (i, c) \\<in> set ns\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  poly c = 0\n  \\<not> zero_satisfies c\n  (i, c) \\<in> set ns\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "from mem"], ["proof (chain)\npicking this:\n  (i, c) \\<in> set ns", "have mem: \"c \\<in> snd ` set ns\""], ["proof (prove)\nusing this:\n  (i, c) \\<in> set ns\n\ngoal (1 subgoal):\n 1. c \\<in> snd ` set ns", "by force"], ["proof (state)\nthis:\n  c \\<in> snd ` set ns\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "let ?c = \"ns_constraint_const c\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "define r where \"r = (case c of LEQ_ns _ _ \\<Rightarrow> 1 | _ \\<Rightarrow> (-1 :: rat))\""], ["proof (state)\nthis:\n  r =\n  (case c of LEQ_ns x xa \\<Rightarrow> 1\n   | GEQ_ns linear_poly a \\<Rightarrow> - 1)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "define d where \"d = (case c of LEQ_ns _ _ \\<Rightarrow> ?c | _ \\<Rightarrow> - ?c)\""], ["proof (state)\nthis:\n  d =\n  (case c of LEQ_ns x xa \\<Rightarrow> ns_constraint_const c\n   | GEQ_ns linear_poly a \\<Rightarrow> - ns_constraint_const c)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "have [simp]: \"(- x < 0) = (0 < x)\" for x :: QDelta"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- x < 0) = (0 < x)", "using uminus_less_lrv[of _ 0]"], ["proof (prove)\nusing this:\n  (- ?a < - (0::?'b1)) = ((0::?'b1) < ?a)\n\ngoal (1 subgoal):\n 1. (- x < 0) = (0 < x)", "by simp"], ["proof (state)\nthis:\n  (- ?x < 0) = (0 < ?x)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set ns) C", "unfolding farkas_coefficients_ns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C c.\n       (\\<forall>(r, n)\\<in>set C.\n           n \\<in> snd ` set ns \\<and>\n           is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, n)\\<leftarrow>C. lec_of_nsc (r *R n)) =\n       Le_Constraint Leq_Rel 0 c \\<and>\n       c < 0", "by (intro exI[of _ \"[(r,c)]\"] exI[of _ d], insert mem contr, cases \"c\", \n        auto simp: r_def d_def)"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns (snd ` set ns) C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The combination of the previous results easily provides the main result of this section:\n  a finite set of non-strict constraints on layer~2 is unsatisfiable if and only if there are Farkas coefficients.\n  Again, here we use results from the simplex formalization, namely soundness of the preprocess-function.\\<close>"], ["", "lemma farkas_coefficients_ns: assumes \"finite (ns :: QDelta ns_constraint set)\" \n  shows \"(\\<exists> C. farkas_coefficients_ns ns C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C. farkas_coefficients_ns ns C) =\n    (\\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_ns ns C \\<Longrightarrow>\n    \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "assume \"\\<exists> C. farkas_coefficients_ns ns C\""], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns ns C\n\ngoal (2 subgoals):\n 1. \\<exists>C. farkas_coefficients_ns ns C \\<Longrightarrow>\n    \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n 2. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "from farkas_coefficients_ns_unsat this"], ["proof (chain)\npicking this:\n  farkas_coefficients_ns ?ns ?C \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ?ns\n  \\<exists>C. farkas_coefficients_ns ns C", "show \"\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\""], ["proof (prove)\nusing this:\n  farkas_coefficients_ns ?ns ?C \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ?ns\n  \\<exists>C. farkas_coefficients_ns ns C\n\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns", "by blast"], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "assume unsat: \"\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ns\""], ["proof (state)\nthis:\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "from finite_list[OF assms]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = ns", "obtain nsl where ns: \"ns = set nsl\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = ns\n\ngoal (1 subgoal):\n 1. (\\<And>nsl. ns = set nsl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ns = set nsl\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "let ?cs = \"map (Pair ()) nsl\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "obtain I t ias where part1: \"preprocess_part_1 ?cs = (t,ias,I)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t ias I.\n        preprocess_part_1 (map (Pair ()) nsl) =\n        (t, ias, I) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"preprocess_part_1 ?cs\", auto)"], ["proof (state)\nthis:\n  preprocess_part_1 (map (Pair ()) nsl) = (t, ias, I)\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "let ?as = \"snd ` set ias\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "let ?s = \"start_fresh_variable ?cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "have fin: \"finite ?as\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snd ` set ias)", "by auto"], ["proof (state)\nthis:\n  finite (snd ` set ias)\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "have id: \"ias = Atoms (preprocess' ?cs ?s)\" \"t = Tableau (preprocess' ?cs ?s)\" \n    \"I = UnsatIndices (preprocess' ?cs ?s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ias =\n    Atoms\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    t =\n    Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    I =\n    UnsatIndices\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl)))", "using part1"], ["proof (prove)\nusing this:\n  preprocess_part_1 (map (Pair ()) nsl) = (t, ias, I)\n\ngoal (1 subgoal):\n 1. ias =\n    Atoms\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    t =\n    Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    I =\n    UnsatIndices\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl)))", "unfolding preprocess_part_1_def Let_def"], ["proof (prove)\nusing this:\n  (Tableau\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl))),\n   Atoms\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl))),\n   UnsatIndices\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl)))) =\n  (t, ias, I)\n\ngoal (1 subgoal):\n 1. ias =\n    Atoms\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    t =\n    Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))) &&&\n    I =\n    UnsatIndices\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl)))", "by auto"], ["proof (state)\nthis:\n  ias =\n  Atoms\n   (preprocess' (map (Pair ()) nsl)\n     (start_fresh_variable (map (Pair ()) nsl)))\n  t =\n  Tableau\n   (preprocess' (map (Pair ()) nsl)\n     (start_fresh_variable (map (Pair ()) nsl)))\n  I =\n  UnsatIndices\n   (preprocess' (map (Pair ()) nsl)\n     (start_fresh_variable (map (Pair ()) nsl)))\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "have norm: \"\\<triangle> t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<triangle> t", "using normalized_tableau_preprocess'[of ?cs]"], ["proof (prove)\nusing this:\n  \\<triangle>\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n\ngoal (1 subgoal):\n 1. \\<triangle> t", "unfolding  id"], ["proof (prove)\nusing this:\n  \\<triangle>\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n\ngoal (1 subgoal):\n 1. \\<triangle>\n     (Tableau\n       (preprocess' (map (Pair ()) nsl)\n         (start_fresh_variable (map (Pair ()) nsl))))", "."], ["proof (state)\nthis:\n  \\<triangle> t\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "{"], ["proof (state)\nthis:\n  \\<triangle> t\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "assume \"v \\<Turnstile>\\<^sub>a\\<^sub>s ?as\" \"v \\<Turnstile>\\<^sub>t t\""], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias)\n  v \\<Turnstile>\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "from preprocess'_sat[OF this[unfolded id], folded id] unsat[unfolded ns]"], ["proof (chain)\npicking this:\n  set I = {} \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  (snd ` set (map (Pair ()) nsl))\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  set nsl", "have \"set I \\<noteq> {}\""], ["proof (prove)\nusing this:\n  set I = {} \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  (snd ` set (map (Pair ()) nsl))\n  \\<nexists>v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  set nsl\n\ngoal (1 subgoal):\n 1. set I \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  set I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "then"], ["proof (chain)\npicking this:\n  set I \\<noteq> {}", "obtain i where \"i \\<in> set I\""], ["proof (prove)\nusing this:\n  set I \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> set I \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using all_not_in_conv"], ["proof (prove)\nusing this:\n  set I \\<noteq> {}\n  (\\<forall>x. x \\<notin> ?A) = (?A = {})\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> set I \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  i \\<in> set I\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "from preprocess'_unsat_index_farkas_coefficients_ns[OF this[unfolded id]]"], ["proof (chain)\npicking this:\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C", "have \"\\<exists>C. farkas_coefficients_ns (snd ` set ?cs) C\""], ["proof (prove)\nusing this:\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C", "by simp"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "}"], ["proof (state)\nthis:\n  \\<lbrakk>?v2 \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias);\n   ?v2 \\<Turnstile>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>C.\n                       farkas_coefficients_ns\n                        (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "with farkas_coefficients_atoms_tableau[OF norm fin]"], ["proof (chain)\npicking this:\n  (\\<exists>C. farkas_coefficients_atoms_tableau (snd ` set ias) t C) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>t t \\<and>\n      v \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias))\n  \\<lbrakk>?v2 \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias);\n   ?v2 \\<Turnstile>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>C.\n                       farkas_coefficients_ns\n                        (snd ` set (map (Pair ()) nsl)) C", "obtain C where \"farkas_coefficients_atoms_tableau ?as t C\n     \\<or> (\\<exists>C. farkas_coefficients_ns (snd ` set ?cs) C)\""], ["proof (prove)\nusing this:\n  (\\<exists>C. farkas_coefficients_atoms_tableau (snd ` set ias) t C) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>t t \\<and>\n      v \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias))\n  \\<lbrakk>?v2 \\<Turnstile>\\<^sub>a\\<^sub>s (snd ` set ias);\n   ?v2 \\<Turnstile>\\<^sub>t t\\<rbrakk>\n  \\<Longrightarrow> \\<exists>C.\n                       farkas_coefficients_ns\n                        (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n        (\\<exists>C.\n            farkas_coefficients_ns (snd ` set (map (Pair ()) nsl))\n             C) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n  (\\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C)\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "from farkas_coefficients_preprocess'[of ?cs, OF refl] this"], ["proof (chain)\npicking this:\n  farkas_coefficients_atoms_tableau\n   (snd `\n    set (Atoms\n          (preprocess' (map (Pair ()) nsl)\n            (start_fresh_variable (map (Pair ()) nsl)))))\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n   ?C \\<Longrightarrow>\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n  farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n  (\\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C)", "have \"\\<exists> C. farkas_coefficients_ns (snd ` set ?cs) C\""], ["proof (prove)\nusing this:\n  farkas_coefficients_atoms_tableau\n   (snd `\n    set (Atoms\n          (preprocess' (map (Pair ()) nsl)\n            (start_fresh_variable (map (Pair ()) nsl)))))\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n   ?C \\<Longrightarrow>\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n  farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n  (\\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C", "using part1"], ["proof (prove)\nusing this:\n  farkas_coefficients_atoms_tableau\n   (snd `\n    set (Atoms\n          (preprocess' (map (Pair ()) nsl)\n            (start_fresh_variable (map (Pair ()) nsl)))))\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n   ?C \\<Longrightarrow>\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n  farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n  (\\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C)\n  preprocess_part_1 (map (Pair ()) nsl) = (t, ias, I)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C", "unfolding preprocess_part_1_def Let_def"], ["proof (prove)\nusing this:\n  farkas_coefficients_atoms_tableau\n   (snd `\n    set (Atoms\n          (preprocess' (map (Pair ()) nsl)\n            (start_fresh_variable (map (Pair ()) nsl)))))\n   (Tableau\n     (preprocess' (map (Pair ()) nsl)\n       (start_fresh_variable (map (Pair ()) nsl))))\n   ?C \\<Longrightarrow>\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n  farkas_coefficients_atoms_tableau (snd ` set ias) t C \\<or>\n  (\\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C)\n  (Tableau\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl))),\n   Atoms\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl))),\n   UnsatIndices\n    (preprocess' (map (Pair ()) nsl)\n      (start_fresh_variable (map (Pair ()) nsl)))) =\n  (t, ias, I)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C", "by auto"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "also"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns (snd ` set (map (Pair ()) nsl)) C\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "have \"snd ` set ?cs = ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) nsl) = ns", "unfolding ns"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) nsl) = set nsl", "by force"], ["proof (state)\nthis:\n  snd ` set (map (Pair ()) nsl) = ns\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s  ns \\<Longrightarrow>\n    \\<exists>C. farkas_coefficients_ns ns C", "finally"], ["proof (chain)\npicking this:\n  \\<exists>C. farkas_coefficients_ns ns C", "show \"\\<exists> C. farkas_coefficients_ns ns C\""], ["proof (prove)\nusing this:\n  \\<exists>C. farkas_coefficients_ns ns C\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients_ns ns C", "."], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients_ns ns C\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Farkas' Lemma on Layer 1\\<close>"], ["", "text \\<open>The main difference of layers 1 and 2 is the restriction to non-strict constraints via delta-rationals.\n  Since we now work with another constraint type, @{type constraint}, we again need translations into\n  linear inequalities of type @{type le_constraint}. Moreover, we also need to define scaling of constraints\n  where flipping the comparison sign may be required.\\<close>"], ["", "fun is_le :: \"constraint \\<Rightarrow> bool\" where\n  \"is_le (LT _ _) = True\" \n| \"is_le (LEQ _ _) = True\" \n| \"is_le _ = False\""], ["", "fun lec_of_constraint where\n  \"lec_of_constraint (LEQ p c) = (Le_Constraint Leq_Rel p c)\"\n| \"lec_of_constraint (LT p c) = (Le_Constraint Lt_Rel p c)\""], ["", "lemma lec_of_constraint: \n  assumes \"is_le c\"\n  shows \"(v \\<Turnstile>\\<^sub>l\\<^sub>e (lec_of_constraint c)) \\<longleftrightarrow> (v \\<Turnstile>\\<^sub>c c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint c =\n    v \\<Turnstile>\\<^sub>c c", "using assms"], ["proof (prove)\nusing this:\n  is_le c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint c =\n    v \\<Turnstile>\\<^sub>c c", "by (cases c, auto)"], ["", "instantiation constraint :: scaleRat\nbegin"], ["", "fun scaleRat_constraint :: \"rat \\<Rightarrow> constraint \\<Rightarrow> constraint\" where\n  \"scaleRat_constraint r cc = (if r = 0 then LEQ 0 0 else \n  (case cc of \n    LEQ p c \\<Rightarrow>\n     (if (r < 0) then GEQ (r *R p) (r *R c) else LEQ (r *R p) (r *R c))\n  | LT p c \\<Rightarrow>\n     (if (r < 0) then GT (r *R p) (r *R c) else LT (r *R p) (r *R c))\n  | GEQ p c \\<Rightarrow> \n    (if (r > 0) then GEQ (r *R p) (r *R c) else LEQ (r *R p) (r *R c))\n  | GT p c \\<Rightarrow> \n    (if (r > 0) then GT (r *R p) (r *R c) else LT (r *R p) (r *R c))\n  | LTPP p q \\<Rightarrow>\n     (if (r < 0) then GT (r *R (p - q)) 0 else LT (r *R (p - q)) 0)\n  | LEQPP p q \\<Rightarrow>\n     (if (r < 0) then GEQ (r *R (p - q)) 0 else LEQ (r *R (p - q)) 0)\n  | GTPP p q \\<Rightarrow>\n     (if (r > 0) then GT (r *R (p - q)) 0 else LT (r *R (p - q)) 0)\n  | GEQPP p q \\<Rightarrow>\n     (if (r > 0) then GEQ (r *R (p - q)) 0 else LEQ (r *R (p - q)) 0)\n  | EQPP p q \\<Rightarrow> LEQ (r *R (p - q)) 0 \\<comment> \\<open>We do not keep equality, since the aim is \n        to convert the scaled constraints into inequalities, which will then be summed up.\\<close>\n  | EQ p c \\<Rightarrow> LEQ (r *R p) (r *R c) \n))\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(constraint, scaleRat_class)", ".."], ["", "end"], ["", "lemma sat_scale_rat: assumes \"(v :: rat valuation) \\<Turnstile>\\<^sub>c c\"\n  shows \"v \\<Turnstile>\\<^sub>c (r *R c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "have \"r < 0 \\<or> r = 0 \\<or> r > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. r < 0 \\<or> r = 0 \\<or> 0 < r", "by auto"], ["proof (state)\nthis:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "then"], ["proof (chain)\npicking this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r", "show ?thesis"], ["proof (prove)\nusing this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "using assms"], ["proof (prove)\nusing this:\n  r < 0 \\<or> r = 0 \\<or> 0 < r\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "by (cases c, auto simp: right_diff_distrib \n        valuate_minus valuate_scaleRat scaleRat_leq1 scaleRat_leq2 valuate_zero)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>In the following definition of Farkas coefficients (for layer 1), the main difference to\n  @{const farkas_coefficients_ns} is that the linear combination evaluates either to\n  a strict inequality where the constant must be non-positive, or to a non-strict inequality where\n  the constant must be negative.\\<close>"], ["", "definition farkas_coefficients where \n  \"farkas_coefficients cs C = (\\<exists> d rel. \n    (\\<forall> (r,c) \\<in> set C. c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n    (\\<Sum> (r,c) \\<leftarrow> C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d \\<and> \n    (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0))\""], ["", "text \\<open>Again, the existence Farkas coefficients immediately implies unsatisfiability.\\<close>"], ["", "lemma farkas_coefficients_unsat: \n  assumes \"farkas_coefficients cs C\" \n  shows \"\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "assume \"\\<exists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (state)\nthis:\n  \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs", "obtain v where *: \"v \\<Turnstile>\\<^sub>c\\<^sub>s cs\""], ["proof (prove)\nusing this:\n  \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "obtain d rel where\n    isleq: \"(\\<forall>(r,c) \\<in> set C. c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0)\" and\n    leq: \"(\\<Sum> (r,c) \\<leftarrow> C. lec_of_constraint (r *R c)) = Le_Constraint rel 0 d\" and\n    choice: \"rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rel d.\n        \\<lbrakk>\\<forall>(r, c)\\<in>set C.\n                    c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n         Le_Constraint rel 0 d;\n         rel = Lt_Rel \\<and> d \\<le> 0 \\<or>\n         rel = Leq_Rel \\<and> d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms farkas_coefficients_def"], ["proof (prove)\nusing this:\n  farkas_coefficients cs C\n  farkas_coefficients ?cs ?C =\n  (\\<exists>d rel.\n      (\\<forall>(r, c)\\<in>set ?C.\n          c \\<in> ?cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n      (\\<Sum>(r, c)\\<leftarrow>?C. lec_of_constraint (r *R c)) =\n      Le_Constraint rel 0 d \\<and>\n      (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0))\n\ngoal (1 subgoal):\n 1. (\\<And>rel d.\n        \\<lbrakk>\\<forall>(r, c)\\<in>set C.\n                    c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0;\n         (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n         Le_Constraint rel 0 d;\n         rel = Lt_Rel \\<and> d \\<le> 0 \\<or>\n         rel = Leq_Rel \\<and> d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n  Le_Constraint rel 0 d\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "{"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n  (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n  Le_Constraint rel 0 d\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "fix r c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "assume c: \"(r,c) \\<in> set C\""], ["proof (state)\nthis:\n  (r, c) \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from c * isleq"], ["proof (chain)\npicking this:\n  (r, c) \\<in> set C\n  v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0", "have \"v \\<Turnstile>\\<^sub>c c\""], ["proof (prove)\nusing this:\n  (r, c) \\<in> set C\n  v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c c", "by auto"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "hence v: \"v \\<Turnstile>\\<^sub>c (r *R c)\""], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>c c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c (r *R c)", "by (rule sat_scale_rat)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from c isleq"], ["proof (chain)\npicking this:\n  (r, c) \\<in> set C\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0", "have \"is_le (r *R c)\""], ["proof (prove)\nusing this:\n  (r, c) \\<in> set C\n  \\<forall>(r, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_le (r *R c)", "by auto"], ["proof (state)\nthis:\n  is_le (r *R c)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "from lec_of_constraint[OF this] v"], ["proof (chain)\npicking this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (r *R c) =\n  ?v \\<Turnstile>\\<^sub>c (r *R c)\n  v \\<Turnstile>\\<^sub>c (r *R c)", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (r *R c)\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (r *R c) =\n  ?v \\<Turnstile>\\<^sub>c (r *R c)\n  v \\<Turnstile>\\<^sub>c (r *R c)\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (r *R c)", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (r *R c)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "}"], ["proof (state)\nthis:\n  (?r2, ?c2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (?r2 *R ?c2)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "note v = this"], ["proof (state)\nthis:\n  (?r2, ?c2) \\<in> set C \\<Longrightarrow>\n  v \\<Turnstile>\\<^sub>l\\<^sub>e lec_of_constraint (?r2 *R ?c2)\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "have \"v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d", "unfolding leq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>l\\<^sub>e\n    (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c))", "by (rule satisfies_sumlist_le_constraints, insert v, auto)"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d\n\ngoal (1 subgoal):\n 1. \\<exists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d\n\ngoal (1 subgoal):\n 1. False", "using choice"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>l\\<^sub>e Le_Constraint rel 0 d\n  rel = Lt_Rel \\<and> d \\<le> 0 \\<or> rel = Leq_Rel \\<and> d < 0\n\ngoal (1 subgoal):\n 1. False", "by (cases rel, auto simp: valuate_zero)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Now follows the difficult implication. \n  The major part is proving that the translation @{const constraint_to_qdelta_constraint} \n  preserves the existence of Farkas coefficients via pointwise compatibility of the sum.\n  Here, compatibility links a strict or non-strict inequality from the input constraint to\n  a translated non-strict inequality over delta-rationals.\\<close>"], ["", "fun compatible_cs where \n  \"compatible_cs (Le_Constraint Leq_Rel p c) (Le_Constraint Leq_Rel q d) = (q = p \\<and> d = QDelta c 0)\" \n| \"compatible_cs (Le_Constraint Lt_Rel p c) (Le_Constraint Leq_Rel q d) = (q = p \\<and> qdfst d = c)\" \n| \"compatible_cs _ _ = False\""], ["", "lemma compatible_cs_0_0: \"compatible_cs 0 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible_cs 0 0", "by code_simp"], ["", "lemma compatible_cs_plus: \"compatible_cs c1 d1 \\<Longrightarrow> compatible_cs c2 d2 \\<Longrightarrow> compatible_cs (c1 + c2) (d1 + d2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>compatible_cs c1 d1; compatible_cs c2 d2\\<rbrakk>\n    \\<Longrightarrow> compatible_cs (c1 + c2) (d1 + d2)", "by (cases c1; cases d1; cases c2; cases d2; cases \"lec_rel c1\"; cases \"lec_rel d1\"; cases \"lec_rel c2\"; \n      cases \"lec_rel d2\"; auto simp: plus_QDelta_def)"], ["", "lemma unsat_farkas_coefficients: assumes \"\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\" \n  and fin: \"finite cs\" \nshows \"\\<exists> C. farkas_coefficients cs C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "from finite_list[OF fin]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = cs", "obtain csl where cs: \"cs = set csl\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = cs\n\ngoal (1 subgoal):\n 1. (\\<And>csl. cs = set csl \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  cs = set csl\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "let ?csl = \"map (Pair ()) csl\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "let ?ns = \"(snd ` set (to_ns ?csl))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "let ?nsl = \"concat (map constraint_to_qdelta_constraint csl)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have id: \"snd ` set ?csl = cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) csl) = cs", "unfolding cs"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (map (Pair ()) csl) = set csl", "by force"], ["proof (state)\nthis:\n  snd ` set (map (Pair ()) csl) = cs\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have id2: \"?ns = set ?nsl\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd ` set (to_ns (map (Pair ()) csl)) =\n    set (concat (map constraint_to_qdelta_constraint csl))", "unfolding to_ns_def set_concat"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd `\n    \\<Union>\n     (set `\n      set (map i_constraint_to_qdelta_constraint (map (Pair ()) csl))) =\n    \\<Union> (set ` set (map constraint_to_qdelta_constraint csl))", "by force"], ["proof (state)\nthis:\n  snd ` set (to_ns (map (Pair ()) csl)) =\n  set (concat (map constraint_to_qdelta_constraint csl))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "from SolveExec'Default.to_ns_sat[of ?csl, unfolded id] assms"], ["proof (chain)\npicking this:\n  \\<langle>?v'\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n  \\<langle>from_ns ?v'\n            (map snd\n              (to_ns\n                (map (Pair ()) csl)))\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  cs\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n  finite cs", "have unsat: \"\\<nexists> v. \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns\""], ["proof (prove)\nusing this:\n  \\<langle>?v'\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n  \\<langle>from_ns ?v'\n            (map snd\n              (to_ns\n                (map (Pair ()) csl)))\\<rangle> \\<Turnstile>\\<^sub>c\\<^sub>s\n  cs\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs\n  finite cs\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl)))", "by metis"], ["proof (state)\nthis:\n  \\<nexists>v.\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have fin: \"finite ?ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (snd ` set (to_ns (map (Pair ()) csl)))", "by auto"], ["proof (state)\nthis:\n  finite (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have \"\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n    False", "assume \"\\<exists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns\""], ["proof (state)\nthis:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))", "obtain v where model: \"v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns\""], ["proof (prove)\nusing this:\n  \\<exists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n        (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n    False", "let ?v = \"Mapping.Mapping (\\<lambda> x. Some (v x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n    False", "have \"v = \\<langle>?v\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v = \\<langle>mapping.Mapping (\\<lambda>x. Some (v x))\\<rangle>", "by (intro ext, auto simp: map2fun_def Mapping.lookup.abs_eq)"], ["proof (state)\nthis:\n  v = \\<langle>mapping.Mapping (\\<lambda>x. Some (v x))\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>v.\n       v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n       (snd ` set (to_ns (map (Pair ()) csl))) \\<Longrightarrow>\n    False", "from model this unsat"], ["proof (chain)\npicking this:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  (snd ` set (to_ns (map (Pair ()) csl)))\n  v = \\<langle>mapping.Mapping (\\<lambda>x. Some (v x))\\<rangle>\n  \\<nexists>v.\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))", "show False"], ["proof (prove)\nusing this:\n  v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  (snd ` set (to_ns (map (Pair ()) csl)))\n  v = \\<langle>mapping.Mapping (\\<lambda>x. Some (v x))\\<rangle>\n  \\<nexists>v.\n     \\<langle>v\\<rangle> \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "from farkas_coefficients_ns[OF fin] this id2"], ["proof (chain)\npicking this:\n  (\\<exists>C.\n      farkas_coefficients_ns (snd ` set (to_ns (map (Pair ()) csl))) C) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      (snd ` set (to_ns (map (Pair ()) csl))))\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n  snd ` set (to_ns (map (Pair ()) csl)) =\n  set (concat (map constraint_to_qdelta_constraint csl))", "obtain N where\n    farkas: \"farkas_coefficients_ns (set ?nsl) N\""], ["proof (prove)\nusing this:\n  (\\<exists>C.\n      farkas_coefficients_ns (snd ` set (to_ns (map (Pair ()) csl))) C) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      (snd ` set (to_ns (map (Pair ()) csl))))\n  \\<nexists>v.\n     v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n     (snd ` set (to_ns (map (Pair ()) csl)))\n  snd ` set (to_ns (map (Pair ()) csl)) =\n  set (concat (map constraint_to_qdelta_constraint csl))\n\ngoal (1 subgoal):\n 1. (\\<And>N.\n        farkas_coefficients_ns\n         (set (concat (map constraint_to_qdelta_constraint csl)))\n         N \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  farkas_coefficients_ns\n   (set (concat (map constraint_to_qdelta_constraint csl))) N\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "from this[unfolded farkas_coefficients_ns_def]"], ["proof (chain)\npicking this:\n  \\<exists>c.\n     (\\<forall>(r, n)\\<in>set N.\n         n \\<in> set (concat\n                       (map constraint_to_qdelta_constraint csl)) \\<and>\n         is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, n)\\<leftarrow>N. lec_of_nsc (r *R n)) =\n     Le_Constraint Leq_Rel 0 c \\<and>\n     c < 0", "obtain d where \n    is_leq: \"\\<And> a n. (a,n) \\<in> set N \\<Longrightarrow> n \\<in> set ?nsl \\<and> is_leq_ns (a *R n) \\<and> a \\<noteq> 0\" and \n    sum: \"(\\<Sum>(a,n)\\<leftarrow>N. lec_of_nsc (a *R n)) = Le_Constraint Leq_Rel 0 d\" and\n    d0: \"d < 0\""], ["proof (prove)\nusing this:\n  \\<exists>c.\n     (\\<forall>(r, n)\\<in>set N.\n         n \\<in> set (concat\n                       (map constraint_to_qdelta_constraint csl)) \\<and>\n         is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, n)\\<leftarrow>N. lec_of_nsc (r *R n)) =\n     Le_Constraint Leq_Rel 0 c \\<and>\n     c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>\\<And>a n.\n                    (a, n) \\<in> set N \\<Longrightarrow>\n                    n \\<in> set (concat\n                                  (map constraint_to_qdelta_constraint\n                                    csl)) \\<and>\n                    is_leq_ns (a *R n) \\<and> a \\<noteq> 0;\n         (\\<Sum>(a, n)\\<leftarrow>N. lec_of_nsc (a *R n)) =\n         Le_Constraint Leq_Rel 0 d;\n         d < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?a, ?n) \\<in> set N \\<Longrightarrow>\n  ?n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (?a *R ?n) \\<and> ?a \\<noteq> 0\n  (\\<Sum>(a, n)\\<leftarrow>N. lec_of_nsc (a *R n)) =\n  Le_Constraint Leq_Rel 0 d\n  d < 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "let ?prop = \"\\<lambda> NN C. (\\<forall> (a,c) \\<in> set C. c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0)\n      \\<and> compatible_cs (\\<Sum> (a,c) \\<leftarrow> C. lec_of_constraint (a *R c)) \n          (\\<Sum>(a,n)\\<leftarrow>NN. lec_of_nsc (a *R n))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have \"set NN \\<subseteq> set N \\<Longrightarrow> \\<exists> C. ?prop NN C\" for NN"], ["proof (prove)\ngoal (1 subgoal):\n 1. set NN \\<subseteq> set N \\<Longrightarrow>\n    \\<exists>C.\n       (\\<forall>(a, c)\\<in>set C.\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n        (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))", "proof (induct NN)"], ["proof (state)\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set N \\<Longrightarrow>\n    \\<exists>C.\n       (\\<forall>(a, c)\\<in>set C.\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n        (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))\n 2. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "case Nil"], ["proof (state)\nthis:\n  set [] \\<subseteq> set N\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set N \\<Longrightarrow>\n    \\<exists>C.\n       (\\<forall>(a, c)\\<in>set C.\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n        (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))\n 2. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "have \"?prop Nil Nil\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(a, c)\\<in>set [].\n        c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n    compatible_cs (\\<Sum>(a, c)\\<leftarrow>[]. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))", "by (simp add: compatible_cs_0_0)"], ["proof (state)\nthis:\n  (\\<forall>(a, c)\\<in>set [].\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs (\\<Sum>(a, c)\\<leftarrow>[]. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))\n\ngoal (2 subgoals):\n 1. set [] \\<subseteq> set N \\<Longrightarrow>\n    \\<exists>C.\n       (\\<forall>(a, c)\\<in>set C.\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n        (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))\n 2. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<forall>(a, c)\\<in>set [].\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs (\\<Sum>(a, c)\\<leftarrow>[]. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>[]. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       (\\<forall>a\\<in>set C.\n           case a of\n           (a, c) \\<Rightarrow>\n             c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs\n        (\\<Sum>a\\<leftarrow>C. case a of\n                               (a, c) \\<Rightarrow>\n                                 lec_of_constraint (a *R c))\n        (\\<Sum>a\\<leftarrow>[]. case a of\n                                (a, n) \\<Rightarrow> lec_of_nsc (a *R n))", "by blast"], ["proof (state)\nthis:\n  \\<exists>C.\n     (\\<forall>a\\<in>set C.\n         case a of\n         (a, c) \\<Rightarrow>\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs\n      (\\<Sum>a\\<leftarrow>C. case a of\n                             (a, c) \\<Rightarrow>\n                               lec_of_constraint (a *R c))\n      (\\<Sum>a\\<leftarrow>[]. case a of\n                              (a, n) \\<Rightarrow> lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "case (Cons an NN)"], ["proof (state)\nthis:\n  set NN \\<subseteq> set N \\<Longrightarrow>\n  \\<exists>C.\n     (\\<forall>a\\<in>set C.\n         case a of\n         (a, c) \\<Rightarrow>\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs\n      (\\<Sum>a\\<leftarrow>C. case a of\n                             (a, c) \\<Rightarrow>\n                               lec_of_constraint (a *R c))\n      (\\<Sum>a\\<leftarrow>NN. case a of\n                              (a, n) \\<Rightarrow> lec_of_nsc (a *R n))\n  set (an # NN) \\<subseteq> set N\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "obtain a n where an: \"an = (a,n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a n. an = (a, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  an = (a, n)\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "from Cons an"], ["proof (chain)\npicking this:\n  set NN \\<subseteq> set N \\<Longrightarrow>\n  \\<exists>C.\n     (\\<forall>a\\<in>set C.\n         case a of\n         (a, c) \\<Rightarrow>\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs\n      (\\<Sum>a\\<leftarrow>C. case a of\n                             (a, c) \\<Rightarrow>\n                               lec_of_constraint (a *R c))\n      (\\<Sum>a\\<leftarrow>NN. case a of\n                              (a, n) \\<Rightarrow> lec_of_nsc (a *R n))\n  set (an # NN) \\<subseteq> set N\n  an = (a, n)", "obtain C where IH: \"?prop NN C\" and n: \"(a,n) \\<in> set N\""], ["proof (prove)\nusing this:\n  set NN \\<subseteq> set N \\<Longrightarrow>\n  \\<exists>C.\n     (\\<forall>a\\<in>set C.\n         case a of\n         (a, c) \\<Rightarrow>\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs\n      (\\<Sum>a\\<leftarrow>C. case a of\n                             (a, c) \\<Rightarrow>\n                               lec_of_constraint (a *R c))\n      (\\<Sum>a\\<leftarrow>NN. case a of\n                              (a, n) \\<Rightarrow> lec_of_nsc (a *R n))\n  set (an # NN) \\<subseteq> set N\n  an = (a, n)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>(\\<forall>(a, c)\\<in>set C.\n                     c \\<in> cs \\<and>\n                     is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                 compatible_cs\n                  (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                  (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n         (a, n) \\<in> set N\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  (\\<forall>(a, c)\\<in>set C.\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))\n  (a, n) \\<in> set N\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "have compat_CN: \"compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) \n      (\\<Sum>(a,n)\\<leftarrow>NN. lec_of_nsc (a *R n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n     (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))", "using IH"], ["proof (prove)\nusing this:\n  (\\<forall>(a, c)\\<in>set C.\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n     (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))", "by blast"], ["proof (state)\nthis:\n  compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n   (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "from n is_leq"], ["proof (chain)\npicking this:\n  (a, n) \\<in> set N\n  (?a, ?n) \\<in> set N \\<Longrightarrow>\n  ?n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (?a *R ?n) \\<and> ?a \\<noteq> 0", "obtain c where c: \"c \\<in> cs\" and nc: \"n \\<in> set (constraint_to_qdelta_constraint c)\""], ["proof (prove)\nusing this:\n  (a, n) \\<in> set N\n  (?a, ?n) \\<in> set N \\<Longrightarrow>\n  ?n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (?a *R ?n) \\<and> ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> cs;\n         n \\<in> set (constraint_to_qdelta_constraint c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding cs"], ["proof (prove)\nusing this:\n  (a, n) \\<in> set N\n  (?a, ?n) \\<in> set N \\<Longrightarrow>\n  ?n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (?a *R ?n) \\<and> ?a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> set csl;\n         n \\<in> set (constraint_to_qdelta_constraint c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  c \\<in> cs\n  n \\<in> set (constraint_to_qdelta_constraint c)\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "from is_leq[OF n]"], ["proof (chain)\npicking this:\n  n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (a *R n) \\<and> a \\<noteq> 0", "have is_leq: \"is_leq_ns (a *R n) \\<and> a \\<noteq> 0\""], ["proof (prove)\nusing this:\n  n \\<in> set (concat (map constraint_to_qdelta_constraint csl)) \\<and>\n  is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_leq_ns (a *R n) \\<and> a \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  is_leq_ns (a *R n) \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "have is_less: \"is_le (a *R c)\" and \n      a0: \"a \\<noteq> 0\" and\n      compat_cn: \"compatible_cs (lec_of_constraint (a *R c)) (lec_of_nsc (a *R n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_le (a *R c) &&&\n    a \\<noteq> 0 &&&\n    compatible_cs (lec_of_constraint (a *R c)) (lec_of_nsc (a *R n))", "by (atomize(full), cases c, insert is_leq nc, auto simp: QDelta_0_0 scaleRat_QDelta_def qdsnd_0 qdfst_0)"], ["proof (state)\nthis:\n  is_le (a *R c)\n  a \\<noteq> 0\n  compatible_cs (lec_of_constraint (a *R c)) (lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "let ?C = \"Cons (a, c) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "let ?N = \"Cons (a, n) NN\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "have \"?prop ?N ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(a, c)\\<in>set ((a, c) # C).\n        c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n    compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "unfolding an"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>(a, c)\\<in>set ((a, c) # C).\n        c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n    compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(a, c)\\<in>set ((a, c) # C).\n       c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0\n 2. compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "show \"\\<forall> (a,c) \\<in> set ?C. c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(a, c)\\<in>set ((a, c) # C).\n       c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0", "using IH is_less a0 c"], ["proof (prove)\nusing this:\n  (\\<forall>(a, c)\\<in>set C.\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n))\n  is_le (a *R c)\n  a \\<noteq> 0\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<forall>(a, c)\\<in>set ((a, c) # C).\n       c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>(a, c)\\<in>set ((a, c) # C).\n     c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0\n\ngoal (1 subgoal):\n 1. compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "show \"compatible_cs (\\<Sum>(a, c)\\<leftarrow>?C. lec_of_constraint (a *R c)) (\\<Sum>(a,n)\\<leftarrow>?N. lec_of_nsc (a *R n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "using compatible_cs_plus[OF compat_cn compat_CN]"], ["proof (prove)\nusing this:\n  compatible_cs\n   (lec_of_constraint (a *R c) +\n    (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)))\n   (lec_of_nsc (a *R n) + (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n)))\n\ngoal (1 subgoal):\n 1. compatible_cs\n     (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n     (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))", "by simp"], ["proof (state)\nthis:\n  compatible_cs\n   (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<forall>(a, c)\\<in>set ((a, c) # C).\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs\n   (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<And>a NN.\n       \\<lbrakk>set NN \\<subseteq> set N \\<Longrightarrow>\n                \\<exists>C.\n                   (\\<forall>(a, c)\\<in>set C.\n                       c \\<in> cs \\<and>\n                       is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                   compatible_cs\n                    (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n                    (\\<Sum>(a, n)\\<leftarrow>NN. lec_of_nsc (a *R n));\n        set (a # NN) \\<subseteq> set N\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C.\n                            (\\<forall>(a, c)\\<in>set C.\n                                c \\<in> cs \\<and>\n                                is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n                            compatible_cs\n                             (\\<Sum>(a,\n                                 c)\\<leftarrow>C. lec_of_constraint\n             (a *R c))\n                             (\\<Sum>(a,\n                                 n)\\<leftarrow>a # NN. lec_of_nsc (a *R n))", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<forall>(a, c)\\<in>set ((a, c) # C).\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs\n   (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       (\\<forall>a\\<in>set C.\n           case a of\n           (a, c) \\<Rightarrow>\n             c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs\n        (\\<Sum>a\\<leftarrow>C. case a of\n                               (a, c) \\<Rightarrow>\n                                 lec_of_constraint (a *R c))\n        (\\<Sum>a\\<leftarrow>an #\n                            NN. case a of\n                                (a, n) \\<Rightarrow> lec_of_nsc (a *R n))", "unfolding an"], ["proof (prove)\nusing this:\n  (\\<forall>(a, c)\\<in>set ((a, c) # C).\n      c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n  compatible_cs\n   (\\<Sum>(a, c)\\<leftarrow>(a, c) # C. lec_of_constraint (a *R c))\n   (\\<Sum>(a, n)\\<leftarrow>(a, n) # NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<exists>C.\n       (\\<forall>a\\<in>set C.\n           case a of\n           (a, c) \\<Rightarrow>\n             c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n       compatible_cs\n        (\\<Sum>a\\<leftarrow>C. case a of\n                               (a, c) \\<Rightarrow>\n                                 lec_of_constraint (a *R c))\n        (\\<Sum>a\\<leftarrow>(a, n) #\n                            NN. case a of\n                                (a, n) \\<Rightarrow> lec_of_nsc (a *R n))", "by blast"], ["proof (state)\nthis:\n  \\<exists>C.\n     (\\<forall>a\\<in>set C.\n         case a of\n         (a, c) \\<Rightarrow>\n           c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs\n      (\\<Sum>a\\<leftarrow>C. case a of\n                             (a, c) \\<Rightarrow>\n                               lec_of_constraint (a *R c))\n      (\\<Sum>a\\<leftarrow>an #\n                          NN. case a of\n                              (a, n) \\<Rightarrow> lec_of_nsc (a *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set ?NN \\<subseteq> set N \\<Longrightarrow>\n  \\<exists>C.\n     (\\<forall>(a, c)\\<in>set C.\n         c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n      (\\<Sum>(a, n)\\<leftarrow>?NN. lec_of_nsc (a *R n))\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "from this[OF subset_refl, unfolded sum]"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     (\\<forall>(a, c)\\<in>set C.\n         c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n      (Le_Constraint Leq_Rel 0 d)", "obtain C where \n    is_less: \"(\\<forall>(a, c)\\<in>set C. c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0)\" and\n    compat: \"compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) (Le_Constraint Leq_Rel 0 d)\" \n    (is \"compatible_cs ?sum _\")"], ["proof (prove)\nusing this:\n  \\<exists>C.\n     (\\<forall>(a, c)\\<in>set C.\n         c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0) \\<and>\n     compatible_cs (\\<Sum>(a, c)\\<leftarrow>C. lec_of_constraint (a *R c))\n      (Le_Constraint Leq_Rel 0 d)\n\ngoal (1 subgoal):\n 1. (\\<And>C.\n        \\<lbrakk>\\<forall>(a, c)\\<in>set C.\n                    c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0;\n         compatible_cs\n          (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n          (Le_Constraint Leq_Rel 0 d)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(a, c)\\<in>set C.\n     c \\<in> cs \\<and> is_le (a *R c) \\<and> a \\<noteq> 0\n  compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n   (Le_Constraint Leq_Rel 0 d)\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "obtain rel p e where \"?sum = Le_Constraint rel p e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>rel p e.\n        (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n        Le_Constraint rel p e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases ?sum)"], ["proof (state)\nthis:\n  (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n  Le_Constraint rel p e\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "with compat"], ["proof (chain)\npicking this:\n  compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n   (Le_Constraint Leq_Rel 0 d)\n  (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n  Le_Constraint rel p e", "have sum: \"?sum = Le_Constraint rel 0 e\""], ["proof (prove)\nusing this:\n  compatible_cs (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c))\n   (Le_Constraint Leq_Rel 0 d)\n  (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n  Le_Constraint rel p e\n\ngoal (1 subgoal):\n 1. (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n    Le_Constraint rel 0 e", "by (cases rel, auto)"], ["proof (state)\nthis:\n  (\\<Sum>(f, c)\\<leftarrow>C. lec_of_constraint (f *R c)) =\n  Le_Constraint rel 0 e\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "have e: \"(rel = Leq_Rel \\<and> e < 0 \\<or> rel = Lt_Rel \\<and> e \\<le> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rel = Leq_Rel \\<and> e < 0 \\<or> rel = Lt_Rel \\<and> e \\<le> 0", "using compat[unfolded sum] d0"], ["proof (prove)\nusing this:\n  compatible_cs (Le_Constraint rel 0 e) (Le_Constraint Leq_Rel 0 d)\n  d < 0\n\ngoal (1 subgoal):\n 1. rel = Leq_Rel \\<and> e < 0 \\<or> rel = Lt_Rel \\<and> e \\<le> 0", "by (cases rel, auto simp: less_QDelta_def qdfst_0 qdsnd_0)"], ["proof (state)\nthis:\n  rel = Leq_Rel \\<and> e < 0 \\<or> rel = Lt_Rel \\<and> e \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C. farkas_coefficients cs C", "unfolding farkas_coefficients_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C d rel.\n       (\\<forall>(r, c)\\<in>set C.\n           c \\<in> cs \\<and> is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n       Le_Constraint rel 0 d \\<and>\n       (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0)", "by (intro exI conjI, rule is_less, rule sum, insert e, auto)"], ["proof (state)\nthis:\n  \\<exists>C. farkas_coefficients cs C\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Finally we can prove on layer 1 that a finite set of constraints is \n  unsatisfiable if and only if there are Farkas coefficients.\\<close>"], ["", "lemma farkas_coefficients: assumes \"finite cs\" \n  shows \"(\\<exists> C. farkas_coefficients cs C) \\<longleftrightarrow> (\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C. farkas_coefficients cs C) =\n    (\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)", "using farkas_coefficients_unsat unsat_farkas_coefficients[OF _ assms]"], ["proof (prove)\nusing this:\n  farkas_coefficients ?cs ?C \\<Longrightarrow>\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s ?cs\n  \\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs \\<Longrightarrow>\n  \\<exists>C. farkas_coefficients cs C\n\ngoal (1 subgoal):\n 1. (\\<exists>C. farkas_coefficients cs C) =\n    (\\<nexists>v. v \\<Turnstile>\\<^sub>c\\<^sub>s cs)", "by blast"], ["", "section \\<open>Corollaries from the Literature\\<close>"], ["", "text \\<open>In this section, we convert the previous variations of Farkas' Lemma into more \n  well-known forms of this result.\n  Moreover, instead of referring to the various constraint types of the simplex formalization, we\n  now speak solely about constraints of type @{type le_constraint}.\\<close>"], ["", "subsection \\<open>Farkas' Lemma on Delta-Rationals\\<close>"], ["", "text \\<open>We start with Lemma~2 of \\cite{Bromberger2017}, a\n  variant of Farkas' Lemma for delta-rationals. To be more precise, it states\n  that a set of non-strict inequalities over delta-rationals is unsatisfiable\n  if and only if there is a linear combination of the inequalities that results\n  in a trivial unsatisfiable constraint $0 < const$ for some negative constant $const$.\n  We can easily prove this statement via the lemma @{thm [source] farkas_coefficients_ns} \n  and some conversions between the \n  different constraint types.\\<close>"], ["", "lemma Farkas'_Lemma_Delta_Rationals: fixes cs :: \"QDelta le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "assume \"c \\<in> cs\""], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "with only_non_strict"], ["proof (chain)\npicking this:\n  lec_rel ` cs \\<subseteq> {Leq_Rel}\n  c \\<in> cs", "have \"lec_rel c = Leq_Rel\""], ["proof (prove)\nusing this:\n  lec_rel ` cs \\<subseteq> {Leq_Rel}\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. lec_rel c = Leq_Rel", "by auto"], ["proof (state)\nthis:\n  lec_rel c = Leq_Rel\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "then"], ["proof (chain)\npicking this:\n  lec_rel c = Leq_Rel", "have \"\\<exists> p const. c = Leqc p const\""], ["proof (prove)\nusing this:\n  lec_rel c = Leq_Rel\n\ngoal (1 subgoal):\n 1. \\<exists>p const. c = Le_Constraint Leq_Rel p const", "by (cases c, auto)"], ["proof (state)\nthis:\n  \\<exists>p const. c = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "}"], ["proof (state)\nthis:\n  ?c2 \\<in> cs \\<Longrightarrow>\n  \\<exists>p const. ?c2 = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "note leqc = this"], ["proof (state)\nthis:\n  ?c2 \\<in> cs \\<Longrightarrow>\n  \\<exists>p const. ?c2 = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "let ?to_ns = \"\\<lambda> c. LEQ_ns (lec_poly c) (lec_const c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "let ?ns = \"?to_ns ` cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "from fin"], ["proof (chain)\npicking this:\n  finite cs", "have fin: \"finite ?ns\""], ["proof (prove)\nusing this:\n  finite cs\n\ngoal (1 subgoal):\n 1. finite ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)", "by auto"], ["proof (state)\nthis:\n  finite ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have \"v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns \\<longleftrightarrow> (\\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n    ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) =\n    (\\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)", "using leqc"], ["proof (prove)\nusing this:\n  ?c2 \\<in> cs \\<Longrightarrow>\n  \\<exists>p const. ?c2 = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n    ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) =\n    (\\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)", "by fastforce"], ["proof (state)\nthis:\n  ?v1 \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) =\n  (\\<forall>c\\<in>cs. ?v1 \\<Turnstile>\\<^sub>l\\<^sub>e c)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "hence \"?lhs = (\\<nexists> v. v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s ?ns)\""], ["proof (prove)\nusing this:\n  ?v1 \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n  ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) =\n  (\\<forall>c\\<in>cs. ?v1 \\<Turnstile>\\<^sub>l\\<^sub>e c)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs))", "by simp"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "also"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have \"\\<dots> = (\\<exists>C. farkas_coefficients_ns ?ns C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)) =\n    (\\<exists>C.\n        farkas_coefficients_ns\n         ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C)", "unfolding farkas_coefficients_ns[OF fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)) =\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs))", ".."], ["proof (state)\nthis:\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)) =\n  (\\<exists>C.\n      farkas_coefficients_ns\n       ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "also"], ["proof (state)\nthis:\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>n\\<^sub>s\\<^sub>s \n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)) =\n  (\\<exists>C.\n      farkas_coefficients_ns\n       ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C.\n        farkas_coefficients_ns\n         ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)\n        C \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "assume \"\\<exists> C. farkas_coefficients_ns ?ns C\""], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients_ns\n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C\n\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)\n        C \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "then"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     farkas_coefficients_ns\n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "obtain C const where is_leq: \"\\<forall> (s, n) \\<in> set C. n \\<in> ?ns \\<and> is_leq_ns (s *R n) \\<and> s \\<noteq> 0\" \n      and sum: \"(\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n)) = Leqc 0 const\"\n      and c0: \"const < 0\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     farkas_coefficients_ns\n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<forall>(s, n)\\<in>set C.\n                    n \\<in> (\\<lambda>c.\n                                LEQ_ns (lec_poly c) (lec_const c)) `\n                            cs \\<and>\n                    is_leq_ns (s *R n) \\<and> s \\<noteq> 0;\n         (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n)) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding farkas_coefficients_ns_def"], ["proof (prove)\nusing this:\n  \\<exists>C c.\n     (\\<forall>(r, n)\\<in>set C.\n         n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n         is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, n)\\<leftarrow>C. lec_of_nsc (r *R n)) =\n     Le_Constraint Leq_Rel 0 c \\<and>\n     c < 0\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<forall>(s, n)\\<in>set C.\n                    n \\<in> (\\<lambda>c.\n                                LEQ_ns (lec_poly c) (lec_const c)) `\n                            cs \\<and>\n                    is_leq_ns (s *R n) \\<and> s \\<noteq> 0;\n         (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n)) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n     is_leq_ns (s *R n) \\<and> s \\<noteq> 0\n  (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)\n        C \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "let ?C = \"map (\\<lambda> (s,n). (s,lec_of_nsc n)) C\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs)\n        C \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "proof (intro exI[of _ ?C] exI[of _ const] conjI c0, unfold sum[symmetric] map_map o_def set_map, \n        intro ballI, clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "fix s n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "assume sn: \"(s, n) \\<in> set C\""], ["proof (state)\nthis:\n  (s, n) \\<in> set C\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "with is_leq"], ["proof (chain)\npicking this:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n     is_leq_ns (s *R n) \\<and> s \\<noteq> 0\n  (s, n) \\<in> set C", "have n_ns: \"n \\<in> ?ns\" and is_leq: \"is_leq_ns (s *R n)\" \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n     is_leq_ns (s *R n) \\<and> s \\<noteq> 0\n  (s, n) \\<in> set C\n\ngoal (1 subgoal):\n 1. n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs &&&\n    is_leq_ns (s *R n) &&& s \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs\n  is_leq_ns (s *R n)\n  s \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "from n_ns"], ["proof (chain)\npicking this:\n  n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs", "obtain c where c: \"c \\<in> cs\" and n: \"n = LEQ_ns (lec_poly c) (lec_const c)\""], ["proof (prove)\nusing this:\n  n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> cs; n = LEQ_ns (lec_poly c) (lec_const c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> cs\n  n = LEQ_ns (lec_poly c) (lec_const c)\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "with leqc[OF c]"], ["proof (chain)\npicking this:\n  \\<exists>p const. c = Le_Constraint Leq_Rel p const\n  c \\<in> cs\n  n = LEQ_ns (lec_poly c) (lec_const c)", "obtain p d where cs: \"Leqc p d \\<in> cs\" and n: \"n = LEQ_ns p d\""], ["proof (prove)\nusing this:\n  \\<exists>p const. c = Le_Constraint Leq_Rel p const\n  c \\<in> cs\n  n = LEQ_ns (lec_poly c) (lec_const c)\n\ngoal (1 subgoal):\n 1. (\\<And>p d.\n        \\<lbrakk>Le_Constraint Leq_Rel p d \\<in> cs; n = LEQ_ns p d\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Le_Constraint Leq_Rel p d \\<in> cs\n  n = LEQ_ns p d\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "from is_leq[unfolded n]"], ["proof (chain)\npicking this:\n  is_leq_ns (s *R LEQ_ns p d)\n  s \\<noteq> 0", "have s0: \"s > 0\""], ["proof (prove)\nusing this:\n  is_leq_ns (s *R LEQ_ns p d)\n  s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < s", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  0 < s\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "let ?n = \"lec_of_nsc n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "from cs n"], ["proof (chain)\npicking this:\n  Le_Constraint Leq_Rel p d \\<in> cs\n  n = LEQ_ns p d", "have mem: \"?n \\<in> cs\""], ["proof (prove)\nusing this:\n  Le_Constraint Leq_Rel p d \\<in> cs\n  n = LEQ_ns p d\n\ngoal (1 subgoal):\n 1. lec_of_nsc n \\<in> cs", "by auto"], ["proof (state)\nthis:\n  lec_of_nsc n \\<in> cs\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_nsc ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "show \"0 < s \\<and> ?n \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < s \\<and> lec_of_nsc n \\<in> cs", "using s0 mem"], ["proof (prove)\nusing this:\n  0 < s\n  lec_of_nsc n \\<in> cs\n\ngoal (1 subgoal):\n 1. 0 < s \\<and> lec_of_nsc n \\<in> cs", "by blast"], ["proof (state)\nthis:\n  0 < s \\<and> lec_of_nsc n \\<in> cs\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "have \"Leqc (s *R lec_poly ?n) (s *R lec_const ?n) = lec_of_nsc (s *R n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc n))\n     (s *R lec_const (lec_of_nsc n)) =\n    lec_of_nsc (s *R n)", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc (LEQ_ns p d)))\n     (s *R lec_const (lec_of_nsc (LEQ_ns p d))) =\n    lec_of_nsc (s *R LEQ_ns p d)", "using s0"], ["proof (prove)\nusing this:\n  0 < s\n\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc (LEQ_ns p d)))\n     (s *R lec_const (lec_of_nsc (LEQ_ns p d))) =\n    lec_of_nsc (s *R LEQ_ns p d)", "by simp"], ["proof (state)\nthis:\n  Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc n))\n   (s *R lec_const (lec_of_nsc n)) =\n  lec_of_nsc (s *R n)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "}"], ["proof (state)\nthis:\n  (?s3, ?n3) \\<in> set C \\<Longrightarrow>\n  Le_Constraint Leq_Rel (?s3 *R lec_poly (lec_of_nsc ?n3))\n   (?s3 *R lec_const (lec_of_nsc ?n3)) =\n  lec_of_nsc (?s3 *R ?n3)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "note id = this"], ["proof (state)\nthis:\n  (?s3, ?n3) \\<in> set C \\<Longrightarrow>\n  Le_Constraint Leq_Rel (?s3 *R lec_poly (lec_of_nsc ?n3))\n   (?s3 *R lec_const (lec_of_nsc ?n3)) =\n  lec_of_nsc (?s3 *R ?n3)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "show \"(\\<Sum>x\\<leftarrow>C. case case x of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n             (r, c) \\<Rightarrow> Leqc (r *R lec_poly c) (r *R lec_const c)) =\n             (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))\" (is \"sum_list (map ?f C) = sum_list (map ?g C)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))", "proof (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))", "fix pair"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))", "assume mem: \"pair \\<in> set C\""], ["proof (state)\nthis:\n  pair \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))", "then"], ["proof (chain)\npicking this:\n  pair \\<in> set C", "obtain s n where pair: \"pair = (s,n)\""], ["proof (prove)\nusing this:\n  pair \\<in> set C\n\ngoal (1 subgoal):\n 1. (\\<And>s n. pair = (s, n) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pair = (s, n)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))", "show \"?f pair = ?g pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case pair of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n     (r, c) \\<Rightarrow>\n       Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n    (case pair of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))", "unfolding pair split"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc n))\n     (s *R lec_const (lec_of_nsc n)) =\n    lec_of_nsc (s *R n)", "using id[OF mem[unfolded pair]]"], ["proof (prove)\nusing this:\n  Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc n))\n   (s *R lec_const (lec_of_nsc n)) =\n  lec_of_nsc (s *R n)\n\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel (s *R lec_poly (lec_of_nsc n))\n     (s *R lec_const (lec_of_nsc n)) =\n    lec_of_nsc (s *R n)", "."], ["proof (state)\nthis:\n  (case case pair of (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n   (r, c) \\<Rightarrow>\n     Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n  (case pair of (s, n) \\<Rightarrow> lec_of_nsc (s *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C. case case x of\n                              (s, n) \\<Rightarrow> (s, lec_of_nsc n) of\n                         (r, c) \\<Rightarrow>\n                           Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n  (\\<Sum>(s, n)\\<leftarrow>C. lec_of_nsc (s *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "then"], ["proof (chain)\npicking this:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0", "obtain C const \n      where C: \"\\<And> r c. (r,c) \\<in> set C \\<Longrightarrow> 0 < r \\<and> c \\<in> cs\" \n        and sum: \"(\\<Sum>(r, c)\\<leftarrow>C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\"\n        and const: \"const < 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<And>r c.\n                    (r, c) \\<in> set C \\<Longrightarrow>\n                    0 < r \\<and> c \\<in> cs;\n         (\\<Sum>(r,\n             c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                               (r *R lec_const c)) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?r1, ?c1) \\<in> set C \\<Longrightarrow> 0 < ?r1 \\<and> ?c1 \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "let ?C = \"map (\\<lambda> (r,c). (r, ?to_ns c)) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "show \"\\<exists> C. farkas_coefficients_ns ?ns C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients_ns\n        ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C", "unfolding farkas_coefficients_ns_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C c.\n       (\\<forall>(r, n)\\<in>set C.\n           n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) `\n                   cs \\<and>\n           is_leq_ns (r *R n) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, n)\\<leftarrow>C. lec_of_nsc (r *R n)) =\n       Le_Constraint Leq_Rel 0 c \\<and>\n       c < 0", "proof (intro exI[of _ ?C] exI[of _ const] conjI const, unfold sum[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(r, n)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, LEQ_ns (lec_poly c) (lec_const c)))\n                        C).\n       n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n       is_leq_ns (r *R n) \\<and> r \\<noteq> 0\n 2. (\\<Sum>(r,\n        n)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, LEQ_ns (lec_poly c) (lec_const c)))\n                       C. lec_of_nsc (r *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "show \"\\<forall>(s, n)\\<in>set ?C. n \\<in> ?ns \\<and> is_leq_ns (s *R n) \\<and> s \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s, n)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, LEQ_ns (lec_poly c) (lec_const c)))\n                        C).\n       n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n       is_leq_ns (s *R n) \\<and> s \\<noteq> 0", "using C"], ["proof (prove)\nusing this:\n  (?r1, ?c1) \\<in> set C \\<Longrightarrow> 0 < ?r1 \\<and> ?c1 \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<forall>(s, n)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, LEQ_ns (lec_poly c) (lec_const c)))\n                        C).\n       n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n       is_leq_ns (s *R n) \\<and> s \\<noteq> 0", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>(s, n)\n           \\<in>set (map (\\<lambda>(r, c).\n                             (r, LEQ_ns (lec_poly c) (lec_const c)))\n                      C).\n     n \\<in> (\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs \\<and>\n     is_leq_ns (s *R n) \\<and> s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        n)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, LEQ_ns (lec_poly c) (lec_const c)))\n                       C. lec_of_nsc (r *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "show \"(\\<Sum>(s, n)\\<leftarrow>?C. lec_of_nsc (s *R n)) \n        = (\\<Sum>(r, c)\\<leftarrow>C. Leqc (r *R lec_poly c) (r *R lec_const c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(s,\n        n)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, LEQ_ns (lec_poly c) (lec_const c)))\n                       C. lec_of_nsc (s *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "unfolding map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (r, c) \\<Rightarrow>\n                                  (r, LEQ_ns (lec_poly c) (lec_const c)) of\n                           (s, n) \\<Rightarrow> lec_of_nsc (s *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "by (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl], insert C, force)"], ["proof (state)\nthis:\n  (\\<Sum>(s,\n      n)\\<leftarrow>map (\\<lambda>(r, c).\n                            (r, LEQ_ns (lec_poly c) (lec_const c)))\n                     C. lec_of_nsc (s *R n)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients_ns\n      ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>C.\n      farkas_coefficients_ns\n       ((\\<lambda>c. LEQ_ns (lec_poly c) (lec_const c)) ` cs) C) =\n  (\\<exists>C const.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "."], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Motzkin's Transposition Theorem or the Kuhn-Fourier Theorem\\<close>"], ["", "text \\<open>Next, we prove a generalization of Farkas' Lemma that permits arbitrary combinations\n  of strict and non-strict inequalities: Motzkin's Transposition Theorem\n  which is also known as the Kuhn--Fourier Theorem.\n\n  The proof is mainly based on the lemma @{thm [source] farkas_coefficients}, \n  again requiring conversions between constraint types.\\<close>"], ["", "theorem Motzkin's_transposition_theorem: fixes cs :: \"rat le_constraint set\"\n  assumes fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const rel. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) \n               = Le_Constraint rel 0 const\n         \\<and> (rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0))\" \n    (is \"?lhs = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "let ?to_cs = \"\\<lambda> c. (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | _ \\<Rightarrow> LT) (lec_poly c) (lec_const c)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "have to_cs: \"v \\<Turnstile>\\<^sub>c ?to_cs c \\<longleftrightarrow> v \\<Turnstile>\\<^sub>l\\<^sub>e c\" for v c"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\n    (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n     (lec_poly c) (lec_const c) =\n    v \\<Turnstile>\\<^sub>l\\<^sub>e c", "by (cases c, cases \"lec_rel c\", auto)"], ["proof (state)\nthis:\n  ?v \\<Turnstile>\\<^sub>c\n  (case lec_rel ?c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n   (lec_poly ?c) (lec_const ?c) =\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e ?c\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "let ?cs = \"?to_cs ` cs\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "from fin"], ["proof (chain)\npicking this:\n  finite cs", "have fin: \"finite ?cs\""], ["proof (prove)\nusing this:\n  finite cs\n\ngoal (1 subgoal):\n 1. finite\n     ((\\<lambda>c.\n          (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c)) `\n      cs)", "by auto"], ["proof (state)\nthis:\n  finite\n   ((\\<lambda>c.\n        (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n         | Lt_Rel \\<Rightarrow> LT)\n         (lec_poly c) (lec_const c)) `\n    cs)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "have \"v \\<Turnstile>\\<^sub>c\\<^sub>s ?cs \\<longleftrightarrow> (\\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)\" for v"], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s\n    ((\\<lambda>c.\n         (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n          | Lt_Rel \\<Rightarrow> LT)\n          (lec_poly c) (lec_const c)) `\n     cs) =\n    (\\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)", "using to_cs"], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>c\n  (case lec_rel ?c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n   (lec_poly ?c) (lec_const ?c) =\n  ?v \\<Turnstile>\\<^sub>l\\<^sub>e ?c\n\ngoal (1 subgoal):\n 1. v \\<Turnstile>\\<^sub>c\\<^sub>s\n    ((\\<lambda>c.\n         (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n          | Lt_Rel \\<Rightarrow> LT)\n          (lec_poly c) (lec_const c)) `\n     cs) =\n    (\\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c)", "by auto"], ["proof (state)\nthis:\n  ?v \\<Turnstile>\\<^sub>c\\<^sub>s\n  ((\\<lambda>c.\n       (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n        | Lt_Rel \\<Rightarrow> LT)\n        (lec_poly c) (lec_const c)) `\n   cs) =\n  (\\<forall>c\\<in>cs. ?v \\<Turnstile>\\<^sub>l\\<^sub>e c)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "hence \"?lhs = (\\<nexists> v. v \\<Turnstile>\\<^sub>c\\<^sub>s ?cs)\""], ["proof (prove)\nusing this:\n  ?v \\<Turnstile>\\<^sub>c\\<^sub>s\n  ((\\<lambda>c.\n       (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n        | Lt_Rel \\<Rightarrow> LT)\n        (lec_poly c) (lec_const c)) `\n   cs) =\n  (\\<forall>c\\<in>cs. ?v \\<Turnstile>\\<^sub>l\\<^sub>e c)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>c\\<^sub>s\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs))", "by simp"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "also"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "have \"\\<dots> = (\\<exists>C. farkas_coefficients ?cs C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>c\\<^sub>s\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)) =\n    (\\<exists>C.\n        farkas_coefficients\n         ((\\<lambda>c.\n              (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n               | Lt_Rel \\<Rightarrow> LT)\n               (lec_poly c) (lec_const c)) `\n          cs)\n         C)", "unfolding farkas_coefficients[OF fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>c\\<^sub>s\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)) =\n    (\\<nexists>v.\n        v \\<Turnstile>\\<^sub>c\\<^sub>s\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs))", ".."], ["proof (state)\nthis:\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)) =\n  (\\<exists>C.\n      farkas_coefficients\n       ((\\<lambda>c.\n            (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n             | Lt_Rel \\<Rightarrow> LT)\n             (lec_poly c) (lec_const c)) `\n        cs)\n       C)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "also"], ["proof (state)\nthis:\n  (\\<nexists>v.\n      v \\<Turnstile>\\<^sub>c\\<^sub>s\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)) =\n  (\\<exists>C.\n      farkas_coefficients\n       ((\\<lambda>c.\n            (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n             | Lt_Rel \\<Rightarrow> LT)\n             (lec_poly c) (lec_const c)) `\n        cs)\n       C)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "have \"\\<dots> = ?rhs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C.\n        farkas_coefficients\n         ((\\<lambda>c.\n              (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n               | Lt_Rel \\<Rightarrow> LT)\n               (lec_poly c) (lec_const c)) `\n          cs)\n         C) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)\n 2. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "assume \"\\<exists> C. farkas_coefficients ?cs C\""], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)\n      C\n\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)\n 2. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "then"], ["proof (chain)\npicking this:\n  \\<exists>C.\n     farkas_coefficients\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)\n      C", "obtain C const rel where is_leq: \"\\<forall> (s, n) \\<in> set C. n \\<in> ?cs \\<and> is_le (s *R n) \\<and> s \\<noteq> 0\" \n      and sum: \"(\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n)) = Le_Constraint rel 0 const\"\n      and c0: \"(rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0)\""], ["proof (prove)\nusing this:\n  \\<exists>C.\n     farkas_coefficients\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)\n      C\n\ngoal (1 subgoal):\n 1. (\\<And>C rel const.\n        \\<lbrakk>\\<forall>(s, n)\\<in>set C.\n                    n \\<in> (\\<lambda>c.\n                                (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                                 | Lt_Rel \\<Rightarrow> LT)\n                                 (lec_poly c) (lec_const c)) `\n                            cs \\<and>\n                    is_le (s *R n) \\<and> s \\<noteq> 0;\n         (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n)) =\n         Le_Constraint rel 0 const;\n         rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding farkas_coefficients_def"], ["proof (prove)\nusing this:\n  \\<exists>C d rel.\n     (\\<forall>(r, c)\\<in>set C.\n         c \\<in> (\\<lambda>c.\n                     (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                      | Lt_Rel \\<Rightarrow> LT)\n                      (lec_poly c) (lec_const c)) `\n                 cs \\<and>\n         is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n     (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n     Le_Constraint rel 0 d \\<and>\n     (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>C rel const.\n        \\<lbrakk>\\<forall>(s, n)\\<in>set C.\n                    n \\<in> (\\<lambda>c.\n                                (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                                 | Lt_Rel \\<Rightarrow> LT)\n                                 (lec_poly c) (lec_const c)) `\n                            cs \\<and>\n                    is_le (s *R n) \\<and> s \\<noteq> 0;\n         (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n)) =\n         Le_Constraint rel 0 const;\n         rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c.\n                 (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                  | Lt_Rel \\<Rightarrow> LT)\n                  (lec_poly c) (lec_const c)) `\n             cs \\<and>\n     is_le (s *R n) \\<and> s \\<noteq> 0\n  (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n)) =\n  Le_Constraint rel 0 const\n  rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\n\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)\n 2. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "let ?C = \"map (\\<lambda> (s,n). (s,lec_of_constraint n)) C\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)\n 2. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)", "proof (intro exI[of _ ?C] exI[of _ const] exI[of _ rel] conjI c0, unfold map_map o_def set_map sum[symmetric], \n        intro ballI, clarify)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "fix s n"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "assume sn: \"(s, n) \\<in> set C\""], ["proof (state)\nthis:\n  (s, n) \\<in> set C\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "with is_leq"], ["proof (chain)\npicking this:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c.\n                 (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                  | Lt_Rel \\<Rightarrow> LT)\n                  (lec_poly c) (lec_const c)) `\n             cs \\<and>\n     is_le (s *R n) \\<and> s \\<noteq> 0\n  (s, n) \\<in> set C", "have n_ns: \"n \\<in> ?cs\" and is_leq: \"is_le (s *R n)\" and s0: \"s \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<forall>(s, n)\\<in>set C.\n     n \\<in> (\\<lambda>c.\n                 (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                  | Lt_Rel \\<Rightarrow> LT)\n                  (lec_poly c) (lec_const c)) `\n             cs \\<and>\n     is_le (s *R n) \\<and> s \\<noteq> 0\n  (s, n) \\<in> set C\n\ngoal (1 subgoal):\n 1. n \\<in> (\\<lambda>c.\n                (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                 | Lt_Rel \\<Rightarrow> LT)\n                 (lec_poly c) (lec_const c)) `\n            cs &&&\n    is_le (s *R n) &&& s \\<noteq> 0", "by force+"], ["proof (state)\nthis:\n  n \\<in> (\\<lambda>c.\n              (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n               | Lt_Rel \\<Rightarrow> LT)\n               (lec_poly c) (lec_const c)) `\n          cs\n  is_le (s *R n)\n  s \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "from n_ns"], ["proof (chain)\npicking this:\n  n \\<in> (\\<lambda>c.\n              (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n               | Lt_Rel \\<Rightarrow> LT)\n               (lec_poly c) (lec_const c)) `\n          cs", "obtain c where c: \"c \\<in> cs\" and n: \"n = ?to_cs c\""], ["proof (prove)\nusing this:\n  n \\<in> (\\<lambda>c.\n              (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n               | Lt_Rel \\<Rightarrow> LT)\n               (lec_poly c) (lec_const c)) `\n          cs\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<in> cs;\n         n =\n         (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n          | Lt_Rel \\<Rightarrow> LT)\n          (lec_poly c) (lec_const c)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<in> cs\n  n =\n  (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n   (lec_poly c) (lec_const c)\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "from is_leq[unfolded n]"], ["proof (chain)\npicking this:\n  is_le\n   (s *R\n    (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n     (lec_poly c) (lec_const c))", "have \"s \\<ge> 0\""], ["proof (prove)\nusing this:\n  is_le\n   (s *R\n    (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n     (lec_poly c) (lec_const c))\n\ngoal (1 subgoal):\n 1. 0 \\<le> s", "by (cases \"lec_rel c\", auto split: if_splits)"], ["proof (state)\nthis:\n  0 \\<le> s\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "with s0"], ["proof (chain)\npicking this:\n  s \\<noteq> 0\n  0 \\<le> s", "have s0: \"s > 0\""], ["proof (prove)\nusing this:\n  s \\<noteq> 0\n  0 \\<le> s\n\ngoal (1 subgoal):\n 1. 0 < s", "by auto"], ["proof (state)\nthis:\n  0 < s\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "let ?c = \"lec_of_constraint n\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "from c n"], ["proof (chain)\npicking this:\n  c \\<in> cs\n  n =\n  (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n   (lec_poly c) (lec_const c)", "have mem: \"?c \\<in> cs\""], ["proof (prove)\nusing this:\n  c \\<in> cs\n  n =\n  (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n   (lec_poly c) (lec_const c)\n\ngoal (1 subgoal):\n 1. lec_of_constraint n \\<in> cs", "by (cases c, cases \"lec_rel c\", auto)"], ["proof (state)\nthis:\n  lec_of_constraint n \\<in> cs\n\ngoal (2 subgoals):\n 1. \\<And>a b aa ba.\n       (aa, ba) \\<in> set C \\<Longrightarrow>\n       0 < aa \\<and> lec_of_constraint ba \\<in> cs\n 2. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "show \"0 < s \\<and> ?c \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < s \\<and> lec_of_constraint n \\<in> cs", "using s0 mem"], ["proof (prove)\nusing this:\n  0 < s\n  lec_of_constraint n \\<in> cs\n\ngoal (1 subgoal):\n 1. 0 < s \\<and> lec_of_constraint n \\<in> cs", "by blast"], ["proof (state)\nthis:\n  0 < s \\<and> lec_of_constraint n \\<in> cs\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "have \"lec_of_constraint (s *R n) = Le_Constraint (lec_rel ?c) (s *R lec_poly ?c) (s *R lec_const ?c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_of_constraint (s *R n) =\n    Le_Constraint (lec_rel (lec_of_constraint n))\n     (s *R lec_poly (lec_of_constraint n))\n     (s *R lec_const (lec_of_constraint n))", "unfolding n"], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_of_constraint\n     (s *R\n      (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n       | Lt_Rel \\<Rightarrow> LT)\n       (lec_poly c) (lec_const c)) =\n    Le_Constraint\n     (lec_rel\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))\n     (s *R\n      lec_poly\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))\n     (s *R\n      lec_const\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))", "using s0"], ["proof (prove)\nusing this:\n  0 < s\n\ngoal (1 subgoal):\n 1. lec_of_constraint\n     (s *R\n      (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n       | Lt_Rel \\<Rightarrow> LT)\n       (lec_poly c) (lec_const c)) =\n    Le_Constraint\n     (lec_rel\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))\n     (s *R\n      lec_poly\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))\n     (s *R\n      lec_const\n       (lec_of_constraint\n         ((case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n           | Lt_Rel \\<Rightarrow> LT)\n           (lec_poly c) (lec_const c))))", "by (cases c, cases \"lec_rel c\", auto)"], ["proof (state)\nthis:\n  lec_of_constraint (s *R n) =\n  Le_Constraint (lec_rel (lec_of_constraint n))\n   (s *R lec_poly (lec_of_constraint n))\n   (s *R lec_const (lec_of_constraint n))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "}"], ["proof (state)\nthis:\n  (?s2, ?n2) \\<in> set C \\<Longrightarrow>\n  lec_of_constraint (?s2 *R ?n2) =\n  Le_Constraint (lec_rel (lec_of_constraint ?n2))\n   (?s2 *R lec_poly (lec_of_constraint ?n2))\n   (?s2 *R lec_const (lec_of_constraint ?n2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "note id = this"], ["proof (state)\nthis:\n  (?s2, ?n2) \\<in> set C \\<Longrightarrow>\n  lec_of_constraint (?s2 *R ?n2) =\n  Le_Constraint (lec_rel (lec_of_constraint ?n2))\n   (?s2 *R lec_poly (lec_of_constraint ?n2))\n   (?s2 *R lec_const (lec_of_constraint ?n2))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "show \"(\\<Sum>x\\<leftarrow>C. case case x of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n             (r, c) \\<Rightarrow> Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n            (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))\" \n        (is \"sum_list (map ?f C) = sum_list (map ?g C)\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (s, n) \\<Rightarrow>\n                                  (s, lec_of_constraint n) of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n    (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))", "proof (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))", "fix pair"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))", "assume mem: \"pair \\<in> set C\""], ["proof (state)\nthis:\n  pair \\<in> set C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))", "obtain r c where pair: \"pair = (r,c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>r c. pair = (r, c) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  pair = (r, c)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set C \\<Longrightarrow>\n       (case case x of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n        (r, c) \\<Rightarrow>\n          Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n       (case x of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))", "show \"?f pair = ?g pair\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case case pair of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n     (r, c) \\<Rightarrow>\n       Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n    (case pair of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))", "unfolding pair split id[OF mem[unfolded pair]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint (lec_rel (lec_of_constraint c))\n     (r *R lec_poly (lec_of_constraint c))\n     (r *R lec_const (lec_of_constraint c)) =\n    Le_Constraint (lec_rel (lec_of_constraint c))\n     (r *R lec_poly (lec_of_constraint c))\n     (r *R lec_const (lec_of_constraint c))", ".."], ["proof (state)\nthis:\n  (case case pair of (s, n) \\<Rightarrow> (s, lec_of_constraint n) of\n   (r, c) \\<Rightarrow>\n     Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n  (case pair of (s, n) \\<Rightarrow> lec_of_constraint (s *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>x\\<leftarrow>C. case case x of\n                              (s, n) \\<Rightarrow>\n                                (s, lec_of_constraint n) of\n                         (r, c) \\<Rightarrow>\n                           Le_Constraint (lec_rel c) (r *R lec_poly c)\n                            (r *R lec_const c)) =\n  (\\<Sum>(s, n)\\<leftarrow>C. lec_of_constraint (s *R n))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "then"], ["proof (chain)\npicking this:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)", "obtain C const rel \n      where C: \"\\<And> r c. (r,c) \\<in> set C \\<Longrightarrow> 0 < r \\<and> c \\<in> cs\" \n        and sum: \"(\\<Sum>(r, c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) \n           = Le_Constraint rel 0 const\"\n        and const: \"rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>C rel const.\n        \\<lbrakk>\\<And>r c.\n                    (r, c) \\<in> set C \\<Longrightarrow>\n                    0 < r \\<and> c \\<in> cs;\n         (\\<Sum>(r,\n             c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                               (r *R lec_const c)) =\n         Le_Constraint rel 0 const;\n         rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?r, ?c) \\<in> set C \\<Longrightarrow> 0 < ?r \\<and> ?c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint rel 0 const\n  rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "let ?C = \"map (\\<lambda> (r,c). (r, ?to_cs c)) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "show \"\\<exists> C. farkas_coefficients ?cs C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C.\n       farkas_coefficients\n        ((\\<lambda>c.\n             (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n              | Lt_Rel \\<Rightarrow> LT)\n              (lec_poly c) (lec_const c)) `\n         cs)\n        C", "unfolding farkas_coefficients_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C d rel.\n       (\\<forall>(r, c)\\<in>set C.\n           c \\<in> (\\<lambda>c.\n                       (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                        | Lt_Rel \\<Rightarrow> LT)\n                        (lec_poly c) (lec_const c)) `\n                   cs \\<and>\n           is_le (r *R c) \\<and> r \\<noteq> 0) \\<and>\n       (\\<Sum>(r, c)\\<leftarrow>C. lec_of_constraint (r *R c)) =\n       Le_Constraint rel 0 d \\<and>\n       (rel = Leq_Rel \\<and> d < 0 \\<or> rel = Lt_Rel \\<and> d \\<le> 0)", "proof (intro exI[of _ ?C] exI[of _ const] exI[of _ rel] conjI const, unfold sum[symmetric])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, (case lec_rel c of\n                                    Leq_Rel \\<Rightarrow> LEQ\n                                    | Lt_Rel \\<Rightarrow> LT)\n                                    (lec_poly c) (lec_const c)))\n                        C).\n       c \\<in> (\\<lambda>c.\n                   (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                    | Lt_Rel \\<Rightarrow> LT)\n                    (lec_poly c) (lec_const c)) `\n               cs \\<and>\n       is_le (r *R c) \\<and> r \\<noteq> 0\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, (case lec_rel c of\n                                   Leq_Rel \\<Rightarrow> LEQ\n                                   | Lt_Rel \\<Rightarrow> LT)\n                                   (lec_poly c) (lec_const c)))\n                       C. lec_of_constraint (r *R c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c))", "show \"\\<forall>(s, n)\\<in>set ?C. n \\<in> ?cs \\<and> is_le (s *R n) \\<and> s \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(s, n)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, (case lec_rel c of\n                                    Leq_Rel \\<Rightarrow> LEQ\n                                    | Lt_Rel \\<Rightarrow> LT)\n                                    (lec_poly c) (lec_const c)))\n                        C).\n       n \\<in> (\\<lambda>c.\n                   (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                    | Lt_Rel \\<Rightarrow> LT)\n                    (lec_poly c) (lec_const c)) `\n               cs \\<and>\n       is_le (s *R n) \\<and> s \\<noteq> 0", "using C"], ["proof (prove)\nusing this:\n  (?r, ?c) \\<in> set C \\<Longrightarrow> 0 < ?r \\<and> ?c \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<forall>(s, n)\n             \\<in>set (map (\\<lambda>(r, c).\n                               (r, (case lec_rel c of\n                                    Leq_Rel \\<Rightarrow> LEQ\n                                    | Lt_Rel \\<Rightarrow> LT)\n                                    (lec_poly c) (lec_const c)))\n                        C).\n       n \\<in> (\\<lambda>c.\n                   (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                    | Lt_Rel \\<Rightarrow> LT)\n                    (lec_poly c) (lec_const c)) `\n               cs \\<and>\n       is_le (s *R n) \\<and> s \\<noteq> 0", "by (fastforce split: le_rel.splits)"], ["proof (state)\nthis:\n  \\<forall>(s, n)\n           \\<in>set (map (\\<lambda>(r, c).\n                             (r, (case lec_rel c of\n                                  Leq_Rel \\<Rightarrow> LEQ\n                                  | Lt_Rel \\<Rightarrow> LT)\n                                  (lec_poly c) (lec_const c)))\n                      C).\n     n \\<in> (\\<lambda>c.\n                 (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                  | Lt_Rel \\<Rightarrow> LT)\n                  (lec_poly c) (lec_const c)) `\n             cs \\<and>\n     is_le (s *R n) \\<and> s \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, (case lec_rel c of\n                                   Leq_Rel \\<Rightarrow> LEQ\n                                   | Lt_Rel \\<Rightarrow> LT)\n                                   (lec_poly c) (lec_const c)))\n                       C. lec_of_constraint (r *R c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c))", "show \"(\\<Sum>(s, n)\\<leftarrow>?C. lec_of_constraint (s *R n)) \n        = (\\<Sum>(r, c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(s,\n        n)\\<leftarrow>map (\\<lambda>(r, c).\n                              (r, (case lec_rel c of\n                                   Leq_Rel \\<Rightarrow> LEQ\n                                   | Lt_Rel \\<Rightarrow> LT)\n                                   (lec_poly c) (lec_const c)))\n                       C. lec_of_constraint (s *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c))", "unfolding map_map o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>C. case case x of\n                                (r, c) \\<Rightarrow>\n                                  (r, (case lec_rel c of\n Leq_Rel \\<Rightarrow> LEQ | Lt_Rel \\<Rightarrow> LT)\n (lec_poly c) (lec_const c)) of\n                           (s, n) \\<Rightarrow>\n                             lec_of_constraint (s *R n)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c))", "by (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl], insert C, fastforce split: le_rel.splits)"], ["proof (state)\nthis:\n  (\\<Sum>(s,\n      n)\\<leftarrow>map (\\<lambda>(r, c).\n                            (r, (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n                                 | Lt_Rel \\<Rightarrow> LT)\n                                 (lec_poly c) (lec_const c)))\n                     C. lec_of_constraint (s *R n)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                        (r *R lec_const c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C.\n     farkas_coefficients\n      ((\\<lambda>c.\n           (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n            | Lt_Rel \\<Rightarrow> LT)\n            (lec_poly c) (lec_const c)) `\n       cs)\n      C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<exists>C.\n      farkas_coefficients\n       ((\\<lambda>c.\n            (case lec_rel c of Leq_Rel \\<Rightarrow> LEQ\n             | Lt_Rel \\<Rightarrow> LT)\n             (lec_poly c) (lec_const c)) `\n        cs)\n       C) =\n  (\\<exists>C const rel.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint rel 0 const \\<and>\n      (rel = Leq_Rel \\<and> const < 0 \\<or>\n       rel = Lt_Rel \\<and> const \\<le> 0))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "finally"], ["proof (chain)\npicking this:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const rel.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint rel 0 const \\<and>\n      (rel = Leq_Rel \\<and> const < 0 \\<or>\n       rel = Lt_Rel \\<and> const \\<le> 0))", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const rel.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint rel 0 const \\<and>\n      (rel = Leq_Rel \\<and> const < 0 \\<or>\n       rel = Lt_Rel \\<and> const \\<le> 0))\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0))", "."], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const rel.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint rel 0 const \\<and>\n      (rel = Leq_Rel \\<and> const < 0 \\<or>\n       rel = Lt_Rel \\<and> const \\<le> 0))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Farkas' Lemma\\<close>"], ["", "text \\<open>Finally we derive the commonly used form of Farkas' Lemma,\n  which easily follows from @{thm [source] Motzkin's_transposition_theorem}. \n  It only permits non-strict inequalities and, as a result, \n  the sum of inequalities will always be non-strict.\\<close>"], ["", "lemma Farkas'_Lemma: fixes cs :: \"rat le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> (r, c) \\<in> set C. r > 0 \\<and> c \\<in> cs)\n         \\<and> (\\<Sum> (r,c) \\<leftarrow> C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\" \n    (is \"_ = ?rhs\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "assume \"c \\<in> cs\""], ["proof (state)\nthis:\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "with only_non_strict"], ["proof (chain)\npicking this:\n  lec_rel ` cs \\<subseteq> {Leq_Rel}\n  c \\<in> cs", "have \"lec_rel c = Leq_Rel\""], ["proof (prove)\nusing this:\n  lec_rel ` cs \\<subseteq> {Leq_Rel}\n  c \\<in> cs\n\ngoal (1 subgoal):\n 1. lec_rel c = Leq_Rel", "by auto"], ["proof (state)\nthis:\n  lec_rel c = Leq_Rel\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "then"], ["proof (chain)\npicking this:\n  lec_rel c = Leq_Rel", "have \"\\<exists> p const. c = Leqc p const\""], ["proof (prove)\nusing this:\n  lec_rel c = Leq_Rel\n\ngoal (1 subgoal):\n 1. \\<exists>p const. c = Le_Constraint Leq_Rel p const", "by (cases c, auto)"], ["proof (state)\nthis:\n  \\<exists>p const. c = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "}"], ["proof (state)\nthis:\n  ?c2 \\<in> cs \\<Longrightarrow>\n  \\<exists>p const. ?c2 = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "note leqc = this"], ["proof (state)\nthis:\n  ?c2 \\<in> cs \\<Longrightarrow>\n  \\<exists>p const. ?c2 = Le_Constraint Leq_Rel p const\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "let ?lhs = \"\\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r, c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) \n           = Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "unfolding Motzkin's_transposition_theorem[OF fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C const rel.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint rel 0 const \\<and>\n        (rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0)) =\n    (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)", "assume ?rhs"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (2 subgoals):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)", "then"], ["proof (chain)\npicking this:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0", "obtain C const where C: \"\\<And> r c. (r, c)\\<in>set C \\<Longrightarrow> 0 < r \\<and> c \\<in> cs\" and\n      sum: \"(\\<Sum>(r, c)\\<leftarrow>C. Leqc (r *R lec_poly c) (r *R lec_const c)) = Leqc 0 const\"  and\n      const: \"const < 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<And>r c.\n                    (r, c) \\<in> set C \\<Longrightarrow>\n                    0 < r \\<and> c \\<in> cs;\n         (\\<Sum>(r,\n             c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                               (r *R lec_const c)) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?r, ?c) \\<in> set C \\<Longrightarrow> 0 < ?r \\<and> ?c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (2 subgoals):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)", "show ?lhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0)", "proof (intro exI[of _ C] exI[of _ const] exI[of _ Leq_Rel] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. Leq_Rel = Leq_Rel \\<and> const < 0 \\<or>\n    Leq_Rel = Lt_Rel \\<and> const \\<le> 0", "show \"\\<forall> (r,c) \\<in> set C. 0 < r \\<and> c \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs", "using C"], ["proof (prove)\nusing this:\n  (?r, ?c) \\<in> set C \\<Longrightarrow> 0 < ?r \\<and> ?c \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs", "by force"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n\ngoal (2 subgoals):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 2. Leq_Rel = Leq_Rel \\<and> const < 0 \\<or>\n    Leq_Rel = Lt_Rel \\<and> const \\<le> 0", "show \"(\\<Sum>(r, c)\\<leftarrow> C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) =\n        Leqc 0 const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "unfolding sum[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "by (rule arg_cong[of _ _ sum_list], rule map_cong[OF refl], insert C, force dest!: leqc)"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal (1 subgoal):\n 1. Leq_Rel = Leq_Rel \\<and> const < 0 \\<or>\n    Leq_Rel = Lt_Rel \\<and> const \\<le> 0", "qed (insert const, auto)"], ["proof (state)\nthis:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "assume ?lhs"], ["proof (state)\nthis:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "then"], ["proof (chain)\npicking this:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)", "obtain C const rel where C: \"\\<And> r c. (r, c)\\<in>set C \\<Longrightarrow> 0 < r \\<and> c \\<in> cs\" and\n      sum: \"(\\<Sum>(r, c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) \n        = Le_Constraint rel 0 const\"  and\n      const: \"rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const rel.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint rel 0 const \\<and>\n     (rel = Leq_Rel \\<and> const < 0 \\<or>\n      rel = Lt_Rel \\<and> const \\<le> 0)\n\ngoal (1 subgoal):\n 1. (\\<And>C rel const.\n        \\<lbrakk>\\<And>r c.\n                    (r, c) \\<in> set C \\<Longrightarrow>\n                    0 < r \\<and> c \\<in> cs;\n         (\\<Sum>(r,\n             c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                               (r *R lec_const c)) =\n         Le_Constraint rel 0 const;\n         rel = Leq_Rel \\<and> const < 0 \\<or>\n         rel = Lt_Rel \\<and> const \\<le> 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  (?r, ?c) \\<in> set C \\<Longrightarrow> 0 < ?r \\<and> ?c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint rel 0 const\n  rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "have id: \"(\\<Sum>(r, c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c) (r *R lec_const c)) = \n          (\\<Sum>(r, c)\\<leftarrow>C. Leqc (r *R lec_poly c) (r *R lec_const c))\" (is \"_  = ?sum\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                          (r *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "by (rule arg_cong[of _ _ sum_list], rule map_cong, auto dest!: C leqc)"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c))\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "have \"lec_rel ?sum = Leq_Rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_rel\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n    Leq_Rel", "unfolding sum_list_lec"], ["proof (prove)\ngoal (1 subgoal):\n 1. lec_rel\n     (Le_Constraint\n       (sum_list\n         (map lec_rel\n           (map (\\<lambda>(r, c).\n                    Le_Constraint Leq_Rel (r *R lec_poly c)\n                     (r *R lec_const c))\n             C)))\n       (sum_list\n         (map lec_poly\n           (map (\\<lambda>(r, c).\n                    Le_Constraint Leq_Rel (r *R lec_poly c)\n                     (r *R lec_const c))\n             C)))\n       (sum_list\n         (map lec_const\n           (map (\\<lambda>(r, c).\n                    Le_Constraint Leq_Rel (r *R lec_poly c)\n                     (r *R lec_const c))\n             C)))) =\n    Leq_Rel", "by (auto simp add: sum_list_Leq_Rel o_def)"], ["proof (state)\nthis:\n  lec_rel\n   (\\<Sum>(r,\n       c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c)) =\n  Leq_Rel\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "with sum[unfolded id]"], ["proof (chain)\npicking this:\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint rel 0 const\n  lec_rel\n   (\\<Sum>(r,\n       c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c)) =\n  Leq_Rel", "have rel: \"rel = Leq_Rel\""], ["proof (prove)\nusing this:\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint rel 0 const\n  lec_rel\n   (\\<Sum>(r,\n       c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c)) =\n  Leq_Rel\n\ngoal (1 subgoal):\n 1. rel = Leq_Rel", "by auto"], ["proof (state)\nthis:\n  rel = Leq_Rel\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "with const"], ["proof (chain)\npicking this:\n  rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\n  rel = Leq_Rel", "have const: \"const < 0\""], ["proof (prove)\nusing this:\n  rel = Leq_Rel \\<and> const < 0 \\<or> rel = Lt_Rel \\<and> const \\<le> 0\n  rel = Leq_Rel\n\ngoal (1 subgoal):\n 1. const < 0", "by auto"], ["proof (state)\nthis:\n  const < 0\n\ngoal (1 subgoal):\n 1. \\<exists>C const rel.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint (lec_rel c) (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint rel 0 const \\<and>\n       (rel = Leq_Rel \\<and> const < 0 \\<or>\n        rel = Lt_Rel \\<and> const \\<le> 0) \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "show ?rhs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "by (intro exI[of _ C] exI[of _ const] conjI const, insert sum id C rel, force+)"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n  (\\<exists>C const.\n      (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n      (\\<Sum>(r,\n          c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c)) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>We also present slightly modified versions\\<close>"], ["", "lemma sum_list_map_filter_sum: fixes f :: \"'a \\<Rightarrow> 'b :: comm_monoid_add\" \n  shows \"sum_list (map f (filter g xs)) + sum_list (map f (filter (Not o g) xs)) = sum_list (map f xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list (map f (filter g xs)) +\n    sum_list (map f (filter (Not \\<circ> g) xs)) =\n    sum_list (map f xs)", "by (induct xs, auto simp: ac_simps)"], ["", "text \\<open>A version where every constraint obtains exactly one coefficient and where 0 coefficients are allowed.\\<close>"], ["", "lemma Farkas'_Lemma_set_sum: fixes cs :: \"rat le_constraint set\"\n  assumes only_non_strict: \"lec_rel ` cs \\<subseteq> {Leq_Rel}\"  \n    and fin: \"finite cs\" \n  shows \"(\\<nexists> v. \\<forall> c \\<in> cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> c \\<in> cs. C c \\<ge> 0)\n         \\<and> (\\<Sum> c \\<in> cs. Leqc ((C c) *R lec_poly c) ((C c) *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>c\\<in>cs. v \\<Turnstile>\\<^sub>l\\<^sub>e c) =\n    (\\<exists>C const.\n        (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "unfolding Farkas'_Lemma[OF only_non_strict fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>C const.\n        (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0) =\n    (\\<exists>C const.\n        (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof ((standard; elim exE conjE), goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0\n 2. \\<And>C const.\n       \\<lbrakk>\\<forall>c\\<in>cs. 0 \\<le> C c;\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>(r, c)\\<in>set C.\n                                0 < r \\<and> c \\<in> cs) \\<and>\n                            (\\<Sum>(r,\n                                c)\\<leftarrow>C. Le_Constraint Leq_Rel\n            (r *R lec_poly c) (r *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "case (2 C const)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>cs. 0 \\<le> C c\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (2 subgoals):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0\n 2. \\<And>C const.\n       \\<lbrakk>\\<forall>c\\<in>cs. 0 \\<le> C c;\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>(r, c)\\<in>set C.\n                                0 < r \\<and> c \\<in> cs) \\<and>\n                            (\\<Sum>(r,\n                                c)\\<leftarrow>C. Le_Constraint Leq_Rel\n            (r *R lec_poly c) (r *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "from finite_distinct_list[OF fin]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = cs \\<and> distinct xs", "obtain csl where csl: \"set csl = cs\" and dist: \"distinct csl\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = cs \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>csl.\n        \\<lbrakk>set csl = cs; distinct csl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set csl = cs\n  distinct csl\n\ngoal (2 subgoals):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0\n 2. \\<And>C const.\n       \\<lbrakk>\\<forall>c\\<in>cs. 0 \\<le> C c;\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>(r, c)\\<in>set C.\n                                0 < r \\<and> c \\<in> cs) \\<and>\n                            (\\<Sum>(r,\n                                c)\\<leftarrow>C. Le_Constraint Leq_Rel\n            (r *R lec_poly c) (r *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "let ?list = \"filter (\\<lambda> c. C c \\<noteq> 0) csl\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0\n 2. \\<And>C const.\n       \\<lbrakk>\\<forall>c\\<in>cs. 0 \\<le> C c;\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>(r, c)\\<in>set C.\n                                0 < r \\<and> c \\<in> cs) \\<and>\n                            (\\<Sum>(r,\n                                c)\\<leftarrow>C. Le_Constraint Leq_Rel\n            (r *R lec_poly c) (r *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "let ?C = \"map (\\<lambda> c. (C c, c)) ?list\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0\n 2. \\<And>C const.\n       \\<lbrakk>\\<forall>c\\<in>cs. 0 \\<le> C c;\n        (\\<Sum>c\\<in>cs.\n           Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>(r, c)\\<in>set C.\n                                0 < r \\<and> c \\<in> cs) \\<and>\n                            (\\<Sum>(r,\n                                c)\\<leftarrow>C. Le_Constraint Leq_Rel\n            (r *R lec_poly c) (r *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "proof (intro exI[of _ ?C] exI[of _ const] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "have \"(\\<Sum>(r, c)\\<leftarrow>?C. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))\n      = (\\<Sum>(r, c)\\<leftarrow>map (\\<lambda>c. (C c, c)) csl. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))", "unfolding map_map"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map ((\\<lambda>(r, c).\n               Le_Constraint Leq_Rel (r *R lec_poly c)\n                (r *R lec_const c)) \\<circ>\n           (\\<lambda>c. (C c, c)))\n       (filter (\\<lambda>c. C c \\<noteq> 0) csl)) =\n    sum_list\n     (map ((\\<lambda>(r, c).\n               Le_Constraint Leq_Rel (r *R lec_poly c)\n                (r *R lec_const c)) \\<circ>\n           (\\<lambda>c. (C c, c)))\n       csl)", "by (rule sum_list_map_filter, auto simp: zero_le_constraint_def)"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     (filter (\\<lambda>c. C c \\<noteq> 0)\n                       csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))\n\ngoal (3 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     (filter (\\<lambda>c. C c \\<noteq> 0)\n                       csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))\n\ngoal (3 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "have \"\\<dots> = Le_Constraint Leq_Rel 0 const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "unfolding 2(2)[symmetric] csl[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n    (\\<Sum>c\\<in>set csl.\n       Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c))", "unfolding sum.distinct_set_conv_list[OF dist] map_map o_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<leftarrow>csl. Le_Constraint Leq_Rel (C x *R lec_poly x)\n                              (C x *R lec_const x)) =\n    (\\<Sum>c\\<leftarrow>csl. Le_Constraint Leq_Rel (C c *R lec_poly c)\n                              (C c *R lec_const c))", ".."], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     csl. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal (3 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     (filter (\\<lambda>c. C c \\<noteq> 0)\n                       csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const", "show \"(\\<Sum>(r, c)\\<leftarrow>?C. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) = Le_Constraint Leq_Rel 0 const\""], ["proof (prove)\nusing this:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     (filter (\\<lambda>c. C c \\<noteq> 0)\n                       csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                       (filter (\\<lambda>c. C c \\<noteq> 0)\n                         csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>map (\\<lambda>c. (C c, c))\n                     (filter (\\<lambda>c. C c \\<noteq> 0)\n                       csl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal (2 subgoals):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs\n 2. const < 0", "show \"const < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const < 0", "by fact"], ["proof (state)\nthis:\n  const < 0\n\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs", "show \"\\<forall>(r, c)\\<in>set ?C. 0 < r \\<and> c \\<in> cs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs", "using 2(1)"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>cs. 0 \\<le> C c\n\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\n             \\<in>set (map (\\<lambda>c. (C c, c))\n                        (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n       0 < r \\<and> c \\<in> cs", "unfolding set_map set_filter csl"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>cs. 0 \\<le> C c\n\ngoal (1 subgoal):\n 1. \\<forall>(r, c)\n             \\<in>(\\<lambda>c. (C c, c)) ` {x \\<in> cs. C x \\<noteq> 0}.\n       0 < r \\<and> c \\<in> cs", "by auto"], ["proof (state)\nthis:\n  \\<forall>(r, c)\n           \\<in>set (map (\\<lambda>c. (C c, c))\n                      (filter (\\<lambda>c. C c \\<noteq> 0) csl)).\n     0 < r \\<and> c \\<in> cs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs) \\<and>\n     (\\<Sum>(r,\n         c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "case (1 C const)"], ["proof (state)\nthis:\n  \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (1 subgoal):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "define CC where \"CC = (\\<lambda> c. sum_list (map fst (filter (\\<lambda> rc. snd rc = c) C)))\""], ["proof (state)\nthis:\n  CC = (\\<lambda>c. sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)))\n\ngoal (1 subgoal):\n 1. \\<And>C const.\n       \\<lbrakk>\\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs;\n        (\\<Sum>(r,\n            c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const;\n        const < 0\\<rbrakk>\n       \\<Longrightarrow> \\<exists>C const.\n                            (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n                            (\\<Sum>c\\<in>cs.\n                               Le_Constraint Leq_Rel (C c *R lec_poly c)\n                                (C c *R lec_const c)) =\n                            Le_Constraint Leq_Rel 0 const \\<and>\n                            const < 0", "show \"(\\<exists> C const. (\\<forall> c \\<in> cs. C c \\<ge> 0)\n         \\<and> (\\<Sum> c \\<in> cs. Leqc ((C c) *R lec_poly c) ((C c) *R lec_const c)) = Leqc 0 const\n         \\<and> const < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n       (\\<Sum>c\\<in>cs.\n          Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "proof (intro exI[of _ CC] exI[of _ const] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>c\\<in>cs. 0 \\<le> CC c\n 2. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "show \"\\<forall>c\\<in>cs. 0 \\<le> CC c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>cs. 0 \\<le> CC c", "unfolding CC_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>cs.\n       0 \\<le> sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C))", "using 1(1)"], ["proof (prove)\nusing this:\n  \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>cs.\n       0 \\<le> sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C))", "by (force intro!: sum_list_nonneg)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>cs. 0 \\<le> CC c\n\ngoal (2 subgoals):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 2. const < 0", "show \"const < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const < 0", "by fact"], ["proof (state)\nthis:\n  const < 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "from 1"], ["proof (chain)\npicking this:\n  \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0", "have snd: \"snd ` set C \\<subseteq> cs\""], ["proof (prove)\nusing this:\n  \\<forall>(r, c)\\<in>set C. 0 < r \\<and> c \\<in> cs\n  (\\<Sum>(r,\n      c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                        (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (1 subgoal):\n 1. snd ` set C \\<subseteq> cs", "by auto"], ["proof (state)\nthis:\n  snd ` set C \\<subseteq> cs\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "show \"(\\<Sum>c\\<in>cs. Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) = Le_Constraint Leq_Rel 0 const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "unfolding 1(2)[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "using fin snd"], ["proof (prove)\nusing this:\n  finite cs\n  snd ` set C \\<subseteq> cs\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "unfolding CC_def"], ["proof (prove)\nusing this:\n  finite cs\n  snd ` set C \\<subseteq> cs\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                          (r *R lec_const c))", "proof (induct cs arbitrary: C rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>C.\n       snd ` set C \\<subseteq> {} \\<Longrightarrow>\n       (\\<Sum>c\\<in>{}.\n          Le_Constraint Leq_Rel\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_poly c)\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_const c)) =\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n 2. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "case empty"], ["proof (state)\nthis:\n  snd ` set C \\<subseteq> {}\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       snd ` set C \\<subseteq> {} \\<Longrightarrow>\n       (\\<Sum>c\\<in>{}.\n          Le_Constraint Leq_Rel\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_poly c)\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_const c)) =\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n 2. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "hence C: \"C = []\""], ["proof (prove)\nusing this:\n  snd ` set C \\<subseteq> {}\n\ngoal (1 subgoal):\n 1. C = []", "by auto"], ["proof (state)\nthis:\n  C = []\n\ngoal (2 subgoals):\n 1. \\<And>C.\n       snd ` set C \\<subseteq> {} \\<Longrightarrow>\n       (\\<Sum>c\\<in>{}.\n          Le_Constraint Leq_Rel\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_poly c)\n           (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n            lec_const c)) =\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n 2. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "thus ?case"], ["proof (prove)\nusing this:\n  C = []\n\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>{}.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>a\\<leftarrow>C. case a of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>{}.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_const c)) =\n  (\\<Sum>a\\<leftarrow>C. case a of\n                         (r, c) \\<Rightarrow>\n                           Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c))\n\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "case *: (insert c cs C)"], ["proof (state)\nthis:\n  finite cs\n  c \\<notin> cs\n  snd ` set ?C \\<subseteq> cs \\<Longrightarrow>\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_const c)) =\n  (\\<Sum>a\\<leftarrow>?C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n  snd ` set C \\<subseteq> insert c cs\n\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "let ?D = \"filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "from *"], ["proof (chain)\npicking this:\n  finite cs\n  c \\<notin> cs\n  snd ` set ?C \\<subseteq> cs \\<Longrightarrow>\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_const c)) =\n  (\\<Sum>a\\<leftarrow>?C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n  snd ` set C \\<subseteq> insert c cs", "have \"snd ` set ?D \\<subseteq> cs\""], ["proof (prove)\nusing this:\n  finite cs\n  c \\<notin> cs\n  snd ` set ?C \\<subseteq> cs \\<Longrightarrow>\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) ?C)) *R\n       lec_const c)) =\n  (\\<Sum>a\\<leftarrow>?C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n  snd ` set C \\<subseteq> insert c cs\n\ngoal (1 subgoal):\n 1. snd ` set (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C)\n    \\<subseteq> cs", "by auto"], ["proof (state)\nthis:\n  snd ` set (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C)\n  \\<subseteq> cs\n\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "note IH = *(3)[OF this]"], ["proof (state)\nthis:\n  (\\<Sum>ca\\<in>cs.\n     Le_Constraint Leq_Rel\n      (sum_list\n        (map fst\n          (filter (\\<lambda>rc. snd rc = ca)\n            (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C))) *R\n       lec_poly ca)\n      (sum_list\n        (map fst\n          (filter (\\<lambda>rc. snd rc = ca)\n            (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C))) *R\n       lec_const ca)) =\n  (\\<Sum>a\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c))\n\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "have id: \"(\\<Sum>a\\<leftarrow> ?D. case a of (r, c) \\<Rightarrow> Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) = \n        (\\<Sum>(r, c)\\<leftarrow>?D. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                         C. case a of\n                            (r, c) \\<Rightarrow>\n                              Le_Constraint Leq_Rel (r *R lec_poly c)\n                               (r *R lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "by (induct C, force+)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                     C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c))\n\ngoal (1 subgoal):\n 1. \\<And>x F C.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>C.\n           snd ` set C \\<subseteq> F \\<Longrightarrow>\n           (\\<Sum>c\\<in>F.\n              Le_Constraint Leq_Rel\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_poly c)\n               (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n                lec_const c)) =\n           (\\<Sum>(r,\n               c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c));\n        snd ` set C \\<subseteq> insert x F\\<rbrakk>\n       \\<Longrightarrow> (\\<Sum>c\\<in>insert x F.\n                            Le_Constraint Leq_Rel\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_poly c)\n                             (sum_list\n                               (map fst\n                                 (filter (\\<lambda>rc. snd rc = c) C)) *R\n                              lec_const c)) =\n                         (\\<Sum>(r,\n                             c)\\<leftarrow>C. Le_Constraint Leq_Rel\n         (r *R lec_poly c) (r *R lec_const c))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>insert c cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>a\\<leftarrow>C. case a of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c))", "unfolding sum.insert[OF *(1,2)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) +\n    (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>a\\<leftarrow>C. case a of\n                           (r, c) \\<Rightarrow>\n                             Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c))", "unfolding sum_list_map_filter_sum[of _ \"\\<lambda> rc. snd rc = c\" C, symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) +\n    (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c)) +\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "proof (rule arg_cong2[of _ _ _ _ \"(+)\"], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))\n 2. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))\n 2. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "unfolding IH[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>c\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c)) =\n    (\\<Sum>ca\\<in>cs.\n       Le_Constraint Leq_Rel\n        (sum_list\n          (map fst\n            (filter (\\<lambda>rc. snd rc = ca)\n              (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C))) *R\n         lec_poly ca)\n        (sum_list\n          (map fst\n            (filter (\\<lambda>rc. snd rc = ca)\n              (filter (Not \\<circ> (\\<lambda>rc. snd rc = c)) C))) *R\n         lec_const ca))", "by (rule sum.cong, insert *(2,1), auto intro!: arg_cong[of _ _ \"\\<lambda> xs. sum_list (map _ xs)\"], (induct C, auto)+)"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_const c)) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>filter (Not \\<circ> (\\<lambda>rc. snd rc = c))\n                     C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c))\n\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "case 1"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n      lec_const c) =\n    (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                           (r *R lec_const c))", "proof (rule sym, induct C)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                         []. case a of\n                             (r, c) \\<Rightarrow>\n                               Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_const c)\n 2. \\<And>a C.\n       (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                            C. case a of\n                               (r, c) \\<Rightarrow>\n                                 Le_Constraint Leq_Rel (r *R lec_poly c)\n                                  (r *R lec_const c)) =\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c) \\<Longrightarrow>\n       (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                            (a #\n                             C). case a of\n                                 (r, c) \\<Rightarrow>\n                                   Le_Constraint Leq_Rel (r *R lec_poly c)\n                                    (r *R lec_const c)) =\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (a # C))) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (a # C))) *R\n         lec_const c)", "case (Cons rc C)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n  Le_Constraint Leq_Rel\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_const c)\n\ngoal (2 subgoals):\n 1. (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                         []. case a of\n                             (r, c) \\<Rightarrow>\n                               Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_const c)\n 2. \\<And>a C.\n       (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                            C. case a of\n                               (r, c) \\<Rightarrow>\n                                 Le_Constraint Leq_Rel (r *R lec_poly c)\n                                  (r *R lec_const c)) =\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n         lec_const c) \\<Longrightarrow>\n       (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                            (a #\n                             C). case a of\n                                 (r, c) \\<Rightarrow>\n                                   Le_Constraint Leq_Rel (r *R lec_poly c)\n                                    (r *R lec_const c)) =\n       Le_Constraint Leq_Rel\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (a # C))) *R\n         lec_poly c)\n        (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (a # C))) *R\n         lec_const c)", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       C. case a of\n                          (r, c) \\<Rightarrow>\n                            Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n  Le_Constraint Leq_Rel\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_const c)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                         (rc #\n                          C). case a of\n                              (r, c) \\<Rightarrow>\n                                Le_Constraint Leq_Rel (r *R lec_poly c)\n                                 (r *R lec_const c)) =\n    Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (rc # C))) *R\n      lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (rc # C))) *R\n      lec_const c)", "by (cases \"rc\", cases \"snd rc = c\", auto simp: field_simps scaleRat_left_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                       (rc #\n                        C). case a of\n                            (r, c) \\<Rightarrow>\n                              Le_Constraint Leq_Rel (r *R lec_poly c)\n                               (r *R lec_const c)) =\n  Le_Constraint Leq_Rel\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (rc # C))) *R\n    lec_poly c)\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) (rc # C))) *R\n    lec_const c)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                         []. case a of\n                             (r, c) \\<Rightarrow>\n                               Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_poly c)\n     (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) [])) *R\n      lec_const c)", "qed (auto simp: zero_le_constraint_def)"], ["proof (state)\nthis:\n  Le_Constraint Leq_Rel\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R lec_poly c)\n   (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n    lec_const c) =\n  (\\<Sum>(r,\n      c)\\<leftarrow>filter (\\<lambda>rc. snd rc = c)\n                     C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                         (r *R lec_const c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>insert c cs.\n     Le_Constraint Leq_Rel\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_poly c)\n      (sum_list (map fst (filter (\\<lambda>rc. snd rc = c) C)) *R\n       lec_const c)) =\n  (\\<Sum>a\\<leftarrow>C. case a of\n                         (r, c) \\<Rightarrow>\n                           Le_Constraint Leq_Rel (r *R lec_poly c)\n                            (r *R lec_const c))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>c\\<in>cs.\n     Le_Constraint Leq_Rel (CC c *R lec_poly c) (CC c *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>c\\<in>cs. 0 \\<le> C c) \\<and>\n     (\\<Sum>c\\<in>cs.\n        Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>A version with indexed constraints, i.e., in particular where constraints may occur several\n  times.\\<close>"], ["", "lemma Farkas'_Lemma_indexed: fixes c :: \"nat \\<Rightarrow> rat le_constraint\"\n  assumes only_non_strict: \"lec_rel ` c ` Is \\<subseteq> {Leq_Rel}\"  \n  and fin: \"finite Is\" \n  shows \"(\\<nexists> v. \\<forall> i \\<in> Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) \\<longleftrightarrow> \n       (\\<exists> C const. (\\<forall> i \\<in> Is. C i \\<ge> 0)\n         \\<and> (\\<Sum> i \\<in> Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const\n         \\<and> const < 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "let ?C = \"c ` Is\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have fin: \"finite ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (c ` Is)", "using fin"], ["proof (prove)\nusing this:\n  finite Is\n\ngoal (1 subgoal):\n 1. finite (c ` Is)", "by auto"], ["proof (state)\nthis:\n  finite (c ` Is)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have \"(\\<nexists> v. \\<forall> i \\<in> Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) = (\\<nexists> v. \\<forall> cc \\<in> ?C. v \\<Turnstile>\\<^sub>l\\<^sub>e cc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc)", "by force"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n  (\\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "also"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n  (\\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "have \"\\<dots> = (\\<exists> C const. (\\<forall> i \\<in> Is. C i \\<ge> 0)\n         \\<and> (\\<Sum> i \\<in> Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const\n         \\<and> const < 0)\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<nexists>v.\n        \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "assume ?r"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n     (\\<Sum>i\\<in>Is.\n        Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n         (C i *R lec_const (c i))) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (2 subgoals):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "then"], ["proof (chain)\npicking this:\n  \\<exists>C const.\n     (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n     (\\<Sum>i\\<in>Is.\n        Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n         (C i *R lec_const (c i))) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0", "obtain C const where r: \"(\\<forall> i \\<in> Is. C i \\<ge> 0)\" \n         and eq: \"(\\<Sum> i \\<in> Is. Leqc ((C i) *R lec_poly (c i)) ((C i) *R lec_const (c i))) = Leqc 0 const\" \n         and \"const < 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const.\n     (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n     (\\<Sum>i\\<in>Is.\n        Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n         (C i *R lec_const (c i))) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<forall>i\\<in>Is. 0 \\<le> C i;\n         (\\<Sum>i\\<in>Is.\n            Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n             (C i *R lec_const (c i))) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>Is. 0 \\<le> C i\n  (\\<Sum>i\\<in>Is.\n     Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n      (C i *R lec_const (c i))) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (2 subgoals):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "from finite_distinct_list[OF \\<open>finite Is\\<close>]"], ["proof (chain)\npicking this:\n  \\<exists>xs. set xs = Is \\<and> distinct xs", "obtain Isl where isl: \"set Isl = Is\" and dist: \"distinct Isl\""], ["proof (prove)\nusing this:\n  \\<exists>xs. set xs = Is \\<and> distinct xs\n\ngoal (1 subgoal):\n 1. (\\<And>Isl.\n        \\<lbrakk>set Isl = Is; distinct Isl\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  set Isl = Is\n  distinct Isl\n\ngoal (2 subgoals):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "let ?CC = \"filter (\\<lambda> rc. fst rc \\<noteq> 0) (map (\\<lambda> i. (C i, c i)) Isl)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0\n 2. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0 \\<Longrightarrow>\n    \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "show ?l"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc", "unfolding Farkas'_Lemma[OF only_non_strict fin]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>(r, ca)\\<in>set C. 0 < r \\<and> ca \\<in> c ` Is) \\<and>\n       (\\<Sum>(r,\n           c)\\<leftarrow>C. Le_Constraint Leq_Rel (r *R lec_poly c)\n                             (r *R lec_const c)) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "proof (intro exI[of _ ?CC] exI[of _ const] conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>(r, ca)\n             \\<in>set (filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                        (map (\\<lambda>i. (C i, c i)) Isl)).\n       0 < r \\<and> ca \\<in> c ` Is\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                       (map (\\<lambda>i. (C i, c i))\n                         Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const\n 3. const < 0", "show \"const < 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. const < 0", "by fact"], ["proof (state)\nthis:\n  const < 0\n\ngoal (2 subgoals):\n 1. \\<forall>(r, ca)\n             \\<in>set (filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                        (map (\\<lambda>i. (C i, c i)) Isl)).\n       0 < r \\<and> ca \\<in> c ` Is\n 2. (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                       (map (\\<lambda>i. (C i, c i))\n                         Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "show \"\\<forall> (r, ca) \\<in> set ?CC. 0 < r \\<and> ca \\<in> ?C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>(r, ca)\n             \\<in>set (filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                        (map (\\<lambda>i. (C i, c i)) Isl)).\n       0 < r \\<and> ca \\<in> c ` Is", "using r(1) isl"], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>Is. 0 \\<le> C i\n  set Isl = Is\n\ngoal (1 subgoal):\n 1. \\<forall>(r, ca)\n             \\<in>set (filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                        (map (\\<lambda>i. (C i, c i)) Isl)).\n       0 < r \\<and> ca \\<in> c ` Is", "by auto"], ["proof (state)\nthis:\n  \\<forall>(r, ca)\n           \\<in>set (filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                      (map (\\<lambda>i. (C i, c i)) Isl)).\n     0 < r \\<and> ca \\<in> c ` Is\n\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                       (map (\\<lambda>i. (C i, c i))\n                         Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "show \"(\\<Sum>(r, c)\\<leftarrow>?CC. Le_Constraint Leq_Rel (r *R lec_poly c) (r *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                       (map (\\<lambda>i. (C i, c i))\n                         Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    Le_Constraint Leq_Rel 0 const", "unfolding eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(r,\n        c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                       (map (\\<lambda>i. (C i, c i))\n                         Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                                (r *R lec_const c)) =\n    (\\<Sum>i\\<in>Is.\n       Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n        (C i *R lec_const (c i)))", "by (subst sum_list_map_filter, force simp: zero_le_constraint_def,\n          unfold map_map o_def, subst sum_list_distinct_conv_sum_set[OF dist], rule sum.cong, auto simp: isl)"], ["proof (state)\nthis:\n  (\\<Sum>(r,\n      c)\\<leftarrow>filter (\\<lambda>rc. fst rc \\<noteq> 0)\n                     (map (\\<lambda>i. (C i, c i))\n                       Isl). Le_Constraint Leq_Rel (r *R lec_poly c)\n                              (r *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "assume ?l"], ["proof (state)\nthis:\n  \\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "from this[unfolded Farkas'_Lemma_set_sum[OF only_non_strict fin]]"], ["proof (chain)\npicking this:\n  \\<exists>C const.\n     (\\<forall>c\\<in>c ` Is. 0 \\<le> C c) \\<and>\n     (\\<Sum>c\\<in>c ` Is.\n        Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0", "obtain C const where nonneg: \"(\\<forall>c\\<in> ?C. 0 \\<le> C c)\" \n     and sum: \"(\\<Sum>c\\<in> ?C. Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n        Le_Constraint Leq_Rel 0 const\" \n     and const: \"const < 0\""], ["proof (prove)\nusing this:\n  \\<exists>C const.\n     (\\<forall>c\\<in>c ` Is. 0 \\<le> C c) \\<and>\n     (\\<Sum>c\\<in>c ` Is.\n        Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal (1 subgoal):\n 1. (\\<And>C const.\n        \\<lbrakk>\\<forall>c\\<in>c ` Is. 0 \\<le> C c;\n         (\\<Sum>c\\<in>c ` Is.\n            Le_Constraint Leq_Rel (C c *R lec_poly c)\n             (C c *R lec_const c)) =\n         Le_Constraint Leq_Rel 0 const;\n         const < 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<forall>c\\<in>c ` Is. 0 \\<le> C c\n  (\\<Sum>c\\<in>c ` Is.\n     Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c)) =\n  Le_Constraint Leq_Rel 0 const\n  const < 0\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "define I where \"I = (\\<lambda> i. (C (c i) / rat_of_nat (card (Is \\<inter> { j. c i = c j}))))\""], ["proof (state)\nthis:\n  I = (\\<lambda>i. C (c i) / rat_of_nat (card (Is \\<inter> {j. c i = c j})))\n\ngoal (1 subgoal):\n 1. \\<nexists>v.\n       \\<forall>cc\\<in>c ` Is.\n          v \\<Turnstile>\\<^sub>l\\<^sub>e cc \\<Longrightarrow>\n    \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "show ?r"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C const.\n       (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n       (\\<Sum>i\\<in>Is.\n          Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n           (C i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel 0 const \\<and>\n       const < 0", "proof (intro exI[of _ I] exI[of _ const] conjI const)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>i\\<in>Is. 0 \\<le> I i\n 2. (\\<Sum>i\\<in>Is.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    Le_Constraint Leq_Rel 0 const", "show \"\\<forall>i \\<in> Is. 0 \\<le> I i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>Is. 0 \\<le> I i", "using nonneg"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>c ` Is. 0 \\<le> C c\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>Is. 0 \\<le> I i", "unfolding I_def"], ["proof (prove)\nusing this:\n  \\<forall>c\\<in>c ` Is. 0 \\<le> C c\n\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>Is.\n       0 \\<le> C (c i) / rat_of_nat (card (Is \\<inter> {j. c i = c j}))", "by auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>Is. 0 \\<le> I i\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>Is.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    Le_Constraint Leq_Rel 0 const", "show \"(\\<Sum> i \\<in> Is. Le_Constraint Leq_Rel (I i *R lec_poly (c i)) (I i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>Is.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    Le_Constraint Leq_Rel 0 const", "unfolding sum[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>Is.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    (\\<Sum>c\\<in>c ` Is.\n       Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c))", "unfolding sum.image_gen[OF \\<open>finite Is\\<close>, of _ c]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>y\\<in>c ` Is.\n       \\<Sum>i\\<in>{x \\<in> Is. c x = y}.\n         Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n          (I i *R lec_const (c i))) =\n    (\\<Sum>c\\<in>c ` Is.\n       Le_Constraint Leq_Rel (C c *R lec_poly c) (C c *R lec_const c))", "proof (rule sum.cong[OF refl], goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "case (1 cc)"], ["proof (state)\nthis:\n  cc \\<in> c ` Is\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "define II where \"II = (Is \\<inter> {j. cc = c j})\""], ["proof (state)\nthis:\n  II = Is \\<inter> {j. cc = c j}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "from 1"], ["proof (chain)\npicking this:\n  cc \\<in> c ` Is", "have \"II \\<noteq> {}\""], ["proof (prove)\nusing this:\n  cc \\<in> c ` Is\n\ngoal (1 subgoal):\n 1. II \\<noteq> {}", "unfolding II_def"], ["proof (prove)\nusing this:\n  cc \\<in> c ` Is\n\ngoal (1 subgoal):\n 1. Is \\<inter> {j. cc = c j} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  II \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "moreover"], ["proof (state)\nthis:\n  II \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "have finII: \"finite II\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite II", "using \\<open>finite Is\\<close>"], ["proof (prove)\nusing this:\n  finite Is\n\ngoal (1 subgoal):\n 1. finite II", "unfolding II_def"], ["proof (prove)\nusing this:\n  finite Is\n\ngoal (1 subgoal):\n 1. finite (Is \\<inter> {j. cc = c j})", "by auto"], ["proof (state)\nthis:\n  finite II\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "ultimately"], ["proof (chain)\npicking this:\n  II \\<noteq> {}\n  finite II", "have card: \"card II \\<noteq> 0\""], ["proof (prove)\nusing this:\n  II \\<noteq> {}\n  finite II\n\ngoal (1 subgoal):\n 1. card II \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  card II \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "let ?C = \"\\<lambda> II. rat_of_nat (card II)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "define ii where \"ii = C cc / rat_of_nat (card II)\""], ["proof (state)\nthis:\n  ii = C cc / rat_of_nat (card II)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "have \"(\\<Sum>i\\<in>{x \\<in> Is. c x = cc}. Le_Constraint Leq_Rel (I i *R lec_poly (c i)) (I i *R lec_const (c i)))\n          = (\\<Sum> i\\<in> II. Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    (\\<Sum>i\\<in>II.\n       Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc))", "unfolding I_def ii_def II_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n       Le_Constraint Leq_Rel\n        ((C (c i) / rat_of_nat (card (Is \\<inter> {j. c i = c j}))) *R\n         lec_poly (c i))\n        ((C (c i) / rat_of_nat (card (Is \\<inter> {j. c i = c j}))) *R\n         lec_const (c i))) =\n    (\\<Sum>i\\<in>Is \\<inter> {j. cc = c j}.\n       Le_Constraint Leq_Rel\n        ((C cc / rat_of_nat (card (Is \\<inter> {j. cc = c j}))) *R\n         lec_poly cc)\n        ((C cc / rat_of_nat (card (Is \\<inter> {j. cc = c j}))) *R\n         lec_const cc))", "by (rule sum.cong, auto)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  (\\<Sum>i\\<in>II.\n     Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  (\\<Sum>i\\<in>II.\n     Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "have \"\\<dots> = Le_Constraint Leq_Rel ((?C II * ii) *R lec_poly cc) ((?C II * ii) *R lec_const cc)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>II.\n       Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc)) =\n    Le_Constraint Leq_Rel ((rat_of_nat (card II) * ii) *R lec_poly cc)\n     ((rat_of_nat (card II) * ii) *R lec_const cc)", "using finII"], ["proof (prove)\nusing this:\n  finite II\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>II.\n       Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc)) =\n    Le_Constraint Leq_Rel ((rat_of_nat (card II) * ii) *R lec_poly cc)\n     ((rat_of_nat (card II) * ii) *R lec_const cc)", "by (induct II rule: finite_induct, auto simp: zero_le_constraint_def field_simps\n            scaleRat_left_distrib)"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>II.\n     Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc)) =\n  Le_Constraint Leq_Rel ((rat_of_nat (card II) * ii) *R lec_poly cc)\n   ((rat_of_nat (card II) * ii) *R lec_const cc)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "also"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>II.\n     Le_Constraint Leq_Rel (ii *R lec_poly cc) (ii *R lec_const cc)) =\n  Le_Constraint Leq_Rel ((rat_of_nat (card II) * ii) *R lec_poly cc)\n   ((rat_of_nat (card II) * ii) *R lec_const cc)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "have \"?C II * ii = C cc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (card II) * ii = C cc", "unfolding ii_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_nat (card II) * (C cc / rat_of_nat (card II)) = C cc", "using card"], ["proof (prove)\nusing this:\n  card II \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_nat (card II) * (C cc / rat_of_nat (card II)) = C cc", "by auto"], ["proof (state)\nthis:\n  rat_of_nat (card II) * ii = C cc\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> c ` Is \\<Longrightarrow>\n       (\\<Sum>i\\<in>{xa \\<in> Is. c xa = x}.\n          Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n           (I i *R lec_const (c i))) =\n       Le_Constraint Leq_Rel (C x *R lec_poly x) (C x *R lec_const x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  Le_Constraint Leq_Rel (C cc *R lec_poly cc) (C cc *R lec_const cc)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  Le_Constraint Leq_Rel (C cc *R lec_poly cc) (C cc *R lec_const cc)\n\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n       Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n        (I i *R lec_const (c i))) =\n    Le_Constraint Leq_Rel (C cc *R lec_poly cc) (C cc *R lec_const cc)", "."], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>{x \\<in> Is. c x = cc}.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  Le_Constraint Leq_Rel (C cc *R lec_poly cc) (C cc *R lec_const cc)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>i\\<in>Is.\n     Le_Constraint Leq_Rel (I i *R lec_poly (c i))\n      (I i *R lec_const (c i))) =\n  Le_Constraint Leq_Rel 0 const\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>C const.\n     (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n     (\\<Sum>i\\<in>Is.\n        Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n         (C i *R lec_const (c i))) =\n     Le_Constraint Leq_Rel 0 const \\<and>\n     const < 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>cc\\<in>c ` Is. v \\<Turnstile>\\<^sub>l\\<^sub>e cc) =\n  (\\<exists>C const.\n      (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n      (\\<Sum>i\\<in>Is.\n         Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n          (C i *R lec_const (c i))) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "finally"], ["proof (chain)\npicking this:\n  (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n  (\\<exists>C const.\n      (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n      (\\<Sum>i\\<in>Is.\n         Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n          (C i *R lec_const (c i))) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n  (\\<exists>C const.\n      (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n      (\\<Sum>i\\<in>Is.\n         Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n          (C i *R lec_const (c i))) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal (1 subgoal):\n 1. (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n    (\\<exists>C const.\n        (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n        (\\<Sum>i\\<in>Is.\n           Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n            (C i *R lec_const (c i))) =\n        Le_Constraint Leq_Rel 0 const \\<and>\n        const < 0)", "."], ["proof (state)\nthis:\n  (\\<nexists>v. \\<forall>i\\<in>Is. v \\<Turnstile>\\<^sub>l\\<^sub>e c i) =\n  (\\<exists>C const.\n      (\\<forall>i\\<in>Is. 0 \\<le> C i) \\<and>\n      (\\<Sum>i\\<in>Is.\n         Le_Constraint Leq_Rel (C i *R lec_poly (c i))\n          (C i *R lec_const (c i))) =\n      Le_Constraint Leq_Rel 0 const \\<and>\n      const < 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}