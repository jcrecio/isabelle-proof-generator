{"file_name": "/home/qj213/afp-2021-10-22/thys/Fresh_Identifiers/Fresh_String.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Fresh_Identifiers", "problem_names": ["lemma ordst_antirefl: \"\\<not> ordst X X\"", "lemma ordst_trans:\nassumes As1: \"ordst X Y\" and As2: \"ordst Y Z\"\nshows \"ordst X Z\"", "lemma ordstNS_refl: \"ordstNS X X\"", "lemma ordstNS_trans:\n\"ordstNS X Y \\<Longrightarrow> ordstNS Y Z \\<Longrightarrow> ordstNS X Z\"", "lemma ordst_ordstNS_trans:\n\"ordst X Y \\<Longrightarrow> ordstNS Y Z \\<Longrightarrow> ordst X Z\"", "lemma ordstNS_ordst_trans:\n\"ordstNS X Y \\<Longrightarrow> ordst Y Z \\<Longrightarrow> ordst X Z\"", "lemma upChar_ordst: \"ordst Y (upChar Y)\"", "lemma fresh_string_ordstNS: \"ordstNS Y (fresh_string Xs Y)\"", "lemma fresh_string_set: \"finite Xs \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs\"", "lemma fresh_string_if:\n  \"fresh_string Xs Y = (\n     if Y \\<in> Xs \\<and> finite Xs then fresh_string (Xs - {Y}) (upChar Y)\n     else Y)\"", "lemmas fresh_string_list[code] = fresh_string_if[where Xs = \"set Xs\" for Xs, simplified]", "lemma map_ascii_of_idem:\n  \"is_ascii str \\<Longrightarrow> map String.ascii_of str = str\"", "lemma is_ascii_butlast:\n  \"is_ascii str \\<Longrightarrow> is_ascii (butlast str)\"", "lemma ascii_char_of:\n  fixes c :: nat\n  assumes \"c < 128\"\n  shows \"\\<not>digit7 (char_of c)\"", "lemmas ascii_of_char_of_idem = ascii_char_of[THEN String.ascii_of_idem]", "lemma is_ascii_upChar:\n  \"is_ascii str \\<Longrightarrow> is_ascii (upChar str)\"", "lemma is_ascii_fresh_string:\n  \"is_ascii Y \\<Longrightarrow> is_ascii (fresh_string Xs Y)\"", "lemma upChar_literal_upChar[code]:\n  \"upChar_literal s = String.implode (upChar (String.explode s))\"", "lemma fresh_literal_if:\n  \"fresh xs y = (if y \\<in> xs \\<and> finite xs then fresh (xs - {y}) (upChar_literal y) else y)\"", "lemmas fresh_literal_list[code] = fresh_literal_if[where xs = \"set xs\" for xs, simplified]"], "translations": [["", "lemma ordst_antirefl: \"\\<not> ordst X X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> ordst X X", "by(auto simp add: ordst_def)"], ["", "lemma ordst_trans:\nassumes As1: \"ordst X Y\" and As2: \"ordst Y Z\"\nshows \"ordst X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordst X Z", "proof(cases \"(length X < length Y) \\<or> (length Y < length Z)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "assume \"(length X < length Y) \\<or> (length Y < length Z)\""], ["proof (state)\nthis:\n  length X < length Y \\<or> length Y < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "moreover"], ["proof (state)\nthis:\n  length X < length Y \\<or> length Y < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "{"], ["proof (state)\nthis:\n  length X < length Y \\<or> length Y < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "assume \"length X < length Y\""], ["proof (state)\nthis:\n  length X < length Y\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "moreover"], ["proof (state)\nthis:\n  length X < length Y\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "have \"length Y \\<le> length Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length Y \\<le> length Z", "using As2 ordst_def"], ["proof (prove)\nusing this:\n  ordst Y Z\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. length Y \\<le> length Z", "by force"], ["proof (state)\nthis:\n  length Y \\<le> length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "ultimately"], ["proof (chain)\npicking this:\n  length X < length Y\n  length Y \\<le> length Z", "have \"length X < length Z\""], ["proof (prove)\nusing this:\n  length X < length Y\n  length Y \\<le> length Z\n\ngoal (1 subgoal):\n 1. length X < length Z", "by force"], ["proof (state)\nthis:\n  length X < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "hence ?thesis"], ["proof (prove)\nusing this:\n  length X < length Z\n\ngoal (1 subgoal):\n 1. ordst X Z", "using ordst_def"], ["proof (prove)\nusing this:\n  length X < length Z\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. ordst X Z", "by force"], ["proof (state)\nthis:\n  ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "}"], ["proof (state)\nthis:\n  length X < length Y \\<Longrightarrow> ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "moreover"], ["proof (state)\nthis:\n  length X < length Y \\<Longrightarrow> ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "{"], ["proof (state)\nthis:\n  length X < length Y \\<Longrightarrow> ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "assume \"length Y < length Z\""], ["proof (state)\nthis:\n  length Y < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "moreover"], ["proof (state)\nthis:\n  length Y < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "have \"length X \\<le> length Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length X \\<le> length Y", "using As1 ordst_def"], ["proof (prove)\nusing this:\n  ordst X Y\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. length X \\<le> length Y", "by force"], ["proof (state)\nthis:\n  length X \\<le> length Y\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "ultimately"], ["proof (chain)\npicking this:\n  length Y < length Z\n  length X \\<le> length Y", "have \"length X < length Z\""], ["proof (prove)\nusing this:\n  length Y < length Z\n  length X \\<le> length Y\n\ngoal (1 subgoal):\n 1. length X < length Z", "by force"], ["proof (state)\nthis:\n  length X < length Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "hence ?thesis"], ["proof (prove)\nusing this:\n  length X < length Z\n\ngoal (1 subgoal):\n 1. ordst X Z", "using ordst_def"], ["proof (prove)\nusing this:\n  length X < length Z\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. ordst X Z", "by force"], ["proof (state)\nthis:\n  ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "}"], ["proof (state)\nthis:\n  length Y < length Z \\<Longrightarrow> ordst X Z\n\ngoal (2 subgoals):\n 1. length X < length Y \\<or> length Y < length Z \\<Longrightarrow>\n    ordst X Z\n 2. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "ultimately"], ["proof (chain)\npicking this:\n  length X < length Y \\<or> length Y < length Z\n  length X < length Y \\<Longrightarrow> ordst X Z\n  length Y < length Z \\<Longrightarrow> ordst X Z", "show ?thesis"], ["proof (prove)\nusing this:\n  length X < length Y \\<or> length Y < length Z\n  length X < length Y \\<Longrightarrow> ordst X Z\n  length Y < length Z \\<Longrightarrow> ordst X Z\n\ngoal (1 subgoal):\n 1. ordst X Z", "by force"], ["proof (state)\nthis:\n  ordst X Z\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "assume \"\\<not> (length X < length Y \\<or> length Y < length Z)\""], ["proof (state)\nthis:\n  \\<not> (length X < length Y \\<or> length Y < length Z)\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "hence Ft: \"\\<not> length X < length Y  \\<and> \\<not> length Y < length Z\""], ["proof (prove)\nusing this:\n  \\<not> (length X < length Y \\<or> length Y < length Z)\n\ngoal (1 subgoal):\n 1. \\<not> length X < length Y \\<and> \\<not> length Y < length Z", "by force"], ["proof (state)\nthis:\n  \\<not> length X < length Y \\<and> \\<not> length Y < length Z\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "hence \"(of_char(last X) :: nat) < of_char(last Y) \\<and>\n         (of_char(last Y) :: nat) < of_char(last Z) \\<and>\n         length X \\<le> length Y \\<and> length Y \\<le> length Z\""], ["proof (prove)\nusing this:\n  \\<not> length X < length Y \\<and> \\<not> length Y < length Z\n\ngoal (1 subgoal):\n 1. of_char (last X) < of_char (last Y) \\<and>\n    of_char (last Y) < of_char (last Z) \\<and>\n    length X \\<le> length Y \\<and> length Y \\<le> length Z", "using As1 As2 ordst_def"], ["proof (prove)\nusing this:\n  \\<not> length X < length Y \\<and> \\<not> length Y < length Z\n  ordst X Y\n  ordst Y Z\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. of_char (last X) < of_char (last Y) \\<and>\n    of_char (last Y) < of_char (last Z) \\<and>\n    length X \\<le> length Y \\<and> length Y \\<le> length Z", "by force"], ["proof (state)\nthis:\n  of_char (last X) < of_char (last Y) \\<and>\n  of_char (last Y) < of_char (last Z) \\<and>\n  length X \\<le> length Y \\<and> length Y \\<le> length Z\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "hence \"(of_char(last X) :: nat) < of_char(last Z) \\<and>\n         length X \\<le> length Z\""], ["proof (prove)\nusing this:\n  of_char (last X) < of_char (last Y) \\<and>\n  of_char (last Y) < of_char (last Z) \\<and>\n  length X \\<le> length Y \\<and> length Y \\<le> length Z\n\ngoal (1 subgoal):\n 1. of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z", "by force"], ["proof (state)\nthis:\n  of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "moreover"], ["proof (state)\nthis:\n  of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "have \"X \\<noteq> [] \\<and> Z \\<noteq> []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<noteq> [] \\<and> Z \\<noteq> []", "using As1 As2 Ft ordst_def"], ["proof (prove)\nusing this:\n  ordst X Y\n  ordst Y Z\n  \\<not> length X < length Y \\<and> \\<not> length Y < length Z\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. X \\<noteq> [] \\<and> Z \\<noteq> []", "by force"], ["proof (state)\nthis:\n  X \\<noteq> [] \\<and> Z \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> (length X < length Y \\<or> length Y < length Z) \\<Longrightarrow>\n    ordst X Z", "ultimately"], ["proof (chain)\npicking this:\n  of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z\n  X \\<noteq> [] \\<and> Z \\<noteq> []", "show ?thesis"], ["proof (prove)\nusing this:\n  of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z\n  X \\<noteq> [] \\<and> Z \\<noteq> []\n\ngoal (1 subgoal):\n 1. ordst X Z", "using ordst_def[of X Z]"], ["proof (prove)\nusing this:\n  of_char (last X) < of_char (last Z) \\<and> length X \\<le> length Z\n  X \\<noteq> [] \\<and> Z \\<noteq> []\n  ordst X Z \\<equiv>\n  length X \\<le> length Z \\<and>\n  X \\<noteq> [] \\<and>\n  Z \\<noteq> [] \\<and> of_char (last X) < of_char (last Z) \\<or>\n  length X < length Z\n\ngoal (1 subgoal):\n 1. ordst X Z", "by force"], ["proof (state)\nthis:\n  ordst X Z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ordstNS_refl: \"ordstNS X X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordstNS X X", "by(simp add: ordstNS_def)"], ["", "lemma ordstNS_trans:\n\"ordstNS X Y \\<Longrightarrow> ordstNS Y Z \\<Longrightarrow> ordstNS X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ordstNS X Y; ordstNS Y Z\\<rbrakk> \\<Longrightarrow> ordstNS X Z", "by (metis ordstNS_def ordst_trans)"], ["", "lemma ordst_ordstNS_trans:\n\"ordst X Y \\<Longrightarrow> ordstNS Y Z \\<Longrightarrow> ordst X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ordst X Y; ordstNS Y Z\\<rbrakk> \\<Longrightarrow> ordst X Z", "by (metis ordstNS_def ordst_trans)"], ["", "lemma ordstNS_ordst_trans:\n\"ordstNS X Y \\<Longrightarrow> ordst Y Z \\<Longrightarrow> ordst X Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ordstNS X Y; ordst Y Z\\<rbrakk> \\<Longrightarrow> ordst X Z", "by (metis ordstNS_def ordst_trans)"], ["", "subsection \\<open>Incrementing a string \\<close>"], ["", "text \\<open>If the last character is $\\geq$ 'a' and $<$ 'z',\n   then \\<open>upChar\\<close> increments this last character;\n   otherwise \\<open>upChar\\<close> appends an 'a'.  \\<close>"], ["", "fun upChar :: \"string \\<Rightarrow> string\" where\n\"upChar Y =\n (if (Y \\<noteq> [] \\<and> of_char(last Y) \\<ge> (97 :: nat) \\<and>\n               of_char(last Y) < (122 :: nat))\n    then (butlast Y) @\n         [char_of(of_char(last Y) + (1 :: nat))]\n    else Y @ ''a''\n )\""], ["", "lemma upChar_ordst: \"ordst Y (upChar Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "assume \"\\<not>(Y \\<noteq> [] \\<and> of_char(last Y) \\<ge> (97 :: nat)\n                       \\<and> of_char(last Y) < (122 :: nat))\""], ["proof (state)\nthis:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "hence \"upChar Y = Y @ ''a''\""], ["proof (prove)\nusing this:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122)\n\ngoal (1 subgoal):\n 1. upChar Y = Y @ ''a''", "by force"], ["proof (state)\nthis:\n  upChar Y = Y @ ''a''\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "hence ?thesis"], ["proof (prove)\nusing this:\n  upChar Y = Y @ ''a''\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "using ordst_def"], ["proof (prove)\nusing this:\n  upChar Y = Y @ ''a''\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "by force"], ["proof (state)\nthis:\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "}"], ["proof (state)\nthis:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and>\n          of_char (last Y) < 122) \\<Longrightarrow>\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "moreover"], ["proof (state)\nthis:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and>\n          of_char (last Y) < 122) \\<Longrightarrow>\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "{"], ["proof (state)\nthis:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and>\n          of_char (last Y) < 122) \\<Longrightarrow>\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "assume As: \"Y \\<noteq> [] \\<and> of_char(last Y) \\<ge> (97 :: nat)\n                       \\<and> of_char(last Y) < (122 :: nat)\""], ["proof (state)\nthis:\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "hence Ft: \"upChar Y = (butlast Y) @\n                     [char_of(of_char(last Y) + (1 :: nat))]\""], ["proof (prove)\nusing this:\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122\n\ngoal (1 subgoal):\n 1. upChar Y = butlast Y @ [char_of (of_char (last Y) + 1)]", "by force"], ["proof (state)\nthis:\n  upChar Y = butlast Y @ [char_of (of_char (last Y) + 1)]\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "hence Ft': \"last (upChar Y) = char_of(of_char(last Y) + (1 :: nat))\""], ["proof (prove)\nusing this:\n  upChar Y = butlast Y @ [char_of (of_char (last Y) + 1)]\n\ngoal (1 subgoal):\n 1. last (upChar Y) = char_of (of_char (last Y) + 1)", "by force"], ["proof (state)\nthis:\n  last (upChar Y) = char_of (of_char (last Y) + 1)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "hence \"of_char(last (upChar Y)) mod (256 :: nat)  =\n          (of_char(last Y) + 1) mod 256\""], ["proof (prove)\nusing this:\n  last (upChar Y) = char_of (of_char (last Y) + 1)\n\ngoal (1 subgoal):\n 1. of_char (last (upChar Y)) mod 256 = (of_char (last Y) + 1) mod 256", "by force"], ["proof (state)\nthis:\n  of_char (last (upChar Y)) mod 256 = (of_char (last Y) + 1) mod 256\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "moreover"], ["proof (state)\nthis:\n  of_char (last (upChar Y)) mod 256 = (of_char (last Y) + 1) mod 256\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "have \"of_char(last(upChar Y))  < (256 :: nat) \\<and>\n         of_char(last Y) + 1 < (256 :: nat)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_char (last (upChar Y)) < 256 \\<and> of_char (last Y) + 1 < 256", "using As Ft'"], ["proof (prove)\nusing this:\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122\n  last (upChar Y) = char_of (of_char (last Y) + 1)\n\ngoal (1 subgoal):\n 1. of_char (last (upChar Y)) < 256 \\<and> of_char (last Y) + 1 < 256", "by force"], ["proof (state)\nthis:\n  of_char (last (upChar Y)) < 256 \\<and> of_char (last Y) + 1 < 256\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "ultimately"], ["proof (chain)\npicking this:\n  of_char (last (upChar Y)) mod 256 = (of_char (last Y) + 1) mod 256\n  of_char (last (upChar Y)) < 256 \\<and> of_char (last Y) + 1 < 256", "have \"of_char (last Y) < (of_char (last(upChar Y)) :: nat)\""], ["proof (prove)\nusing this:\n  of_char (last (upChar Y)) mod 256 = (of_char (last Y) + 1) mod 256\n  of_char (last (upChar Y)) < 256 \\<and> of_char (last Y) + 1 < 256\n\ngoal (1 subgoal):\n 1. of_char (last Y) < of_char (last (upChar Y))", "by force"], ["proof (state)\nthis:\n  of_char (last Y) < of_char (last (upChar Y))\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "moreover"], ["proof (state)\nthis:\n  of_char (last Y) < of_char (last (upChar Y))\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "from Ft"], ["proof (chain)\npicking this:\n  upChar Y = butlast Y @ [char_of (of_char (last Y) + 1)]", "have \"length Y \\<le> length (upChar Y)\""], ["proof (prove)\nusing this:\n  upChar Y = butlast Y @ [char_of (of_char (last Y) + 1)]\n\ngoal (1 subgoal):\n 1. length Y \\<le> length (upChar Y)", "by force"], ["proof (state)\nthis:\n  length Y \\<le> length (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "ultimately"], ["proof (chain)\npicking this:\n  of_char (last Y) < of_char (last (upChar Y))\n  length Y \\<le> length (upChar Y)", "have ?thesis"], ["proof (prove)\nusing this:\n  of_char (last Y) < of_char (last (upChar Y))\n  length Y \\<le> length (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "using ordst_def"], ["proof (prove)\nusing this:\n  of_char (last Y) < of_char (last (upChar Y))\n  length Y \\<le> length (upChar Y)\n  ordst ?X ?Y \\<equiv>\n  length ?X \\<le> length ?Y \\<and>\n  ?X \\<noteq> [] \\<and>\n  ?Y \\<noteq> [] \\<and> of_char (last ?X) < of_char (last ?Y) \\<or>\n  length ?X < length ?Y\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "by force"], ["proof (state)\nthis:\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "}"], ["proof (state)\nthis:\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122 \\<Longrightarrow>\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and>\n          of_char (last Y) < 122) \\<Longrightarrow>\n  ordst Y (upChar Y)\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122 \\<Longrightarrow>\n  ordst Y (upChar Y)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> (Y \\<noteq> [] \\<and>\n          97 \\<le> of_char (last Y) \\<and>\n          of_char (last Y) < 122) \\<Longrightarrow>\n  ordst Y (upChar Y)\n  Y \\<noteq> [] \\<and>\n  97 \\<le> of_char (last Y) \\<and> of_char (last Y) < 122 \\<Longrightarrow>\n  ordst Y (upChar Y)\n\ngoal (1 subgoal):\n 1. ordst Y (upChar Y)", "by force"], ["proof (state)\nthis:\n  ordst Y (upChar Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The fresh-identifier operator\\<close>"], ["", "text \\<open>\\<open>fresh Xs Y\\<close> changes \\<open>Y\\<close> as little as possible so that\n   it becomes disjoint from all strings in \\<open>Xs\\<close>. \\<close>"], ["", "function fresh_string :: \"string set \\<Rightarrow> string \\<Rightarrow> string\"\nwhere\nUp: \"Y \\<in> Xs \\<Longrightarrow> finite Xs \\<Longrightarrow> fresh_string Xs Y = fresh_string (Xs - {Y}) (upChar Y)\"\n|\nFresh: \"Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow> fresh_string Xs Y = Y\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>Y Xs.\n                   \\<lbrakk>Y \\<in> Xs; finite Xs; x = (Xs, Y)\\<rbrakk>\n                   \\<Longrightarrow> P;\n        \\<And>Y Xs.\n           \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; x = (Xs, Y)\\<rbrakk>\n           \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>Y Xs Ya Xsa.\n       \\<lbrakk>Y \\<in> Xs; finite Xs; Ya \\<in> Xsa; finite Xsa;\n        (Xs, Y) = (Xsa, Ya)\\<rbrakk>\n       \\<Longrightarrow> fresh_string_sumC (Xs - {Y}, upChar Y) =\n                         fresh_string_sumC (Xsa - {Ya}, upChar Ya)\n 3. \\<And>Y Xs Ya Xsa.\n       \\<lbrakk>Y \\<in> Xs; finite Xs; Ya \\<notin> Xsa \\<or> infinite Xsa;\n        (Xs, Y) = (Xsa, Ya)\\<rbrakk>\n       \\<Longrightarrow> fresh_string_sumC (Xs - {Y}, upChar Y) = Ya\n 4. \\<And>Y Xs Ya Xsa.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs;\n        Ya \\<notin> Xsa \\<or> infinite Xsa; (Xs, Y) = (Xsa, Ya)\\<rbrakk>\n       \\<Longrightarrow> Y = Ya", "by auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All fresh_string_dom", "apply(relation \"measure (\\<lambda>(Xs,Y). card Xs)\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs\\<rbrakk>\n       \\<Longrightarrow> card Xs - Suc 0 < card Xs", "by (metis card_gt_0_iff diff_Suc_less empty_iff)"], ["", "lemma fresh_string_ordstNS: \"ordstNS Y (fresh_string Xs Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string Xs Y)", "proof (induction Xs Y rule: fresh_string.induct[case_names Up Fresh])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\\<rbrakk>\n       \\<Longrightarrow> ordstNS Y (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "case (Up Y Xs)"], ["proof (state)\nthis:\n  Y \\<in> Xs\n  finite Xs\n  ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\\<rbrakk>\n       \\<Longrightarrow> ordstNS Y (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "hence \"ordst Y (fresh_string (Xs - {Y}) (upChar Y))\""], ["proof (prove)\nusing this:\n  Y \\<in> Xs\n  finite Xs\n  ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (1 subgoal):\n 1. ordst Y (fresh_string (Xs - {Y}) (upChar Y))", "using upChar_ordst[of Y] ordst_ordstNS_trans"], ["proof (prove)\nusing this:\n  Y \\<in> Xs\n  finite Xs\n  ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\n  ordst Y (upChar Y)\n  \\<lbrakk>ordst ?X ?Y; ordstNS ?Y ?Z\\<rbrakk> \\<Longrightarrow> ordst ?X ?Z\n\ngoal (1 subgoal):\n 1. ordst Y (fresh_string (Xs - {Y}) (upChar Y))", "by force"], ["proof (state)\nthis:\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\\<rbrakk>\n       \\<Longrightarrow> ordstNS Y (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "hence \"ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))\""], ["proof (prove)\nusing this:\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))", "using ordstNS_def"], ["proof (prove)\nusing this:\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n  ordstNS ?X ?Y \\<equiv> ?X = ?Y \\<or> ordst ?X ?Y\n\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))", "by auto"], ["proof (state)\nthis:\n  ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        ordstNS (upChar Y) (fresh_string (Xs - {Y}) (upChar Y))\\<rbrakk>\n       \\<Longrightarrow> ordstNS Y (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "thus ?case"], ["proof (prove)\nusing this:\n  ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string Xs Y)", "using Up.hyps"], ["proof (prove)\nusing this:\n  ordstNS Y (fresh_string (Xs - {Y}) (upChar Y))\n  Y \\<in> Xs\n  finite Xs\n\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string Xs Y)", "by auto"], ["proof (state)\nthis:\n  ordstNS Y (fresh_string Xs Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "case (Fresh Y Xs)"], ["proof (state)\nthis:\n  Y \\<notin> Xs \\<or> infinite Xs\n\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       Y \\<notin> Xs \\<or> infinite Xs \\<Longrightarrow>\n       ordstNS Y (fresh_string Xs Y)", "then"], ["proof (chain)\npicking this:\n  Y \\<notin> Xs \\<or> infinite Xs", "show ?case"], ["proof (prove)\nusing this:\n  Y \\<notin> Xs \\<or> infinite Xs\n\ngoal (1 subgoal):\n 1. ordstNS Y (fresh_string Xs Y)", "by (auto intro: ordstNS_refl)"], ["proof (state)\nthis:\n  ordstNS Y (fresh_string Xs Y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fresh_string_set: \"finite Xs \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Xs \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs", "proof (induction Xs Y rule: fresh_string.induct[case_names Up Fresh])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        finite (Xs - {Y}) \\<Longrightarrow>\n        fresh_string (Xs - {Y}) (upChar Y) \\<notin> Xs - {Y};\n        finite Xs\\<rbrakk>\n       \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs\n 2. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; finite Xs\\<rbrakk>\n       \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs", "case (Up Y Xs)"], ["proof (state)\nthis:\n  Y \\<in> Xs\n  finite Xs\n  finite (Xs - {Y}) \\<Longrightarrow>\n  fresh_string (Xs - {Y}) (upChar Y) \\<notin> Xs - {Y}\n  finite Xs\n\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        finite (Xs - {Y}) \\<Longrightarrow>\n        fresh_string (Xs - {Y}) (upChar Y) \\<notin> Xs - {Y};\n        finite Xs\\<rbrakk>\n       \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs\n 2. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; finite Xs\\<rbrakk>\n       \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<notin> Xs", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "assume \"fresh_string Xs Y \\<in> Xs\""], ["proof (state)\nthis:\n  fresh_string Xs Y \\<in> Xs\n\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fresh_string Xs Y \\<in> Xs", "have \"fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs\""], ["proof (prove)\nusing this:\n  fresh_string Xs Y \\<in> Xs\n\ngoal (1 subgoal):\n 1. fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs", "using Up.hyps"], ["proof (prove)\nusing this:\n  fresh_string Xs Y \\<in> Xs\n  Y \\<in> Xs\n  finite Xs\n\ngoal (1 subgoal):\n 1. fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs", "by force"], ["proof (state)\nthis:\n  fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs\n\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs", "have \"fresh_string (Xs - {Y}) (upChar Y) = Y\""], ["proof (prove)\nusing this:\n  fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs\n\ngoal (1 subgoal):\n 1. fresh_string (Xs - {Y}) (upChar Y) = Y", "using Up.IH \\<open>finite Xs\\<close>"], ["proof (prove)\nusing this:\n  fresh_string (Xs - {Y}) (upChar Y) \\<in> Xs\n  finite (Xs - {Y}) \\<Longrightarrow>\n  fresh_string (Xs - {Y}) (upChar Y) \\<notin> Xs - {Y}\n  finite Xs\n\ngoal (1 subgoal):\n 1. fresh_string (Xs - {Y}) (upChar Y) = Y", "by blast"], ["proof (state)\nthis:\n  fresh_string (Xs - {Y}) (upChar Y) = Y\n\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fresh_string (Xs - {Y}) (upChar Y) = Y\n\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "have \"ordst Y (fresh_string (Xs - {Y}) (upChar Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ordst Y (fresh_string (Xs - {Y}) (upChar Y))", "using upChar_ordst[of Y] fresh_string_ordstNS ordst_ordstNS_trans"], ["proof (prove)\nusing this:\n  ordst Y (upChar Y)\n  ordstNS ?Y (fresh_string ?Xs ?Y)\n  \\<lbrakk>ordst ?X ?Y; ordstNS ?Y ?Z\\<rbrakk> \\<Longrightarrow> ordst ?X ?Z\n\ngoal (1 subgoal):\n 1. ordst Y (fresh_string (Xs - {Y}) (upChar Y))", "by auto"], ["proof (state)\nthis:\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (1 subgoal):\n 1. fresh_string Xs Y \\<in> Xs \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fresh_string (Xs - {Y}) (upChar Y) = Y\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))", "show False"], ["proof (prove)\nusing this:\n  fresh_string (Xs - {Y}) (upChar Y) = Y\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n\ngoal (1 subgoal):\n 1. False", "using ordst_antirefl"], ["proof (prove)\nusing this:\n  fresh_string (Xs - {Y}) (upChar Y) = Y\n  ordst Y (fresh_string (Xs - {Y}) (upChar Y))\n  \\<not> ordst ?X ?X\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fresh_string Xs Y \\<notin> Xs\n\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; finite Xs\\<rbrakk>\n       \\<Longrightarrow> fresh_string Xs Y \\<notin> Xs", "qed auto"], ["", "text \\<open>Code generation:\\<close>"], ["", "lemma fresh_string_if:\n  \"fresh_string Xs Y = (\n     if Y \\<in> Xs \\<and> finite Xs then fresh_string (Xs - {Y}) (upChar Y)\n     else Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh_string Xs Y =\n    (if Y \\<in> Xs \\<and> finite Xs then fresh_string (Xs - {Y}) (upChar Y)\n     else Y)", "by simp"], ["", "lemmas fresh_string_list[code] = fresh_string_if[where Xs = \"set Xs\" for Xs, simplified]"], ["", "text \\<open>Some tests: \\<close>"], ["", "value \"[fresh_string {} ''Abc'',\n        fresh_string {''X'', ''Abc''} ''Abd'',\n        fresh_string {''X'', ''Y''} ''Y'',\n        fresh_string {''X'', ''Yaa'', ''Ya'', ''Yaa''} ''Ya'',\n        fresh_string {''X'', ''Yaa'', ''Yz'', ''Yza''} ''Yz'',\n        fresh_string {''X'', ''Y'', ''Yab'', ''Y''} ''Y'']\""], ["", "text \\<open>Here we do locale interpretation rather than class instantiation,\nsince \\<^typ>\\<open>string\\<close> is a type synonym for \\<^typ>\\<open>char list\\<close>.\\<close>"], ["", "interpretation fresh_string: fresh where fresh = fresh_string"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.fresh fresh_string", "by standard (use fresh_string_set in auto)"], ["", "subsection \\<open>Lifting to string literals\\<close>"], ["", "abbreviation \"is_ascii str \\<equiv> (\\<forall>c \\<in> set str. \\<not>digit7 c)\""], ["", "lemma map_ascii_of_idem:\n  \"is_ascii str \\<Longrightarrow> map String.ascii_of str = str\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ascii str \\<Longrightarrow> map String.ascii_of str = str", "by (induction str) (auto simp: String.ascii_of_idem)"], ["", "lemma is_ascii_butlast:\n  \"is_ascii str \\<Longrightarrow> is_ascii (butlast str)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ascii str \\<Longrightarrow> is_ascii (butlast str)", "by (auto dest: in_set_butlastD)"], ["", "lemma ascii_char_of:\n  fixes c :: nat\n  assumes \"c < 128\"\n  shows \"\\<not>digit7 (char_of c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> digit7 (char_of c)", "using assms"], ["proof (prove)\nusing this:\n  c < 128\n\ngoal (1 subgoal):\n 1. \\<not> digit7 (char_of c)", "by (auto simp: char_of_def bit_iff_odd)"], ["", "lemmas ascii_of_char_of_idem = ascii_char_of[THEN String.ascii_of_idem]"], ["", "lemma is_ascii_upChar:\n  \"is_ascii str \\<Longrightarrow> is_ascii (upChar str)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ascii str \\<Longrightarrow> is_ascii (upChar str)", "by (auto simp: ascii_char_of is_ascii_butlast)"], ["", "lemma is_ascii_fresh_string:\n  \"is_ascii Y \\<Longrightarrow> is_ascii (fresh_string Xs Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ascii Y \\<Longrightarrow> is_ascii (fresh_string Xs Y)", "proof (induction Xs Y rule: fresh_string.induct[case_names Up Fresh])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        is_ascii (upChar Y) \\<Longrightarrow>\n        is_ascii (fresh_string (Xs - {Y}) (upChar Y));\n        is_ascii Y\\<rbrakk>\n       \\<Longrightarrow> is_ascii (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; is_ascii Y\\<rbrakk>\n       \\<Longrightarrow> is_ascii (fresh_string Xs Y)", "case (Up Y Xs)"], ["proof (state)\nthis:\n  Y \\<in> Xs\n  finite Xs\n  is_ascii (upChar Y) \\<Longrightarrow>\n  is_ascii (fresh_string (Xs - {Y}) (upChar Y))\n  is_ascii Y\n\ngoal (2 subgoals):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<in> Xs; finite Xs;\n        is_ascii (upChar Y) \\<Longrightarrow>\n        is_ascii (fresh_string (Xs - {Y}) (upChar Y));\n        is_ascii Y\\<rbrakk>\n       \\<Longrightarrow> is_ascii (fresh_string Xs Y)\n 2. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; is_ascii Y\\<rbrakk>\n       \\<Longrightarrow> is_ascii (fresh_string Xs Y)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_ascii (fresh_string Xs Y)", "using Up.IH[OF is_ascii_upChar[OF \\<open>is_ascii Y\\<close>]] Up.hyps"], ["proof (prove)\nusing this:\n  is_ascii (fresh_string (Xs - {Y}) (upChar Y))\n  Y \\<in> Xs\n  finite Xs\n\ngoal (1 subgoal):\n 1. is_ascii (fresh_string Xs Y)", "by auto"], ["proof (state)\nthis:\n  is_ascii (fresh_string Xs Y)\n\ngoal (1 subgoal):\n 1. \\<And>Y Xs.\n       \\<lbrakk>Y \\<notin> Xs \\<or> infinite Xs; is_ascii Y\\<rbrakk>\n       \\<Longrightarrow> is_ascii (fresh_string Xs Y)", "qed auto"], ["", "text \\<open>For string literals we can properly instantiate the class.\\<close>"], ["", "instantiation String.literal :: fresh\nbegin"], ["", "context\n  includes literal.lifting\nbegin"], ["", "lift_definition fresh_literal :: \"String.literal set \\<Rightarrow> String.literal \\<Rightarrow> String.literal\"\n  is fresh_string"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>seta list char.\n       \\<lbrakk>\\<And>cs c.\n                   \\<lbrakk>cs \\<in> seta; c \\<in> set cs\\<rbrakk>\n                   \\<Longrightarrow> \\<not> digit7 c;\n        \\<And>c. c \\<in> set list \\<Longrightarrow> \\<not> digit7 c;\n        char \\<in> set (fresh_string seta list)\\<rbrakk>\n       \\<Longrightarrow> \\<not> digit7 char", "using is_ascii_fresh_string"], ["proof (prove)\nusing this:\n  is_ascii ?Y \\<Longrightarrow> is_ascii (fresh_string ?Xs ?Y)\n\ngoal (1 subgoal):\n 1. \\<And>seta list char.\n       \\<lbrakk>\\<And>cs c.\n                   \\<lbrakk>cs \\<in> seta; c \\<in> set cs\\<rbrakk>\n                   \\<Longrightarrow> \\<not> digit7 c;\n        \\<And>c. c \\<in> set list \\<Longrightarrow> \\<not> digit7 c;\n        char \\<in> set (fresh_string seta list)\\<rbrakk>\n       \\<Longrightarrow> \\<not> digit7 char", "by blast"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(String.literal, fresh_class)", "by (standard; transfer) (use fresh_string_set in auto)"], ["", "end"], ["", "end"], ["", "text \\<open>Code generation:\\<close>"], ["", "context\n  includes literal.lifting\nbegin"], ["", "lift_definition upChar_literal :: \"String.literal \\<Rightarrow> String.literal\" is upChar"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>list char.\n       \\<lbrakk>\\<And>c. c \\<in> set list \\<Longrightarrow> \\<not> digit7 c;\n        char \\<in> set (upChar list)\\<rbrakk>\n       \\<Longrightarrow> \\<not> digit7 char", "using is_ascii_upChar"], ["proof (prove)\nusing this:\n  is_ascii ?str \\<Longrightarrow> is_ascii (upChar ?str)\n\ngoal (1 subgoal):\n 1. \\<And>list char.\n       \\<lbrakk>\\<And>c. c \\<in> set list \\<Longrightarrow> \\<not> digit7 c;\n        char \\<in> set (upChar list)\\<rbrakk>\n       \\<Longrightarrow> \\<not> digit7 char", "by blast"], ["", "lemma upChar_literal_upChar[code]:\n  \"upChar_literal s = String.implode (upChar (String.explode s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. upChar_literal s = String.implode (upChar (literal.explode s))", "by transfer (auto simp: map_ascii_of_idem is_ascii_butlast ascii_of_char_of_idem)"], ["", "lemma fresh_literal_if:\n  \"fresh xs y = (if y \\<in> xs \\<and> finite xs then fresh (xs - {y}) (upChar_literal y) else y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fresh xs y =\n    (if y \\<in> xs \\<and> finite xs then fresh (xs - {y}) (upChar_literal y)\n     else y)", "by transfer (intro fresh_string_if)"], ["", "lemmas fresh_literal_list[code] = fresh_literal_if[where xs = \"set xs\" for xs, simplified]"], ["", "end"], ["", "text \\<open>Some tests: \\<close>"], ["", "value \"[fresh {} (STR ''Abc''),\n        fresh {STR ''X'', STR ''Abc''} (STR ''Abd''),\n        fresh {STR ''X'', STR ''Y''} (STR  ''Y''),\n        fresh {STR ''X'', STR ''Yaa'', STR ''Ya'', STR ''Yaa''} (STR ''Ya''),\n        fresh {STR ''X'', STR ''Yaa'', STR ''Yz'', STR ''Yza''} (STR ''Yz''),\n        fresh {STR ''X'', STR ''Y'', STR ''Yab'', STR ''Y''} (STR ''Y'')]\""], ["", "end"]]}